y, function parseEnumValue_block(token) {\n\n            /* istanbul ignore else */\n            if (token === \"option\") {\n                parseOption(dummy, token); // skip\n                skip(\";\");\n            } else\n                throw illegal(token);\n\n        }, function parseEnumValue_line() {\n            parseInlineOptions(dummy); // skip\n        });\n        parent.add(token, value, dummy.comment, dummy.options);\n    }\n\n    function parseOption(parent, token) {\n        var isCustom = skip(\"(\", true);\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(token = next()))\n            throw illegal(token, \"name\");\n\n        var name = token;\n        var option = name;\n        var propName;\n\n        if (isCustom) {\n            skip(\")\");\n            name = \"(\" + name + \")\";\n            option = name;\n            token = peek();\n            if (fqTypeRefRe.test(token)) {\n                propName = token.slice(1); //remove '.' before property name\n                name += token;\n                next();\n            }\n        }\n        skip(\"=\");\n        var optionValue = parseOptionValue(parent, name);\n        setParsedOption(parent, option, optionValue, propName);\n    }\n\n    function parseOptionValue(parent, name) {\n        // { a: \"foo\" b { c: \"bar\" } }\n        if (skip(\"{\", true)) {\n            var objectResult = {};\n\n            while (!skip(\"}\", true)) {\n                /* istanbul ignore if */\n                if (!nameRe.test(token = next())) {\n                    throw illegal(token, \"name\");\n                }\n                if (token === null) {\n                  throw illegal(token, \"end of input\");\n                }\n\n                var value;\n                var propName = token;\n\n                skip(\":\", true);\n\n                if (peek() === \"{\")\n                    value = parseOptionValue(parent, name + \".\" + token);\n                else if (peek() === \"[\") {\n                    // option (my_option) = {\n                    //     repeated_value: [ \"foo\", \"bar\" ]\n                    // };\n                    value = [];\n                    var lastValue;\n                    if (skip(\"[\", true)) {\n                        do {\n                            lastValue = readValue(true);\n                            value.push(lastValue);\n                        } while (skip(\",\", true));\n                        skip(\"]\");\n                        if (typeof lastValue !== \"undefined\") {\n                            setOption(parent, name + \".\" + token, lastValue);\n                        }\n                    }\n                } else {\n                    value = readValue(true);\n                    setOption(parent, name + \".\" + token, value);\n                }\n\n                var prevValue = objectResult[propName];\n\n                if (prevValue)\n                    value = [].concat(prevValue).concat(value);\n\n                objectResult[propName] = value;\n\n                // Semicolons and commas can be optional\n                skip(\",\", true);\n                skip(\";\", true);\n            }\n\n            return objectResult;\n        }\n\n        var simpleValue = readValue(true);\n        setOption(parent, name, simpleValue);\n        return simpleValue;\n        // Does not enforce a delimiter to be universal\n    }\n\n    function setOption(parent, name, value) {\n        if (parent.setOption)\n            parent.setOption(name, value);\n    }\n\n    function setParsedOption(parent, name, value, propName) {\n        if (parent.setParsedOption)\n            parent.setParsedOption(name, value, propName);\n    }\n\n    function parseInlineOptions(parent) {\n        if (skip(\"[\", true)) {\n            do {\n                parseOption(parent, \"option\");\n            } while (skip(\",\", true));\n            skip(\"]\");\n        }\n        return parent;\n    }\n\n    function parseService(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"service name\");\n\n        var service = new Service(token);\n        ifBlock(service, function parseService_block(token) {\n            if (parseCommon(service, token))\n                return;\n\n            /* istanbul ignore else */\n            if (token === \"rpc\")\n                parseMethod(service, token);\n            else\n                throw illegal(token);\n        });\n        parent.add(service);\n    }\n\n    function parseMethod(parent, token) {\n        // Get the comment of the preceding line now (if one exists) in case the\n        // method is defined across multiple lines.\n        var commentText = cmnt();\n\n        var type = token;\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"name\");\n\n        var name = token,\n            requestType, requestStream,\n            responseType, responseStream;\n\n        skip(\"(\");\n        if (skip(\"stream\", true))\n            requestStream = true;\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(token = next()))\n            throw illegal(token);\n\n        requestType = token;\n        skip(\")\"); skip(\"returns\"); skip(\"(\");\n        if (skip(\"stream\", true))\n            responseStream = true;\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(token = next()))\n            throw illegal(token);\n\n        responseType = token;\n        skip(\")\");\n\n        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);\n        method.comment = commentText;\n        ifBlock(method, function parseMethod_block(token) {\n\n            /* istanbul ignore else */\n            if (token === \"option\") {\n                parseOption(method, token);\n                skip(\";\");\n            } else\n                throw illegal(token);\n\n        });\n        parent.add(method);\n    }\n\n    function parseExtension(parent, token) {\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(token = next()))\n            throw illegal(token, \"reference\");\n\n        var reference = token;\n        ifBlock(null, function parseExtension_block(token) {\n            switch (token) {\n\n                case \"required\":\n                case \"repeated\":\n                    parseField(parent, token, reference);\n                    break;\n\n                case \"optional\":\n                    /* istanbul ignore if */\n                    if (isProto3) {\n                        parseField(parent, \"proto3_optional\", reference);\n                    } else {\n                        parseField(parent, \"optional\", reference);\n                    }\n                    break;\n\n                default:\n                    /* istanbul ignore if */\n                    if (!isProto3 || !typeRefRe.test(token))\n                        throw illegal(token);\n                    push(token);\n                    parseField(parent, \"optional\", reference);\n                    break;\n            }\n        });\n    }\n\n    var token;\n    while ((token = next()) !== null) {\n        switch (token) {\n\n            case \"package\":\n\n                /* istanbul ignore if */\n                if (!head)\n                    throw illegal(token);\n\n                parsePackage();\n                break;\n\n            case \"import\":\n\n                /* istanbul ignore if */\n                if (!head)\n                    throw illegal(token);\n\n                parseImport();\n                break;\n\n            case \"syntax\":\n\n                /* istanbul ignore if */\n                if (!head)\n                    throw illegal(token);\n\n                parseSyntax();\n                break;\n\n            case \"option\":\n\n                parseOption(ptr, token);\n                skip(\";\");\n                break;\n\n            default:\n\n                /* istanbul ignore else */\n                if (parseCommon(ptr, token)) {\n                    head = false;\n                    continue;\n                }\n\n                /* istanbul ignore next */\n                throw illegal(token);\n        }\n    }\n\n    parse.filename = null;\n    return {\n        \"package\"     : pkg,\n        \"imports\"     : imports,\n         weakImports  : weakImports,\n         syntax       : syntax,\n         root         : root\n    };\n}\n\n/**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @name parse\n * @function\n * @param {string} source Source contents\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n * @variation 2\n */\n","\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(39);\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n\n    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer\n            ? nativeBuffer.alloc(0)\n            : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n","\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(27);\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(39);\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n","\"use strict\";\nmodule.exports = Root;\n\n// extends Namespace\nvar Namespace = require(23);\n((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = \"Root\";\n\nvar Field   = require(16),\n    Enum    = require(15),\n    OneOf   = require(25),\n    util    = require(37);\n\nvar Type,   // cyclic\n    parse,  // might be excluded\n    common; // \"\n\n/**\n * Constructs a new root namespace instance.\n * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.\n * @extends NamespaceBase\n * @constructor\n * @param {Object.<string,*>} [options] Top level options\n */\nfunction Root(options) {\n    Namespace.call(this, \"\", options);\n\n    /**\n     * Deferred extension fields.\n     * @type {Field[]}\n     */\n    this.deferred = [];\n\n    /**\n     * Resolved file names of loaded files.\n     * @type {string[]}\n     */\n    this.files = [];\n}\n\n/**\n * Loads a namespace descriptor into a root namespace.\n * @param {INamespace} json Nameespace descriptor\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted\n * @returns {Root} Root namespace\n */\nRoot.fromJSON = function fromJSON(json, root) {\n    if (!root)\n        root = new Root();\n    if (json.options)\n        root.setOptions(json.options);\n    return root.addJSON(json.nested);\n};\n\n/**\n * Resolves the path of an imported file, relative to the importing origin.\n * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.\n * @function\n * @param {string} origin The file name of the importing file\n * @param {string} target The file name being imported\n * @returns {string|null} Resolved path to `target` or `null` to skip the file\n */\nRoot.prototype.resolvePath = util.path.resolve;\n\n/**\n * Fetch content from file path or url\n * This method exists so you can override it with your own logic.\n * @function\n * @param {string} path File path or url\n * @param {FetchCallback} callback Callback function\n * @returns {undefined}\n */\nRoot.prototype.fetch = util.fetch;\n\n// A symbol-like function to safely signal synchronous loading\n/* istanbul ignore next */\nfunction SYNC() {} // eslint-disable-line no-empty-function\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} options Parse options\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n */\nRoot.prototype.load = function load(filename, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    var self = this;\n    if (!callback)\n        return util.asPromise(load, self, filename, options);\n\n    var sync = callback === SYNC; // undocumented\n\n    // Finishes loading by calling the callback (exactly once)\n    function finish(err, root) {\n        /* istanbul ignore if */\n        if (!callback)\n            return;\n        if (sync)\n            throw err;\n        var cb = callback;\n        callback = null;\n        cb(err, root);\n    }\n\n    // Bundled definition existence checking\n    function getBundledFileName(filename) {\n        var idx = filename.lastIndexOf(\"google/protobuf/\");\n        if (idx > -1) {\n            var altname = filename.substring(idx);\n            if (altname in common) return altname;\n        }\n        return null;\n    }\n\n    // Processes a single file\n    function process(filename, source) {\n        try {\n            if (util.isString(source) && source.charAt(0) === \"{\")\n                source = JSON.parse(source);\n            if (!util.isString(source))\n                self.setOptions(source.options).addJSON(source.nested);\n            else {\n                parse.filename = filename;\n                var parsed = parse(source, self, options),\n                    resolved,\n                    i = 0;\n                if (parsed.imports)\n                    for (; i < parsed.imports.length; ++i)\n                        if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i]))\n                            fetch(resolved);\n                if (parsed.weakImports)\n                    for (i = 0; i < parsed.weakImports.length; ++i)\n                        if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i]))\n                            fetch(resolved, true);\n            }\n        } catch (err) {\n            finish(err);\n        }\n        if (!sync && !queued)\n            finish(null, self); // only once anyway\n    }\n\n    // Fetches a single file\n    function fetch(filename, weak) {\n        filename = getBundledFileName(filename) || filename;\n\n        // Skip if already loaded / attempted\n        if (self.files.indexOf(filename) > -1)\n            return;\n        self.files.push(filename);\n\n        // Shortcut bundled definitions\n        if (filename in common) {\n            if (sync)\n                process(filename, common[filename]);\n            else {\n                ++queued;\n                setTimeout(function() {\n                    --queued;\n                    process(filename, common[filename]);\n                });\n            }\n            return;\n        }\n\n        // Otherwise fetch from disk or network\n        if (sync) {\n            var source;\n            try {\n                source = util.fs.readFileSync(filename).toString(\"utf8\");\n            } catch (err) {\n                if (!weak)\n                    finish(err);\n                return;\n            }\n            process(filename, source);\n        } else {\n            ++queued;\n            self.fetch(filename, function(err, source) {\n                --queued;\n                /* istanbul ignore if */\n                if (!callback)\n                    return; // terminated meanwhile\n                if (err) {\n                    /* istanbul ignore else */\n                    if (!weak)\n                        finish(err);\n                    else if (!queued) // can't be covered reliably\n                        finish(null, self);\n                    return;\n                }\n                process(filename, source);\n            });\n        }\n    }\n    var queued = 0;\n\n    // Assembling the root namespace doesn't require working type\n    // references anymore, so we can load everything in parallel\n    if (util.isString(filename))\n        filename = [ filename ];\n    for (var i = 0, resolved; i < filename.length; ++i)\n        if (resolved = self.resolvePath(\"\", filename[i]))\n            fetch(resolved);\n\n    if (sync)\n        return self;\n    if (!queued)\n        finish(null, self);\n    return undefined;\n};\n// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.\n * @function Root#load\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @variation 2\n */\n// function load(filename:string, callback:LoadCallback):undefined\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.\n * @function Root#load\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {Promise<Root>} Promise\n * @variation 3\n */\n// function load(filename:string, [options:IParseOptions]):Promise<Root>\n\n/**\n * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).\n * @function Root#loadSync\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {Root} Root namespace\n * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid\n */\nRoot.prototype.loadSync = function loadSync(filename, options) {\n    if (!util.isNode)\n        throw Error(\"not supported\");\n    return this.load(filename, options, SYNC);\n};\n\n/**\n * @override\n */\nRoot.prototype.resolveAll = function resolveAll() {\n    if (this.deferred.length)\n        throw Error(\"unresolvable extensions: \" + this.deferred.map(function(field) {\n            return \"'extend \" + field.extend + \"' in \" + field.parent.fullName;\n        }).join(\", \"));\n    return Namespace.prototype.resolveAll.call(this);\n};\n\n// only uppercased (and thus conflict-free) children are exposed, see below\nvar exposeRe = /^[A-Z]/;\n\n/**\n * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.\n * @param {Root} root Root instance\n * @param {Field} field Declaring extension field witin the declaring type\n * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise\n * @inner\n * @ignore\n */\nfunction tryHandleExtension(root, field) {\n    var extendedType = field.parent.lookup(field.extend);\n    if (extendedType) {\n        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);\n        //do not allow to extend same field twice to prevent the error\n        if (extendedType.get(sisterField.name)) {\n            return true;\n        }\n        sisterField.declaringField = field;\n        field.extensionField = sisterField;\n        extendedType.add(sisterField);\n        return true;\n    }\n    return false;\n}\n\n/**\n * Called when any object is added to this root or its sub-namespaces.\n * @param {ReflectionObject} object Object added\n * @returns {undefined}\n * @private\n */\nRoot.prototype._handleAdd = function _handleAdd(object) {\n    if (object instanceof Field) {\n\n        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)\n            if (!tryHandleExtension(this, object))\n                this.deferred.push(object);\n\n    } else if (object instanceof Enum) {\n\n        if (exposeRe.test(object.name))\n            object.parent[object.name] = object.values; // expose enum values as property of its parent\n\n    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {\n\n        if (object instanceof Type) // Try to handle any deferred extensions\n            for (var i = 0; i < this.deferred.length;)\n                if (tryHandleExtension(this, this.deferred[i]))\n                    this.deferred.splice(i, 1);\n                else\n                    ++i;\n        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace\n            this._handleAdd(object._nestedArray[j]);\n        if (exposeRe.test(object.name))\n            object.parent[object.name] = object; // expose namespace as property of its parent\n    }\n\n    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as\n    // properties of namespaces just like static code does. This allows using a .d.ts generated for\n    // a static module with reflection-based solutions where the condition is met.\n};\n\n/**\n * Called when any object is removed from this root or its sub-namespaces.\n * @param {ReflectionObject} object Object removed\n * @returns {undefined}\n * @private\n */\nRoot.prototype._handleRemove = function _handleRemove(object) {\n    if (object instanceof Field) {\n\n        if (/* an extension field */ object.extend !== undefined) {\n            if (/* already handled */ object.extensionField) { // remove its sister field\n                object.extensionField.parent.remove(object.extensionField);\n                object.extensionField = null;\n            } else { // cancel the extension\n                var index = this.deferred.indexOf(object);\n                /* istanbul ignore else */\n                if (index > -1)\n                    this.deferred.splice(index, 1);\n            }\n        }\n\n    } else if (object instanceof Enum) {\n\n        if (exposeRe.test(object.name))\n            delete object.parent[object.name]; // unexpose enum values\n\n    } else if (object instanceof Namespace) {\n\n        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace\n            this._handleRemove(object._nestedArray[i]);\n\n        if (exposeRe.test(object.name))\n            delete object.parent[object.name]; // unexpose namespaces\n\n    }\n};\n\n// Sets up cyclic dependencies (called in index-light)\nRoot._configure = function(Type_, parse_, common_) {\n    Type   = Type_;\n    parse  = parse_;\n    common = common_;\n};\n","\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n","\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(32);\n","\"use strict\";\nmodule.exports = Service;\n\nvar util = require(39);\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n","\"use strict\";\nmodule.exports = Service;\n\n// extends Namespace\nvar Namespace = require(23);\n((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = \"Service\";\n\nvar Method = require(22),\n    util   = require(37),\n    rpc    = require(31);\n\n/**\n * Constructs a new service instance.\n * @classdesc Reflected service.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Service name\n * @param {Object.<string,*>} [options] Service options\n * @throws {TypeError} If arguments are invalid\n */\nfunction Service(name, options) {\n    Namespace.call(this, name, options);\n\n    /**\n     * Service methods.\n     * @type {Object.<string,Method>}\n     */\n    this.methods = {}; // toJSON, marker\n\n    /**\n     * Cached methods as an array.\n     * @type {Method[]|null}\n     * @private\n     */\n    this._methodsArray = null;\n}\n\n/**\n * Service descriptor.\n * @interface IService\n * @extends INamespace\n * @property {Object.<string,IMethod>} methods Method descriptors\n */\n\n/**\n * Constructs a service from a service descriptor.\n * @param {string} name Service name\n * @param {IService} json Service descriptor\n * @returns {Service} Created service\n * @throws {TypeError} If arguments are invalid\n */\nService.fromJSON = function fromJSON(name, json) {\n    var service = new Service(name, json.options);\n    /* istanbul ignore else */\n    if (json.methods)\n        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)\n            service.add(Method.fromJSON(names[i], json.methods[names[i]]));\n    if (json.nested)\n        service.addJSON(json.nested);\n    service.comment = json.comment;\n    return service;\n};\n\n/**\n * Converts this service to a service descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IService} Service descriptor\n */\nService.prototype.toJSON = function toJSON(toJSONOptions) {\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\" , inherited && inherited.options || undefined,\n        \"methods\" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},\n        \"nested\"  , inherited && inherited.nested || undefined,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * Methods of this service as an array for iteration.\n * @name Service#methodsArray\n * @type {Method[]}\n * @readonly\n */\nObject.defineProperty(Service.prototype, \"methodsArray\", {\n    get: function() {\n        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));\n    }\n});\n\nfunction clearCache(service) {\n    service._methodsArray = null;\n    return service;\n}\n\n/**\n * @override\n */\nService.prototype.get = function get(name) {\n    return util.getProp(this.methods, name)\n        || Namespace.prototype.get.call(this, name);\n};\n\n/**\n * @override\n */\nService.prototype.resolveAll = function resolveAll() {\n    var methods = this.methodsArray;\n    for (var i = 0; i < methods.length; ++i)\n        methods[i].resolve();\n    return Namespace.prototype.resolve.call(this);\n};\n\n/**\n * @override\n */\nService.prototype.add = function add(object) {\n\n    /* istanbul ignore if */\n    if (this.get(object.name))\n        throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n\n    if (object instanceof Method) {\n        this.methods[object.name] = object;\n        object.parent = this;\n        return clearCache(this);\n    }\n    return Namespace.prototype.add.call(this, object);\n};\n\n/**\n * @override\n */\nService.prototype.remove = function remove(object) {\n    if (object instanceof Method) {\n\n        /* istanbul ignore if */\n        if (this.methods[object.name] !== object)\n            throw Error(object + \" is not a member of \" + this);\n\n        delete this.methods[object.name];\n        object.parent = null;\n        return clearCache(this);\n    }\n    return Namespace.prototype.remove.call(this, object);\n};\n\n/**\n * Creates a runtime service using the specified rpc implementation.\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.\n */\nService.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {\n    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);\n    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {\n        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\\w_]/g, \"\");\n        rpcService[methodName] = util.codegen([\"r\",\"c\"], util.isReserved(methodName) ? methodName + \"_\" : methodName)(\"return this.rpcCall(m,q,s,r,c)\")({\n            m: method,\n            q: method.resolvedRequestType.ctor,\n            s: method.resolvedResponseType.ctor\n        });\n    }\n    return rpcService;\n};\n","\"use strict\";\nmodule.exports = tokenize;\n\nvar delimRe        = /[\\s{}=;:[\\],'\"()<>]/g,\n    stringDoubleRe = /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")/g,\n    stringSingleRe = /(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g;\n\nvar setCommentRe = /^ *[*/]+ */,\n    setCommentAltRe = /^\\s*\\*?\\/*/,\n    setCommentSplitRe = /\\n/g,\n    whitespaceRe = /\\s/,\n    unescapeRe = /\\\\(.?)/g;\n\nvar unescapeMap = {\n    \"0\": \"\\0\",\n    \"r\": \"\\r\",\n    \"n\": \"\\n\",\n    \"t\": \"\\t\"\n};\n\n/**\n * Unescapes a string.\n * @param {string} str String to unescape\n * @returns {string} Unescaped string\n * @property {Object.<string,string>} map Special characters map\n * @memberof tokenize\n */\nfunction unescape(str) {\n    return str.replace(unescapeRe, function($0, $1) {\n        switch ($1) {\n            case \"\\\\\":\n            case \"\":\n                return $1;\n            default:\n                return unescapeMap[$1] || \"\";\n        }\n    });\n}\n\ntokenize.unescape = unescape;\n\n/**\n * Gets the next token and advances.\n * @typedef TokenizerHandleNext\n * @type {function}\n * @returns {string|null} Next token or `null` on eof\n */\n\n/**\n * Peeks for the next token.\n * @typedef TokenizerHandlePeek\n * @type {function}\n * @returns {string|null} Next token or `null` on eof\n */\n\n/**\n * Pushes a token back to the stack.\n * @typedef TokenizerHandlePush\n * @type {function}\n * @param {string} token Token\n * @returns {undefined}\n */\n\n/**\n * Skips the next token.\n * @typedef TokenizerHandleSkip\n * @type {function}\n * @param {string} expected Expected token\n * @param {boolean} [optional=false] If optional\n * @returns {boolean} Whether the token matched\n * @throws {Error} If the token didn't match and is not optional\n */\n\n/**\n * Gets the comment on the previous line or, alternatively, the line comment on the specified line.\n * @typedef TokenizerHandleCmnt\n * @type {function}\n * @param {number} [line] Line number\n * @returns {string|null} Comment text or `null` if none\n */\n\n/**\n * Handle object returned from {@link tokenize}.\n * @interface ITokenizerHandle\n * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)\n * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)\n * @property {TokenizerHandlePush} push Pushes a token back to the stack\n * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws\n * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any\n * @property {number} line Current line number\n */\n\n/**\n * Tokenizes the given .proto source and returns an object with useful utility functions.\n * @param {string} source Source contents\n * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.\n * @returns {ITokenizerHandle} Tokenizer handle\n */\nfunction tokenize(source, alternateCommentMode) {\n    /* eslint-disable callback-return */\n    source = source.toString();\n\n    var offset = 0,\n        length = source.length,\n        line = 1,\n        lastCommentLine = 0,\n        comments = {};\n\n    var stack = [];\n\n    var stringDelim = null;\n\n    /* istanbul ignore next */\n    /**\n     * Creates an error for illegal syntax.\n     * @param {string} subject Subject\n     * @returns {Error} Error created\n     * @inner\n     */\n    function illegal(subject) {\n        return Error(\"illegal \" + subject + \" (line \" + line + \")\");\n    }\n\n    /**\n     * Reads a string till its end.\n     * @returns {string} String read\n     * @inner\n     */\n    function readString() {\n        var re = stringDelim === \"'\" ? stringSingleRe : stringDoubleRe;\n        re.lastIndex = offset - 1;\n        var match = re.exec(source);\n        if (!match)\n            throw illegal(\"string\");\n        offset = re.lastIndex;\n        push(stringDelim);\n        stringDelim = null;\n        return unescape(match[1]);\n    }\n\n    /**\n     * Gets the character at `pos` within the source.\n     * @param {number} pos Position\n     * @returns {string} Character\n     * @inner\n     */\n    function charAt(pos) {\n        return source.charAt(pos);\n    }\n\n    /**\n     * Sets the current comment text.\n     * @param {number} start Start offset\n     * @param {number} end End offset\n     * @param {boolean} isLeading set if a leading comment\n     * @returns {undefined}\n     * @inner\n     */\n    function setComment(start, end, isLeading) {\n        var comment = {\n            type: source.charAt(start++),\n            lineEmpty: false,\n            leading: isLeading,\n        };\n        var lookback;\n        if (alternateCommentMode) {\n            lookback = 2;  // alternate comment parsing: \"//\" or \"/*\"\n        } else {\n            lookback = 3;  // \"///\" or \"/**\"\n        }\n        var commentOffset = start - lookback,\n            c;\n        do {\n            if (--commentOffset < 0 ||\n                    (c = source.charAt(commentOffset)) === \"\\n\") {\n                comment.lineEmpty = true;\n                break;\n            }\n        } while (c === \" \" || c === \"\\t\");\n        var lines = source\n            .substring(start, end)\n            .split(setCommentSplitRe);\n        for (var i = 0; i < lines.length; ++i)\n            lines[i] = lines[i]\n                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, \"\")\n                .trim();\n        comment.text = lines\n            .join(\"\\n\")\n            .trim();\n\n        comments[line] = comment;\n        lastCommentLine = line;\n    }\n\n    function isDoubleSlashCommentLine(startOffset) {\n        var endOffset = findEndOfLine(startOffset);\n\n        // see if remaining line matches comment pattern\n        var lineText = source.substring(startOffset, endOffset);\n        var isComment = /^\\s*\\/\\//.test(lineText);\n        return isComment;\n    }\n\n    function findEndOfLine(cursor) {\n        // find end of cursor's line\n        var endOffset = cursor;\n        while (endOffset < length && charAt(endOffset) !== \"\\n\") {\n            endOffset++;\n        }\n        return endOffset;\n    }\n\n    /**\n     * Obtains the next token.\n     * @returns {string|null} Next token or `null` on eof\n     * @inner\n     */\n    function next() {\n        if (stack.length > 0)\n            return stack.shift();\n        if (stringDelim)\n            return readString();\n        var repeat,\n            prev,\n            curr,\n            start,\n            isDoc,\n            isLeadingComment = offset === 0;\n        do {\n            if (offset === length)\n                return null;\n            repeat = false;\n            while (whitespaceRe.test(curr = charAt(offset))) {\n                if (curr === \"\\n\") {\n                    isLeadingComment = true;\n                    ++line;\n                }\n                if (++offset === length)\n                    return null;\n            }\n\n            if (charAt(offset) === \"/\") {\n                if (++offset === length) {\n                    throw illegal(\"comment\");\n                }\n                if (charAt(offset) === \"/\") { // Line\n                    if (!alternateCommentMode) {\n                        // check for triple-slash comment\n                        isDoc = charAt(start = offset + 1) === \"/\";\n\n                        while (charAt(++offset) !== \"\\n\") {\n                            if (offset === length) {\n                                return null;\n                            }\n                        }\n                        ++offset;\n                        if (isDoc) {\n                            setComment(start, offset - 1, isLeadingComment);\n                            // Trailing comment cannot not be multi-line,\n                            // so leading comment state should be reset to handle potential next comments\n                            isLeadingComment = true;\n                        }\n                        ++line;\n                        repeat = true;\n                    } else {\n                        // check for double-slash comments, consolidating consecutive lines\n                        start = offset;\n                        isDoc = false;\n                        if (isDoubleSlashCommentLine(offset - 1)) {\n                            isDoc = true;\n                            do {\n                                offset = findEndOfLine(offset);\n                                if (offset === length) {\n                                    break;\n                                }\n                                offset++;\n                                if (!isLeadingComment) {\n                                    // Trailing comment cannot not be multi-line\n                                    break;\n                                }\n                            } while (isDoubleSlashCommentLine(offset));\n                        } else {\n                            offset = Math.min(length, findEndOfLine(offset) + 1);\n                        }\n                        if (isDoc) {\n                            setComment(start, offset, isLeadingComment);\n                            isLeadingComment = true;\n                        }\n                        line++;\n                        repeat = true;\n                    }\n                } else if ((curr = charAt(offset)) === \"*\") { /* Block */\n                    // check for /** (regular comment mode) or /* (alternate comment mode)\n                    start = offset + 1;\n                    isDoc = alternateCommentMode || charAt(start) === \"*\";\n                    do {\n                        if (curr === \"\\n\") {\n                            ++line;\n                        }\n                        if (++offset === length) {\n                            throw illegal(\"comment\");\n                        }\n                        prev = curr;\n                        curr = charAt(offset);\n                    } while (prev !== \"*\" || curr !== \"/\");\n                    ++offset;\n                    if (isDoc) {\n                        setComment(start, offset - 2, isLeadingComment);\n                        isLeadingComment = true;\n                    }\n                    repeat = true;\n                } else {\n                    return \"/\";\n                }\n            }\n        } while (repeat);\n\n        // offset !== length if we got here\n\n        var end = offset;\n        delimRe.lastIndex = 0;\n        var delim = delimRe.test(charAt(end++));\n        if (!delim)\n            while (end < length && !delimRe.test(charAt(end)))\n                ++end;\n        var token = source.substring(offset, offset = end);\n        if (token === \"\\\"\" || token === \"'\")\n            stringDelim = token;\n        return token;\n    }\n\n    /**\n     * Pushes a token back to the stack.\n     * @param {string} token Token\n     * @returns {undefined}\n     * @inner\n     */\n    function push(token) {\n        stack.push(token);\n    }\n\n    /**\n     * Peeks for the next token.\n     * @returns {string|null} Token or `null` on eof\n     * @inner\n     */\n    function peek() {\n        if (!stack.length) {\n            var token = next();\n            if (token === null)\n                return null;\n            push(token);\n        }\n        return stack[0];\n    }\n\n    /**\n     * Skips a token.\n     * @param {string} expected Expected token\n     * @param {boolean} [optional=false] Whether the token is optional\n     * @returns {boolean} `true` when skipped, `false` if not\n     * @throws {Error} When a required token is not present\n     * @inner\n     */\n    function skip(expected, optional) {\n        var actual = peek(),\n            equals = actual === expected;\n        if (equals) {\n            next();\n            return true;\n        }\n        if (!optional)\n            throw illegal(\"token '\" + actual + \"', '\" + expected + \"' expected\");\n        return false;\n    }\n\n    /**\n     * Gets a comment.\n     * @param {number} [trailingLine] Line number if looking for a trailing comment\n     * @returns {string|null} Comment text\n     * @inner\n     */\n    function cmnt(trailingLine) {\n        var ret = null;\n        var comment;\n        if (trailingLine === undefined) {\n            comment = comments[line - 1];\n            delete comments[line - 1];\n            if (comment && (alternateCommentMode || comment.type === \"*\" || comment.lineEmpty)) {\n                ret = comment.leading ? comment.text : null;\n            }\n        } else {\n            /* istanbul ignore else */\n            if (lastCommentLine < trailingLine) {\n                peek();\n            }\n            comment = comments[trailingLine];\n            delete comments[trailingLine];\n            if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === \"/\")) {\n                ret = comment.leading ? null : comment.text;\n            }\n        }\n        return ret;\n    }\n\n    return Object.defineProperty({\n        next: next,\n        peek: peek,\n        push: push,\n        skip: skip,\n        cmnt: cmnt\n    }, \"line\", {\n        get: function() { return line; }\n    });\n    /* eslint-enable callback-return */\n}\n","\"use strict\";\nmodule.exports = Type;\n\n// extends Namespace\nvar Namespace = require(23);\n((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = \"Type\";\n\nvar Enum      = require(15),\n    OneOf     = require(25),\n    Field     = require(16),\n    MapField  = require(20),\n    Service   = require(33),\n    Message   = require(21),\n    Reader    = require(27),\n    Writer    = require(42),\n    util      = require(37),\n    encoder   = require(14),\n    decoder   = require(13),\n    verifier  = require(40),\n    converter = require(12),\n    wrappers  = require(41);\n\n/**\n * Constructs a new reflected message type instance.\n * @classdesc Reflected message type.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Message name\n * @param {Object.<string,*>} [options] Declared options\n */\nfunction Type(name, options) {\n    Namespace.call(this, name, options);\n\n    /**\n     * Message fields.\n     * @type {Object.<string,Field>}\n     */\n    this.fields = {};  // toJSON, marker\n\n    /**\n     * Oneofs declared within this namespace, if any.\n     * @type {Object.<string,OneOf>}\n     */\n    this.oneofs = undefined; // toJSON\n\n    /**\n     * Extension ranges, if any.\n     * @type {number[][]}\n     */\n    this.extensions = undefined; // toJSON\n\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */\n    this.reserved = undefined; // toJSON\n\n    /*?\n     * Whether this type is a legacy group.\n     * @type {boolean|undefined}\n     */\n    this.group = undefined; // toJSON\n\n    /**\n     * Cached fields by id.\n     * @type {Object.<number,Field>|null}\n     * @private\n     */\n    this._fieldsById = null;\n\n    /**\n     * Cached fields as an array.\n     * @type {Field[]|null}\n     * @private\n     */\n    this._fieldsArray = null;\n\n    /**\n     * Cached oneofs as an array.\n     * @type {OneOf[]|null}\n     * @private\n     */\n    this._oneofsArray = null;\n\n    /**\n     * Cached constructor.\n     * @type {Constructor<{}>}\n     * @private\n     */\n    this._ctor = null;\n}\n\nObject.defineProperties(Type.prototype, {\n\n    /**\n     * Message fields by id.\n     * @name Type#fieldsById\n     * @type {Object.<number,Field>}\n     * @readonly\n     */\n    fieldsById: {\n        get: function() {\n\n            /* istanbul ignore if */\n            if (this._fieldsById)\n                return this._fieldsById;\n\n            this._fieldsById = {};\n            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {\n                var field = this.fields[names[i]],\n                    id = field.id;\n\n                /* istanbul ignore if */\n                if (this._fieldsById[id])\n                    throw Error(\"duplicate id \" + id + \" in \" + this);\n\n                this._fieldsById[id] = field;\n            }\n            return this._fieldsById;\n        }\n    },\n\n    /**\n     * Fields of this message as an array for iteration.\n     * @name Type#fieldsArray\n     * @type {Field[]}\n     * @readonly\n     */\n    fieldsArray: {\n        get: function() {\n            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));\n        }\n    },\n\n    /**\n     * Oneofs of this message as an array for iteration.\n     * @name Type#oneofsArray\n     * @type {OneOf[]}\n     * @readonly\n     */\n    oneofsArray: {\n        get: function() {\n            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));\n        }\n    },\n\n    /**\n     * The registered constructor, if any registered, otherwise a generic constructor.\n     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.\n     * @name Type#ctor\n     * @type {Constructor<{}>}\n     */\n    ctor: {\n        get: function() {\n            return this._ctor || (this.ctor = Type.generateConstructor(this)());\n        },\n        set: function(ctor) {\n\n            // Ensure proper prototype\n            var prototype = ctor.prototype;\n            if (!(prototype instanceof Message)) {\n                (ctor.prototype = new Message()).constructor = ctor;\n                util.merge(ctor.prototype, prototype);\n            }\n\n            // Classes and messages reference their reflected type\n            ctor.$type = ctor.prototype.$type = this;\n\n            // Mix in static methods\n            util.merge(ctor, Message, true);\n\n            this._ctor = ctor;\n\n            // Messages have non-enumerable default values on their prototype\n            var i = 0;\n            for (; i < /* initializes */ this.fieldsArray.length; ++i)\n                this._fieldsArray[i].resolve(); // ensures a proper value\n\n            // Messages have non-enumerable getters and setters for each virtual oneof field\n            var ctorProperties = {};\n            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)\n                ctorProperties[this._oneofsArray[i].resolve().name] = {\n                    get: util.oneOfGetter(this._oneofsArray[i].oneof),\n                    set: util.oneOfSetter(this._oneofsArray[i].oneof)\n                };\n            if (i)\n                Object.defineProperties(ctor.prototype, ctorProperties);\n        }\n    }\n});\n\n/**\n * Generates a constructor function for the specified type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nType.generateConstructor = function generateConstructor(mtype) {\n    /* eslint-disable no-unexpected-multiline */\n    var gen = util.codegen([\"p\"], mtype.name);\n    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype\n    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)\n        if ((field = mtype._fieldsArray[i]).map) gen\n            (\"this%s={}\", util.safeProp(field.name));\n        else if (field.repeated) gen\n            (\"this%s=[]\", util.safeProp(field.name));\n    return gen\n    (\"if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)\") // omit undefined or null\n        (\"this[ks[i]]=p[ks[i]]\");\n    /* eslint-enable no-unexpected-multiline */\n};\n\nfunction clearCache(type) {\n    type._fieldsById = type._fieldsArray = type._oneofsArray = null;\n    delete type.encode;\n    delete type.decode;\n    delete type.verify;\n    return type;\n}\n\n/**\n * Message type descriptor.\n * @interface IType\n * @extends INamespace\n * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors\n * @property {Object.<string,IField>} fields Field descriptors\n * @property {number[][]} [extensions] Extension ranges\n * @property {Array.<number[]|string>} [reserved] Reserved ranges\n * @property {boolean} [group=false] Whether a legacy group or not\n */\n\n/**\n * Creates a message type from a message type descriptor.\n * @param {string} name Message name\n * @param {IType} json Message type descriptor\n * @returns {Type} Created message type\n */\nType.fromJSON = function fromJSON(name, json) {\n    var type = new Type(name, json.options);\n    type.extensions = json.extensions;\n    type.reserved = json.reserved;\n    var names = Object.keys(json.fields),\n        i = 0;\n    for (; i < names.length; ++i)\n        type.add(\n            ( typeof json.fields[names[i]].keyType !== \"undefined\"\n            ? MapField.fromJSON\n            : Field.fromJSON )(names[i], json.fields[names[i]])\n        );\n    if (json.oneofs)\n        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)\n            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));\n    if (json.nested)\n        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {\n            var nested = json.nested[names[i]];\n            type.add( // most to least likely\n                ( nested.id !== undefined\n                ? Field.fromJSON\n                : nested.fields !== undefined\n                ? Type.fromJSON\n                : nested.values !== undefined\n                ? Enum.fromJSON\n                : nested.methods !== undefined\n                ? Service.fromJSON\n                : Namespace.fromJSON )(names[i], nested)\n            );\n        }\n    if (json.extensions && json.extensions.length)\n        type.extensions = json.extensions;\n    if (json.reserved && json.reserved.length)\n        type.reserved = json.reserved;\n    if (json.group)\n        type.group = true;\n    if (json.comment)\n        type.comment = json.comment;\n    return type;\n};\n\n/**\n * Converts this message type to a message type descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IType} Message type descriptor\n */\nType.prototype.toJSON = function toJSON(toJSONOptions) {\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\"    , inherited && inherited.options || undefined,\n        \"oneofs\"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),\n        \"fields\"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},\n        \"extensions\" , this.extensions && this.extensions.length ? this.extensions : undefined,\n        \"reserved\"   , this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"group\"      , this.group || undefined,\n        \"nested\"     , inherited && inherited.nested || undefined,\n        \"comment\"    , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * @override\n */\nType.prototype.resolveAll = function resolveAll() {\n    var fields = this.fieldsArray, i = 0;\n    while (i < fields.length)\n        fields[i++].resolve();\n    var oneofs = this.oneofsArray; i = 0;\n    while (i < oneofs.length)\n        oneofs[i++].resolve();\n    return Namespace.prototype.resolveAll.call(this);\n};\n\n/**\n * @override\n */\nType.prototype.get = function get(name) {\n    return util.getProp(this.fields, name)\n        || util.getProp(this.oneofs, name)\n        || util.getProp(this.nested, name)\n        || null;\n};\n\n/**\n * Adds a nested object to this type.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Type} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id\n */\nType.prototype.add = function add(object) {\n\n    if (this.get(object.name))\n        throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n\n    if (object instanceof Field && object.extend === undefined) {\n        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.\n        // The root object takes care of adding distinct sister-fields to the respective extended\n        // type instead.\n\n        // avoids calling the getter if not absolutely necessary because it's called quite frequently\n        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])\n            throw Error(\"duplicate id \" + object.id + \" in \" + this);\n        if (this.isReservedId(object.id))\n            throw Error(\"id \" + object.id + \" is reserved in \" + this);\n        if (this.isReservedName(object.name))\n            throw Error(\"name '\" + object.name + \"' is reserved in \" + this);\n\n        if (object.parent)\n            object.parent.remove(object);\n        this.fields[object.name] = object;\n        object.message = this;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n        if (!this.oneofs)\n            this.oneofs = {};\n        this.oneofs[object.name] = object;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.add.call(this, object);\n};\n\n/**\n * Removes a nested object from this type.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Type} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this type\n */\nType.prototype.remove = function remove(object) {\n    if (object instanceof Field && object.extend === undefined) {\n        // See Type#add for the reason why extension fields are excluded here.\n\n        /* istanbul ignore if */\n        if (!this.fields || this.fields[object.name] !== object)\n            throw Error(object + \" is not a member of \" + this);\n\n        delete this.fields[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n\n        /* istanbul ignore if */\n        if (!this.oneofs || this.oneofs[object.name] !== object)\n            throw Error(object + \" is not a member of \" + this);\n\n        delete this.oneofs[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.remove.call(this, object);\n};\n\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nType.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nType.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n\n/**\n * Creates a new message of this type using the specified properties.\n * @param {Object.<string,*>} [properties] Properties to set\n * @returns {Message<{}>} Message instance\n */\nType.prototype.create = function create(properties) {\n    return new this.ctor(properties);\n};\n\n/**\n * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.\n * @returns {Type} `this`\n */\nType.prototype.setup = function setup() {\n    // Sets up everything at once so that the prototype chain does not have to be re-evaluated\n    // multiple times (V8, soft-deopt prototype-check).\n\n    var fullName = this.fullName,\n        types    = [];\n    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)\n        types.push(this._fieldsArray[i].resolve().resolvedType);\n\n    // Replace setup methods with type-specific generated functions\n    this.encode = encoder(this)({\n        Writer : Writer,\n        types  : types,\n        util   : util\n    });\n    this.decode = decoder(this)({\n        Reader : Reader,\n        types  : types,\n        util   : util\n    });\n    this.verify = verifier(this)({\n        types : types,\n        util  : util\n    });\n    this.fromObject = converter.fromObject(this)({\n        types : types,\n        util  : util\n    });\n    this.toObject = converter.toObject(this)({\n        types : types,\n        util  : util\n    });\n\n    // Inject custom wrappers for common types\n    var wrapper = wrappers[fullName];\n    if (wrapper) {\n        var originalThis = Object.create(this);\n        // if (wrapper.fromObject) {\n            originalThis.fromObject = this.fromObject;\n            this.fromObject = wrapper.fromObject.bind(originalThis);\n        // }\n        // if (wrapper.toObject) {\n            originalThis.toObject = this.toObject;\n            this.toObject = wrapper.toObject.bind(originalThis);\n        // }\n    }\n\n    return this;\n};\n\n/**\n * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */\nType.prototype.encode = function encode_setup(message, writer) {\n    return this.setup().encode(message, writer); // overrides this method\n};\n\n/**\n * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */\nType.prototype.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();\n};\n\n/**\n * Decodes a message of this type.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @param {number} [length] Length of the message, if known beforehand\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError<{}>} If required fields are missing\n */\nType.prototype.decode = function decode_setup(reader, length) {\n    return this.setup().decode(reader, length); // overrides this method\n};\n\n/**\n * Decodes a message of this type preceeded by its byte length as a varint.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError} If required fields are missing\n */\nType.prototype.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof Reader))\n        reader = Reader.create(reader);\n    return this.decode(reader, reader.uint32());\n};\n\n/**\n * Verifies that field values are valid and that required fields are present.\n * @param {Object.<string,*>} message Plain object to verify\n * @returns {null|string} `null` if valid, otherwise the reason why it is not\n */\nType.prototype.verify = function verify_setup(message) {\n    return this.setup().verify(message); // overrides this method\n};\n\n/**\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n * @param {Object.<string,*>} object Plain object to convert\n * @returns {Message<{}>} Message instance\n */\nType.prototype.fromObject = function fromObject(object) {\n    return this.setup().fromObject(object);\n};\n\n/**\n * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.\n * @interface IConversionOptions\n * @property {Function} [longs] Long conversion type.\n * Valid values are `String` and `Number` (the global types).\n * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.\n * @property {Function} [enums] Enum value conversion type.\n * Only valid value is `String` (the global type).\n * Defaults to copy the present value, which is the numeric id.\n * @property {Function} [bytes] Bytes value conversion type.\n * Valid values are `Array` and (a base64 encoded) `String` (the global types).\n * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.\n * @property {boolean} [defaults=false] Also sets default values on the resulting object\n * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`\n * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`\n * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any\n * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings\n */\n\n/**\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n */\nType.prototype.toObject = function toObject(message, options) {\n    return this.setup().toObject(message, options);\n};\n\n/**\n * Decorator function as returned by {@link Type.d} (TypeScript).\n * @typedef TypeDecorator\n * @type {function}\n * @param {Constructor<T>} target Target constructor\n * @returns {undefined}\n * @template T extends Message<T>\n */\n\n/**\n * Type decorator (TypeScript).\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {TypeDecorator<T>} Decorator function\n * @template T extends Message<T>\n */\nType.d = function decorateType(typeName) {\n    return function typeDecorator(target) {\n        util.decorateType(target, typeName);\n    };\n};\n","\"use strict\";\n\n/**\n * Common type constants.\n * @namespace\n */\nvar types = exports;\n\nvar util = require(37);\n\nvar s = [\n    \"double\",   // 0\n    \"float\",    // 1\n    \"int32\",    // 2\n    \"uint32\",   // 3\n    \"sint32\",   // 4\n    \"fixed32\",  // 5\n    \"sfixed32\", // 6\n    \"int64\",    // 7\n    \"uint64\",   // 8\n    \"sint64\",   // 9\n    \"fixed64\",  // 10\n    \"sfixed64\", // 11\n    \"bool\",     // 12\n    \"string\",   // 13\n    \"bytes\"     // 14\n];\n\nfunction bake(values, offset) {\n    var i = 0, o = {};\n    offset |= 0;\n    while (i < values.length) o[s[i + offset]] = values[i++];\n    return o;\n}\n\n/**\n * Basic type wire types.\n * @type {Object.<string,number>}\n * @const\n * @property {number} double=1 Fixed64 wire type\n * @property {number} float=5 Fixed32 wire type\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n * @property {number} string=2 Ldelim wire type\n * @property {number} bytes=2 Ldelim wire type\n */\ntypes.basic = bake([\n    /* double   */ 1,\n    /* float    */ 5,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0,\n    /* string   */ 2,\n    /* bytes    */ 2\n]);\n\n/**\n * Basic type defaults.\n * @type {Object.<string,*>}\n * @const\n * @property {number} double=0 Double default\n * @property {number} float=0 Float default\n * @property {number} int32=0 Int32 default\n * @property {number} uint32=0 Uint32 default\n * @property {number} sint32=0 Sint32 default\n * @property {number} fixed32=0 Fixed32 default\n * @property {number} sfixed32=0 Sfixed32 default\n * @property {number} int64=0 Int64 default\n * @property {number} uint64=0 Uint64 default\n * @property {number} sint64=0 Sint32 default\n * @property {number} fixed64=0 Fixed64 default\n * @property {number} sfixed64=0 Sfixed64 default\n * @property {boolean} bool=false Bool default\n * @property {string} string=\"\" String default\n * @property {Array.<number>} bytes=Array(0) Bytes default\n * @property {null} message=null Message default\n */\ntypes.defaults = bake([\n    /* double   */ 0,\n    /* float    */ 0,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 0,\n    /* sfixed32 */ 0,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 0,\n    /* sfixed64 */ 0,\n    /* bool     */ false,\n    /* string   */ \"\",\n    /* bytes    */ util.emptyArray,\n    /* message  */ null\n]);\n\n/**\n * Basic long type wire types.\n * @type {Object.<string,number>}\n * @const\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n */\ntypes.long = bake([\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1\n], 7);\n\n/**\n * Allowed types for map keys with their associated wire type.\n * @type {Object.<string,number>}\n * @const\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n * @property {number} string=2 Ldelim wire type\n */\ntypes.mapKey = bake([\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0,\n    /* string   */ 2\n], 2);\n\n/**\n * Allowed types for packed repeated fields with their associated wire type.\n * @type {Object.<string,number>}\n * @const\n * @property {number} double=1 Fixed64 wire type\n * @property {number} float=5 Fixed32 wire type\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n */\ntypes.packed = bake([\n    /* double   */ 1,\n    /* float    */ 5,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0\n]);\n","\"use strict\";\n\n/**\n * Various utility functions.\n * @namespace\n */\nvar util = module.exports = require(39);\n\nvar roots = require(30);\n\nvar Type, // cyclic\n    Enum;\n\nutil.codegen = require(3);\nutil.fetch   = require(5);\nutil.path    = require(8);\n\n/**\n * Node's fs module if available.\n * @type {Object.<string,*>}\n */\nutil.fs = util.inquire(\"fs\");\n\n/**\n * Converts an object's values to an array.\n * @param {Object.<string,*>} object Object to convert\n * @returns {Array.<*>} Converted array\n */\nutil.toArray = function toArray(object) {\n    if (object) {\n        var keys  = Object.keys(object),\n            array = new Array(keys.length),\n            index = 0;\n        while (index < keys.length)\n            array[index] = object[keys[index++]];\n        return array;\n    }\n    return [];\n};\n\n/**\n * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.\n * @param {Array.<*>} array Array to convert\n * @returns {Object.<string,*>} Converted object\n */\nutil.toObject = function toObject(array) {\n    var object = {},\n        index  = 0;\n    while (index < array.length) {\n        var key = array[index++],\n            val = array[index++];\n        if (val !== undefined)\n            object[key] = val;\n    }\n    return object;\n};\n\nvar safePropBackslashRe = /\\\\/g,\n    safePropQuoteRe     = /\"/g;\n\n/**\n * Tests whether the specified name is a reserved word in JS.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nutil.isReserved = function isReserved(name) {\n    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);\n};\n\n/**\n * Returns a safe property accessor for the specified property name.\n * @param {string} prop Property name\n * @returns {string} Safe accessor\n */\nutil.safeProp = function safeProp(prop) {\n    if (!/^[$\\w_]+$/.test(prop) || util.isReserved(prop))\n        return \"[\\\"\" + prop.replace(safePropBackslashRe, \"\\\\\\\\\").replace(safePropQuoteRe, \"\\\\\\\"\") + \"\\\"]\";\n    return \".\" + prop;\n};\n\n/**\n * Returns the value of a property found directly in a given object.\n * @param {Object} object Source object\n * @param {string} prop Property name\n * @returns {*} Value or `undefined` if not set\n */\nutil.getProp = function get(object, prop) {\n    return object && Object.prototype.hasOwnProperty.call(object, prop) ? object[prop] : undefined;\n};\n\n/**\n * Converts the first character of a string to upper case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.ucFirst = function ucFirst(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n};\n\nvar camelCaseRe = /_([a-z])/g;\n\n/**\n * Converts a string to camel case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.camelCase = function camelCase(str) {\n    return str.substring(0, 1)\n         + str.substring(1)\n               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });\n};\n\n/**\n * Compares reflected fields by id.\n * @param {Field} a First field\n * @param {Field} b Second field\n * @returns {number} Comparison value\n */\nutil.compareFieldsById = function compareFieldsById(a, b) {\n    return a.id - b.id;\n};\n\n/**\n * Decorator helper for types (TypeScript).\n * @param {Constructor<T>} ctor Constructor function\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {Type} Reflected type\n * @template T extends Message<T>\n * @property {Root} root Decorators root\n */\nutil.decorateType = function decorateType(ctor, typeName) {\n\n    /* istanbul ignore if */\n    if (ctor.$type) {\n        if (typeName && ctor.$type.name !== typeName) {\n            util.decorateRoot.remove(ctor.$type);\n            ctor.$type.name = typeName;\n            util.decorateRoot.add(ctor.$type);\n        }\n        return ctor.$type;\n    }\n\n    /* istanbul ignore next */\n    if (!Type)\n        Type = require(35);\n\n    var type = new Type(typeName || ctor.name);\n    util.decorateRoot.add(type);\n    type.ctor = ctor; // sets up .encode, .decode etc.\n    Object.defineProperty(ctor, \"$type\", { value: type, enumerable: false });\n    Object.defineProperty(ctor.prototype, \"$type\", { value: type, enumerable: false });\n    return type;\n};\n\nvar decorateEnumIndex = 0;\n\n/**\n * Decorator helper for enums (TypeScript).\n * @param {Object} object Enum object\n * @returns {Enum} Reflected enum\n */\nutil.decorateEnum = function decorateEnum(object) {\n\n    /* istanbul ignore if */\n    if (object.$type)\n        return object.$type;\n\n    /* istanbul ignore next */\n    if (!Enum)\n        Enum = require(15);\n\n    var enm = new Enum(\"Enum\" + decorateEnumIndex++, object);\n    util.decorateRoot.add(enm);\n    Object.defineProperty(object, \"$type\", { value: enm, enumerable: false });\n    return enm;\n};\n\n\n/**\n * Sets the value of a property by property path. If a value already exists, it is turned to an array\n * @param {Object.<string,*>} dst Destination object\n * @param {string} path dot '.' delimited path of the property to set\n * @param {Object} value the value to set\n * @returns {Object.<string,*>} Destination object\n */\nutil.setProperty = function setProperty(dst, path, value) {\n    function setProp(dst, path, value) {\n        var part = path.shift();\n        if (part === \"__proto__\" || part === \"prototype\") {\n          return dst;\n        }\n        if (path.length > 0) {\n            dst[part] = setProp(dst[part] || {}, path, value);\n        } else {\n            var prevValue = dst[part];\n            if (prevValue)\n                value = [].concat(prevValue).concat(value);\n            dst[part] = value;\n        }\n        return dst;\n    }\n\n    if (typeof dst !== \"object\")\n        throw TypeError(\"dst must be an object\");\n    if (!path)\n        throw TypeError(\"path must be specified\");\n\n    path = path.split(\".\");\n    return setProp(dst, path, value);\n};\n\n/**\n * Decorator root (TypeScript).\n * @name util.decorateRoot\n * @type {Root}\n * @readonly\n */\nObject.defineProperty(util, \"decorateRoot\", {\n    get: function() {\n        return roots[\"decorated\"] || (roots[\"decorated\"] = new (require(29))());\n    }\n});\n","\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(39);\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n","\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(1);\n\n// converts to / from base64 encoded strings\nutil.base64 = require(2);\n\n// base class of rpc.Service\nutil.EventEmitter = require(4);\n\n// float handling accross browsers\nutil.float = require(6);\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(7);\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(10);\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(9);\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(38);\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n        name: {\n            get: function get() { return name; },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true,\n        },\n        toString: {\n            value: function value() { return this.name + \": \" + this.message; },\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n    });\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n","\"use strict\";\nmodule.exports = verifier;\n\nvar Enum      = require(15),\n    util      = require(37);\n\nfunction invalid(field, expected) {\n    return field.name + \": \" + expected + (field.repeated && expected !== \"array\" ? \"[]\" : field.map && expected !== \"object\" ? \"{k:\"+field.keyType+\"}\" : \"\") + \" expected\";\n}\n\n/**\n * Generates a partial value verifier.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genVerifyValue(gen, field, fieldIndex, ref) {\n    /* eslint-disable no-unexpected-multiline */\n    if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) { gen\n            (\"switch(%s){\", ref)\n                (\"default:\")\n                    (\"return%j\", invalid(field, \"enum value\"));\n            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen\n                (\"case %i:\", field.resolvedType.values[keys[j]]);\n            gen\n                    (\"break\")\n            (\"}\");\n        } else {\n            gen\n            (\"{\")\n                (\"var e=types[%i].verify(%s);\", fieldIndex, ref)\n                (\"if(e)\")\n                    (\"return%j+e\", field.name + \".\")\n            (\"}\");\n        }\n    } else {\n        switch (field.type) {\n            case \"int32\":\n            case \"uint32\":\n            case \"sint32\":\n            case \"fixed32\":\n            case \"sfixed32\": gen\n                (\"if(!util.isInteger(%s))\", ref)\n                    (\"return%j\", invalid(field, \"integer\"));\n                break;\n            case \"int64\":\n            case \"uint64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\": gen\n                (\"if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))\", ref, ref, ref, ref)\n                    (\"return%j\", invalid(field, \"integer|Long\"));\n                break;\n            case \"float\":\n            case \"double\": gen\n                (\"if(typeof %s!==\\\"number\\\")\", ref)\n                    (\"return%j\", invalid(field, \"number\"));\n                break;\n            case \"bool\": gen\n                (\"if(typeof %s!==\\\"boolean\\\")\", ref)\n                    (\"return%j\", invalid(field, \"boolean\"));\n                break;\n            case \"string\": gen\n                (\"if(!util.isString(%s))\", ref)\n                    (\"return%j\", invalid(field, \"string\"));\n                break;\n            case \"bytes\": gen\n                (\"if(!(%s&&typeof %s.length===\\\"number\\\"||util.isString(%s)))\", ref, ref, ref)\n                    (\"return%j\", invalid(field, \"buffer\"));\n                break;\n        }\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline */\n}\n\n/**\n * Generates a partial key verifier.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genVerifyKey(gen, field, ref) {\n    /* eslint-disable no-unexpected-multiline */\n    switch (field.keyType) {\n        case \"int32\":\n        case \"uint32\":\n        case \"sint32\":\n        case \"fixed32\":\n        case \"sfixed32\": gen\n            (\"if(!util.key32Re.test(%s))\", ref)\n                (\"return%j\", invalid(field, \"integer key\"));\n            break;\n        case \"int64\":\n        case \"uint64\":\n        case \"sint64\":\n        case \"fixed64\":\n        case \"sfixed64\": gen\n            (\"if(!util.key64Re.test(%s))\", ref) // see comment above: x is ok, d is not\n                (\"return%j\", invalid(field, \"integer|Long key\"));\n            break;\n        case \"bool\": gen\n            (\"if(!util.key2Re.test(%s))\", ref)\n                (\"return%j\", invalid(field, \"boolean key\"));\n            break;\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline */\n}\n\n/**\n * Generates a verifier specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction verifier(mtype) {\n    /* eslint-disable no-unexpected-multiline */\n\n    var gen = util.codegen([\"m\"], mtype.name + \"$verify\")\n    (\"if(typeof m!==\\\"object\\\"||m===null)\")\n        (\"return%j\", \"object expected\");\n    var oneofs = mtype.oneofsArray,\n        seenFirstField = {};\n    if (oneofs.length) gen\n    (\"var p={}\");\n\n    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {\n        var field = mtype._fieldsArray[i].resolve(),\n            ref   = \"m\" + util.safeProp(field.name);\n\n        if (field.optional) gen\n        (\"if(%s!=null&&m.hasOwnProperty(%j)){\", ref, field.name); // !== undefined && !== null\n\n        // map fields\n        if (field.map) { gen\n            (\"if(!util.isObject(%s))\", ref)\n                (\"return%j\", invalid(field, \"object\"))\n            (\"var k=Object.keys(%s)\", ref)\n            (\"for(var i=0;i<k.length;++i){\");\n                genVerifyKey(gen, field, \"k[i]\");\n                genVerifyValue(gen, field, i, ref + \"[k[i]]\")\n            (\"}\");\n\n        // repeated fields\n        } else if (field.repeated) { gen\n            (\"if(!Array.isArray(%s))\", ref)\n                (\"return%j\", invalid(field, \"array\"))\n            (\"for(var i=0;i<%s.length;++i){\", ref);\n                genVerifyValue(gen, field, i, ref + \"[i]\")\n            (\"}\");\n\n        // required or present fields\n        } else {\n            if (field.partOf) {\n                var oneofProp = util.safeProp(field.partOf.name);\n                if (seenFirstField[field.partOf.name] === 1) gen\n            (\"if(p%s===1)\", oneofProp)\n                (\"return%j\", field.partOf.name + \": multiple values\");\n                seenFirstField[field.partOf.name] = 1;\n                gen\n            (\"p%s=1\", oneofProp);\n            }\n            genVerifyValue(gen, field, i, ref);\n        }\n        if (field.optional) gen\n        (\"}\");\n    }\n    return gen\n    (\"return null\");\n    /* eslint-enable no-unexpected-multiline */\n}","\"use strict\";\n\n/**\n * Wrappers for common types.\n * @type {Object.<string,IWrapper>}\n * @const\n */\nvar wrappers = exports;\n\nvar Message = require(21);\n\n/**\n * From object converter part of an {@link IWrapper}.\n * @typedef WrapperFromObjectConverter\n * @type {function}\n * @param {Object.<string,*>} object Plain object\n * @returns {Message<{}>} Message instance\n * @this Type\n */\n\n/**\n * To object converter part of an {@link IWrapper}.\n * @typedef WrapperToObjectConverter\n * @type {function}\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n * @this Type\n */\n\n/**\n * Common type wrapper part of {@link wrappers}.\n * @interface IWrapper\n * @property {WrapperFromObjectConverter} [fromObject] From object converter\n * @property {WrapperToObjectConverter} [toObject] To object converter\n */\n\n// Custom wrapper for Any\nwrappers[\".google.protobuf.Any\"] = {\n\n    fromObject: function(object) {\n\n        // unwrap value type if mapped\n        if (object && object[\"@type\"]) {\n             // Only use fully qualified type name after the last '/'\n            var name = object[\"@type\"].substring(object[\"@type\"].lastIndexOf(\"/\") + 1);\n            var type = this.lookup(name);\n            /* istanbul ignore else */\n            if (type) {\n                // type_url does not accept leading \".\"\n                var type_url = object[\"@type\"].charAt(0) === \".\" ?\n                    object[\"@type\"].slice(1) : object[\"@type\"];\n                // type_url prefix is optional, but path seperator is required\n                if (type_url.indexOf(\"/\") === -1) {\n                    type_url = \"/\" + type_url;\n                }\n                return this.create({\n                    type_url: type_url,\n                    value: type.encode(type.fromObject(object)).finish()\n                });\n            }\n        }\n\n        return this.fromObject(object);\n    },\n\n    toObject: function(message, options) {\n\n        // Default prefix\n        var googleApi = \"type.googleapis.com/\";\n        var prefix = \"\";\n        var name = \"\";\n\n        // decode value if requested and unmapped\n        if (options && options.json && message.type_url && message.value) {\n            // Only use fully qualified type name after the last '/'\n            name = message.type_url.substring(message.type_url.lastIndexOf(\"/\") + 1);\n            // Separate the prefix used\n            prefix = message.type_url.substring(0, message.type_url.lastIndexOf(\"/\") + 1);\n            var type = this.lookup(name);\n            /* istanbul ignore else */\n            if (type)\n                message = type.decode(message.value);\n        }\n\n        // wrap value if unmapped\n        if (!(message instanceof this.ctor) && message instanceof Message) {\n            var object = message.$type.toObject(message, options);\n            var messageName = message.$type.fullName[0] === \".\" ?\n                message.$type.fullName.slice(1) : message.$type.fullName;\n            // Default to type.googleapis.com prefix if no prefix is used\n            if (prefix === \"\") {\n                prefix = googleApi;\n            }\n            name = prefix + messageName;\n            object[\"@type\"] = name;\n            return object;\n        }\n\n        return this.toObject(message, options);\n    }\n};\n","\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(39);\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n","\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(42);\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(39);\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n"],"sourceRoot":"."}/*!
 * protobuf.js v7.3.2-postman.2 (c) 2016, daniel wirtz
 * compiled fri, 19 jul 2024 16:26:24 utc
 * licensed under the bsd-3-clause license
 * see: https://github.com/dcodeio/protobuf.js for details
 */
!function(nt){"use strict";!function(r,e,t){var i=function t(i){var n=e[i];return n||r[i][0].call(n=e[i]={exports:{}},t,n,n.exports),n.exports}(t[0]);i.util.global.protobuf=i,"function"==typeof define&&define.amd&&define(["long"],function(t){return t&&t.isLong&&(i.util.Long=t,i.configure()),i}),"object"==typeof module&&module&&module.exports&&(module.exports=i)}({1:[function(t,i,n){i.exports=function(t,i){var n=Array(arguments.length-1),s=0,r=2,o=!0;for(;r<arguments.length;)n[s++]=arguments[r++];return new Promise(function(r,e){n[s]=function(t){if(o)if(o=!1,t)e(t);else{for(var i=Array(arguments.length-1),n=0;n<i.length;)i[n++]=arguments[n];r.apply(null,i)}};try{t.apply(i||null,n)}catch(t){o&&(o=!1,e(t))}})}},{}],2:[function(t,i,n){n.length=function(t){var i=t.length;if(!i)return 0;for(var n=0;1<--i%4&&"="==(t[0|i]||"");)++n;return Math.ceil(3*t.length)/4-n};for(var h=Array(64),f=Array(123),r=0;r<64;)f[h[r]=r<26?r+65:r<52?r+71:r<62?r-4:r-59|43]=r++;n.encode=function(t,i,n){for(var r,e=null,s=[],o=0,u=0;i<n;){var f=t[i++];switch(u){case 0:s[o++]=h[f>>2],r=(3&f)<<4,u=1;break;case 1:s[o++]=h[r|f>>4],r=(15&f)<<2,u=2;break;case 2:s[o++]=h[r|f>>6],s[o++]=h[63&f],u=0}8191<o&&((e=e||[]).push(String.fromCharCode.apply(String,s)),o=0)}return u&&(s[o++]=h[r],s[o++]=61,1===u&&(s[o++]=61)),e?(o&&e.push(String.fromCharCode.apply(String,s.slice(0,o))),e.join("")):String.fromCharCode.apply(String,s.slice(0,o))};var a="invalid encoding";n.decode=function(t,i,n){for(var r,e=n,s=0,o=0;o<t.length;){var u=t.charCodeAt(o++);if(61==u&&1<s)break;if((u=f[u])===nt)throw Error(a);switch(s){case 0:r=u,s=1;break;case 1:i[n++]=r<<2|(48&u)>>4,r=u,s=2;break;case 2:i[n++]=(15&r)<<4|(60&u)>>2,r=u,s=3;break;case 3:i[n++]=(3&r)<<6|u,s=0}}if(1===s)throw Error(a);return n-e},n.test=function(t){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t)}},{}],3:[function(t,i,n){function c(i,n){"string"==typeof i&&(n=i,i=nt);var f=[];function h(t){if("string"!=typeof t){var i=a();if(c.verbose&&console.log("codegen: "+i),i="return "+i,t){for(var n=Object.keys(t),r=Array(n.length+1),e=Array(n.length),s=0;s<n.length;)r[s]=n[s],e[s]=t[n[s++]];return r[s]=i,Function.apply(null,r).apply(null,e)}return Function(i)()}for(var o=Array(arguments.length-1),u=0;u<o.length;)o[u]=arguments[++u];if(u=0,t=t.replace(/%([%dfijs])/g,function(t,i){var n=o[u++];switch(i){case"d":case"f":return""+ +(""+n);case"i":return""+Math.floor(n);case"j":return JSON.stringify(n);case"s":return""+n}return"%"}),u!==o.length)throw Error("parameter count mismatch");return f.push(t),h}function a(t){return"function "+(t||n||"")+"("+(i&&i.join(",")||"")+"){\n  "+f.join("\n  ")+"\n}"}return h.toString=a,h}(i.exports=c).verbose=!1},{}],4:[function(t,i,n){function r(){this.i={}}(i.exports=r).prototype.on=function(t,i,n){return(this.i[t]||(this.i[t]=[])).push({fn:i,ctx:n||this}),this},r.prototype.off=function(t,i){if(t===nt)this.i={};else if(i===nt)this.i[t]=[];else for(var n=this.i[t],r=0;r<n.length;)n[r].fn===i?n.splice(r,1):++r;return this},r.prototype.emit=function(t){var i=this.i[t];if(i){for(var n=[],r=1;r<arguments.length;)n.push(arguments[r++]);for(r=0;r<i.length;)i[r].fn.apply(i[r++].ctx,n)}return this}},{}],5:[function(t,i,n){i.exports=u;var s=t(1),o=t(7)("fs");function u(n,r,e){return r="function"==typeof r?(e=r,{}):r||{},e?!r.xhr&&o&&o.readFile?o.readFile(n,function(t,i){return t&&"undefined"!=typeof XMLHttpRequest?u.xhr(n,r,e):t?e(t):e(null,r.binary?i:i.toString("utf8"))}):u.xhr(n,r,e):s(u,this,n,r)}u.xhr=function(t,n,r){var e=new XMLHttpRequest;e.onreadystatechange=function(){if(4!==e.readyState)return nt;if(0!==e.status&&200!==e.status)return r(Error("status "+e.status));if(n.binary){if(!(t=e.response))for(var t=[],i=0;i<e.responseText.length;++i)t.push(255&e.responseText.charCodeAt(i));return r(null,"undefined"!=typeof Uint8Array?new Uint8Array(t):t)}return r(null,e.responseText)},n.binary&&("overrideMimeType"in e&&e.overrideMimeType("text/plain; charset=x-user-defined"),e.responseType="arraybuffer"),e.open("GET",t),e.send()}},{1:1,7:7}],6:[function(t,i,n){function r(t){function i(t,i,n,r){var e=i<0?1:0;t(0===(i=e?-i:i)?0<1/i?0:2147483648:isNaN(i)?2143289344:34028234663852886e22<i?(e<<31|2139095040)>>>0:i<11754943508222875e-54?(e<<31|Math.round(i/1401298464324817e-60))>>>0:(e<<31|127+(t=Math.floor(Math.log(i)/Math.LN2))<<23|8388607&Math.round(i*Math.pow(2,-t)*8388608))>>>0,n,r)}function n(t,i,n){t=t(i,n),i=2*(t>>31)+1,n=t>>>23&255,t&=8388607;return 255==n?t?NaN:1/0*i:0==n?1401298464324817e-60*i*t:i*Math.pow(2,n-150)*(8388608+t)}function r(t,i,n){u[0]=t,i[n]=f[0],i[n+1]=f[1],i[n+2]=f[2],i[n+3]=f[3]}function e(t,i,n){u[0]=t,i[n]=f[3],i[n+1]=f[2],i[n+2]=f[1],i[n+3]=f[0]}function s(t,i){return f[0]=t[i],f[1]=t[i+1],f[2]=t[i+2],f[3]=t[i+3],u[0]}function o(t,i){return f[3]=t[i],f[2]=t[i+1],f[1]=t[i+2],f[0]=t[i+3],u[0]}var u,f,h,a,c;function l(t,i,n,r,e,s){var o,u=r<0?1:0;0===(r=u?-r:r)?(t(0,e,s+i),t(0<1/r?0:2147483648,e,s+n)):isNaN(r)?(t(0,e,s+i),t(2146959360,e,s+n)):17976931348623157e292<r?(t(0,e,s+i),t((u<<31|2146435072)>>>0,e,s+n)):r<22250738585072014e-324?(t((o=r/5e-324)>>>0,e,s+i),t((u<<31|o/4294967296)>>>0,e,s+n)):(t(4503599627370496*(o=r*Math.pow(2,-(r=1024===(r=Math.floor(Math.log(r)/Math.LN2))?1023:r)))>>>0,e,s+i),t((u<<31|r+1023<<20|1048576*o&1048575)>>>0,e,s+n))}function d(t,i,n,r,e){i=t(r,e+i),t=t(r,e+n),r=2*(t>>31)+1,e=t>>>20&2047,n=4294967296*(1048575&t)+i;return 2047==e?n?NaN:1/0*r:0==e?5e-324*r*n:r*Math.pow(2,e-1075)*(n+4503599627370496)}function v(t,i,n){h[0]=t,i[n]=a[0],i[n+1]=a[1],i[n+2]=a[2],i[n+3]=a[3],i[n+4]=a[4],i[n+5]=a[5],i[n+6]=a[6],i[n+7]=a[7]}function p(t,i,n){h[0]=t,i[n]=a[7],i[n+1]=a[6],i[n+2]=a[5],i[n+3]=a[4],i[n+4]=a[3],i[n+5]=a[2],i[n+6]=a[1],i[n+7]=a[0]}function b(t,i){return a[0]=t[i],a[1]=t[i+1],a[2]=t[i+2],a[3]=t[i+3],a[4]=t[i+4],a[5]=t[i+5],a[6]=t[i+6],a[7]=t[i+7],h[0]}function w(t,i){return a[7]=t[i],a[6]=t[i+1],a[5]=t[i+2],a[4]=t[i+3],a[3]=t[i+4],a[2]=t[i+5],a[1]=t[i+6],a[0]=t[i+7],h[0]}return"undefined"!=typeof Float32Array?(u=new Float32Array([-0]),f=new Uint8Array(u.buffer),c=128===f[3],t.writeFloatLE=c?r:e,t.writeFloatBE=c?e:r,t.readFloatLE=c?s:o,t.readFloatBE=c?o:s):(t.writeFloatLE=i.bind(null,y),t.writeFloatBE=i.bind(null,m),t.readFloatLE=n.bind(null,g),t.readFloatBE=n.bind(null,j)),"undefined"!=typeof Float64Array?(h=new Float64Array([-0]),a=new Uint8Array(h.buffer),c=128===a[7],t.writeDoubleLE=c?v:p,t.writeDoubleBE=c?p:v,t.readDoubleLE=c?b:w,t.readDoubleBE=c?w:b):(t.writeDoubleLE=l.bind(null,y,0,4),t.writeDoubleBE=l.bind(null,m,4,0),t.readDoubleLE=d.bind(null,g,0,4),t.readDoubleBE=d.bind(null,j,4,0)),t}function y(t,i,n){i[n]=255&t,i[n+1]=t>>>8&255,i[n+2]=t>>>16&255,i[n+3]=t>>>24}function m(t,i,n){i[n]=t>>>24,i[n+1]=t>>>16&255,i[n+2]=t>>>8&255,i[n+3]=255&t}function g(t,i){return(t[i]|t[i+1]<<8|t[i+2]<<16|t[i+3]<<24)>>>0}function j(t,i){return(t[i]<<24|t[i+1]<<16|t[i+2]<<8|t[i+3])>>>0}i.exports=r(r)},{}],7:[function(t,i,n){function r(t){try{var i=eval("require")(t);if(i&&(i.length||Object.keys(i).length))return i}catch(t){}return null}i.exports=r},{}],8:[function(t,i,n){var e=n.isAbsolute=function(t){return/^(?:\/|\w+:)/.test(t)},r=n.normalize=function(t){var i=(t=t.replace(/\\/g,"/").replace(/\/{2,}/g,"/")).split("/"),n=e(t),t="";n&&(t=i.shift()+"/");for(var r=0;r<i.length;)".."===i[r]?0<r&&".."!==i[r-1]?i.splice(--r,2):n?i.splice(r,1):++r:"."===i[r]?i.splice(r,1):++r;return t+i.join("/")};n.resolve=function(t,i,n){return n||(i=r(i)),!e(i)&&(t=(t=n?t:r(t)).replace(/(?:\/|^)[^/]+$/,"")).length?r(t+"/"+i):i}},{}],9:[function(t,i,n){i.exports=function(i,n,t){var r=t||8192,e=r>>>1,s=null,o=r;return function(t){if(t<1||e<t)return i(t);r<o+t&&(s=i(r),o=0);t=n.call(s,o,o+=t);return 7&o&&(o=1+(7|o)),t}}},{}],10:[function(t,i,n){n.length=function(t){for(var i,n=0,r=0;r<t.length;++r)(i=t.charCodeAt(r))<128?n+=1:i<2048?n+=2:55296==(64512&i)&&56320==(64512&t.charCodeAt(r+1))?(++r,n+=4):n+=3;return n},n.read=function(t,i,n){if(n-i<1)return"";for(var r,e=null,s=[],o=0;i<n;)(r=t[i++])<128?s[o++]=r:191<r&&r<224?s[o++]=(31&r)<<6|63&t[i++]:239<r&&r<365?(r=((7&r)<<18|(63&t[i++])<<12|(63&t[i++])<<6|63&t[i++])-65536,s[o++]=55296+(r>>10),s[o++]=56320+(1023&r)):s[o++]=(15&r)<<12|(63&t[i++])<<6|63&t[i++],8191<o&&((e=e||[]).push(String.fromCharCode.apply(String,s)),o=0);return e?(o&&e.push(String.fromCharCode.apply(String,s.slice(0,o))),e.join("")):String.fromCharCode.apply(String,s.slice(0,o))},n.write=function(t,i,n){for(var r,e,s=n,o=0;o<t.length;++o)(r=t.charCodeAt(o))<128?i[n++]=r:(r<2048?i[n++]=r>>6|192:(55296==(64512&r)&&56320==(64512&(e=t.charCodeAt(o+1)))?(++o,i[n++]=(r=65536+((1023&r)<<10)+(1023&e))>>18|240,i[n++]=r>>12&63|128):i[n++]=r>>12|224,i[n++]=r>>6&63|128),i[n++]=63&r|128);return n-s}},{}],11:[function(t,i,n){i.exports=e;var r=/\/|\./;function e(t,i){r.test(t)||(t="google/protobuf/"+t+".proto",i={nested:{google:{nested:{protobuf:{nested:i}}}}}),e[t]=i}e("any",{Any:{fields:{type_url:{type:"string",id:1},value:{type:"bytes",id:2}}}}),e("duration",{Duration:i={fields:{seconds:{type:"int64",id:1},nanos:{type:"int32",id:2}}}}),e("timestamp",{Timestamp:i}),e("empty",{Empty:{fields:{}}}),e("struct",{Struct:{fields:{fields:{keyType:"string",type:"Value",id:1}}},Value:{oneofs:{kind:{oneof:["null_value","number_value","string_value","bool_value","struct_value","list_value"]}},fields:{null_value:{type:"NullValue",id:1},number_value:{type:"double",id:2},string_value:{type:"string",id:3},bool_value:{type:"bool",id:4},struct_value:{type:"Struct",id:5},list_value:{type:"ListValue",id:6}}},NullValue:{values:{NULL_VALUE:0}},ListValue:{fields:{values:{rule:"repeated",type:"Value",id:1}}}}),e("wrappers",{DoubleValue:{fields:{value:{type:"double",id:1}}},FloatValue:{fields:{value:{type:"float",id:1}}},Int64Value:{fields:{value:{type:"int64",id:1}}},UInt64Value:{fields:{value:{type:"uint64",id:1}}},Int32Value:{fields:{value:{type:"int32",id:1}}},UInt32Value:{fields:{value:{type:"uint32",id:1}}},BoolValue:{fields:{value:{type:"bool",id:1}}},StringValue:{fields:{value:{type:"string",id:1}}},BytesValue:{fields:{value:{type:"bytes",id:1}}}}),e("field_mask",{FieldMask:{fields:{paths:{rule:"repeated",type:"string",id:1}}}}),e.get=function(t){return e[t]||null}},{}],12:[function(t,i,n){var l=t(15),d=t(37);function o(t,i,n,r){var e=!1;if(i.resolvedType)if(i.resolvedType instanceof l){t("switch(d%s){",r);for(var s=i.resolvedType.values,o=Object.keys(s),u=0;u<o.length;++u)s[o[u]]!==i.typeDefault||e||(t("default:")('if(typeof(d%s)==="number"){m%s=d%s;break}',r,r,r),i.repeated||t("break"),e=!0),t("case%j:",o[u])("case %i:",s[o[u]])("m%s=%j",r,s[o[u]])("break");t("}")}else t('if(typeof d%s!=="object")',r)("throw TypeError(%j)",i.fullName+": object expected")("m%s=types[%i].fromObject(d%s)",r,n,r);else{var f=!1;switch(i.type){case"double":case"float":t("m%s=Number(d%s)",r,r);break;case"uint32":case"fixed32":t("m%s=d%s>>>0",r,r);break;case"int32":case"sint32":case"sfixed32":t("m%s=d%s|0",r,r);break;case"uint64":f=!0;case"int64":case"sint64":case"fixed64":case"sfixed64":t("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j",r,r,f)('else if(typeof d%s==="string")',r)("m%s=parseInt(d%s,10)",r,r)('else if(typeof d%s==="number")',r)("m%s=d%s",r,r)('else if(typeof d%s==="object")',r)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)",r,r,r,f?"true":"");break;case"bytes":t('if(typeof d%s==="string")',r)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)",r,r,r)("else if(d%s.length >= 0)",r)("m%s=d%s",r,r);break;case"string":t("m%s=String(d%s)",r,r);break;case"bool":t("m%s=Boolean(d%s)",r,r)}}return t}function v(t,i,n,r){if(i.resolvedType)i.resolvedType instanceof l?t("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s",r,n,r,r,n,r,r):t("d%s=types[%i].toObject(m%s,o)",r,n,r);else{var e=!1;switch(i.type){case"double":case"float":t("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s",r,r,r,r);break;case"uint64":e=!0;case"int64":case"sint64":case"fixed64":case"sfixed64":t('if(typeof m%s==="number")',r)("d%s=o.longs===String?String(m%s):m%s",r,r,r)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s",r,r,r,r,e?"true":"",r);break;case"bytes":t("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s",r,r,r,r,r);break;default:t("d%s=m%s",r,r)}}return t}n.fromObject=function(t){var i=t.fieldsArray,n=d.codegen(["d"],t.name+"$fromObject")("if(d instanceof this.ctor)")("return d");if(!i.length)return n("return new this.ctor");n("var m=new this.ctor");for(var r=0;r<i.length;++r){var e=i[r].resolve(),s=d.safeProp(e.name);e.map?(n("if(d%s){",s)('if(typeof d%s!=="object")',s)("throw TypeError(%j)",e.fullName+": object expected")("m%s={}",s)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){",s),o(n,e,r,s+"[ks[i]]")("}")("}")):e.repeated?(n("if(d%s){",s)("if(!Array.isArray(d%s))",s)("throw TypeError(%j)",e.fullName+": array expected")("m%s=[]",s)("for(var i=0;i<d%s.length;++i){",s),o(n,e,r,s+"[i]")("}")("}")):(e.resolvedType instanceof l||n("if(d%s!=null){",s),o(n,e,r,s),e.resolvedType instanceof l||n("}"))}return n("return m")},n.toObject=function(t){var i=t.fieldsArray.slice().sort(d.compareFieldsById);if(!i.length)return d.codegen()("return {}");for(var n=d.codegen(["m","o"],t.name+"$toObject")("if(!o)")("o={}")("var d={}"),r=[],e=[],s=[],o=0;o<i.length;++o)i[o].partOf||(i[o].resolve().repeated?r:i[o].map?e:s).push(i[o]);if(r.length){for(n("if(o.arrays||o.defaults){"),o=0;o<r.length;++o)n("d%s=[]",d.safeProp(r[o].name));n("}")}if(e.length){for(n("if(o.objects||o.defaults){"),o=0;o<e.length;++o)n("d%s={}",d.safeProp(e[o].name));n("}")}if(s.length){for(n("if(o.defaults){"),o=0;o<s.length;++o){var u,f=s[o],h=d.safeProp(f.name);f.resolvedType instanceof l?n("d%s=o.enums===String?%j:%j",h,f.resolvedType.valuesById[f.typeDefault],f.typeDefault):f.long?n("if(util.Long){")("var n=new util.Long(%i,%i,%j)",f.typeDefault.low,f.typeDefault.high,f.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n",h)("}else")("d%s=o.longs===String?%j:%i",h,f.typeDefault.toString(),f.typeDefault.toNumber()):f.bytes?(u="["+Array.prototype.slice.call(f.typeDefault).join(",")+"]",n("if(o.bytes===String)d%s=%j",h,String.fromCharCode.apply(String,f.typeDefault))("else{")("d%s=%s",h,u)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)",h,h)("}")):n("d%s=%j",h,f.typeDefault)}n("}")}for(var a=!1,o=0;o<i.length;++o){var f=i[o],c=t.e.indexOf(f),h=d.safeProp(f.name);f.map?(a||(a=!0,n("var ks2")),n("if(m%s&&(ks2=Object.keys(m%s)).length){",h,h)("d%s={}",h)("for(var j=0;j<ks2.length;++j){"),v(n,f,c,h+"[ks2[j]]")("}")):f.repeated?(n("if(m%s&&m%s.length){",h,h)("d%s=[]",h)("for(var j=0;j<m%s.length;++j){",h),v(n,f,c,h+"[j]")("}")):(n("if(m%s!=null&&m.hasOwnProperty(%j)){",h,f.name),v(n,f,c,h),f.partOf&&n("if(o.oneofs)")("d%s=%j",d.safeProp(f.partOf.name),f.name)),n("}")}return n("return d")}},{15:15,37:37}],13:[function(t,i,n){i.exports=function(t){var i=h.codegen(["r","l"],t.name+"$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor"+(t.fieldsArray.filter(function(t){return t.map}).length?",k,value":""))("while(r.pos<c){")("var t=r.uint32()");t.group&&i("if((t&7)===4)")("break");i("switch(t>>>3){");for(var n=0;n<t.fieldsArray.length;++n){var r=t.e[n].resolve(),e=r.resolvedType instanceof u?"int32":r.type,s="m"+h.safeProp(r.name);i("case %i: {",r.id),r.map?(i("if(%s===util.emptyObject)",s)("%s={}",s)("var c2 = r.uint32()+r.pos"),f.defaults[r.keyType]!==nt?i("k=%j",f.defaults[r.keyType]):i("k=null"),f.defaults[e]!==nt?i("value=%j",f.defaults[e]):i("value=null"),i("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break",r.keyType)("case 2:"),f.basic[e]===nt?i("value=types[%i].decode(r,r.uint32())",n):i("value=r.%s()",e),i("break")("default:")("r.skipType(tag2&7)")("break")("}")("}"),f.long[r.keyType]!==nt?i('%s[typeof k==="object"?util.longToHash(k):k]=value',s):i("%s[k]=value",s)):r.repeated?(i("if(!(%s&&%s.length))",s,s)("%s=[]",s),f.packed[e]!==nt&&i("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())",s,e)("}else"),f.basic[e]===nt?i(r.resolvedType.group?"%s.push(types[%i].decode(r))":"%s.push(types[%i].decode(r,r.uint32()))",s,n):i("%s.push(r.%s())",s,e)):f.basic[e]===nt?i(r.resolvedType.group?"%s=types[%i].decode(r)":"%s=types[%i].decode(r,r.uint32())",s,n):i("%s=r.%s()",s,e),i("break")("}")}for(i("default:")("r.skipType(t&7)")("break")("}")("}"),n=0;n<t.e.length;++n){var o=t.e[n];o.required&&i("if(!m.hasOwnProperty(%j))",o.name)("throw util.ProtocolError(%j,{instance:m})","missing required '"+o.name+"'")}return i("return m")};var u=t(15),f=t(36),h=t(37)},{15:15,36:36,37:37}],14:[function(t,i,n){i.exports=function(t){for(var i,n=c.codegen(["m","w"],t.name+"$encode")("if(!w)")("w=Writer.create()"),r=t.fieldsArray.slice().sort(c.compareFieldsById),e=0;e<r.length;++e){var s=r[e].resolve(),o=t.e.indexOf(s),u=s.resolvedType instanceof h?"int32":s.type,f=a.basic[u];i="m"+c.safeProp(s.name),s.map?(n("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){",i,s.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){",i)("w.uint32(%i).fork().uint32(%i).%s(ks[i])",(s.id<<3|2)>>>0,8|a.mapKey[s.keyType],s.keyType),f===nt?n("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()",o,i):n(".uint32(%i).%s(%s[ks[i]]).ldelim()",16|f,u,i),n("}")("}")):s.repeated?(n("if(%s!=null&&%s.length){",i,i),s.packed&&a.packed[u]!==nt?n("w.uint32(%i).fork()",(s.id<<3|2)>>>0)("for(var i=0;i<%s.length;++i)",i)("w.%s(%s[i])",u,i)("w.ldelim()"):(n("for(var i=0;i<%s.length;++i)",i),f===nt?l(n,s,o,i+"[i]"):n("w.uint32(%i).%s(%s[i])",(s.id<<3|f)>>>0,u,i)),n("}")):(s.optional&&n("if(%s!=null&&Object.hasOwnProperty.call(m,%j))",i,s.name),f===nt?l(n,s,o,i):n("w.uint32(%i).%s(%s)",(s.id<<3|f)>>>0,u,i))}return n("return w")};var h=t(15),a=t(36),c=t(37);function l(t,i,n,r){i.resolvedType.group?t("types[%i].encode(%s,w.uint32(%i)).uint32(%i)",n,r,(i.id<<3|3)>>>0,(i.id<<3|4)>>>0):t("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()",n,r,(i.id<<3|2)>>>0)}},{15:15,36:36,37:37}],15:[function(t,i,n){i.exports=s;var f=t(24),r=(((s.prototype=Object.create(f.prototype)).constructor=s).className="Enum",t(23)),e=t(37);function s(t,i,n,r,e,s){if(f.call(this,t,n),i&&"object"!=typeof i)throw TypeError("values must be an object");if(this.valuesById={},this.values=Object.create(this.valuesById),this.comment=r,this.comments=e||{},this.valuesOptions=s,this.reserved=nt,i)for(var o=Object.keys(i),u=0;u<o.length;++u)"number"==typeof i[o[u]]&&(this.valuesById[this.values[o[u]]=i[o[u]]]=o[u])}s.fromJSON=function(t,i){t=new s(t,i.values,i.options,i.comment,i.comments);return t.reserved=i.reserved,t},s.prototype.toJSON=function(t){t=!!t&&!!t.keepComments;return e.toObject(["options",this.options,"valuesOptions",this.valuesOptions,"values",this.values,"reserved",this.reserved&&this.reserved.length?this.reserved:nt,"comment",t?this.comment:nt,"comments",t?this.comments:nt])},s.prototype.add=function(t,i,n,r){if(!e.isString(t))throw TypeError("name must be a string");if(!e.isInteger(i))throw TypeError("id must be an integer");if(this.values[t]!==nt)throw Error("duplicate name '"+t+"' in "+this);if(this.isReservedId(i))throw Error("id "+i+" is reserved in "+this);if(this.isReservedName(t))throw Error("name '"+t+"' is reserved in "+this);if(this.valuesById[i]!==nt){if(!this.options||!this.options.allow_alias)throw Error("duplicate id "+i+" in "+this);this.values[t]=i}else this.valuesById[this.values[t]=i]=t;return r&&(this.valuesOptions===nt&&(this.valuesOptions={}),this.valuesOptions[t]=r||null),this.comments[t]=n||null,this},s.prototype.remove=function(t){if(!e.isString(t))throw TypeError("name must be a string");var i=this.values[t];if(null==i)throw Error("name '"+t+"' does not exist in "+this);return delete this.valuesById[i],delete this.values[t],delete this.comments[t],this.valuesOptions&&delete this.valuesOptions[t],this},s.prototype.isReservedId=function(t){return r.isReservedId(this.reserved,t)},s.prototype.isReservedName=function(t){return r.isReservedName(this.reserved,t)}},{23:23,24:24,37:37}],16:[function(t,i,n){i.exports=o;var r,u=t(24),e=(((o.prototype=Object.create(u.prototype)).constructor=o).className="Field",t(15)),f=t(36),h=t(37),a=/^required|optional|repeated$/;function o(t,i,n,r,e,s,o){if(h.isObject(r)?(o=e,s=r,r=e=nt):h.isObject(e)&&(o=s,s=e,e=nt),u.call(this,t,s),!h.isInteger(i)||i<0)throw TypeError("id must be a non-negative integer");if(!h.isString(n))throw TypeError("type must be a string");if(r!==nt&&!a.test(r=r.toString().toLowerCase()))throw TypeError("rule must be a string rule");if(e!==nt&&!h.isString(e))throw TypeError("extend must be a string");this.rule=(r="proto3_optional"===r?"optional":r)&&"optional"!==r?r:nt,this.type=n,this.id=i,this.extend=e||nt,this.required="required"===r,this.optional=!this.required,this.repeated="repeated"===r,this.map=!1,this.message=null,this.partOf=null,this.typeDefault=null,this.defaultValue=null,this.long=!!h.Long&&f.long[n]!==nt,this.bytes="bytes"===n,this.resolvedType=null,this.extensionField=null,this.declaringField=null,this.o=null,this.comment=o}o.fromJSON=function(t,i){return new o(t,i.id,i.type,i.rule,i.extend,i.options,i.comment)},Object.defineProperty(o.prototype,"packed",{get:function(){return null===this.o&&(this.o=!1!==this.getOption("packed")),this.o}}),o.prototype.setOption=function(t,i,n){return"packed"===t&&(this.o=null),u.prototype.setOption.call(this,t,i,n)},o.prototype.toJSON=function(t){t=!!t&&!!t.keepComments;return h.toObject(["rule","optional"!==this.rule&&this.rule||nt,"type",this.type,"id",this.id,"extend",this.extend,"options",this.options,"comment",t?this.comment:nt])},o.prototype.resolve=function(){var t;return this.resolved?this:((this.typeDefault=f.defaults[this.type])===nt?(this.resolvedType=(this.declaringField||this).parent.lookupTypeOrEnum(this.type),this.resolvedType instanceof r?this.typeDefault=null:this.typeDefault=this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]):this.options&&this.options.proto3_optional&&(this.typeDefault=null),this.options&&null!=this.options.default&&(this.typeDefault=this.options.default,this.resolvedType instanceof e&&"string"==typeof this.typeDefault&&(this.typeDefault=this.resolvedType.values[this.typeDefault])),this.options&&(!0!==this.options.packed&&(this.options.packed===nt||!this.resolvedType||this.resolvedType instanceof e)||delete this.options.packed,Object.keys(this.options).length||(this.options=nt)),this.long?(this.typeDefault=h.Long.fromNumber(this.typeDefault,"u"==(this.type[0]||"")),Object.freeze&&Object.freeze(this.typeDefault)):this.bytes&&"string"==typeof this.typeDefault&&(h.base64.test(this.typeDefault)?h.base64.decode(this.typeDefault,t=h.newBuffer(h.base64.length(this.typeDefault)),0):h.utf8.write(this.typeDefault,t=h.newBuffer(h.utf8.length(this.typeDefault)),0),this.typeDefault=t),this.map?this.defaultValue=h.emptyObject:this.repeated?this.defaultValue=h.emptyArray:this.defaultValue=this.typeDefault,this.parent instanceof r&&(this.parent.ctor.prototype[this.name]=this.defaultValue),u.prototype.resolve.call(this))},o.d=function(n,r,e,s){return"function"==typeof r?r=h.decorateType(r).name:r&&"object"==typeof r&&(r=h.decorateEnum(r).name),function(t,i){h.decorateType(t.constructor).add(new o(i,n,r,e,{default:s}))}},o.u=function(t){r=t}},{15:15,24:24,36:36,37:37}],17:[function(t,i,n){var r=i.exports=t(18);r.build="light",r.load=function(t,i,n){return(i="function"==typeof i?(n=i,new r.Root):i||new r.Root).load(t,n)},r.loadSync=function(t,i){return(i=i||new r.Root).loadSync(t)},r.encoder=t(14),r.decoder=t(13),r.verifier=t(40),r.converter=t(12),r.ReflectionObject=t(24),r.Namespace=t(23),r.Root=t(29),r.Enum=t(15),r.Type=t(35),r.Field=t(16),r.OneOf=t(25),r.MapField=t(20),r.Service=t(33),r.Method=t(22),r.Message=t(21),r.wrappers=t(41),r.types=t(36),r.util=t(37),r.ReflectionObject.u(r.Root),r.Namespace.u(r.Type,r.Service,r.Enum),r.Root.u(r.Type),r.Field.u(r.Type)},{12:12,13:13,14:14,15:15,16:16,18:18,20:20,21:21,22:22,23:23,24:24,25:25,29:29,33:33,35:35,36:36,37:37,40:40,41:41}],18:[function(t,i,n){var r=n;function e(){r.util.u(),r.Writer.u(r.BufferWriter),r.Reader.u(r.BufferReader)}r.build="minimal",r.Writer=t(42),r.BufferWriter=t(43),r.Reader=t(27),r.BufferReader=t(28),r.util=t(39),r.rpc=t(31),r.roots=t(30),r.configure=e,e()},{27:27,28:28,30:30,31:31,39:39,42:42,43:43}],19:[function(t,i,n){i=i.exports=t(17);i.build="full",i.tokenize=t(34),i.parse=t(26),i.common=t(11),i.Root.u(i.Type,i.parse,i.common)},{11:11,17:17,26:26,34:34}],20:[function(t,i,n){i.exports=s;var o=t(16),r=(((s.prototype=Object.create(o.prototype)).constructor=s).className="MapField",t(36)),u=t(37);function s(t,i,n,r,e,s){if(o.call(this,t,i,r,nt,nt,e,s),!u.isString(n))throw TypeError("keyType must be a string");this.keyType=n,this.resolvedKeyType=null,this.map=!0}s.fromJSON=function(t,i){return new s(t,i.id,i.keyType,i.type,i.options,i.comment)},s.prototype.toJSON=function(t){t=!!t&&!!t.keepComments;return u.toObject(["keyType",this.keyType,"type",this.type,"id",this.id,"extend",this.extend,"options",this.options,"comment",t?this.comment:nt])},s.prototype.resolve=function(){if(this.resolved)return this;if(r.mapKey[this.keyType]===nt)throw Error("invalid key type: "+this.keyType);return o.prototype.resolve.call(this)},s.d=function(n,r,e){return"function"==typeof e?e=u.decorateType(e).name:e&&"object"==typeof e&&(e=u.decorateEnum(e).name),function(t,i){u.decorateType(t.constructor).add(new s(i,n,r,e))}}},{16:16,36:36,37:37}],21:[function(t,i,n){i.exports=e;var r=t(39);function e(t){if(t)for(var i=Object.keys(t),n=0;n<i.length;++n)this[i[n]]=t[i[n]]}e.create=function(t){return this.$type.create(t)},e.encode=function(t,i){return this.$type.encode(t,i)},e.encodeDelimited=function(t,i){return this.$type.encodeDelimited(t,i)},e.decode=function(t){return this.$type.decode(t)},e.decodeDelimited=function(t){return this.$type.decodeDelimited(t)},e.verify=function(t){return this.$type.verify(t)},e.fromObject=function(t){return this.$type.fromObject(t)},e.toObject=function(t,i){return this.$type.toObject(t,i)},e.prototype.toJSON=function(){return this.$type.toObject(this,r.toJSONOptions)}},{39:39}],22:[function(t,i,n){i.exports=r;var h=t(24),a=(((r.prototype=Object.create(h.prototype)).constructor=r).className="Method",t(37));function r(t,i,n,r,e,s,o,u,f){if(a.isObject(e)?(o=e,e=s=nt):a.isObject(s)&&(o=s,s=nt),i!==nt&&!a.isString(i))throw TypeError("type must be a string");if(!a.isString(n))throw TypeError("requestType must be a string");if(!a.isString(r))throw TypeError("responseType must be a string");h.call(this,t,o),this.type=i||"rpc",this.requestType=n,this.requestStream=!!e||nt,this.responseType=r,this.responseStream=!!s||nt,this.resolvedRequestType=null,this.resolvedResponseType=null,this.comment=u,this.parsedOptions=f}r.fromJSON=function(t,i){return new r(t,i.type,i.requestType,i.responseType,i.requestStream,i.responseStream,i.options,i.comment,i.parsedOptions)},r.prototype.toJSON=function(t){t=!!t&&!!t.keepComments;return a.toObject(["type","rpc"!==this.type&&this.type||nt,"requestType",this.requestType,"requestStream",this.requestStream,"responseType",this.responseType,"responseStream",this.responseStream,"options",this.options,"comment",t?this.comment:nt,"parsedOptions",this.parsedOptions])},r.prototype.resolve=function(){return this.resolved?this:(this.resolvedRequestType=this.parent.lookupType(this.requestType),this.resolvedResponseType=this.parent.lookupType(this.responseType),h.prototype.resolve.call(this))}},{24:24,37:37}],23:[function(t,i,n){i.exports=c;var e,s,o,r=t(24),u=(((c.prototype=Object.create(r.prototype)).constructor=c).className="Namespace",t(16)),f=t(37),h=t(25);function a(t,i){if(!t||!t.length)return nt;for(var n={},r=0;r<t.length;++r)n[t[r].name]=t[r].toJSON(i);return n}function c(t,i){r.call(this,t,i),this.nested=nt,this.f=null}function l(t){return t.f=null,t}c.fromJSON=function(t,i){return new c(t,i.options).addJSON(i.nested)},c.arrayToJSON=a,c.isReservedId=function(t,i){if(t)for(var n=0;n<t.length;++n)if("string"!=typeof t[n]&&t[n][0]<=i&&t[n][1]>i)return!0;return!1},c.isReservedName=function(t,i){if(t)for(var n=0;n<t.length;++n)if(t[n]===i)return!0;return!1},Object.defineProperty(c.prototype,"nestedArray",{get:function(){return this.f||(this.f=f.toArray(this.nested))}}),c.prototype.toJSON=function(t){return f.toObject(["options",this.options,"nested",a(this.nestedArray,t)])},c.prototype.addJSON=function(t){if(t)for(var i,n=Object.keys(t),r=0;r<n.length;++r)i=t[n[r]],this.add((i.fields!==nt?e:i.values!==nt?o:i.methods!==nt?s:i.id!==nt?u:c).fromJSON(n[r],i));return this},c.prototype.get=function(t){return f.getProp(this.nested,t)||null},c.prototype.getEnum=function(t){if(this.nested&&this.nested[t]instanceof o)return this.nested[t].values;throw Error("no such enum: "+t)},c.prototype.add=function(t){if(!(t instanceof u&&t.extend!==nt||t instanceof e||t instanceof h||t instanceof o||t instanceof s||t instanceof c))throw TypeError("object must be a valid nested object");if(this.nested){var i=this.get(t.name);if(i){if(!(i instanceof c&&t instanceof c)||i instanceof e||i instanceof s)throw Error("duplicate name '"+t.name+"' in "+this);for(var n=i.nestedArray,r=0;r<n.length;++r)t.add(n[r]);this.remove(i),this.nested||(this.nested={}),t.setOptions(i.options,!0)}}else this.nested={};return(this.nested[t.name]=t).onAdd(this),l(this)},c.prototype.remove=function(t){if(!(t instanceof r))throw TypeError("object must be a ReflectionObject");if(t.parent!==this)throw Error(t+" is not a member of "+this);return delete this.nested[t.name],Object.keys(this.nested).length||(this.nested=nt),t.onRemove(this),l(this)},c.prototype.define=function(t,i){if(f.isString(t))t=t.split(".");else if(!Array.isArray(t))throw TypeError("illegal path");if(t&&t.length&&""===t[0])throw Error("path must be relative");for(var n=this;0<t.length;){var r=t.shift();if(n.nested&&n.nested[r]){if(!((n=n.nested[r])instanceof c))throw Error("path conflicts with non-namespace objects")}else n.add(n=new c(r))}return i&&n.addJSON(i),n},c.prototype.resolveAll=function(){for(var t=this.nestedArray,i=0;i<t.length;)t[i]instanceof c?t[i++].resolveAll():t[i++].resolve();return this.resolve()},c.prototype.lookup=function(t,i,n){if("boolean"==typeof i?(n=i,i=nt):i&&!Array.isArray(i)&&(i=[i]),f.isString(t)&&t.length){if("."===t)return this.root;t=t.split(".")}else if(!t.length)return this;if(""===t[0])return this.root.lookup(t.slice(1),i);var r=this.get(t[0]);if(r){if(1===t.length){if(!i||~i.indexOf(r.constructor))return r}else if(r instanceof c&&(r=r.lookup(t.slice(1),i,!0)))return r}else for(var e=0;e<this.nestedArray.length;++e)if(this.f[e]instanceof c&&(r=this.f[e].lookup(t,i,!0)))return r;return null===this.parent||n?null:this.parent.lookup(t,i)},c.prototype.lookupType=function(t){var i=this.lookup(t,[e]);if(i)return i;throw Error("no such type: "+t)},c.prototype.lookupEnum=function(t){var i=this.lookup(t,[o]);if(i)return i;throw Error("no such Enum '"+t+"' in "+this)},c.prototype.lookupTypeOrEnum=function(t){var i=this.lookup(t,[e,o]);if(i)return i;throw Error("no such Type or Enum '"+t+"' in "+this)},c.prototype.lookupService=function(t){var i=this.lookup(t,[s]);if(i)return i;throw Error("no such Service '"+t+"' in "+this)},c.u=function(t,i,n){e=t,s=i,o=n}},{16:16,24:24,25:25,37:37}],24:[function(t,i,n){(i.exports=e).className="ReflectionObject";var r,o=t(37);function e(t,i){if(!o.isString(t))throw TypeError("name must be a string");if(i&&!o.isObject(i))throw TypeError("options must be an object");this.options=i,this.parsedOptions=null,this.name=t,this.parent=null,this.resolved=!1,this.comment=null,this.filename=null}Object.defineProperties(e.prototype,{root:{get:function(){for(var t=this;null!==t.parent;)t=t.parent;return t}},fullName:{get:function(){for(var t=[this.name],i=this.parent;i;)t.unshift(i.name),i=i.parent;return t.join(".")}}}),e.prototype.toJSON=function(){throw Error()},e.prototype.onAdd=function(t){this.parent&&this.parent!==t&&this.parent.remove(this),this.parent=t,this.resolved=!1;t=t.root;t instanceof r&&t.h(this)},e.prototype.onRemove=function(t){t=t.root;t instanceof r&&t.a(this),this.parent=null,this.resolved=!1},e.prototype.resolve=function(){return this.resolved||this.root instanceof r&&(this.resolved=!0),this},e.prototype.getOption=function(t){return this.options?this.options[t]:nt},e.prototype.setOption=function(t,i,n){return n&&this.options&&this.options[t]!==nt||((this.options||(this.options={}))[t]=i),this},e.prototype.setParsedOption=function(i,t,n){this.parsedOptions||(this.parsedOptions=[]);var r,e,s=this.parsedOptions;return n?(r=s.find(function(t){return Object.prototype.hasOwnProperty.call(t,i)}))?(e=r[i],o.setProperty(e,n,t)):((r={})[i]=o.setProperty({},n,t),s.push(r)):((e={})[i]=t,s.push(e)),this},e.prototype.setOptions=function(t,i){if(t)for(var n=Object.keys(t),r=0;r<n.length;++r)this.setOption(n[r],t[n[r]],i);return this},e.prototype.toString=function(){var t=this.constructor.className,i=this.fullName;return i.length?t+" "+i:t},e.u=function(t){r=t}},{37:37}],25:[function(t,i,n){i.exports=o;var e=t(24),r=(((o.prototype=Object.create(e.prototype)).constructor=o).className="OneOf",t(16)),s=t(37);function o(t,i,n,r){if(Array.isArray(i)||(n=i,i=nt),e.call(this,t,n),i!==nt&&!Array.isArray(i))throw TypeError("fieldNames must be an Array");this.oneof=i||[],this.fieldsArray=[],this.comment=r}function u(t){if(t.parent)for(var i=0;i<t.fieldsArray.length;++i)t.fieldsArray[i].parent||t.parent.add(t.fieldsArray[i])}o.fromJSON=function(t,i){return new o(t,i.oneof,i.options,i.comment)},o.prototype.toJSON=function(t){t=!!t&&!!t.keepComments;return s.toObject(["options",this.options,"oneof",this.oneof,"comment",t?this.comment:nt])},o.prototype.add=function(t){if(t instanceof r)return t.parent&&t.parent!==this.parent&&t.parent.remove(t),this.oneof.push(t.name),this.fieldsArray.push(t),u(t.partOf=this),this;throw TypeError("field must be a Field")},o.prototype.remove=function(t){if(!(t instanceof r))throw TypeError("field must be a Field");var i=this.fieldsArray.indexOf(t);if(i<0)throw Error(t+" is not a member of "+this);return this.fieldsArray.splice(i,1),-1<(i=this.oneof.indexOf(t.name))&&this.oneof.splice(i,1),t.partOf=null,this},o.prototype.onAdd=function(t){e.prototype.onAdd.call(this,t);for(var i=0;i<this.oneof.length;++i){var n=t.get(this.oneof[i]);n&&!n.partOf&&(n.partOf=this).fieldsArray.push(n)}u(this)},o.prototype.onRemove=function(t){for(var i,n=0;n<this.fieldsArray.length;++n)(i=this.fieldsArray[n]).parent&&i.parent.remove(i);e.prototype.onRemove.call(this,t)},o.d=function(){for(var n=Array(arguments.length),t=0;t<arguments.length;)n[t]=arguments[t++];return function(t,i){s.decorateType(t.constructor).add(new o(i,n)),Object.defineProperty(t,i,{get:s.oneOfGetter(n),set:s.oneOfSetter(n)})}}},{16:16,24:24,37:37}],26:[function(t,i,n){(i.exports=it).filename=null,it.defaults={keepCase:!1};var F=t(34),L=t(29),V=t(35),U=t(16),q=t(20),R=t(25),z=t(15),Z=t(33),B=t(22),P=t(36),H=t(37),X=/^[1-9][0-9]*$/,C=/^-?[1-9][0-9]*$/,D=/^0[x][0-9a-fA-F]+$/,J=/^-?0[x][0-9a-fA-F]+$/,W=/^0[0-7]+$/,G=/^-?0[0-7]+$/,K=/^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,Q=/^[a-zA-Z_][a-zA-Z_0-9]*$/,Y=/^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,tt=/^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;function it(t,i,n){i instanceof L||(n=i,i=new L);var r,e,s,o,h,u,f,a=(n=n||it.defaults).preferTrailingComment||!1,c=F(t,n.alternateCommentMode||!1),l=c.next,d=c.push,v=c.peek,p=c.skip,b=c.cmnt,w=!0,y=!1,m=i,g=n.keepCase?function(t){return t}:H.camelCase;function j(t,i,n){var r=it.filename;return n||(it.filename=null),Error("illegal "+(i||"token")+" '"+t+"' ("+(r?r+", ":"")+"line "+c.line+")")}function k(){var t,i=[];do{if('"'!==(t=l())&&"'"!==t)throw j(t)}while(i.push(l()),p(t),'"'===(t=v())||"'"===t);return i.join("")}function O(i){var n=l();switch(n){case"'":case'"':return d(n),k();case"true":case"TRUE":return!0;case"false":case"FALSE":return!1}try{var t=n,r=!0,e=1;switch("-"==(t[0]||"")&&(e=-1,t=t.substring(1)),t){case"inf":case"INF":case"Inf":return e*(1/0);case"nan":case"NAN":case"Nan":case"NaN":return NaN;case"0":return 0}if(X.test(t))return e*parseInt(t,10);if(D.test(t))return e*parseInt(t,16);if(W.test(t))return e*parseInt(t,8);if(K.test(t))return e*parseFloat(t);throw j(t,"number",r)}catch(t){if(i&&Y.test(n))return n;throw j(n,"value")}}function E(t,i){for(var n;!i||'"'!==(n=v())&&"'"!==n?t.push([n=A(l()),p("to",!0)?A(l()):n]):t.push(k()),p(",",!0););var r={options:nt,setOption:function(t,i){this.options===nt&&(this.options={}),this.options[t]=i}};S(r,function(t){if("option"!==t)throw j(t);$(r,t),p(";")},function(){I(r)})}function A(t,i){switch(t){case"max":case"MAX":case"Max":return 536870911;case"0":return 0}if(i||"-"!=(t[0]||"")){if(C.test(t))return parseInt(t,10);if(J.test(t))return parseInt(t,16);if(G.test(t))return parseInt(t,8)}throw j(t,"id")}function x(t,i){switch(i){case"option":return $(t,i),p(";"),1;case"message":return T(t),1;case"enum":return N(t),1;case"service":var h,n=t,r=i;if(Q.test(r=l()))return S(h=new Z(r),function(t){if(!x(h,t)){if("rpc"!==t)throw j(t);var i=h,n=b(),r=t;if(!Q.test(t=l()))throw j(t,"name");var e,s,o,u=t;if(p("("),p("stream",!0)&&(s=!0),!Y.test(t=l()))throw j(t);if(e=t,p(")"),p("returns"),p("("),p("stream",!0)&&(o=!0),!Y.test(t=l()))throw j(t);t=t,p(")");var f=new B(u,r,e,t,s,o);f.comment=n,S(f,function(t){if("option"!==t)throw j(t);$(f,t),p(";")}),i.add(f)}}),n.add(h),1;throw j(r,"service name");case"extend":var e,s=t,n=i;if(Y.test(n=l()))return e=n,S(null,function(t){switch(t){case"required":case"repeated":_(s,t,e);break;case"optional":_(s,y?"proto3_optional":"optional",e);break;default:if(!y||!Y.test(t))throw j(t);d(t),_(s,"optional",e)}}),1;throw j(n,"reference")}}function S(t,i,n){var r,e=c.line;if(t&&("string"!=typeof t.comment&&(t.comment=b()),t.filename=it.filename),p("{",!0)){for(;"}"!==(r=l());)i(r);p(";",!0)}else n&&n(),p(";"),t&&("string"!=typeof t.comment||a)&&(t.comment=b(e)||t.comment)}function T(t,i){if(!Q.test(i=l()))throw j(i,"type name");var u=new V(i);S(u,function(t){if(!x(u,t))switch(t){case"map":var i=u,n=(p("<"),l());if(P.mapKey[n]===nt)throw j(n,"type");p(",");var r=l();if(!Y.test(r))throw j(r,"type");p(">");var e=l();if(!Q.test(e))throw j(e,"name");p("=");var s=new q(g(e),A(l()),n,r);S(s,function(t){if("option"!==t)throw j(t);$(s,t),p(";")},function(){I(s)}),i.add(s);break;case"required":case"repeated":_(u,t);break;case"optional":_(u,y?"proto3_optional":"optional");break;case"oneof":e=u,n=t;if(!Q.test(n=l()))throw j(n,"name");var o=new R(g(n));S(o,function(t){"option"===t?($(o,t),p(";")):(d(t),_(o,"optional"))}),e.add(o);break;case"extensions":E(u.extensions||(u.extensions=[]));break;case"reserved":E(u.reserved||(u.reserved=[]),!0);break;default:if(!y||!Y.test(t))throw j(t);d(t),_(u,"optional")}}),t.add(u)}function _(t,i,n){var r=l();if("group"===r){var e,s,o=t,u=i,f=l();if(Q.test(f))return s=H.lcFirst(f),f===s&&(f=H.ucFirst(f)),p("="),h=A(l()),(e=new V(f)).group=!0,(s=new U(s,h,f,u)).filename=it.filename,S(e,function(t){switch(t){case"option":$(e,t),p(";");break;case"required":case"repeated":_(e,t);break;case"optional":_(e,y?"proto3_optional":"optional");break;case"message":T(e);break;case"enum":N(e);break;default:throw j(t)}}),void o.add(e).add(s);throw j(f,"name")}for(;r.endsWith(".")||v().startsWith(".");)r+=l();if(!Y.test(r))throw j(r,"type");var h=l();if(!Q.test(h))throw j(h,"name");h=g(h),p("=");var a=new U(h,A(l()),r,i,n);S(a,function(t){if("option"!==t)throw j(t);$(a,t),p(";")},function(){I(a)}),"proto3_optional"===i?(u=new R("_"+h),a.setOption("proto3_optional",!0),u.add(a),t.add(u)):t.add(a),y||!a.repeated||P.packed[r]===nt&&P.basic[r]!==nt||a.setOption("packed",!1,!0)}function N(t,i){if(!Q.test(i=l()))throw j(i,"name");var s=new z(i);S(s,function(t){switch(t){case"option":$(s,t),p(";");break;case"reserved":E(s.reserved||(s.reserved=[]),!0);break;default:var i=s,n=t;if(!Q.test(n))throw j(n,"name");p("=");var r=A(l(),!0),e={options:nt,setOption:function(t,i){this.options===nt&&(this.options={}),this.options[t]=i}};return S(e,function(t){if("option"!==t)throw j(t);$(e,t),p(";")},function(){I(e)}),void i.add(n,r,e.comment,e.options)}}),t.add(s)}function $(t,i){var n=p("(",!0);if(!Y.test(i=l()))throw j(i,"name");var r,e=i,s=e,n=(n&&(p(")"),s=e="("+e+")",i=v(),tt.test(i)&&(r=i.slice(1),e+=i,l())),p("="),function t(i,n){if(p("{",!0)){for(var r={};!p("}",!0);){if(!Q.test(h=l()))throw j(h,"name");if(null===h)throw j(h,"end of input");var e,s,o=h;if(p(":",!0),"{"===v())e=t(i,n+"."+h);else if("["===v()){if(e=[],p("[",!0)){for(;s=O(!0),e.push(s),p(",",!0););p("]"),void 0!==s&&M(i,n+"."+h,s)}}else e=O(!0),M(i,n+"."+h,e);var u=r[o];u&&(e=[].concat(u).concat(e)),r[o]=e,p(",",!0),p(";",!0)}return r}var f=O(!0);M(i,n,f);return f}(t,e));i=s,e=n,s=r,(n=t).setParsedOption&&n.setParsedOption(i,e,s)}function M(t,i,n){t.setOption&&t.setOption(i,n)}function I(t){if(p("[",!0)){for(;$(t,"option"),p(",",!0););p("]")}}for(;null!==(h=l());)switch(h){case"package":if(!w)throw j(h);if(r!==nt)throw j("package");if(r=l(),!Y.test(r))throw j(r,"name");m=m.define(r),p(";");break;case"import":if(!w)throw j(h);switch(f=u=void 0,v()){case"weak":f=s=s||[],l();break;case"public":l();default:f=e=e||[]}u=k(),p(";"),f.push(u);break;case"syntax":if(!w)throw j(h);if(p("="),o=k(),!(y="proto3"===o)&&"proto2"!==o)throw j(o,"syntax");p(";");break;case"option":$(m,h),p(";");break;default:if(x(m,h)){w=!1;continue}throw j(h)}return it.filename=null,{package:r,imports:e,weakImports:s,syntax:o,root:i}}},{15:15,16:16,20:20,22:22,25:25,29:29,33:33,34:34,35:35,36:36,37:37}],27:[function(t,i,n){i.exports=f;var r,e=t(39),s=e.LongBits,o=e.utf8;function u(t,i){return RangeError("index out of range: "+t.pos+" + "+(i||1)+" > "+t.len)}function f(t){this.buf=t,this.pos=0,this.len=t.length}function h(){return e.Buffer?function(t){return(f.create=function(t){return e.Buffer.isBuffer(t)?new r(t):c(t)})(t)}:c}var a,c="undefined"!=typeof Uint8Array?function(t){if(t instanceof Uint8Array||Array.isArray(t))return new f(t);throw Error("illegal buffer")}:function(t){if(Array.isArray(t))return new f(t);throw Error("illegal buffer")};function l(){var t=new s(0,0),i=0;if(!(4<this.len-this.pos)){for(;i<3;++i){if(this.pos>=this.len)throw u(this);if(t.lo=(t.lo|(127&this.buf[this.pos])<<7*i)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(127&this.buf[this.pos++])<<7*i)>>>0,t}for(;i<4;++i)if(t.lo=(t.lo|(127&this.buf[this.pos])<<7*i)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(127&this.buf[this.pos])<<28)>>>0,t.hi=(t.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return t;if(i=0,4<this.len-this.pos){for(;i<5;++i)if(t.hi=(t.hi|(127&this.buf[this.pos])<<7*i+3)>>>0,this.buf[this.pos++]<128)return t}else for(;i<5;++i){if(this.pos>=this.len)throw u(this);if(t.hi=(t.hi|(127&this.buf[this.pos])<<7*i+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}function d(t,i){return(t[i-4]|t[i-3]<<8|t[i-2]<<16|t[i-1]<<24)>>>0}function v(){if(this.pos+8>this.len)throw u(this,8);return new s(d(this.buf,this.pos+=4),d(this.buf,this.pos+=4))}f.create=h(),f.prototype.c=e.Array.prototype.subarray||e.Array.prototype.slice,f.prototype.uint32=(a=4294967295,function(){if(a=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(a=(a|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128||(a=(a|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128||(a=(a|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128||(a=(a|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128||!((this.pos+=5)>this.len))))))return a;throw this.pos=this.len,u(this,10)}),f.prototype.int32=function(){return 0|this.uint32()},f.prototype.sint32=function(){var t=this.uint32();return t>>>1^-(1&t)|0},f.prototype.bool=function(){return 0!==this.uint32()},f.prototype.fixed32=function(){if(this.pos+4>this.len)throw u(this,4);return d(this.buf,this.pos+=4)},f.prototype.sfixed32=function(){if(this.pos+4>this.len)throw u(this,4);return 0|d(this.buf,this.pos+=4)},f.prototype.float=function(){if(this.pos+4>this.len)throw u(this,4);var t=e.float.readFloatLE(this.buf,this.pos);return this.pos+=4,t},f.prototype.double=function(){if(this.pos+8>this.len)throw u(this,4);var t=e.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,t},f.prototype.bytes=function(){var t=this.uint32(),i=this.pos,n=this.pos+t;if(n>this.len)throw u(this,t);return this.pos+=t,Array.isArray(this.buf)?this.buf.slice(i,n):i===n?(t=e.Buffer)?t.alloc(0):new this.buf.constructor(0):this.c.call(this.buf,i,n)},f.prototype.string=function(){var t=this.bytes();return o.read(t,0,t.length)},f.prototype.skip=function(t){if("number"==typeof t){if(this.pos+t>this.len)throw u(this,t);this.pos+=t}else do{if(this.pos>=this.len)throw u(this)}while(128&this.buf[this.pos++]);return this},f.prototype.skipType=function(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(t=7&this.uint32());)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+t+" at offset "+this.pos)}return this},f.u=function(t){r=t,f.create=h(),r.u();var i=e.Long?"toLong":"toNumber";e.merge(f.prototype,{int64:function(){return l.call(this)[i](!1)},uint64:function(){return l.call(this)[i](!0)},sint64:function(){return l.call(this).zzDecode()[i](!1)},fixed64:function(){return v.call(this)[i](!0)},sfixed64:function(){return v.call(this)[i](!1)}})}},{39:39}],28:[function(t,i,n){i.exports=s;var r=t(27),e=((s.prototype=Object.create(r.prototype)).constructor=s,t(39));function s(t){r.call(this,t)}s.u=function(){e.Buffer&&(s.prototype.c=e.Buffer.prototype.slice)},s.prototype.string=function(){var t=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+t,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+t,this.len))},s.u()},{27:27,39:39}],29:[function(t,i,n){i.exports=f;var r,d,v,e=t(23),s=(((f.prototype=Object.create(e.prototype)).constructor=f).className="Root",t(16)),o=t(15),u=t(25),p=t(37);function f(t){e.call(this,"",t),this.deferred=[],this.files=[]}function b(){}f.fromJSON=function(t,i){return i=i||new f,t.options&&i.setOptions(t.options),i.addJSON(t.nested)},f.prototype.resolvePath=p.path.resolve,f.prototype.fetch=p.fetch,f.prototype.load=function t(i,s,e){"function"==typeof s&&(e=s,s=nt);var o=this;if(!e)return p.asPromise(t,o,i,s);var u=e===b;function f(t,i){if(e){if(u)throw t;var n=e;e=null,n(t,i)}}function h(t){var i=t.lastIndexOf("google/protobuf/");if(-1<i){t=t.substring(i);if(t in v)return t}return null}function a(t,i){try{if(p.isString(i)&&"{"==(i[0]||"")&&(i=JSON.parse(i)),p.isString(i)){d.filename=t;var n,r=d(i,o,s),e=0;if(r.imports)for(;e<r.imports.length;++e)(n=h(r.imports[e])||o.resolvePath(t,r.imports[e]))&&c(n);if(r.weakImports)for(e=0;e<r.weakImports.length;++e)(n=h(r.weakImports[e])||o.resolvePath(t,r.weakImports[e]))&&c(n,!0)}else o.setOptions(i.options).addJSON(i.nested)}catch(t){f(t)}u||l||f(null,o)}function c(n,r){if(n=h(n)||n,!~o.files.indexOf(n))if(o.files.push(n),n in v)u?a(n,v[n]):(++l,setTimeout(function(){--l,a(n,v[n])}));else if(u){var t;try{t=p.fs.readFileSync(n).toString("utf8")}catch(t){return void(r||f(t))}a(n,t)}else++l,o.fetch(n,function(t,i){--l,e&&(t?r?l||f(null,o):f(t):a(n,i))})}var l=0;p.isString(i)&&(i=[i]);for(var n,r=0;r<i.length;++r)(n=o.resolvePath("",i[r]))&&c(n);return u?o:(l||f(null,o),nt)},f.prototype.loadSync=function(t,i){if(p.isNode)return this.load(t,i,b);throw Error("not supported")},f.prototype.resolveAll=function(){if(this.deferred.length)throw Error("unresolvable extensions: "+this.deferred.map(function(t){return"'extend "+t.extend+"' in "+t.parent.fullName}).join(", "));return e.prototype.resolveAll.call(this)};var h=/^[A-Z]/;function a(t,i){var n,r=i.parent.lookup(i.extend);if(r)return n=new s(i.fullName,i.id,i.type,i.rule,nt,i.options),r.get(n.name)||((n.declaringField=i).extensionField=n,r.add(n)),1}f.prototype.h=function(t){if(t instanceof s)t.extend===nt||t.extensionField||a(0,t)||this.deferred.push(t);else if(t instanceof o)h.test(t.name)&&(t.parent[t.name]=t.values);else if(!(t instanceof u)){if(t instanceof r)for(var i=0;i<this.deferred.length;)a(0,this.deferred[i])?this.deferred.splice(i,1):++i;for(var n=0;n<t.nestedArray.length;++n)this.h(t.f[n]);h.test(t.name)&&(t.parent[t.name]=t)}},f.prototype.a=function(t){var i;if(t instanceof s)t.extend!==nt&&(t.extensionField?(t.extensionField.parent.remove(t.extensionField),t.extensionField=null):-1<(i=this.deferred.indexOf(t))&&this.deferred.splice(i,1));else if(t instanceof o)h.test(t.name)&&delete t.parent[t.name];else if(t instanceof e){for(var n=0;n<t.nestedArray.length;++n)this.a(t.f[n]);h.test(t.name)&&delete t.parent[t.name]}},f.u=function(t,i,n){r=t,d=i,v=n}},{15:15,16:16,23:23,25:25,37:37}],30:[function(t,i,n){i.exports={}},{}],31:[function(t,i,n){n.Service=t(32)},{32:32}],32:[function(t,i,n){i.exports=r;var u=t(39);function r(t,i,n){if("function"!=typeof t)throw TypeError("rpcImpl must be a function");u.EventEmitter.call(this),this.rpcImpl=t,this.requestDelimited=!!i,this.responseDelimited=!!n}((r.prototype=Object.create(u.EventEmitter.prototype)).constructor=r).prototype.rpcCall=function t(n,i,r,e,s){if(!e)throw TypeError("request must be specified");var o=this;if(!s)return u.asPromise(t,o,n,i,r,e);if(!o.rpcImpl)return setTimeout(function(){s(Error("already ended"))},0),nt;try{return o.rpcImpl(n,i[o.requestDelimited?"encodeDelimited":"encode"](e).finish(),function(t,i){if(t)return o.emit("error",t,n),s(t);if(null===i)return o.end(!0),nt;if(!(i instanceof r))try{i=r[o.responseDelimited?"decodeDelimited":"decode"](i)}catch(t){return o.emit("error",t,n),s(t)}return o.emit("data",i,n),s(null,i)})}catch(t){return o.emit("error",t,n),setTimeout(function(){s(t)},0),nt}},r.prototype.end=function(t){return this.rpcImpl&&(t||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},{39:39}],33:[function(t,i,n){i.exports=o;var r=t(23),s=(((o.prototype=Object.create(r.prototype)).constructor=o).className="Service",t(22)),u=t(37),f=t(31);function o(t,i){r.call(this,t,i),this.methods={},this.l=null}function e(t){return t.l=null,t}o.fromJSON=function(t,i){var n=new o(t,i.options);if(i.methods)for(var r=Object.keys(i.methods),e=0;e<r.length;++e)n.add(s.fromJSON(r[e],i.methods[r[e]]));return i.nested&&n.addJSON(i.nested),n.comment=i.comment,n},o.prototype.toJSON=function(t){var i=r.prototype.toJSON.call(this,t),n=!!t&&!!t.keepComments;return u.toObject(["options",i&&i.options||nt,"methods",r.arrayToJSON(this.methodsArray,t)||{},"nested",i&&i.nested||nt,"comment",n?this.comment:nt])},Object.defineProperty(o.prototype,"methodsArray",{get:function(){return this.l||(this.l=u.toArray(this.methods))}}),o.prototype.get=function(t){return u.getProp(this.methods,t)||r.prototype.get.call(this,t)},o.prototype.resolveAll=function(){for(var t=this.methodsArray,i=0;i<t.length;++i)t[i].resolve();return r.prototype.resolve.call(this)},o.prototype.add=function(t){if(this.get(t.name))throw Error("duplicate name '"+t.name+"' in "+this);return t instanceof s?e((this.methods[t.name]=t).parent=this):r.prototype.add.call(this,t)},o.prototype.remove=function(t){if(t instanceof s){if(this.methods[t.name]!==t)throw Error(t+" is not a member of "+this);return delete this.methods[t.name],t.parent=null,e(this)}return r.prototype.remove.call(this,t)},o.prototype.create=function(t,i,n){for(var r,e=new f.Service(t,i,n),s=0;s<this.methodsArray.length;++s){var o=u.lcFirst((r=this.l[s]).resolve().name).replace(/[^$\w_]/g,"");e[o]=u.codegen(["r","c"],u.isReserved(o)?o+"_":o)("return this.rpcCall(m,q,s,r,c)")({m:r,q:r.resolvedRequestType.ctor,s:r.resolvedResponseType.ctor})}return e}},{22:22,23:23,31:31,37:37}],34:[function(t,i,n){i.exports=s;var O=/[\s{}=;:[\],'"()<>]/g,E=/(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,A=/(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g,x=/^ *[*/]+ */,S=/^\s*\*?\/*/,T=/\n/g,_=/\s/,r=/\\(.?)/g,e={0:"\0",r:"\r",n:"\n",t:"\t"};function N(t){return t.replace(r,function(t,i){switch(i){case"\\":case"":return i;default:return e[i]||""}})}function s(h,a){h=h.toString();var c=0,l=h.length,d=1,f=0,v={},p=[],b=null;function w(t){return Error("illegal "+t+" (line "+d+")")}function y(t){return h[0|t]||""}function m(t,i,n){var r,e={type:h[0|t++]||"",lineEmpty:!1,leading:n},n=a?2:3,s=t-n;do{if(--s<0||"\n"==(r=h[0|s]||"")){e.lineEmpty=!0;break}}while(" "===r||"\t"===r);for(var o=h.substring(t,i).split(T),u=0;u<o.length;++u)o[u]=o[u].replace(a?S:x,"").trim();e.text=o.join("\n").trim(),v[d]=e,f=d}function g(t){var i=j(t),t=h.substring(t,i);return/^\s*\/\//.test(t)}function j(t){for(var i=t;i<l&&"\n"!==y(i);)i++;return i}function r(){if(0<p.length)return p.shift();if(b){var t="'"===b?A:E,i=(t.lastIndex=c-1,t.exec(h));if(i)return c=t.lastIndex,k(b),b=null,N(i[1]);throw w("string")}var n,r,e,s,o,u=0===c;do{if(c===l)return null;for(n=!1;_.test(e=y(c));)if("\n"===e&&(u=!0,++d),++c===l)return null;if("/"===y(c)){if(++c===l)throw w("comment");if("/"===y(c))if(a){if(o=!1,g((s=c)-1))for(o=!0;(c=j(c))!==l&&(c++,u&&g(c)););else c=Math.min(l,j(c)+1);o&&(m(s,c,u),u=!0),d++}else{for(o="/"===y(s=c+1);"\n"!==y(++c);)if(c===l)return null;++c,o&&(m(s,c-1,u),u=!0),++d}else{if("*"!==(e=y(c)))return"/";s=c+1,o=a||"*"===y(s);do{if("\n"===e&&++d,++c===l)throw w("comment")}while(r=e,e=y(c),"*"!==r||"/"!==e);++c,o&&(m(s,c-2,u),u=!0)}n=!0}}while(n);var f=c;if(O.lastIndex=0,!O.test(y(f++)))for(;f<l&&!O.test(y(f));)++f;t=h.substring(c,c=f);return'"'!=t&&"'"!=t||(b=t),t}function k(t){p.push(t)}function e(){if(!p.length){var t=r();if(null===t)return null;k(t)}return p[0]}return Object.defineProperty({next:r,peek:e,push:k,skip:function(t,i){var n=e();if(n===t)return r(),!0;if(i)return!1;throw w("token '"+n+"', '"+t+"' expected")},cmnt:function(t){var i,n=null;return t===nt?(i=v[d-1],delete v[d-1],i&&(a||"*"===i.type||i.lineEmpty)&&(n=i.leading?i.text:null)):(f<t&&e(),i=v[t],delete v[t],!i||i.lineEmpty||!a&&"/"!==i.type||(n=i.leading?null:i.text)),n}},"line",{get:function(){return d}})}s.unescape=N},{}],35:[function(t,i,n){i.exports=m;var o=t(23),u=(((m.prototype=Object.create(o.prototype)).constructor=m).className="Type",t(15)),f=t(25),h=t(16),a=t(20),c=t(33),e=t(21),s=t(27),l=t(42),d=t(37),v=t(14),p=t(13),b=t(40),w=t(12),y=t(41);function m(t,i){o.call(this,t,i),this.fields={},this.oneofs=nt,this.extensions=nt,this.reserved=nt,this.group=nt,this.v=null,this.e=null,this.p=null,this.b=null}function r(t){return t.v=t.e=t.p=null,delete t.encode,delete t.decode,delete t.verify,t}Object.defineProperties(m.prototype,{fieldsById:{get:function(){if(!this.v){this.v={};for(var t=Object.keys(this.fields),i=0;i<t.length;++i){var n=this.fields[t[i]],r=n.id;if(this.v[r])throw Error("duplicate id "+r+" in "+this);this.v[r]=n}}return this.v}},fieldsArray:{get:function(){return this.e||(this.e=d.toArray(this.fields))}},oneofsArray:{get:function(){return this.p||(this.p=d.toArray(this.oneofs))}},ctor:{get:function(){return this.b||(this.ctor=m.generateConstructor(this)())},set:function(t){for(var i=t.prototype,n=(i instanceof e||((t.prototype=new e).constructor=t,d.merge(t.prototype,i)),t.$type=t.prototype.$type=this,d.merge(t,e,!0),this.b=t,0);n<this.fieldsArray.length;++n)this.e[n].resolve();for(var r={},n=0;n<this.oneofsArray.length;++n)r[this.p[n].resolve().name]={get:d.oneOfGetter(this.p[n].oneof),set:d.oneOfSetter(this.p[n].oneof)};n&&Object.defineProperties(t.prototype,r)}}}),m.generateConstructor=function(t){for(var i,n=d.codegen(["p"],t.name),r=0;r<t.fieldsArray.length;++r)(i=t.e[r]).map?n("this%s={}",d.safeProp(i.name)):i.repeated&&n("this%s=[]",d.safeProp(i.name));return n("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]")},m.fromJSON=function(t,i){for(var n=new m(t,i.options),r=(n.extensions=i.extensions,n.reserved=i.reserved,Object.keys(i.fields)),e=0;e<r.length;++e)n.add((void 0!==i.fields[r[e]].keyType?a:h).fromJSON(r[e],i.fields[r[e]]));if(i.oneofs)for(r=Object.keys(i.oneofs),e=0;e<r.length;++e)n.add(f.fromJSON(r[e],i.oneofs[r[e]]));if(i.nested)for(r=Object.keys(i.nested),e=0;e<r.length;++e){var s=i.nested[r[e]];n.add((s.id!==nt?h:s.fields!==nt?m:s.values!==nt?u:s.methods!==nt?c:o).fromJSON(r[e],s))}return i.extensions&&i.extensions.length&&(n.extensions=i.extensions),i.reserved&&i.reserved.length&&(n.reserved=i.reserved),i.group&&(n.group=!0),i.comment&&(n.comment=i.comment),n},m.prototype.toJSON=function(t){var i=o.prototype.toJSON.call(this,t),n=!!t&&!!t.keepComments;return d.toObject(["options",i&&i.options||nt,"oneofs",o.arrayToJSON(this.oneofsArray,t),"fields",o.arrayToJSON(this.fieldsArray.filter(function(t){return!t.declaringField}),t)||{},"extensions",this.extensions&&this.extensions.length?this.extensions:nt,"reserved",this.reserved&&this.reserved.length?this.reserved:nt,"group",this.group||nt,"nested",i&&i.nested||nt,"comment",n?this.comment:nt])},m.prototype.resolveAll=function(){for(var t=this.fieldsArray,i=0;i<t.length;)t[i++].resolve();for(var n=this.oneofsArray,i=0;i<n.length;)n[i++].resolve();return o.prototype.resolveAll.call(this)},m.prototype.get=function(t){return d.getProp(this.fields,t)||d.getProp(this.oneofs,t)||d.getProp(this.nested,t)||null},m.prototype.add=function(t){if(this.get(t.name))throw Error("duplicate name '"+t.name+"' in "+this);if(t instanceof h&&t.extend===nt){if((this.v||this.fieldsById)[t.id])throw Error("duplicate id "+t.id+" in "+this);if(this.isReservedId(t.id))throw Error("id "+t.id+" is reserved in "+this);if(this.isReservedName(t.name))throw Error("name '"+t.name+"' is reserved in "+this);return t.parent&&t.parent.remove(t),(this.fields[t.name]=t).message=this,t.onAdd(this),r(this)}return t instanceof f?(this.oneofs||(this.oneofs={}),(this.oneofs[t.name]=t).onAdd(this),r(this)):o.prototype.add.call(this,t)},m.prototype.remove=function(t){if(t instanceof h&&t.extend===nt){if(this.fields&&this.fields[t.name]===t)return delete this.fields[t.name],t.parent=null,t.onRemove(this),r(this);throw Error(t+" is not a member of "+this)}if(t instanceof f){if(this.oneofs&&this.oneofs[t.name]===t)return delete this.oneofs[t.name],t.parent=null,t.onRemove(this),r(this);throw Error(t+" is not a member of "+this)}return o.prototype.remove.call(this,t)},m.prototype.isReservedId=function(t){return o.isReservedId(this.reserved,t)},m.prototype.isReservedName=function(t){return o.isReservedName(this.reserved,t)},m.prototype.create=function(t){return new this.ctor(t)},m.prototype.setup=function(){for(var t=this.fullName,i=[],n=0;n<this.fieldsArray.length;++n)i.push(this.e[n].resolve().resolvedType);this.encode=v(this)({Writer:l,types:i,util:d}),this.decode=p(this)({Reader:s,types:i,util:d}),this.verify=b(this)({types:i,util:d}),this.fromObject=w.fromObject(this)({types:i,util:d}),this.toObject=w.toObject(this)({types:i,util:d});var r,t=y[t];return t&&((r=Object.create(this)).fromObject=this.fromObject,this.fromObject=t.fromObject.bind(r),r.toObject=this.toObject,this.toObject=t.toObject.bind(r)),this},m.prototype.encode=function(t,i){return this.setup().encode(t,i)},m.prototype.encodeDelimited=function(t,i){return this.encode(t,i&&i.len?i.fork():i).ldelim()},m.prototype.decode=function(t,i){return this.setup().decode(t,i)},m.prototype.decodeDelimited=function(t){return t instanceof s||(t=s.create(t)),this.decode(t,t.uint32())},m.prototype.verify=function(t){return this.setup().verify(t)},m.prototype.fromObject=function(t){return this.setup().fromObject(t)},m.prototype.toObject=function(t,i){return this.setup().toObject(t,i)},m.d=function(i){return function(t){d.decorateType(t,i)}}},{12:12,13:13,14:14,15:15,16:16,20:20,21:21,23:23,25:25,27:27,33:33,37:37,40:40,41:41,42:42}],36:[function(t,i,n){var t=t(37),e=["double","float","int32","uint32","sint32","fixed32","sfixed32","int64","uint64","sint64","fixed64","sfixed64","bool","string","bytes"];function r(t,i){var n=0,r={};for(i|=0;n<t.length;)r[e[n+i]]=t[n++];return r}n.basic=r([1,5,0,0,0,5,5,0,0,0,1,1,0,2,2]),n.defaults=r([0,0,0,0,0,0,0,0,0,0,0,0,!1,"",t.emptyArray,null]),n.long=r([0,0,0,1,1],7),n.mapKey=r([0,0,0,5,5,0,0,0,1,1,0,2],2),n.packed=r([1,5,0,0,0,5,5,0,0,0,1,1,0])},{37:37}],37:[function(n,t,i){var r,e,s=t.exports=n(39),o=n(30),u=(s.codegen=n(3),s.fetch=n(5),s.path=n(8),s.fs=s.inquire("fs"),s.toArray=function(t){if(t){for(var i=Object.keys(t),n=Array(i.length),r=0;r<i.length;)n[r]=t[i[r++]];return n}return[]},s.toObject=function(t){for(var i={},n=0;n<t.length;){var r=t[n++],e=t[n++];e!==nt&&(i[r]=e)}return i},/\\/g),f=/"/g,h=(s.isReserved=function(t){return/^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(t)},s.safeProp=function(t){return!/^[$\w_]+$/.test(t)||s.isReserved(t)?'["'+t.replace(u,"\\\\").replace(f,'\\"')+'"]':"."+t},s.getProp=function(t,i){return t&&Object.prototype.hasOwnProperty.call(t,i)?t[i]:nt},s.ucFirst=function(t){return(t[0]||"").toUpperCase()+t.substring(1)},/_([a-z])/g),a=(s.camelCase=function(t){return t.substring(0,1)+t.substring(1).replace(h,function(t,i){return i.toUpperCase()})},s.compareFieldsById=function(t,i){return t.id-i.id},s.decorateType=function(t,i){return t.$type?(i&&t.$type.name!==i&&(s.decorateRoot.remove(t.$type),t.$type.name=i,s.decorateRoot.add(t.$type)),t.$type):(i=new(r=r||n(35))(i||t.name),s.decorateRoot.add(i),i.ctor=t,Object.defineProperty(t,"$type",{value:i,enumerable:!1}),Object.defineProperty(t.prototype,"$type",{value:i,enumerable:!1}),i)},0);s.decorateEnum=function(t){var i;return t.$type||(i=new(e=e||n(15))("Enum"+a++,t),s.decorateRoot.add(i),Object.defineProperty(t,"$type",{value:i,enumerable:!1}),i)},s.setProperty=function(t,i,n){if("object"!=typeof t)throw TypeError("dst must be an object");if(i)return function t(i,n,r){var e=n.shift();return"__proto__"!==e&&"prototype"!==e&&(0<n.length?i[e]=t(i[e]||{},n,r):((n=i[e])&&(r=[].concat(n).concat(r)),i[e]=r)),i}(t,i=i.split("."),n);throw TypeError("path must be specified")},Object.defineProperty(s,"decorateRoot",{get:function(){return o.decorated||(o.decorated=new(n(29)))}})},{15:15,29:29,3:3,30:30,35:35,39:39,5:5,8:8}],38:[function(t,i,n){i.exports=e;var r=t(39);function e(t,i){this.lo=t>>>0,this.hi=i>>>0}var s=e.zero=new e(0,0),o=(s.toNumber=function(){return 0},s.zzEncode=s.zzDecode=function(){return this},s.length=function(){return 1},e.zeroHash="\0\0\0\0\0\0\0\0",e.fromNumber=function(t){var i,n;return 0===t?s:(n=(t=(i=t<0)?-t:t)>>>0,t=(t-n)/4294967296>>>0,i&&(t=~t>>>0,n=~n>>>0,4294967295<++n&&(n=0,4294967295<++t&&(t=0))),new e(n,t))},e.from=function(t){if("number"==typeof t)return e.fromNumber(t);if(r.isString(t)){if(!r.Long)return e.fromNumber(parseInt(t,10));t=r.Long.fromString(t)}return t.low||t.high?new e(t.low>>>0,t.high>>>0):s},e.prototype.toNumber=function(t){var i;return!t&&this.hi>>>31?(t=1+~this.lo>>>0,i=~this.hi>>>0,-(t+4294967296*(i=t?i:i+1>>>0))):this.lo+4294967296*this.hi},e.prototype.toLong=function(t){return r.Long?new r.Long(0|this.lo,0|this.hi,!!t):{low:0|this.lo,high:0|this.hi,unsigned:!!t}},String.prototype.charCodeAt);e.fromHash=function(t){return"\0\0\0\0\0\0\0\0"===t?s:new e((o.call(t,0)|o.call(t,1)<<8|o.call(t,2)<<16|o.call(t,3)<<24)>>>0,(o.call(t,4)|o.call(t,5)<<8|o.call(t,6)<<16|o.call(t,7)<<24)>>>0)},e.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},e.prototype.zzEncode=function(){var t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this},e.prototype.zzDecode=function(){var t=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this},e.prototype.length=function(){var t=this.lo,i=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return 0==n?0==i?t<16384?t<128?1:2:t<2097152?3:4:i<16384?i<128?5:6:i<2097152?7:8:n<128?9:10}},{39:39}],39:[function(t,i,n){var r=n;function e(t,i,n){for(var r=Object.keys(i),e=0;e<r.length;++e)t[r[e]]!==nt&&n||(t[r[e]]=i[r[e]]);return t}function s(t){function n(t,i){if(!(this instanceof n))return new n(t,i);Object.defineProperty(this,"message",{get:function(){return t}}),Error.captureStackTrace?Error.captureStackTrace(this,n):Object.defineProperty(this,"stack",{value:Error().stack||""}),i&&e(this,i)}return n.prototype=Object.create(Error.prototype,{constructor:{value:n,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return t},set:nt,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),n}r.asPromise=t(1),r.base64=t(2),r.EventEmitter=t(4),r.float=t(6),r.inquire=t(7),r.utf8=t(10),r.pool=t(9),r.LongBits=t(38),r.isNode=!!("undefined"!=typeof global&&global&&global.process&&global.process.versions&&global.process.versions.node),r.global=r.isNode&&global||"undefined"!=typeof window&&window||"undefined"!=typeof self&&self||this,r.emptyArray=Object.freeze?Object.freeze([]):[],r.emptyObject=Object.freeze?Object.freeze({}):{},r.isInteger=Number.isInteger||function(t){return"number"==typeof t&&isFinite(t)&&Math.floor(t)===t},r.isString=function(t){return"string"==typeof t||t instanceof String},r.isObject=function(t){return t&&"object"==typeof t},r.isset=r.isSet=function(t,i){var n=t[i];return null!=n&&t.hasOwnProperty(i)&&("object"!=typeof n||0<(Array.isArray(n)?n:Object.keys(n)).length)},r.Buffer=function(){try{var t=r.inquire("buffer").Buffer;return t.prototype.utf8Write?t:null}catch(t){return null}}(),r.w=null,r.y=null,r.newBuffer=function(t){return"number"==typeof t?r.Buffer?r.y(t):new r.Array(t):r.Buffer?r.w(t):"undefined"==typeof Uint8Array?t:new Uint8Array(t)},r.Array="undefined"!=typeof Uint8Array?Uint8Array:Array,r.Long=r.global.dcodeIO&&r.global.dcodeIO.Long||r.global.Long||r.inquire("long"),r.key2Re=/^true|false|0|1$/,r.key32Re=/^-?(?:0|[1-9][0-9]*)$/,r.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,r.longToHash=function(t){return t?r.LongBits.from(t).toHash():r.LongBits.zeroHash},r.longFromHash=function(t,i){t=r.LongBits.fromHash(t);return r.Long?r.Long.fromBits(t.lo,t.hi,i):t.toNumber(!!i)},r.merge=e,r.lcFirst=function(t){return(t[0]||"").toLowerCase()+t.substring(1)},r.newError=s,r.ProtocolError=s("ProtocolError"),r.oneOfGetter=function(t){for(var n={},i=0;i<t.length;++i)n[t[i]]=1;return function(){for(var t=Object.keys(this),i=t.length-1;-1<i;--i)if(1===n[t[i]]&&this[t[i]]!==nt&&null!==this[t[i]])return t[i]}},r.oneOfSetter=function(n){return function(t){for(var i=0;i<n.length;++i)n[i]!==t&&delete this[n[i]]}},r.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},r.u=function(){var n=r.Buffer;n?(r.w=n.from!==Uint8Array.from&&n.from||function(t,i){return new n(t,i)},r.y=n.allocUnsafe||function(t){return new n(t)}):r.w=r.y=null}},{1:1,10:10,2:2,38:38,4:4,6:6,7:7,9:9}],40:[function(t,i,n){i.exports=function(t){var i=f.codegen(["m"],t.name+"$verify")('if(typeof m!=="object"||m===null)')("return%j","object expected"),n=t.oneofsArray,r={};n.length&&i("var p={}");for(var e=0;e<t.fieldsArray.length;++e){var s,o=t.e[e].resolve(),u="m"+f.safeProp(o.name);o.optional&&i("if(%s!=null&&m.hasOwnProperty(%j)){",u,o.name),o.map?(i("if(!util.isObject(%s))",u)("return%j",h(o,"object"))("var k=Object.keys(%s)",u)("for(var i=0;i<k.length;++i){"),function(t,i,n){switch(i.keyType){case"int32":case"uint32":case"sint32":case"fixed32":case"sfixed32":t("if(!util.key32Re.test(%s))",n)("return%j",h(i,"integer key"));break;case"int64":case"uint64":case"sint64":case"fixed64":case"sfixed64":t("if(!util.key64Re.test(%s))",n)("return%j",h(i,"integer|Long key"));break;case"bool":t("if(!util.key2Re.test(%s))",n)("return%j",h(i,"boolean key"))}}(i,o,"k[i]"),a(i,o,e,u+"[k[i]]")("}")):o.repeated?(i("if(!Array.isArray(%s))",u)("return%j",h(o,"array"))("for(var i=0;i<%s.length;++i){",u),a(i,o,e,u+"[i]")("}")):(o.partOf&&(s=f.safeProp(o.partOf.name),1===r[o.partOf.name]&&i("if(p%s===1)",s)("return%j",o.partOf.name+": multiple values"),r[o.partOf.name]=1,i("p%s=1",s)),a(i,o,e,u)),o.optional&&i("}")}return i("return null")};var o=t(15),f=t(37);function h(t,i){return t.name+": "+i+(t.repeated&&"array"!==i?"[]":t.map&&"object"!==i?"{k:"+t.keyType+"}":"")+" expected"}function a(t,i,n,r){if(i.resolvedType)if(i.resolvedType instanceof o){t("switch(%s){",r)("default:")("return%j",h(i,"enum value"));for(var e=Object.keys(i.resolvedType.values),s=0;s<e.length;++s)t("case %i:",i.resolvedType.values[e[s]]);t("break")("}")}else t("{")("var e=types[%i].verify(%s);",n,r)("if(e)")("return%j+e",i.name+".")("}");else switch(i.type){case"int32":case"uint32":case"sint32":case"fixed32":case"sfixed32":t("if(!util.isInteger(%s))",r)("return%j",h(i,"integer"));break;case"int64":case"uint64":case"sint64":case"fixed64":case"sfixed64":t("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))",r,r,r,r)("return%j",h(i,"integer|Long"));break;case"float":case"double":t('if(typeof %s!=="number")',r)("return%j",h(i,"number"));break;case"bool":t('if(typeof %s!=="boolean")',r)("return%j",h(i,"boolean"));break;case"string":t("if(!util.isString(%s))",r)("return%j",h(i,"string"));break;case"bytes":t('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))',r,r,r)("return%j",h(i,"buffer"))}return t}},{15:15,37:37}],41:[function(t,i,n){var o=t(21);n[".google.protobuf.Any"]={fromObject:function(t){if(t&&t["@type"]){var i,n=t["@type"].substring(1+t["@type"].lastIndexOf("/")),n=this.lookup(n);if(n)return~(i="."==(t["@type"][0]||"")?t["@type"].slice(1):t["@type"]).indexOf("/")||(i="/"+i),this.create({type_url:i,value:n.encode(n.fromObject(t)).finish()})}return this.fromObject(t)},toObject:function(t,i){var n,r,e="",s="";return i&&i.json&&t.type_url&&t.value&&(s=t.type_url.substring(1+t.type_url.lastIndexOf("/")),e=t.type_url.substring(0,1+t.type_url.lastIndexOf("/")),(n=this.lookup(s))&&(t=n.decode(t.value))),!(t instanceof this.ctor)&&t instanceof o?(n=t.$type.toObject(t,i),r="."===t.$type.fullName[0]?t.$type.fullName.slice(1):t.$type.fullName,n["@type"]=s=(e=""===e?"type.googleapis.com/":e)+r,n):this.toObject(t,i)}}},{21:21}],42:[function(t,i,n){i.exports=c;var r,e=t(39),s=e.LongBits,o=e.base64,u=e.utf8;function f(t,i,n){this.fn=t,this.len=i,this.next=nt,this.val=n}function h(){}function a(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}function c(){this.len=0,this.head=new f(h,0,0),this.tail=this.head,this.states=null}function l(){return e.Buffer?function(){return(c.create=function(){return new r})()}:function(){return new c}}function d(t,i,n){i[n]=255&t}function v(t,i){this.len=t,this.next=nt,this.val=i}function p(t,i,n){for(;t.hi;)i[n++]=127&t.lo|128,t.lo=(t.lo>>>7|t.hi<<25)>>>0,t.hi>>>=7;for(;127<t.lo;)i[n++]=127&t.lo|128,t.lo=t.lo>>>7;i[n++]=t.lo}function b(t,i,n){i[n]=255&t,i[n+1]=t>>>8&255,i[n+2]=t>>>16&255,i[n+3]=t>>>24}c.create=l(),c.alloc=function(t){return new e.Array(t)},e.Array!==Array&&(c.alloc=e.pool(c.alloc,e.Array.prototype.subarray)),c.prototype.g=function(t,i,n){return this.tail=this.tail.next=new f(t,i,n),this.len+=i,this},(v.prototype=Object.create(f.prototype)).fn=function(t,i,n){for(;127<t;)i[n++]=127&t|128,t>>>=7;i[n]=t},c.prototype.uint32=function(t){return this.len+=(this.tail=this.tail.next=new v((t>>>=0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this},c.prototype.int32=function(t){return t<0?this.g(p,10,s.fromNumber(t)):this.uint32(t)},c.prototype.sint32=function(t){return this.uint32((t<<1^t>>31)>>>0)},c.prototype.int64=c.prototype.uint64=function(t){t=s.from(t);return this.g(p,t.length(),t)},c.prototype.sint64=function(t){t=s.from(t).zzEncode();return this.g(p,t.length(),t)},c.prototype.bool=function(t){return this.g(d,1,t?1:0)},c.prototype.sfixed32=c.prototype.fixed32=function(t){return this.g(b,4,t>>>0)},c.prototype.sfixed64=c.prototype.fixed64=function(t){t=s.from(t);return this.g(b,4,t.lo).g(b,4,t.hi)},c.prototype.float=function(t){return this.g(e.float.writeFloatLE,4,t)},c.prototype.double=function(t){return this.g(e.float.writeDoubleLE,8,t)};var w=e.Array.prototype.set?function(t,i,n){i.set(t,n)}:function(t,i,n){for(var r=0;r<t.length;++r)i[n+r]=t[r]};c.prototype.bytes=function(t){var i,n=t.length>>>0;return n?(e.isString(t)&&(i=c.alloc(n=o.length(t)),o.decode(t,i,0),t=i),this.uint32(n).g(w,n,t)):this.g(d,1,0)},c.prototype.string=function(t){var i=u.length(t);return i?this.uint32(i).g(u.write,i,t):this.g(d,1,0)},c.prototype.fork=function(){return this.states=new a(this),this.head=this.tail=new f(h,0,0),this.len=0,this},c.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new f(h,0,0),this.len=0),this},c.prototype.ldelim=function(){var t=this.head,i=this.tail,n=this.len;return this.reset().uint32(n),n&&(this.tail.next=t.next,this.tail=i,this.len+=n),this},c.prototype.finish=function(){for(var t=this.head.next,i=this.constructor.alloc(this.len),n=0;t;)t.fn(t.val,i,n),n+=t.len,t=t.next;return i},c.u=function(t){r=t,c.create=l(),r.u()}},{39:39}],43:[function(t,i,n){i.exports=s;var r=t(42),e=((s.prototype=Object.create(r.prototype)).constructor=s,t(39));function s(){r.call(this)}function o(t,i,n){t.length<40?e.utf8.write(t,i,n):i.utf8Write?i.utf8Write(t,n):i.write(t,n)}s.u=function(){s.alloc=e.y,s.writeBytesBuffer=e.Buffer&&e.Buffer.prototype instanceof Uint8Array&&"set"===e.Buffer.prototype.set.name?function(t,i,n){i.set(t,n)}:function(t,i,n){if(t.copy)t.copy(i,n,0,t.length);else for(var r=0;r<t.length;)i[n++]=t[r++]}},s.prototype.bytes=function(t){var i=(t=e.isString(t)?e.w(t,"base64"):t).length>>>0;return this.uint32(i),i&&this.g(s.writeBytesBuffer,i,t),this},s.prototype.string=function(t){var i=e.Buffer.byteLength(t);return this.uint32(i),i&&this.g(o,i,t),this},s.u()},{39:39,42:42}]},{},[19])}();
//# sourceMappingURL=protobuf.min.js.map
{"version":3,"sources":["lib/prelude.js","../node_modules/@protobufjs/aspromise/index.js","../node_modules/@protobufjs/base64/index.js","../node_modules/@protobufjs/codegen/index.js","../node_modules/@protobufjs/eventemitter/index.js","../node_modules/@protobufjs/fetch/index.js","../node_modules/@protobufjs/float/index.js","../node_modules/@protobufjs/inquire/index.js","../node_modules/@protobufjs/path/index.js","../node_modules/@protobufjs/pool/index.js","../node_modules/@protobufjs/utf8/index.js","../src/common.js","../src/converter.js","../src/decoder.js","../src/encoder.js","../src/enum.js","../src/field.js","../src/index-light.js","../src/index-minimal.js","../src/index","../src/mapfield.js","../src/message.js","../src/method.js","../src/namespace.js","../src/object.js","../src/oneof.js","../src/parse.js","../src/reader.js","../src/reader_buffer.js","../src/root.js","../src/roots.js","../src/rpc.js","../src/rpc/service.js","../src/service.js","../src/tokenize.js","../src/type.js","../src/types.js","../src/util.js","../src/util/longbits.js","../src/util/minimal.js","../src/verifier.js","../src/wrappers.js","../src/writer.js","../src/writer_buffer.js"],"names":["undefined","modules","cache","entries","protobuf","$require","name","$module","call","exports","util","global","define","amd","Long","isLong","configure","module","1","require","fn","ctx","params","Array","arguments","length","offset","index","pending","Promise","resolve","reject","err","apply","base64","string","p","n","Math","ceil","b64","s64","i","encode","buffer","start","end","t","parts","chunk","j","b","push","String","fromCharCode","slice","join","invalidEncoding","decode","c","charCodeAt","Error","test","codegen","functionParams","functionName","body","Codegen","formatStringOrScope","source","toString","verbose","console","log","scopeKeys","Object","keys","scopeParams","scopeValues","scopeOffset","Function","formatParams","formatOffset","replace","$0","$1","value","Number","floor","JSON","stringify","functionNameOverride","EventEmitter","this","_listeners","prototype","on","evt","off","listeners","splice","emit","args","fetch","asPromise","fs","filename","options","callback","xhr","readFile","contents","XMLHttpRequest","binary","onreadystatechange","readyState","status","response","responseText","Uint8Array","overrideMimeType","responseType","open","send","factory","writeFloat_ieee754","writeUint","val","buf","pos","sign","isNaN","round","exponent","LN2","pow","readFloat_ieee754","readUint","uint","mantissa","NaN","Infinity","writeFloat_f32_cpy","f32","f8b","writeFloat_f32_rev","readFloat_f32_cpy","readFloat_f32_rev","f64","le","writeDouble_ieee754","off0","off1","readDouble_ieee754","lo","hi","writeDouble_f64_cpy","writeDouble_f64_rev","readDouble_f64_cpy","readDouble_f64_rev","Float32Array","writeFloatLE","writeFloatBE","readFloatLE","readFloatBE","bind","writeUintLE","writeUintBE","readUintLE","readUintBE","Float64Array","writeDoubleLE","writeDoubleBE","readDoubleLE","readDoubleBE","inquire","moduleName","mod","eval","e","isAbsolute","path","normalize","split","absolute","prefix","shift","originPath","includePath","alreadyNormalized","alloc","size","SIZE","MAX","slab","utf8","len","read","write","c1","c2","common","commonRe","json","nested","google","Any","fields","type_url","type","id","Duration","timeType","seconds","nanos","Timestamp","Empty","Struct","keyType","Value","oneofs","kind","oneof","null_value","number_value","string_value","bool_value","struct_value","list_value","NullValue","values","NULL_VALUE","ListValue","rule","DoubleValue","FloatValue","Int64Value","UInt64Value","Int32Value","UInt32Value","BoolValue","StringValue","BytesValue","FieldMask","paths","get","file","Enum","genValuePartial_fromObject","gen","field","fieldIndex","prop","defaultAlreadyEmitted","resolvedType","typeDefault","repeated","fullName","isUnsigned","genValuePartial_toObject","converter","fromObject","mtype","fieldsArray","safeProp","map","toObject","sort","compareFieldsById","repeatedFields","mapFields","normalFields","partOf","arrayDefault","valuesById","long","low","high","unsigned","toNumber","bytes","hasKs2","_fieldsArray","indexOf","filter","group","ref","types","defaults","basic","packed","rfield","required","wireType","mapKey","genTypePartial","optional","ReflectionObject","Namespace","create","constructor","className","comment","comments","valuesOptions","TypeError","reserved","fromJSON","enm","toJSON","toJSONOptions","keepComments","Boolean","add","isString","isInteger","isReservedId","isReservedName","allow_alias","remove","Field","Type","ruleRe","extend","isObject","toLowerCase","message","defaultValue","extensionField","declaringField","_packed","defineProperty","getOption","setOption","ifNotSet","resolved","parent","lookupTypeOrEnum","proto3_optional","fromNumber","freeze","newBuffer","emptyObject","emptyArray","ctor","d","fieldId","fieldType","fieldRule","decorateType","decorateEnum","fieldName","default","_configure","Type_","build","load","root","Root","loadSync","encoder","decoder","verifier","OneOf","MapField","Service","Method","Message","wrappers","Writer","BufferWriter","Reader","BufferReader","rpc","roots","tokenize","parse","resolvedKeyType","fieldKeyType","fieldValueType","properties","$type","writer","encodeDelimited","reader","decodeDelimited","verify","object","requestType","requestStream","responseStream","parsedOptions","resolvedRequestType","resolvedResponseType","lookupType","arrayToJSON","array","obj","_nestedArray","clearCache","namespace","addJSON","toArray","nestedArray","nestedJson","names","methods","getProp","getEnum","prev","setOptions","onAdd","onRemove","isArray","ptr","part","resolveAll","lookup","filterTypes","parentAlreadyChecked","found","lookupEnum","lookupService","Service_","Enum_","defineProperties","unshift","_handleAdd","_handleRemove","setParsedOption","propName","opt","newOpt","find","hasOwnProperty","newValue","setProperty","Root_","fieldNames","addFieldsToParent","oneofName","oneOfGetter","set","oneOfSetter","keepCase","base10Re","base10NegRe","base16Re","base16NegRe","base8Re","base8NegRe","numberRe","nameRe","typeRefRe","fqTypeRefRe","pkg","imports","weakImports","syntax","token","whichImports","preferTrailingComment","tn","alternateCommentMode","next","peek","skip","cmnt","head","isProto3","applyCase","camelCase","illegal","insideTryCatch","line","readString","readValue","acceptTypeRef","parseNumber","substring","parseInt","parseFloat","readRanges","target","acceptStrings","parseId","dummy","ifBlock","parseOption","parseInlineOptions","acceptNegative","parseCommon","parseType","parseEnum","parseService","service","parseMethod","commentText","method","parseExtension","reference","parseField","fnIf","fnElse","trailingLine","parseMapField","valueType","extensions","parseGroup","lcFirst","ucFirst","endsWith","startsWith","parseEnumValue","isCustom","option","optionValue","parseOptionValue","objectResult","lastValue","prevValue","concat","simpleValue","package","LongBits","indexOutOfRange","writeLength","RangeError","Buffer","isBuffer","create_array","readLongVarint","bits","readFixed32_end","readFixed64","_slice","subarray","uint32","int32","sint32","bool","fixed32","sfixed32","float","double","nativeBuffer","skipType","BufferReader_","merge","int64","uint64","sint64","zzDecode","fixed64","sfixed64","utf8Slice","min","deferred","files","SYNC","resolvePath","self","sync","finish","cb","getBundledFileName","idx","lastIndexOf","altname","process","parsed","queued","weak","setTimeout","readFileSync","isNode","exposeRe","tryHandleExtension","sisterField","extendedType","parse_","common_","rpcImpl","requestDelimited","responseDelimited","rpcCall","requestCtor","responseCtor","request","endedByRPC","_methodsArray","inherited","methodsArray","rpcService","methodName","isReserved","m","q","s","delimRe","stringDoubleRe","stringSingleRe","setCommentRe","setCommentAltRe","setCommentSplitRe","whitespaceRe","unescapeRe","unescapeMap","0","r","unescape","str","lastCommentLine","stack","stringDelim","subject","charAt","setComment","isLeading","lineEmpty","leading","lookback","commentOffset","lines","trim","text","isDoubleSlashCommentLine","startOffset","endOffset","findEndOfLine","lineText","cursor","re","match","lastIndex","exec","repeat","curr","isDoc","isLeadingComment","expected","actual","ret","_fieldsById","_oneofsArray","_ctor","fieldsById","oneofsArray","generateConstructor","ctorProperties","setup","originalThis","wrapper","fork","ldelim","typeName","bake","o","safePropBackslashRe","key","safePropQuoteRe","camelCaseRe","toUpperCase","decorateEnumIndex","a","decorateRoot","enumerable","dst","setProp","zero","zzEncode","zeroHash","from","fromString","toLong","fromHash","hash","toHash","mask","part0","part1","part2","src","newError","CustomError","captureStackTrace","writable","configurable","pool","versions","node","window","isFinite","isset","isSet","utf8Write","_Buffer_from","_Buffer_allocUnsafe","sizeOrArray","dcodeIO","key2Re","key32Re","key64Re","longToHash","longFromHash","fromBits","ProtocolError","fieldMap","longs","enums","encoding","allocUnsafe","seenFirstField","oneofProp","invalid","genVerifyValue","messageName","Op","noop","State","tail","states","writeByte","VarintOp","writeVarint64","writeFixed32","_push","writeBytes","reset","BufferWriter_","writeStringBuffer","writeBytesBuffer","copy","byteLength"],"mappings":"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A,CACA,CACA,CACA,CACA,CAAA,EAEAT,EAAA,YAAA,CAUAc,UAAAH,CACA,CAAA,EAEAX,EAAA,QAAA,CAOAe,MAAA,CACAT,OAAA,EACA,CACA,CAAA,EAEAN,EAAA,SAAA,CASAgB,OAAA,CACAV,OAAA,CACAA,OAAA,CACAW,QAAA,SACAT,KAAA,QACAC,GAAA,CACA,CACA,CACA,EAeAS,MAAA,CACAC,OAAA,CACAC,KAAA,CACAC,MAAA,CACA,aACA,eACA,eACA,aACA,eACA,aAEA,CACA,EACAf,OAAA,CACAgB,WAAA,CACAd,KAAA,YACAC,GAAA,CACA,EACAc,aAAA,CACAf,KAAA,SACAC,GAAA,CACA,EACAe,aAAA,CACAhB,KAAA,SACAC,GAAA,CACA,EACAgB,WAAA,CACAjB,KAAA,OACAC,GAAA,CACA,EACAiB,aAAA,CACAlB,KAAA,SACAC,GAAA,CACA,EACAkB,WAAA,CACAnB,KAAA,YACAC,GAAA,CACA,CACA,CACA,EAEAmB,UAAA,CACAC,OAAA,CACAC,WAAA,CACA,CACA,EASAC,UAAA,CACAzB,OAAA,CACAuB,OAAA,CACAG,KAAA,WACAxB,KAAA,QACAC,GAAA,CACA,CACA,CACA,CACA,CAAA,EAEAT,EAAA,WAAA,CASAiC,YAAA,CACA3B,OAAA,CACAzH,MAAA,CACA2H,KAAA,SACAC,GAAA,CACA,CACA,CACA,EASAyB,WAAA,CACA5B,OAAA,CACAzH,MAAA,CACA2H,KAAA,QACAC,GAAA,CACA,CACA,CACA,EASA0B,WAAA,CACA7B,OAAA,CACAzH,MAAA,CACA2H,KAAA,QACAC,GAAA,CACA,CACA,CACA,EASA2B,YAAA,CACA9B,OAAA,CACAzH,MAAA,CACA2H,KAAA,SACAC,GAAA,CACA,CACA,CACA,EASA4B,WAAA,CACA/B,OAAA,CACAzH,MAAA,CACA2H,KAAA,QACAC,GAAA,CACA,CACA,CACA,EASA6B,YAAA,CACAhC,OAAA,CACAzH,MAAA,CACA2H,KAAA,SACAC,GAAA,CACA,CACA,CACA,EASA8B,UAAA,CACAjC,OAAA,CACAzH,MAAA,CACA2H,KA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","file":"protobuf.min.js","sourcesContent":["(function prelude(modules, cache, entries) {\n\n    // This is the prelude used to bundle protobuf.js for the browser. Wraps up the CommonJS\n    // sources through a conflict-free require shim and is again wrapped within an iife that\n    // provides a minification-friendly `undefined` var plus a global \"use strict\" directive\n    // so that minification can remove the directives of each module.\n\n    function $require(name) {\n        var $module = cache[name];\n        if (!$module)\n            modules[name][0].call($module = cache[name] = { exports: {} }, $require, $module, $module.exports);\n        return $module.exports;\n    }\n\n    var protobuf = $require(entries[0]);\n\n    // Expose globally\n    protobuf.util.global.protobuf = protobuf;\n\n    // Be nice to AMD\n    if (typeof define === \"function\" && define.amd)\n        define([\"long\"], function(Long) {\n            if (Long && Long.isLong) {\n                protobuf.util.Long = Long;\n                protobuf.configure();\n            }\n            return protobuf;\n        });\n\n    // Be nice to CommonJS\n    if (typeof module === \"object\" && module && module.exports)\n        module.exports = protobuf;\n\n})/* end of prelude */","\"use strict\";\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n","\"use strict\";\r\nmodule.exports = codegen;\r\n\r\n/**\r\n * Begins generating a function.\r\n * @memberof util\r\n * @param {string[]} functionParams Function parameter names\r\n * @param {string} [functionName] Function name if not anonymous\r\n * @returns {Codegen} Appender that appends code to the function's body\r\n */\r\nfunction codegen(functionParams, functionName) {\r\n\r\n    /* istanbul ignore if */\r\n    if (typeof functionParams === \"string\") {\r\n        functionName = functionParams;\r\n        functionParams = undefined;\r\n    }\r\n\r\n    var body = [];\r\n\r\n    /**\r\n     * Appends code to the function's body or finishes generation.\r\n     * @typedef Codegen\r\n     * @type {function}\r\n     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any\r\n     * @param {...*} [formatParams] Format parameters\r\n     * @returns {Codegen|Function} Itself or the generated function if finished\r\n     * @throws {Error} If format parameter counts do not match\r\n     */\r\n\r\n    function Codegen(formatStringOrScope) {\r\n        // note that explicit array handling below makes this ~50% faster\r\n\r\n        // finish the function\r\n        if (typeof formatStringOrScope !== \"string\") {\r\n            var source = toString();\r\n            if (codegen.verbose)\r\n                console.log(\"codegen: \" + source); // eslint-disable-line no-console\r\n            source = \"return \" + source;\r\n            if (formatStringOrScope) {\r\n                var scopeKeys   = Object.keys(formatStringOrScope),\r\n                    scopeParams = new Array(scopeKeys.length + 1),\r\n                    scopeValues = new Array(scopeKeys.length),\r\n                    scopeOffset = 0;\r\n                while (scopeOffset < scopeKeys.length) {\r\n                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];\r\n                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];\r\n                }\r\n                scopeParams[scopeOffset] = source;\r\n                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func\r\n            }\r\n            return Function(source)(); // eslint-disable-line no-new-func\r\n        }\r\n\r\n        // otherwise append to body\r\n        var formatParams = new Array(arguments.length - 1),\r\n            formatOffset = 0;\r\n        while (formatOffset < formatParams.length)\r\n            formatParams[formatOffset] = arguments[++formatOffset];\r\n        formatOffset = 0;\r\n        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {\r\n            var value = formatParams[formatOffset++];\r\n            switch ($1) {\r\n                case \"d\": case \"f\": return String(Number(value));\r\n                case \"i\": return String(Math.floor(value));\r\n                case \"j\": return JSON.stringify(value);\r\n                case \"s\": return String(value);\r\n            }\r\n            return \"%\";\r\n        });\r\n        if (formatOffset !== formatParams.length)\r\n            throw Error(\"parameter count mismatch\");\r\n        body.push(formatStringOrScope);\r\n        return Codegen;\r\n    }\r\n\r\n    function toString(functionNameOverride) {\r\n        return \"function \" + (functionNameOverride || functionName || \"\") + \"(\" + (functionParams && functionParams.join(\",\") || \"\") + \"){\\n  \" + body.join(\"\\n  \") + \"\\n}\";\r\n    }\r\n\r\n    Codegen.toString = toString;\r\n    return Codegen;\r\n}\r\n\r\n/**\r\n * Begins generating a function.\r\n * @memberof util\r\n * @function codegen\r\n * @param {string} [functionName] Function name if not anonymous\r\n * @returns {Codegen} Appender that appends code to the function's body\r\n * @variation 2\r\n */\r\n\r\n/**\r\n * When set to `true`, codegen will log generated code to console. Useful for debugging.\r\n * @name util.codegen.verbose\r\n * @type {boolean}\r\n */\r\ncodegen.verbose = false;\r\n","\"use strict\";\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n","\"use strict\";\r\nmodule.exports = fetch;\r\n\r\nvar asPromise = require(1),\r\n    inquire   = require(7);\r\n\r\nvar fs = inquire(\"fs\");\r\n\r\n/**\r\n * Node-style callback as used by {@link util.fetch}.\r\n * @typedef FetchCallback\r\n * @type {function}\r\n * @param {?Error} error Error, if any, otherwise `null`\r\n * @param {string} [contents] File contents, if there hasn't been an error\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Options as used by {@link util.fetch}.\r\n * @typedef FetchOptions\r\n * @type {Object}\r\n * @property {boolean} [binary=false] Whether expecting a binary response\r\n * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest\r\n */\r\n\r\n/**\r\n * Fetches the contents of a file.\r\n * @memberof util\r\n * @param {string} filename File path or url\r\n * @param {FetchOptions} options Fetch options\r\n * @param {FetchCallback} callback Callback function\r\n * @returns {undefined}\r\n */\r\nfunction fetch(filename, options, callback) {\r\n    if (typeof options === \"function\") {\r\n        callback = options;\r\n        options = {};\r\n    } else if (!options)\r\n        options = {};\r\n\r\n    if (!callback)\r\n        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this\r\n\r\n    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.\r\n    if (!options.xhr && fs && fs.readFile)\r\n        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {\r\n            return err && typeof XMLHttpRequest !== \"undefined\"\r\n                ? fetch.xhr(filename, options, callback)\r\n                : err\r\n                ? callback(err)\r\n                : callback(null, options.binary ? contents : contents.toString(\"utf8\"));\r\n        });\r\n\r\n    // use the XHR version otherwise.\r\n    return fetch.xhr(filename, options, callback);\r\n}\r\n\r\n/**\r\n * Fetches the contents of a file.\r\n * @name util.fetch\r\n * @function\r\n * @param {string} path File path or url\r\n * @param {FetchCallback} callback Callback function\r\n * @returns {undefined}\r\n * @variation 2\r\n */\r\n\r\n/**\r\n * Fetches the contents of a file.\r\n * @name util.fetch\r\n * @function\r\n * @param {string} path File path or url\r\n * @param {FetchOptions} [options] Fetch options\r\n * @returns {Promise<string|Uint8Array>} Promise\r\n * @variation 3\r\n */\r\n\r\n/**/\r\nfetch.xhr = function fetch_xhr(filename, options, callback) {\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {\r\n\r\n        if (xhr.readyState !== 4)\r\n            return undefined;\r\n\r\n        // local cors security errors return status 0 / empty string, too. afaik this cannot be\r\n        // reliably distinguished from an actually empty file for security reasons. feel free\r\n        // to send a pull request if you are aware of a solution.\r\n        if (xhr.status !== 0 && xhr.status !== 200)\r\n            return callback(Error(\"status \" + xhr.status));\r\n\r\n        // if binary data is expected, make sure that some sort of array is returned, even if\r\n        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.\r\n        if (options.binary) {\r\n            var buffer = xhr.response;\r\n            if (!buffer) {\r\n                buffer = [];\r\n                for (var i = 0; i < xhr.responseText.length; ++i)\r\n                    buffer.push(xhr.responseText.charCodeAt(i) & 255);\r\n            }\r\n            return callback(null, typeof Uint8Array !== \"undefined\" ? new Uint8Array(buffer) : buffer);\r\n        }\r\n        return callback(null, xhr.responseText);\r\n    };\r\n\r\n    if (options.binary) {\r\n        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers\r\n        if (\"overrideMimeType\" in xhr)\r\n            xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\r\n        xhr.responseType = \"arraybuffer\";\r\n    }\r\n\r\n    xhr.open(\"GET\", filename);\r\n    xhr.send();\r\n};\r\n","\"use strict\";\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n","\"use strict\";\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal path module to resolve Unix, Windows and URL paths alike.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar path = exports;\r\n\r\nvar isAbsolute =\r\n/**\r\n * Tests if the specified path is absolute.\r\n * @param {string} path Path to test\r\n * @returns {boolean} `true` if path is absolute\r\n */\r\npath.isAbsolute = function isAbsolute(path) {\r\n    return /^(?:\\/|\\w+:)/.test(path);\r\n};\r\n\r\nvar normalize =\r\n/**\r\n * Normalizes the specified path.\r\n * @param {string} path Path to normalize\r\n * @returns {string} Normalized path\r\n */\r\npath.normalize = function normalize(path) {\r\n    path = path.replace(/\\\\/g, \"/\")\r\n               .replace(/\\/{2,}/g, \"/\");\r\n    var parts    = path.split(\"/\"),\r\n        absolute = isAbsolute(path),\r\n        prefix   = \"\";\r\n    if (absolute)\r\n        prefix = parts.shift() + \"/\";\r\n    for (var i = 0; i < parts.length;) {\r\n        if (parts[i] === \"..\") {\r\n            if (i > 0 && parts[i - 1] !== \"..\")\r\n                parts.splice(--i, 2);\r\n            else if (absolute)\r\n                parts.splice(i, 1);\r\n            else\r\n                ++i;\r\n        } else if (parts[i] === \".\")\r\n            parts.splice(i, 1);\r\n        else\r\n            ++i;\r\n    }\r\n    return prefix + parts.join(\"/\");\r\n};\r\n\r\n/**\r\n * Resolves the specified include path against the specified origin path.\r\n * @param {string} originPath Path to the origin file\r\n * @param {string} includePath Include path relative to origin path\r\n * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized\r\n * @returns {string} Path to the include file\r\n */\r\npath.resolve = function resolve(originPath, includePath, alreadyNormalized) {\r\n    if (!alreadyNormalized)\r\n        includePath = normalize(includePath);\r\n    if (isAbsolute(includePath))\r\n        return includePath;\r\n    if (!alreadyNormalized)\r\n        originPath = normalize(originPath);\r\n    return (originPath = originPath.replace(/(?:\\/|^)[^/]+$/, \"\")).length ? normalize(originPath + \"/\" + includePath) : includePath;\r\n};\r\n","\"use strict\";\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n","\"use strict\";\nmodule.exports = common;\n\nvar commonRe = /\\/|\\./;\n\n/**\n * Provides common type definitions.\n * Can also be used to provide additional google types or your own custom types.\n * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name\n * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition\n * @returns {undefined}\n * @property {INamespace} google/protobuf/any.proto Any\n * @property {INamespace} google/protobuf/duration.proto Duration\n * @property {INamespace} google/protobuf/empty.proto Empty\n * @property {INamespace} google/protobuf/field_mask.proto FieldMask\n * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue\n * @property {INamespace} google/protobuf/timestamp.proto Timestamp\n * @property {INamespace} google/protobuf/wrappers.proto Wrappers\n * @example\n * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)\n * protobuf.common(\"descriptor\", descriptorJson);\n *\n * // manually provides a custom definition (uses my.foo namespace)\n * protobuf.common(\"my/foo/bar.proto\", myFooBarJson);\n */\nfunction common(name, json) {\n    if (!commonRe.test(name)) {\n        name = \"google/protobuf/\" + name + \".proto\";\n        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };\n    }\n    common[name] = json;\n}\n\n// Not provided because of limited use (feel free to discuss or to provide yourself):\n//\n// google/protobuf/descriptor.proto\n// google/protobuf/source_context.proto\n// google/protobuf/type.proto\n//\n// Stripped and pre-parsed versions of these non-bundled files are instead available as part of\n// the repository or package within the google/protobuf directory.\n\ncommon(\"any\", {\n\n    /**\n     * Properties of a google.protobuf.Any message.\n     * @interface IAny\n     * @type {Object}\n     * @property {string} [typeUrl]\n     * @property {Uint8Array} [bytes]\n     * @memberof common\n     */\n    Any: {\n        fields: {\n            type_url: {\n                type: \"string\",\n                id: 1\n            },\n            value: {\n                type: \"bytes\",\n                id: 2\n            }\n        }\n    }\n});\n\nvar timeType;\n\ncommon(\"duration\", {\n\n    /**\n     * Properties of a google.protobuf.Duration message.\n     * @interface IDuration\n     * @type {Object}\n     * @property {number|Long} [seconds]\n     * @property {number} [nanos]\n     * @memberof common\n     */\n    Duration: timeType = {\n        fields: {\n            seconds: {\n                type: \"int64\",\n                id: 1\n            },\n            nanos: {\n                type: \"int32\",\n                id: 2\n            }\n        }\n    }\n});\n\ncommon(\"timestamp\", {\n\n    /**\n     * Properties of a google.protobuf.Timestamp message.\n     * @interface ITimestamp\n     * @type {Object}\n     * @property {number|Long} [seconds]\n     * @property {number} [nanos]\n     * @memberof common\n     */\n    Timestamp: timeType\n});\n\ncommon(\"empty\", {\n\n    /**\n     * Properties of a google.protobuf.Empty message.\n     * @interface IEmpty\n     * @memberof common\n     */\n    Empty: {\n        fields: {}\n    }\n});\n\ncommon(\"struct\", {\n\n    /**\n     * Properties of a google.protobuf.Struct message.\n     * @interface IStruct\n     * @type {Object}\n     * @property {Object.<string,IValue>} [fields]\n     * @memberof common\n     */\n    Struct: {\n        fields: {\n            fields: {\n                keyType: \"string\",\n                type: \"Value\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.Value message.\n     * @interface IValue\n     * @type {Object}\n     * @property {string} [kind]\n     * @property {0} [null_value]\n     * @property {number} [number_value]\n     * @property {string} [string_value]\n     * @property {boolean} [bool_value]\n     * @property {IStruct} [struct_value]\n     * @property {IListValue} [list_value]\n     * @memberof common\n     */\n    Value: {\n        oneofs: {\n            kind: {\n                oneof: [\n                    \"null_value\",\n                    \"number_value\",\n                    \"string_value\",\n                    \"bool_value\",\n                    \"struct_value\",\n                    \"list_value\"\n                ]\n            }\n        },\n        fields: {\n            null_value: {\n                type: \"NullValue\",\n                id: 1\n            },\n            number_value: {\n                type: \"double\",\n                id: 2\n            },\n            string_value: {\n                type: \"string\",\n                id: 3\n            },\n            bool_value: {\n                type: \"bool\",\n                id: 4\n            },\n            struct_value: {\n                type: \"Struct\",\n                id: 5\n            },\n            list_value: {\n                type: \"ListValue\",\n                id: 6\n            }\n        }\n    },\n\n    NullValue: {\n        values: {\n            NULL_VALUE: 0\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.ListValue message.\n     * @interface IListValue\n     * @type {Object}\n     * @property {Array.<IValue>} [values]\n     * @memberof common\n     */\n    ListValue: {\n        fields: {\n            values: {\n                rule: \"repeated\",\n                type: \"Value\",\n                id: 1\n            }\n        }\n    }\n});\n\ncommon(\"wrappers\", {\n\n    /**\n     * Properties of a google.protobuf.DoubleValue message.\n     * @interface IDoubleValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */\n    DoubleValue: {\n        fields: {\n            value: {\n                type: \"double\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.FloatValue message.\n     * @interface IFloatValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */\n    FloatValue: {\n        fields: {\n            value: {\n                type: \"float\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.Int64Value message.\n     * @interface IInt64Value\n     * @type {Object}\n     * @property {number|Long} [value]\n     * @memberof common\n     */\n    Int64Value: {\n        fields: {\n            value: {\n                type: \"int64\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.UInt64Value message.\n     * @interface IUInt64Value\n     * @type {Object}\n     * @property {number|Long} [value]\n     * @memberof common\n     */\n    UInt64Value: {\n        fields: {\n            value: {\n                type: \"uint64\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.Int32Value message.\n     * @interface IInt32Value\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */\n    Int32Value: {\n        fields: {\n            value: {\n                type: \"int32\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.UInt32Value message.\n     * @interface IUInt32Value\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */\n    UInt32Value: {\n        fields: {\n            value: {\n                type: \"uint32\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.BoolValue message.\n     * @interface IBoolValue\n     * @type {Object}\n     * @property {boolean} [value]\n     * @memberof common\n     */\n    BoolValue: {\n        fields: {\n            value: {\n                type: \"bool\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.StringValue message.\n     * @interface IStringValue\n     * @type {Object}\n     * @property {string} [value]\n     * @memberof common\n     */\n    StringValue: {\n        fields: {\n            value: {\n                type: \"string\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.BytesValue message.\n     * @interface IBytesValue\n     * @type {Object}\n     * @property {Uint8Array} [value]\n     * @memberof common\n     */\n    BytesValue: {\n        fields: {\n            value: {\n                type: \"bytes\",\n                id: 1\n            }\n        }\n    }\n});\n\ncommon(\"field_mask\", {\n\n    /**\n     * Properties of a google.protobuf.FieldMask message.\n     * @interface IDoubleValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */\n    FieldMask: {\n        fields: {\n            paths: {\n                rule: \"repeated\",\n                type: \"string\",\n                id: 1\n            }\n        }\n    }\n});\n\n/**\n * Gets the root definition of the specified common proto file.\n *\n * Bundled definitions are:\n * - google/protobuf/any.proto\n * - google/protobuf/duration.proto\n * - google/protobuf/empty.proto\n * - google/protobuf/field_mask.proto\n * - google/protobuf/struct.proto\n * - google/protobuf/timestamp.proto\n * - google/protobuf/wrappers.proto\n *\n * @param {string} file Proto file name\n * @returns {INamespace|null} Root definition or `null` if not defined\n */\ncommon.get = function get(file) {\n    return common[file] || null;\n};\n","\"use strict\";\n/**\n * Runtime message from/to plain object converters.\n * @namespace\n */\nvar converter = exports;\n\nvar Enum = require(15),\n    util = require(37);\n\n/**\n * Generates a partial value fromObject conveter.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} prop Property reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genValuePartial_fromObject(gen, field, fieldIndex, prop) {\n    var defaultAlreadyEmitted = false;\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) { gen\n            (\"switch(d%s){\", prop);\n            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {\n                // enum unknown values passthrough\n                if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) { gen\n                    (\"default:\")\n                        (\"if(typeof(d%s)===\\\"number\\\"){m%s=d%s;break}\", prop, prop, prop);\n                    if (!field.repeated) gen // fallback to default value only for\n                                             // arrays, to avoid leaving holes.\n                        (\"break\");           // for non-repeated fields, just ignore\n                    defaultAlreadyEmitted = true;\n                }\n                gen\n                (\"case%j:\", keys[i])\n                (\"case %i:\", values[keys[i]])\n                    (\"m%s=%j\", prop, values[keys[i]])\n                    (\"break\");\n            } gen\n            (\"}\");\n        } else gen\n            (\"if(typeof d%s!==\\\"object\\\")\", prop)\n                (\"throw TypeError(%j)\", field.fullName + \": object expected\")\n            (\"m%s=types[%i].fromObject(d%s)\", prop, fieldIndex, prop);\n    } else {\n        var isUnsigned = false;\n        switch (field.type) {\n            case \"double\":\n            case \"float\": gen\n                (\"m%s=Number(d%s)\", prop, prop); // also catches \"NaN\", \"Infinity\"\n                break;\n            case \"uint32\":\n            case \"fixed32\": gen\n                (\"m%s=d%s>>>0\", prop, prop);\n                break;\n            case \"int32\":\n            case \"sint32\":\n            case \"sfixed32\": gen\n                (\"m%s=d%s|0\", prop, prop);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n                // eslint-disable-next-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\": gen\n                (\"if(util.Long)\")\n                    (\"(m%s=util.Long.fromValue(d%s)).unsigned=%j\", prop, prop, isUnsigned)\n                (\"else if(typeof d%s===\\\"string\\\")\", prop)\n                    (\"m%s=parseInt(d%s,10)\", prop, prop)\n                (\"else if(typeof d%s===\\\"number\\\")\", prop)\n                    (\"m%s=d%s\", prop, prop)\n                (\"else if(typeof d%s===\\\"object\\\")\", prop)\n                    (\"m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)\", prop, prop, prop, isUnsigned ? \"true\" : \"\");\n                break;\n            case \"bytes\": gen\n                (\"if(typeof d%s===\\\"string\\\")\", prop)\n                    (\"util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)\", prop, prop, prop)\n                (\"else if(d%s.length >= 0)\", prop)\n                    (\"m%s=d%s\", prop, prop);\n                break;\n            case \"string\": gen\n                (\"m%s=String(d%s)\", prop, prop);\n                break;\n            case \"bool\": gen\n                (\"m%s=Boolean(d%s)\", prop, prop);\n                break;\n            /* default: gen\n                (\"m%s=d%s\", prop, prop);\n                break; */\n        }\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}\n\n/**\n * Generates a plain object to runtime message converter specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nconverter.fromObject = function fromObject(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    var fields = mtype.fieldsArray;\n    var gen = util.codegen([\"d\"], mtype.name + \"$fromObject\")\n    (\"if(d instanceof this.ctor)\")\n        (\"return d\");\n    if (!fields.length) return gen\n    (\"return new this.ctor\");\n    gen\n    (\"var m=new this.ctor\");\n    for (var i = 0; i < fields.length; ++i) {\n        var field  = fields[i].resolve(),\n            prop   = util.safeProp(field.name);\n\n        // Map fields\n        if (field.map) { gen\n    (\"if(d%s){\", prop)\n        (\"if(typeof d%s!==\\\"object\\\")\", prop)\n            (\"throw TypeError(%j)\", field.fullName + \": object expected\")\n        (\"m%s={}\", prop)\n        (\"for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){\", prop);\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[ks[i]]\")\n        (\"}\")\n    (\"}\");\n\n        // Repeated fields\n        } else if (field.repeated) { gen\n    (\"if(d%s){\", prop)\n        (\"if(!Array.isArray(d%s))\", prop)\n            (\"throw TypeError(%j)\", field.fullName + \": array expected\")\n        (\"m%s=[]\", prop)\n        (\"for(var i=0;i<d%s.length;++i){\", prop);\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[i]\")\n        (\"}\")\n    (\"}\");\n\n        // Non-repeated fields\n        } else {\n            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)\n    (\"if(d%s!=null){\", prop); // !== undefined && !== null\n        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);\n            if (!(field.resolvedType instanceof Enum)) gen\n    (\"}\");\n        }\n    } return gen\n    (\"return m\");\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n};\n\n/**\n * Generates a partial value toObject converter.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} prop Property reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genValuePartial_toObject(gen, field, fieldIndex, prop) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) gen\n            (\"d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s\", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);\n        else gen\n            (\"d%s=types[%i].toObject(m%s,o)\", prop, fieldIndex, prop);\n    } else {\n        var isUnsigned = false;\n        switch (field.type) {\n            case \"double\":\n            case \"float\": gen\n            (\"d%s=o.json&&!isFinite(m%s)?String(m%s):m%s\", prop, prop, prop, prop);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n                // eslint-disable-next-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\": gen\n            (\"if(typeof m%s===\\\"number\\\")\", prop)\n                (\"d%s=o.longs===String?String(m%s):m%s\", prop, prop, prop)\n            (\"else\") // Long-like\n                (\"d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s\", prop, prop, prop, prop, isUnsigned ? \"true\": \"\", prop);\n                break;\n            case \"bytes\": gen\n            (\"d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s\", prop, prop, prop, prop, prop);\n                break;\n            default: gen\n            (\"d%s=m%s\", prop, prop);\n                break;\n        }\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}\n\n/**\n * Generates a runtime message to plain object converter specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nconverter.toObject = function toObject(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);\n    if (!fields.length)\n        return util.codegen()(\"return {}\");\n    var gen = util.codegen([\"m\", \"o\"], mtype.name + \"$toObject\")\n    (\"if(!o)\")\n        (\"o={}\")\n    (\"var d={}\");\n\n    var repeatedFields = [],\n        mapFields = [],\n        normalFields = [],\n        i = 0;\n    for (; i < fields.length; ++i)\n        if (!fields[i].partOf)\n            ( fields[i].resolve().repeated ? repeatedFields\n            : fields[i].map ? mapFields\n            : normalFields).push(fields[i]);\n\n    if (repeatedFields.length) { gen\n    (\"if(o.arrays||o.defaults){\");\n        for (i = 0; i < repeatedFields.length; ++i) gen\n        (\"d%s=[]\", util.safeProp(repeatedFields[i].name));\n        gen\n    (\"}\");\n    }\n\n    if (mapFields.length) { gen\n    (\"if(o.objects||o.defaults){\");\n        for (i = 0; i < mapFields.length; ++i) gen\n        (\"d%s={}\", util.safeProp(mapFields[i].name));\n        gen\n    (\"}\");\n    }\n\n    if (normalFields.length) { gen\n    (\"if(o.defaults){\");\n        for (i = 0; i < normalFields.length; ++i) {\n            var field = normalFields[i],\n                prop  = util.safeProp(field.name);\n            if (field.resolvedType instanceof Enum) gen\n        (\"d%s=o.enums===String?%j:%j\", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);\n            else if (field.long) gen\n        (\"if(util.Long){\")\n            (\"var n=new util.Long(%i,%i,%j)\", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)\n            (\"d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n\", prop)\n        (\"}else\")\n            (\"d%s=o.longs===String?%j:%i\", prop, field.typeDefault.toString(), field.typeDefault.toNumber());\n            else if (field.bytes) {\n                var arrayDefault = \"[\" + Array.prototype.slice.call(field.typeDefault).join(\",\") + \"]\";\n                gen\n        (\"if(o.bytes===String)d%s=%j\", prop, String.fromCharCode.apply(String, field.typeDefault))\n        (\"else{\")\n            (\"d%s=%s\", prop, arrayDefault)\n            (\"if(o.bytes!==Array)d%s=util.newBuffer(d%s)\", prop, prop)\n        (\"}\");\n            } else gen\n        (\"d%s=%j\", prop, field.typeDefault); // also messages (=null)\n        } gen\n    (\"}\");\n    }\n    var hasKs2 = false;\n    for (i = 0; i < fields.length; ++i) {\n        var field = fields[i],\n            index = mtype._fieldsArray.indexOf(field),\n            prop  = util.safeProp(field.name);\n        if (field.map) {\n            if (!hasKs2) { hasKs2 = true; gen\n    (\"var ks2\");\n            } gen\n    (\"if(m%s&&(ks2=Object.keys(m%s)).length){\", prop, prop)\n        (\"d%s={}\", prop)\n        (\"for(var j=0;j<ks2.length;++j){\");\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[ks2[j]]\")\n        (\"}\");\n        } else if (field.repeated) { gen\n    (\"if(m%s&&m%s.length){\", prop, prop)\n        (\"d%s=[]\", prop)\n        (\"for(var j=0;j<m%s.length;++j){\", prop);\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[j]\")\n        (\"}\");\n        } else { gen\n    (\"if(m%s!=null&&m.hasOwnProperty(%j)){\", prop, field.name); // !== undefined && !== null\n        genValuePartial_toObject(gen, field, /* sorted */ index, prop);\n        if (field.partOf) gen\n        (\"if(o.oneofs)\")\n            (\"d%s=%j\", util.safeProp(field.partOf.name), field.name);\n        }\n        gen\n    (\"}\");\n    }\n    return gen\n    (\"return d\");\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n};\n","\"use strict\";\nmodule.exports = decoder;\n\nvar Enum    = require(15),\n    types   = require(36),\n    util    = require(37);\n\nfunction missing(field) {\n    return \"missing required '\" + field.name + \"'\";\n}\n\n/**\n * Generates a decoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction decoder(mtype) {\n    /* eslint-disable no-unexpected-multiline */\n    var gen = util.codegen([\"r\", \"l\"], mtype.name + \"$decode\")\n    (\"if(!(r instanceof Reader))\")\n        (\"r=Reader.create(r)\")\n    (\"var c=l===undefined?r.len:r.pos+l,m=new this.ctor\" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? \",k,value\" : \"\"))\n    (\"while(r.pos<c){\")\n        (\"var t=r.uint32()\");\n    if (mtype.group) gen\n        (\"if((t&7)===4)\")\n            (\"break\");\n    gen\n        (\"switch(t>>>3){\");\n\n    var i = 0;\n    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {\n        var field = mtype._fieldsArray[i].resolve(),\n            type  = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n            ref   = \"m\" + util.safeProp(field.name); gen\n            (\"case %i: {\", field.id);\n\n        // Map fields\n        if (field.map) { gen\n                (\"if(%s===util.emptyObject)\", ref)\n                    (\"%s={}\", ref)\n                (\"var c2 = r.uint32()+r.pos\");\n\n            if (types.defaults[field.keyType] !== undefined) gen\n                (\"k=%j\", types.defaults[field.keyType]);\n            else gen\n                (\"k=null\");\n\n            if (types.defaults[type] !== undefined) gen\n                (\"value=%j\", types.defaults[type]);\n            else gen\n                (\"value=null\");\n\n            gen\n                (\"while(r.pos<c2){\")\n                    (\"var tag2=r.uint32()\")\n                    (\"switch(tag2>>>3){\")\n                        (\"case 1: k=r.%s(); break\", field.keyType)\n                        (\"case 2:\");\n\n            if (types.basic[type] === undefined) gen\n                            (\"value=types[%i].decode(r,r.uint32())\", i); // can't be groups\n            else gen\n                            (\"value=r.%s()\", type);\n\n            gen\n                            (\"break\")\n                        (\"default:\")\n                            (\"r.skipType(tag2&7)\")\n                            (\"break\")\n                    (\"}\")\n                (\"}\");\n\n            if (types.long[field.keyType] !== undefined) gen\n                (\"%s[typeof k===\\\"object\\\"?util.longToHash(k):k]=value\", ref);\n            else gen\n                (\"%s[k]=value\", ref);\n\n        // Repeated fields\n        } else if (field.repeated) { gen\n\n                (\"if(!(%s&&%s.length))\", ref, ref)\n                    (\"%s=[]\", ref);\n\n            // Packable (always check for forward and backward compatiblity)\n            if (types.packed[type] !== undefined) gen\n                (\"if((t&7)===2){\")\n                    (\"var c2=r.uint32()+r.pos\")\n                    (\"while(r.pos<c2)\")\n                        (\"%s.push(r.%s())\", ref, type)\n                (\"}else\");\n\n            // Non-packed\n            if (types.basic[type] === undefined) gen(field.resolvedType.group\n                    ? \"%s.push(types[%i].decode(r))\"\n                    : \"%s.push(types[%i].decode(r,r.uint32()))\", ref, i);\n            else gen\n                    (\"%s.push(r.%s())\", ref, type);\n\n        // Non-repeated\n        } else if (types.basic[type] === undefined) gen(field.resolvedType.group\n                ? \"%s=types[%i].decode(r)\"\n                : \"%s=types[%i].decode(r,r.uint32())\", ref, i);\n        else gen\n                (\"%s=r.%s()\", ref, type);\n        gen\n                (\"break\")\n            (\"}\");\n        // Unknown fields\n    } gen\n            (\"default:\")\n                (\"r.skipType(t&7)\")\n                (\"break\")\n\n        (\"}\")\n    (\"}\");\n\n    // Field presence\n    for (i = 0; i < mtype._fieldsArray.length; ++i) {\n        var rfield = mtype._fieldsArray[i];\n        if (rfield.required) gen\n    (\"if(!m.hasOwnProperty(%j))\", rfield.name)\n        (\"throw util.ProtocolError(%j,{instance:m})\", missing(rfield));\n    }\n\n    return gen\n    (\"return m\");\n    /* eslint-enable no-unexpected-multiline */\n}\n","\"use strict\";\nmodule.exports = encoder;\n\nvar Enum     = require(15),\n    types    = require(36),\n    util     = require(37);\n\n/**\n * Generates a partial message type encoder.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genTypePartial(gen, field, fieldIndex, ref) {\n    return field.resolvedType.group\n        ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)\n        : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\n}\n\n/**\n * Generates an encoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction encoder(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    var gen = util.codegen([\"m\", \"w\"], mtype.name + \"$encode\")\n    (\"if(!w)\")\n        (\"w=Writer.create()\");\n\n    var i, ref;\n\n    // \"when a message is serialized its known fields should be written sequentially by field number\"\n    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);\n\n    for (var i = 0; i < fields.length; ++i) {\n        var field    = fields[i].resolve(),\n            index    = mtype._fieldsArray.indexOf(field),\n            type     = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n            wireType = types.basic[type];\n            ref      = \"m\" + util.safeProp(field.name);\n\n        // Map fields\n        if (field.map) {\n            gen\n    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j)){\", ref, field.name) // !== undefined && !== null\n        (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)\n            (\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\n            if (wireType === undefined) gen\n            (\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\n            else gen\n            (\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\n            gen\n        (\"}\")\n    (\"}\");\n\n            // Repeated fields\n        } else if (field.repeated) { gen\n    (\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\n\n            // Packed repeated\n            if (field.packed && types.packed[type] !== undefined) { gen\n\n        (\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)\n        (\"for(var i=0;i<%s.length;++i)\", ref)\n            (\"w.%s(%s[i])\", type, ref)\n        (\"w.ldelim()\");\n\n            // Non-packed\n            } else { gen\n\n        (\"for(var i=0;i<%s.length;++i)\", ref);\n                if (wireType === undefined)\n            genTypePartial(gen, field, index, ref + \"[i]\");\n                else gen\n            (\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\n\n            } gen\n    (\"}\");\n\n        // Non-repeated\n        } else {\n            if (field.optional) gen\n    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j))\", ref, field.name); // !== undefined && !== null\n\n            if (wireType === undefined)\n        genTypePartial(gen, field, index, ref);\n            else gen\n        (\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\n\n        }\n    }\n\n    return gen\n    (\"return w\");\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}\n","\"use strict\";\nmodule.exports = Enum;\n\n// extends ReflectionObject\nvar ReflectionObject = require(24);\n((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = \"Enum\";\n\nvar Namespace = require(23),\n    util = require(37);\n\n/**\n * Constructs a new enum instance.\n * @classdesc Reflected enum.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {Object.<string,number>} [values] Enum values as an object, by name\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this enum\n * @param {Object.<string,string>} [comments] The value comments for this enum\n * @param {Object.<string,Object<string,*>>|undefined} [valuesOptions] The value options for this enum\n */\nfunction Enum(name, values, options, comment, comments, valuesOptions) {\n    ReflectionObject.call(this, name, options);\n\n    if (values && typeof values !== \"object\")\n        throw TypeError(\"values must be an object\");\n\n    /**\n     * Enum values by id.\n     * @type {Object.<number,string>}\n     */\n    this.valuesById = {};\n\n    /**\n     * Enum values by name.\n     * @type {Object.<string,number>}\n     */\n    this.values = Object.create(this.valuesById); // toJSON, marker\n\n    /**\n     * Enum comment text.\n     * @type {string|null}\n     */\n    this.comment = comment;\n\n    /**\n     * Value comment texts, if any.\n     * @type {Object.<string,string>}\n     */\n    this.comments = comments || {};\n\n    /**\n     * Values options, if any\n     * @type {Object<string, Object<string, *>>|undefined}\n     */\n    this.valuesOptions = valuesOptions;\n\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */\n    this.reserved = undefined; // toJSON\n\n    // Note that values inherit valuesById on their prototype which makes them a TypeScript-\n    // compatible enum. This is used by pbts to write actual enum definitions that work for\n    // static and reflection code alike instead of emitting generic object definitions.\n\n    if (values)\n        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)\n            if (typeof values[keys[i]] === \"number\") // use forward entries only\n                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];\n}\n\n/**\n * Enum descriptor.\n * @interface IEnum\n * @property {Object.<string,number>} values Enum values\n * @property {Object.<string,*>} [options] Enum options\n */\n\n/**\n * Constructs an enum from an enum descriptor.\n * @param {string} name Enum name\n * @param {IEnum} json Enum descriptor\n * @returns {Enum} Created enum\n * @throws {TypeError} If arguments are invalid\n */\nEnum.fromJSON = function fromJSON(name, json) {\n    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);\n    enm.reserved = json.reserved;\n    return enm;\n};\n\n/**\n * Converts this enum to an enum descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IEnum} Enum descriptor\n */\nEnum.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\"       , this.options,\n        \"valuesOptions\" , this.valuesOptions,\n        \"values\"        , this.values,\n        \"reserved\"      , this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"comment\"       , keepComments ? this.comment : undefined,\n        \"comments\"      , keepComments ? this.comments : undefined\n    ]);\n};\n\n/**\n * Adds a value to this enum.\n * @param {string} name Value name\n * @param {number} id Value id\n * @param {string} [comment] Comment, if any\n * @param {Object.<string, *>|undefined} [options] Options, if any\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a value with this name or id\n */\nEnum.prototype.add = function add(name, id, comment, options) {\n    // utilized by the parser but not by .fromJSON\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    if (!util.isInteger(id))\n        throw TypeError(\"id must be an integer\");\n\n    if (this.values[name] !== undefined)\n        throw Error(\"duplicate name '\" + name + \"' in \" + this);\n\n    if (this.isReservedId(id))\n        throw Error(\"id \" + id + \" is reserved in \" + this);\n\n    if (this.isReservedName(name))\n        throw Error(\"name '\" + name + \"' is reserved in \" + this);\n\n    if (this.valuesById[id] !== undefined) {\n        if (!(this.options && this.options.allow_alias))\n            throw Error(\"duplicate id \" + id + \" in \" + this);\n        this.values[name] = id;\n    } else\n        this.valuesById[this.values[name] = id] = name;\n\n    if (options) {\n        if (this.valuesOptions === undefined)\n            this.valuesOptions = {};\n        this.valuesOptions[name] = options || null;\n    }\n\n    this.comments[name] = comment || null;\n    return this;\n};\n\n/**\n * Removes a value from this enum\n * @param {string} name Value name\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `name` is not a name of this enum\n */\nEnum.prototype.remove = function remove(name) {\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    var val = this.values[name];\n    if (val == null)\n        throw Error(\"name '\" + name + \"' does not exist in \" + this);\n\n    delete this.valuesById[val];\n    delete this.values[name];\n    delete this.comments[name];\n    if (this.valuesOptions)\n        delete this.valuesOptions[name];\n\n    return this;\n};\n\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nEnum.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nEnum.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n","\"use strict\";\nmodule.exports = Field;\n\n// extends ReflectionObject\nvar ReflectionObject = require(24);\n((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = \"Field\";\n\nvar Enum  = require(15),\n    types = require(36),\n    util  = require(37);\n\nvar Type; // cyclic\n\nvar ruleRe = /^required|optional|repeated$/;\n\n/**\n * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.\n * @name Field\n * @classdesc Reflected message field.\n * @extends FieldBase\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} type Value type\n * @param {string|Object.<string,*>} [rule=\"optional\"] Field rule\n * @param {string|Object.<string,*>} [extend] Extended type if different from parent\n * @param {Object.<string,*>} [options] Declared options\n */\n\n/**\n * Constructs a field from a field descriptor.\n * @param {string} name Field name\n * @param {IField} json Field descriptor\n * @returns {Field} Created field\n * @throws {TypeError} If arguments are invalid\n */\nField.fromJSON = function fromJSON(name, json) {\n    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);\n};\n\n/**\n * Not an actual constructor. Use {@link Field} instead.\n * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports FieldBase\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} type Value type\n * @param {string|Object.<string,*>} [rule=\"optional\"] Field rule\n * @param {string|Object.<string,*>} [extend] Extended type if different from parent\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */\nfunction Field(name, id, type, rule, extend, options, comment) {\n\n    if (util.isObject(rule)) {\n        comment = extend;\n        options = rule;\n        rule = extend = undefined;\n    } else if (util.isObject(extend)) {\n        comment = options;\n        options = extend;\n        extend = undefined;\n    }\n\n    ReflectionObject.call(this, name, options);\n\n    if (!util.isInteger(id) || id < 0)\n        throw TypeError(\"id must be a non-negative integer\");\n\n    if (!util.isString(type))\n        throw TypeError(\"type must be a string\");\n\n    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))\n        throw TypeError(\"rule must be a string rule\");\n\n    if (extend !== undefined && !util.isString(extend))\n        throw TypeError(\"extend must be a string\");\n\n    /**\n     * Field rule, if any.\n     * @type {string|undefined}\n     */\n    if (rule === \"proto3_optional\") {\n        rule = \"optional\";\n    }\n    this.rule = rule && rule !== \"optional\" ? rule : undefined; // toJSON\n\n    /**\n     * Field type.\n     * @type {string}\n     */\n    this.type = type; // toJSON\n\n    /**\n     * Unique field id.\n     * @type {number}\n     */\n    this.id = id; // toJSON, marker\n\n    /**\n     * Extended type if different from parent.\n     * @type {string|undefined}\n     */\n    this.extend = extend || undefined; // toJSON\n\n    /**\n     * Whether this field is required.\n     * @type {boolean}\n     */\n    this.required = rule === \"required\";\n\n    /**\n     * Whether this field is optional.\n     * @type {boolean}\n     */\n    this.optional = !this.required;\n\n    /**\n     * Whether this field is repeated.\n     * @type {boolean}\n     */\n    this.repeated = rule === \"repeated\";\n\n    /**\n     * Whether this field is a map or not.\n     * @type {boolean}\n     */\n    this.map = false;\n\n    /**\n     * Message this field belongs to.\n     * @type {Type|null}\n     */\n    this.message = null;\n\n    /**\n     * OneOf this field belongs to, if any,\n     * @type {OneOf|null}\n     */\n    this.partOf = null;\n\n    /**\n     * The field type's default value.\n     * @type {*}\n     */\n    this.typeDefault = null;\n\n    /**\n     * The field's default value on prototypes.\n     * @type {*}\n     */\n    this.defaultValue = null;\n\n    /**\n     * Whether this field's value should be treated as a long.\n     * @type {boolean}\n     */\n    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;\n\n    /**\n     * Whether this field's value is a buffer.\n     * @type {boolean}\n     */\n    this.bytes = type === \"bytes\";\n\n    /**\n     * Resolved type if not a basic type.\n     * @type {Type|Enum|null}\n     */\n    this.resolvedType = null;\n\n    /**\n     * Sister-field within the extended type if a declaring extension field.\n     * @type {Field|null}\n     */\n    this.extensionField = null;\n\n    /**\n     * Sister-field within the declaring namespace if an extended field.\n     * @type {Field|null}\n     */\n    this.declaringField = null;\n\n    /**\n     * Internally remembers whether this field is packed.\n     * @type {boolean|null}\n     * @private\n     */\n    this._packed = null;\n\n    /**\n     * Comment for this field.\n     * @type {string|null}\n     */\n    this.comment = comment;\n}\n\n/**\n * Determines whether this field is packed. Only relevant when repeated and working with proto2.\n * @name Field#packed\n * @type {boolean}\n * @readonly\n */\nObject.defineProperty(Field.prototype, \"packed\", {\n    get: function() {\n        // defaults to packed=true if not explicity set to false\n        if (this._packed === null)\n            this._packed = this.getOption(\"packed\") !== false;\n        return this._packed;\n    }\n});\n\n/**\n * @override\n */\nField.prototype.setOption = function setOption(name, value, ifNotSet) {\n    if (name === \"packed\") // clear cached before setting\n        this._packed = null;\n    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);\n};\n\n/**\n * Field descriptor.\n * @interface IField\n * @property {string} [rule=\"optional\"] Field rule\n * @property {string} type Field type\n * @property {number} id Field id\n * @property {Object.<string,*>} [options] Field options\n */\n\n/**\n * Extension field descriptor.\n * @interface IExtensionField\n * @extends IField\n * @property {string} extend Extended type\n */\n\n/**\n * Converts this field to a field descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IField} Field descriptor\n */\nField.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"rule\"    , this.rule !== \"optional\" && this.rule || undefined,\n        \"type\"    , this.type,\n        \"id\"      , this.id,\n        \"extend\"  , this.extend,\n        \"options\" , this.options,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * Resolves this field's type references.\n * @returns {Field} `this`\n * @throws {Error} If any reference cannot be resolved\n */\nField.prototype.resolve = function resolve() {\n\n    if (this.resolved)\n        return this;\n\n    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it\n        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);\n        if (this.resolvedType instanceof Type)\n            this.typeDefault = null;\n        else // instanceof Enum\n            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined\n    } else if (this.options && this.options.proto3_optional) {\n        // proto3 scalar value marked optional; should default to null\n        this.typeDefault = null;\n    }\n\n    // use explicitly set default value if present\n    if (this.options && this.options[\"default\"] != null) {\n        this.typeDefault = this.options[\"default\"];\n        if (this.resolvedType instanceof Enum && typeof this.typeDefault === \"string\")\n            this.typeDefault = this.resolvedType.values[this.typeDefault];\n    }\n\n    // remove unnecessary options\n    if (this.options) {\n        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))\n            delete this.options.packed;\n        if (!Object.keys(this.options).length)\n            this.options = undefined;\n    }\n\n    // convert to internal data type if necesssary\n    if (this.long) {\n        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === \"u\");\n\n        /* istanbul ignore else */\n        if (Object.freeze)\n            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)\n\n    } else if (this.bytes && typeof this.typeDefault === \"string\") {\n        var buf;\n        if (util.base64.test(this.typeDefault))\n            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);\n        else\n            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);\n        this.typeDefault = buf;\n    }\n\n    // take special care of maps and repeated fields\n    if (this.map)\n        this.defaultValue = util.emptyObject;\n    else if (this.repeated)\n        this.defaultValue = util.emptyArray;\n    else\n        this.defaultValue = this.typeDefault;\n\n    // ensure proper value on prototype\n    if (this.parent instanceof Type)\n        this.parent.ctor.prototype[this.name] = this.defaultValue;\n\n    return ReflectionObject.prototype.resolve.call(this);\n};\n\n/**\n * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).\n * @typedef FieldDecorator\n * @type {function}\n * @param {Object} prototype Target prototype\n * @param {string} fieldName Field name\n * @returns {undefined}\n */\n\n/**\n * Field decorator (TypeScript).\n * @name Field.d\n * @function\n * @param {number} fieldId Field id\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"string\"|\"bool\"|\"bytes\"|Object} fieldType Field type\n * @param {\"optional\"|\"required\"|\"repeated\"} [fieldRule=\"optional\"] Field rule\n * @param {T} [defaultValue] Default value\n * @returns {FieldDecorator} Decorator function\n * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]\n */\nField.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {\n\n    // submessage: decorate the submessage and use its name as the type\n    if (typeof fieldType === \"function\")\n        fieldType = util.decorateType(fieldType).name;\n\n    // enum reference: create a reflected copy of the enum and keep reuseing it\n    else if (fieldType && typeof fieldType === \"object\")\n        fieldType = util.decorateEnum(fieldType).name;\n\n    return function fieldDecorator(prototype, fieldName) {\n        util.decorateType(prototype.constructor)\n            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { \"default\": defaultValue }));\n    };\n};\n\n/**\n * Field decorator (TypeScript).\n * @name Field.d\n * @function\n * @param {number} fieldId Field id\n * @param {Constructor<T>|string} fieldType Field type\n * @param {\"optional\"|\"required\"|\"repeated\"} [fieldRule=\"optional\"] Field rule\n * @returns {FieldDecorator} Decorator function\n * @template T extends Message<T>\n * @variation 2\n */\n// like Field.d but without a default value\n\n// Sets up cyclic dependencies (called in index-light)\nField._configure = function configure(Type_) {\n    Type = Type_;\n};\n","\"use strict\";\nvar protobuf = module.exports = require(18);\n\nprotobuf.build = \"light\";\n\n/**\n * A node-style callback as used by {@link load} and {@link Root#load}.\n * @typedef LoadCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Root} [root] Root, if there hasn't been an error\n * @returns {undefined}\n */\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} root Root namespace, defaults to create a new one if omitted.\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @see {@link Root#load}\n */\nfunction load(filename, root, callback) {\n    if (typeof root === \"function\") {\n        callback = root;\n        root = new protobuf.Root();\n    } else if (!root)\n        root = new protobuf.Root();\n    return root.load(filename, callback);\n}\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.\n * @name load\n * @function\n * @param {string|string[]} filename One or multiple files to load\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @see {@link Root#load}\n * @variation 2\n */\n// function load(filename:string, callback:LoadCallback):undefined\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.\n * @name load\n * @function\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted.\n * @returns {Promise<Root>} Promise\n * @see {@link Root#load}\n * @variation 3\n */\n// function load(filename:string, [root:Root]):Promise<Root>\n\nprotobuf.load = load;\n\n/**\n * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted.\n * @returns {Root} Root namespace\n * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid\n * @see {@link Root#loadSync}\n */\nfunction loadSync(filename, root) {\n    if (!root)\n        root = new protobuf.Root();\n    return root.loadSync(filename);\n}\n\nprotobuf.loadSync = loadSync;\n\n// Serialization\nprotobuf.encoder          = require(14);\nprotobuf.decoder          = require(13);\nprotobuf.verifier         = require(40);\nprotobuf.converter        = require(12);\n\n// Reflection\nprotobuf.ReflectionObject = require(24);\nprotobuf.Namespace        = require(23);\nprotobuf.Root             = require(29);\nprotobuf.Enum             = require(15);\nprotobuf.Type             = require(35);\nprotobuf.Field            = require(16);\nprotobuf.OneOf            = require(25);\nprotobuf.MapField         = require(20);\nprotobuf.Service          = require(33);\nprotobuf.Method           = require(22);\n\n// Runtime\nprotobuf.Message          = require(21);\nprotobuf.wrappers         = require(41);\n\n// Utility\nprotobuf.types            = require(36);\nprotobuf.util             = require(37);\n\n// Set up possibly cyclic reflection dependencies\nprotobuf.ReflectionObject._configure(protobuf.Root);\nprotobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);\nprotobuf.Root._configure(protobuf.Type);\nprotobuf.Field._configure(protobuf.Type);\n","\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(42);\nprotobuf.BufferWriter = require(43);\nprotobuf.Reader       = require(27);\nprotobuf.BufferReader = require(28);\n\n// Utility\nprotobuf.util         = require(39);\nprotobuf.rpc          = require(31);\nprotobuf.roots        = require(30);\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n","\"use strict\";\nvar protobuf = module.exports = require(17);\n\nprotobuf.build = \"full\";\n\n// Parser\nprotobuf.tokenize         = require(34);\nprotobuf.parse            = require(26);\nprotobuf.common           = require(11);\n\n// Configure parser\nprotobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);\n","\"use strict\";\nmodule.exports = MapField;\n\n// extends Field\nvar Field = require(16);\n((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = \"MapField\";\n\nvar types   = require(36),\n    util    = require(37);\n\n/**\n * Constructs a new map field instance.\n * @classdesc Reflected map field.\n * @extends FieldBase\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} keyType Key type\n * @param {string} type Value type\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */\nfunction MapField(name, id, keyType, type, options, comment) {\n    Field.call(this, name, id, type, undefined, undefined, options, comment);\n\n    /* istanbul ignore if */\n    if (!util.isString(keyType))\n        throw TypeError(\"keyType must be a string\");\n\n    /**\n     * Key type.\n     * @type {string}\n     */\n    this.keyType = keyType; // toJSON, marker\n\n    /**\n     * Resolved key type if not a basic type.\n     * @type {ReflectionObject|null}\n     */\n    this.resolvedKeyType = null;\n\n    // Overrides Field#map\n    this.map = true;\n}\n\n/**\n * Map field descriptor.\n * @interface IMapField\n * @extends {IField}\n * @property {string} keyType Key type\n */\n\n/**\n * Extension map field descriptor.\n * @interface IExtensionMapField\n * @extends IMapField\n * @property {string} extend Extended type\n */\n\n/**\n * Constructs a map field from a map field descriptor.\n * @param {string} name Field name\n * @param {IMapField} json Map field descriptor\n * @returns {MapField} Created map field\n * @throws {TypeError} If arguments are invalid\n */\nMapField.fromJSON = function fromJSON(name, json) {\n    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);\n};\n\n/**\n * Converts this map field to a map field descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMapField} Map field descriptor\n */\nMapField.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"keyType\" , this.keyType,\n        \"type\"    , this.type,\n        \"id\"      , this.id,\n        \"extend\"  , this.extend,\n        \"options\" , this.options,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * @override\n */\nMapField.prototype.resolve = function resolve() {\n    if (this.resolved)\n        return this;\n\n    // Besides a value type, map fields have a key type that may be \"any scalar type except for floating point types and bytes\"\n    if (types.mapKey[this.keyType] === undefined)\n        throw Error(\"invalid key type: \" + this.keyType);\n\n    return Field.prototype.resolve.call(this);\n};\n\n/**\n * Map field decorator (TypeScript).\n * @name MapField.d\n * @function\n * @param {number} fieldId Field id\n * @param {\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"} fieldKeyType Field key type\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"|\"bytes\"|Object|Constructor<{}>} fieldValueType Field value type\n * @returns {FieldDecorator} Decorator function\n * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }\n */\nMapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {\n\n    // submessage value: decorate the submessage and use its name as the type\n    if (typeof fieldValueType === \"function\")\n        fieldValueType = util.decorateType(fieldValueType).name;\n\n    // enum reference value: create a reflected copy of the enum and keep reuseing it\n    else if (fieldValueType && typeof fieldValueType === \"object\")\n        fieldValueType = util.decorateEnum(fieldValueType).name;\n\n    return function mapFieldDecorator(prototype, fieldName) {\n        util.decorateType(prototype.constructor)\n            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));\n    };\n};\n","\"use strict\";\nmodule.exports = Message;\n\nvar util = require(39);\n\n/**\n * Constructs a new message instance.\n * @classdesc Abstract runtime message.\n * @constructor\n * @param {Properties<T>} [properties] Properties to set\n * @template T extends object = object\n */\nfunction Message(properties) {\n    // not used internally\n    if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            this[keys[i]] = properties[keys[i]];\n}\n\n/**\n * Reference to the reflected type.\n * @name Message.$type\n * @type {Type}\n * @readonly\n */\n\n/**\n * Reference to the reflected type.\n * @name Message#$type\n * @type {Type}\n * @readonly\n */\n\n/*eslint-disable valid-jsdoc*/\n\n/**\n * Creates a new message of this type using the specified properties.\n * @param {Object.<string,*>} [properties] Properties to set\n * @returns {Message<T>} Message instance\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.create = function create(properties) {\n    return this.$type.create(properties);\n};\n\n/**\n * Encodes a message of this type.\n * @param {T|Object.<string,*>} message Message to encode\n * @param {Writer} [writer] Writer to use\n * @returns {Writer} Writer\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.encode = function encode(message, writer) {\n    return this.$type.encode(message, writer);\n};\n\n/**\n * Encodes a message of this type preceeded by its length as a varint.\n * @param {T|Object.<string,*>} message Message to encode\n * @param {Writer} [writer] Writer to use\n * @returns {Writer} Writer\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.$type.encodeDelimited(message, writer);\n};\n\n/**\n * Decodes a message of this type.\n * @name Message.decode\n * @function\n * @param {Reader|Uint8Array} reader Reader or buffer to decode\n * @returns {T} Decoded message\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.decode = function decode(reader) {\n    return this.$type.decode(reader);\n};\n\n/**\n * Decodes a message of this type preceeded by its length as a varint.\n * @name Message.decodeDelimited\n * @function\n * @param {Reader|Uint8Array} reader Reader or buffer to decode\n * @returns {T} Decoded message\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.decodeDelimited = function decodeDelimited(reader) {\n    return this.$type.decodeDelimited(reader);\n};\n\n/**\n * Verifies a message of this type.\n * @name Message.verify\n * @function\n * @param {Object.<string,*>} message Plain object to verify\n * @returns {string|null} `null` if valid, otherwise the reason why it is not\n */\nMessage.verify = function verify(message) {\n    return this.$type.verify(message);\n};\n\n/**\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n * @param {Object.<string,*>} object Plain object\n * @returns {T} Message instance\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.fromObject = function fromObject(object) {\n    return this.$type.fromObject(object);\n};\n\n/**\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\n * @param {T} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.toObject = function toObject(message, options) {\n    return this.$type.toObject(message, options);\n};\n\n/**\n * Converts this message to JSON.\n * @returns {Object.<string,*>} JSON object\n */\nMessage.prototype.toJSON = function toJSON() {\n    return this.$type.toObject(this, util.toJSONOptions);\n};\n\n/*eslint-enable valid-jsdoc*/","\"use strict\";\nmodule.exports = Method;\n\n// extends ReflectionObject\nvar ReflectionObject = require(24);\n((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = \"Method\";\n\nvar util = require(37);\n\n/**\n * Constructs a new service method instance.\n * @classdesc Reflected service method.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Method name\n * @param {string|undefined} type Method type, usually `\"rpc\"`\n * @param {string} requestType Request message type\n * @param {string} responseType Response message type\n * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed\n * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this method\n * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object\n */\nfunction Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {\n\n    /* istanbul ignore next */\n    if (util.isObject(requestStream)) {\n        options = requestStream;\n        requestStream = responseStream = undefined;\n    } else if (util.isObject(responseStream)) {\n        options = responseStream;\n        responseStream = undefined;\n    }\n\n    /* istanbul ignore if */\n    if (!(type === undefined || util.isString(type)))\n        throw TypeError(\"type must be a string\");\n\n    /* istanbul ignore if */\n    if (!util.isString(requestType))\n        throw TypeError(\"requestType must be a string\");\n\n    /* istanbul ignore if */\n    if (!util.isString(responseType))\n        throw TypeError(\"responseType must be a string\");\n\n    ReflectionObject.call(this, name, options);\n\n    /**\n     * Method type.\n     * @type {string}\n     */\n    this.type = type || \"rpc\"; // toJSON\n\n    /**\n     * Request type.\n     * @type {string}\n     */\n    this.requestType = requestType; // toJSON, marker\n\n    /**\n     * Whether requests are streamed or not.\n     * @type {boolean|undefined}\n     */\n    this.requestStream = requestStream ? true : undefined; // toJSON\n\n    /**\n     * Response type.\n     * @type {string}\n     */\n    this.responseType = responseType; // toJSON\n\n    /**\n     * Whether responses are streamed or not.\n     * @type {boolean|undefined}\n     */\n    this.responseStream = responseStream ? true : undefined; // toJSON\n\n    /**\n     * Resolved request type.\n     * @type {Type|null}\n     */\n    this.resolvedRequestType = null;\n\n    /**\n     * Resolved response type.\n     * @type {Type|null}\n     */\n    this.resolvedResponseType = null;\n\n    /**\n     * Comment for this method\n     * @type {string|null}\n     */\n    this.comment = comment;\n\n    /**\n     * Options properly parsed into an object\n     */\n    this.parsedOptions = parsedOptions;\n}\n\n/**\n * Method descriptor.\n * @interface IMethod\n * @property {string} [type=\"rpc\"] Method type\n * @property {string} requestType Request type\n * @property {string} responseType Response type\n * @property {boolean} [requestStream=false] Whether requests are streamed\n * @property {boolean} [responseStream=false] Whether responses are streamed\n * @property {Object.<string,*>} [options] Method options\n * @property {string} comment Method comments\n * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object\n */\n\n/**\n * Constructs a method from a method descriptor.\n * @param {string} name Method name\n * @param {IMethod} json Method descriptor\n * @returns {Method} Created method\n * @throws {TypeError} If arguments are invalid\n */\nMethod.fromJSON = function fromJSON(name, json) {\n    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);\n};\n\n/**\n * Converts this method to a method descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMethod} Method descriptor\n */\nMethod.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"type\"           , this.type !== \"rpc\" && /* istanbul ignore next */ this.type || undefined,\n        \"requestType\"    , this.requestType,\n        \"requestStream\"  , this.requestStream,\n        \"responseType\"   , this.responseType,\n        \"responseStream\" , this.responseStream,\n        \"options\"        , this.options,\n        \"comment\"        , keepComments ? this.comment : undefined,\n        \"parsedOptions\"  , this.parsedOptions,\n    ]);\n};\n\n/**\n * @override\n */\nMethod.prototype.resolve = function resolve() {\n\n    /* istanbul ignore if */\n    if (this.resolved)\n        return this;\n\n    this.resolvedRequestType = this.parent.lookupType(this.requestType);\n    this.resolvedResponseType = this.parent.lookupType(this.responseType);\n\n    return ReflectionObject.prototype.resolve.call(this);\n};\n","\"use strict\";\nmodule.exports = Namespace;\n\n// extends ReflectionObject\nvar ReflectionObject = require(24);\n((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\n\nvar Field    = require(16),\n    util     = require(37),\n    OneOf    = require(25);\n\nvar Type,    // cyclic\n    Service,\n    Enum;\n\n/**\n * Constructs a new namespace instance.\n * @name Namespace\n * @classdesc Reflected namespace.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n */\n\n/**\n * Constructs a namespace from JSON.\n * @memberof Namespace\n * @function\n * @param {string} name Namespace name\n * @param {Object.<string,*>} json JSON object\n * @returns {Namespace} Created namespace\n * @throws {TypeError} If arguments are invalid\n */\nNamespace.fromJSON = function fromJSON(name, json) {\n    return new Namespace(name, json.options).addJSON(json.nested);\n};\n\n/**\n * Converts an array of reflection objects to JSON.\n * @memberof Namespace\n * @param {ReflectionObject[]} array Object array\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\n */\nfunction arrayToJSON(array, toJSONOptions) {\n    if (!(array && array.length))\n        return undefined;\n    var obj = {};\n    for (var i = 0; i < array.length; ++i)\n        obj[array[i].name] = array[i].toJSON(toJSONOptions);\n    return obj;\n}\n\nNamespace.arrayToJSON = arrayToJSON;\n\n/**\n * Tests if the specified id is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nNamespace.isReservedId = function isReservedId(reserved, id) {\n    if (reserved)\n        for (var i = 0; i < reserved.length; ++i)\n            if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] > id)\n                return true;\n    return false;\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nNamespace.isReservedName = function isReservedName(reserved, name) {\n    if (reserved)\n        for (var i = 0; i < reserved.length; ++i)\n            if (reserved[i] === name)\n                return true;\n    return false;\n};\n\n/**\n * Not an actual constructor. Use {@link Namespace} instead.\n * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports NamespaceBase\n * @extends ReflectionObject\n * @abstract\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n * @see {@link Namespace}\n */\nfunction Namespace(name, options) {\n    ReflectionObject.call(this, name, options);\n\n    /**\n     * Nested objects by name.\n     * @type {Object.<string,ReflectionObject>|undefined}\n     */\n    this.nested = undefined; // toJSON\n\n    /**\n     * Cached nested objects as an array.\n     * @type {ReflectionObject[]|null}\n     * @private\n     */\n    this._nestedArray = null;\n}\n\nfunction clearCache(namespace) {\n    namespace._nestedArray = null;\n    return namespace;\n}\n\n/**\n * Nested objects of this namespace as an array for iteration.\n * @name NamespaceBase#nestedArray\n * @type {ReflectionObject[]}\n * @readonly\n */\nObject.defineProperty(Namespace.prototype, \"nestedArray\", {\n    get: function() {\n        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\n    }\n});\n\n/**\n * Namespace descriptor.\n * @interface INamespace\n * @property {Object.<string,*>} [options] Namespace options\n * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\n */\n\n/**\n * Any extension field descriptor.\n * @typedef AnyExtensionField\n * @type {IExtensionField|IExtensionMapField}\n */\n\n/**\n * Any nested object descriptor.\n * @typedef AnyNestedObject\n * @type {IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf}\n */\n\n/**\n * Converts this namespace to a namespace descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {INamespace} Namespace descriptor\n */\nNamespace.prototype.toJSON = function toJSON(toJSONOptions) {\n    return util.toObject([\n        \"options\" , this.options,\n        \"nested\"  , arrayToJSON(this.nestedArray, toJSONOptions)\n    ]);\n};\n\n/**\n * Adds nested objects to this namespace from nested object descriptors.\n * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\n * @returns {Namespace} `this`\n */\nNamespace.prototype.addJSON = function addJSON(nestedJson) {\n    var ns = this;\n    /* istanbul ignore else */\n    if (nestedJson) {\n        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {\n            nested = nestedJson[names[i]];\n            ns.add( // most to least likely\n                ( nested.fields !== undefined\n                ? Type.fromJSON\n                : nested.values !== undefined\n                ? Enum.fromJSON\n                : nested.methods !== undefined\n                ? Service.fromJSON\n                : nested.id !== undefined\n                ? Field.fromJSON\n                : Namespace.fromJSON )(names[i], nested)\n            );\n        }\n    }\n    return this;\n};\n\n/**\n * Gets the nested object of the specified name.\n * @param {string} name Nested object name\n * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\n */\nNamespace.prototype.get = function get(name) {\n    return util.getProp(this.nested, name)\n        || null;\n};\n\n/**\n * Gets the values of the nested {@link Enum|enum} of the specified name.\n * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\n * @param {string} name Nested enum name\n * @returns {Object.<string,number>} Enum values\n * @throws {Error} If there is no such enum\n */\nNamespace.prototype.getEnum = function getEnum(name) {\n    if (this.nested && this.nested[name] instanceof Enum)\n        return this.nested[name].values;\n    throw Error(\"no such enum: \" + name);\n};\n\n/**\n * Adds a nested object to this namespace.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name\n */\nNamespace.prototype.add = function add(object) {\n\n    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type  || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))\n        throw TypeError(\"object must be a valid nested object\");\n\n    if (!this.nested)\n        this.nested = {};\n    else {\n        var prev = this.get(object.name);\n        if (prev) {\n            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\n                // replace plain namespace but keep existing nested elements and options\n                var nested = prev.nestedArray;\n                for (var i = 0; i < nested.length; ++i)\n                    object.add(nested[i]);\n                this.remove(prev);\n                if (!this.nested)\n                    this.nested = {};\n                object.setOptions(prev.options, true);\n\n            } else\n                throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n        }\n    }\n    this.nested[object.name] = object;\n    object.onAdd(this);\n    return clearCache(this);\n};\n\n/**\n * Removes a nested object from this namespace.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this namespace\n */\nNamespace.prototype.remove = function remove(object) {\n\n    if (!(object instanceof ReflectionObject))\n        throw TypeError(\"object must be a ReflectionObject\");\n    if (object.parent !== this)\n        throw Error(object + \" is not a member of \" + this);\n\n    delete this.nested[object.name];\n    if (!Object.keys(this.nested).length)\n        this.nested = undefined;\n\n    object.onRemove(this);\n    return clearCache(this);\n};\n\n/**\n * Defines additial namespaces within this one if not yet existing.\n * @param {string|string[]} path Path to create\n * @param {*} [json] Nested types to create from JSON\n * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\n */\nNamespace.prototype.define = function define(path, json) {\n\n    if (util.isString(path))\n        path = path.split(\".\");\n    else if (!Array.isArray(path))\n        throw TypeError(\"illegal path\");\n    if (path && path.length && path[0] === \"\")\n        throw Error(\"path must be relative\");\n\n    var ptr = this;\n    while (path.length > 0) {\n        var part = path.shift();\n        if (ptr.nested && ptr.nested[part]) {\n            ptr = ptr.nested[part];\n            if (!(ptr instanceof Namespace))\n                throw Error(\"path conflicts with non-namespace objects\");\n        } else\n            ptr.add(ptr = new Namespace(part));\n    }\n    if (json)\n        ptr.addJSON(json);\n    return ptr;\n};\n\n/**\n * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\n * @returns {Namespace} `this`\n */\nNamespace.prototype.resolveAll = function resolveAll() {\n    var nested = this.nestedArray, i = 0;\n    while (i < nested.length)\n        if (nested[i] instanceof Namespace)\n            nested[i++].resolveAll();\n        else\n            nested[i++].resolve();\n    return this.resolve();\n};\n\n/**\n * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\n * @param {string|string[]} path Path to look up\n * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\n * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n */\nNamespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\n\n    /* istanbul ignore next */\n    if (typeof filterTypes === \"boolean\") {\n        parentAlreadyChecked = filterTypes;\n        filterTypes = undefined;\n    } else if (filterTypes && !Array.isArray(filterTypes))\n        filterTypes = [ filterTypes ];\n\n    if (util.isString(path) && path.length) {\n        if (path === \".\")\n            return this.root;\n        path = path.split(\".\");\n    } else if (!path.length)\n        return this;\n\n    // Start at root if path is absolute\n    if (path[0] === \"\")\n        return this.root.lookup(path.slice(1), filterTypes);\n\n    // Test if the first part matches any nested object, and if so, traverse if path contains more\n    var found = this.get(path[0]);\n    if (found) {\n        if (path.length === 1) {\n            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)\n                return found;\n        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))\n            return found;\n\n    // Otherwise try each nested namespace\n    } else\n        for (var i = 0; i < this.nestedArray.length; ++i)\n            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))\n                return found;\n\n    // If there hasn't been a match, try again at the parent\n    if (this.parent === null || parentAlreadyChecked)\n        return null;\n    return this.parent.lookup(path, filterTypes);\n};\n\n/**\n * Looks up the reflection object at the specified path, relative to this namespace.\n * @name NamespaceBase#lookup\n * @function\n * @param {string|string[]} path Path to look up\n * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n * @variation 2\n */\n// lookup(path: string, [parentAlreadyChecked: boolean])\n\n/**\n * Looks up the {@link Type|type} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type\n * @throws {Error} If `path` does not point to a type\n */\nNamespace.prototype.lookupType = function lookupType(path) {\n    var found = this.lookup(path, [ Type ]);\n    if (!found)\n        throw Error(\"no such type: \" + path);\n    return found;\n};\n\n/**\n * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Enum} Looked up enum\n * @throws {Error} If `path` does not point to an enum\n */\nNamespace.prototype.lookupEnum = function lookupEnum(path) {\n    var found = this.lookup(path, [ Enum ]);\n    if (!found)\n        throw Error(\"no such Enum '\" + path + \"' in \" + this);\n    return found;\n};\n\n/**\n * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type or enum\n * @throws {Error} If `path` does not point to a type or enum\n */\nNamespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\n    var found = this.lookup(path, [ Type, Enum ]);\n    if (!found)\n        throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\n    return found;\n};\n\n/**\n * Looks up the {@link Service|service} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Service} Looked up service\n * @throws {Error} If `path` does not point to a service\n */\nNamespace.prototype.lookupService = function lookupService(path) {\n    var found = this.lookup(path, [ Service ]);\n    if (!found)\n        throw Error(\"no such Service '\" + path + \"' in \" + this);\n    return found;\n};\n\n// Sets up cyclic dependencies (called in index-light)\nNamespace._configure = function(Type_, Service_, Enum_) {\n    Type    = Type_;\n    Service = Service_;\n    Enum    = Enum_;\n};\n","\"use strict\";\nmodule.exports = ReflectionObject;\n\nReflectionObject.className = \"ReflectionObject\";\n\nvar util = require(37);\n\nvar Root; // cyclic\n\n/**\n * Constructs a new reflection object instance.\n * @classdesc Base class of all reflection objects.\n * @constructor\n * @param {string} name Object name\n * @param {Object.<string,*>} [options] Declared options\n * @abstract\n */\nfunction ReflectionObject(name, options) {\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    if (options && !util.isObject(options))\n        throw TypeError(\"options must be an object\");\n\n    /**\n     * Options.\n     * @type {Object.<string,*>|undefined}\n     */\n    this.options = options; // toJSON\n\n    /**\n     * Parsed Options.\n     * @type {Array.<Object.<string,*>>|undefined}\n     */\n    this.parsedOptions = null;\n\n    /**\n     * Unique name within its namespace.\n     * @type {string}\n     */\n    this.name = name;\n\n    /**\n     * Parent namespace.\n     * @type {Namespace|null}\n     */\n    this.parent = null;\n\n    /**\n     * Whether already resolved or not.\n     * @type {boolean}\n     */\n    this.resolved = false;\n\n    /**\n     * Comment text, if any.\n     * @type {string|null}\n     */\n    this.comment = null;\n\n    /**\n     * Defining file name.\n     * @type {string|null}\n     */\n    this.filename = null;\n}\n\nObject.defineProperties(ReflectionObject.prototype, {\n\n    /**\n     * Reference to the root namespace.\n     * @name ReflectionObject#root\n     * @type {Root}\n     * @readonly\n     */\n    root: {\n        get: function() {\n            var ptr = this;\n            while (ptr.parent !== null)\n                ptr = ptr.parent;\n            return ptr;\n        }\n    },\n\n    /**\n     * Full name including leading dot.\n     * @name ReflectionObject#fullName\n     * @type {string}\n     * @readonly\n     */\n    fullName: {\n        get: function() {\n            var path = [ this.name ],\n                ptr = this.parent;\n            while (ptr) {\n                path.unshift(ptr.name);\n                ptr = ptr.parent;\n            }\n            return path.join(\".\");\n        }\n    }\n});\n\n/**\n * Converts this reflection object to its descriptor representation.\n * @returns {Object.<string,*>} Descriptor\n * @abstract\n */\nReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {\n    throw Error(); // not implemented, shouldn't happen\n};\n\n/**\n * Called when this object is added to a parent.\n * @param {ReflectionObject} parent Parent added to\n * @returns {undefined}\n */\nReflectionObject.prototype.onAdd = function onAdd(parent) {\n    if (this.parent && this.parent !== parent)\n        this.parent.remove(this);\n    this.parent = parent;\n    this.resolved = false;\n    var root = parent.root;\n    if (root instanceof Root)\n        root._handleAdd(this);\n};\n\n/**\n * Called when this object is removed from a parent.\n * @param {ReflectionObject} parent Parent removed from\n * @returns {undefined}\n */\nReflectionObject.prototype.onRemove = function onRemove(parent) {\n    var root = parent.root;\n    if (root instanceof Root)\n        root._handleRemove(this);\n    this.parent = null;\n    this.resolved = false;\n};\n\n/**\n * Resolves this objects type references.\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.resolve = function resolve() {\n    if (this.resolved)\n        return this;\n    if (this.root instanceof Root)\n        this.resolved = true; // only if part of a root\n    return this;\n};\n\n/**\n * Gets an option value.\n * @param {string} name Option name\n * @returns {*} Option value or `undefined` if not set\n */\nReflectionObject.prototype.getOption = function getOption(name) {\n    if (this.options)\n        return this.options[name];\n    return undefined;\n};\n\n/**\n * Sets an option.\n * @param {string} name Option name\n * @param {*} value Option value\n * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {\n    if (!ifNotSet || !this.options || this.options[name] === undefined)\n        (this.options || (this.options = {}))[name] = value;\n    return this;\n};\n\n/**\n * Sets a parsed option.\n * @param {string} name parsed Option name\n * @param {*} value Option value\n * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\\empty, will add a new option with that value\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {\n    if (!this.parsedOptions) {\n        this.parsedOptions = [];\n    }\n    var parsedOptions = this.parsedOptions;\n    if (propName) {\n        // If setting a sub property of an option then try to merge it\n        // with an existing option\n        var opt = parsedOptions.find(function (opt) {\n            return Object.prototype.hasOwnProperty.call(opt, name);\n        });\n        if (opt) {\n            // If we found an existing option - just merge the property value\n            var newValue = opt[name];\n            util.setProperty(newValue, propName, value);\n        } else {\n            // otherwise, create a new option, set it's property and add it to the list\n            opt = {};\n            opt[name] = util.setProperty({}, propName, value);\n            parsedOptions.push(opt);\n        }\n    } else {\n        // Always create a new option when setting the value of the option itself\n        var newOpt = {};\n        newOpt[name] = value;\n        parsedOptions.push(newOpt);\n    }\n    return this;\n};\n\n/**\n * Sets multiple options.\n * @param {Object.<string,*>} options Options to set\n * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {\n    if (options)\n        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)\n            this.setOption(keys[i], options[keys[i]], ifNotSet);\n    return this;\n};\n\n/**\n * Converts this instance to its string representation.\n * @returns {string} Class name[, space, full name]\n */\nReflectionObject.prototype.toString = function toString() {\n    var className = this.constructor.className,\n        fullName  = this.fullName;\n    if (fullName.length)\n        return className + \" \" + fullName;\n    return className;\n};\n\n// Sets up cyclic dependencies (called in index-light)\nReflectionObject._configure = function(Root_) {\n    Root = Root_;\n};\n","\"use strict\";\nmodule.exports = OneOf;\n\n// extends ReflectionObject\nvar ReflectionObject = require(24);\n((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = \"OneOf\";\n\nvar Field = require(16),\n    util  = require(37);\n\n/**\n * Constructs a new oneof instance.\n * @classdesc Reflected oneof.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Oneof name\n * @param {string[]|Object.<string,*>} [fieldNames] Field names\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */\nfunction OneOf(name, fieldNames, options, comment) {\n    if (!Array.isArray(fieldNames)) {\n        options = fieldNames;\n        fieldNames = undefined;\n    }\n    ReflectionObject.call(this, name, options);\n\n    /* istanbul ignore if */\n    if (!(fieldNames === undefined || Array.isArray(fieldNames)))\n        throw TypeError(\"fieldNames must be an Array\");\n\n    /**\n     * Field names that belong to this oneof.\n     * @type {string[]}\n     */\n    this.oneof = fieldNames || []; // toJSON, marker\n\n    /**\n     * Fields that belong to this oneof as an array for iteration.\n     * @type {Field[]}\n     * @readonly\n     */\n    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent\n\n    /**\n     * Comment for this field.\n     * @type {string|null}\n     */\n    this.comment = comment;\n}\n\n/**\n * Oneof descriptor.\n * @interface IOneOf\n * @property {Array.<string>} oneof Oneof field names\n * @property {Object.<string,*>} [options] Oneof options\n */\n\n/**\n * Constructs a oneof from a oneof descriptor.\n * @param {string} name Oneof name\n * @param {IOneOf} json Oneof descriptor\n * @returns {OneOf} Created oneof\n * @throws {TypeError} If arguments are invalid\n */\nOneOf.fromJSON = function fromJSON(name, json) {\n    return new OneOf(name, json.oneof, json.options, json.comment);\n};\n\n/**\n * Converts this oneof to a oneof descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IOneOf} Oneof descriptor\n */\nOneOf.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\" , this.options,\n        \"oneof\"   , this.oneof,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * Adds the fields of the specified oneof to the parent if not already done so.\n * @param {OneOf} oneof The oneof\n * @returns {undefined}\n * @inner\n * @ignore\n */\nfunction addFieldsToParent(oneof) {\n    if (oneof.parent)\n        for (var i = 0; i < oneof.fieldsArray.length; ++i)\n            if (!oneof.fieldsArray[i].parent)\n                oneof.parent.add(oneof.fieldsArray[i]);\n}\n\n/**\n * Adds a field to this oneof and removes it from its current parent, if any.\n * @param {Field} field Field to add\n * @returns {OneOf} `this`\n */\nOneOf.prototype.add = function add(field) {\n\n    /* istanbul ignore if */\n    if (!(field instanceof Field))\n        throw TypeError(\"field must be a Field\");\n\n    if (field.parent && field.parent !== this.parent)\n        field.parent.remove(field);\n    this.oneof.push(field.name);\n    this.fieldsArray.push(field);\n    field.partOf = this; // field.parent remains null\n    addFieldsToParent(this);\n    return this;\n};\n\n/**\n * Removes a field from this oneof and puts it back to the oneof's parent.\n * @param {Field} field Field to remove\n * @returns {OneOf} `this`\n */\nOneOf.prototype.remove = function remove(field) {\n\n    /* istanbul ignore if */\n    if (!(field instanceof Field))\n        throw TypeError(\"field must be a Field\");\n\n    var index = this.fieldsArray.indexOf(field);\n\n    /* istanbul ignore if */\n    if (index < 0)\n        throw Error(field + \" is not a member of \" + this);\n\n    this.fieldsArray.splice(index, 1);\n    index = this.oneof.indexOf(field.name);\n\n    /* istanbul ignore else */\n    if (index > -1) // theoretical\n        this.oneof.splice(index, 1);\n\n    field.partOf = null;\n    return this;\n};\n\n/**\n * @override\n */\nOneOf.prototype.onAdd = function onAdd(parent) {\n    ReflectionObject.prototype.onAdd.call(this, parent);\n    var self = this;\n    // Collect present fields\n    for (var i = 0; i < this.oneof.length; ++i) {\n        var field = parent.get(this.oneof[i]);\n        if (field && !field.partOf) {\n            field.partOf = self;\n            self.fieldsArray.push(field);\n        }\n    }\n    // Add not yet present fields\n    addFieldsToParent(this);\n};\n\n/**\n * @override\n */\nOneOf.prototype.onRemove = function onRemove(parent) {\n    for (var i = 0, field; i < this.fieldsArray.length; ++i)\n        if ((field = this.fieldsArray[i]).parent)\n            field.parent.remove(field);\n    ReflectionObject.prototype.onRemove.call(this, parent);\n};\n\n/**\n * Decorator function as returned by {@link OneOf.d} (TypeScript).\n * @typedef OneOfDecorator\n * @type {function}\n * @param {Object} prototype Target prototype\n * @param {string} oneofName OneOf name\n * @returns {undefined}\n */\n\n/**\n * OneOf decorator (TypeScript).\n * @function\n * @param {...string} fieldNames Field names\n * @returns {OneOfDecorator} Decorator function\n * @template T extends string\n */\nOneOf.d = function decorateOneOf() {\n    var fieldNames = new Array(arguments.length),\n        index = 0;\n    while (index < arguments.length)\n        fieldNames[index] = arguments[index++];\n    return function oneOfDecorator(prototype, oneofName) {\n        util.decorateType(prototype.constructor)\n            .add(new OneOf(oneofName, fieldNames));\n        Object.defineProperty(prototype, oneofName, {\n            get: util.oneOfGetter(fieldNames),\n            set: util.oneOfSetter(fieldNames)\n        });\n    };\n};\n","\"use strict\";\nmodule.exports = parse;\n\nparse.filename = null;\nparse.defaults = { keepCase: false };\n\nvar tokenize  = require(34),\n    Root      = require(29),\n    Type      = require(35),\n    Field     = require(16),\n    MapField  = require(20),\n    OneOf     = require(25),\n    Enum      = require(15),\n    Service   = require(33),\n    Method    = require(22),\n    types     = require(36),\n    util      = require(37);\n\nvar base10Re    = /^[1-9][0-9]*$/,\n    base10NegRe = /^-?[1-9][0-9]*$/,\n    base16Re    = /^0[x][0-9a-fA-F]+$/,\n    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,\n    base8Re     = /^0[0-7]+$/,\n    base8NegRe  = /^-?0[0-7]+$/,\n    numberRe    = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,\n    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,\n    typeRefRe   = /^(?:\\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,\n    fqTypeRefRe = /^(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;\n\n/**\n * Result object returned from {@link parse}.\n * @interface IParserResult\n * @property {string|undefined} package Package name, if declared\n * @property {string[]|undefined} imports Imports, if any\n * @property {string[]|undefined} weakImports Weak imports, if any\n * @property {string|undefined} syntax Syntax, if specified (either `\"proto2\"` or `\"proto3\"`)\n * @property {Root} root Populated root instance\n */\n\n/**\n * Options modifying the behavior of {@link parse}.\n * @interface IParseOptions\n * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case\n * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.\n * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.\n */\n\n/**\n * Options modifying the behavior of JSON serialization.\n * @interface IToJSONOptions\n * @property {boolean} [keepComments=false] Serializes comments.\n */\n\n/**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @param {string} source Source contents\n * @param {Root} root Root to populate\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n */\nfunction parse(source, root, options) {\n    /* eslint-disable callback-return */\n    if (!(root instanceof Root)) {\n        options = root;\n        root = new Root();\n    }\n    if (!options)\n        options = parse.defaults;\n\n    var preferTrailingComment = options.preferTrailingComment || false;\n    var tn = tokenize(source, options.alternateCommentMode || false),\n        next = tn.next,\n        push = tn.push,\n        peek = tn.peek,\n        skip = tn.skip,\n        cmnt = tn.cmnt;\n\n    var head = true,\n        pkg,\n        imports,\n        weakImports,\n        syntax,\n        isProto3 = false;\n\n    var ptr = root;\n\n    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;\n\n    /* istanbul ignore next */\n    function illegal(token, name, insideTryCatch) {\n        var filename = parse.filename;\n        if (!insideTryCatch)\n            parse.filename = null;\n        return Error(\"illegal \" + (name || \"token\") + \" '\" + token + \"' (\" + (filename ? filename + \", \" : \"\") + \"line \" + tn.line + \")\");\n    }\n\n    function readString() {\n        var values = [],\n            token;\n        do {\n            /* istanbul ignore if */\n            if ((token = next()) !== \"\\\"\" && token !== \"'\")\n                throw illegal(token);\n\n            values.push(next());\n            skip(token);\n            token = peek();\n        } while (token === \"\\\"\" || token === \"'\");\n        return values.join(\"\");\n    }\n\n    function readValue(acceptTypeRef) {\n        var token = next();\n        switch (token) {\n            case \"'\":\n            case \"\\\"\":\n                push(token);\n                return readString();\n            case \"true\": case \"TRUE\":\n                return true;\n            case \"false\": case \"FALSE\":\n                return false;\n        }\n        try {\n            return parseNumber(token, /* insideTryCatch */ true);\n        } catch (e) {\n\n            /* istanbul ignore else */\n            if (acceptTypeRef && typeRefRe.test(token))\n                return token;\n\n            /* istanbul ignore next */\n            throw illegal(token, \"value\");\n        }\n    }\n\n    function readRanges(target, acceptStrings) {\n        var token, start;\n        do {\n            if (acceptStrings && ((token = peek()) === \"\\\"\" || token === \"'\"))\n                target.push(readString());\n            else\n                target.push([ start = parseId(next()), skip(\"to\", true) ? parseId(next()) : start ]);\n        } while (skip(\",\", true));\n        var dummy = {options: undefined};\n        dummy.setOption = function(name, value) {\n          if (this.options === undefined) this.options = {};\n          this.options[name] = value;\n        };\n        ifBlock(\n            dummy,\n            function parseRange_block(token) {\n              /* istanbul ignore else */\n              if (token === \"option\") {\n                parseOption(dummy, token);  // skip\n                skip(\";\");\n              } else\n                throw illegal(token);\n            },\n            function parseRange_line() {\n              parseInlineOptions(dummy);  // skip\n            });\n    }\n\n    function parseNumber(token, insideTryCatch) {\n        var sign = 1;\n        if (token.charAt(0) === \"-\") {\n            sign = -1;\n            token = token.substring(1);\n        }\n        switch (token) {\n            case \"inf\": case \"INF\": case \"Inf\":\n                return sign * Infinity;\n            case \"nan\": case \"NAN\": case \"Nan\": case \"NaN\":\n                return NaN;\n            case \"0\":\n                return 0;\n        }\n        if (base10Re.test(token))\n            return sign * parseInt(token, 10);\n        if (base16Re.test(token))\n            return sign * parseInt(token, 16);\n        if (base8Re.test(token))\n            return sign * parseInt(token, 8);\n\n        /* istanbul ignore else */\n        if (numberRe.test(token))\n            return sign * parseFloat(token);\n\n        /* istanbul ignore next */\n        throw illegal(token, \"number\", insideTryCatch);\n    }\n\n    function parseId(token, acceptNegative) {\n        switch (token) {\n            case \"max\": case \"MAX\": case \"Max\":\n                return 536870911;\n            case \"0\":\n                return 0;\n        }\n\n        /* istanbul ignore if */\n        if (!acceptNegative && token.charAt(0) === \"-\")\n            throw illegal(token, \"id\");\n\n        if (base10NegRe.test(token))\n            return parseInt(token, 10);\n        if (base16NegRe.test(token))\n            return parseInt(token, 16);\n\n        /* istanbul ignore else */\n        if (base8NegRe.test(token))\n            return parseInt(token, 8);\n\n        /* istanbul ignore next */\n        throw illegal(token, \"id\");\n    }\n\n    function parsePackage() {\n\n        /* istanbul ignore if */\n        if (pkg !== undefined)\n            throw illegal(\"package\");\n\n        pkg = next();\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(pkg))\n            throw illegal(pkg, \"name\");\n\n        ptr = ptr.define(pkg);\n        skip(\";\");\n    }\n\n    function parseImport() {\n        var token = peek();\n        var whichImports;\n        switch (token) {\n            case \"weak\":\n                whichImports = weakImports || (weakImports = []);\n                next();\n                break;\n            case \"public\":\n                next();\n                // eslint-disable-next-line no-fallthrough\n            default:\n                whichImports = imports || (imports = []);\n                break;\n        }\n        token = readString();\n        skip(\";\");\n        whichImports.push(token);\n    }\n\n    function parseSyntax() {\n        skip(\"=\");\n        syntax = readString();\n        isProto3 = syntax === \"proto3\";\n\n        /* istanbul ignore if */\n        if (!isProto3 && syntax !== \"proto2\")\n            throw illegal(syntax, \"syntax\");\n\n        skip(\";\");\n    }\n\n    function parseCommon(parent, token) {\n        switch (token) {\n\n            case \"option\":\n                parseOption(parent, token);\n                skip(\";\");\n                return true;\n\n            case \"message\":\n                parseType(parent, token);\n                return true;\n\n            case \"enum\":\n                parseEnum(parent, token);\n                return true;\n\n            case \"service\":\n                parseService(parent, token);\n                return true;\n\n            case \"extend\":\n                parseExtension(parent, token);\n                return true;\n        }\n        return false;\n    }\n\n    function ifBlock(obj, fnIf, fnElse) {\n        var trailingLine = tn.line;\n        if (obj) {\n            if(typeof obj.comment !== \"string\") {\n              obj.comment = cmnt(); // try block-type comment\n            }\n            obj.filename = parse.filename;\n        }\n        if (skip(\"{\", true)) {\n            var token;\n            while ((token = next()) !== \"}\")\n                fnIf(token);\n            skip(\";\", true);\n        } else {\n            if (fnElse)\n                fnElse();\n            skip(\";\");\n            if (obj && (typeof obj.comment !== \"string\" || preferTrailingComment))\n                obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment\n        }\n    }\n\n    function parseType(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"type name\");\n\n        var type = new Type(token);\n        ifBlock(type, function parseType_block(token) {\n            if (parseCommon(type, token))\n                return;\n\n            switch (token) {\n\n                case \"map\":\n                    parseMapField(type, token);\n                    break;\n\n                case \"required\":\n                case \"repeated\":\n                    parseField(type, token);\n                    break;\n\n                case \"optional\":\n                    /* istanbul ignore if */\n                    if (isProto3) {\n                        parseField(type, \"proto3_optional\");\n                    } else {\n                        parseField(type, \"optional\");\n                    }\n                    break;\n\n                case \"oneof\":\n                    parseOneOf(type, token);\n                    break;\n\n                case \"extensions\":\n                    readRanges(type.extensions || (type.extensions = []));\n                    break;\n\n                case \"reserved\":\n                    readRanges(type.reserved || (type.reserved = []), true);\n                    break;\n\n                default:\n                    /* istanbul ignore if */\n                    if (!isProto3 || !typeRefRe.test(token))\n                        throw illegal(token);\n\n                    push(token);\n                    parseField(type, \"optional\");\n                    break;\n            }\n        });\n        parent.add(type);\n    }\n\n    function parseField(parent, rule, extend) {\n        var type = next();\n        if (type === \"group\") {\n            parseGroup(parent, rule);\n            return;\n        }\n        // Type names can consume multiple tokens, in multiple variants:\n        //    package.subpackage   field       tokens: \"package.subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package . subpackage field       tokens: \"package\" \".\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package.  subpackage field       tokens: \"package.\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package  .subpackage field       tokens: \"package\" \".subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        // Keep reading tokens until we get a type name with no period at the end,\n        // and the next token does not start with a period.\n        while (type.endsWith(\".\") || peek().startsWith(\".\")) {\n            type += next();\n        }\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(type))\n            throw illegal(type, \"type\");\n\n        var name = next();\n\n        /* istanbul ignore if */\n        if (!nameRe.test(name))\n            throw illegal(name, \"name\");\n\n        name = applyCase(name);\n        skip(\"=\");\n\n        var field = new Field(name, parseId(next()), type, rule, extend);\n        ifBlock(field, function parseField_block(token) {\n\n            /* istanbul ignore else */\n            if (token === \"option\") {\n                parseOption(field, token);\n                skip(\";\");\n            } else\n                throw illegal(token);\n\n        }, function parseField_line() {\n            parseInlineOptions(field);\n        });\n\n        if (rule === \"proto3_optional\") {\n            // for proto3 optional fields, we create a single-member Oneof to mimic \"optional\" behavior\n            var oneof = new OneOf(\"_\" + name);\n            field.setOption(\"proto3_optional\", true);\n            oneof.add(field);\n            parent.add(oneof);\n        } else {\n            parent.add(field);\n        }\n\n        // JSON defaults to packed=true if not set so we have to set packed=false explicity when\n        // parsing proto2 descriptors without the option, where applicable. This must be done for\n        // all known packable types and anything that could be an enum (= is not a basic type).\n        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))\n            field.setOption(\"packed\", false, /* ifNotSet */ true);\n    }\n\n    function parseGroup(parent, rule) {\n        var name = next();\n\n        /* istanbul ignore if */\n        if (!nameRe.test(name))\n            throw illegal(name, \"name\");\n\n        var fieldName = util.lcFirst(name);\n        if (name === fieldName)\n            name = util.ucFirst(name);\n        skip(\"=\");\n        var id = parseId(next());\n        var type = new Type(name);\n        type.group = true;\n        var field = new Field(fieldName, id, name, rule);\n        field.filename = parse.filename;\n        ifBlock(type, function parseGroup_block(token) {\n            switch (token) {\n\n                case \"option\":\n                    parseOption(type, token);\n                    skip(\";\");\n                    break;\n\n                case \"required\":\n                case \"repeated\":\n                    parseField(type, token);\n                    break;\n\n                case \"optional\":\n                    /* istanbul ignore if */\n                    if (isProto3) {\n                        parseField(type, \"proto3_optional\");\n                    } else {\n                        parseField(type, \"optional\");\n                    }\n                    break;\n\n                case \"message\":\n                    parseType(type, token);\n                    break;\n\n                case \"enum\":\n                    parseEnum(type, token);\n                    break;\n\n                /* istanbul ignore next */\n                default:\n                    throw illegal(token); // there are no groups with proto3 semantics\n            }\n        });\n        parent.add(type)\n              .add(field);\n    }\n\n    function parseMapField(parent) {\n        skip(\"<\");\n        var keyType = next();\n\n        /* istanbul ignore if */\n        if (types.mapKey[keyType] === undefined)\n            throw illegal(keyType, \"type\");\n\n        skip(\",\");\n        var valueType = next();\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(valueType))\n            throw illegal(valueType, \"type\");\n\n        skip(\">\");\n        var name = next();\n\n        /* istanbul ignore if */\n        if (!nameRe.test(name))\n            throw illegal(name, \"name\");\n\n        skip(\"=\");\n        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);\n        ifBlock(field, function parseMapField_block(token) {\n\n            /* istanbul ignore else */\n            if (token === \"option\") {\n                parseOption(field, token);\n                skip(\";\");\n            } else\n                throw illegal(token);\n\n        }, function parseMapField_line() {\n            parseInlineOptions(field);\n        });\n        parent.add(field);\n    }\n\n    function parseOneOf(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"name\");\n\n        var oneof = new OneOf(applyCase(token));\n        ifBlock(oneof, function parseOneOf_block(token) {\n            if (token === \"option\") {\n                parseOption(oneof, token);\n                skip(\";\");\n            } else {\n                push(token);\n                parseField(oneof, \"optional\");\n            }\n        });\n        parent.add(oneof);\n    }\n\n    function parseEnum(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"name\");\n\n        var enm = new Enum(token);\n        ifBlock(enm, function parseEnum_block(token) {\n          switch(token) {\n            case \"option\":\n              parseOption(enm, token);\n              skip(\";\");\n              break;\n\n            case \"reserved\":\n              readRanges(enm.reserved || (enm.reserved = []), true);\n              break;\n\n            default:\n              parseEnumValue(enm, token);\n          }\n        });\n        parent.add(enm);\n    }\n\n    function parseEnumValue(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token))\n            throw illegal(token, \"name\");\n\n        skip(\"=\");\n        var value = parseId(next(), true),\n            dummy = {\n                options: undefined\n            };\n        dummy.setOption = function(name, value) {\n            if (this.options === undefined)\n                this.options = {};\n            this.options[name] = value;\n        };\n        ifBlock(dummy, function parseEnumValue_block(token) {\n\n            /* istanbul ignore else */\n            if (token === \"option\") {\n                parseOption(dummy, token); // skip\n                skip(\";\");\n            } else\n                throw illegal(token);\n\n        }, function parseEnumValue_line() {\n            parseInlineOptions(dummy); // skip\n        });\n        parent.add(token, value, dummy.comment, dummy.options);\n    }\n\n    function parseOption(parent, token) {\n        var isCustom = skip(\"(\", true);\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(token = next()))\n            throw illegal(token, \"name\");\n\n        var name = token;\n        var option = name;\n        var propName;\n\n        if (isCustom) {\n            skip(\")\");\n            name = \"(\" + name + \")\";\n            option = name;\n            token = peek();\n            if (fqTypeRefRe.test(token)) {\n                propName = token.slice(1); //remove '.' before property name\n                name += token;\n                next();\n            }\n        }\n        skip(\"=\");\n        var optionValue = parseOptionValue(parent, name);\n        setParsedOption(parent, option, optionValue, propName);\n    }\n\n    function parseOptionValue(parent, name) {\n        // { a: \"foo\" b { c: \"bar\" } }\n        if (skip(\"{\", true)) {\n            var objectResult = {};\n\n            while (!skip(\"}\", true)) {\n                /* istanbul ignore if */\n                if (!nameRe.test(token = next())) {\n                    throw illegal(token, \"name\");\n                }\n                if (token === null) {\n                  throw illegal(token, \"end of input\");\n                }\n\n                var value;\n                var propName = token;\n\n                skip(\":\", true);\n\n                if (peek() === \"{\")\n                    value = parseOptionValue(parent, name + \".\" + token);\n                else if (peek() === \"[\") {\n                    // option (my_option) = {\n                    //     repeated_value: [ \"foo\", \"bar\" ]\n                    // };\n                    value = [];\n                    var lastValue;\n                    if (skip(\"[\", true)) {\n                        do {\n                            lastValue = readValue(true);\n                            value.push(lastValue);\n                        } while (skip(\",\", true));\n                        skip(\"]\");\n                        if (typeof lastValue !== \"undefined\") {\n                            setOption(parent, name + \".\" + token, lastValue);\n                        }\n                    }\n                } else {\n                    value = readValue(true);\n                    setOption(parent, name + \".\" + token, value);\n                }\n\n                var prevValue = objectResult[propName];\n\n                if (prevValue)\n                    value = [].concat(prevValue).concat(value);\n\n                objectResult[propName] = value;\n\n                // Semicolons and commas can be optional\n                skip(\",\", true);\n                skip(\";\", true);\n            }\n\n            return objectResult;\n        }\n\n        var simpleValue = readValue(true);\n        setOption(parent, name, simpleValue);\n        return simpleValue;\n        // Does not enforce a delimiter to be universal\n    }\n\n    function setOption(parent, name, value) {\n        if (parent.setOption)\n            parent.setOption(name, value);\n    }\n\n    function setParsedOption(parent, name, value, propName) {\n        if (parent.setParsedOption)\n            parent.setParsedOption(name, value, propName);\n    }\n\n    function parseInlineOptions(parent) {\n        if (skip(\"[\", true)) {\n            do {\n                parseOption(parent, \"option\");\n            } while (skip(\",\", true));\n            skip(\"]\");\n        }\n        return parent;\n    }\n\n    function parseService(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"service name\");\n\n        var service = new Service(token);\n        ifBlock(service, function parseService_block(token) {\n            if (parseCommon(service, token))\n                return;\n\n            /* istanbul ignore else */\n            if (token === \"rpc\")\n                parseMethod(service, token);\n            else\n                throw illegal(token);\n        });\n        parent.add(service);\n    }\n\n    function parseMethod(parent, token) {\n        // Get the comment of the preceding line now (if one exists) in case the\n        // method is defined across multiple lines.\n        var commentText = cmnt();\n\n        var type = token;\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"name\");\n\n        var name = token,\n            requestType, requestStream,\n            responseType, responseStream;\n\n        skip(\"(\");\n        if (skip(\"stream\", true))\n            requestStream = true;\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(token = next()))\n            throw illegal(token);\n\n        requestType = token;\n        skip(\")\"); skip(\"returns\"); skip(\"(\");\n        if (skip(\"stream\", true))\n            responseStream = true;\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(token = next()))\n            throw illegal(token);\n\n        responseType = token;\n        skip(\")\");\n\n        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);\n        method.comment = commentText;\n        ifBlock(method, function parseMethod_block(token) {\n\n            /* istanbul ignore else */\n            if (token === \"option\") {\n                parseOption(method, token);\n                skip(\";\");\n            } else\n                throw illegal(token);\n\n        });\n        parent.add(method);\n    }\n\n    function parseExtension(parent, token) {\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(token = next()))\n            throw illegal(token, \"reference\");\n\n        var reference = token;\n        ifBlock(null, function parseExtension_block(token) {\n            switch (token) {\n\n                case \"required\":\n                case \"repeated\":\n                    parseField(parent, token, reference);\n                    break;\n\n                case \"optional\":\n                    /* istanbul ignore if */\n                    if (isProto3) {\n                        parseField(parent, \"proto3_optional\", reference);\n                    } else {\n                        parseField(parent, \"optional\", reference);\n                    }\n                    break;\n\n                default:\n                    /* istanbul ignore if */\n                    if (!isProto3 || !typeRefRe.test(token))\n                        throw illegal(token);\n                    push(token);\n                    parseField(parent, \"optional\", reference);\n                    break;\n            }\n        });\n    }\n\n    var token;\n    while ((token = next()) !== null) {\n        switch (token) {\n\n            case \"package\":\n\n                /* istanbul ignore if */\n                if (!head)\n                    throw illegal(token);\n\n                parsePackage();\n                break;\n\n            case \"import\":\n\n                /* istanbul ignore if */\n                if (!head)\n                    throw illegal(token);\n\n                parseImport();\n                break;\n\n            case \"syntax\":\n\n                /* istanbul ignore if */\n                if (!head)\n                    throw illegal(token);\n\n                parseSyntax();\n                break;\n\n            case \"option\":\n\n                parseOption(ptr, token);\n                skip(\";\");\n                break;\n\n            default:\n\n                /* istanbul ignore else */\n                if (parseCommon(ptr, token)) {\n                    head = false;\n                    continue;\n                }\n\n                /* istanbul ignore next */\n                throw illegal(token);\n        }\n    }\n\n    parse.filename = null;\n    return {\n        \"package\"     : pkg,\n        \"imports\"     : imports,\n         weakImports  : weakImports,\n         syntax       : syntax,\n         root         : root\n    };\n}\n\n/**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @name parse\n * @function\n * @param {string} source Source contents\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n * @variation 2\n */\n","\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(39);\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n\n    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer\n            ? nativeBuffer.alloc(0)\n            : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n","\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(27);\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(39);\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n","\"use strict\";\nmodule.exports = Root;\n\n// extends Namespace\nvar Namespace = require(23);\n((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = \"Root\";\n\nvar Field   = require(16),\n    Enum    = require(15),\n    OneOf   = require(25),\n    util    = require(37);\n\nvar Type,   // cyclic\n    parse,  // might be excluded\n    common; // \"\n\n/**\n * Constructs a new root namespace instance.\n * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.\n * @extends NamespaceBase\n * @constructor\n * @param {Object.<string,*>} [options] Top level options\n */\nfunction Root(options) {\n    Namespace.call(this, \"\", options);\n\n    /**\n     * Deferred extension fields.\n     * @type {Field[]}\n     */\n    this.deferred = [];\n\n    /**\n     * Resolved file names of loaded files.\n     * @type {string[]}\n     */\n    this.files = [];\n}\n\n/**\n * Loads a namespace descriptor into a root namespace.\n * @param {INamespace} json Nameespace descriptor\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted\n * @returns {Root} Root namespace\n */\nRoot.fromJSON = function fromJSON(json, root) {\n    if (!root)\n        root = new Root();\n    if (json.options)\n        root.setOptions(json.options);\n    return root.addJSON(json.nested);\n};\n\n/**\n * Resolves the path of an imported file, relative to the importing origin.\n * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.\n * @function\n * @param {string} origin The file name of the importing file\n * @param {string} target The file name being imported\n * @returns {string|null} Resolved path to `target` or `null` to skip the file\n */\nRoot.prototype.resolvePath = util.path.resolve;\n\n/**\n * Fetch content from file path or url\n * This method exists so you can override it with your own logic.\n * @function\n * @param {string} path File path or url\n * @param {FetchCallback} callback Callback function\n * @returns {undefined}\n */\nRoot.prototype.fetch = util.fetch;\n\n// A symbol-like function to safely signal synchronous loading\n/* istanbul ignore next */\nfunction SYNC() {} // eslint-disable-line no-empty-function\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} options Parse options\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n */\nRoot.prototype.load = function load(filename, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    var self = this;\n    if (!callback)\n        return util.asPromise(load, self, filename, options);\n\n    var sync = callback === SYNC; // undocumented\n\n    // Finishes loading by calling the callback (exactly once)\n    function finish(err, root) {\n        /* istanbul ignore if */\n        if (!callback)\n            return;\n        if (sync)\n            throw err;\n        var cb = callback;\n        callback = null;\n        cb(err, root);\n    }\n\n    // Bundled definition existence checking\n    function getBundledFileName(filename) {\n        var idx = filename.lastIndexOf(\"google/protobuf/\");\n        if (idx > -1) {\n            var altname = filename.substring(idx);\n            if (altname in common) return altname;\n        }\n        return null;\n    }\n\n    // Processes a single file\n    function process(filename, source) {\n        try {\n            if (util.isString(source) && source.charAt(0) === \"{\")\n                source = JSON.parse(source);\n            if (!util.isString(source))\n                self.setOptions(source.options).addJSON(source.nested);\n            else {\n                parse.filename = filename;\n                var parsed = parse(source, self, options),\n                    resolved,\n                    i = 0;\n                if (parsed.imports)\n                    for (; i < parsed.imports.length; ++i)\n                        if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i]))\n                            fetch(resolved);\n                if (parsed.weakImports)\n                    for (i = 0; i < parsed.weakImports.length; ++i)\n                        if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i]))\n                            fetch(resolved, true);\n            }\n        } catch (err) {\n            finish(err);\n        }\n        if (!sync && !queued)\n            finish(null, self); // only once anyway\n    }\n\n    // Fetches a single file\n    function fetch(filename, weak) {\n        filename = getBundledFileName(filename) || filename;\n\n        // Skip if already loaded / attempted\n        if (self.files.indexOf(filename) > -1)\n            return;\n        self.files.push(filename);\n\n        // Shortcut bundled definitions\n        if (filename in common) {\n            if (sync)\n                process(filename, common[filename]);\n            else {\n                ++queued;\n                setTimeout(function() {\n                    --queued;\n                    process(filename, common[filename]);\n                });\n            }\n            return;\n        }\n\n        // Otherwise fetch from disk or network\n        if (sync) {\n            var source;\n            try {\n                source = util.fs.readFileSync(filename).toString(\"utf8\");\n            } catch (err) {\n                if (!weak)\n                    finish(err);\n                return;\n            }\n            process(filename, source);\n        } else {\n            ++queued;\n            self.fetch(filename, function(err, source) {\n                --queued;\n                /* istanbul ignore if */\n                if (!callback)\n                    return; // terminated meanwhile\n                if (err) {\n                    /* istanbul ignore else */\n                    if (!weak)\n                        finish(err);\n                    else if (!queued) // can't be covered reliably\n                        finish(null, self);\n                    return;\n                }\n                process(filename, source);\n            });\n        }\n    }\n    var queued = 0;\n\n    // Assembling the root namespace doesn't require working type\n    // references anymore, so we can load everything in parallel\n    if (util.isString(filename))\n        filename = [ filename ];\n    for (var i = 0, resolved; i < filename.length; ++i)\n        if (resolved = self.resolvePath(\"\", filename[i]))\n            fetch(resolved);\n\n    if (sync)\n        return self;\n    if (!queued)\n        finish(null, self);\n    return undefined;\n};\n// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.\n * @function Root#load\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @variation 2\n */\n// function load(filename:string, callback:LoadCallback):undefined\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.\n * @function Root#load\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {Promise<Root>} Promise\n * @variation 3\n */\n// function load(filename:string, [options:IParseOptions]):Promise<Root>\n\n/**\n * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).\n * @function Root#loadSync\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {Root} Root namespace\n * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid\n */\nRoot.prototype.loadSync = function loadSync(filename, options) {\n    if (!util.isNode)\n        throw Error(\"not supported\");\n    return this.load(filename, options, SYNC);\n};\n\n/**\n * @override\n */\nRoot.prototype.resolveAll = function resolveAll() {\n    if (this.deferred.length)\n        throw Error(\"unresolvable extensions: \" + this.deferred.map(function(field) {\n            return \"'extend \" + field.extend + \"' in \" + field.parent.fullName;\n        }).join(\", \"));\n    return Namespace.prototype.resolveAll.call(this);\n};\n\n// only uppercased (and thus conflict-free) children are exposed, see below\nvar exposeRe = /^[A-Z]/;\n\n/**\n * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.\n * @param {Root} root Root instance\n * @param {Field} field Declaring extension field witin the declaring type\n * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise\n * @inner\n * @ignore\n */\nfunction tryHandleExtension(root, field) {\n    var extendedType = field.parent.lookup(field.extend);\n    if (extendedType) {\n        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);\n        //do not allow to extend same field twice to prevent the error\n        if (extendedType.get(sisterField.name)) {\n            return true;\n        }\n        sisterField.declaringField = field;\n        field.extensionField = sisterField;\n        extendedType.add(sisterField);\n        return true;\n    }\n    return false;\n}\n\n/**\n * Called when any object is added to this root or its sub-namespaces.\n * @param {ReflectionObject} object Object added\n * @returns {undefined}\n * @private\n */\nRoot.prototype._handleAdd = function _handleAdd(object) {\n    if (object instanceof Field) {\n\n        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)\n            if (!tryHandleExtension(this, object))\n                this.deferred.push(object);\n\n    } else if (object instanceof Enum) {\n\n        if (exposeRe.test(object.name))\n            object.parent[object.name] = object.values; // expose enum values as property of its parent\n\n    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {\n\n        if (object instanceof Type) // Try to handle any deferred extensions\n            for (var i = 0; i < this.deferred.length;)\n                if (tryHandleExtension(this, this.deferred[i]))\n                    this.deferred.splice(i, 1);\n                else\n                    ++i;\n        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace\n            this._handleAdd(object._nestedArray[j]);\n        if (exposeRe.test(object.name))\n            object.parent[object.name] = object; // expose namespace as property of its parent\n    }\n\n    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as\n    // properties of namespaces just like static code does. This allows using a .d.ts generated for\n    // a static module with reflection-based solutions where the condition is met.\n};\n\n/**\n * Called when any object is removed from this root or its sub-namespaces.\n * @param {ReflectionObject} object Object removed\n * @returns {undefined}\n * @private\n */\nRoot.prototype._handleRemove = function _handleRemove(object) {\n    if (object instanceof Field) {\n\n        if (/* an extension field */ object.extend !== undefined) {\n            if (/* already handled */ object.extensionField) { // remove its sister field\n                object.extensionField.parent.remove(object.extensionField);\n                object.extensionField = null;\n            } else { // cancel the extension\n                var index = this.deferred.indexOf(object);\n                /* istanbul ignore else */\n                if (index > -1)\n                    this.deferred.splice(index, 1);\n            }\n        }\n\n    } else if (object instanceof Enum) {\n\n        if (exposeRe.test(object.name))\n            delete object.parent[object.name]; // unexpose enum values\n\n    } else if (object instanceof Namespace) {\n\n        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace\n            this._handleRemove(object._nestedArray[i]);\n\n        if (exposeRe.test(object.name))\n            delete object.parent[object.name]; // unexpose namespaces\n\n    }\n};\n\n// Sets up cyclic dependencies (called in index-light)\nRoot._configure = function(Type_, parse_, common_) {\n    Type   = Type_;\n    parse  = parse_;\n    common = common_;\n};\n","\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n","\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(32);\n","\"use strict\";\nmodule.exports = Service;\n\nvar util = require(39);\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n","\"use strict\";\nmodule.exports = Service;\n\n// extends Namespace\nvar Namespace = require(23);\n((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = \"Service\";\n\nvar Method = require(22),\n    util   = require(37),\n    rpc    = require(31);\n\n/**\n * Constructs a new service instance.\n * @classdesc Reflected service.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Service name\n * @param {Object.<string,*>} [options] Service options\n * @throws {TypeError} If arguments are invalid\n */\nfunction Service(name, options) {\n    Namespace.call(this, name, options);\n\n    /**\n     * Service methods.\n     * @type {Object.<string,Method>}\n     */\n    this.methods = {}; // toJSON, marker\n\n    /**\n     * Cached methods as an array.\n     * @type {Method[]|null}\n     * @private\n     */\n    this._methodsArray = null;\n}\n\n/**\n * Service descriptor.\n * @interface IService\n * @extends INamespace\n * @property {Object.<string,IMethod>} methods Method descriptors\n */\n\n/**\n * Constructs a service from a service descriptor.\n * @param {string} name Service name\n * @param {IService} json Service descriptor\n * @returns {Service} Created service\n * @throws {TypeError} If arguments are invalid\n */\nService.fromJSON = function fromJSON(name, json) {\n    var service = new Service(name, json.options);\n    /* istanbul ignore else */\n    if (json.methods)\n        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)\n            service.add(Method.fromJSON(names[i], json.methods[names[i]]));\n    if (json.nested)\n        service.addJSON(json.nested);\n    service.comment = json.comment;\n    return service;\n};\n\n/**\n * Converts this service to a service descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IService} Service descriptor\n */\nService.prototype.toJSON = function toJSON(toJSONOptions) {\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\" , inherited && inherited.options || undefined,\n        \"methods\" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},\n        \"nested\"  , inherited && inherited.nested || undefined,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * Methods of this service as an array for iteration.\n * @name Service#methodsArray\n * @type {Method[]}\n * @readonly\n */\nObject.defineProperty(Service.prototype, \"methodsArray\", {\n    get: function() {\n        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));\n    }\n});\n\nfunction clearCache(service) {\n    service._methodsArray = null;\n    return service;\n}\n\n/**\n * @override\n */\nService.prototype.get = function get(name) {\n    return util.getProp(this.methods, name)\n        || Namespace.prototype.get.call(this, name);\n};\n\n/**\n * @override\n */\nService.prototype.resolveAll = function resolveAll() {\n    var methods = this.methodsArray;\n    for (var i = 0; i < methods.length; ++i)\n        methods[i].resolve();\n    return Namespace.prototype.resolve.call(this);\n};\n\n/**\n * @override\n */\nService.prototype.add = function add(object) {\n\n    /* istanbul ignore if */\n    if (this.get(object.name))\n        throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n\n    if (object instanceof Method) {\n        this.methods[object.name] = object;\n        object.parent = this;\n        return clearCache(this);\n    }\n    return Namespace.prototype.add.call(this, object);\n};\n\n/**\n * @override\n */\nService.prototype.remove = function remove(object) {\n    if (object instanceof Method) {\n\n        /* istanbul ignore if */\n        if (this.methods[object.name] !== object)\n            throw Error(object + \" is not a member of \" + this);\n\n        delete this.methods[object.name];\n        object.parent = null;\n        return clearCache(this);\n    }\n    return Namespace.prototype.remove.call(this, object);\n};\n\n/**\n * Creates a runtime service using the specified rpc implementation.\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.\n */\nService.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {\n    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);\n    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {\n        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\\w_]/g, \"\");\n        rpcService[methodName] = util.codegen([\"r\",\"c\"], util.isReserved(methodName) ? methodName + \"_\" : methodName)(\"return this.rpcCall(m,q,s,r,c)\")({\n            m: method,\n            q: method.resolvedRequestType.ctor,\n            s: method.resolvedResponseType.ctor\n        });\n    }\n    return rpcService;\n};\n","\"use strict\";\nmodule.exports = tokenize;\n\nvar delimRe        = /[\\s{}=;:[\\],'\"()<>]/g,\n    stringDoubleRe = /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")/g,\n    stringSingleRe = /(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g;\n\nvar setCommentRe = /^ *[*/]+ */,\n    setCommentAltRe = /^\\s*\\*?\\/*/,\n    setCommentSplitRe = /\\n/g,\n    whitespaceRe = /\\s/,\n    unescapeRe = /\\\\(.?)/g;\n\nvar unescapeMap = {\n    \"0\": \"\\0\",\n    \"r\": \"\\r\",\n    \"n\": \"\\n\",\n    \"t\": \"\\t\"\n};\n\n/**\n * Unescapes a string.\n * @param {string} str String to unescape\n * @returns {string} Unescaped string\n * @property {Object.<string,string>} map Special characters map\n * @memberof tokenize\n */\nfunction unescape(str) {\n    return str.replace(unescapeRe, function($0, $1) {\n        switch ($1) {\n            case \"\\\\\":\n            case \"\":\n                return $1;\n            default:\n                return unescapeMap[$1] || \"\";\n        }\n    });\n}\n\ntokenize.unescape = unescape;\n\n/**\n * Gets the next token and advances.\n * @typedef TokenizerHandleNext\n * @type {function}\n * @returns {string|null} Next token or `null` on eof\n */\n\n/**\n * Peeks for the next token.\n * @typedef TokenizerHandlePeek\n * @type {function}\n * @returns {string|null} Next token or `null` on eof\n */\n\n/**\n * Pushes a token back to the stack.\n * @typedef TokenizerHandlePush\n * @type {function}\n * @param {string} token Token\n * @returns {undefined}\n */\n\n/**\n * Skips the next token.\n * @typedef TokenizerHandleSkip\n * @type {function}\n * @param {string} expected Expected token\n * @param {boolean} [optional=false] If optional\n * @returns {boolean} Whether the token matched\n * @throws {Error} If the token didn't match and is not optional\n */\n\n/**\n * Gets the comment on the previous line or, alternatively, the line comment on the specified line.\n * @typedef TokenizerHandleCmnt\n * @type {function}\n * @param {number} [line] Line number\n * @returns {string|null} Comment text or `null` if none\n */\n\n/**\n * Handle object returned from {@link tokenize}.\n * @interface ITokenizerHandle\n * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)\n * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)\n * @property {TokenizerHandlePush} push Pushes a token back to the stack\n * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws\n * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any\n * @property {number} line Current line number\n */\n\n/**\n * Tokenizes the given .proto source and returns an object with useful utility functions.\n * @param {string} source Source contents\n * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.\n * @returns {ITokenizerHandle} Tokenizer handle\n */\nfunction tokenize(source, alternateCommentMode) {\n    /* eslint-disable callback-return */\n    source = source.toString();\n\n    var offset = 0,\n        length = source.length,\n        line = 1,\n        lastCommentLine = 0,\n        comments = {};\n\n    var stack = [];\n\n    var stringDelim = null;\n\n    /* istanbul ignore next */\n    /**\n     * Creates an error for illegal syntax.\n     * @param {string} subject Subject\n     * @returns {Error} Error created\n     * @inner\n     */\n    function illegal(subject) {\n        return Error(\"illegal \" + subject + \" (line \" + line + \")\");\n    }\n\n    /**\n     * Reads a string till its end.\n     * @returns {string} String read\n     * @inner\n     */\n    function readString() {\n        var re = stringDelim === \"'\" ? stringSingleRe : stringDoubleRe;\n        re.lastIndex = offset - 1;\n        var match = re.exec(source);\n        if (!match)\n            throw illegal(\"string\");\n        offset = re.lastIndex;\n        push(stringDelim);\n        stringDelim = null;\n        return unescape(match[1]);\n    }\n\n    /**\n     * Gets the character at `pos` within the source.\n     * @param {number} pos Position\n     * @returns {string} Character\n     * @inner\n     */\n    function charAt(pos) {\n        return source.charAt(pos);\n    }\n\n    /**\n     * Sets the current comment text.\n     * @param {number} start Start offset\n     * @param {number} end End offset\n     * @param {boolean} isLeading set if a leading comment\n     * @returns {undefined}\n     * @inner\n     */\n    function setComment(start, end, isLeading) {\n        var comment = {\n            type: source.charAt(start++),\n            lineEmpty: false,\n            leading: isLeading,\n        };\n        var lookback;\n        if (alternateCommentMode) {\n            lookback = 2;  // alternate comment parsing: \"//\" or \"/*\"\n        } else {\n            lookback = 3;  // \"///\" or \"/**\"\n        }\n        var commentOffset = start - lookback,\n            c;\n        do {\n            if (--commentOffset < 0 ||\n                    (c = source.charAt(commentOffset)) === \"\\n\") {\n                comment.lineEmpty = true;\n                break;\n            }\n        } while (c === \" \" || c === \"\\t\");\n        var lines = source\n            .substring(start, end)\n            .split(setCommentSplitRe);\n        for (var i = 0; i < lines.length; ++i)\n            lines[i] = lines[i]\n                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, \"\")\n                .trim();\n        comment.text = lines\n            .join(\"\\n\")\n            .trim();\n\n        comments[line] = comment;\n        lastCommentLine = line;\n    }\n\n    function isDoubleSlashCommentLine(startOffset) {\n        var endOffset = findEndOfLine(startOffset);\n\n        // see if remaining line matches comment pattern\n        var lineText = source.substring(startOffset, endOffset);\n        var isComment = /^\\s*\\/\\//.test(lineText);\n        return isComment;\n    }\n\n    function findEndOfLine(cursor) {\n        // find end of cursor's line\n        var endOffset = cursor;\n        while (endOffset < length && charAt(endOffset) !== \"\\n\") {\n            endOffset++;\n        }\n        return endOffset;\n    }\n\n    /**\n     * Obtains the next token.\n     * @returns {string|null} Next token or `null` on eof\n     * @inner\n     */\n    function next() {\n        if (stack.length > 0)\n            return stack.shift();\n        if (stringDelim)\n            return readString();\n        var repeat,\n            prev,\n            curr,\n            start,\n            isDoc,\n            isLeadingComment = offset === 0;\n        do {\n            if (offset === length)\n                return null;\n            repeat = false;\n            while (whitespaceRe.test(curr = charAt(offset))) {\n                if (curr === \"\\n\") {\n                    isLeadingComment = true;\n                    ++line;\n                }\n                if (++offset === length)\n                    return null;\n            }\n\n            if (charAt(offset) === \"/\") {\n                if (++offset === length) {\n                    throw illegal(\"comment\");\n                }\n                if (charAt(offset) === \"/\") { // Line\n                    if (!alternateCommentMode) {\n                        // check for triple-slash comment\n                        isDoc = charAt(start = offset + 1) === \"/\";\n\n                        while (charAt(++offset) !== \"\\n\") {\n                            if (offset === length) {\n                                return null;\n                            }\n                        }\n                        ++offset;\n                        if (isDoc) {\n                            setComment(start, offset - 1, isLeadingComment);\n                            // Trailing comment cannot not be multi-line,\n                            // so leading comment state should be reset to handle potential next comments\n                            isLeadingComment = true;\n                        }\n                        ++line;\n                        repeat = true;\n                    } else {\n                        // check for double-slash comments, consolidating consecutive lines\n                        start = offset;\n                        isDoc = false;\n                        if (isDoubleSlashCommentLine(offset - 1)) {\n                            isDoc = true;\n                            do {\n                                offset = findEndOfLine(offset);\n                                if (offset === length) {\n                                    break;\n                                }\n                                offset++;\n                                if (!isLeadingComment) {\n                                    // Trailing comment cannot not be multi-line\n                                    break;\n                                }\n                            } while (isDoubleSlashCommentLine(offset));\n                        } else {\n                            offset = Math.min(length, findEndOfLine(offset) + 1);\n                        }\n                        if (isDoc) {\n                            setComment(start, offset, isLeadingComment);\n                            isLeadingComment = true;\n                        }\n                        line++;\n                        repeat = true;\n                    }\n                } else if ((curr = charAt(offset)) === \"*\") { /* Block */\n                    // check for /** (regular comment mode) or /* (alternate comment mode)\n                    start = offset + 1;\n                    isDoc = alternateCommentMode || charAt(start) === \"*\";\n                    do {\n                        if (curr === \"\\n\") {\n                            ++line;\n                        }\n                        if (++offset === length) {\n                            throw illegal(\"comment\");\n                        }\n                        prev = curr;\n                        curr = charAt(offset);\n                    } while (prev !== \"*\" || curr !== \"/\");\n                    ++offset;\n                    if (isDoc) {\n                        setComment(start, offset - 2, isLeadingComment);\n                        isLeadingComment = true;\n                    }\n                    repeat = true;\n                } else {\n                    return \"/\";\n                }\n            }\n        } while (repeat);\n\n        // offset !== length if we got here\n\n        var end = offset;\n        delimRe.lastIndex = 0;\n        var delim = delimRe.test(charAt(end++));\n        if (!delim)\n            while (end < length && !delimRe.test(charAt(end)))\n                ++end;\n        var token = source.substring(offset, offset = end);\n        if (token === \"\\\"\" || token === \"'\")\n            stringDelim = token;\n        return token;\n    }\n\n    /**\n     * Pushes a token back to the stack.\n     * @param {string} token Token\n     * @returns {undefined}\n     * @inner\n     */\n    function push(token) {\n        stack.push(token);\n    }\n\n    /**\n     * Peeks for the next token.\n     * @returns {string|null} Token or `null` on eof\n     * @inner\n     */\n    function peek() {\n        if (!stack.length) {\n            var token = next();\n            if (token === null)\n                return null;\n            push(token);\n        }\n        return stack[0];\n    }\n\n    /**\n     * Skips a token.\n     * @param {string} expected Expected token\n     * @param {boolean} [optional=false] Whether the token is optional\n     * @returns {boolean} `true` when skipped, `false` if not\n     * @throws {Error} When a required token is not present\n     * @inner\n     */\n    function skip(expected, optional) {\n        var actual = peek(),\n            equals = actual === expected;\n        if (equals) {\n            next();\n            return true;\n        }\n        if (!optional)\n            throw illegal(\"token '\" + actual + \"', '\" + expected + \"' expected\");\n        return false;\n    }\n\n    /**\n     * Gets a comment.\n     * @param {number} [trailingLine] Line number if looking for a trailing comment\n     * @returns {string|null} Comment text\n     * @inner\n     */\n    function cmnt(trailingLine) {\n        var ret = null;\n        var comment;\n        if (trailingLine === undefined) {\n            comment = comments[line - 1];\n            delete comments[line - 1];\n            if (comment && (alternateCommentMode || comment.type === \"*\" || comment.lineEmpty)) {\n                ret = comment.leading ? comment.text : null;\n            }\n        } else {\n            /* istanbul ignore else */\n            if (lastCommentLine < trailingLine) {\n                peek();\n            }\n            comment = comments[trailingLine];\n            delete comments[trailingLine];\n            if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === \"/\")) {\n                ret = comment.leading ? null : comment.text;\n            }\n        }\n        return ret;\n    }\n\n    return Object.defineProperty({\n        next: next,\n        peek: peek,\n        push: push,\n        skip: skip,\n        cmnt: cmnt\n    }, \"line\", {\n        get: function() { return line; }\n    });\n    /* eslint-enable callback-return */\n}\n","\"use strict\";\nmodule.exports = Type;\n\n// extends Namespace\nvar Namespace = require(23);\n((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = \"Type\";\n\nvar Enum      = require(15),\n    OneOf     = require(25),\n    Field     = require(16),\n    MapField  = require(20),\n    Service   = require(33),\n    Message   = require(21),\n    Reader    = require(27),\n    Writer    = require(42),\n    util      = require(37),\n    encoder   = require(14),\n    decoder   = require(13),\n    verifier  = require(40),\n    converter = require(12),\n    wrappers  = require(41);\n\n/**\n * Constructs a new reflected message type instance.\n * @classdesc Reflected message type.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Message name\n * @param {Object.<string,*>} [options] Declared options\n */\nfunction Type(name, options) {\n    Namespace.call(this, name, options);\n\n    /**\n     * Message fields.\n     * @type {Object.<string,Field>}\n     */\n    this.fields = {};  // toJSON, marker\n\n    /**\n     * Oneofs declared within this namespace, if any.\n     * @type {Object.<string,OneOf>}\n     */\n    this.oneofs = undefined; // toJSON\n\n    /**\n     * Extension ranges, if any.\n     * @type {number[][]}\n     */\n    this.extensions = undefined; // toJSON\n\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */\n    this.reserved = undefined; // toJSON\n\n    /*?\n     * Whether this type is a legacy group.\n     * @type {boolean|undefined}\n     */\n    this.group = undefined; // toJSON\n\n    /**\n     * Cached fields by id.\n     * @type {Object.<number,Field>|null}\n     * @private\n     */\n    this._fieldsById = null;\n\n    /**\n     * Cached fields as an array.\n     * @type {Field[]|null}\n     * @private\n     */\n    this._fieldsArray = null;\n\n    /**\n     * Cached oneofs as an array.\n     * @type {OneOf[]|null}\n     * @private\n     */\n    this._oneofsArray = null;\n\n    /**\n     * Cached constructor.\n     * @type {Constructor<{}>}\n     * @private\n     */\n    this._ctor = null;\n}\n\nObject.defineProperties(Type.prototype, {\n\n    /**\n     * Message fields by id.\n     * @name Type#fieldsById\n     * @type {Object.<number,Field>}\n     * @readonly\n     */\n    fieldsById: {\n        get: function() {\n\n            /* istanbul ignore if */\n            if (this._fieldsById)\n                return this._fieldsById;\n\n            this._fieldsById = {};\n            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {\n                var field = this.fields[names[i]],\n                    id = field.id;\n\n                /* istanbul ignore if */\n                if (this._fieldsById[id])\n                    throw Error(\"duplicate id \" + id + \" in \" + this);\n\n                this._fieldsById[id] = field;\n            }\n            return this._fieldsById;\n        }\n    },\n\n    /**\n     * Fields of this message as an array for iteration.\n     * @name Type#fieldsArray\n     * @type {Field[]}\n     * @readonly\n     */\n    fieldsArray: {\n        get: function() {\n            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));\n        }\n    },\n\n    /**\n     * Oneofs of this message as an array for iteration.\n     * @name Type#oneofsArray\n     * @type {OneOf[]}\n     * @readonly\n     */\n    oneofsArray: {\n        get: function() {\n            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));\n        }\n    },\n\n    /**\n     * The registered constructor, if any registered, otherwise a generic constructor.\n     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.\n     * @name Type#ctor\n     * @type {Constructor<{}>}\n     */\n    ctor: {\n        get: function() {\n            return this._ctor || (this.ctor = Type.generateConstructor(this)());\n        },\n        set: function(ctor) {\n\n            // Ensure proper prototype\n            var prototype = ctor.prototype;\n            if (!(prototype instanceof Message)) {\n                (ctor.prototype = new Message()).constructor = ctor;\n                util.merge(ctor.prototype, prototype);\n            }\n\n            // Classes and messages reference their reflected type\n            ctor.$type = ctor.prototype.$type = this;\n\n            // Mix in static methods\n            util.merge(ctor, Message, true);\n\n            this._ctor = ctor;\n\n            // Messages have non-enumerable default values on their prototype\n            var i = 0;\n            for (; i < /* initializes */ this.fieldsArray.length; ++i)\n                this._fieldsArray[i].resolve(); // ensures a proper value\n\n            // Messages have non-enumerable getters and setters for each virtual oneof field\n            var ctorProperties = {};\n            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)\n                ctorProperties[this._oneofsArray[i].resolve().name] = {\n                    get: util.oneOfGetter(this._oneofsArray[i].oneof),\n                    set: util.oneOfSetter(this._oneofsArray[i].oneof)\n                };\n            if (i)\n                Object.defineProperties(ctor.prototype, ctorProperties);\n        }\n    }\n});\n\n/**\n * Generates a constructor function for the specified type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nType.generateConstructor = function generateConstructor(mtype) {\n    /* eslint-disable no-unexpected-multiline */\n    var gen = util.codegen([\"p\"], mtype.name);\n    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype\n    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)\n        if ((field = mtype._fieldsArray[i]).map) gen\n            (\"this%s={}\", util.safeProp(field.name));\n        else if (field.repeated) gen\n            (\"this%s=[]\", util.safeProp(field.name));\n    return gen\n    (\"if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)\") // omit undefined or null\n        (\"this[ks[i]]=p[ks[i]]\");\n    /* eslint-enable no-unexpected-multiline */\n};\n\nfunction clearCache(type) {\n    type._fieldsById = type._fieldsArray = type._oneofsArray = null;\n    delete type.encode;\n    delete type.decode;\n    delete type.verify;\n    return type;\n}\n\n/**\n * Message type descriptor.\n * @interface IType\n * @extends INamespace\n * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors\n * @property {Object.<string,IField>} fields Field descriptors\n * @property {number[][]} [extensions] Extension ranges\n * @property {Array.<number[]|string>} [reserved] Reserved ranges\n * @property {boolean} [group=false] Whether a legacy group or not\n */\n\n/**\n * Creates a message type from a message type descriptor.\n * @param {string} name Message name\n * @param {IType} json Message type descriptor\n * @returns {Type} Created message type\n */\nType.fromJSON = function fromJSON(name, json) {\n    var type = new Type(name, json.options);\n    type.extensions = json.extensions;\n    type.reserved = json.reserved;\n    var names = Object.keys(json.fields),\n        i = 0;\n    for (; i < names.length; ++i)\n        type.add(\n            ( typeof json.fields[names[i]].keyType !== \"undefined\"\n            ? MapField.fromJSON\n            : Field.fromJSON )(names[i], json.fields[names[i]])\n        );\n    if (json.oneofs)\n        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)\n            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));\n    if (json.nested)\n        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {\n            var nested = json.nested[names[i]];\n            type.add( // most to least likely\n                ( nested.id !== undefined\n                ? Field.fromJSON\n                : nested.fields !== undefined\n                ? Type.fromJSON\n                : nested.values !== undefined\n                ? Enum.fromJSON\n                : nested.methods !== undefined\n                ? Service.fromJSON\n                : Namespace.fromJSON )(names[i], nested)\n            );\n        }\n    if (json.extensions && json.extensions.length)\n        type.extensions = json.extensions;\n    if (json.reserved && json.reserved.length)\n        type.reserved = json.reserved;\n    if (json.group)\n        type.group = true;\n    if (json.comment)\n        type.comment = json.comment;\n    return type;\n};\n\n/**\n * Converts this message type to a message type descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IType} Message type descriptor\n */\nType.prototype.toJSON = function toJSON(toJSONOptions) {\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\"    , inherited && inherited.options || undefined,\n        \"oneofs\"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),\n        \"fields\"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},\n        \"extensions\" , this.extensions && this.extensions.length ? this.extensions : undefined,\n        \"reserved\"   , this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"group\"      , this.group || undefined,\n        \"nested\"     , inherited && inherited.nested || undefined,\n        \"comment\"    , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * @override\n */\nType.prototype.resolveAll = function resolveAll() {\n    var fields = this.fieldsArray, i = 0;\n    while (i < fields.length)\n        fields[i++].resolve();\n    var oneofs = this.oneofsArray; i = 0;\n    while (i < oneofs.length)\n        oneofs[i++].resolve();\n    return Namespace.prototype.resolveAll.call(this);\n};\n\n/**\n * @override\n */\nType.prototype.get = function get(name) {\n    return util.getProp(this.fields, name)\n        || util.getProp(this.oneofs, name)\n        || util.getProp(this.nested, name)\n        || null;\n};\n\n/**\n * Adds a nested object to this type.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Type} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id\n */\nType.prototype.add = function add(object) {\n\n    if (this.get(object.name))\n        throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n\n    if (object instanceof Field && object.extend === undefined) {\n        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.\n        // The root object takes care of adding distinct sister-fields to the respective extended\n        // type instead.\n\n        // avoids calling the getter if not absolutely necessary because it's called quite frequently\n        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])\n            throw Error(\"duplicate id \" + object.id + \" in \" + this);\n        if (this.isReservedId(object.id))\n            throw Error(\"id \" + object.id + \" is reserved in \" + this);\n        if (this.isReservedName(object.name))\n            throw Error(\"name '\" + object.name + \"' is reserved in \" + this);\n\n        if (object.parent)\n            object.parent.remove(object);\n        this.fields[object.name] = object;\n        object.message = this;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n        if (!this.oneofs)\n            this.oneofs = {};\n        this.oneofs[object.name] = object;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.add.call(this, object);\n};\n\n/**\n * Removes a nested object from this type.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Type} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this type\n */\nType.prototype.remove = function remove(object) {\n    if (object instanceof Field && object.extend === undefined) {\n        // See Type#add for the reason why extension fields are excluded here.\n\n        /* istanbul ignore if */\n        if (!this.fields || this.fields[object.name] !== object)\n            throw Error(object + \" is not a member of \" + this);\n\n        delete this.fields[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n\n        /* istanbul ignore if */\n        if (!this.oneofs || this.oneofs[object.name] !== object)\n            throw Error(object + \" is not a member of \" + this);\n\n        delete this.oneofs[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.remove.call(this, object);\n};\n\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nType.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nType.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n\n/**\n * Creates a new message of this type using the specified properties.\n * @param {Object.<string,*>} [properties] Properties to set\n * @returns {Message<{}>} Message instance\n */\nType.prototype.create = function create(properties) {\n    return new this.ctor(properties);\n};\n\n/**\n * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.\n * @returns {Type} `this`\n */\nType.prototype.setup = function setup() {\n    // Sets up everything at once so that the prototype chain does not have to be re-evaluated\n    // multiple times (V8, soft-deopt prototype-check).\n\n    var fullName = this.fullName,\n        types    = [];\n    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)\n        types.push(this._fieldsArray[i].resolve().resolvedType);\n\n    // Replace setup methods with type-specific generated functions\n    this.encode = encoder(this)({\n        Writer : Writer,\n        types  : types,\n        util   : util\n    });\n    this.decode = decoder(this)({\n        Reader : Reader,\n        types  : types,\n        util   : util\n    });\n    this.verify = verifier(this)({\n        types : types,\n        util  : util\n    });\n    this.fromObject = converter.fromObject(this)({\n        types : types,\n        util  : util\n    });\n    this.toObject = converter.toObject(this)({\n        types : types,\n        util  : util\n    });\n\n    // Inject custom wrappers for common types\n    var wrapper = wrappers[fullName];\n    if (wrapper) {\n        var originalThis = Object.create(this);\n        // if (wrapper.fromObject) {\n            originalThis.fromObject = this.fromObject;\n            this.fromObject = wrapper.fromObject.bind(originalThis);\n        // }\n        // if (wrapper.toObject) {\n            originalThis.toObject = this.toObject;\n            this.toObject = wrapper.toObject.bind(originalThis);\n        // }\n    }\n\n    return this;\n};\n\n/**\n * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */\nType.prototype.encode = function encode_setup(message, writer) {\n    return this.setup().encode(message, writer); // overrides this method\n};\n\n/**\n * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */\nType.prototype.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();\n};\n\n/**\n * Decodes a message of this type.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @param {number} [length] Length of the message, if known beforehand\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError<{}>} If required fields are missing\n */\nType.prototype.decode = function decode_setup(reader, length) {\n    return this.setup().decode(reader, length); // overrides this method\n};\n\n/**\n * Decodes a message of this type preceeded by its byte length as a varint.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError} If required fields are missing\n */\nType.prototype.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof Reader))\n        reader = Reader.create(reader);\n    return this.decode(reader, reader.uint32());\n};\n\n/**\n * Verifies that field values are valid and that required fields are present.\n * @param {Object.<string,*>} message Plain object to verify\n * @returns {null|string} `null` if valid, otherwise the reason why it is not\n */\nType.prototype.verify = function verify_setup(message) {\n    return this.setup().verify(message); // overrides this method\n};\n\n/**\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n * @param {Object.<string,*>} object Plain object to convert\n * @returns {Message<{}>} Message instance\n */\nType.prototype.fromObject = function fromObject(object) {\n    return this.setup().fromObject(object);\n};\n\n/**\n * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.\n * @interface IConversionOptions\n * @property {Function} [longs] Long conversion type.\n * Valid values are `String` and `Number` (the global types).\n * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.\n * @property {Function} [enums] Enum value conversion type.\n * Only valid value is `String` (the global type).\n * Defaults to copy the present value, which is the numeric id.\n * @property {Function} [bytes] Bytes value conversion type.\n * Valid values are `Array` and (a base64 encoded) `String` (the global types).\n * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.\n * @property {boolean} [defaults=false] Also sets default values on the resulting object\n * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`\n * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`\n * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any\n * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings\n */\n\n/**\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n */\nType.prototype.toObject = function toObject(message, options) {\n    return this.setup().toObject(message, options);\n};\n\n/**\n * Decorator function as returned by {@link Type.d} (TypeScript).\n * @typedef TypeDecorator\n * @type {function}\n * @param {Constructor<T>} target Target constructor\n * @returns {undefined}\n * @template T extends Message<T>\n */\n\n/**\n * Type decorator (TypeScript).\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {TypeDecorator<T>} Decorator function\n * @template T extends Message<T>\n */\nType.d = function decorateType(typeName) {\n    return function typeDecorator(target) {\n        util.decorateType(target, typeName);\n    };\n};\n","\"use strict\";\n\n/**\n * Common type constants.\n * @namespace\n */\nvar types = exports;\n\nvar util = require(37);\n\nvar s = [\n    \"double\",   // 0\n    \"float\",    // 1\n    \"int32\",    // 2\n    \"uint32\",   // 3\n    \"sint32\",   // 4\n    \"fixed32\",  // 5\n    \"sfixed32\", // 6\n    \"int64\",    // 7\n    \"uint64\",   // 8\n    \"sint64\",   // 9\n    \"fixed64\",  // 10\n    \"sfixed64\", // 11\n    \"bool\",     // 12\n    \"string\",   // 13\n    \"bytes\"     // 14\n];\n\nfunction bake(values, offset) {\n    var i = 0, o = {};\n    offset |= 0;\n    while (i < values.length) o[s[i + offset]] = values[i++];\n    return o;\n}\n\n/**\n * Basic type wire types.\n * @type {Object.<string,number>}\n * @const\n * @property {number} double=1 Fixed64 wire type\n * @property {number} float=5 Fixed32 wire type\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n * @property {number} string=2 Ldelim wire type\n * @property {number} bytes=2 Ldelim wire type\n */\ntypes.basic = bake([\n    /* double   */ 1,\n    /* float    */ 5,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0,\n    /* string   */ 2,\n    /* bytes    */ 2\n]);\n\n/**\n * Basic type defaults.\n * @type {Object.<string,*>}\n * @const\n * @property {number} double=0 Double default\n * @property {number} float=0 Float default\n * @property {number} int32=0 Int32 default\n * @property {number} uint32=0 Uint32 default\n * @property {number} sint32=0 Sint32 default\n * @property {number} fixed32=0 Fixed32 default\n * @property {number} sfixed32=0 Sfixed32 default\n * @property {number} int64=0 Int64 default\n * @property {number} uint64=0 Uint64 default\n * @property {number} sint64=0 Sint32 default\n * @property {number} fixed64=0 Fixed64 default\n * @property {number} sfixed64=0 Sfixed64 default\n * @property {boolean} bool=false Bool default\n * @property {string} string=\"\" String default\n * @property {Array.<number>} bytes=Array(0) Bytes default\n * @property {null} message=null Message default\n */\ntypes.defaults = bake([\n    /* double   */ 0,\n    /* float    */ 0,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 0,\n    /* sfixed32 */ 0,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 0,\n    /* sfixed64 */ 0,\n    /* bool     */ false,\n    /* string   */ \"\",\n    /* bytes    */ util.emptyArray,\n    /* message  */ null\n]);\n\n/**\n * Basic long type wire types.\n * @type {Object.<string,number>}\n * @const\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n */\ntypes.long = bake([\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1\n], 7);\n\n/**\n * Allowed types for map keys with their associated wire type.\n * @type {Object.<string,number>}\n * @const\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n * @property {number} string=2 Ldelim wire type\n */\ntypes.mapKey = bake([\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0,\n    /* string   */ 2\n], 2);\n\n/**\n * Allowed types for packed repeated fields with their associated wire type.\n * @type {Object.<string,number>}\n * @const\n * @property {number} double=1 Fixed64 wire type\n * @property {number} float=5 Fixed32 wire type\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n */\ntypes.packed = bake([\n    /* double   */ 1,\n    /* float    */ 5,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0\n]);\n","\"use strict\";\n\n/**\n * Various utility functions.\n * @namespace\n */\nvar util = module.exports = require(39);\n\nvar roots = require(30);\n\nvar Type, // cyclic\n    Enum;\n\nutil.codegen = require(3);\nutil.fetch   = require(5);\nutil.path    = require(8);\n\n/**\n * Node's fs module if available.\n * @type {Object.<string,*>}\n */\nutil.fs = util.inquire(\"fs\");\n\n/**\n * Converts an object's values to an array.\n * @param {Object.<string,*>} object Object to convert\n * @returns {Array.<*>} Converted array\n */\nutil.toArray = function toArray(object) {\n    if (object) {\n        var keys  = Object.keys(object),\n            array = new Array(keys.length),\n            index = 0;\n        while (index < keys.length)\n            array[index] = object[keys[index++]];\n        return array;\n    }\n    return [];\n};\n\n/**\n * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.\n * @param {Array.<*>} array Array to convert\n * @returns {Object.<string,*>} Converted object\n */\nutil.toObject = function toObject(array) {\n    var object = {},\n        index  = 0;\n    while (index < array.length) {\n        var key = array[index++],\n            val = array[index++];\n        if (val !== undefined)\n            object[key] = val;\n    }\n    return object;\n};\n\nvar safePropBackslashRe = /\\\\/g,\n    safePropQuoteRe     = /\"/g;\n\n/**\n * Tests whether the specified name is a reserved word in JS.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nutil.isReserved = function isReserved(name) {\n    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);\n};\n\n/**\n * Returns a safe property accessor for the specified property name.\n * @param {string} prop Property name\n * @returns {string} Safe accessor\n */\nutil.safeProp = function safeProp(prop) {\n    if (!/^[$\\w_]+$/.test(prop) || util.isReserved(prop))\n        return \"[\\\"\" + prop.replace(safePropBackslashRe, \"\\\\\\\\\").replace(safePropQuoteRe, \"\\\\\\\"\") + \"\\\"]\";\n    return \".\" + prop;\n};\n\n/**\n * Returns the value of a property found directly in a given object.\n * @param {Object} object Source object\n * @param {string} prop Property name\n * @returns {*} Value or `undefined` if not set\n */\nutil.getProp = function get(object, prop) {\n    return object && Object.prototype.hasOwnProperty.call(object, prop) ? object[prop] : undefined;\n};\n\n/**\n * Converts the first character of a string to upper case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.ucFirst = function ucFirst(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n};\n\nvar camelCaseRe = /_([a-z])/g;\n\n/**\n * Converts a string to camel case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.camelCase = function camelCase(str) {\n    return str.substring(0, 1)\n         + str.substring(1)\n               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });\n};\n\n/**\n * Compares reflected fields by id.\n * @param {Field} a First field\n * @param {Field} b Second field\n * @returns {number} Comparison value\n */\nutil.compareFieldsById = function compareFieldsById(a, b) {\n    return a.id - b.id;\n};\n\n/**\n * Decorator helper for types (TypeScript).\n * @param {Constructor<T>} ctor Constructor function\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {Type} Reflected type\n * @template T extends Message<T>\n * @property {Root} root Decorators root\n */\nutil.decorateType = function decorateType(ctor, typeName) {\n\n    /* istanbul ignore if */\n    if (ctor.$type) {\n        if (typeName && ctor.$type.name !== typeName) {\n            util.decorateRoot.remove(ctor.$type);\n            ctor.$type.name = typeName;\n            util.decorateRoot.add(ctor.$type);\n        }\n        return ctor.$type;\n    }\n\n    /* istanbul ignore next */\n    if (!Type)\n        Type = require(35);\n\n    var type = new Type(typeName || ctor.name);\n    util.decorateRoot.add(type);\n    type.ctor = ctor; // sets up .encode, .decode etc.\n    Object.defineProperty(ctor, \"$type\", { value: type, enumerable: false });\n    Object.defineProperty(ctor.prototype, \"$type\", { value: type, enumerable: false });\n    return type;\n};\n\nvar decorateEnumIndex = 0;\n\n/**\n * Decorator helper for enums (TypeScript).\n * @param {Object} object Enum object\n * @returns {Enum} Reflected enum\n */\nutil.decorateEnum = function decorateEnum(object) {\n\n    /* istanbul ignore if */\n    if (object.$type)\n        return object.$type;\n\n    /* istanbul ignore next */\n    if (!Enum)\n        Enum = require(15);\n\n    var enm = new Enum(\"Enum\" + decorateEnumIndex++, object);\n    util.decorateRoot.add(enm);\n    Object.defineProperty(object, \"$type\", { value: enm, enumerable: false });\n    return enm;\n};\n\n\n/**\n * Sets the value of a property by property path. If a value already exists, it is turned to an array\n * @param {Object.<string,*>} dst Destination object\n * @param {string} path dot '.' delimited path of the property to set\n * @param {Object} value the value to set\n * @returns {Object.<string,*>} Destination object\n */\nutil.setProperty = function setProperty(dst, path, value) {\n    function setProp(dst, path, value) {\n        var part = path.shift();\n        if (part === \"__proto__\" || part === \"prototype\") {\n          return dst;\n        }\n        if (path.length > 0) {\n            dst[part] = setProp(dst[part] || {}, path, value);\n        } else {\n            var prevValue = dst[part];\n            if (prevValue)\n                value = [].concat(prevValue).concat(value);\n            dst[part] = value;\n        }\n        return dst;\n    }\n\n    if (typeof dst !== \"object\")\n        throw TypeError(\"dst must be an object\");\n    if (!path)\n        throw TypeError(\"path must be specified\");\n\n    path = path.split(\".\");\n    return setProp(dst, path, value);\n};\n\n/**\n * Decorator root (TypeScript).\n * @name util.decorateRoot\n * @type {Root}\n * @readonly\n */\nObject.defineProperty(util, \"decorateRoot\", {\n    get: function() {\n        return roots[\"decorated\"] || (roots[\"decorated\"] = new (require(29))());\n    }\n});\n","\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(39);\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n","\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(1);\n\n// converts to / from base64 encoded strings\nutil.base64 = require(2);\n\n// base class of rpc.Service\nutil.EventEmitter = require(4);\n\n// float handling accross browsers\nutil.float = require(6);\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(7);\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(10);\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(9);\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(38);\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n        name: {\n            get: function get() { return name; },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true,\n        },\n        toString: {\n            value: function value() { return this.name + \": \" + this.message; },\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n    });\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n","\"use strict\";\nmodule.exports = verifier;\n\nvar Enum      = require(15),\n    util      = require(37);\n\nfunction invalid(field, expected) {\n    return field.name + \": \" + expected + (field.repeated && expected !== \"array\" ? \"[]\" : field.map && expected !== \"object\" ? \"{k:\"+field.keyType+\"}\" : \"\") + \" expected\";\n}\n\n/**\n * Generates a partial value verifier.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genVerifyValue(gen, field, fieldIndex, ref) {\n    /* eslint-disable no-unexpected-multiline */\n    if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) { gen\n            (\"switch(%s){\", ref)\n                (\"default:\")\n                    (\"return%j\", invalid(field, \"enum value\"));\n            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen\n                (\"case %i:\", field.resolvedType.values[keys[j]]);\n            gen\n                    (\"break\")\n            (\"}\");\n        } else {\n            gen\n            (\"{\")\n                (\"var e=types[%i].verify(%s);\", fieldIndex, ref)\n                (\"if(e)\")\n                    (\"return%j+e\", field.name + \".\")\n            (\"}\");\n        }\n    } else {\n        switch (field.type) {\n            case \"int32\":\n            case \"uint32\":\n            case \"sint32\":\n            case \"fixed32\":\n            case \"sfixed32\": gen\n                (\"if(!util.isInteger(%s))\", ref)\n                    (\"return%j\", invalid(field, \"integer\"));\n                break;\n            case \"int64\":\n            case \"uint64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\": gen\n                (\"if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))\", ref, ref, ref, ref)\n                    (\"return%j\", invalid(field, \"integer|Long\"));\n                break;\n            case \"float\":\n            case \"double\": gen\n                (\"if(typeof %s!==\\\"number\\\")\", ref)\n                    (\"return%j\", invalid(field, \"number\"));\n                break;\n            case \"bool\": gen\n                (\"if(typeof %s!==\\\"boolean\\\")\", ref)\n                    (\"return%j\", invalid(field, \"boolean\"));\n                break;\n            case \"string\": gen\n                (\"if(!util.isString(%s))\", ref)\n                    (\"return%j\", invalid(field, \"string\"));\n                break;\n            case \"bytes\": gen\n                (\"if(!(%s&&typeof %s.length===\\\"number\\\"||util.isString(%s)))\", ref, ref, ref)\n                    (\"return%j\", invalid(field, \"buffer\"));\n                break;\n        }\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline */\n}\n\n/**\n * Generates a partial key verifier.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genVerifyKey(gen, field, ref) {\n    /* eslint-disable no-unexpected-multiline */\n    switch (field.keyType) {\n        case \"int32\":\n        case \"uint32\":\n        case \"sint32\":\n        case \"fixed32\":\n        case \"sfixed32\": gen\n            (\"if(!util.key32Re.test(%s))\", ref)\n                (\"return%j\", invalid(field, \"integer key\"));\n            break;\n        case \"int64\":\n        case \"uint64\":\n        case \"sint64\":\n        case \"fixed64\":\n        case \"sfixed64\": gen\n            (\"if(!util.key64Re.test(%s))\", ref) // see comment above: x is ok, d is not\n                (\"return%j\", invalid(field, \"integer|Long key\"));\n            break;\n        case \"bool\": gen\n            (\"if(!util.key2Re.test(%s))\", ref)\n                (\"return%j\", invalid(field, \"boolean key\"));\n            break;\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline */\n}\n\n/**\n * Generates a verifier specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction verifier(mtype) {\n    /* eslint-disable no-unexpected-multiline */\n\n    var gen = util.codegen([\"m\"], mtype.name + \"$verify\")\n    (\"if(typeof m!==\\\"object\\\"||m===null)\")\n        (\"return%j\", \"object expected\");\n    var oneofs = mtype.oneofsArray,\n        seenFirstField = {};\n    if (oneofs.length) gen\n    (\"var p={}\");\n\n    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {\n        var field = mtype._fieldsArray[i].resolve(),\n            ref   = \"m\" + util.safeProp(field.name);\n\n        if (field.optional) gen\n        (\"if(%s!=null&&m.hasOwnProperty(%j)){\", ref, field.name); // !== undefined && !== null\n\n        // map fields\n        if (field.map) { gen\n            (\"if(!util.isObject(%s))\", ref)\n                (\"return%j\", invalid(field, \"object\"))\n            (\"var k=Object.keys(%s)\", ref)\n            (\"for(var i=0;i<k.length;++i){\");\n                genVerifyKey(gen, field, \"k[i]\");\n                genVerifyValue(gen, field, i, ref + \"[k[i]]\")\n            (\"}\");\n\n        // repeated fields\n        } else if (field.repeated) { gen\n            (\"if(!Array.isArray(%s))\", ref)\n                (\"return%j\", invalid(field, \"array\"))\n            (\"for(var i=0;i<%s.length;++i){\", ref);\n                genVerifyValue(gen, field, i, ref + \"[i]\")\n            (\"}\");\n\n        // required or present fields\n        } else {\n            if (field.partOf) {\n                var oneofProp = util.safeProp(field.partOf.name);\n                if (seenFirstField[field.partOf.name] === 1) gen\n            (\"if(p%s===1)\", oneofProp)\n                (\"return%j\", field.partOf.name + \": multiple values\");\n                seenFirstField[field.partOf.name] = 1;\n                gen\n            (\"p%s=1\", oneofProp);\n            }\n            genVerifyValue(gen, field, i, ref);\n        }\n        if (field.optional) gen\n        (\"}\");\n    }\n    return gen\n    (\"return null\");\n    /* eslint-enable no-unexpected-multiline */\n}","\"use strict\";\n\n/**\n * Wrappers for common types.\n * @type {Object.<string,IWrapper>}\n * @const\n */\nvar wrappers = exports;\n\nvar Message = require(21);\n\n/**\n * From object converter part of an {@link IWrapper}.\n * @typedef WrapperFromObjectConverter\n * @type {function}\n * @param {Object.<string,*>} object Plain object\n * @returns {Message<{}>} Message instance\n * @this Type\n */\n\n/**\n * To object converter part of an {@link IWrapper}.\n * @typedef WrapperToObjectConverter\n * @type {function}\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n * @this Type\n */\n\n/**\n * Common type wrapper part of {@link wrappers}.\n * @interface IWrapper\n * @property {WrapperFromObjectConverter} [fromObject] From object converter\n * @property {WrapperToObjectConverter} [toObject] To object converter\n */\n\n// Custom wrapper for Any\nwrappers[\".google.protobuf.Any\"] = {\n\n    fromObject: function(object) {\n\n        // unwrap value type if mapped\n        if (object && object[\"@type\"]) {\n             // Only use fully qualified type name after the last '/'\n            var name = object[\"@type\"].substring(object[\"@type\"].lastIndexOf(\"/\") + 1);\n            var type = this.lookup(name);\n            /* istanbul ignore else */\n            if (type) {\n                // type_url does not accept leading \".\"\n                var type_url = object[\"@type\"].charAt(0) === \".\" ?\n                    object[\"@type\"].slice(1) : object[\"@type\"];\n                // type_url prefix is optional, but path seperator is required\n                if (type_url.indexOf(\"/\") === -1) {\n                    type_url = \"/\" + type_url;\n                }\n                return this.create({\n                    type_url: type_url,\n                    value: type.encode(type.fromObject(object)).finish()\n                });\n            }\n        }\n\n        return this.fromObject(object);\n    },\n\n    toObject: function(message, options) {\n\n        // Default prefix\n        var googleApi = \"type.googleapis.com/\";\n        var prefix = \"\";\n        var name = \"\";\n\n        // decode value if requested and unmapped\n        if (options && options.json && message.type_url && message.value) {\n            // Only use fully qualified type name after the last '/'\n            name = message.type_url.substring(message.type_url.lastIndexOf(\"/\") + 1);\n            // Separate the prefix used\n            prefix = message.type_url.substring(0, message.type_url.lastIndexOf(\"/\") + 1);\n            var type = this.lookup(name);\n            /* istanbul ignore else */\n            if (type)\n                message = type.decode(message.value);\n        }\n\n        // wrap value if unmapped\n        if (!(message instanceof this.ctor) && message instanceof Message) {\n            var object = message.$type.toObject(message, options);\n            var messageName = message.$type.fullName[0] === \".\" ?\n                message.$type.fullName.slice(1) : message.$type.fullName;\n            // Default to type.googleapis.com prefix if no prefix is used\n            if (prefix === \"\") {\n                prefix = googleApi;\n            }\n            name = prefix + messageName;\n            object[\"@type\"] = name;\n            return object;\n        }\n\n        return this.toObject(message, options);\n    }\n};\n","\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(39);\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n","\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(42);\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(39);\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n"],"sourceRoot":"."}"use strict";
var protobuf = require("../..");

/**
 * Debugging utility functions. Only present in debug builds.
 * @namespace
 */
var debug = protobuf.debug = module.exports = {};

var codegen = protobuf.util.codegen;

var debugFnRe = /function ([^(]+)\(([^)]*)\) {/g;

// Counts number of calls to any generated function
function codegen_debug() {
    codegen_debug.supported = codegen.supported;
    codegen_debug.verbose = codegen.verbose;
    var gen = codegen.apply(null, Array.prototype.slice.call(arguments));
    gen.str = (function(str) { return function str_debug() {
        return str.apply(null, Array.prototype.slice.call(arguments)).replace(debugFnRe, "function $1($2) {\n\t$1.calls=($1.calls|0)+1");
    };})(gen.str);
    return gen;
}

/**
 * Returns a list of unused types within the specified root.
 * @param {NamespaceBase} ns Namespace to search
 * @returns {Type[]} Unused types
 */
debug.unusedTypes = function unusedTypes(ns) {

    /* istanbul ignore if */
    if (!(ns instanceof protobuf.Namespace))
        throw TypeError("ns must be a Namespace");

    /* istanbul ignore if */
    if (!ns.nested)
        return [];

    var unused = [];
    for (var names = Object.keys(ns.nested), i = 0; i < names.length; ++i) {
        var nested = ns.nested[names[i]];
        if (nested instanceof protobuf.Type) {
            var calls = (nested.encode.calls|0)
                      + (nested.decode.calls|0)
                      + (nested.verify.calls|0)
                      + (nested.toObject.calls|0)
                      + (nested.fromObject.calls|0);
            if (!calls)
                unused.push(nested);
        } else if (nested instanceof protobuf.Namespace)
            Array.prototype.push.apply(unused, unusedTypes(nested));
    }
    return unused;
};

/**
 * Enables debugging extensions.
 * @returns {undefined}
 */
debug.enable = function enable() {
    protobuf.util.codegen = codegen_debug;
};

/**
 * Disables debugging extensions.
 * @returns {undefined}
 */
debug.disable = function disable() {
    protobuf.util.codegen = codegen;
};
protobufjs/ext/debug
=========================

Experimental debugging extension.
import * as $protobuf from "../..";
export const FileDescriptorSet: $protobuf.Type;

export const FileDescriptorProto: $protobuf.Type;

export const DescriptorProto: $protobuf.Type & {
    ExtensionRange: $protobuf.Type,
    ReservedRange: $protobuf.Type
};

export const FieldDescriptorProto: $protobuf.Type & {
    Label: $protobuf.Enum,
    Type: $protobuf.Enum
};

export const OneofDescriptorProto: $protobuf.Type;

export const EnumDescriptorProto: $protobuf.Type;

export const ServiceDescriptorProto: $protobuf.Type;

export const EnumValueDescriptorProto: $protobuf.Type;

export const MethodDescriptorProto: $protobuf.Type;

export const FileOptions: $protobuf.Type & {
    OptimizeMode: $protobuf.Enum
};

export const MessageOptions: $protobuf.Type;

export const FieldOptions: $protobuf.Type & {
    CType: $protobuf.Enum,
    JSType: $protobuf.Enum
};

export const OneofOptions: $protobuf.Type;

export const EnumOptions: $protobuf.Type;

export const EnumValueOptions: $protobuf.Type;

export const ServiceOptions: $protobuf.Type;

export const MethodOptions: $protobuf.Type;

export const UninterpretedOption: $protobuf.Type & {
    NamePart: $protobuf.Type
};

export const SourceCodeInfo: $protobuf.Type & {
    Location: $protobuf.Type
};

export const GeneratedCodeInfo: $protobuf.Type & {
    Annotation: $protobuf.Type
};

export interface IFileDescriptorSet {
    file: IFileDescriptorProto[];
}

export interface IFileDescriptorProto {
    name?: string;
    package?: string;
    dependency?: any;
    publicDependency?: any;
    weakDependency?: any;
    messageType?: IDescriptorProto[];
    enumType?: IEnumDescriptorProto[];
    service?: IServiceDescriptorProto[];
    extension?: IFieldDescriptorProto[];
    options?: IFileOptions;
    sourceCodeInfo?: any;
    syntax?: string;
}

export interface IFileOptions {
    javaPackage?: string;
    javaOuterClassname?: string;
    javaMultipleFiles?: boolean;
    javaGenerateEqualsAndHash?: boolean;
    javaStringCheckUtf8?: boolean;
    optimizeFor?: IFileOptionsOptimizeMode;
    goPackage?: string;
    ccGenericServices?: boolean;
    javaGenericServices?: boolean;
    pyGenericServices?: boolean;
    deprecated?: boolean;
    ccEnableArenas?: boolean;
    objcClassPrefix?: string;
    csharpNamespace?: string;
}

type IFileOptionsOptimizeMode = number;

export interface IDescriptorProto {
    name?: string;
    field?: IFieldDescriptorProto[];
    extension?: IFieldDescriptorProto[];
    nestedType?: IDescriptorProto[];
    enumType?: IEnumDescriptorProto[];
    extensionRange?: IDescriptorProtoExtensionRange[];
    oneofDecl?: IOneofDescriptorProto[];
    options?: IMessageOptions;
    reservedRange?: IDescriptorProtoReservedRange[];
    reservedName?: string[];
}

export interface IMessageOptions {
    mapEntry?: boolean;
}

export interface IDescriptorProtoExtensionRange {
    start?: number;
    end?: number;
}

export interface IDescriptorProtoReservedRange {
    start?: number;
    end?: number;
}

export interface IFieldDescriptorProto {
    name?: string;
    number?: number;
    label?: IFieldDescriptorProtoLabel;
    type?: IFieldDescriptorProtoType;
    typeName?: string;
    extendee?: string;
    defaultValue?: string;
    oneofIndex?: number;
    jsonName?: any;
    options?: IFieldOptions;
}

type IFieldDescriptorProtoLabel = number;

type IFieldDescriptorProtoType = number;

export interface IFieldOptions {
    packed?: boolean;
    jstype?: IFieldOptionsJSType;
}

type IFieldOptionsJSType = number;

export interface IEnumDescriptorProto {
    name?: string;
    value?: IEnumValueDescriptorProto[];
    options?: IEnumOptions;
}

export interface IEnumValueDescriptorProto {
    name?: string;
    number?: number;
    options?: any;
}

export interface IEnumOptions {
    allowAlias?: boolean;
    deprecated?: boolean;
}

export interface IOneofDescriptorProto {
    name?: string;
    options?: any;
}

export interface IServiceDescriptorProto {
    name?: string;
    method?: IMethodDescriptorProto[];
    options?: IServiceOptions;
}

export interface IServiceOptions {
    deprecated?: boolean;
}

export interface IMethodDescriptorProto {
    name?: string;
    inputType?: string;
    outputType?: string;
    options?: IMethodOptions;
    clientStreaming?: boolean;
    serverStreaming?: boolean;
}

export interface IMethodOptions {
    deprecated?: boolean;
}
"use strict";
var $protobuf = require("../..");
module.exports = exports = $protobuf.descriptor = $protobuf.Root.fromJSON(require("../../google/protobuf/descriptor.json")).lookup(".google.protobuf");

var Namespace = $protobuf.Namespace,
    Root      = $protobuf.Root,
    Enum      = $protobuf.Enum,
    Type      = $protobuf.Type,
    Field     = $protobuf.Field,
    MapField  = $protobuf.MapField,
    OneOf     = $protobuf.OneOf,
    Service   = $protobuf.Service,
    Method    = $protobuf.Method;

// --- Root ---

/**
 * Properties of a FileDescriptorSet message.
 * @interface IFileDescriptorSet
 * @property {IFileDescriptorProto[]} file Files
 */

/**
 * Properties of a FileDescriptorProto message.
 * @interface IFileDescriptorProto
 * @property {string} [name] File name
 * @property {string} [package] Package
 * @property {*} [dependency] Not supported
 * @property {*} [publicDependency] Not supported
 * @property {*} [weakDependency] Not supported
 * @property {IDescriptorProto[]} [messageType] Nested message types
 * @property {IEnumDescriptorProto[]} [enumType] Nested enums
 * @property {IServiceDescriptorProto[]} [service] Nested services
 * @property {IFieldDescriptorProto[]} [extension] Nested extension fields
 * @property {IFileOptions} [options] Options
 * @property {*} [sourceCodeInfo] Not supported
 * @property {string} [syntax="proto2"] Syntax
 */

/**
 * Properties of a FileOptions message.
 * @interface IFileOptions
 * @property {string} [javaPackage]
 * @property {string} [javaOuterClassname]
 * @property {boolean} [javaMultipleFiles]
 * @property {boolean} [javaGenerateEqualsAndHash]
 * @property {boolean} [javaStringCheckUtf8]
 * @property {IFileOptionsOptimizeMode} [optimizeFor=1]
 * @property {string} [goPackage]
 * @property {boolean} [ccGenericServices]
 * @property {boolean} [javaGenericServices]
 * @property {boolean} [pyGenericServices]
 * @property {boolean} [deprecated]
 * @property {boolean} [ccEnableArenas]
 * @property {string} [objcClassPrefix]
 * @property {string} [csharpNamespace]
 */

/**
 * Values of he FileOptions.OptimizeMode enum.
 * @typedef IFileOptionsOptimizeMode
 * @type {number}
 * @property {number} SPEED=1
 * @property {number} CODE_SIZE=2
 * @property {number} LITE_RUNTIME=3
 */

/**
 * Creates a root from a descriptor set.
 * @param {IFileDescriptorSet|Reader|Uint8Array} descriptor Descriptor
 * @returns {Root} Root instance
 */
Root.fromDescriptor = function fromDescriptor(descriptor, options) {

    // Decode the descriptor message if specified as a buffer:
    if (typeof descriptor.length === "number")
        descriptor = exports.FileDescriptorSet.decode(descriptor);

    var root = new Root();

    if (descriptor.file) {
        var fileDescriptor,
            filePackage;
        for (var j = 0, i; j < descriptor.file.length; ++j) {
            filePackage = root;
            if ((fileDescriptor = descriptor.file[j])["package"] && fileDescriptor["package"].length)
                filePackage = root.define(fileDescriptor["package"]);
            if (fileDescriptor.name && fileDescriptor.name.length)
                root.files.push(filePackage.filename = fileDescriptor.name);
            if (fileDescriptor.messageType)
                for (i = 0; i < fileDescriptor.messageType.length; ++i)
                    filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], fileDescriptor.syntax, options));
            if (fileDescriptor.enumType)
                for (i = 0; i < fileDescriptor.enumType.length; ++i)
                    filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i]));
            if (fileDescriptor.extension)
                for (i = 0; i < fileDescriptor.extension.length; ++i)
                    filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i]));
            if (fileDescriptor.service)
                for (i = 0; i < fileDescriptor.service.length; ++i)
                    filePackage.add(Service.fromDescriptor(fileDescriptor.service[i]));
            var opts = fromDescriptorOptions(fileDescriptor.options, exports.FileOptions);
            if (opts) {
                var ks = Object.keys(opts);
                for (i = 0; i < ks.length; ++i)
                    filePackage.setOption(ks[i], opts[ks[i]]);
            }
        }
    }

    return root;
};

/**
 * Converts a root to a descriptor set.
 * @returns {Message<IFileDescriptorSet>} Descriptor
 * @param {string} [syntax="proto2"] Syntax
 */
Root.prototype.toDescriptor = function toDescriptor(syntax) {
    var set = exports.FileDescriptorSet.create();
    Root_toDescriptorRecursive(this, set.file, syntax);
    return set;
};

// Traverses a namespace and assembles the descriptor set
function Root_toDescriptorRecursive(ns, files, syntax) {

    // Create a new file
    var file = exports.FileDescriptorProto.create({ name: ns.filename || (ns.fullName.substring(1).replace(/\./g, "_") || "root") + ".proto" });
    if (syntax)
        file.syntax = syntax;
    if (!(ns instanceof Root))
        file["package"] = ns.fullName.substring(1);

    // Add nested types
    for (var i = 0, nested; i < ns.nestedArray.length; ++i)
        if ((nested = ns._nestedArray[i]) instanceof Type)
            file.messageType.push(nested.toDescriptor(syntax));
        else if (nested instanceof Enum)
            file.enumType.push(nested.toDescriptor());
        else if (nested instanceof Field)
            file.extension.push(nested.toDescriptor(syntax));
        else if (nested instanceof Service)
            file.service.push(nested.toDescriptor());
        else if (nested instanceof /* plain */ Namespace)
            Root_toDescriptorRecursive(nested, files, syntax); // requires new file

    // Keep package-level options
    file.options = toDescriptorOptions(ns.options, exports.FileOptions);

    // And keep the file only if there is at least one nested object
    if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length)
        files.push(file);
}

// --- Type ---

/**
 * Properties of a DescriptorProto message.
 * @interface IDescriptorProto
 * @property {string} [name] Message type name
 * @property {IFieldDescriptorProto[]} [field] Fields
 * @property {IFieldDescriptorProto[]} [extension] Extension fields
 * @property {IDescriptorProto[]} [nestedType] Nested message types
 * @property {IEnumDescriptorProto[]} [enumType] Nested enums
 * @property {IDescriptorProtoExtensionRange[]} [extensionRange] Extension ranges
 * @property {IOneofDescriptorProto[]} [oneofDecl] Oneofs
 * @property {IMessageOptions} [options] Not supported
 * @property {IDescriptorProtoReservedRange[]} [reservedRange] Reserved ranges
 * @property {string[]} [reservedName] Reserved names
 */

/**
 * Properties of a MessageOptions message.
 * @interface IMessageOptions
 * @property {boolean} [mapEntry=false] Whether this message is a map entry
 */

/**
 * Properties of an ExtensionRange message.
 * @interface IDescriptorProtoExtensionRange
 * @property {number} [start] Start field id
 * @property {number} [end] End field id
 */

/**
 * Properties of a ReservedRange message.
 * @interface IDescriptorProtoReservedRange
 * @property {number} [start] Start field id
 * @property {number} [end] End field id
 */

var unnamedMessageIndex = 0;

/**
 * Creates a type from a descriptor.
 * @param {IDescriptorProto|Reader|Uint8Array} descriptor Descriptor
 * @param {string} [syntax="proto2"] Syntax
 * @returns {Type} Type instance
 */
Type.fromDescriptor = function fromDescriptor(descriptor, syntax, options) {

    // Decode the descriptor message if specified as a buffer:
    if (typeof descriptor.length === "number")
        descriptor = exports.DescriptorProto.decode(descriptor);

    // Create the message type
    var type = new Type(descriptor.name.length ? descriptor.name : "Type" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports.MessageOptions)),
        useMapField = options && options.useMapField,
        i;

    /* Oneofs */ if (descriptor.oneofDecl)
        for (i = 0; i < descriptor.oneofDecl.length; ++i)
            type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));
    /* Fields */ if (descriptor.field)
        for (i = 0; i < descriptor.field.length; ++i) {
            var mapType = useMapField && descriptor.nestedType 
                ? descriptor.nestedType.find(function (t) {
                    var currField = descriptor.field[i];
                    var nestedTypeName = currField.typeName && currField.typeName.split('.').pop();
                    return t.options && t.options.mapEntry && t.name === nestedTypeName
                }) 
                : null;
            var field = mapType
                ? MapField.fromDescriptor(descriptor.field[i], mapType, syntax)
                : Field.fromDescriptor(descriptor.field[i], syntax);

            type.add(field);
            if (descriptor.field[i].hasOwnProperty("oneofIndex")) // eslint-disable-line no-prototype-builtins
                type.oneofsArray[descriptor.field[i].oneofIndex].add(field);
        }
    /* Extension fields */ if (descriptor.extension)
        for (i = 0; i < descriptor.extension.length; ++i)
            type.add(Field.fromDescriptor(descriptor.extension[i], syntax));
    /* Nested types */ if (descriptor.nestedType)
        for (i = 0; i < descriptor.nestedType.length; ++i) {
            if (useMapField) {
                // Nested types representing map entry are added as MapField and should not be added as Type
                if (!descriptor.nestedType[i].options || !descriptor.nestedType[i].options.mapEntry)
                    type.add(Type.fromDescriptor(descriptor.nestedType[i], syntax, options));
            } else {
                type.add(Type.fromDescriptor(descriptor.nestedType[i], syntax, options));
                if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry)
                    type.setOption("map_entry", true);
            }
        }
    /* Nested enums */ if (descriptor.enumType)
        for (i = 0; i < descriptor.enumType.length; ++i)
            type.add(Enum.fromDescriptor(descriptor.enumType[i]));
    /* Extension ranges */ if (descriptor.extensionRange && descriptor.extensionRange.length) {
        type.extensions = [];
        for (i = 0; i < descriptor.extensionRange.length; ++i)
            type.extensions.push([ descriptor.extensionRange[i].start, descriptor.extensionRange[i].end ]);
    }
    /* Reserved... */ if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {
        type.reserved = [];
        /* Ranges */ if (descriptor.reservedRange)
            for (i = 0; i < descriptor.reservedRange.length; ++i)
                type.reserved.push([ descriptor.reservedRange[i].start, descriptor.reservedRange[i].end ]);
        /* Names */ if (descriptor.reservedName)
            for (i = 0; i < descriptor.reservedName.length; ++i)
                type.reserved.push(descriptor.reservedName[i]);
    }

    return type;
};

/**
 * Converts a type to a descriptor.
 * @returns {Message<IDescriptorProto>} Descriptor
 * @param {string} [syntax="proto2"] Syntax
 */
Type.prototype.toDescriptor = function toDescriptor(syntax) {
    var descriptor = exports.DescriptorProto.create({ name: this.name }),
        i;

    /* Fields */ for (i = 0; i < this.fieldsArray.length; ++i) {
        var fieldDescriptor;
        descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(syntax));
        if (this._fieldsArray[i] instanceof MapField) { // map fields are repeated FieldNameEntry
            var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType),
                valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType),
                valueTypeName = valueType === /* type */ 11 || valueType === /* enum */ 14
                    ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type
                    : undefined;
            descriptor.nestedType.push(exports.DescriptorProto.create({
                name: fieldDescriptor.typeName,
                field: [
                    exports.FieldDescriptorProto.create({ name: "key", number: 1, label: 1, type: keyType }), // can't reference a type or enum
                    exports.FieldDescriptorProto.create({ name: "value", number: 2, label: 1, type: valueType, typeName: valueTypeName })
                ],
                options: exports.MessageOptions.create({ mapEntry: true })
            }));
        }
    }
    /* Oneofs */ for (i = 0; i < this.oneofsArray.length; ++i)
        descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());
    /* Nested... */ for (i = 0; i < this.nestedArray.length; ++i) {
        /* Extension fields */ if (this._nestedArray[i] instanceof Field)
            descriptor.field.push(this._nestedArray[i].toDescriptor(syntax));
        /* Types */ else if (this._nestedArray[i] instanceof Type)
            descriptor.nestedType.push(this._nestedArray[i].toDescriptor(syntax));
        /* Enums */ else if (this._nestedArray[i] instanceof Enum)
            descriptor.enumType.push(this._nestedArray[i].toDescriptor());
        // plain nested namespaces become packages instead in Root#toDescriptor
    }
    /* Extension ranges */ if (this.extensions)
        for (i = 0; i < this.extensions.length; ++i)
            descriptor.extensionRange.push(exports.DescriptorProto.ExtensionRange.create({ start: this.extensions[i][0], end: this.extensions[i][1] }));
    /* Reserved... */ if (this.reserved)
        for (i = 0; i < this.reserved.length; ++i)
            /* Names */ if (typeof this.reserved[i] === "string")
                descriptor.reservedName.push(this.reserved[i]);
            /* Ranges */ else
                descriptor.reservedRange.push(exports.DescriptorProto.ReservedRange.create({ start: this.reserved[i][0], end: this.reserved[i][1] }));

    descriptor.options = toDescriptorOptions(this.options, exports.MessageOptions);

    return descriptor;
};

// --- Field ---

/**
 * Properties of a FieldDescriptorProto message.
 * @interface IFieldDescriptorProto
 * @property {string} [name] Field name
 * @property {number} [number] Field id
 * @property {IFieldDescriptorProtoLabel} [label] Field rule
 * @property {IFieldDescriptorProtoType} [type] Field basic type
 * @property {string} [typeName] Field type name
 * @property {string} [extendee] Extended type name
 * @property {string} [defaultValue] Literal default value
 * @property {number} [oneofIndex] Oneof index if part of a oneof
 * @property {*} [jsonName] Not supported
 * @property {IFieldOptions} [options] Field options
 */

/**
 * Values of the FieldDescriptorProto.Label enum.
 * @typedef IFieldDescriptorProtoLabel
 * @type {number}
 * @property {number} LABEL_OPTIONAL=1
 * @property {number} LABEL_REQUIRED=2
 * @property {number} LABEL_REPEATED=3
 */

/**
 * Values of the FieldDescriptorProto.Type enum.
 * @typedef IFieldDescriptorProtoType
 * @type {number}
 * @property {number} TYPE_DOUBLE=1
 * @property {number} TYPE_FLOAT=2
 * @property {number} TYPE_INT64=3
 * @property {number} TYPE_UINT64=4
 * @property {number} TYPE_INT32=5
 * @property {number} TYPE_FIXED64=6
 * @property {number} TYPE_FIXED32=7
 * @property {number} TYPE_BOOL=8
 * @property {number} TYPE_STRING=9
 * @property {number} TYPE_GROUP=10
 * @property {number} TYPE_MESSAGE=11
 * @property {number} TYPE_BYTES=12
 * @property {number} TYPE_UINT32=13
 * @property {number} TYPE_ENUM=14
 * @property {number} TYPE_SFIXED32=15
 * @property {number} TYPE_SFIXED64=16
 * @property {number} TYPE_SINT32=17
 * @property {number} TYPE_SINT64=18
 */

/**
 * Properties of a FieldOptions message.
 * @interface IFieldOptions
 * @property {boolean} [packed] Whether packed or not (defaults to `false` for proto2 and `true` for proto3)
 * @property {IFieldOptionsJSType} [jstype] JavaScript value type (not used by protobuf.js)
 */

/**
 * Values of the FieldOptions.JSType enum.
 * @typedef IFieldOptionsJSType
 * @type {number}
 * @property {number} JS_NORMAL=0
 * @property {number} JS_STRING=1
 * @property {number} JS_NUMBER=2
 */

// copied here from parse.js
var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;

/**
 * Creates a field from a descriptor.
 * @param {IFieldDescriptorProto|Reader|Uint8Array} descriptor Descriptor
 * @param {string} [syntax="proto2"] Syntax
 * @returns {Field} Field instance
 */
Field.fromDescriptor = function fromDescriptor(descriptor, syntax) {

    // Decode the descriptor message if specified as a buffer:
    if (typeof descriptor.length === "number")
        descriptor = exports.DescriptorProto.decode(descriptor);

    if (typeof descriptor.number !== "number")
        throw Error("missing field id");

    // Rewire field type
    var fieldType;
    if (descriptor.typeName && descriptor.typeName.length)
        fieldType = descriptor.typeName;
    else
        fieldType = fromDescriptorType(descriptor.type);

    // Rewire field rule
    var fieldRule;
    switch (descriptor.label) {
        // 0 is reserved for errors
        case 1: fieldRule = undefined; break;
        case 2: fieldRule = "required"; break;
        case 3: fieldRule = "repeated"; break;
        default: throw Error("illegal label: " + descriptor.label);
    }

	var extendee = descriptor.extendee;
	if (descriptor.extendee !== undefined) {
		extendee = extendee.length ? extendee : undefined;
	}
    var field = new Field(
        descriptor.name.length ? descriptor.name : "field" + descriptor.number,
        descriptor.number,
        fieldType,
        fieldRule,
        extendee
    );

    field.options = fromDescriptorOptions(descriptor.options, exports.FieldOptions);

    if (descriptor.defaultValue && descriptor.defaultValue.length) {
        var defaultValue = descriptor.defaultValue;
        switch (defaultValue) {
            case "true": case "TRUE":
                defaultValue = true;
                break;
            case "false": case "FALSE":
                defaultValue = false;
                break;
            default:
                var match = numberRe.exec(defaultValue);
                if (match)
                    defaultValue = parseInt(defaultValue); // eslint-disable-line radix
                break;
        }
        field.setOption("default", defaultValue);
    }

    if (packableDescriptorType(descriptor.type)) {
        if (syntax === "proto3") { // defaults to packed=true (internal preset is packed=true)
            if (descriptor.options && !descriptor.options.packed)
                field.setOption("packed", false);
        } else if (!(descriptor.options && descriptor.options.packed)) // defaults to packed=false
            field.setOption("packed", false);
    }

    return field;
};

/**
 * Converts a field to a descriptor.
 * @returns {Message<IFieldDescriptorProto>} Descriptor
 * @param {string} [syntax="proto2"] Syntax
 */
Field.prototype.toDescriptor = function toDescriptor(syntax) {
    var descriptor = exports.FieldDescriptorProto.create({ name: this.name, number: this.id });

    if (this.map) {

        descriptor.type = 11; // message
        descriptor.typeName = $protobuf.util.ucFirst(this.name); // fieldName -> FieldNameEntry (built in Type#toDescriptor)
        descriptor.label = 3; // repeated

    } else {

        // Rewire field type
        switch (descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType)) {
            case 10: // group
            case 11: // type
            case 14: // enum
                descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;
                break;
        }

        // Rewire field rule
        switch (this.rule) {
            case "repeated": descriptor.label = 3; break;
            case "required": descriptor.label = 2; break;
            default: descriptor.label = 1; break;
        }

    }

    // Handle extension field
    descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;

    // Handle part of oneof
    if (this.partOf)
        if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0)
            throw Error("missing oneof");

    if (this.options) {
        descriptor.options = toDescriptorOptions(this.options, exports.FieldOptions);
        if (this.options["default"] != null)
            descriptor.defaultValue = String(this.options["default"]);
    }

    if (syntax === "proto3") { // defaults to packed=true
        if (!this.packed)
            (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = false;
    } else if (this.packed) // defaults to packed=false
        (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = true;

    return descriptor;
};

// --- MapField ---

/**
 * Creates a map field from a descriptor.
 * @param {IFieldDescriptorProto|Reader|Uint8Array} descriptor Descriptor
 * @param {IDescriptorProto} nestedType Nested type descriptor
 * @returns {MapField} MapField instance
 */
MapField.fromDescriptor = function fromDescriptor(descriptor, nestedType) {
    // Decode the descriptor message if specified as a buffer:
    if (typeof descriptor.length === "number")
        descriptor = exports.DescriptorProto.decode(descriptor);

    // Decode the nested type if specified as a buffer:
    if (typeof nestedType.length === "number")
        nestedType = exports.DescriptorProto.decode(nestedType);

    if (typeof descriptor.number !== "number")
        throw Error("missing field id");

    var typeName = nestedType.field[1].typeName;
    var type = typeName && typeName.length 
        ? typeName 
        : fromDescriptorType(nestedType.field[1].type);

    var field = new MapField(
        descriptor.name.length ? descriptor.name : "field" + descriptor.number,
        descriptor.number,
        fromDescriptorType(nestedType.field[0].type),
        type,
        fromDescriptorOptions(descriptor.options, exports.FieldOptions)
    );

    var extendee = descriptor.extendee;
    if (extendee !== undefined) {
        field.extend = extendee.length ? extendee : undefined;
    }

    if (descriptor.defaultValue && descriptor.defaultValue.length) {
        var defaultValue = descriptor.defaultValue;
        switch (defaultValue) {
            case "true": case "TRUE":
                defaultValue = true;
                break;
            case "false": case "FALSE":
                defaultValue = false;
                break;
            default:
                var match = numberRe.exec(defaultValue);
                if (match)
                    defaultValue = parseInt(defaultValue); // eslint-disable-line radix
                break;
        }
        field.setOption("default", defaultValue);
    }

    return field;
}

// --- Enum ---

/**
 * Properties of an EnumDescriptorProto message.
 * @interface IEnumDescriptorProto
 * @property {string} [name] Enum name
 * @property {IEnumValueDescriptorProto[]} [value] Enum values
 * @property {IEnumOptions} [options] Enum options
 */

/**
 * Properties of an EnumValueDescriptorProto message.
 * @interface IEnumValueDescriptorProto
 * @property {string} [name] Name
 * @property {number} [number] Value
 * @property {*} [options] Not supported
 */

/**
 * Properties of an EnumOptions message.
 * @interface IEnumOptions
 * @property {boolean} [allowAlias] Whether aliases are allowed
 * @property {boolean} [deprecated]
 */

var unnamedEnumIndex = 0;

/**
 * Creates an enum from a descriptor.
 * @param {IEnumDescriptorProto|Reader|Uint8Array} descriptor Descriptor
 * @returns {Enum} Enum instance
 */
Enum.fromDescriptor = function fromDescriptor(descriptor) {

    // Decode the descriptor message if specified as a buffer:
    if (typeof descriptor.length === "number")
        descriptor = exports.EnumDescriptorProto.decode(descriptor);

    // Construct values object
    var values = {};
    if (descriptor.value)
        for (var i = 0; i < descriptor.value.length; ++i) {
            var name  = descriptor.value[i].name,
                value = descriptor.value[i].number || 0;
            values[name && name.length ? name : "NAME" + value] = value;
        }

    return new Enum(
        descriptor.name && descriptor.name.length ? descriptor.name : "Enum" + unnamedEnumIndex++,
        values,
        fromDescriptorOptions(descriptor.options, exports.EnumOptions)
    );
};

/**
 * Converts an enum to a descriptor.
 * @returns {Message<IEnumDescriptorProto>} Descriptor
 */
Enum.prototype.toDescriptor = function toDescriptor() {

    // Values
    var values = [];
    for (var i = 0, ks = Object.keys(this.values); i < ks.length; ++i)
        values.push(exports.EnumValueDescriptorProto.create({ name: ks[i], number: this.values[ks[i]] }));

    return exports.EnumDescriptorProto.create({
        name: this.name,
        value: values,
        options: toDescriptorOptions(this.options, exports.EnumOptions)
    });
};

// --- OneOf ---

/**
 * Properties of a OneofDescriptorProto message.
 * @interface IOneofDescriptorProto
 * @property {string} [name] Oneof name
 * @property {*} [options] Not supported
 */

var unnamedOneofIndex = 0;

/**
 * Creates a oneof from a descriptor.
 * @param {IOneofDescriptorProto|Reader|Uint8Array} descriptor Descriptor
 * @returns {OneOf} OneOf instance
 */
OneOf.fromDescriptor = function fromDescriptor(descriptor) {

    // Decode the descriptor message if specified as a buffer:
    if (typeof descriptor.length === "number")
        descriptor = exports.OneofDescriptorProto.decode(descriptor);

    return new OneOf(
        // unnamedOneOfIndex is global, not per type, because we have no ref to a type here
        descriptor.name && descriptor.name.length ? descriptor.name : "oneof" + unnamedOneofIndex++
        // fromDescriptorOptions(descriptor.options, exports.OneofOptions) - only uninterpreted_option
    );
};

/**
 * Converts a oneof to a descriptor.
 * @returns {Message<IOneofDescriptorProto>} Descriptor
 */
OneOf.prototype.toDescriptor = function toDescriptor() {
    return exports.OneofDescriptorProto.create({
        name: this.name
        // options: toDescriptorOptions(this.options, exports.OneofOptions) - only uninterpreted_option
    });
};

// --- Service ---

/**
 * Properties of a ServiceDescriptorProto message.
 * @interface IServiceDescriptorProto
 * @property {string} [name] Service name
 * @property {IMethodDescriptorProto[]} [method] Methods
 * @property {IServiceOptions} [options] Options
 */

/**
 * Properties of a ServiceOptions message.
 * @interface IServiceOptions
 * @property {boolean} [deprecated]
 */

var unnamedServiceIndex = 0;

/**
 * Creates a service from a descriptor.
 * @param {IServiceDescriptorProto|Reader|Uint8Array} descriptor Descriptor
 * @returns {Service} Service instance
 */
Service.fromDescriptor = function fromDescriptor(descriptor) {

    // Decode the descriptor message if specified as a buffer:
    if (typeof descriptor.length === "number")
        descriptor = exports.ServiceDescriptorProto.decode(descriptor);

    var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : "Service" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports.ServiceOptions));
    if (descriptor.method)
        for (var i = 0; i < descriptor.method.length; ++i)
            service.add(Method.fromDescriptor(descriptor.method[i]));

    return service;
};

/**
 * Converts a service to a descriptor.
 * @returns {Message<IServiceDescriptorProto>} Descriptor
 */
Service.prototype.toDescriptor = function toDescriptor() {

    // Methods
    var methods = [];
    for (var i = 0; i < this.methodsArray.length; ++i)
        methods.push(this._methodsArray[i].toDescriptor());

    return exports.ServiceDescriptorProto.create({
        name: this.name,
        method: methods,
        options: toDescriptorOptions(this.options, exports.ServiceOptions)
    });
};

// --- Method ---

/**
 * Properties of a MethodDescriptorProto message.
 * @interface IMethodDescriptorProto
 * @property {string} [name] Method name
 * @property {string} [inputType] Request type name
 * @property {string} [outputType] Response type name
 * @property {IMethodOptions} [options] Not supported
 * @property {boolean} [clientStreaming=false] Whether requests are streamed
 * @property {boolean} [serverStreaming=false] Whether responses are streamed
 */

/**
 * Properties of a MethodOptions message.
 * @interface IMethodOptions
 * @property {boolean} [deprecated]
 */

var unnamedMethodIndex = 0;

/**
 * Creates a method from a descriptor.
 * @param {IMethodDescriptorProto|Reader|Uint8Array} descriptor Descriptor
 * @returns {Method} Reflected method instance
 */
Method.fromDescriptor = function fromDescriptor(descriptor) {

    // Decode the descriptor message if specified as a buffer:
    if (typeof descriptor.length === "number")
        descriptor = exports.MethodDescriptorProto.decode(descriptor);

    return new Method(
        // unnamedMethodIndex is global, not per service, because we have no ref to a service here
        descriptor.name && descriptor.name.length ? descriptor.name : "Method" + unnamedMethodIndex++,
        "rpc",
        descriptor.inputType,
        descriptor.outputType,
        Boolean(descriptor.clientStreaming),
        Boolean(descriptor.serverStreaming),
        fromDescriptorOptions(descriptor.options, exports.MethodOptions)
    );
};

/**
 * Converts a method to a descriptor.
 * @returns {Message<IMethodDescriptorProto>} Descriptor
 */
Method.prototype.toDescriptor = function toDescriptor() {
    return exports.MethodDescriptorProto.create({
        name: this.name,
        inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,
        outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,
        clientStreaming: this.requestStream,
        serverStreaming: this.responseStream,
        options: toDescriptorOptions(this.options, exports.MethodOptions)
    });
};

// --- utility ---

// Converts a descriptor type to a protobuf.js basic type
function fromDescriptorType(type) {
    switch (type) {
        // 0 is reserved for errors
        case 1: return "double";
        case 2: return "float";
        case 3: return "int64";
        case 4: return "uint64";
        case 5: return "int32";
        case 6: return "fixed64";
        case 7: return "fixed32";
        case 8: return "bool";
        case 9: return "string";
        case 12: return "bytes";
        case 13: return "uint32";
        case 15: return "sfixed32";
        case 16: return "sfixed64";
        case 17: return "sint32";
        case 18: return "sint64";
    }
    throw Error("illegal type: " + type);
}

// Tests if a descriptor type is packable
function packableDescriptorType(type) {
    switch (type) {
        case 1: // double
        case 2: // float
        case 3: // int64
        case 4: // uint64
        case 5: // int32
        case 6: // fixed64
        case 7: // fixed32
        case 8: // bool
        case 13: // uint32
        case 14: // enum (!)
        case 15: // sfixed32
        case 16: // sfixed64
        case 17: // sint32
        case 18: // sint64
            return true;
    }
    return false;
}

// Converts a protobuf.js basic type to a descriptor type
function toDescriptorType(type, resolvedType) {
    switch (type) {
        // 0 is reserved for errors
        case "double": return 1;
        case "float": return 2;
        case "int64": return 3;
        case "uint64": return 4;
        case "int32": return 5;
        case "fixed64": return 6;
        case "fixed32": return 7;
        case "bool": return 8;
        case "string": return 9;
        case "bytes": return 12;
        case "uint32": return 13;
        case "sfixed32": return 15;
        case "sfixed64": return 16;
        case "sint32": return 17;
        case "sint64": return 18;
    }
    if (resolvedType instanceof Enum)
        return 14;
    if (resolvedType instanceof Type)
        return resolvedType.group ? 10 : 11;
    throw Error("illegal type: " + type);
}

// Converts descriptor options to an options object
function fromDescriptorOptions(options, type) {
    if (!options)
        return undefined;
    var out = [];
    for (var i = 0, field, key, val; i < type.fieldsArray.length; ++i)
        if ((key = (field = type._fieldsArray[i]).name) !== "uninterpretedOption")
            if (options.hasOwnProperty(key)) { // eslint-disable-line no-prototype-builtins
                val = options[key];
                if (field.resolvedType instanceof Enum && typeof val === "number" && field.resolvedType.valuesById[val] !== undefined)
                    val = field.resolvedType.valuesById[val];
                out.push(underScore(key), val);
            }
    return out.length ? $protobuf.util.toObject(out) : undefined;
}

// Converts an options object to descriptor options
function toDescriptorOptions(options, type) {
    if (!options)
        return undefined;
    var out = [];
    for (var i = 0, ks = Object.keys(options), key, val; i < ks.length; ++i) {
        val = options[key = ks[i]];
        if (key === "default")
            continue;
        var field = type.fields[key];
        if (!field && !(field = type.fields[key = $protobuf.util.camelCase(key)]))
            continue;
        out.push(key, val);
    }
    return out.length ? type.fromObject($protobuf.util.toObject(out)) : undefined;
}

// Calculates the shortest relative path from `from` to `to`.
function shortname(from, to) {
    var fromPath = from.fullName.split("."),
        toPath = to.fullName.split("."),
        i = 0,
        j = 0,
        k = toPath.length - 1;
    if (!(from instanceof Root) && to instanceof Namespace)
        while (i < fromPath.length && j < k && fromPath[i] === toPath[j]) {
            var other = to.lookup(fromPath[i++], true);
            if (other !== null && other !== to)
                break;
            ++j;
        }
    else
        for (; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j);
    return toPath.slice(j).join(".");
}

// copied here from cli/targets/proto.js
function underScore(str) {
    return str.substring(0,1)
         + str.substring(1)
               .replace(/([A-Z])(?=[a-z]|$)/g, function($0, $1) { return "_" + $1.toLowerCase(); });
}

// --- exports ---

/**
 * Reflected file descriptor set.
 * @name FileDescriptorSet
 * @type {Type}
 * @const
 * @tstype $protobuf.Type
 */

/**
 * Reflected file descriptor proto.
 * @name FileDescriptorProto
 * @type {Type}
 * @const
 * @tstype $protobuf.Type
 */

/**
 * Reflected descriptor proto.
 * @name DescriptorProto
 * @type {Type}
 * @property {Type} ExtensionRange
 * @property {Type} ReservedRange
 * @const
 * @tstype $protobuf.Type & {
 *     ExtensionRange: $protobuf.Type,
 *     ReservedRange: $protobuf.Type
 * }
 */

/**
 * Reflected field descriptor proto.
 * @name FieldDescriptorProto
 * @type {Type}
 * @property {Enum} Label
 * @property {Enum} Type
 * @const
 * @tstype $protobuf.Type & {
 *     Label: $protobuf.Enum,
 *     Type: $protobuf.Enum
 * }
 */

/**
 * Reflected oneof descriptor proto.
 * @name OneofDescriptorProto
 * @type {Type}
 * @const
 * @tstype $protobuf.Type
 */

/**
 * Reflected enum descriptor proto.
 * @name EnumDescriptorProto
 * @type {Type}
 * @const
 * @tstype $protobuf.Type
 */

/**
 * Reflected service descriptor proto.
 * @name ServiceDescriptorProto
 * @type {Type}
 * @const
 * @tstype $protobuf.Type
 */

/**
 * Reflected enum value descriptor proto.
 * @name EnumValueDescriptorProto
 * @type {Type}
 * @const
 * @tstype $protobuf.Type
 */

/**
 * Reflected method descriptor proto.
 * @name MethodDescriptorProto
 * @type {Type}
 * @const
 * @tstype $protobuf.Type
 */

/**
 * Reflected file options.
 * @name FileOptions
 * @type {Type}
 * @property {Enum} OptimizeMode
 * @const
 * @tstype $protobuf.Type & {
 *     OptimizeMode: $protobuf.Enum
 * }
 */

/**
 * Reflected message options.
 * @name MessageOptions
 * @type {Type}
 * @const
 * @tstype $protobuf.Type
 */

/**
 * Reflected field options.
 * @name FieldOptions
 * @type {Type}
 * @property {Enum} CType
 * @property {Enum} JSType
 * @const
 * @tstype $protobuf.Type & {
 *     CType: $protobuf.Enum,
 *     JSType: $protobuf.Enum
 * }
 */

/**
 * Reflected oneof options.
 * @name OneofOptions
 * @type {Type}
 * @const
 * @tstype $protobuf.Type
 */

/**
 * Reflected enum options.
 * @name EnumOptions
 * @type {Type}
 * @const
 * @tstype $protobuf.Type
 */

/**
 * Reflected enum value options.
 * @name EnumValueOptions
 * @type {Type}
 * @const
 * @tstype $protobuf.Type
 */

/**
 * Reflected service options.
 * @name ServiceOptions
 * @type {Type}
 * @const
 * @tstype $protobuf.Type
 */

/**
 * Reflected method options.
 * @name MethodOptions
 * @type {Type}
 * @const
 * @tstype $protobuf.Type
 */

/**
 * Reflected uninterpretet option.
 * @name UninterpretedOption
 * @type {Type}
 * @property {Type} NamePart
 * @const
 * @tstype $protobuf.Type & {
 *     NamePart: $protobuf.Type
 * }
 */

/**
 * Reflected source code info.
 * @name SourceCodeInfo
 * @type {Type}
 * @property {Type} Location
 * @const
 * @tstype $protobuf.Type & {
 *     Location: $protobuf.Type
 * }
 */

/**
 * Reflected generated code info.
 * @name GeneratedCodeInfo
 * @type {Type}
 * @property {Type} Annotation
 * @const
 * @tstype $protobuf.Type & {
 *     Annotation: $protobuf.Type
 * }
 */
protobufjs/ext/descriptor
=========================

Experimental extension for interoperability with [descriptor.proto](https://github.com/google/protobuf/blob/master/src/google/protobuf/descriptor.proto) types.

Usage
-----

```js
var protobuf   = require("protobufjs"), // requires the full library
    descriptor = require("protobufjs/ext/descriptor");

var root = ...;

// convert any existing root instance to the corresponding descriptor type
var descriptorMsg = root.toDescriptor("proto2");
// ^ returns a FileDescriptorSet message, see table below

// encode to a descriptor buffer
var buffer = descriptor.FileDescriptorSet.encode(descriptorMsg).finish();

// decode from a descriptor buffer
var decodedDescriptor = descriptor.FileDescriptorSet.decode(buffer);

// convert any existing descriptor to a root instance
root = protobuf.Root.fromDescriptor(decodedDescriptor);
// ^ expects a FileDescriptorSet message or buffer, see table below

// and start all over again
```

API
---

The extension adds `.fromDescriptor(descriptor[, syntax])` and `#toDescriptor([syntax])` methods to reflection objects and exports the `.google.protobuf` namespace of the internally used `Root` instance containing the following types present in descriptor.proto:

| Descriptor type               | protobuf.js type | Remarks
|-------------------------------|------------------|---------
| **FileDescriptorSet**         | Root             |
| FileDescriptorProto           |                  | dependencies are not supported
| FileOptions                   |                  |
| FileOptionsOptimizeMode       |                  |
| SourceCodeInfo                |                  | not supported
| SourceCodeInfoLocation        |                  |
| GeneratedCodeInfo             |                  | not supported
| GeneratedCodeInfoAnnotation   |                  |
| **DescriptorProto**           | Type             |
| MessageOptions                |                  |
| DescriptorProtoExtensionRange |                  |
| DescriptorProtoReservedRange  |                  |
| **FieldDescriptorProto**      | Field            |
| FieldDescriptorProtoLabel     |                  |
| FieldDescriptorProtoType      |                  |
| FieldOptions                  |                  |
| FieldOptionsCType             |                  |
| FieldOptionsJSType            |                  |
| **OneofDescriptorProto**      | OneOf            |
| OneofOptions                  |                  |
| **EnumDescriptorProto**       | Enum             |
| EnumOptions                   |                  |
| EnumValueDescriptorProto      |                  |
| EnumValueOptions              |                  | not supported
| **ServiceDescriptorProto**    | Service          |
| ServiceOptions                |                  |
| **MethodDescriptorProto**     | Method           |
| MethodOptions                 |                  |
| UninterpretedOption           |                  | not supported
| UninterpretedOptionNamePart   |                  |

Note that not all features of descriptor.proto translate perfectly to a protobuf.js root instance. A root instance has only limited knowlege of packages or individual files for example, which is then compensated by guessing and generating fictional file names.

When using TypeScript, the respective interface types can be used to reference specific message instances (i.e. `protobuf.Message<IDescriptorProto>`).
/*eslint-disable no-console*/
"use strict";
var protobuf   = require("../../"),
    descriptor = require(".");

/* var proto = {
    nested: {
        Message: {
            fields: {
                foo: {
                    type: "string",
                    id: 1
                }
            },
            nested: {
                SubMessage: {
                    fields: {}
                }
            }
        },
        Enum: {
            values: {
                ONE: 1,
                TWO: 2
            }
        }
    }
}; */

// var root = protobuf.Root.fromJSON(proto).resolveAll();
var root = protobuf.loadSync("tests/data/google/protobuf/descriptor.proto").resolveAll();

// console.log("Original proto", JSON.stringify(root, null, 2));

var msg  = root.toDescriptor();

// console.log("\nDescriptor", JSON.stringify(msg.toObject(), null, 2));

var buf  = descriptor.FileDescriptorSet.encode(msg).finish();
var root2 = protobuf.Root.fromDescriptor(buf, "proto2").resolveAll();

// console.log("\nDecoded proto", JSON.stringify(root2, null, 2));

var diff = require("deep-diff").diff(root.toJSON(), root2.toJSON());
if (diff) {
    diff.forEach(function(diff) {
        console.log(diff.kind + " @ " + diff.path.join("."));
        console.log("lhs:", typeof diff.lhs, diff.lhs);
        console.log("rhs:", typeof diff.rhs, diff.rhs);
        console.log();
    });
    process.exitCode = 1;
} else
    console.log("no differences");
{
  "nested": {
    "google": {
      "nested": {
        "api": {
          "nested": {
            "http": {
              "type": "HttpRule",
              "id": 72295728,
              "extend": "google.protobuf.MethodOptions"
            },
            "HttpRule": {
              "oneofs": {
                "pattern": {
                  "oneof": [
                    "get",
                    "put",
                    "post",
                    "delete",
                    "patch",
                    "custom"
                  ]
                }
              },
              "fields": {
                "get": {
                  "type": "string",
                  "id": 2
                },
                "put": {
                  "type": "string",
                  "id": 3
                },
                "post": {
                  "type": "string",
                  "id": 4
                },
                "delete": {
                  "type": "string",
                  "id": 5
                },
                "patch": {
                  "type": "string",
                  "id": 6
                },
                "custom": {
                  "type": "CustomHttpPattern",
                  "id": 8
                },
                "selector": {
                  "type": "string",
                  "id": 1
                },
                "body": {
                  "type": "string",
                  "id": 7
                },
                "additionalBindings": {
                  "rule": "repeated",
                  "type": "HttpRule",
                  "id": 11
                }
              }
            }
          }
        },
        "protobuf": {
          "nested": {
            "MethodOptions": {
              "fields": {},
              "extensions": [
                [
                  1000,
                  536870911
                ]
              ]
            }
          }
        }
      }
    }
  }
}syntax = "proto3";

package google.api;

import "google/api/http.proto";
import "google/protobuf/descriptor.proto";

extend google.protobuf.MethodOptions {

    HttpRule http = 72295728;
}{
  "nested": {
    "google": {
      "nested": {
        "api": {
          "nested": {
            "Http": {
              "fields": {
                "rules": {
                  "rule": "repeated",
                  "type": "HttpRule",
                  "id": 1
                }
              }
            },
            "HttpRule": {
              "oneofs": {
                "pattern": {
                  "oneof": [
                    "get",
                    "put",
                    "post",
                    "delete",
                    "patch",
                    "custom"
                  ]
                }
              },
              "fields": {
                "get": {
                  "type": "string",
                  "id": 2
                },
                "put": {
                  "type": "string",
                  "id": 3
                },
                "post": {
                  "type": "string",
                  "id": 4
                },
                "delete": {
                  "type": "string",
                  "id": 5
                },
                "patch": {
                  "type": "string",
                  "id": 6
                },
                "custom": {
                  "type": "CustomHttpPattern",
                  "id": 8
                },
                "selector": {
                  "type": "string",
                  "id": 1
                },
                "body": {
                  "type": "string",
                  "id": 7
                },
                "additionalBindings": {
                  "rule": "repeated",
                  "type": "HttpRule",
                  "id": 11
                }
              }
            },
            "CustomHttpPattern": {
              "fields": {
                "kind": {
                  "type": "string",
                  "id": 1
                },
                "path": {
                  "type": "string",
                  "id": 2
                }
              }
            }
          }
        }
      }
    }
  }
}syntax = "proto3";

package google.api;

message Http {

    repeated HttpRule rules = 1;
}

message HttpRule {

    oneof pattern {

        string get = 2;
        string put = 3;
        string post = 4;
        string delete = 5;
        string patch = 6;
        CustomHttpPattern custom = 8;
    }

    string selector = 1;
    string body = 7;
    repeated HttpRule additional_bindings = 11;
}

message CustomHttpPattern {

    string kind = 1;
    string path = 2;
}Copyright 2014, Google Inc.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
    * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{
  "nested": {
    "google": {
      "nested": {
        "protobuf": {
          "nested": {
            "Api": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "methods": {
                  "rule": "repeated",
                  "type": "Method",
                  "id": 2
                },
                "options": {
                  "rule": "repeated",
                  "type": "Option",
                  "id": 3
                },
                "version": {
                  "type": "string",
                  "id": 4
                },
                "sourceContext": {
                  "type": "SourceContext",
                  "id": 5
                },
                "mixins": {
                  "rule": "repeated",
                  "type": "Mixin",
                  "id": 6
                },
                "syntax": {
                  "type": "Syntax",
                  "id": 7
                }
              }
            },
            "Method": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "requestTypeUrl": {
                  "type": "string",
                  "id": 2
                },
                "requestStreaming": {
                  "type": "bool",
                  "id": 3
                },
                "responseTypeUrl": {
                  "type": "string",
                  "id": 4
                },
                "responseStreaming": {
                  "type": "bool",
                  "id": 5
                },
                "options": {
                  "rule": "repeated",
                  "type": "Option",
                  "id": 6
                },
                "syntax": {
                  "type": "Syntax",
                  "id": 7
                }
              }
            },
            "Mixin": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "root": {
                  "type": "string",
                  "id": 2
                }
              }
            },
            "SourceContext": {
              "fields": {
                "fileName": {
                  "type": "string",
                  "id": 1
                }
              }
            },
            "Option": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "value": {
                  "type": "Any",
                  "id": 2
                }
              }
            },
            "Syntax": {
              "values": {
                "SYNTAX_PROTO2": 0,
                "SYNTAX_PROTO3": 1
              }
            }
          }
        }
      }
    }
  }
}syntax = "proto3";

package google.protobuf;

import "google/protobuf/source_context.proto";
import "google/protobuf/type.proto";

message Api {

    string name = 1;
    repeated Method methods = 2;
    repeated Option options = 3;
    string version = 4;
    SourceContext source_context = 5;
    repeated Mixin mixins = 6;
    Syntax syntax = 7;
}

message Method {

    string name = 1;
    string request_type_url = 2;
    bool request_streaming = 3;
    string response_type_url = 4;
    bool response_streaming = 5;
    repeated Option options = 6;
    Syntax syntax = 7;
}

message Mixin {

    string name = 1;
    string root = 2;
}{
  "nested": {
    "google": {
      "nested": {
        "protobuf": {
          "nested": {
            "FileDescriptorSet": {
              "fields": {
                "file": {
                  "rule": "repeated",
                  "type": "FileDescriptorProto",
                  "id": 1
                }
              }
            },
            "FileDescriptorProto": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "package": {
                  "type": "string",
                  "id": 2
                },
                "dependency": {
                  "rule": "repeated",
                  "type": "string",
                  "id": 3
                },
                "publicDependency": {
                  "rule": "repeated",
                  "type": "int32",
                  "id": 10,
                  "options": {
                    "packed": false
                  }
                },
                "weakDependency": {
                  "rule": "repeated",
                  "type": "int32",
                  "id": 11,
                  "options": {
                    "packed": false
                  }
                },
                "messageType": {
                  "rule": "repeated",
                  "type": "DescriptorProto",
                  "id": 4
                },
                "enumType": {
                  "rule": "repeated",
                  "type": "EnumDescriptorProto",
                  "id": 5
                },
                "service": {
                  "rule": "repeated",
                  "type": "ServiceDescriptorProto",
                  "id": 6
                },
                "extension": {
                  "rule": "repeated",
                  "type": "FieldDescriptorProto",
                  "id": 7
                },
                "options": {
                  "type": "FileOptions",
                  "id": 8
                },
                "sourceCodeInfo": {
                  "type": "SourceCodeInfo",
                  "id": 9
                },
                "syntax": {
                  "type": "string",
                  "id": 12
                }
              }
            },
            "DescriptorProto": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "field": {
                  "rule": "repeated",
                  "type": "FieldDescriptorProto",
                  "id": 2
                },
                "extension": {
                  "rule": "repeated",
                  "type": "FieldDescriptorProto",
                  "id": 6
                },
                "nestedType": {
                  "rule": "repeated",
                  "type": "DescriptorProto",
                  "id": 3
                },
                "enumType": {
                  "rule": "repeated",
                  "type": "EnumDescriptorProto",
                  "id": 4
                },
                "extensionRange": {
                  "rule": "repeated",
                  "type": "ExtensionRange",
                  "id": 5
                },
                "oneofDecl": {
                  "rule": "repeated",
                  "type": "OneofDescriptorProto",
                  "id": 8
                },
                "options": {
                  "type": "MessageOptions",
                  "id": 7
                },
                "reservedRange": {
                  "rule": "repeated",
                  "type": "ReservedRange",
                  "id": 9
                },
                "reservedName": {
                  "rule": "repeated",
                  "type": "string",
                  "id": 10
                }
              },
              "nested": {
                "ExtensionRange": {
                  "fields": {
                    "start": {
                      "type": "int32",
                      "id": 1
                    },
                    "end": {
                      "type": "int32",
                      "id": 2
                    }
                  }
                },
                "ReservedRange": {
                  "fields": {
                    "start": {
                      "type": "int32",
                      "id": 1
                    },
                    "end": {
                      "type": "int32",
                      "id": 2
                    }
                  }
                }
              }
            },
            "FieldDescriptorProto": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "number": {
                  "type": "int32",
                  "id": 3
                },
                "label": {
                  "type": "Label",
                  "id": 4
                },
                "type": {
                  "type": "Type",
                  "id": 5
                },
                "typeName": {
                  "type": "string",
                  "id": 6
                },
                "extendee": {
                  "type": "string",
                  "id": 2
                },
                "defaultValue": {
                  "type": "string",
                  "id": 7
                },
                "oneofIndex": {
                  "type": "int32",
                  "id": 9
                },
                "jsonName": {
                  "type": "string",
                  "id": 10
                },
                "options": {
                  "type": "FieldOptions",
                  "id": 8
                }
              },
              "nested": {
                "Type": {
                  "values": {
                    "TYPE_DOUBLE": 1,
                    "TYPE_FLOAT": 2,
                    "TYPE_INT64": 3,
                    "TYPE_UINT64": 4,
                    "TYPE_INT32": 5,
                    "TYPE_FIXED64": 6,
                    "TYPE_FIXED32": 7,
                    "TYPE_BOOL": 8,
                    "TYPE_STRING": 9,
                    "TYPE_GROUP": 10,
                    "TYPE_MESSAGE": 11,
                    "TYPE_BYTES": 12,
                    "TYPE_UINT32": 13,
                    "TYPE_ENUM": 14,
                    "TYPE_SFIXED32": 15,
                    "TYPE_SFIXED64": 16,
                    "TYPE_SINT32": 17,
                    "TYPE_SINT64": 18
                  }
                },
                "Label": {
                  "values": {
                    "LABEL_OPTIONAL": 1,
                    "LABEL_REQUIRED": 2,
                    "LABEL_REPEATED": 3
                  }
                }
              }
            },
            "OneofDescriptorProto": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "options": {
                  "type": "OneofOptions",
                  "id": 2
                }
              }
            },
            "EnumDescriptorProto": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "value": {
                  "rule": "repeated",
                  "type": "EnumValueDescriptorProto",
                  "id": 2
                },
                "options": {
                  "type": "EnumOptions",
                  "id": 3
                }
              }
            },
            "EnumValueDescriptorProto": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "number": {
                  "type": "int32",
                  "id": 2
                },
                "options": {
                  "type": "EnumValueOptions",
                  "id": 3
                }
              }
            },
            "ServiceDescriptorProto": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "method": {
                  "rule": "repeated",
                  "type": "MethodDescriptorProto",
                  "id": 2
                },
                "options": {
                  "type": "ServiceOptions",
                  "id": 3
                }
              }
            },
            "MethodDescriptorProto": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "inputType": {
                  "type": "string",
                  "id": 2
                },
                "outputType": {
                  "type": "string",
                  "id": 3
                },
                "options": {
                  "type": "MethodOptions",
                  "id": 4
                },
                "clientStreaming": {
                  "type": "bool",
                  "id": 5
                },
                "serverStreaming": {
                  "type": "bool",
                  "id": 6
                }
              }
            },
            "FileOptions": {
              "fields": {
                "javaPackage": {
                  "type": "string",
                  "id": 1
                },
                "javaOuterClassname": {
                  "type": "string",
                  "id": 8
                },
                "javaMultipleFiles": {
                  "type": "bool",
                  "id": 10
                },
                "javaGenerateEqualsAndHash": {
                  "type": "bool",
                  "id": 20,
                  "options": {
                    "deprecated": true
                  }
                },
                "javaStringCheckUtf8": {
                  "type": "bool",
                  "id": 27
                },
                "optimizeFor": {
                  "type": "OptimizeMode",
                  "id": 9,
                  "options": {
                    "default": "SPEED"
                  }
                },
                "goPackage": {
                  "type": "string",
                  "id": 11
                },
                "ccGenericServices": {
                  "type": "bool",
                  "id": 16
                },
                "javaGenericServices": {
                  "type": "bool",
                  "id": 17
                },
                "pyGenericServices": {
                  "type": "bool",
                  "id": 18
                },
                "deprecated": {
                  "type": "bool",
                  "id": 23
                },
                "ccEnableArenas": {
                  "type": "bool",
                  "id": 31
                },
                "objcClassPrefix": {
                  "type": "string",
                  "id": 36
                },
                "csharpNamespace": {
                  "type": "string",
                  "id": 37
                },
                "uninterpretedOption": {
                  "rule": "repeated",
                  "type": "UninterpretedOption",
                  "id": 999
                }
              },
              "extensions": [
                [
                  1000,
                  536870911
                ]
              ],
              "reserved": [
                [
                  38,
                  38
                ]
              ],
              "nested": {
                "OptimizeMode": {
                  "values": {
                    "SPEED": 1,
                    "CODE_SIZE": 2,
                    "LITE_RUNTIME": 3
                  }
                }
              }
            },
            "MessageOptions": {
              "fields": {
                "messageSetWireFormat": {
                  "type": "bool",
                  "id": 1
                },
                "noStandardDescriptorAccessor": {
                  "type": "bool",
                  "id": 2
                },
                "deprecated": {
                  "type": "bool",
                  "id": 3
                },
                "mapEntry": {
                  "type": "bool",
                  "id": 7
                },
                "uninterpretedOption": {
                  "rule": "repeated",
                  "type": "UninterpretedOption",
                  "id": 999
                }
              },
              "extensions": [
                [
                  1000,
                  536870911
                ]
              ],
              "reserved": [
                [
                  8,
                  8
                ]
              ]
            },
            "FieldOptions": {
              "fields": {
                "ctype": {
                  "type": "CType",
                  "id": 1,
                  "options": {
                    "default": "STRING"
                  }
                },
                "packed": {
                  "type": "bool",
                  "id": 2
                },
                "jstype": {
                  "type": "JSType",
                  "id": 6,
                  "options": {
                    "default": "JS_NORMAL"
                  }
                },
                "lazy": {
                  "type": "bool",
                  "id": 5
                },
                "deprecated": {
                  "type": "bool",
                  "id": 3
                },
                "weak": {
                  "type": "bool",
                  "id": 10
                },
                "uninterpretedOption": {
                  "rule": "repeated",
                  "type": "UninterpretedOption",
                  "id": 999
                }
              },
              "extensions": [
                [
                  1000,
                  536870911
                ]
              ],
              "reserved": [
                [
                  4,
                  4
                ]
              ],
              "nested": {
                "CType": {
                  "values": {
                    "STRING": 0,
                    "CORD": 1,
                    "STRING_PIECE": 2
                  }
                },
                "JSType": {
                  "values": {
                    "JS_NORMAL": 0,
                    "JS_STRING": 1,
                    "JS_NUMBER": 2
                  }
                }
              }
            },
            "OneofOptions": {
              "fields": {
                "uninterpretedOption": {
                  "rule": "repeated",
                  "type": "UninterpretedOption",
                  "id": 999
                }
              },
              "extensions": [
                [
                  1000,
                  536870911
                ]
              ]
            },
            "EnumOptions": {
              "fields": {
                "allowAlias": {
                  "type": "bool",
                  "id": 2
                },
                "deprecated": {
                  "type": "bool",
                  "id": 3
                },
                "uninterpretedOption": {
                  "rule": "repeated",
                  "type": "UninterpretedOption",
                  "id": 999
                }
              },
              "extensions": [
                [
                  1000,
                  536870911
                ]
              ]
            },
            "EnumValueOptions": {
              "fields": {
                "deprecated": {
                  "type": "bool",
                  "id": 1
                },
                "uninterpretedOption": {
                  "rule": "repeated",
                  "type": "UninterpretedOption",
                  "id": 999
                }
              },
              "extensions": [
                [
                  1000,
                  536870911
                ]
              ]
            },
            "ServiceOptions": {
              "fields": {
                "deprecated": {
                  "type": "bool",
                  "id": 33
                },
                "uninterpretedOption": {
                  "rule": "repeated",
                  "type": "UninterpretedOption",
                  "id": 999
                }
              },
              "extensions": [
                [
                  1000,
                  536870911
                ]
              ]
            },
            "MethodOptions": {
              "fields": {
                "deprecated": {
                  "type": "bool",
                  "id": 33
                },
                "uninterpretedOption": {
                  "rule": "repeated",
                  "type": "UninterpretedOption",
                  "id": 999
                }
              },
              "extensions": [
                [
                  1000,
                  536870911
                ]
              ]
            },
            "UninterpretedOption": {
              "fields": {
                "name": {
                  "rule": "repeated",
                  "type": "NamePart",
                  "id": 2
                },
                "identifierValue": {
                  "type": "string",
                  "id": 3
                },
                "positiveIntValue": {
                  "type": "uint64",
                  "id": 4
                },
                "negativeIntValue": {
                  "type": "int64",
                  "id": 5
                },
                "doubleValue": {
                  "type": "double",
                  "id": 6
                },
                "stringValue": {
                  "type": "bytes",
                  "id": 7
                },
                "aggregateValue": {
                  "type": "string",
                  "id": 8
                }
              },
              "nested": {
                "NamePart": {
                  "fields": {
                    "namePart": {
                      "rule": "required",
                      "type": "string",
                      "id": 1
                    },
                    "isExtension": {
                      "rule": "required",
                      "type": "bool",
                      "id": 2
                    }
                  }
                }
              }
            },
            "SourceCodeInfo": {
              "fields": {
                "location": {
                  "rule": "repeated",
                  "type": "Location",
                  "id": 1
                }
              },
              "nested": {
                "Location": {
                  "fields": {
                    "path": {
                      "rule": "repeated",
                      "type": "int32",
                      "id": 1
                    },
                    "span": {
                      "rule": "repeated",
                      "type": "int32",
                      "id": 2
                    },
                    "leadingComments": {
                      "type": "string",
                      "id": 3
                    },
                    "trailingComments": {
                      "type": "string",
                      "id": 4
                    },
                    "leadingDetachedComments": {
                      "rule": "repeated",
                      "type": "string",
                      "id": 6
                    }
                  }
                }
              }
            },
            "GeneratedCodeInfo": {
              "fields": {
                "annotation": {
                  "rule": "repeated",
                  "type": "Annotation",
                  "id": 1
                }
              },
              "nested": {
                "Annotation": {
                  "fields": {
                    "path": {
                      "rule": "repeated",
                      "type": "int32",
                      "id": 1
                    },
                    "sourceFile": {
                      "type": "string",
                      "id": 2
                    },
                    "begin": {
                      "type": "int32",
                      "id": 3
                    },
                    "end": {
                      "type": "int32",
                      "id": 4
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}syntax = "proto2";

package google.protobuf;

message FileDescriptorSet {

    repeated FileDescriptorProto file = 1;
}

message FileDescriptorProto {

    optional string name = 1;
    optional string package = 2;
    repeated string dependency = 3;
    repeated int32 public_dependency = 10;
    repeated int32 weak_dependency = 11;
    repeated DescriptorProto message_type = 4;
    repeated EnumDescriptorProto enum_type = 5;
    repeated ServiceDescriptorProto service = 6;
    repeated FieldDescriptorProto extension = 7;
    optional FileOptions options = 8;
    optional SourceCodeInfo source_code_info = 9;
    optional string syntax = 12;
}

message DescriptorProto {

    optional string name = 1;
    repeated FieldDescriptorProto field = 2;
    repeated FieldDescriptorProto extension = 6;
    repeated DescriptorProto nested_type = 3;
    repeated EnumDescriptorProto enum_type = 4;
    repeated ExtensionRange extension_range = 5;
    repeated OneofDescriptorProto oneof_decl = 8;
    optional MessageOptions options = 7;
    repeated ReservedRange reserved_range = 9;
    repeated string reserved_name = 10;

    message ExtensionRange {

        optional int32 start = 1;
        optional int32 end = 2;
    }

    message ReservedRange {

        optional int32 start = 1;
        optional int32 end = 2;
    }
}

message FieldDescriptorProto {

    optional string name = 1;
    optional int32 number = 3;
    optional Label label = 4;
    optional Type type = 5;
    optional string type_name = 6;
    optional string extendee = 2;
    optional string default_value = 7;
    optional int32 oneof_index = 9;
    optional string json_name = 10;
    optional FieldOptions options = 8;

    enum Type {

        TYPE_DOUBLE = 1;
        TYPE_FLOAT = 2;
        TYPE_INT64 = 3;
        TYPE_UINT64 = 4;
        TYPE_INT32 = 5;
        TYPE_FIXED64 = 6;
        TYPE_FIXED32 = 7;
        TYPE_BOOL = 8;
        TYPE_STRING = 9;
        TYPE_GROUP = 10;
        TYPE_MESSAGE = 11;
        TYPE_BYTES = 12;
        TYPE_UINT32 = 13;
        TYPE_ENUM = 14;
        TYPE_SFIXED32 = 15;
        TYPE_SFIXED64 = 16;
        TYPE_SINT32 = 17;
        TYPE_SINT64 = 18;
    }

    enum Label {

        LABEL_OPTIONAL = 1;
        LABEL_REQUIRED = 2;
        LABEL_REPEATED = 3;
    }
}

message OneofDescriptorProto {

    optional string name = 1;
    optional OneofOptions options = 2;
}

message EnumDescriptorProto {

    optional string name = 1;
    repeated EnumValueDescriptorProto value = 2;
    optional EnumOptions options = 3;
}

message EnumValueDescriptorProto {

    optional string name = 1;
    optional int32 number = 2;
    optional EnumValueOptions options = 3;
}

message ServiceDescriptorProto {

    optional string name = 1;
    repeated MethodDescriptorProto method = 2;
    optional ServiceOptions options = 3;
}

message MethodDescriptorProto {

    optional string name = 1;
    optional string input_type = 2;
    optional string output_type = 3;
    optional MethodOptions options = 4;
    optional bool client_streaming = 5;
    optional bool server_streaming = 6;
}

message FileOptions {

    optional string java_package = 1;
    optional string java_outer_classname = 8;
    optional bool java_multiple_files = 10;
    optional bool java_generate_equals_and_hash = 20 [deprecated=true];
    optional bool java_string_check_utf8 = 27;
    optional OptimizeMode optimize_for = 9 [default=SPEED];
    optional string go_package = 11;
    optional bool cc_generic_services = 16;
    optional bool java_generic_services = 17;
    optional bool py_generic_services = 18;
    optional bool deprecated = 23;
    optional bool cc_enable_arenas = 31;
    optional string objc_class_prefix = 36;
    optional string csharp_namespace = 37;
    repeated UninterpretedOption uninterpreted_option = 999;

    enum OptimizeMode {

        SPEED = 1;
        CODE_SIZE = 2;
        LITE_RUNTIME = 3;
    }

    extensions 1000 to max;

    reserved 38;
}

message MessageOptions {

    optional bool message_set_wire_format = 1;
    optional bool no_standard_descriptor_accessor = 2;
    optional bool deprecated = 3;
    optional bool map_entry = 7;
    repeated UninterpretedOption uninterpreted_option = 999;

    extensions 1000 to max;

    reserved 8;
}

message FieldOptions {

    optional CType ctype = 1 [default=STRING];
    optional bool packed = 2;
    optional JSType jstype = 6 [default=JS_NORMAL];
    optional bool lazy = 5;
    optional bool deprecated = 3;
    optional bool weak = 10;
    repeated UninterpretedOption uninterpreted_option = 999;

    enum CType {

        STRING = 0;
        CORD = 1;
        STRING_PIECE = 2;
    }

    enum JSType {

        JS_NORMAL = 0;
        JS_STRING = 1;
        JS_NUMBER = 2;
    }

    extensions 1000 to max;

    reserved 4;
}

message OneofOptions {

    repeated UninterpretedOption uninterpreted_option = 999;

    extensions 1000 to max;
}

message EnumOptions {

    optional bool allow_alias = 2;
    optional bool deprecated = 3;
    repeated UninterpretedOption uninterpreted_option = 999;

    extensions 1000 to max;
}

message EnumValueOptions {

    optional bool deprecated = 1;
    repeated UninterpretedOption uninterpreted_option = 999;

    extensions 1000 to max;
}

message ServiceOptions {

    optional bool deprecated = 33;
    repeated UninterpretedOption uninterpreted_option = 999;

    extensions 1000 to max;
}

message MethodOptions {

    optional bool deprecated = 33;
    repeated UninterpretedOption uninterpreted_option = 999;

    extensions 1000 to max;
}

message UninterpretedOption {

    repeated NamePart name = 2;
    optional string identifier_value = 3;
    optional uint64 positive_int_value = 4;
    optional int64 negative_int_value = 5;
    optional double double_value = 6;
    optional bytes string_value = 7;
    optional string aggregate_value = 8;

    message NamePart {

        required string name_part = 1;
        required bool is_extension = 2;
    }
}

message SourceCodeInfo {

    repeated Location location = 1;

    message Location {

        repeated int32 path = 1 [packed=true];
        repeated int32 span = 2 [packed=true];
        optional string leading_comments = 3;
        optional string trailing_comments = 4;
        repeated string leading_detached_comments = 6;
    }
}

message GeneratedCodeInfo {

    repeated Annotation annotation = 1;

    message Annotation {

        repeated int32 path = 1 [packed=true];
        optional string source_file = 2;
        optional int32 begin = 3;
        optional int32 end = 4;
    }
}
{
  "nested": {
    "google": {
      "nested": {
        "protobuf": {
          "nested": {
            "SourceContext": {
              "fields": {
                "fileName": {
                  "type": "string",
                  "id": 1
                }
              }
            }
          }
        }
      }
    }
  }
}syntax = "proto3";

package google.protobuf;

message SourceContext {
    string file_name = 1;
}
{
  "nested": {
    "google": {
      "nested": {
        "protobuf": {
          "nested": {
            "Type": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "fields": {
                  "rule": "repeated",
                  "type": "Field",
                  "id": 2
                },
                "oneofs": {
                  "rule": "repeated",
                  "type": "string",
                  "id": 3
                },
                "options": {
                  "rule": "repeated",
                  "type": "Option",
                  "id": 4
                },
                "sourceContext": {
                  "type": "SourceContext",
                  "id": 5
                },
                "syntax": {
                  "type": "Syntax",
                  "id": 6
                }
              }
            },
            "Field": {
              "fields": {
                "kind": {
                  "type": "Kind",
                  "id": 1
                },
                "cardinality": {
                  "type": "Cardinality",
                  "id": 2
                },
                "number": {
                  "type": "int32",
                  "id": 3
                },
                "name": {
                  "type": "string",
                  "id": 4
                },
                "typeUrl": {
                  "type": "string",
                  "id": 6
                },
                "oneofIndex": {
                  "type": "int32",
                  "id": 7
                },
                "packed": {
                  "type": "bool",
                  "id": 8
                },
                "options": {
                  "rule": "repeated",
                  "type": "Option",
                  "id": 9
                },
                "jsonName": {
                  "type": "string",
                  "id": 10
                },
                "defaultValue": {
                  "type": "string",
                  "id": 11
                }
              },
              "nested": {
                "Kind": {
                  "values": {
                    "TYPE_UNKNOWN": 0,
                    "TYPE_DOUBLE": 1,
                    "TYPE_FLOAT": 2,
                    "TYPE_INT64": 3,
                    "TYPE_UINT64": 4,
                    "TYPE_INT32": 5,
                    "TYPE_FIXED64": 6,
                    "TYPE_FIXED32": 7,
                    "TYPE_BOOL": 8,
                    "TYPE_STRING": 9,
                    "TYPE_GROUP": 10,
                    "TYPE_MESSAGE": 11,
                    "TYPE_BYTES": 12,
                    "TYPE_UINT32": 13,
                    "TYPE_ENUM": 14,
                    "TYPE_SFIXED32": 15,
                    "TYPE_SFIXED64": 16,
                    "TYPE_SINT32": 17,
                    "TYPE_SINT64": 18
                  }
                },
                "Cardinality": {
                  "values": {
                    "CARDINALITY_UNKNOWN": 0,
                    "CARDINALITY_OPTIONAL": 1,
                    "CARDINALITY_REQUIRED": 2,
                    "CARDINALITY_REPEATED": 3
                  }
                }
              }
            },
            "Enum": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "enumvalue": {
                  "rule": "repeated",
                  "type": "EnumValue",
                  "id": 2
                },
                "options": {
                  "rule": "repeated",
                  "type": "Option",
                  "id": 3
                },
                "sourceContext": {
                  "type": "SourceContext",
                  "id": 4
                },
                "syntax": {
                  "type": "Syntax",
                  "id": 5
                }
              }
            },
            "EnumValue": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "number": {
                  "type": "int32",
                  "id": 2
                },
                "options": {
                  "rule": "repeated",
                  "type": "Option",
                  "id": 3
                }
              }
            },
            "Option": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "value": {
                  "type": "Any",
                  "id": 2
                }
              }
            },
            "Syntax": {
              "values": {
                "SYNTAX_PROTO2": 0,
                "SYNTAX_PROTO3": 1
              }
            },
            "Any": {
              "fields": {
                "type_url": {
                  "type": "string",
                  "id": 1
                },
                "value": {
                  "type": "bytes",
                  "id": 2
                }
              }
            },
            "SourceContext": {
              "fields": {
                "fileName": {
                  "type": "string",
                  "id": 1
                }
              }
            }
          }
        }
      }
    }
  }
}syntax = "proto3";

package google.protobuf;

import "google/protobuf/any.proto";
import "google/protobuf/source_context.proto";

message Type {

    string name = 1;
    repeated Field fields = 2;
    repeated string oneofs = 3;
    repeated Option options = 4;
    SourceContext source_context = 5;
    Syntax syntax = 6;
}

message Field {

    Kind kind = 1;
    Cardinality cardinality = 2;
    int32 number = 3;
    string name = 4;
    string type_url = 6;
    int32 oneof_index = 7;
    bool packed = 8;
    repeated Option options = 9;
    string json_name = 10;
    string default_value = 11;

    enum Kind {

        TYPE_UNKNOWN = 0;
        TYPE_DOUBLE = 1;
        TYPE_FLOAT = 2;
        TYPE_INT64 = 3;
        TYPE_UINT64 = 4;
        TYPE_INT32 = 5;
        TYPE_FIXED64 = 6;
        TYPE_FIXED32 = 7;
        TYPE_BOOL = 8;
        TYPE_STRING = 9;
        TYPE_GROUP = 10;
        TYPE_MESSAGE = 11;
        TYPE_BYTES = 12;
        TYPE_UINT32 = 13;
        TYPE_ENUM = 14;
        TYPE_SFIXED32 = 15;
        TYPE_SFIXED64 = 16;
        TYPE_SINT32 = 17;
        TYPE_SINT64 = 18;
    }

    enum Cardinality {

        CARDINALITY_UNKNOWN = 0;
        CARDINALITY_OPTIONAL = 1;
        CARDINALITY_REQUIRED = 2;
        CARDINALITY_REPEATED = 3;
    }
}

message Enum {

    string name = 1;
    repeated EnumValue enumvalue = 2;
    repeated Option options = 3;
    SourceContext source_context = 4;
    Syntax syntax = 5;
}

message EnumValue {

    string name = 1;
    int32 number = 2;
    repeated Option options = 3;
}

message Option {

    string name = 1;
    Any value = 2;
}

enum Syntax {

    SYNTAX_PROTO2 = 0;
    SYNTAX_PROTO3 = 1;
}
This folder contains stripped and pre-parsed definitions of common Google types. These files are not used by protobuf.js directly but are here so you can use or include them where required.
{
  "nested": {
    "google": {
      "nested": {
        "rpc": {
          "nested": {
            "RetryInfo": {
              "fields": {
                "retryDelay": {
                  "type": "Duration",
                  "id": 1
                }
              },
              "nested": {
                "Duration": {
                  "fields": {
                    "seconds": {
                      "type": "int64",
                      "id": 1
                    },
                    "nanos": {
                      "type": "int32",
                      "id": 2
                    }
                  }
                }
              }
            },
            "DebugInfo": {
              "fields": {
                "stackEntries": {
                  "rule": "repeated",
                  "type": "string",
                  "id": 1
                },
                "detail": {
                  "type": "string",
                  "id": 2
                }
              }
            },
            "QuotaFailure": {
              "fields": {
                "violations": {
                  "rule": "repeated",
                  "type": "Violation",
                  "id": 1
                }
              },
              "nested": {
                "Violation": {
                  "fields": {
                    "subject": {
                      "type": "string",
                      "id": 1
                    },
                    "description": {
                      "type": "string",
                      "id": 2
                    }
                  }
                }
              }
            },
            "ErrorInfo": {
              "fields": {
                "reason": {
                  "type": "string",
                  "id": 1
                },
                "domain": {
                  "type": "string",
                  "id": 2
                },
                "metadata": {
                  "keyType": "string",
                  "type": "string",
                  "id": 3
                }
              }
            },
            "PreconditionFailure": {
              "fields": {
                "violations": {
                  "rule": "repeated",
                  "type": "Violation",
                  "id": 1
                }
              },
              "nested": {
                "Violation": {
                  "fields": {
                    "type": {
                      "type": "string",
                      "id": 1
                    },
                    "subject": {
                      "type": "string",
                      "id": 2
                    },
                    "description": {
                      "type": "string",
                      "id": 3
                    }
                  }
                }
              }
            },
            "BadRequest": {
              "fields": {
                "fieldViolations": {
                  "rule": "repeated",
                  "type": "FieldViolation",
                  "id": 1
                }
              },
              "nested": {
                "FieldViolation": {
                  "fields": {
                    "field": {
                      "type": "string",
                      "id": 1
                    },
                    "description": {
                      "type": "string",
                      "id": 2
                    }
                  }
                }
              }
            },
            "RequestInfo": {
              "fields": {
                "requestId": {
                  "type": "string",
                  "id": 1
                },
                "servingData": {
                  "type": "string",
                  "id": 2
                }
              }
            },
            "ResourceInfo": {
              "fields": {
                "resourceType": {
                  "type": "string",
                  "id": 1
                },
                "resourceName": {
                  "type": "string",
                  "id": 2
                },
                "owner": {
                  "type": "string",
                  "id": 3
                },
                "description": {
                  "type": "string",
                  "id": 4
                }
              }
            },
            "Help": {
              "fields": {
                "links": {
                  "rule": "repeated",
                  "type": "Link",
                  "id": 1
                }
              },
              "nested": {
                "Link": {
                  "fields": {
                    "description": {
                      "type": "string",
                      "id": 1
                    },
                    "url": {
                      "type": "string",
                      "id": 2
                    }
                  }
                }
              }
            },
            "LocalizedMessage": {
              "fields": {
                "locale": {
                  "type": "string",
                  "id": 1
                },
                "message": {
                  "type": "string",
                  "id": 2
                }
              }
            }
          }
        }
      }
    }
  }
}syntax = "proto3";

package google.rpc;

message RetryInfo {
  message Duration {
    int64 seconds = 1;
    int32 nanos = 2;
  }

  Duration retry_delay = 1;
}

message DebugInfo {
  repeated string stack_entries = 1;
  string detail = 2;
}

message QuotaFailure {
  message Violation {
    string subject = 1;
    string description = 2;
  }

  repeated Violation violations = 1;
}

message ErrorInfo {
  string reason = 1;
  string domain = 2;
  map<string, string> metadata = 3;
}

message PreconditionFailure {
  message Violation {
    string type = 1;
    string subject = 2;
    string description = 3;
  }

  repeated Violation violations = 1;
}

message BadRequest {
  message FieldViolation {
    string field = 1;
    string description = 2;
  }

  repeated FieldViolation field_violations = 1;
}

message RequestInfo {
  string request_id = 1;
  string serving_data = 2;
}

message ResourceInfo {
  string resource_type = 1;
  string resource_name = 2;
  string owner = 3;
  string description = 4;
}

message Help {
  message Link {
    string description = 1;
    string url = 2;
  }

  repeated Link links = 1;
}

message LocalizedMessage {
  string locale = 1;
  string message = 2;
}
{
  "nested": {
    "google": {
      "nested": {
        "protobuf": {
          "nested": {
            "Any": {
              "fields": {
                "type_url": {
                  "type": "string",
                  "id": 1
                },
                "value": {
                  "type": "bytes",
                  "id": 2
                }
              }
            }
          }
        },
        "rpc": {
          "nested": {
            "Status": {
              "fields": {
                "code": {
                  "type": "int32",
                  "id": 1
                },
                "message": {
                  "type": "string",
                  "id": 2
                },
                "details": {
                  "rule": "repeated",
                  "type": "google.protobuf.Any",
                  "id": 3
                }
              }
            }
          }
        }
      }
    }
  }
}syntax = "proto3";

package google.rpc;

import "google/protobuf/any.proto";

message Status {
  int32 code = 1;
  string message = 2;
  repeated google.protobuf.Any details = 3;
}
// DO NOT EDIT! This is a generated file. Edit the JSDoc in src/*.js instead and run 'npm run build:types'.

export as namespace protobuf;

/**
 * Provides common type definitions.
 * Can also be used to provide additional google types or your own custom types.
 * @param name Short name as in `google/protobuf/[name].proto` or full file name
 * @param json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition
 */
export function common(name: string, json: { [k: string]: any }): void;

export namespace common {

    /** Properties of a google.protobuf.Any message. */
    interface IAny {
        typeUrl?: string;
        bytes?: Uint8Array;
    }

    /** Properties of a google.protobuf.Duration message. */
    interface IDuration {
        seconds?: (number|Long);
        nanos?: number;
    }

    /** Properties of a google.protobuf.Timestamp message. */
    interface ITimestamp {
        seconds?: (number|Long);
        nanos?: number;
    }

    /** Properties of a google.protobuf.Empty message. */
    interface IEmpty {
    }

    /** Properties of a google.protobuf.Struct message. */
    interface IStruct {
        fields?: { [k: string]: IValue };
    }

    /** Properties of a google.protobuf.Value message. */
    interface IValue {
        kind?: string;
        null_value?: 0;
        number_value?: number;
        string_value?: string;
        bool_value?: boolean;
        struct_value?: IStruct;
        list_value?: IListValue;
    }

    /** Properties of a google.protobuf.ListValue message. */
    interface IListValue {
        values?: IValue[];
    }

    /** Properties of a google.protobuf.DoubleValue message. */
    interface IDoubleValue {
        value?: number;
    }

    /** Properties of a google.protobuf.FloatValue message. */
    interface IFloatValue {
        value?: number;
    }

    /** Properties of a google.protobuf.Int64Value message. */
    interface IInt64Value {
        value?: (number|Long);
    }

    /** Properties of a google.protobuf.UInt64Value message. */
    interface IUInt64Value {
        value?: (number|Long);
    }

    /** Properties of a google.protobuf.Int32Value message. */
    interface IInt32Value {
        value?: number;
    }

    /** Properties of a google.protobuf.UInt32Value message. */
    interface IUInt32Value {
        value?: number;
    }

    /** Properties of a google.protobuf.BoolValue message. */
    interface IBoolValue {
        value?: boolean;
    }

    /** Properties of a google.protobuf.StringValue message. */
    interface IStringValue {
        value?: string;
    }

    /** Properties of a google.protobuf.BytesValue message. */
    interface IBytesValue {
        value?: Uint8Array;
    }

    /**
     * Gets the root definition of the specified common proto file.
     *
     * Bundled definitions are:
     * - google/protobuf/any.proto
     * - google/protobuf/duration.proto
     * - google/protobuf/empty.proto
     * - google/protobuf/field_mask.proto
     * - google/protobuf/struct.proto
     * - google/protobuf/timestamp.proto
     * - google/protobuf/wrappers.proto
     *
     * @param file Proto file name
     * @returns Root definition or `null` if not defined
     */
    function get(file: string): (INamespace|null);
}

/** Runtime message from/to plain object converters. */
export namespace converter {

    /**
     * Generates a plain object to runtime message converter specific to the specified message type.
     * @param mtype Message type
     * @returns Codegen instance
     */
    function fromObject(mtype: Type): Codegen;

    /**
     * Generates a runtime message to plain object converter specific to the specified message type.
     * @param mtype Message type
     * @returns Codegen instance
     */
    function toObject(mtype: Type): Codegen;
}

/**
 * Generates a decoder specific to the specified message type.
 * @param mtype Message type
 * @returns Codegen instance
 */
export function decoder(mtype: Type): Codegen;

/**
 * Generates an encoder specific to the specified message type.
 * @param mtype Message type
 * @returns Codegen instance
 */
export function encoder(mtype: Type): Codegen;

/** Reflected enum. */
export class Enum extends ReflectionObject {

    /**
     * Constructs a new enum instance.
     * @param name Unique name within its namespace
     * @param [values] Enum values as an object, by name
     * @param [options] Declared options
     * @param [comment] The comment for this enum
     * @param [comments] The value comments for this enum
     * @param [valuesOptions] The value options for this enum
     */
    constructor(name: string, values?: { [k: string]: number }, options?: { [k: string]: any }, comment?: string, comments?: { [k: string]: string }, valuesOptions?: ({ [k: string]: { [k: string]: any } }|undefined));

    /** Enum values by id. */
    public valuesById: { [k: number]: string };

    /** Enum values by name. */
    public values: { [k: string]: number };

    /** Enum comment text. */
    public comment: (string|null);

    /** Value comment texts, if any. */
    public comments: { [k: string]: string };

    /** Values options, if any */
    public valuesOptions?: { [k: string]: { [k: string]: any } };

    /** Reserved ranges, if any. */
    public reserved: (number[]|string)[];

    /**
     * Constructs an enum from an enum descriptor.
     * @param name Enum name
     * @param json Enum descriptor
     * @returns Created enum
     * @throws {TypeError} If arguments are invalid
     */
    public static fromJSON(name: string, json: IEnum): Enum;

    /**
     * Converts this enum to an enum descriptor.
     * @param [toJSONOptions] JSON conversion options
     * @returns Enum descriptor
     */
    public toJSON(toJSONOptions?: IToJSONOptions): IEnum;

    /**
     * Adds a value to this enum.
     * @param name Value name
     * @param id Value id
     * @param [comment] Comment, if any
     * @param {Object.<string, *>|undefined} [options] Options, if any
     * @returns `this`
     * @throws {TypeError} If arguments are invalid
     * @throws {Error} If there is already a value with this name or id
     */
    public add(name: string, id: number, comment?: string, options?: ({ [k: string]: any }|undefined)): Enum;

    /**
     * Removes a value from this enum
     * @param name Value name
     * @returns `this`
     * @throws {TypeError} If arguments are invalid
     * @throws {Error} If `name` is not a name of this enum
     */
    public remove(name: string): Enum;

    /**
     * Tests if the specified id is reserved.
     * @param id Id to test
     * @returns `true` if reserved, otherwise `false`
     */
    public isReservedId(id: number): boolean;

    /**
     * Tests if the specified name is reserved.
     * @param name Name to test
     * @returns `true` if reserved, otherwise `false`
     */
    public isReservedName(name: string): boolean;
}

/** Enum descriptor. */
export interface IEnum {

    /** Enum values */
    values: { [k: string]: number };

    /** Enum options */
    options?: { [k: string]: any };
}

/** Reflected message field. */
export class Field extends FieldBase {

    /**
     * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
     * @param name Unique name within its namespace
     * @param id Unique id within its namespace
     * @param type Value type
     * @param [rule="optional"] Field rule
     * @param [extend] Extended type if different from parent
     * @param [options] Declared options
     */
    constructor(name: string, id: number, type: string, rule?: (string|{ [k: string]: any }), extend?: (string|{ [k: string]: any }), options?: { [k: string]: any });

    /**
     * Constructs a field from a field descriptor.
     * @param name Field name
     * @param json Field descriptor
     * @returns Created field
     * @throws {TypeError} If arguments are invalid
     */
    public static fromJSON(name: string, json: IField): Field;

    /** Determines whether this field is packed. Only relevant when repeated and working with proto2. */
    public readonly packed: boolean;

    /**
     * Field decorator (TypeScript).
     * @param fieldId Field id
     * @param fieldType Field type
     * @param [fieldRule="optional"] Field rule
     * @param [defaultValue] Default value
     * @returns Decorator function
     */
    public static d<T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]>(fieldId: number, fieldType: ("double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|object), fieldRule?: ("optional"|"required"|"repeated"), defaultValue?: T): FieldDecorator;

    /**
     * Field decorator (TypeScript).
     * @param fieldId Field id
     * @param fieldType Field type
     * @param [fieldRule="optional"] Field rule
     * @returns Decorator function
     */
    public static d<T extends Message<T>>(fieldId: number, fieldType: (Constructor<T>|string), fieldRule?: ("optional"|"required"|"repeated")): FieldDecorator;
}

/** Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions. */
export class FieldBase extends ReflectionObject {

    /**
     * Not an actual constructor. Use {@link Field} instead.
     * @param name Unique name within its namespace
     * @param id Unique id within its namespace
     * @param type Value type
     * @param [rule="optional"] Field rule
     * @param [extend] Extended type if different from parent
     * @param [options] Declared options
     * @param [comment] Comment associated with this field
     */
    constructor(name: string, id: number, type: string, rule?: (string|{ [k: string]: any }), extend?: (string|{ [k: string]: any }), options?: { [k: string]: any }, comment?: string);

    /** Field type. */
    public type: string;

    /** Unique field id. */
    public id: number;

    /** Extended type if different from parent. */
    public extend?: string;

    /** Whether this field is required. */
    public required: boolean;

    /** Whether this field is optional. */
    public optional: boolean;

    /** Whether this field is repeated. */
    public repeated: boolean;

    /** Whether this field is a map or not. */
    public map: boolean;

    /** Message this field belongs to. */
    public message: (Type|null);

    /** OneOf this field belongs to, if any, */
    public partOf: (OneOf|null);

    /** The field type's default value. */
    public typeDefault: any;

    /** The field's default value on prototypes. */
    public defaultValue: any;

    /** Whether this field's value should be treated as a long. */
    public long: boolean;

    /** Whether this field's value is a buffer. */
    public bytes: boolean;

    /** Resolved type if not a basic type. */
    public resolvedType: (Type|Enum|null);

    /** Sister-field within the extended type if a declaring extension field. */
    public extensionField: (Field|null);

    /** Sister-field within the declaring namespace if an extended field. */
    public declaringField: (Field|null);

    /** Comment for this field. */
    public comment: (string|null);

    /**
     * Converts this field to a field descriptor.
     * @param [toJSONOptions] JSON conversion options
     * @returns Field descriptor
     */
    public toJSON(toJSONOptions?: IToJSONOptions): IField;

    /**
     * Resolves this field's type references.
     * @returns `this`
     * @throws {Error} If any reference cannot be resolved
     */
    public resolve(): Field;
}

/** Field descriptor. */
export interface IField {

    /** Field rule */
    rule?: string;

    /** Field type */
    type: string;

    /** Field id */
    id: number;

    /** Field options */
    options?: { [k: string]: any };
}

/** Extension field descriptor. */
export interface IExtensionField extends IField {

    /** Extended type */
    extend: string;
}

/**
 * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
 * @param prototype Target prototype
 * @param fieldName Field name
 */
type FieldDecorator = (prototype: object, fieldName: string) => void;

/**
 * A node-style callback as used by {@link load} and {@link Root#load}.
 * @param error Error, if any, otherwise `null`
 * @param [root] Root, if there hasn't been an error
 */
type LoadCallback = (error: (Error|null), root?: Root) => void;

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @param filename One or multiple files to load
 * @param root Root namespace, defaults to create a new one if omitted.
 * @param callback Callback function
 * @see {@link Root#load}
 */
export function load(filename: (string|string[]), root: Root, callback: LoadCallback): void;

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @param filename One or multiple files to load
 * @param callback Callback function
 * @see {@link Root#load}
 */
export function load(filename: (string|string[]), callback: LoadCallback): void;

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
 * @param filename One or multiple files to load
 * @param [root] Root namespace, defaults to create a new one if omitted.
 * @returns Promise
 * @see {@link Root#load}
 */
export function load(filename: (string|string[]), root?: Root): Promise<Root>;

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
 * @param filename One or multiple files to load
 * @param [root] Root namespace, defaults to create a new one if omitted.
 * @returns Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 * @see {@link Root#loadSync}
 */
export function loadSync(filename: (string|string[]), root?: Root): Root;

/** Build type, one of `"full"`, `"light"` or `"minimal"`. */
export const build: string;

/** Reconfigures the library according to the environment. */
export function configure(): void;

/** Reflected map field. */
export class MapField extends FieldBase {

    /**
     * Constructs a new map field instance.
     * @param name Unique name within its namespace
     * @param id Unique id within its namespace
     * @param keyType Key type
     * @param type Value type
     * @param [options] Declared options
     * @param [comment] Comment associated with this field
     */
    constructor(name: string, id: number, keyType: string, type: string, options?: { [k: string]: any }, comment?: string);

    /** Key type. */
    public keyType: string;

    /** Resolved key type if not a basic type. */
    public resolvedKeyType: (ReflectionObject|null);

    /**
     * Constructs a map field from a map field descriptor.
     * @param name Field name
     * @param json Map field descriptor
     * @returns Created map field
     * @throws {TypeError} If arguments are invalid
     */
    public static fromJSON(name: string, json: IMapField): MapField;

    /**
     * Converts this map field to a map field descriptor.
     * @param [toJSONOptions] JSON conversion options
     * @returns Map field descriptor
     */
    public toJSON(toJSONOptions?: IToJSONOptions): IMapField;

    /**
     * Map field decorator (TypeScript).
     * @param fieldId Field id
     * @param fieldKeyType Field key type
     * @param fieldValueType Field value type
     * @returns Decorator function
     */
    public static d<T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }>(fieldId: number, fieldKeyType: ("int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"), fieldValueType: ("double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|object|Constructor<{}>)): FieldDecorator;
}

/** Map field descriptor. */
export interface IMapField extends IField {

    /** Key type */
    keyType: string;
}

/** Extension map field descriptor. */
export interface IExtensionMapField extends IMapField {

    /** Extended type */
    extend: string;
}

/** Abstract runtime message. */
export class Message<T extends object = object> {

    /**
     * Constructs a new message instance.
     * @param [properties] Properties to set
     */
    constructor(properties?: Properties<T>);

    /** Reference to the reflected type. */
    public static readonly $type: Type;

    /** Reference to the reflected type. */
    public readonly $type: Type;

    /**
     * Creates a new message of this type using the specified properties.
     * @param [properties] Properties to set
     * @returns Message instance
     */
    public static create<T extends Message<T>>(this: Constructor<T>, properties?: { [k: string]: any }): Message<T>;

    /**
     * Encodes a message of this type.
     * @param message Message to encode
     * @param [writer] Writer to use
     * @returns Writer
     */
    public static encode<T extends Message<T>>(this: Constructor<T>, message: (T|{ [k: string]: any }), writer?: Writer): Writer;

    /**
     * Encodes a message of this type preceeded by its length as a varint.
     * @param message Message to encode
     * @param [writer] Writer to use
     * @returns Writer
     */
    public static encodeDelimited<T extends Message<T>>(this: Constructor<T>, message: (T|{ [k: string]: any }), writer?: Writer): Writer;

    /**
     * Decodes a message of this type.
     * @param reader Reader or buffer to decode
     * @returns Decoded message
     */
    public static decode<T extends Message<T>>(this: Constructor<T>, reader: (Reader|Uint8Array)): T;

    /**
     * Decodes a message of this type preceeded by its length as a varint.
     * @param reader Reader or buffer to decode
     * @returns Decoded message
     */
    public static decodeDelimited<T extends Message<T>>(this: Constructor<T>, reader: (Reader|Uint8Array)): T;

    /**
     * Verifies a message of this type.
     * @param message Plain object to verify
     * @returns `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): (string|null);

    /**
     * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
     * @param object Plain object
     * @returns Message instance
     */
    public static fromObject<T extends Message<T>>(this: Constructor<T>, object: { [k: string]: any }): T;

    /**
     * Creates a plain object from a message of this type. Also converts values to other types if specified.
     * @param message Message instance
     * @param [options] Conversion options
     * @returns Plain object
     */
    public static toObject<T extends Message<T>>(this: Constructor<T>, message: T, options?: IConversionOptions): { [k: string]: any };

    /**
     * Converts this message to JSON.
     * @returns JSON object
     */
    public toJSON(): { [k: string]: any };
}

/** Reflected service method. */
export class Method extends ReflectionObject {

    /**
     * Constructs a new service method instance.
     * @param name Method name
     * @param type Method type, usually `"rpc"`
     * @param requestType Request message type
     * @param responseType Response message type
     * @param [requestStream] Whether the request is streamed
     * @param [responseStream] Whether the response is streamed
     * @param [options] Declared options
     * @param [comment] The comment for this method
     * @param [parsedOptions] Declared options, properly parsed into an object
     */
    constructor(name: string, type: (string|undefined), requestType: string, responseType: string, requestStream?: (boolean|{ [k: string]: any }), responseStream?: (boolean|{ [k: string]: any }), options?: { [k: string]: any }, comment?: string, parsedOptions?: { [k: string]: any });

    /** Method type. */
    public type: string;

    /** Request type. */
    public requestType: string;

    /** Whether requests are streamed or not. */
    public requestStream?: boolean;

    /** Response type. */
    public responseType: string;

    /** Whether responses are streamed or not. */
    public responseStream?: boolean;

    /** Resolved request type. */
    public resolvedRequestType: (Type|null);

    /** Resolved response type. */
    public resolvedResponseType: (Type|null);

    /** Comment for this method */
    public comment: (string|null);

    /** Options properly parsed into an object */
    public parsedOptions: any;

    /**
     * Constructs a method from a method descriptor.
     * @param name Method name
     * @param json Method descriptor
     * @returns Created method
     * @throws {TypeError} If arguments are invalid
     */
    public static fromJSON(name: string, json: IMethod): Method;

    /**
     * Converts this method to a method descriptor.
     * @param [toJSONOptions] JSON conversion options
     * @returns Method descriptor
     */
    public toJSON(toJSONOptions?: IToJSONOptions): IMethod;
}

/** Method descriptor. */
export interface IMethod {

    /** Method type */
    type?: string;

    /** Request type */
    requestType: string;

    /** Response type */
    responseType: string;

    /** Whether requests are streamed */
    requestStream?: boolean;

    /** Whether responses are streamed */
    responseStream?: boolean;

    /** Method options */
    options?: { [k: string]: any };

    /** Method comments */
    comment: string;

    /** Method options properly parsed into an object */
    parsedOptions?: { [k: string]: any };
}

/** Reflected namespace. */
export class Namespace extends NamespaceBase {

    /**
     * Constructs a new namespace instance.
     * @param name Namespace name
     * @param [options] Declared options
     */
    constructor(name: string, options?: { [k: string]: any });

    /**
     * Constructs a namespace from JSON.
     * @param name Namespace name
     * @param json JSON object
     * @returns Created namespace
     * @throws {TypeError} If arguments are invalid
     */
    public static fromJSON(name: string, json: { [k: string]: any }): Namespace;

    /**
     * Converts an array of reflection objects to JSON.
     * @param array Object array
     * @param [toJSONOptions] JSON conversion options
     * @returns JSON object or `undefined` when array is empty
     */
    public static arrayToJSON(array: ReflectionObject[], toJSONOptions?: IToJSONOptions): ({ [k: string]: any }|undefined);

    /**
     * Tests if the specified id is reserved.
     * @param reserved Array of reserved ranges and names
     * @param id Id to test
     * @returns `true` if reserved, otherwise `false`
     */
    public static isReservedId(reserved: ((number[]|string)[]|undefined), id: number): boolean;

    /**
     * Tests if the specified name is reserved.
     * @param reserved Array of reserved ranges and names
     * @param name Name to test
     * @returns `true` if reserved, otherwise `false`
     */
    public static isReservedName(reserved: ((number[]|string)[]|undefined), name: string): boolean;
}

/** Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions. */
export abstract class NamespaceBase extends ReflectionObject {

    /** Nested objects by name. */
    public nested?: { [k: string]: ReflectionObject };

    /** Nested objects of this namespace as an array for iteration. */
    public readonly nestedArray: ReflectionObject[];

    /**
     * Converts this namespace to a namespace descriptor.
     * @param [toJSONOptions] JSON conversion options
     * @returns Namespace descriptor
     */
    public toJSON(toJSONOptions?: IToJSONOptions): INamespace;

    /**
     * Adds nested objects to this namespace from nested object descriptors.
     * @param nestedJson Any nested object descriptors
     * @returns `this`
     */
    public addJSON(nestedJson: { [k: string]: AnyNestedObject }): Namespace;

    /**
     * Gets the nested object of the specified name.
     * @param name Nested object name
     * @returns The reflection object or `null` if it doesn't exist
     */
    public get(name: string): (ReflectionObject|null);

    /**
     * Gets the values of the nested {@link Enum|enum} of the specified name.
     * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
     * @param name Nested enum name
     * @returns Enum values
     * @throws {Error} If there is no such enum
     */
    public getEnum(name: string): { [k: string]: number };

    /**
     * Adds a nested object to this namespace.
     * @param object Nested object to add
     * @returns `this`
     * @throws {TypeError} If arguments are invalid
     * @throws {Error} If there is already a nested object with this name
     */
    public add(object: ReflectionObject): Namespace;

    /**
     * Removes a nested object from this namespace.
     * @param object Nested object to remove
     * @returns `this`
     * @throws {TypeError} If arguments are invalid
     * @throws {Error} If `object` is not a member of this namespace
     */
    public remove(object: ReflectionObject): Namespace;

    /**
     * Defines additial namespaces within this one if not yet existing.
     * @param path Path to create
     * @param [json] Nested types to create from JSON
     * @returns Pointer to the last namespace created or `this` if path is empty
     */
    public define(path: (string|string[]), json?: any): Namespace;

    /**
     * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
     * @returns `this`
     */
    public resolveAll(): Namespace;

    /**
     * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
     * @param path Path to look up
     * @param filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
     * @param [parentAlreadyChecked=false] If known, whether the parent has already been checked
     * @returns Looked up object or `null` if none could be found
     */
    public lookup(path: (string|string[]), filterTypes: (any|any[]), parentAlreadyChecked?: boolean): (ReflectionObject|null);

    /**
     * Looks up the reflection object at the specified path, relative to this namespace.
     * @param path Path to look up
     * @param [parentAlreadyChecked=false] Whether the parent has already been checked
     * @returns Looked up object or `null` if none could be found
     */
    public lookup(path: (string|string[]), parentAlreadyChecked?: boolean): (ReflectionObject|null);

    /**
     * Looks up the {@link Type|type} at the specified path, relative to this namespace.
     * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
     * @param path Path to look up
     * @returns Looked up type
     * @throws {Error} If `path` does not point to a type
     */
    public lookupType(path: (string|string[])): Type;

    /**
     * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
     * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
     * @param path Path to look up
     * @returns Looked up enum
     * @throws {Error} If `path` does not point to an enum
     */
    public lookupEnum(path: (string|string[])): Enum;

    /**
     * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
     * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
     * @param path Path to look up
     * @returns Looked up type or enum
     * @throws {Error} If `path` does not point to a type or enum
     */
    public lookupTypeOrEnum(path: (string|string[])): Type;

    /**
     * Looks up the {@link Service|service} at the specified path, relative to this namespace.
     * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
     * @param path Path to look up
     * @returns Looked up service
     * @throws {Error} If `path` does not point to a service
     */
    public lookupService(path: (string|string[])): Service;
}

/** Namespace descriptor. */
export interface INamespace {

    /** Namespace options */
    options?: { [k: string]: any };

    /** Nested object descriptors */
    nested?: { [k: string]: AnyNestedObject };
}

/** Any extension field descriptor. */
type AnyExtensionField = (IExtensionField|IExtensionMapField);

/** Any nested object descriptor. */
type AnyNestedObject = (IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf);

/** Base class of all reflection objects. */
export abstract class ReflectionObject {

    /** Options. */
    public options?: { [k: string]: any };

    /** Parsed Options. */
    public parsedOptions?: { [k: string]: any[] };

    /** Unique name within its namespace. */
    public name: string;

    /** Parent namespace. */
    public parent: (Namespace|null);

    /** Whether already resolved or not. */
    public resolved: boolean;

    /** Comment text, if any. */
    public comment: (string|null);

    /** Defining file name. */
    public filename: (string|null);

    /** Reference to the root namespace. */
    public readonly root: Root;

    /** Full name including leading dot. */
    public readonly fullName: string;

    /**
     * Converts this reflection object to its descriptor representation.
     * @returns Descriptor
     */
    public toJSON(): { [k: string]: any };

    /**
     * Called when this object is added to a parent.
     * @param parent Parent added to
     */
    public onAdd(parent: ReflectionObject): void;

    /**
     * Called when this object is removed from a parent.
     * @param parent Parent removed from
     */
    public onRemove(parent: ReflectionObject): void;

    /**
     * Resolves this objects type references.
     * @returns `this`
     */
    public resolve(): ReflectionObject;

    /**
     * Gets an option value.
     * @param name Option name
     * @returns Option value or `undefined` if not set
     */
    public getOption(name: string): any;

    /**
     * Sets an option.
     * @param name Option name
     * @param value Option value
     * @param [ifNotSet] Sets the option only if it isn't currently set
     * @returns `this`
     */
    public setOption(name: string, value: any, ifNotSet?: boolean): ReflectionObject;

    /**
     * Sets a parsed option.
     * @param name parsed Option name
     * @param value Option value
     * @param propName dot '.' delimited full path of property within the option to set. if undefined\empty, will add a new option with that value
     * @returns `this`
     */
    public setParsedOption(name: string, value: any, propName: string): ReflectionObject;

    /**
     * Sets multiple options.
     * @param options Options to set
     * @param [ifNotSet] Sets an option only if it isn't currently set
     * @returns `this`
     */
    public setOptions(options: { [k: string]: any }, ifNotSet?: boolean): ReflectionObject;

    /**
     * Converts this instance to its string representation.
     * @returns Class name[, space, full name]
     */
    public toString(): string;
}

/** Reflected oneof. */
export class OneOf extends ReflectionObject {

    /**
     * Constructs a new oneof instance.
     * @param name Oneof name
     * @param [fieldNames] Field names
     * @param [options] Declared options
     * @param [comment] Comment associated with this field
     */
    constructor(name: string, fieldNames?: (string[]|{ [k: string]: any }), options?: { [k: string]: any }, comment?: string);

    /** Field names that belong to this oneof. */
    public oneof: string[];

    /** Fields that belong to this oneof as an array for iteration. */
    public readonly fieldsArray: Field[];

    /** Comment for this field. */
    public comment: (string|null);

    /**
     * Constructs a oneof from a oneof descriptor.
     * @param name Oneof name
     * @param json Oneof descriptor
     * @returns Created oneof
     * @throws {TypeError} If arguments are invalid
     */
    public static fromJSON(name: string, json: IOneOf): OneOf;

    /**
     * Converts this oneof to a oneof descriptor.
     * @param [toJSONOptions] JSON conversion options
     * @returns Oneof descriptor
     */
    public toJSON(toJSONOptions?: IToJSONOptions): IOneOf;

    /**
     * Adds a field to this oneof and removes it from its current parent, if any.
     * @param field Field to add
     * @returns `this`
     */
    public add(field: Field): OneOf;

    /**
     * Removes a field from this oneof and puts it back to the oneof's parent.
     * @param field Field to remove
     * @returns `this`
     */
    public remove(field: Field): OneOf;

    /**
     * OneOf decorator (TypeScript).
     * @param fieldNames Field names
     * @returns Decorator function
     */
    public static d<T extends string>(...fieldNames: string[]): OneOfDecorator;
}

/** Oneof descriptor. */
export interface IOneOf {

    /** Oneof field names */
    oneof: string[];

    /** Oneof options */
    options?: { [k: string]: any };
}

/**
 * Decorator function as returned by {@link OneOf.d} (TypeScript).
 * @param prototype Target prototype
 * @param oneofName OneOf name
 */
type OneOfDecorator = (prototype: object, oneofName: string) => void;

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @param source Source contents
 * @param [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns Parser result
 */
export function parse(source: string, options?: IParseOptions): IParserResult;

/** Result object returned from {@link parse}. */
export interface IParserResult {

    /** Package name, if declared */
    package: (string|undefined);

    /** Imports, if any */
    imports: (string[]|undefined);

    /** Weak imports, if any */
    weakImports: (string[]|undefined);

    /** Syntax, if specified (either `"proto2"` or `"proto3"`) */
    syntax: (string|undefined);

    /** Populated root instance */
    root: Root;
}

/** Options modifying the behavior of {@link parse}. */
export interface IParseOptions {

    /** Keeps field casing instead of converting to camel case */
    keepCase?: boolean;

    /** Recognize double-slash comments in addition to doc-block comments. */
    alternateCommentMode?: boolean;

    /** Use trailing comment when both leading comment and trailing comment exist. */
    preferTrailingComment?: boolean;
}

/** Options modifying the behavior of JSON serialization. */
export interface IToJSONOptions {

    /** Serializes comments. */
    keepComments?: boolean;
}

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @param source Source contents
 * @param root Root to populate
 * @param [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns Parser result
 */
export function parse(source: string, root: Root, options?: IParseOptions): IParserResult;

/** Wire format reader using `Uint8Array` if available, otherwise `Array`. */
export class Reader {

    /**
     * Constructs a new reader instance using the specified buffer.
     * @param buffer Buffer to read from
     */
    constructor(buffer: Uint8Array);

    /** Read buffer. */
    public buf: Uint8Array;

    /** Read buffer position. */
    public pos: number;

    /** Read buffer length. */
    public len: number;

    /**
     * Creates a new reader using the specified buffer.
     * @param buffer Buffer to read from
     * @returns A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
     * @throws {Error} If `buffer` is not a valid buffer
     */
    public static create(buffer: (Uint8Array|Buffer)): (Reader|BufferReader);

    /**
     * Reads a varint as an unsigned 32 bit value.
     * @returns Value read
     */
    public uint32(): number;

    /**
     * Reads a varint as a signed 32 bit value.
     * @returns Value read
     */
    public int32(): number;

    /**
     * Reads a zig-zag encoded varint as a signed 32 bit value.
     * @returns Value read
     */
    public sint32(): number;

    /**
     * Reads a varint as a signed 64 bit value.
     * @returns Value read
     */
    public int64(): Long;

    /**
     * Reads a varint as an unsigned 64 bit value.
     * @returns Value read
     */
    public uint64(): Long;

    /**
     * Reads a zig-zag encoded varint as a signed 64 bit value.
     * @returns Value read
     */
    public sint64(): Long;

    /**
     * Reads a varint as a boolean.
     * @returns Value read
     */
    public bool(): boolean;

    /**
     * Reads fixed 32 bits as an unsigned 32 bit integer.
     * @returns Value read
     */
    public fixed32(): number;

    /**
     * Reads fixed 32 bits as a signed 32 bit integer.
     * @returns Value read
     */
    public sfixed32(): number;

    /**
     * Reads fixed 64 bits.
     * @returns Value read
     */
    public fixed64(): Long;

    /**
     * Reads zig-zag encoded fixed 64 bits.
     * @returns Value read
     */
    public sfixed64(): Long;

    /**
     * Reads a float (32 bit) as a number.
     * @returns Value read
     */
    public float(): number;

    /**
     * Reads a double (64 bit float) as a number.
     * @returns Value read
     */
    public double(): number;

    /**
     * Reads a sequence of bytes preceeded by its length as a varint.
     * @returns Value read
     */
    public bytes(): Uint8Array;

    /**
     * Reads a string preceeded by its byte length as a varint.
     * @returns Value read
     */
    public string(): string;

    /**
     * Skips the specified number of bytes if specified, otherwise skips a varint.
     * @param [length] Length if known, otherwise a varint is assumed
     * @returns `this`
     */
    public skip(length?: number): Reader;

    /**
     * Skips the next element of the specified wire type.
     * @param wireType Wire type received
     * @returns `this`
     */
    public skipType(wireType: number): Reader;
}

/** Wire format reader using node buffers. */
export class BufferReader extends Reader {

    /**
     * Constructs a new buffer reader instance.
     * @param buffer Buffer to read from
     */
    constructor(buffer: Buffer);

    /**
     * Reads a sequence of bytes preceeded by its length as a varint.
     * @returns Value read
     */
    public bytes(): Buffer;
}

/** Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together. */
export class Root extends NamespaceBase {

    /**
     * Constructs a new root namespace instance.
     * @param [options] Top level options
     */
    constructor(options?: { [k: string]: any });

    /** Deferred extension fields. */
    public deferred: Field[];

    /** Resolved file names of loaded files. */
    public files: string[];

    /**
     * Loads a namespace descriptor into a root namespace.
     * @param json Nameespace descriptor
     * @param [root] Root namespace, defaults to create a new one if omitted
     * @returns Root namespace
     */
    public static fromJSON(json: INamespace, root?: Root): Root;

    /**
     * Resolves the path of an imported file, relative to the importing origin.
     * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
     * @param origin The file name of the importing file
     * @param target The file name being imported
     * @returns Resolved path to `target` or `null` to skip the file
     */
    public resolvePath(origin: string, target: string): (string|null);

    /**
     * Fetch content from file path or url
     * This method exists so you can override it with your own logic.
     * @param path File path or url
     * @param callback Callback function
     */
    public fetch(path: string, callback: FetchCallback): void;

    /**
     * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
     * @param filename Names of one or multiple files to load
     * @param options Parse options
     * @param callback Callback function
     */
    public load(filename: (string|string[]), options: IParseOptions, callback: LoadCallback): void;

    /**
     * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
     * @param filename Names of one or multiple files to load
     * @param callback Callback function
     */
    public load(filename: (string|string[]), callback: LoadCallback): void;

    /**
     * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
     * @param filename Names of one or multiple files to load
     * @param [options] Parse options. Defaults to {@link parse.defaults} when omitted.
     * @returns Promise
     */
    public load(filename: (string|string[]), options?: IParseOptions): Promise<Root>;

    /**
     * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
     * @param filename Names of one or multiple files to load
     * @param [options] Parse options. Defaults to {@link parse.defaults} when omitted.
     * @returns Root namespace
     * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
     */
    public loadSync(filename: (string|string[]), options?: IParseOptions): Root;
}

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available across modules.
 */
export let roots: { [k: string]: Root };

/** Streaming RPC helpers. */
export namespace rpc {

    /**
     * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
     *
     * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
     * @param error Error, if any
     * @param [response] Response message
     */
    type ServiceMethodCallback<TRes extends Message<TRes>> = (error: (Error|null), response?: TRes) => void;

    /**
     * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
     * @param request Request message or plain object
     * @param [callback] Node-style callback called with the error, if any, and the response message
     * @returns Promise if `callback` has been omitted, otherwise `undefined`
     */
    type ServiceMethod<TReq extends Message<TReq>, TRes extends Message<TRes>> = (request: (TReq|Properties<TReq>), callback?: rpc.ServiceMethodCallback<TRes>) => Promise<Message<TRes>>;

    /** An RPC service as returned by {@link Service#create}. */
    class Service extends util.EventEmitter {

        /**
         * Constructs a new RPC service instance.
         * @param rpcImpl RPC implementation
         * @param [requestDelimited=false] Whether requests are length-delimited
         * @param [responseDelimited=false] Whether responses are length-delimited
         */
        constructor(rpcImpl: RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

        /** RPC implementation. Becomes `null` once the service is ended. */
        public rpcImpl: (RPCImpl|null);

        /** Whether requests are length-delimited. */
        public requestDelimited: boolean;

        /** Whether responses are length-delimited. */
        public responseDelimited: boolean;

        /**
         * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
         * @param method Reflected or static method
         * @param requestCtor Request constructor
         * @param responseCtor Response constructor
         * @param request Request message or plain object
         * @param callback Service callback
         */
        public rpcCall<TReq extends Message<TReq>, TRes extends Message<TRes>>(method: (Method|rpc.ServiceMethod<TReq, TRes>), requestCtor: Constructor<TReq>, responseCtor: Constructor<TRes>, request: (TReq|Properties<TReq>), callback: rpc.ServiceMethodCallback<TRes>): void;

        /**
         * Ends this service and emits the `end` event.
         * @param [endedByRPC=false] Whether the service has been ended by the RPC implementation.
         * @returns `this`
         */
        public end(endedByRPC?: boolean): rpc.Service;
    }
}

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @param method Reflected or static method being called
 * @param requestData Request data
 * @param callback Callback function
 */
type RPCImpl = (method: (Method|rpc.ServiceMethod<Message<{}>, Message<{}>>), requestData: Uint8Array, callback: RPCImplCallback) => void;

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @param error Error, if any, otherwise `null`
 * @param [response] Response data or `null` to signal end of stream, if there hasn't been an error
 */
type RPCImplCallback = (error: (Error|null), response?: (Uint8Array|null)) => void;

/** Reflected service. */
export class Service extends NamespaceBase {

    /**
     * Constructs a new service instance.
     * @param name Service name
     * @param [options] Service options
     * @throws {TypeError} If arguments are invalid
     */
    constructor(name: string, options?: { [k: string]: any });

    /** Service methods. */
    public methods: { [k: string]: Method };

    /**
     * Constructs a service from a service descriptor.
     * @param name Service name
     * @param json Service descriptor
     * @returns Created service
     * @throws {TypeError} If arguments are invalid
     */
    public static fromJSON(name: string, json: IService): Service;

    /**
     * Converts this service to a service descriptor.
     * @param [toJSONOptions] JSON conversion options
     * @returns Service descriptor
     */
    public toJSON(toJSONOptions?: IToJSONOptions): IService;

    /** Methods of this service as an array for iteration. */
    public readonly methodsArray: Method[];

    /**
     * Creates a runtime service using the specified rpc implementation.
     * @param rpcImpl RPC implementation
     * @param [requestDelimited=false] Whether requests are length-delimited
     * @param [responseDelimited=false] Whether responses are length-delimited
     * @returns RPC service. Useful where requests and/or responses are streamed.
     */
    public create(rpcImpl: RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): rpc.Service;
}

/** Service descriptor. */
export interface IService extends INamespace {

    /** Method descriptors */
    methods: { [k: string]: IMethod };
}

/**
 * Gets the next token and advances.
 * @returns Next token or `null` on eof
 */
type TokenizerHandleNext = () => (string|null);

/**
 * Peeks for the next token.
 * @returns Next token or `null` on eof
 */
type TokenizerHandlePeek = () => (string|null);

/**
 * Pushes a token back to the stack.
 * @param token Token
 */
type TokenizerHandlePush = (token: string) => void;

/**
 * Skips the next token.
 * @param expected Expected token
 * @param [optional=false] If optional
 * @returns Whether the token matched
 * @throws {Error} If the token didn't match and is not optional
 */
type TokenizerHandleSkip = (expected: string, optional?: boolean) => boolean;

/**
 * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
 * @param [line] Line number
 * @returns Comment text or `null` if none
 */
type TokenizerHandleCmnt = (line?: number) => (string|null);

/** Handle object returned from {@link tokenize}. */
export interface ITokenizerHandle {

    /** Gets the next token and advances (`null` on eof) */
    next: TokenizerHandleNext;

    /** Peeks for the next token (`null` on eof) */
    peek: TokenizerHandlePeek;

    /** Pushes a token back to the stack */
    push: TokenizerHandlePush;

    /** Skips a token, returns its presence and advances or, if non-optional and not present, throws */
    skip: TokenizerHandleSkip;

    /** Gets the comment on the previous line or the line comment on the specified line, if any */
    cmnt: TokenizerHandleCmnt;

    /** Current line number */
    line: number;
}

/**
 * Tokenizes the given .proto source and returns an object with useful utility functions.
 * @param source Source contents
 * @param alternateCommentMode Whether we should activate alternate comment parsing mode.
 * @returns Tokenizer handle
 */
export function tokenize(source: string, alternateCommentMode: boolean): ITokenizerHandle;

export namespace tokenize {

    /**
     * Unescapes a string.
     * @param str String to unescape
     * @returns Unescaped string
     */
    function unescape(str: string): string;
}

/** Reflected message type. */
export class Type extends NamespaceBase {

    /**
     * Constructs a new reflected message type instance.
     * @param name Message name
     * @param [options] Declared options
     */
    constructor(name: string, options?: { [k: string]: any });

    /** Message fields. */
    public fields: { [k: string]: Field };

    /** Oneofs declared within this namespace, if any. */
    public oneofs: { [k: string]: OneOf };

    /** Extension ranges, if any. */
    public extensions: number[][];

    /** Reserved ranges, if any. */
    public reserved: (number[]|string)[];

    /** Message fields by id. */
    public readonly fieldsById: { [k: number]: Field };

    /** Fields of this message as an array for iteration. */
    public readonly fieldsArray: Field[];

    /** Oneofs of this message as an array for iteration. */
    public readonly oneofsArray: OneOf[];

    /**
     * The registered constructor, if any registered, otherwise a generic constructor.
     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
     */
    public ctor: Constructor<{}>;

    /**
     * Generates a constructor function for the specified type.
     * @param mtype Message type
     * @returns Codegen instance
     */
    public static generateConstructor(mtype: Type): Codegen;

    /**
     * Creates a message type from a message type descriptor.
     * @param name Message name
     * @param json Message type descriptor
     * @returns Created message type
     */
    public static fromJSON(name: string, json: IType): Type;

    /**
     * Converts this message type to a message type descriptor.
     * @param [toJSONOptions] JSON conversion options
     * @returns Message type descriptor
     */
    public toJSON(toJSONOptions?: IToJSONOptions): IType;

    /**
     * Adds a nested object to this type.
     * @param object Nested object to add
     * @returns `this`
     * @throws {TypeError} If arguments are invalid
     * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
     */
    public add(object: ReflectionObject): Type;

    /**
     * Removes a nested object from this type.
     * @param object Nested object to remove
     * @returns `this`
     * @throws {TypeError} If arguments are invalid
     * @throws {Error} If `object` is not a member of this type
     */
    public remove(object: ReflectionObject): Type;

    /**
     * Tests if the specified id is reserved.
     * @param id Id to test
     * @returns `true` if reserved, otherwise `false`
     */
    public isReservedId(id: number): boolean;

    /**
     * Tests if the specified name is reserved.
     * @param name Name to test
     * @returns `true` if reserved, otherwise `false`
     */
    public isReservedName(name: string): boolean;

    /**
     * Creates a new message of this type using the specified properties.
     * @param [properties] Properties to set
     * @returns Message instance
     */
    public create(properties?: { [k: string]: any }): Message<{}>;

    /**
     * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
     * @returns `this`
     */
    public setup(): Type;

    /**
     * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
     * @param message Message instance or plain object
     * @param [writer] Writer to encode to
     * @returns writer
     */
    public encode(message: (Message<{}>|{ [k: string]: any }), writer?: Writer): Writer;

    /**
     * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
     * @param message Message instance or plain object
     * @param [writer] Writer to encode to
     * @returns writer
     */
    public encodeDelimited(message: (Message<{}>|{ [k: string]: any }), writer?: Writer): Writer;

    /**
     * Decodes a message of this type.
     * @param reader Reader or buffer to decode from
     * @param [length] Length of the message, if known beforehand
     * @returns Decoded message
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {util.ProtocolError<{}>} If required fields are missing
     */
    public decode(reader: (Reader|Uint8Array), length?: number): Message<{}>;

    /**
     * Decodes a message of this type preceeded by its byte length as a varint.
     * @param reader Reader or buffer to decode from
     * @returns Decoded message
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {util.ProtocolError} If required fields are missing
     */
    public decodeDelimited(reader: (Reader|Uint8Array)): Message<{}>;

    /**
     * Verifies that field values are valid and that required fields are present.
     * @param message Plain object to verify
     * @returns `null` if valid, otherwise the reason why it is not
     */
    public verify(message: { [k: string]: any }): (null|string);

    /**
     * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
     * @param object Plain object to convert
     * @returns Message instance
     */
    public fromObject(object: { [k: string]: any }): Message<{}>;

    /**
     * Creates a plain object from a message of this type. Also converts values to other types if specified.
     * @param message Message instance
     * @param [options] Conversion options
     * @returns Plain object
     */
    public toObject(message: Message<{}>, options?: IConversionOptions): { [k: string]: any };

    /**
     * Type decorator (TypeScript).
     * @param [typeName] Type name, defaults to the constructor's name
     * @returns Decorator function
     */
    public static d<T extends Message<T>>(typeName?: string): TypeDecorator<T>;
}

/** Message type descriptor. */
export interface IType extends INamespace {

    /** Oneof descriptors */
    oneofs?: { [k: string]: IOneOf };

    /** Field descriptors */
    fields: { [k: string]: IField };

    /** Extension ranges */
    extensions?: number[][];

    /** Reserved ranges */
    reserved?: (number[]|string)[];

    /** Whether a legacy group or not */
    group?: boolean;
}

/** Conversion options as used by {@link Type#toObject} and {@link Message.toObject}. */
export interface IConversionOptions {

    /**
     * Long conversion type.
     * Valid values are `String` and `Number` (the global types).
     * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
     */
    longs?: Function;

    /**
     * Enum value conversion type.
     * Only valid value is `String` (the global type).
     * Defaults to copy the present value, which is the numeric id.
     */
    enums?: Function;

    /**
     * Bytes value conversion type.
     * Valid values are `Array` and (a base64 encoded) `String` (the global types).
     * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
     */
    bytes?: Function;

    /** Also sets default values on the resulting object */
    defaults?: boolean;

    /** Sets empty arrays for missing repeated fields even if `defaults=false` */
    arrays?: boolean;

    /** Sets empty objects for missing map fields even if `defaults=false` */
    objects?: boolean;

    /** Includes virtual oneof properties set to the present field's name, if any */
    oneofs?: boolean;

    /** Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings */
    json?: boolean;
}

/**
 * Decorator function as returned by {@link Type.d} (TypeScript).
 * @param target Target constructor
 */
type TypeDecorator<T extends Message<T>> = (target: Constructor<T>) => void;

/** Common type constants. */
export namespace types {

    /** Basic type wire types. */
    const basic: {
        "double": number,
        "float": number,
        "int32": number,
        "uint32": number,
        "sint32": number,
        "fixed32": number,
        "sfixed32": number,
        "int64": number,
        "uint64": number,
        "sint64": number,
        "fixed64": number,
        "sfixed64": number,
        "bool": number,
        "string": number,
        "bytes": number
    };

    /** Basic type defaults. */
    const defaults: {
        "double": number,
        "float": number,
        "int32": number,
        "uint32": number,
        "sint32": number,
        "fixed32": number,
        "sfixed32": number,
        "int64": number,
        "uint64": number,
        "sint64": number,
        "fixed64": number,
        "sfixed64": number,
        "bool": boolean,
        "string": string,
        "bytes": number[],
        "message": null
    };

    /** Basic long type wire types. */
    const long: {
        "int64": number,
        "uint64": number,
        "sint64": number,
        "fixed64": number,
        "sfixed64": number
    };

    /** Allowed types for map keys with their associated wire type. */
    const mapKey: {
        "int32": number,
        "uint32": number,
        "sint32": number,
        "fixed32": number,
        "sfixed32": number,
        "int64": number,
        "uint64": number,
        "sint64": number,
        "fixed64": number,
        "sfixed64": number,
        "bool": number,
        "string": number
    };

    /** Allowed types for packed repeated fields with their associated wire type. */
    const packed: {
        "double": number,
        "float": number,
        "int32": number,
        "uint32": number,
        "sint32": number,
        "fixed32": number,
        "sfixed32": number,
        "int64": number,
        "uint64": number,
        "sint64": number,
        "fixed64": number,
        "sfixed64": number,
        "bool": number
    };
}

/** Constructor type. */
export interface Constructor<T> extends Function {
    new(...params: any[]): T; prototype: T;
}

/** Properties type. */
type Properties<T> = { [P in keyof T]?: T[P] };

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 */
export interface Buffer extends Uint8Array {
}

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 */
export interface Long {

    /** Low bits */
    low: number;

    /** High bits */
    high: number;

    /** Whether unsigned or not */
    unsigned: boolean;
}

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @returns Set field name, if any
 */
type OneOfGetter = () => (string|undefined);

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @param value Field name
 */
type OneOfSetter = (value: (string|undefined)) => void;

/** Various utility functions. */
export namespace util {

    /** Helper class for working with the low and high bits of a 64 bit value. */
    class LongBits {

        /**
         * Constructs new long bits.
         * @param lo Low 32 bits, unsigned
         * @param hi High 32 bits, unsigned
         */
        constructor(lo: number, hi: number);

        /** Low bits. */
        public lo: number;

        /** High bits. */
        public hi: number;

        /** Zero bits. */
        public static zero: util.LongBits;

        /** Zero hash. */
        public static zeroHash: string;

        /**
         * Constructs new long bits from the specified number.
         * @param value Value
         * @returns Instance
         */
        public static fromNumber(value: number): util.LongBits;

        /**
         * Constructs new long bits from a number, long or string.
         * @param value Value
         * @returns Instance
         */
        public static from(value: (Long|number|string)): util.LongBits;

        /**
         * Converts this long bits to a possibly unsafe JavaScript number.
         * @param [unsigned=false] Whether unsigned or not
         * @returns Possibly unsafe number
         */
        public toNumber(unsigned?: boolean): number;

        /**
         * Converts this long bits to a long.
         * @param [unsigned=false] Whether unsigned or not
         * @returns Long
         */
        public toLong(unsigned?: boolean): Long;

        /**
         * Constructs new long bits from the specified 8 characters long hash.
         * @param hash Hash
         * @returns Bits
         */
        public static fromHash(hash: string): util.LongBits;

        /**
         * Converts this long bits to a 8 characters long hash.
         * @returns Hash
         */
        public toHash(): string;

        /**
         * Zig-zag encodes this long bits.
         * @returns `this`
         */
        public zzEncode(): util.LongBits;

        /**
         * Zig-zag decodes this long bits.
         * @returns `this`
         */
        public zzDecode(): util.LongBits;

        /**
         * Calculates the length of this longbits when encoded as a varint.
         * @returns Length
         */
        public length(): number;
    }

    /** Whether running within node or not. */
    let isNode: boolean;

    /** Global object reference. */
    let global: object;

    /** An immuable empty array. */
    const emptyArray: any[];

    /** An immutable empty object. */
    const emptyObject: object;

    /**
     * Tests if the specified value is an integer.
     * @param value Value to test
     * @returns `true` if the value is an integer
     */
    function isInteger(value: any): boolean;

    /**
     * Tests if the specified value is a string.
     * @param value Value to test
     * @returns `true` if the value is a string
     */
    function isString(value: any): boolean;

    /**
     * Tests if the specified value is a non-null object.
     * @param value Value to test
     * @returns `true` if the value is a non-null object
     */
    function isObject(value: any): boolean;

    /**
     * Checks if a property on a message is considered to be present.
     * This is an alias of {@link util.isSet}.
     * @param obj Plain object or message instance
     * @param prop Property name
     * @returns `true` if considered to be present, otherwise `false`
     */
    function isset(obj: object, prop: string): boolean;

    /**
     * Checks if a property on a message is considered to be present.
     * @param obj Plain object or message instance
     * @param prop Property name
     * @returns `true` if considered to be present, otherwise `false`
     */
    function isSet(obj: object, prop: string): boolean;

    /** Node's Buffer class if available. */
    let Buffer: Constructor<Buffer>;

    /**
     * Creates a new buffer of whatever type supported by the environment.
     * @param [sizeOrArray=0] Buffer size or number array
     * @returns Buffer
     */
    function newBuffer(sizeOrArray?: (number|number[])): (Uint8Array|Buffer);

    /** Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`. */
    let Array: Constructor<Uint8Array>;

    /** Long.js's Long class if available. */
    let Long: Constructor<Long>;

    /** Regular expression used to verify 2 bit (`bool`) map keys. */
    const key2Re: RegExp;

    /** Regular expression used to verify 32 bit (`int32` etc.) map keys. */
    const key32Re: RegExp;

    /** Regular expression used to verify 64 bit (`int64` etc.) map keys. */
    const key64Re: RegExp;

    /**
     * Converts a number or long to an 8 characters long hash string.
     * @param value Value to convert
     * @returns Hash
     */
    function longToHash(value: (Long|number)): string;

    /**
     * Converts an 8 characters long hash string to a long or number.
     * @param hash Hash
     * @param [unsigned=false] Whether unsigned or not
     * @returns Original value
     */
    function longFromHash(hash: string, unsigned?: boolean): (Long|number);

    /**
     * Merges the properties of the source object into the destination object.
     * @param dst Destination object
     * @param src Source object
     * @param [ifNotSet=false] Merges only if the key is not already set
     * @returns Destination object
     */
    function merge(dst: { [k: string]: any }, src: { [k: string]: any }, ifNotSet?: boolean): { [k: string]: any };

    /**
     * Converts the first character of a string to lower case.
     * @param str String to convert
     * @returns Converted string
     */
    function lcFirst(str: string): string;

    /**
     * Creates a custom error constructor.
     * @param name Error name
     * @returns Custom error constructor
     */
    function newError(name: string): Constructor<Error>;

    /** Error subclass indicating a protocol specifc error. */
    class ProtocolError<T extends Message<T>> extends Error {

        /**
         * Constructs a new protocol error.
         * @param message Error message
         * @param [properties] Additional properties
         */
        constructor(message: string, properties?: { [k: string]: any });

        /** So far decoded message instance. */
        public instance: Message<T>;
    }

    /**
     * Builds a getter for a oneof's present field name.
     * @param fieldNames Field names
     * @returns Unbound getter
     */
    function oneOfGetter(fieldNames: string[]): OneOfGetter;

    /**
     * Builds a setter for a oneof's present field name.
     * @param fieldNames Field names
     * @returns Unbound setter
     */
    function oneOfSetter(fieldNames: string[]): OneOfSetter;

    /**
     * Default conversion options used for {@link Message#toJSON} implementations.
     *
     * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
     *
     * - Longs become strings
     * - Enums become string keys
     * - Bytes become base64 encoded strings
     * - (Sub-)Messages become plain objects
     * - Maps become plain objects with all string keys
     * - Repeated fields become arrays
     * - NaN and Infinity for float and double fields become strings
     *
     * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
     */
    let toJSONOptions: IConversionOptions;

    /** Node's fs module if available. */
    let fs: { [k: string]: any };

    /**
     * Converts an object's values to an array.
     * @param object Object to convert
     * @returns Converted array
     */
    function toArray(object: { [k: string]: any }): any[];

    /**
     * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
     * @param array Array to convert
     * @returns Converted object
     */
    function toObject(array: any[]): { [k: string]: any };

    /**
     * Tests whether the specified name is a reserved word in JS.
     * @param name Name to test
     * @returns `true` if reserved, otherwise `false`
     */
    function isReserved(name: string): boolean;

    /**
     * Returns a safe property accessor for the specified property name.
     * @param prop Property name
     * @returns Safe accessor
     */
    function safeProp(prop: string): string;

    /**
     * Returns the value of a property found directly in a given object.
     * @param object Source object
     * @param prop Property name
     * @returns Value or `undefined` if not set
     */
    function getProp(object: object, prop: string): any;

    /**
     * Converts the first character of a string to upper case.
     * @param str String to convert
     * @returns Converted string
     */
    function ucFirst(str: string): string;

    /**
     * Converts a string to camel case.
     * @param str String to convert
     * @returns Converted string
     */
    function camelCase(str: string): string;

    /**
     * Compares reflected fields by id.
     * @param a First field
     * @param b Second field
     * @returns Comparison value
     */
    function compareFieldsById(a: Field, b: Field): number;

    /**
     * Decorator helper for types (TypeScript).
     * @param ctor Constructor function
     * @param [typeName] Type name, defaults to the constructor's name
     * @returns Reflected type
     */
    function decorateType<T extends Message<T>>(ctor: Constructor<T>, typeName?: string): Type;

    /**
     * Decorator helper for enums (TypeScript).
     * @param object Enum object
     * @returns Reflected enum
     */
    function decorateEnum(object: object): Enum;

    /**
     * Sets the value of a property by property path. If a value already exists, it is turned to an array
     * @param dst Destination object
     * @param path dot '.' delimited path of the property to set
     * @param value the value to set
     * @returns Destination object
     */
    function setProperty(dst: { [k: string]: any }, path: string, value: object): { [k: string]: any };

    /** Decorator root (TypeScript). */
    let decorateRoot: Root;

    /**
     * Returns a promise from a node-style callback function.
     * @param fn Function to call
     * @param ctx Function context
     * @param params Function arguments
     * @returns Promisified function
     */
    function asPromise(fn: asPromiseCallback, ctx: any, ...params: any[]): Promise<any>;

    /** A minimal base64 implementation for number arrays. */
    namespace base64 {

        /**
         * Calculates the byte length of a base64 encoded string.
         * @param string Base64 encoded string
         * @returns Byte length
         */
        function length(string: string): number;

        /**
         * Encodes a buffer to a base64 encoded string.
         * @param buffer Source buffer
         * @param start Source start
         * @param end Source end
         * @returns Base64 encoded string
         */
        function encode(buffer: Uint8Array, start: number, end: number): string;

        /**
         * Decodes a base64 encoded string to a buffer.
         * @param string Source string
         * @param buffer Destination buffer
         * @param offset Destination offset
         * @returns Number of bytes written
         * @throws {Error} If encoding is invalid
         */
        function decode(string: string, buffer: Uint8Array, offset: number): number;

        /**
         * Tests if the specified string appears to be base64 encoded.
         * @param string String to test
         * @returns `true` if probably base64 encoded, otherwise false
         */
        function test(string: string): boolean;
    }

    /**
     * Begins generating a function.
     * @param functionParams Function parameter names
     * @param [functionName] Function name if not anonymous
     * @returns Appender that appends code to the function's body
     */
    function codegen(functionParams: string[], functionName?: string): Codegen;

    namespace codegen {

        /** When set to `true`, codegen will log generated code to console. Useful for debugging. */
        let verbose: boolean;
    }

    /**
     * Begins generating a function.
     * @param [functionName] Function name if not anonymous
     * @returns Appender that appends code to the function's body
     */
    function codegen(functionName?: string): Codegen;

    /** A minimal event emitter. */
    class EventEmitter {

        /** Constructs a new event emitter instance. */
        constructor();

        /**
         * Registers an event listener.
         * @param evt Event name
         * @param fn Listener
         * @param [ctx] Listener context
         * @returns `this`
         */
        public on(evt: string, fn: EventEmitterListener, ctx?: any): this;

        /**
         * Removes an event listener or any matching listeners if arguments are omitted.
         * @param [evt] Event name. Removes all listeners if omitted.
         * @param [fn] Listener to remove. Removes all listeners of `evt` if omitted.
         * @returns `this`
         */
        public off(evt?: string, fn?: EventEmitterListener): this;

        /**
         * Emits an event by calling its listeners with the specified arguments.
         * @param evt Event name
         * @param args Arguments
         * @returns `this`
         */
        public emit(evt: string, ...args: any[]): this;
    }

    /** Reads / writes floats / doubles from / to buffers. */
    namespace float {

        /**
         * Writes a 32 bit float to a buffer using little endian byte order.
         * @param val Value to write
         * @param buf Target buffer
         * @param pos Target buffer offset
         */
        function writeFloatLE(val: number, buf: Uint8Array, pos: number): void;

        /**
         * Writes a 32 bit float to a buffer using big endian byte order.
         * @param val Value to write
         * @param buf Target buffer
         * @param pos Target buffer offset
         */
        function writeFloatBE(val: number, buf: Uint8Array, pos: number): void;

        /**
         * Reads a 32 bit float from a buffer using little endian byte order.
         * @param buf Source buffer
         * @param pos Source buffer offset
         * @returns Value read
         */
        function readFloatLE(buf: Uint8Array, pos: number): number;

        /**
         * Reads a 32 bit float from a buffer using big endian byte order.
         * @param buf Source buffer
         * @param pos Source buffer offset
         * @returns Value read
         */
        function readFloatBE(buf: Uint8Array, pos: number): number;

        /**
         * Writes a 64 bit double to a buffer using little endian byte order.
         * @param val Value to write
         * @param buf Target buffer
         * @param pos Target buffer offset
         */
        function writeDoubleLE(val: number, buf: Uint8Array, pos: number): void;

        /**
         * Writes a 64 bit double to a buffer using big endian byte order.
         * @param val Value to write
         * @param buf Target buffer
         * @param pos Target buffer offset
         */
        function writeDoubleBE(val: number, buf: Uint8Array, pos: number): void;

        /**
         * Reads a 64 bit double from a buffer using little endian byte order.
         * @param buf Source buffer
         * @param pos Source buffer offset
         * @returns Value read
         */
        function readDoubleLE(buf: Uint8Array, pos: number): number;

        /**
         * Reads a 64 bit double from a buffer using big endian byte order.
         * @param buf Source buffer
         * @param pos Source buffer offset
         * @returns Value read
         */
        function readDoubleBE(buf: Uint8Array, pos: number): number;
    }

    /**
     * Fetches the contents of a file.
     * @param filename File path or url
     * @param options Fetch options
     * @param callback Callback function
     */
    function fetch(filename: string, options: IFetchOptions, callback: FetchCallback): void;

    /**
     * Fetches the contents of a file.
     * @param path File path or url
     * @param callback Callback function
     */
    function fetch(path: string, callback: FetchCallback): void;

    /**
     * Fetches the contents of a file.
     * @param path File path or url
     * @param [options] Fetch options
     * @returns Promise
     */
    function fetch(path: string, options?: IFetchOptions): Promise<(string|Uint8Array)>;

    /**
     * Requires a module only if available.
     * @param moduleName Module to require
     * @returns Required module if available and not empty, otherwise `null`
     */
    function inquire(moduleName: string): object;

    /** A minimal path module to resolve Unix, Windows and URL paths alike. */
    namespace path {

        /**
         * Tests if the specified path is absolute.
         * @param path Path to test
         * @returns `true` if path is absolute
         */
        function isAbsolute(path: string): boolean;

        /**
         * Normalizes the specified path.
         * @param path Path to normalize
         * @returns Normalized path
         */
        function normalize(path: string): string;

        /**
         * Resolves the specified include path against the specified origin path.
         * @param originPath Path to the origin file
         * @param includePath Include path relative to origin path
         * @param [alreadyNormalized=false] `true` if both paths are already known to be normalized
         * @returns Path to the include file
         */
        function resolve(originPath: string, includePath: string, alreadyNormalized?: boolean): string;
    }

    /**
     * A general purpose buffer pool.
     * @param alloc Allocator
     * @param slice Slicer
     * @param [size=8192] Slab size
     * @returns Pooled allocator
     */
    function pool(alloc: PoolAllocator, slice: PoolSlicer, size?: number): PoolAllocator;

    /** A minimal UTF8 implementation for number arrays. */
    namespace utf8 {

        /**
         * Calculates the UTF8 byte length of a string.
         * @param string String
         * @returns Byte length
         */
        function length(string: string): number;

        /**
         * Reads UTF8 bytes as a string.
         * @param buffer Source buffer
         * @param start Source start
         * @param end Source end
         * @returns String read
         */
        function read(buffer: Uint8Array, start: number, end: number): string;

        /**
         * Writes a string as UTF8 bytes.
         * @param string Source string
         * @param buffer Destination buffer
         * @param offset Destination offset
         * @returns Bytes written
         */
        function write(string: string, buffer: Uint8Array, offset: number): number;
    }
}

/**
 * Generates a verifier specific to the specified message type.
 * @param mtype Message type
 * @returns Codegen instance
 */
export function verifier(mtype: Type): Codegen;

/** Wrappers for common types. */
export const wrappers: { [k: string]: IWrapper };

/**
 * From object converter part of an {@link IWrapper}.
 * @param object Plain object
 * @returns Message instance
 */
type WrapperFromObjectConverter = (this: Type, object: { [k: string]: any }) => Message<{}>;

/**
 * To object converter part of an {@link IWrapper}.
 * @param message Message instance
 * @param [options] Conversion options
 * @returns Plain object
 */
type WrapperToObjectConverter = (this: Type, message: Message<{}>, options?: IConversionOptions) => { [k: string]: any };

/** Common type wrapper part of {@link wrappers}. */
export interface IWrapper {

    /** From object converter */
    fromObject?: WrapperFromObjectConverter;

    /** To object converter */
    toObject?: WrapperToObjectConverter;
}

/** Wire format writer using `Uint8Array` if available, otherwise `Array`. */
export class Writer {

    /** Constructs a new writer instance. */
    constructor();

    /** Current length. */
    public len: number;

    /** Operations head. */
    public head: object;

    /** Operations tail */
    public tail: object;

    /** Linked forked states. */
    public states: (object|null);

    /**
     * Creates a new writer.
     * @returns A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
     */
    public static create(): (BufferWriter|Writer);

    /**
     * Allocates a buffer of the specified size.
     * @param size Buffer size
     * @returns Buffer
     */
    public static alloc(size: number): Uint8Array;

    /**
     * Writes an unsigned 32 bit value as a varint.
     * @param value Value to write
     * @returns `this`
     */
    public uint32(value: number): Writer;

    /**
     * Writes a signed 32 bit value as a varint.
     * @param value Value to write
     * @returns `this`
     */
    public int32(value: number): Writer;

    /**
     * Writes a 32 bit value as a varint, zig-zag encoded.
     * @param value Value to write
     * @returns `this`
     */
    public sint32(value: number): Writer;

    /**
     * Writes an unsigned 64 bit value as a varint.
     * @param value Value to write
     * @returns `this`
     * @throws {TypeError} If `value` is a string and no long library is present.
     */
    public uint64(value: (Long|number|string)): Writer;

    /**
     * Writes a signed 64 bit value as a varint.
     * @param value Value to write
     * @returns `this`
     * @throws {TypeError} If `value` is a string and no long library is present.
     */
    public int64(value: (Long|number|string)): Writer;

    /**
     * Writes a signed 64 bit value as a varint, zig-zag encoded.
     * @param value Value to write
     * @returns `this`
     * @throws {TypeError} If `value` is a string and no long library is present.
     */
    public sint64(value: (Long|number|string)): Writer;

    /**
     * Writes a boolish value as a varint.
     * @param value Value to write
     * @returns `this`
     */
    public bool(value: boolean): Writer;

    /**
     * Writes an unsigned 32 bit value as fixed 32 bits.
     * @param value Value to write
     * @returns `this`
     */
    public fixed32(value: number): Writer;

    /**
     * Writes a signed 32 bit value as fixed 32 bits.
     * @param value Value to write
     * @returns `this`
     */
    public sfixed32(value: number): Writer;

    /**
     * Writes an unsigned 64 bit value as fixed 64 bits.
     * @param value Value to write
     * @returns `this`
     * @throws {TypeError} If `value` is a string and no long library is present.
     */
    public fixed64(value: (Long|number|string)): Writer;

    /**
     * Writes a signed 64 bit value as fixed 64 bits.
     * @param value Value to write
     * @returns `this`
     * @throws {TypeError} If `value` is a string and no long library is present.
     */
    public sfixed64(value: (Long|number|string)): Writer;

    /**
     * Writes a float (32 bit).
     * @param value Value to write
     * @returns `this`
     */
    public float(value: number): Writer;

    /**
     * Writes a double (64 bit float).
     * @param value Value to write
     * @returns `this`
     */
    public double(value: number): Writer;

    /**
     * Writes a sequence of bytes.
     * @param value Buffer or base64 encoded string to write
     * @returns `this`
     */
    public bytes(value: (Uint8Array|string)): Writer;

    /**
     * Writes a string.
     * @param value Value to write
     * @returns `this`
     */
    public string(value: string): Writer;

    /**
     * Forks this writer's state by pushing it to a stack.
     * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
     * @returns `this`
     */
    public fork(): Writer;

    /**
     * Resets this instance to the last state.
     * @returns `this`
     */
    public reset(): Writer;

    /**
     * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
     * @returns `this`
     */
    public ldelim(): Writer;

    /**
     * Finishes the write operation.
     * @returns Finished buffer
     */
    public finish(): Uint8Array;
}

/** Wire format writer using node buffers. */
export class BufferWriter extends Writer {

    /** Constructs a new buffer writer instance. */
    constructor();

    /**
     * Allocates a buffer of the specified size.
     * @param size Buffer size
     * @returns Buffer
     */
    public static alloc(size: number): Buffer;

    /**
     * Finishes the write operation.
     * @returns Finished buffer
     */
    public finish(): Buffer;
}

/**
 * Callback as used by {@link util.asPromise}.
 * @param error Error, if any
 * @param params Additional arguments
 */
type asPromiseCallback = (error: (Error|null), ...params: any[]) => void;

/**
 * Appends code to the function's body or finishes generation.
 * @param [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
 * @param [formatParams] Format parameters
 * @returns Itself or the generated function if finished
 * @throws {Error} If format parameter counts do not match
 */
type Codegen = (formatStringOrScope?: (string|{ [k: string]: any }), ...formatParams: any[]) => (Codegen|Function);

/**
 * Event listener as used by {@link util.EventEmitter}.
 * @param args Arguments
 */
type EventEmitterListener = (...args: any[]) => void;

/**
 * Node-style callback as used by {@link util.fetch}.
 * @param error Error, if any, otherwise `null`
 * @param [contents] File contents, if there hasn't been an error
 */
type FetchCallback = (error: Error, contents?: string) => void;

/** Options as used by {@link util.fetch}. */
export interface IFetchOptions {

    /** Whether expecting a binary response */
    binary?: boolean;

    /** If `true`, forces the use of XMLHttpRequest */
    xhr?: boolean;
}

/**
 * An allocator as used by {@link util.pool}.
 * @param size Buffer size
 * @returns Buffer
 */
type PoolAllocator = (size: number) => Uint8Array;

/**
 * A slicer as used by {@link util.pool}.
 * @param start Start offset
 * @param end End offset
 * @returns Buffer slice
 */
type PoolSlicer = (this: Uint8Array, start: number, end: number) => Uint8Array;
// full library entry point.

"use strict";
module.exports = require("./src/index");
This license applies to all parts of protobuf.js except those files
either explicitly including or referencing a different license or
located in a directory containing a different LICENSE file.

---

Copyright (c) 2016, Daniel Wirtz  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.
* Neither the name of its author, nor the names of its contributors
  may be used to endorse or promote products derived from this software
  without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

---

Code generated by the command line utilities is owned by the owner
of the input file used when generating it. This code is not
standalone and requires a support library to be linked with it. This
support library is itself covered by the above license.
export as namespace protobuf;
export * from "./index";
// light library entry point.

"use strict";
module.exports = require("./src/index-light");export as namespace protobuf;
export * from "./index";
// minimal library entry point.

"use strict";
module.exports = require("./src/index-minimal");
{
  "name": "@postman/protobufjs",
  "version": "7.3.2-postman.3",
  "versionScheme": "~",
  "description": "Protocol Buffers for JavaScript (& TypeScript).",
  "license": "Apache-2.0",
  "repository": "https://github.com/postmanlabs/protobuf.js",
  "bugs": "https://github.com/postmanlabs/protobuf.js/issues",
  "homepage": "https://github.com/postmanlabs/protobuf.js",
  "engines": {
    "node": ">=12.0.0"
  },
  "eslintConfig": {
    "env": {
      "es6": true
    },
    "parserOptions": {
      "ecmaVersion": 6
    }
  },
  "keywords": [
    "protobuf",
    "protocol-buffers",
    "serialization",
    "typescript"
  ],
  "main": "index.js",
  "types": "index.d.ts",
  "scripts": {
    "bench": "node bench",
    "build": "npm run build:bundle && npm run build:types",
    "build:bundle": "gulp --gulpfile scripts/gulpfile.js",
    "build:types": "node cli/bin/pbts --main --global protobuf --out index.d.ts src/ lib/aspromise/index.js lib/base64/index.js lib/codegen/index.js lib/eventemitter/index.js lib/float/index.js lib/fetch/index.js lib/inquire/index.js lib/path/index.js lib/pool/index.js lib/utf8/index.js",
    "changelog": "node scripts/changelog -w",
    "coverage": "nyc tape -r ./lib/tape-adapter tests/*.js tests/node/*.js",
    "docs": "jsdoc -c config/jsdoc.json -R README.md --verbose --pedantic",
    "lint": "npm run lint:sources && npm run lint:types",
    "lint:sources": "eslint \"**/*.js\" -c config/eslint.json",
    "lint:types": "tslint \"**/*.d.ts\" -e \"**/node_modules/**\" -t stylish -c config/tslint.json",
    "pages": "node scripts/pages",
    "prepublish": "cd cli && npm install && cd .. && npm run build",
    "postinstall": "node scripts/postinstall",
    "prof": "node bench/prof",
    "test": "npm run test:sources && npm run test:types",
    "test:sources": "tape -r ./lib/tape-adapter tests/*.js tests/node/*.js",
    "test:types": "tsc tests/comp_typescript.ts --lib es2015 --esModuleInterop --strictNullChecks --experimentalDecorators --emitDecoratorMetadata && tsc tests/data/test.js.ts --lib es2015 --esModuleInterop --noEmit --strictNullChecks && tsc tests/data/*.ts --lib es2015 --esModuleInterop --noEmit --strictNullChecks",
    "make": "npm run lint:sources && npm run build && npm run lint:types && node ./scripts/gentests.js && npm test"
  },
  "dependencies": {
    "@protobufjs/aspromise": "^1.1.2",
    "@protobufjs/base64": "^1.1.2",
    "@protobufjs/codegen": "^2.0.4",
    "@protobufjs/eventemitter": "^1.1.0",
    "@protobufjs/fetch": "^1.1.0",
    "@protobufjs/float": "^1.0.2",
    "@protobufjs/inquire": "^1.1.0",
    "@protobufjs/path": "^1.1.2",
    "@protobufjs/pool": "^1.1.0",
    "@protobufjs/utf8": "^1.1.0",
    "@types/node": ">=13.7.0",
    "long": "^5.0.0"
  },
  "devDependencies": {
    "benchmark": "^2.1.4",
    "browserify": "^17.0.0",
    "browserify-wrap": "^1.0.2",
    "bundle-collapser": "^1.3.0",
    "chalk": "^4.0.0",
    "escodegen": "^1.13.0",
    "eslint": "^8.15.0",
    "espree": "^9.0.0",
    "estraverse": "^5.1.0",
    "gh-pages": "^4.0.0",
    "git-raw-commits": "^2.0.3",
    "git-semver-tags": "^4.0.0",
    "google-protobuf": "^3.11.3",
    "gulp": "^4.0.2",
    "gulp-header": "^2.0.9",
    "gulp-if": "^3.0.0",
    "gulp-sourcemaps": "^3.0.0",
    "gulp-uglify": "^3.0.2",
    "jaguarjs-jsdoc": "github:dcodeIO/jaguarjs-jsdoc",
    "jsdoc": "^4.0.0",
    "minimist": "^1.2.0",
    "nyc": "^15.0.0",
    "reflect-metadata": "^0.1.13",
    "tape": "^5.0.0",
    "tslint": "^6.0.0",
    "typescript": "^3.7.5",
    "uglify-js": "^3.7.7",
    "vinyl-buffer": "^1.0.1",
    "vinyl-fs": "^3.0.3",
    "vinyl-source-stream": "^2.0.0"
  },
  "files": [
    "index.js",
    "index.d.ts",
    "light.d.ts",
    "light.js",
    "minimal.d.ts",
    "minimal.js",
    "package-lock.json",
    "tsconfig.json",
    "scripts/postinstall.js",
    "dist/**",
    "ext/**",
    "google/**",
    "src/**"
  ]
}
<h1><p align="center"><img alt="protobuf.js" src="https://github.com/protobufjs/protobuf.js/raw/master/pbjs.svg" height="100" /><br/>protobuf.js</p></h1>
<p align="center">
  <a href="https://github.com/protobufjs/protobuf.js/actions/workflows/test.yml"><img src="https://img.shields.io/github/actions/workflow/status/protobufjs/protobuf.js/test.yml?branch=master&label=build&logo=github" alt=""></a>
  <a href="https://github.com/protobufjs/protobuf.js/actions/workflows/release.yaml"><img src="https://img.shields.io/github/actions/workflow/status/protobufjs/protobuf.js/release.yaml?branch=master&label=release&logo=github" alt=""></a>
  <a href="https://npmjs.org/package/protobufjs"><img src="https://img.shields.io/npm/v/protobufjs.svg?logo=npm" alt=""></a>
  <a href="https://npmjs.org/package/protobufjs"><img src="https://img.shields.io/npm/dm/protobufjs.svg?label=downloads&logo=npm" alt=""></a>
  <a href="https://www.jsdelivr.com/package/npm/protobufjs"><img src="https://img.shields.io/jsdelivr/npm/hm/protobufjs?label=requests&logo=jsdelivr" alt=""></a>
</p>

**Protocol Buffers** are a language-neutral, platform-neutral, extensible way of serializing structured data for use in communications protocols, data storage, and more, originally designed at Google ([see](https://protobuf.dev/)).

**protobuf.js** is a pure JavaScript implementation with [TypeScript](https://www.typescriptlang.org) support for [Node.js](https://nodejs.org) and the browser. It's easy to use, does not sacrifice on performance, has good conformance and works out of the box with [.proto](https://protobuf.dev/programming-guides/proto3/) files!

Contents
--------

* [Installation](#installation)<br />
  How to include protobuf.js in your project.

* [Usage](#usage)<br />
  A brief introduction to using the toolset.

  * [Valid Message](#valid-message)
  * [Toolset](#toolset)<br />

* [Examples](#examples)<br />
  A few examples to get you started.

  * [Using .proto files](#using-proto-files)
  * [Using JSON descriptors](#using-json-descriptors)
  * [Using reflection only](#using-reflection-only)
  * [Using custom classes](#using-custom-classes)
  * [Using services](#using-services)
  * [Usage with TypeScript](#usage-with-typescript)<br />

* [Additional documentation](#additional-documentation)<br />
  A list of available documentation resources.

* [Performance](#performance)<br />
  A few internals and a benchmark on performance.

* [Compatibility](#compatibility)<br />
  Notes on compatibility regarding browsers and optional libraries.

* [Building](#building)<br />
  How to build the library and its components yourself.

Installation
---------------

### Node.js

```sh
npm install protobufjs --save
```

```js
// Static code + Reflection + .proto parser
var protobuf = require("protobufjs");

// Static code + Reflection
var protobuf = require("protobufjs/light");

// Static code only
var protobuf = require("protobufjs/minimal");
```

The optional [command line utility](./cli/) to generate static code and reflection bundles lives in the `protobufjs-cli` package and can be installed separately:

```sh
npm install protobufjs-cli --save-dev
```

### Browsers

Pick the variant matching your needs and replace the version tag with the exact [release](https://github.com/protobufjs/protobuf.js/tags) your project depends upon. For example, to use the minified full variant:

```html
<script src="//cdn.jsdelivr.net/npm/protobufjs@7.X.X/dist/protobuf.min.js"></script>
```

| Distribution | Location
|--------------|--------------------------------------------------------
| Full         | <https://cdn.jsdelivr.net/npm/protobufjs/dist/>
| Light        | <https://cdn.jsdelivr.net/npm/protobufjs/dist/light/>
| Minimal      | <https://cdn.jsdelivr.net/npm/protobufjs/dist/minimal/>

All variants support CommonJS and AMD loaders and export globally as `window.protobuf`.

Usage
-----

Because JavaScript is a dynamically typed language, protobuf.js utilizes the concept of a **valid message** in order to provide the best possible [performance](#performance) (and, as a side product, proper typings):

### Valid message

> A valid message is an object (1) not missing any required fields and (2) exclusively composed of JS types understood by the wire format writer.

There are two possible types of valid messages and the encoder is able to work with both of these for convenience:

* **Message instances** (explicit instances of message classes with default values on their prototype) naturally satisfy the requirements of a valid message and
* **Plain JavaScript objects** that just so happen to be composed in a way satisfying the requirements of a valid message as well.

In a nutshell, the wire format writer understands the following types:

| Field type | Expected JS type (create, encode) | Conversion (fromObject)
|------------|-----------------------------------|------------------------
| s-/u-/int32<br />s-/fixed32 | `number` (32 bit integer) | <code>value &#124; 0</code> if signed<br />`value >>> 0` if unsigned
| s-/u-/int64<br />s-/fixed64 | `Long`-like (optimal)<br />`number` (53 bit integer) | `Long.fromValue(value)` with long.js<br />`parseInt(value, 10)` otherwise
| float<br />double | `number` | `Number(value)`
| bool | `boolean` | `Boolean(value)`
| string | `string` | `String(value)`
| bytes | `Uint8Array` (optimal)<br />`Buffer` (optimal under node)<br />`Array.<number>` (8 bit integers) | `base64.decode(value)` if a `string`<br />`Object` with non-zero `.length` is assumed to be buffer-like
| enum | `number` (32 bit integer) | Looks up the numeric id if a `string`
| message | Valid message | `Message.fromObject(value)`
| repeated T | `Array<T>` | Copy
| map<K, V> | `Object<K,V>` | Copy

* Explicit `undefined` and `null` are considered as not set if the field is optional.
* Maps are objects where the key is the string representation of the respective value or an 8 characters long hash string for `Long`-likes.

### Toolset

With that in mind and again for performance reasons, each message class provides a distinct set of methods with each method doing just one thing. This avoids unnecessary assertions / redundant operations where performance is a concern but also forces a user to perform verification (of plain JavaScript objects that *might* just so happen to be a valid message) explicitly where necessary - for example when dealing with user input.

**Note** that `Message` below refers to any message class.

* **Message.verify**(message: `Object`): `null|string`<br />
  verifies that a **plain JavaScript object** satisfies the requirements of a valid message and thus can be encoded without issues. Instead of throwing, it returns the error message as a string, if any.

  ```js
  var payload = "invalid (not an object)";
  var err = AwesomeMessage.verify(payload);
  if (err)
    throw Error(err);
  ```

* **Message.encode**(message: `Message|Object` [, writer: `Writer`]): `Writer`<br />
  encodes a **message instance** or valid **plain JavaScript object**. This method does not implicitly verify the message and it's up to the user to make sure that the payload is a valid message.

  ```js
  var buffer = AwesomeMessage.encode(message).finish();
  ```

* **Message.encodeDelimited**(message: `Message|Object` [, writer: `Writer`]): `Writer`<br />
  works like `Message.encode` but additionally prepends the length of the message as a varint.

* **Message.decode**(reader: `Reader|Uint8Array`): `Message`<br />
  decodes a buffer to a **message instance**. If required fields are missing, it throws a `util.ProtocolError` with an `instance` property set to the so far decoded message. If the wire format is invalid, it throws an `Error`.

  ```js
  try {
    var decodedMessage = AwesomeMessage.decode(buffer);
  } catch (e) {
      if (e instanceof protobuf.util.ProtocolError) {
        // e.instance holds the so far decoded message with missing required fields
      } else {
        // wire format is invalid
      }
  }
  ```

* **Message.decodeDelimited**(reader: `Reader|Uint8Array`): `Message`<br />
  works like `Message.decode` but additionally reads the length of the message prepended as a varint.

* **Message.create**(properties: `Object`): `Message`<br />
  creates a new **message instance** from a set of properties that satisfy the requirements of a valid message. Where applicable, it is recommended to prefer `Message.create` over `Message.fromObject` because it doesn't perform possibly redundant conversion.

  ```js
  var message = AwesomeMessage.create({ awesomeField: "AwesomeString" });
  ```

* **Message.fromObject**(object: `Object`): `Message`<br />
  converts any non-valid **plain JavaScript object** to a **message instance** using the conversion steps outlined within the table above.

  ```js
  var message = AwesomeMessage.fromObject({ awesomeField: 42 });
  // converts awesomeField to a string
  ```

* **Message.toObject**(message: `Message` [, options: `ConversionOptions`]): `Object`<br />
  converts a **message instance** to an arbitrary **plain JavaScript object** for interoperability with other libraries or storage. The resulting plain JavaScript object *might* still satisfy the requirements of a valid message depending on the actual conversion options specified, but most of the time it does not.

  ```js
  var object = AwesomeMessage.toObject(message, {
    enums: String,  // enums as string names
    longs: String,  // longs as strings (requires long.js)
    bytes: String,  // bytes as base64 encoded strings
    defaults: true, // includes default values
    arrays: true,   // populates empty arrays (repeated fields) even if defaults=false
    objects: true,  // populates empty objects (map fields) even if defaults=false
    oneofs: true    // includes virtual oneof fields set to the present field's name
  });
  ```

For reference, the following diagram aims to display relationships between the different methods and the concept of a valid message:

<p align="center"><img alt="Toolset Diagram" src="https://protobufjs.github.io/protobuf.js/toolset.svg" /></p>

> In other words: `verify` indicates that calling `create` or `encode` directly on the plain object will [result in a valid message respectively] succeed. `fromObject`, on the other hand, does conversion from a broader range of plain objects to create valid messages. ([ref](https://github.com/protobufjs/protobuf.js/issues/748#issuecomment-291925749))

Examples
--------

### Using .proto files

It is possible to load existing .proto files using the full library, which parses and compiles the definitions to ready to use (reflection-based) message classes:

```protobuf
// awesome.proto
package awesomepackage;
syntax = "proto3";

message AwesomeMessage {
    string awesome_field = 1; // becomes awesomeField
}
```

```js
protobuf.load("awesome.proto", function(err, root) {
    if (err)
        throw err;

    // Obtain a message type
    var AwesomeMessage = root.lookupType("awesomepackage.AwesomeMessage");

    // Exemplary payload
    var payload = { awesomeField: "AwesomeString" };

    // Verify the payload if necessary (i.e. when possibly incomplete or invalid)
    var errMsg = AwesomeMessage.verify(payload);
    if (errMsg)
        throw Error(errMsg);

    // Create a new message
    var message = AwesomeMessage.create(payload); // or use .fromObject if conversion is necessary

    // Encode a message to an Uint8Array (browser) or Buffer (node)
    var buffer = AwesomeMessage.encode(message).finish();
    // ... do something with buffer

    // Decode an Uint8Array (browser) or Buffer (node) to a message
    var message = AwesomeMessage.decode(buffer);
    // ... do something with message

    // If the application uses length-delimited buffers, there is also encodeDelimited and decodeDelimited.

    // Maybe convert the message back to a plain object
    var object = AwesomeMessage.toObject(message, {
        longs: String,
        enums: String,
        bytes: String,
        // see ConversionOptions
    });
});
```

Additionally, promise syntax can be used by omitting the callback, if preferred:

```js
protobuf.load("awesome.proto")
    .then(function(root) {
       ...
    });
```

### Using JSON descriptors

The library utilizes JSON descriptors that are equivalent to a .proto definition. For example, the following is identical to the .proto definition seen above:

```json
// awesome.json
{
  "nested": {
    "awesomepackage": {
      "nested": {
        "AwesomeMessage": {
          "fields": {
            "awesomeField": {
              "type": "string",
              "id": 1
            }
          }
        }
      }
    }
  }
}
```

JSON descriptors closely resemble the internal reflection structure:

| Type (T)           | Extends            | Type-specific properties
|--------------------|--------------------|-------------------------
| *ReflectionObject* |                    | options
| *Namespace*        | *ReflectionObject* | nested
| Root               | *Namespace*        | **nested**
| Type               | *Namespace*        | **fields**
| Enum               | *ReflectionObject* | **values**
| Field              | *ReflectionObject* | rule, **type**, **id**
| MapField           | Field              | **keyType**
| OneOf              | *ReflectionObject* | **oneof** (array of field names)
| Service            | *Namespace*        | **methods**
| Method             | *ReflectionObject* | type, **requestType**, **responseType**, requestStream, responseStream

* **Bold properties** are required. *Italic types* are abstract.
* `T.fromJSON(name, json)` creates the respective reflection object from a JSON descriptor
* `T#toJSON()` creates a JSON descriptor from the respective reflection object (its name is used as the key within the parent)

Exclusively using JSON descriptors instead of .proto files enables the use of just the light library (the parser isn't required in this case).

A JSON descriptor can either be loaded the usual way:

```js
protobuf.load("awesome.json", function(err, root) {
    if (err) throw err;

    // Continue at "Obtain a message type" above
});
```

Or it can be loaded inline:

```js
var jsonDescriptor = require("./awesome.json"); // exemplary for node

var root = protobuf.Root.fromJSON(jsonDescriptor);

// Continue at "Obtain a message type" above
```

### Using reflection only

Both the full and the light library include full reflection support. One could, for example, define the .proto definitions seen in the examples above using just reflection:

```js
...
var Root  = protobuf.Root,
    Type  = protobuf.Type,
    Field = protobuf.Field;

var AwesomeMessage = new Type("AwesomeMessage").add(new Field("awesomeField", 1, "string"));

var root = new Root().define("awesomepackage").add(AwesomeMessage);

// Continue at "Create a new message" above
...
```

Detailed information on the reflection structure is available within the [API documentation](#additional-documentation).

### Using custom classes

Message classes can also be extended with custom functionality and it is also possible to register a custom constructor with a reflected message type:

```js
...

// Define a custom constructor
function AwesomeMessage(properties) {
    // custom initialization code
    ...
}

// Register the custom constructor with its reflected type (*)
root.lookupType("awesomepackage.AwesomeMessage").ctor = AwesomeMessage;

// Define custom functionality
AwesomeMessage.customStaticMethod = function() { ... };
AwesomeMessage.prototype.customInstanceMethod = function() { ... };

// Continue at "Create a new message" above
```

(*) Besides referencing its reflected type through `AwesomeMessage.$type` and `AwesomeMesage#$type`, the respective custom class is automatically populated with:

* `AwesomeMessage.create`
* `AwesomeMessage.encode` and `AwesomeMessage.encodeDelimited`
* `AwesomeMessage.decode` and `AwesomeMessage.decodeDelimited`
* `AwesomeMessage.verify`
* `AwesomeMessage.fromObject`, `AwesomeMessage.toObject` and `AwesomeMessage#toJSON`

Afterwards, decoded messages of this type are `instanceof AwesomeMessage`.

Alternatively, it is also possible to reuse and extend the internal constructor if custom initialization code is not required:

```js
...

// Reuse the internal constructor
var AwesomeMessage = root.lookupType("awesomepackage.AwesomeMessage").ctor;

// Define custom functionality
AwesomeMessage.customStaticMethod = function() { ... };
AwesomeMessage.prototype.customInstanceMethod = function() { ... };

// Continue at "Create a new message" above
```

### Using services

The library also supports consuming services but it doesn't make any assumptions about the actual transport channel. Instead, a user must provide a suitable RPC implementation, which is an asynchronous function that takes the reflected service method, the binary request and a node-style callback as its parameters:

```js
function rpcImpl(method, requestData, callback) {
    // perform the request using an HTTP request or a WebSocket for example
    var responseData = ...;
    // and call the callback with the binary response afterwards:
    callback(null, responseData);
}
```

Below is a working example with a typescript implementation using grpc npm package.
```ts
const grpc = require('grpc')

const Client = grpc.makeGenericClientConstructor({})
const client = new Client(
  grpcServerUrl,
  grpc.credentials.createInsecure()
)

const rpcImpl = function(method, requestData, callback) {
  client.makeUnaryRequest(
    method.name,
    arg => arg,
    arg => arg,
    requestData,
    callback
  )
}
```

Example:

```protobuf
// greeter.proto
syntax = "proto3";

service Greeter {
    rpc SayHello (HelloRequest) returns (HelloReply) {}
}

message HelloRequest {
    string name = 1;
}

message HelloReply {
    string message = 1;
}
```

```js
...
var Greeter = root.lookup("Greeter");
var greeter = Greeter.create(/* see above */ rpcImpl, /* request delimited? */ false, /* response delimited? */ false);

greeter.sayHello({ name: 'you' }, function(err, response) {
    console.log('Greeting:', response.message);
});
```

Services also support promises:

```js
greeter.sayHello({ name: 'you' })
    .then(function(response) {
        console.log('Greeting:', response.message);
    });
```

There is also an [example for streaming RPC](https://github.com/protobufjs/protobuf.js/blob/master/examples/streaming-rpc.js).

Note that the service API is meant for clients. Implementing a server-side endpoint pretty much always requires transport channel (i.e. http, websocket, etc.) specific code with the only common denominator being that it decodes and encodes messages.

### Usage with TypeScript

The library ships with its own [type definitions](https://github.com/protobufjs/protobuf.js/blob/master/index.d.ts) and modern editors like [Visual Studio Code](https://code.visualstudio.com/) will automatically detect and use them for code completion.

The npm package depends on [@types/node](https://www.npmjs.com/package/@types/node) because of `Buffer` and [@types/long](https://www.npmjs.com/package/@types/long) because of `Long`. If you are not building for node and/or not using long.js, it should be safe to exclude them manually.

#### Using the JS API

The API shown above works pretty much the same with TypeScript. However, because everything is typed, accessing fields on instances of dynamically generated message classes requires either using bracket-notation (i.e. `message["awesomeField"]`) or explicit casts. Alternatively, it is possible to use a [typings file generated for its static counterpart](#pbts-for-typescript).

```ts
import { load } from "protobufjs"; // respectively "./node_modules/protobufjs"

load("awesome.proto", function(err, root) {
  if (err)
    throw err;

  // example code
  const AwesomeMessage = root.lookupType("awesomepackage.AwesomeMessage");

  let message = AwesomeMessage.create({ awesomeField: "hello" });
  console.log(`message = ${JSON.stringify(message)}`);

  let buffer = AwesomeMessage.encode(message).finish();
  console.log(`buffer = ${Array.prototype.toString.call(buffer)}`);

  let decoded = AwesomeMessage.decode(buffer);
  console.log(`decoded = ${JSON.stringify(decoded)}`);
});
```

#### Using generated static code

If you generated static code to `bundle.js` using the CLI and its type definitions to `bundle.d.ts`, then you can just do:

```ts
import { AwesomeMessage } from "./bundle.js";

// example code
let message = AwesomeMessage.create({ awesomeField: "hello" });
let buffer  = AwesomeMessage.encode(message).finish();
let decoded = AwesomeMessage.decode(buffer);
```

#### Using decorators

The library also includes an early implementation of [decorators](https://www.typescriptlang.org/docs/handbook/decorators.html).

**Note** that decorators are an experimental feature in TypeScript and that declaration order is important depending on the JS target. For example, `@Field.d(2, AwesomeArrayMessage)` requires that `AwesomeArrayMessage` has been defined earlier when targeting `ES5`.

```ts
import { Message, Type, Field, OneOf } from "protobufjs/light"; // respectively "./node_modules/protobufjs/light.js"

export class AwesomeSubMessage extends Message<AwesomeSubMessage> {

  @Field.d(1, "string")
  public awesomeString: string;

}

export enum AwesomeEnum {
  ONE = 1,
  TWO = 2
}

@Type.d("SuperAwesomeMessage")
export class AwesomeMessage extends Message<AwesomeMessage> {

  @Field.d(1, "string", "optional", "awesome default string")
  public awesomeField: string;

  @Field.d(2, AwesomeSubMessage)
  public awesomeSubMessage: AwesomeSubMessage;

  @Field.d(3, AwesomeEnum, "optional", AwesomeEnum.ONE)
  public awesomeEnum: AwesomeEnum;

  @OneOf.d("awesomeSubMessage", "awesomeEnum")
  public which: string;

}

// example code
let message = new AwesomeMessage({ awesomeField: "hello" });
let buffer  = AwesomeMessage.encode(message).finish();
let decoded = AwesomeMessage.decode(buffer);
```

Supported decorators are:

* **Type.d(typeName?: `string`)** &nbsp; *(optional)*<br />
  annotates a class as a protobuf message type. If `typeName` is not specified, the constructor's runtime function name is used for the reflected type.

* **Field.d&lt;T>(fieldId: `number`, fieldType: `string | Constructor<T>`, fieldRule?: `"optional" | "required" | "repeated"`, defaultValue?: `T`)**<br />
  annotates a property as a protobuf field with the specified id and protobuf type.

* **MapField.d&lt;T extends { [key: string]: any }>(fieldId: `number`, fieldKeyType: `string`, fieldValueType. `string | Constructor<{}>`)**<br />
  annotates a property as a protobuf map field with the specified id, protobuf key and value type.

* **OneOf.d&lt;T extends string>(...fieldNames: `string[]`)**<br />
  annotates a property as a protobuf oneof covering the specified fields.

Other notes:

* Decorated types reside in `protobuf.roots["decorated"]` using a flat structure, so no duplicate names.
* Enums are copied to a reflected enum with a generic name on decorator evaluation because referenced enum objects have no runtime name the decorator could use.
* Default values must be specified as arguments to the decorator instead of using a property initializer for proper prototype behavior.
* Property names on decorated classes must not be renamed on compile time (i.e. by a minifier) because decorators just receive the original field name as a string.

**ProTip!** Not as pretty, but you can [use decorators in plain JavaScript](https://github.com/protobufjs/protobuf.js/blob/master/examples/js-decorators.js) as well.

Additional documentation
------------------------

#### Protocol Buffers
* [Google's Developer Guide](https://protobuf.dev/overview/)

#### protobuf.js
* [API Documentation](https://protobufjs.github.io/protobuf.js)
* [CHANGELOG](https://github.com/protobufjs/protobuf.js/blob/master/CHANGELOG.md)
* [Frequently asked questions](https://github.com/protobufjs/protobuf.js/wiki) on our wiki

#### Community
* [Questions and answers](http://stackoverflow.com/search?tab=newest&q=protobuf.js) on StackOverflow

Performance
-----------
The package includes a benchmark that compares protobuf.js performance to native JSON (as far as this is possible) and [Google's JS implementation](https://github.com/google/protobuf/tree/master/js). On an i7-2600K running node 6.9.1 it yields:

```
benchmarking encoding performance ...

protobuf.js (reflect) x 541,707 ops/sec 1.13% (87 runs sampled)
protobuf.js (static) x 548,134 ops/sec 1.38% (89 runs sampled)
JSON (string) x 318,076 ops/sec 0.63% (93 runs sampled)
JSON (buffer) x 179,165 ops/sec 2.26% (91 runs sampled)
google-protobuf x 74,406 ops/sec 0.85% (86 runs sampled)

   protobuf.js (static) was fastest
  protobuf.js (reflect) was 0.9% ops/sec slower (factor 1.0)
          JSON (string) was 41.5% ops/sec slower (factor 1.7)
          JSON (buffer) was 67.6% ops/sec slower (factor 3.1)
        google-protobuf was 86.4% ops/sec slower (factor 7.3)

benchmarking decoding performance ...

protobuf.js (reflect) x 1,383,981 ops/sec 0.88% (93 runs sampled)
protobuf.js (static) x 1,378,925 ops/sec 0.81% (93 runs sampled)
JSON (string) x 302,444 ops/sec 0.81% (93 runs sampled)
JSON (buffer) x 264,882 ops/sec 0.81% (93 runs sampled)
google-protobuf x 179,180 ops/sec 0.64% (94 runs sampled)

  protobuf.js (reflect) was fastest
   protobuf.js (static) was 0.3% ops/sec slower (factor 1.0)
          JSON (string) was 78.1% ops/sec slower (factor 4.6)
          JSON (buffer) was 80.8% ops/sec slower (factor 5.2)
        google-protobuf was 87.0% ops/sec slower (factor 7.7)

benchmarking combined performance ...

protobuf.js (reflect) x 275,900 ops/sec 0.78% (90 runs sampled)
protobuf.js (static) x 290,096 ops/sec 0.96% (90 runs sampled)
JSON (string) x 129,381 ops/sec 0.77% (90 runs sampled)
JSON (buffer) x 91,051 ops/sec 0.94% (90 runs sampled)
google-protobuf x 42,050 ops/sec 0.85% (91 runs sampled)

   protobuf.js (static) was fastest
  protobuf.js (reflect) was 4.7% ops/sec slower (factor 1.0)
          JSON (string) was 55.3% ops/sec slower (factor 2.2)
          JSON (buffer) was 68.6% ops/sec slower (factor 3.2)
        google-protobuf was 85.5% ops/sec slower (factor 6.9)
```

These results are achieved by

* generating type-specific encoders, decoders, verifiers and converters at runtime
* configuring the reader/writer interface according to the environment
* using node-specific functionality where beneficial and, of course
* avoiding unnecessary operations through splitting up [the toolset](#toolset).

You can also run [the benchmark](https://github.com/protobufjs/protobuf.js/blob/master/bench/index.js) ...

```
$> npm run bench
```

and [the profiler](https://github.com/protobufjs/protobuf.js/blob/master/bench/prof.js) yourself (the latter requires a recent version of node):

```
$> npm run prof <encode|decode|encode-browser|decode-browser> [iterations=10000000]
```

Note that as of this writing, the benchmark suite performs significantly slower on node 7.2.0 compared to 6.9.1 because moths.

Compatibility
-------------

* Works in all modern and not-so-modern browsers except IE8.
* Because the internals of this package do not rely on `google/protobuf/descriptor.proto`, options are parsed and presented literally.
* If typed arrays are not supported by the environment, plain arrays will be used instead.
* Support for pre-ES5 environments (except IE8) can be achieved by [using a polyfill](https://github.com/protobufjs/protobuf.js/blob/master/lib/polyfill.js).
* Support for [Content Security Policy](https://w3c.github.io/webappsec-csp/)-restricted environments (like Chrome extensions without unsafe-eval) can be achieved by generating and using static code instead.
* If a proper way to work with 64 bit values (uint64, int64 etc.) is required, just install [long.js](https://github.com/dcodeIO/long.js) alongside this library. All 64 bit numbers will then be returned as a `Long` instance instead of a possibly unsafe JavaScript number ([see](https://github.com/dcodeIO/long.js)).
* For descriptor.proto interoperability, see [ext/descriptor](https://github.com/protobufjs/protobuf.js/tree/master/ext/descriptor)

Building
--------

To build the library or its components yourself, clone it from GitHub and install the development dependencies:

```
$> git clone https://github.com/protobufjs/protobuf.js.git
$> cd protobuf.js
$> npm install
```

Building the respective development and production versions with their respective source maps to `dist/`:

```
$> npm run build
```

Building the documentation to `docs/`:

```
$> npm run docs
```

Building the TypeScript definition to `index.d.ts`:

```
$> npm run build:types
```

### Browserify integration

By default, protobuf.js integrates into any browserify build-process without requiring any optional modules. Hence:

* If int64 support is required, explicitly require the `long` module somewhere in your project as it will be excluded otherwise. This assumes that a global `require` function is present that protobuf.js can call to obtain the long module.

  If there is no global `require` function present after bundling, it's also possible to assign the long module programmatically:

  ```js
  var Long = ...;

  protobuf.util.Long = Long;
  protobuf.configure();
  ```

* If you have any special requirements, there is [the bundler](https://github.com/protobufjs/protobuf.js/blob/master/scripts/bundle.js) for reference.

**License:** [BSD 3-Clause License](https://opensource.org/licenses/BSD-3-Clause)
"use strict";

var path = require("path"),
    fs   = require("fs"),
    pkg  = require(path.join(__dirname, "..", "package.json"));

// check version scheme used by dependents
if (!pkg.versionScheme)
    return;

var warn = process.stderr.isTTY
    ? "\x1b[30m\x1b[43mWARN\x1b[0m \x1b[35m" + path.basename(process.argv[1], ".js") + "\x1b[0m"
    : "WARN " + path.basename(process.argv[1], ".js");

var basePkg;
try {
    basePkg = JSON.parse(fs.readFileSync(path.join(__dirname, "..", "..", "package.json")));
} catch (e) {
    return;
}

[
    "dependencies",
    "devDependencies",
    "optionalDependencies",
    "peerDependencies"
]
.forEach(function(check) {
    var version = basePkg && basePkg[check] && basePkg[check][pkg.name];
    if (typeof version === "string" && version.charAt(0) !== pkg.versionScheme)
        process.stderr.write(pkg.name + " " + warn + " " + pkg.name + "@" + version + " is configured as a dependency of " + basePkg.name + ". use " + pkg.name + "@" + pkg.versionScheme + version.substring(1) + " instead for API compatibility.\n");
});
"use strict";
module.exports = common;

var commonRe = /\/|\./;

/**
 * Provides common type definitions.
 * Can also be used to provide additional google types or your own custom types.
 * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name
 * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition
 * @returns {undefined}
 * @property {INamespace} google/protobuf/any.proto Any
 * @property {INamespace} google/protobuf/duration.proto Duration
 * @property {INamespace} google/protobuf/empty.proto Empty
 * @property {INamespace} google/protobuf/field_mask.proto FieldMask
 * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue
 * @property {INamespace} google/protobuf/timestamp.proto Timestamp
 * @property {INamespace} google/protobuf/wrappers.proto Wrappers
 * @example
 * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)
 * protobuf.common("descriptor", descriptorJson);
 *
 * // manually provides a custom definition (uses my.foo namespace)
 * protobuf.common("my/foo/bar.proto", myFooBarJson);
 */
function common(name, json) {
    if (!commonRe.test(name)) {
        name = "google/protobuf/" + name + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
    }
    common[name] = json;
}

// Not provided because of limited use (feel free to discuss or to provide yourself):
//
// google/protobuf/descriptor.proto
// google/protobuf/source_context.proto
// google/protobuf/type.proto
//
// Stripped and pre-parsed versions of these non-bundled files are instead available as part of
// the repository or package within the google/protobuf directory.

common("any", {

    /**
     * Properties of a google.protobuf.Any message.
     * @interface IAny
     * @type {Object}
     * @property {string} [typeUrl]
     * @property {Uint8Array} [bytes]
     * @memberof common
     */
    Any: {
        fields: {
            type_url: {
                type: "string",
                id: 1
            },
            value: {
                type: "bytes",
                id: 2
            }
        }
    }
});

var timeType;

common("duration", {

    /**
     * Properties of a google.protobuf.Duration message.
     * @interface IDuration
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Duration: timeType = {
        fields: {
            seconds: {
                type: "int64",
                id: 1
            },
            nanos: {
                type: "int32",
                id: 2
            }
        }
    }
});

common("timestamp", {

    /**
     * Properties of a google.protobuf.Timestamp message.
     * @interface ITimestamp
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Timestamp: timeType
});

common("empty", {

    /**
     * Properties of a google.protobuf.Empty message.
     * @interface IEmpty
     * @memberof common
     */
    Empty: {
        fields: {}
    }
});

common("struct", {

    /**
     * Properties of a google.protobuf.Struct message.
     * @interface IStruct
     * @type {Object}
     * @property {Object.<string,IValue>} [fields]
     * @memberof common
     */
    Struct: {
        fields: {
            fields: {
                keyType: "string",
                type: "Value",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Value message.
     * @interface IValue
     * @type {Object}
     * @property {string} [kind]
     * @property {0} [null_value]
     * @property {number} [number_value]
     * @property {string} [string_value]
     * @property {boolean} [bool_value]
     * @property {IStruct} [struct_value]
     * @property {IListValue} [list_value]
     * @memberof common
     */
    Value: {
        oneofs: {
            kind: {
                oneof: [
                    "null_value",
                    "number_value",
                    "string_value",
                    "bool_value",
                    "struct_value",
                    "list_value"
                ]
            }
        },
        fields: {
            null_value: {
                type: "NullValue",
                id: 1
            },
            number_value: {
                type: "double",
                id: 2
            },
            string_value: {
                type: "string",
                id: 3
            },
            bool_value: {
                type: "bool",
                id: 4
            },
            struct_value: {
                type: "Struct",
                id: 5
            },
            list_value: {
                type: "ListValue",
                id: 6
            }
        }
    },

    NullValue: {
        values: {
            NULL_VALUE: 0
        }
    },

    /**
     * Properties of a google.protobuf.ListValue message.
     * @interface IListValue
     * @type {Object}
     * @property {Array.<IValue>} [values]
     * @memberof common
     */
    ListValue: {
        fields: {
            values: {
                rule: "repeated",
                type: "Value",
                id: 1
            }
        }
    }
});

common("wrappers", {

    /**
     * Properties of a google.protobuf.DoubleValue message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    DoubleValue: {
        fields: {
            value: {
                type: "double",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.FloatValue message.
     * @interface IFloatValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FloatValue: {
        fields: {
            value: {
                type: "float",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int64Value message.
     * @interface IInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    Int64Value: {
        fields: {
            value: {
                type: "int64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt64Value message.
     * @interface IUInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    UInt64Value: {
        fields: {
            value: {
                type: "uint64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int32Value message.
     * @interface IInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    Int32Value: {
        fields: {
            value: {
                type: "int32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt32Value message.
     * @interface IUInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    UInt32Value: {
        fields: {
            value: {
                type: "uint32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BoolValue message.
     * @interface IBoolValue
     * @type {Object}
     * @property {boolean} [value]
     * @memberof common
     */
    BoolValue: {
        fields: {
            value: {
                type: "bool",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.StringValue message.
     * @interface IStringValue
     * @type {Object}
     * @property {string} [value]
     * @memberof common
     */
    StringValue: {
        fields: {
            value: {
                type: "string",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BytesValue message.
     * @interface IBytesValue
     * @type {Object}
     * @property {Uint8Array} [value]
     * @memberof common
     */
    BytesValue: {
        fields: {
            value: {
                type: "bytes",
                id: 1
            }
        }
    }
});

common("field_mask", {

    /**
     * Properties of a google.protobuf.FieldMask message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FieldMask: {
        fields: {
            paths: {
                rule: "repeated",
                type: "string",
                id: 1
            }
        }
    }
});

/**
 * Gets the root definition of the specified common proto file.
 *
 * Bundled definitions are:
 * - google/protobuf/any.proto
 * - google/protobuf/duration.proto
 * - google/protobuf/empty.proto
 * - google/protobuf/field_mask.proto
 * - google/protobuf/struct.proto
 * - google/protobuf/timestamp.proto
 * - google/protobuf/wrappers.proto
 *
 * @param {string} file Proto file name
 * @returns {INamespace|null} Root definition or `null` if not defined
 */
common.get = function get(file) {
    return common[file] || null;
};
"use strict";
/**
 * Runtime message from/to plain object converters.
 * @namespace
 */
var converter = exports;

var Enum = require("./enum"),
    util = require("./util");

/**
 * Generates a partial value fromObject conveter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
    var defaultAlreadyEmitted = false;
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(d%s){", prop);
            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                // enum unknown values passthrough
                if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) { gen
                    ("default:")
                        ("if(typeof(d%s)===\"number\"){m%s=d%s;break}", prop, prop, prop);
                    if (!field.repeated) gen // fallback to default value only for
                                             // arrays, to avoid leaving holes.
                        ("break");           // for non-repeated fields, just ignore
                    defaultAlreadyEmitted = true;
                }
                gen
                ("case%j:", keys[i])
                ("case %i:", values[keys[i]])
                    ("m%s=%j", prop, values[keys[i]])
                    ("break");
            } gen
            ("}");
        } else gen
            ("if(typeof d%s!==\"object\")", prop)
                ("throw TypeError(%j)", field.fullName + ": object expected")
            ("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
                ("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"
                break;
            case "uint32":
            case "fixed32": gen
                ("m%s=d%s>>>0", prop, prop);
                break;
            case "int32":
            case "sint32":
            case "sfixed32": gen
                ("m%s=d%s|0", prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-next-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(util.Long)")
                    ("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)
                ("else if(typeof d%s===\"string\")", prop)
                    ("m%s=parseInt(d%s,10)", prop, prop)
                ("else if(typeof d%s===\"number\")", prop)
                    ("m%s=d%s", prop, prop)
                ("else if(typeof d%s===\"object\")", prop)
                    ("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
                break;
            case "bytes": gen
                ("if(typeof d%s===\"string\")", prop)
                    ("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)
                ("else if(d%s.length >= 0)", prop)
                    ("m%s=d%s", prop, prop);
                break;
            case "string": gen
                ("m%s=String(d%s)", prop, prop);
                break;
            case "bool": gen
                ("m%s=Boolean(d%s)", prop, prop);
                break;
            /* default: gen
                ("m%s=d%s", prop, prop);
                break; */
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a plain object to runtime message converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.fromObject = function fromObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray;
    var gen = util.codegen(["d"], mtype.name + "$fromObject")
    ("if(d instanceof this.ctor)")
        ("return d");
    if (!fields.length) return gen
    ("return new this.ctor");
    gen
    ("var m=new this.ctor");
    for (var i = 0; i < fields.length; ++i) {
        var field  = fields[i].resolve(),
            prop   = util.safeProp(field.name);

        // Map fields
        if (field.map) { gen
    ("if(d%s){", prop)
        ("if(typeof d%s!==\"object\")", prop)
            ("throw TypeError(%j)", field.fullName + ": object expected")
        ("m%s={}", prop)
        ("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[ks[i]]")
        ("}")
    ("}");

        // Repeated fields
        } else if (field.repeated) { gen
    ("if(d%s){", prop)
        ("if(!Array.isArray(d%s))", prop)
            ("throw TypeError(%j)", field.fullName + ": array expected")
        ("m%s=[]", prop)
        ("for(var i=0;i<d%s.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[i]")
        ("}")
    ("}");

        // Non-repeated fields
        } else {
            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
    ("if(d%s!=null){", prop); // !== undefined && !== null
        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);
            if (!(field.resolvedType instanceof Enum)) gen
    ("}");
        }
    } return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

/**
 * Generates a partial value toObject converter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_toObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) gen
            ("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);
        else gen
            ("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
            ("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-next-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
            ("if(typeof m%s===\"number\")", prop)
                ("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)
            ("else") // Long-like
                ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true": "", prop);
                break;
            case "bytes": gen
            ("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
                break;
            default: gen
            ("d%s=m%s", prop, prop);
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a runtime message to plain object converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.toObject = function toObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    if (!fields.length)
        return util.codegen()("return {}");
    var gen = util.codegen(["m", "o"], mtype.name + "$toObject")
    ("if(!o)")
        ("o={}")
    ("var d={}");

    var repeatedFields = [],
        mapFields = [],
        normalFields = [],
        i = 0;
    for (; i < fields.length; ++i)
        if (!fields[i].partOf)
            ( fields[i].resolve().repeated ? repeatedFields
            : fields[i].map ? mapFields
            : normalFields).push(fields[i]);

    if (repeatedFields.length) { gen
    ("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen
        ("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen
    ("}");
    }

    if (mapFields.length) { gen
    ("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen
        ("d%s={}", util.safeProp(mapFields[i].name));
        gen
    ("}");
    }

    if (normalFields.length) { gen
    ("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
            var field = normalFields[i],
                prop  = util.safeProp(field.name);
            if (field.resolvedType instanceof Enum) gen
        ("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
            else if (field.long) gen
        ("if(util.Long){")
            ("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)
            ("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)
        ("}else")
            ("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
            else if (field.bytes) {
                var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
                gen
        ("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))
        ("else{")
            ("d%s=%s", prop, arrayDefault)
            ("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)
        ("}");
            } else gen
        ("d%s=%j", prop, field.typeDefault); // also messages (=null)
        } gen
    ("}");
    }
    var hasKs2 = false;
    for (i = 0; i < fields.length; ++i) {
        var field = fields[i],
            index = mtype._fieldsArray.indexOf(field),
            prop  = util.safeProp(field.name);
        if (field.map) {
            if (!hasKs2) { hasKs2 = true; gen
    ("var ks2");
            } gen
    ("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)
        ("d%s={}", prop)
        ("for(var j=0;j<ks2.length;++j){");
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[ks2[j]]")
        ("}");
        } else if (field.repeated) { gen
    ("if(m%s&&m%s.length){", prop, prop)
        ("d%s=[]", prop)
        ("for(var j=0;j<m%s.length;++j){", prop);
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[j]")
        ("}");
        } else { gen
    ("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null
        genValuePartial_toObject(gen, field, /* sorted */ index, prop);
        if (field.partOf) gen
        ("if(o.oneofs)")
            ("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen
    ("}");
    }
    return gen
    ("return d");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};
"use strict";
module.exports = decoder;

var Enum    = require("./enum"),
    types   = require("./types"),
    util    = require("./util");

function missing(field) {
    return "missing required '" + field.name + "'";
}

/**
 * Generates a decoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function decoder(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["r", "l"], mtype.name + "$decode")
    ("if(!(r instanceof Reader))")
        ("r=Reader.create(r)")
    ("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? ",k,value" : ""))
    ("while(r.pos<c){")
        ("var t=r.uint32()");
    if (mtype.group) gen
        ("if((t&7)===4)")
            ("break");
    gen
        ("switch(t>>>3){");

    var i = 0;
    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            type  = field.resolvedType instanceof Enum ? "int32" : field.type,
            ref   = "m" + util.safeProp(field.name); gen
            ("case %i: {", field.id);

        // Map fields
        if (field.map) { gen
                ("if(%s===util.emptyObject)", ref)
                    ("%s={}", ref)
                ("var c2 = r.uint32()+r.pos");

            if (types.defaults[field.keyType] !== undefined) gen
                ("k=%j", types.defaults[field.keyType]);
            else gen
                ("k=null");

            if (types.defaults[type] !== undefined) gen
                ("value=%j", types.defaults[type]);
            else gen
                ("value=null");

            gen
                ("while(r.pos<c2){")
                    ("var tag2=r.uint32()")
                    ("switch(tag2>>>3){")
                        ("case 1: k=r.%s(); break", field.keyType)
                        ("case 2:");

            if (types.basic[type] === undefined) gen
                            ("value=types[%i].decode(r,r.uint32())", i); // can't be groups
            else gen
                            ("value=r.%s()", type);

            gen
                            ("break")
                        ("default:")
                            ("r.skipType(tag2&7)")
                            ("break")
                    ("}")
                ("}");

            if (types.long[field.keyType] !== undefined) gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=value", ref);
            else gen
                ("%s[k]=value", ref);

        // Repeated fields
        } else if (field.repeated) { gen

                ("if(!(%s&&%s.length))", ref, ref)
                    ("%s=[]", ref);

            // Packable (always check for forward and backward compatiblity)
            if (types.packed[type] !== undefined) gen
                ("if((t&7)===2){")
                    ("var c2=r.uint32()+r.pos")
                    ("while(r.pos<c2)")
                        ("%s.push(r.%s())", ref, type)
                ("}else");

            // Non-packed
            if (types.basic[type] === undefined) gen(field.resolvedType.group
                    ? "%s.push(types[%i].decode(r))"
                    : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
            else gen
                    ("%s.push(r.%s())", ref, type);

        // Non-repeated
        } else if (types.basic[type] === undefined) gen(field.resolvedType.group
                ? "%s=types[%i].decode(r)"
                : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else gen
                ("%s=r.%s()", ref, type);
        gen
                ("break")
            ("}");
        // Unknown fields
    } gen
            ("default:")
                ("r.skipType(t&7)")
                ("break")

        ("}")
    ("}");

    // Field presence
    for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required) gen
    ("if(!m.hasOwnProperty(%j))", rfield.name)
        ("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
    }

    return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline */
}
"use strict";
module.exports = encoder;

var Enum     = require("./enum"),
    types    = require("./types"),
    util     = require("./util");

/**
 * Generates a partial message type encoder.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genTypePartial(gen, field, fieldIndex, ref) {
    return field.resolvedType.group
        ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)
        : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
}

/**
 * Generates an encoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function encoder(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var gen = util.codegen(["m", "w"], mtype.name + "$encode")
    ("if(!w)")
        ("w=Writer.create()");

    var i, ref;

    // "when a message is serialized its known fields should be written sequentially by field number"
    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);

    for (var i = 0; i < fields.length; ++i) {
        var field    = fields[i].resolve(),
            index    = mtype._fieldsArray.indexOf(field),
            type     = field.resolvedType instanceof Enum ? "int32" : field.type,
            wireType = types.basic[type];
            ref      = "m" + util.safeProp(field.name);

        // Map fields
        if (field.map) {
            gen
    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name) // !== undefined && !== null
        ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)
            ("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
            if (wireType === undefined) gen
            ("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
            else gen
            (".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
            gen
        ("}")
    ("}");

            // Repeated fields
        } else if (field.repeated) { gen
    ("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null

            // Packed repeated
            if (field.packed && types.packed[type] !== undefined) { gen

        ("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)
        ("for(var i=0;i<%s.length;++i)", ref)
            ("w.%s(%s[i])", type, ref)
        ("w.ldelim()");

            // Non-packed
            } else { gen

        ("for(var i=0;i<%s.length;++i)", ref);
                if (wireType === undefined)
            genTypePartial(gen, field, index, ref + "[i]");
                else gen
            ("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);

            } gen
    ("}");

        // Non-repeated
        } else {
            if (field.optional) gen
    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name); // !== undefined && !== null

            if (wireType === undefined)
        genTypePartial(gen, field, index, ref);
            else gen
        ("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);

        }
    }

    return gen
    ("return w");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}
"use strict";
module.exports = Enum;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

var Namespace = require("./namespace"),
    util = require("./util");

/**
 * Constructs a new enum instance.
 * @classdesc Reflected enum.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {Object.<string,number>} [values] Enum values as an object, by name
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this enum
 * @param {Object.<string,string>} [comments] The value comments for this enum
 * @param {Object.<string,Object<string,*>>|undefined} [valuesOptions] The value options for this enum
 */
function Enum(name, values, options, comment, comments, valuesOptions) {
    ReflectionObject.call(this, name, options);

    if (values && typeof values !== "object")
        throw TypeError("values must be an object");

    /**
     * Enum values by id.
     * @type {Object.<number,string>}
     */
    this.valuesById = {};

    /**
     * Enum values by name.
     * @type {Object.<string,number>}
     */
    this.values = Object.create(this.valuesById); // toJSON, marker

    /**
     * Enum comment text.
     * @type {string|null}
     */
    this.comment = comment;

    /**
     * Value comment texts, if any.
     * @type {Object.<string,string>}
     */
    this.comments = comments || {};

    /**
     * Values options, if any
     * @type {Object<string, Object<string, *>>|undefined}
     */
    this.valuesOptions = valuesOptions;

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
    // compatible enum. This is used by pbts to write actual enum definitions that work for
    // static and reflection code alike instead of emitting generic object definitions.

    if (values)
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
            if (typeof values[keys[i]] === "number") // use forward entries only
                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
}

/**
 * Enum descriptor.
 * @interface IEnum
 * @property {Object.<string,number>} values Enum values
 * @property {Object.<string,*>} [options] Enum options
 */

/**
 * Constructs an enum from an enum descriptor.
 * @param {string} name Enum name
 * @param {IEnum} json Enum descriptor
 * @returns {Enum} Created enum
 * @throws {TypeError} If arguments are invalid
 */
Enum.fromJSON = function fromJSON(name, json) {
    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
    enm.reserved = json.reserved;
    return enm;
};

/**
 * Converts this enum to an enum descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IEnum} Enum descriptor
 */
Enum.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"       , this.options,
        "valuesOptions" , this.valuesOptions,
        "values"        , this.values,
        "reserved"      , this.reserved && this.reserved.length ? this.reserved : undefined,
        "comment"       , keepComments ? this.comment : undefined,
        "comments"      , keepComments ? this.comments : undefined
    ]);
};

/**
 * Adds a value to this enum.
 * @param {string} name Value name
 * @param {number} id Value id
 * @param {string} [comment] Comment, if any
 * @param {Object.<string, *>|undefined} [options] Options, if any
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a value with this name or id
 */
Enum.prototype.add = function add(name, id, comment, options) {
    // utilized by the parser but not by .fromJSON

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (!util.isInteger(id))
        throw TypeError("id must be an integer");

    if (this.values[name] !== undefined)
        throw Error("duplicate name '" + name + "' in " + this);

    if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);

    if (this.isReservedName(name))
        throw Error("name '" + name + "' is reserved in " + this);

    if (this.valuesById[id] !== undefined) {
        if (!(this.options && this.options.allow_alias))
            throw Error("duplicate id " + id + " in " + this);
        this.values[name] = id;
    } else
        this.valuesById[this.values[name] = id] = name;

    if (options) {
        if (this.valuesOptions === undefined)
            this.valuesOptions = {};
        this.valuesOptions[name] = options || null;
    }

    this.comments[name] = comment || null;
    return this;
};

/**
 * Removes a value from this enum
 * @param {string} name Value name
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `name` is not a name of this enum
 */
Enum.prototype.remove = function remove(name) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    var val = this.values[name];
    if (val == null)
        throw Error("name '" + name + "' does not exist in " + this);

    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];
    if (this.valuesOptions)
        delete this.valuesOptions[name];

    return this;
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};
"use strict";
module.exports = Field;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

var Enum  = require("./enum"),
    types = require("./types"),
    util  = require("./util");

var Type; // cyclic

var ruleRe = /^required|optional|repeated$/;

/**
 * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
 * @name Field
 * @classdesc Reflected message field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a field from a field descriptor.
 * @param {string} name Field name
 * @param {IField} json Field descriptor
 * @returns {Field} Created field
 * @throws {TypeError} If arguments are invalid
 */
Field.fromJSON = function fromJSON(name, json) {
    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
};

/**
 * Not an actual constructor. Use {@link Field} instead.
 * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports FieldBase
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function Field(name, id, type, rule, extend, options, comment) {

    if (util.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = undefined;
    } else if (util.isObject(extend)) {
        comment = options;
        options = extend;
        extend = undefined;
    }

    ReflectionObject.call(this, name, options);

    if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");

    if (!util.isString(type))
        throw TypeError("type must be a string");

    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");

    if (extend !== undefined && !util.isString(extend))
        throw TypeError("extend must be a string");

    /**
     * Field rule, if any.
     * @type {string|undefined}
     */
    if (rule === "proto3_optional") {
        rule = "optional";
    }
    this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

    /**
     * Field type.
     * @type {string}
     */
    this.type = type; // toJSON

    /**
     * Unique field id.
     * @type {number}
     */
    this.id = id; // toJSON, marker

    /**
     * Extended type if different from parent.
     * @type {string|undefined}
     */
    this.extend = extend || undefined; // toJSON

    /**
     * Whether this field is required.
     * @type {boolean}
     */
    this.required = rule === "required";

    /**
     * Whether this field is optional.
     * @type {boolean}
     */
    this.optional = !this.required;

    /**
     * Whether this field is repeated.
     * @type {boolean}
     */
    this.repeated = rule === "repeated";

    /**
     * Whether this field is a map or not.
     * @type {boolean}
     */
    this.map = false;

    /**
     * Message this field belongs to.
     * @type {Type|null}
     */
    this.message = null;

    /**
     * OneOf this field belongs to, if any,
     * @type {OneOf|null}
     */
    this.partOf = null;

    /**
     * The field type's default value.
     * @type {*}
     */
    this.typeDefault = null;

    /**
     * The field's default value on prototypes.
     * @type {*}
     */
    this.defaultValue = null;

    /**
     * Whether this field's value should be treated as a long.
     * @type {boolean}
     */
    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

    /**
     * Whether this field's value is a buffer.
     * @type {boolean}
     */
    this.bytes = type === "bytes";

    /**
     * Resolved type if not a basic type.
     * @type {Type|Enum|null}
     */
    this.resolvedType = null;

    /**
     * Sister-field within the extended type if a declaring extension field.
     * @type {Field|null}
     */
    this.extensionField = null;

    /**
     * Sister-field within the declaring namespace if an extended field.
     * @type {Field|null}
     */
    this.declaringField = null;

    /**
     * Internally remembers whether this field is packed.
     * @type {boolean|null}
     * @private
     */
    this._packed = null;

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Determines whether this field is packed. Only relevant when repeated and working with proto2.
 * @name Field#packed
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(Field.prototype, "packed", {
    get: function() {
        // defaults to packed=true if not explicity set to false
        if (this._packed === null)
            this._packed = this.getOption("packed") !== false;
        return this._packed;
    }
});

/**
 * @override
 */
Field.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (name === "packed") // clear cached before setting
        this._packed = null;
    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
};

/**
 * Field descriptor.
 * @interface IField
 * @property {string} [rule="optional"] Field rule
 * @property {string} type Field type
 * @property {number} id Field id
 * @property {Object.<string,*>} [options] Field options
 */

/**
 * Extension field descriptor.
 * @interface IExtensionField
 * @extends IField
 * @property {string} extend Extended type
 */

/**
 * Converts this field to a field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IField} Field descriptor
 */
Field.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "rule"    , this.rule !== "optional" && this.rule || undefined,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Resolves this field's type references.
 * @returns {Field} `this`
 * @throws {Error} If any reference cannot be resolved
 */
Field.prototype.resolve = function resolve() {

    if (this.resolved)
        return this;

    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
            this.typeDefault = null;
        else // instanceof Enum
            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
    } else if (this.options && this.options.proto3_optional) {
        // proto3 scalar value marked optional; should default to null
        this.typeDefault = null;
    }

    // use explicitly set default value if present
    if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
            this.typeDefault = this.resolvedType.values[this.typeDefault];
    }

    // remove unnecessary options
    if (this.options) {
        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))
            delete this.options.packed;
        if (!Object.keys(this.options).length)
            this.options = undefined;
    }

    // convert to internal data type if necesssary
    if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");

        /* istanbul ignore else */
        if (Object.freeze)
            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)

    } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
    }

    // take special care of maps and repeated fields
    if (this.map)
        this.defaultValue = util.emptyObject;
    else if (this.repeated)
        this.defaultValue = util.emptyArray;
    else
        this.defaultValue = this.typeDefault;

    // ensure proper value on prototype
    if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;

    return ReflectionObject.prototype.resolve.call(this);
};

/**
 * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
 * @typedef FieldDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} fieldName Field name
 * @returns {undefined}
 */

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @param {T} [defaultValue] Default value
 * @returns {FieldDecorator} Decorator function
 * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
 */
Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {

    // submessage: decorate the submessage and use its name as the type
    if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;

    // enum reference: create a reflected copy of the enum and keep reuseing it
    else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;

    return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
    };
};

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {Constructor<T>|string} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @returns {FieldDecorator} Decorator function
 * @template T extends Message<T>
 * @variation 2
 */
// like Field.d but without a default value

// Sets up cyclic dependencies (called in index-light)
Field._configure = function configure(Type_) {
    Type = Type_;
};
"use strict";
var protobuf = module.exports = require("./index-minimal");

protobuf.build = "light";

/**
 * A node-style callback as used by {@link load} and {@link Root#load}.
 * @typedef LoadCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Root} [root] Root, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} root Root namespace, defaults to create a new one if omitted.
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 */
function load(filename, root, callback) {
    if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
    } else if (!root)
        root = new protobuf.Root();
    return root.load(filename, callback);
}

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Promise<Root>} Promise
 * @see {@link Root#load}
 * @variation 3
 */
// function load(filename:string, [root:Root]):Promise<Root>

protobuf.load = load;

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 * @see {@link Root#loadSync}
 */
function loadSync(filename, root) {
    if (!root)
        root = new protobuf.Root();
    return root.loadSync(filename);
}

protobuf.loadSync = loadSync;

// Serialization
protobuf.encoder          = require("./encoder");
protobuf.decoder          = require("./decoder");
protobuf.verifier         = require("./verifier");
protobuf.converter        = require("./converter");

// Reflection
protobuf.ReflectionObject = require("./object");
protobuf.Namespace        = require("./namespace");
protobuf.Root             = require("./root");
protobuf.Enum             = require("./enum");
protobuf.Type             = require("./type");
protobuf.Field            = require("./field");
protobuf.OneOf            = require("./oneof");
protobuf.MapField         = require("./mapfield");
protobuf.Service          = require("./service");
protobuf.Method           = require("./method");

// Runtime
protobuf.Message          = require("./message");
protobuf.wrappers         = require("./wrappers");

// Utility
protobuf.types            = require("./types");
protobuf.util             = require("./util");

// Set up possibly cyclic reflection dependencies
protobuf.ReflectionObject._configure(protobuf.Root);
protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
protobuf.Root._configure(protobuf.Type);
protobuf.Field._configure(protobuf.Type);
"use strict";
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = require("./writer");
protobuf.BufferWriter = require("./writer_buffer");
protobuf.Reader       = require("./reader");
protobuf.BufferReader = require("./reader_buffer");

// Utility
protobuf.util         = require("./util/minimal");
protobuf.rpc          = require("./rpc");
protobuf.roots        = require("./roots");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();
"use strict";
var protobuf = module.exports = require("./index-light");

protobuf.build = "full";

// Parser
protobuf.tokenize         = require("./tokenize");
protobuf.parse            = require("./parse");
protobuf.common           = require("./common");

// Configure parser
protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
"use strict";
module.exports = MapField;

// extends Field
var Field = require("./field");
((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

var types   = require("./types"),
    util    = require("./util");

/**
 * Constructs a new map field instance.
 * @classdesc Reflected map field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} keyType Key type
 * @param {string} type Value type
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function MapField(name, id, keyType, type, options, comment) {
    Field.call(this, name, id, type, undefined, undefined, options, comment);

    /* istanbul ignore if */
    if (!util.isString(keyType))
        throw TypeError("keyType must be a string");

    /**
     * Key type.
     * @type {string}
     */
    this.keyType = keyType; // toJSON, marker

    /**
     * Resolved key type if not a basic type.
     * @type {ReflectionObject|null}
     */
    this.resolvedKeyType = null;

    // Overrides Field#map
    this.map = true;
}

/**
 * Map field descriptor.
 * @interface IMapField
 * @extends {IField}
 * @property {string} keyType Key type
 */

/**
 * Extension map field descriptor.
 * @interface IExtensionMapField
 * @extends IMapField
 * @property {string} extend Extended type
 */

/**
 * Constructs a map field from a map field descriptor.
 * @param {string} name Field name
 * @param {IMapField} json Map field descriptor
 * @returns {MapField} Created map field
 * @throws {TypeError} If arguments are invalid
 */
MapField.fromJSON = function fromJSON(name, json) {
    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
};

/**
 * Converts this map field to a map field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMapField} Map field descriptor
 */
MapField.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "keyType" , this.keyType,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
MapField.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;

    // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
    if (types.mapKey[this.keyType] === undefined)
        throw Error("invalid key type: " + this.keyType);

    return Field.prototype.resolve.call(this);
};

/**
 * Map field decorator (TypeScript).
 * @name MapField.d
 * @function
 * @param {number} fieldId Field id
 * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
 * @returns {FieldDecorator} Decorator function
 * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
 */
MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {

    // submessage value: decorate the submessage and use its name as the type
    if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;

    // enum reference value: create a reflected copy of the enum and keep reuseing it
    else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;

    return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
    };
};
"use strict";
module.exports = Message;

var util = require("./util/minimal");

/**
 * Constructs a new message instance.
 * @classdesc Abstract runtime message.
 * @constructor
 * @param {Properties<T>} [properties] Properties to set
 * @template T extends object = object
 */
function Message(properties) {
    // not used internally
    if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            this[keys[i]] = properties[keys[i]];
}

/**
 * Reference to the reflected type.
 * @name Message.$type
 * @type {Type}
 * @readonly
 */

/**
 * Reference to the reflected type.
 * @name Message#$type
 * @type {Type}
 * @readonly
 */

/*eslint-disable valid-jsdoc*/

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<T>} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.create = function create(properties) {
    return this.$type.create(properties);
};

/**
 * Encodes a message of this type.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encode = function encode(message, writer) {
    return this.$type.encode(message, writer);
};

/**
 * Encodes a message of this type preceeded by its length as a varint.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encodeDelimited = function encodeDelimited(message, writer) {
    return this.$type.encodeDelimited(message, writer);
};

/**
 * Decodes a message of this type.
 * @name Message.decode
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decode = function decode(reader) {
    return this.$type.decode(reader);
};

/**
 * Decodes a message of this type preceeded by its length as a varint.
 * @name Message.decodeDelimited
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decodeDelimited = function decodeDelimited(reader) {
    return this.$type.decodeDelimited(reader);
};

/**
 * Verifies a message of this type.
 * @name Message.verify
 * @function
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {string|null} `null` if valid, otherwise the reason why it is not
 */
Message.verify = function verify(message) {
    return this.$type.verify(message);
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object
 * @returns {T} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.fromObject = function fromObject(object) {
    return this.$type.fromObject(object);
};

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {T} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.toObject = function toObject(message, options) {
    return this.$type.toObject(message, options);
};

/**
 * Converts this message to JSON.
 * @returns {Object.<string,*>} JSON object
 */
Message.prototype.toJSON = function toJSON() {
    return this.$type.toObject(this, util.toJSONOptions);
};

/*eslint-enable valid-jsdoc*/"use strict";
module.exports = Method;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

var util = require("./util");

/**
 * Constructs a new service method instance.
 * @classdesc Reflected service method.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Method name
 * @param {string|undefined} type Method type, usually `"rpc"`
 * @param {string} requestType Request message type
 * @param {string} responseType Response message type
 * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
 * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this method
 * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object
 */
function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {

    /* istanbul ignore next */
    if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = undefined;
    } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = undefined;
    }

    /* istanbul ignore if */
    if (!(type === undefined || util.isString(type)))
        throw TypeError("type must be a string");

    /* istanbul ignore if */
    if (!util.isString(requestType))
        throw TypeError("requestType must be a string");

    /* istanbul ignore if */
    if (!util.isString(responseType))
        throw TypeError("responseType must be a string");

    ReflectionObject.call(this, name, options);

    /**
     * Method type.
     * @type {string}
     */
    this.type = type || "rpc"; // toJSON

    /**
     * Request type.
     * @type {string}
     */
    this.requestType = requestType; // toJSON, marker

    /**
     * Whether requests are streamed or not.
     * @type {boolean|undefined}
     */
    this.requestStream = requestStream ? true : undefined; // toJSON

    /**
     * Response type.
     * @type {string}
     */
    this.responseType = responseType; // toJSON

    /**
     * Whether responses are streamed or not.
     * @type {boolean|undefined}
     */
    this.responseStream = responseStream ? true : undefined; // toJSON

    /**
     * Resolved request type.
     * @type {Type|null}
     */
    this.resolvedRequestType = null;

    /**
     * Resolved response type.
     * @type {Type|null}
     */
    this.resolvedResponseType = null;

    /**
     * Comment for this method
     * @type {string|null}
     */
    this.comment = comment;

    /**
     * Options properly parsed into an object
     */
    this.parsedOptions = parsedOptions;
}

/**
 * Method descriptor.
 * @interface IMethod
 * @property {string} [type="rpc"] Method type
 * @property {string} requestType Request type
 * @property {string} responseType Response type
 * @property {boolean} [requestStream=false] Whether requests are streamed
 * @property {boolean} [responseStream=false] Whether responses are streamed
 * @property {Object.<string,*>} [options] Method options
 * @property {string} comment Method comments
 * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object
 */

/**
 * Constructs a method from a method descriptor.
 * @param {string} name Method name
 * @param {IMethod} json Method descriptor
 * @returns {Method} Created method
 * @throws {TypeError} If arguments are invalid
 */
Method.fromJSON = function fromJSON(name, json) {
    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
};

/**
 * Converts this method to a method descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMethod} Method descriptor
 */
Method.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "type"           , this.type !== "rpc" && /* istanbul ignore next */ this.type || undefined,
        "requestType"    , this.requestType,
        "requestStream"  , this.requestStream,
        "responseType"   , this.responseType,
        "responseStream" , this.responseStream,
        "options"        , this.options,
        "comment"        , keepComments ? this.comment : undefined,
        "parsedOptions"  , this.parsedOptions,
    ]);
};

/**
 * @override
 */
Method.prototype.resolve = function resolve() {

    /* istanbul ignore if */
    if (this.resolved)
        return this;

    this.resolvedRequestType = this.parent.lookupType(this.requestType);
    this.resolvedResponseType = this.parent.lookupType(this.responseType);

    return ReflectionObject.prototype.resolve.call(this);
};
"use strict";
module.exports = Namespace;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

var Field    = require("./field"),
    util     = require("./util"),
    OneOf    = require("./oneof");

var Type,    // cyclic
    Service,
    Enum;

/**
 * Constructs a new namespace instance.
 * @name Namespace
 * @classdesc Reflected namespace.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a namespace from JSON.
 * @memberof Namespace
 * @function
 * @param {string} name Namespace name
 * @param {Object.<string,*>} json JSON object
 * @returns {Namespace} Created namespace
 * @throws {TypeError} If arguments are invalid
 */
Namespace.fromJSON = function fromJSON(name, json) {
    return new Namespace(name, json.options).addJSON(json.nested);
};

/**
 * Converts an array of reflection objects to JSON.
 * @memberof Namespace
 * @param {ReflectionObject[]} array Object array
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
 */
function arrayToJSON(array, toJSONOptions) {
    if (!(array && array.length))
        return undefined;
    var obj = {};
    for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
    return obj;
}

Namespace.arrayToJSON = arrayToJSON;

/**
 * Tests if the specified id is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedId = function isReservedId(reserved, id) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
                return true;
    return false;
};

/**
 * Tests if the specified name is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedName = function isReservedName(reserved, name) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (reserved[i] === name)
                return true;
    return false;
};

/**
 * Not an actual constructor. Use {@link Namespace} instead.
 * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports NamespaceBase
 * @extends ReflectionObject
 * @abstract
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 * @see {@link Namespace}
 */
function Namespace(name, options) {
    ReflectionObject.call(this, name, options);

    /**
     * Nested objects by name.
     * @type {Object.<string,ReflectionObject>|undefined}
     */
    this.nested = undefined; // toJSON

    /**
     * Cached nested objects as an array.
     * @type {ReflectionObject[]|null}
     * @private
     */
    this._nestedArray = null;
}

function clearCache(namespace) {
    namespace._nestedArray = null;
    return namespace;
}

/**
 * Nested objects of this namespace as an array for iteration.
 * @name NamespaceBase#nestedArray
 * @type {ReflectionObject[]}
 * @readonly
 */
Object.defineProperty(Namespace.prototype, "nestedArray", {
    get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
    }
});

/**
 * Namespace descriptor.
 * @interface INamespace
 * @property {Object.<string,*>} [options] Namespace options
 * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
 */

/**
 * Any extension field descriptor.
 * @typedef AnyExtensionField
 * @type {IExtensionField|IExtensionMapField}
 */

/**
 * Any nested object descriptor.
 * @typedef AnyNestedObject
 * @type {IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf}
 */

/**
 * Converts this namespace to a namespace descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {INamespace} Namespace descriptor
 */
Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
    return util.toObject([
        "options" , this.options,
        "nested"  , arrayToJSON(this.nestedArray, toJSONOptions)
    ]);
};

/**
 * Adds nested objects to this namespace from nested object descriptors.
 * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
 * @returns {Namespace} `this`
 */
Namespace.prototype.addJSON = function addJSON(nestedJson) {
    var ns = this;
    /* istanbul ignore else */
    if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
            nested = nestedJson[names[i]];
            ns.add( // most to least likely
                ( nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : nested.id !== undefined
                ? Field.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    }
    return this;
};

/**
 * Gets the nested object of the specified name.
 * @param {string} name Nested object name
 * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
 */
Namespace.prototype.get = function get(name) {
    return util.getProp(this.nested, name)
        || null;
};

/**
 * Gets the values of the nested {@link Enum|enum} of the specified name.
 * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
 * @param {string} name Nested enum name
 * @returns {Object.<string,number>} Enum values
 * @throws {Error} If there is no such enum
 */
Namespace.prototype.getEnum = function getEnum(name) {
    if (this.nested && this.nested[name] instanceof Enum)
        return this.nested[name].values;
    throw Error("no such enum: " + name);
};

/**
 * Adds a nested object to this namespace.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name
 */
Namespace.prototype.add = function add(object) {

    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type  || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))
        throw TypeError("object must be a valid nested object");

    if (!this.nested)
        this.nested = {};
    else {
        var prev = this.get(object.name);
        if (prev) {
            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
                // replace plain namespace but keep existing nested elements and options
                var nested = prev.nestedArray;
                for (var i = 0; i < nested.length; ++i)
                    object.add(nested[i]);
                this.remove(prev);
                if (!this.nested)
                    this.nested = {};
                object.setOptions(prev.options, true);

            } else
                throw Error("duplicate name '" + object.name + "' in " + this);
        }
    }
    this.nested[object.name] = object;
    object.onAdd(this);
    return clearCache(this);
};

/**
 * Removes a nested object from this namespace.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this namespace
 */
Namespace.prototype.remove = function remove(object) {

    if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
    if (object.parent !== this)
        throw Error(object + " is not a member of " + this);

    delete this.nested[object.name];
    if (!Object.keys(this.nested).length)
        this.nested = undefined;

    object.onRemove(this);
    return clearCache(this);
};

/**
 * Defines additial namespaces within this one if not yet existing.
 * @param {string|string[]} path Path to create
 * @param {*} [json] Nested types to create from JSON
 * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
 */
Namespace.prototype.define = function define(path, json) {

    if (util.isString(path))
        path = path.split(".");
    else if (!Array.isArray(path))
        throw TypeError("illegal path");
    if (path && path.length && path[0] === "")
        throw Error("path must be relative");

    var ptr = this;
    while (path.length > 0) {
        var part = path.shift();
        if (ptr.nested && ptr.nested[part]) {
            ptr = ptr.nested[part];
            if (!(ptr instanceof Namespace))
                throw Error("path conflicts with non-namespace objects");
        } else
            ptr.add(ptr = new Namespace(part));
    }
    if (json)
        ptr.addJSON(json);
    return ptr;
};

/**
 * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
 * @returns {Namespace} `this`
 */
Namespace.prototype.resolveAll = function resolveAll() {
    var nested = this.nestedArray, i = 0;
    while (i < nested.length)
        if (nested[i] instanceof Namespace)
            nested[i++].resolveAll();
        else
            nested[i++].resolve();
    return this.resolve();
};

/**
 * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
 * @param {string|string[]} path Path to look up
 * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
 * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 */
Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {

    /* istanbul ignore next */
    if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = undefined;
    } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [ filterTypes ];

    if (util.isString(path) && path.length) {
        if (path === ".")
            return this.root;
        path = path.split(".");
    } else if (!path.length)
        return this;

    // Start at root if path is absolute
    if (path[0] === "")
        return this.root.lookup(path.slice(1), filterTypes);

    // Test if the first part matches any nested object, and if so, traverse if path contains more
    var found = this.get(path[0]);
    if (found) {
        if (path.length === 1) {
            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
                return found;
        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
            return found;

    // Otherwise try each nested namespace
    } else
        for (var i = 0; i < this.nestedArray.length; ++i)
            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
                return found;

    // If there hasn't been a match, try again at the parent
    if (this.parent === null || parentAlreadyChecked)
        return null;
    return this.parent.lookup(path, filterTypes);
};

/**
 * Looks up the reflection object at the specified path, relative to this namespace.
 * @name NamespaceBase#lookup
 * @function
 * @param {string|string[]} path Path to look up
 * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 * @variation 2
 */
// lookup(path: string, [parentAlreadyChecked: boolean])

/**
 * Looks up the {@link Type|type} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type
 * @throws {Error} If `path` does not point to a type
 */
Namespace.prototype.lookupType = function lookupType(path) {
    var found = this.lookup(path, [ Type ]);
    if (!found)
        throw Error("no such type: " + path);
    return found;
};

/**
 * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Enum} Looked up enum
 * @throws {Error} If `path` does not point to an enum
 */
Namespace.prototype.lookupEnum = function lookupEnum(path) {
    var found = this.lookup(path, [ Enum ]);
    if (!found)
        throw Error("no such Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type or enum
 * @throws {Error} If `path` does not point to a type or enum
 */
Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
    var found = this.lookup(path, [ Type, Enum ]);
    if (!found)
        throw Error("no such Type or Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Service|service} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Service} Looked up service
 * @throws {Error} If `path` does not point to a service
 */
Namespace.prototype.lookupService = function lookupService(path) {
    var found = this.lookup(path, [ Service ]);
    if (!found)
        throw Error("no such Service '" + path + "' in " + this);
    return found;
};

// Sets up cyclic dependencies (called in index-light)
Namespace._configure = function(Type_, Service_, Enum_) {
    Type    = Type_;
    Service = Service_;
    Enum    = Enum_;
};
"use strict";
module.exports = ReflectionObject;

ReflectionObject.className = "ReflectionObject";

var util = require("./util");

var Root; // cyclic

/**
 * Constructs a new reflection object instance.
 * @classdesc Base class of all reflection objects.
 * @constructor
 * @param {string} name Object name
 * @param {Object.<string,*>} [options] Declared options
 * @abstract
 */
function ReflectionObject(name, options) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (options && !util.isObject(options))
        throw TypeError("options must be an object");

    /**
     * Options.
     * @type {Object.<string,*>|undefined}
     */
    this.options = options; // toJSON

    /**
     * Parsed Options.
     * @type {Array.<Object.<string,*>>|undefined}
     */
    this.parsedOptions = null;

    /**
     * Unique name within its namespace.
     * @type {string}
     */
    this.name = name;

    /**
     * Parent namespace.
     * @type {Namespace|null}
     */
    this.parent = null;

    /**
     * Whether already resolved or not.
     * @type {boolean}
     */
    this.resolved = false;

    /**
     * Comment text, if any.
     * @type {string|null}
     */
    this.comment = null;

    /**
     * Defining file name.
     * @type {string|null}
     */
    this.filename = null;
}

Object.defineProperties(ReflectionObject.prototype, {

    /**
     * Reference to the root namespace.
     * @name ReflectionObject#root
     * @type {Root}
     * @readonly
     */
    root: {
        get: function() {
            var ptr = this;
            while (ptr.parent !== null)
                ptr = ptr.parent;
            return ptr;
        }
    },

    /**
     * Full name including leading dot.
     * @name ReflectionObject#fullName
     * @type {string}
     * @readonly
     */
    fullName: {
        get: function() {
            var path = [ this.name ],
                ptr = this.parent;
            while (ptr) {
                path.unshift(ptr.name);
                ptr = ptr.parent;
            }
            return path.join(".");
        }
    }
});

/**
 * Converts this reflection object to its descriptor representation.
 * @returns {Object.<string,*>} Descriptor
 * @abstract
 */
ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {
    throw Error(); // not implemented, shouldn't happen
};

/**
 * Called when this object is added to a parent.
 * @param {ReflectionObject} parent Parent added to
 * @returns {undefined}
 */
ReflectionObject.prototype.onAdd = function onAdd(parent) {
    if (this.parent && this.parent !== parent)
        this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root = parent.root;
    if (root instanceof Root)
        root._handleAdd(this);
};

/**
 * Called when this object is removed from a parent.
 * @param {ReflectionObject} parent Parent removed from
 * @returns {undefined}
 */
ReflectionObject.prototype.onRemove = function onRemove(parent) {
    var root = parent.root;
    if (root instanceof Root)
        root._handleRemove(this);
    this.parent = null;
    this.resolved = false;
};

/**
 * Resolves this objects type references.
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;
    if (this.root instanceof Root)
        this.resolved = true; // only if part of a root
    return this;
};

/**
 * Gets an option value.
 * @param {string} name Option name
 * @returns {*} Option value or `undefined` if not set
 */
ReflectionObject.prototype.getOption = function getOption(name) {
    if (this.options)
        return this.options[name];
    return undefined;
};

/**
 * Sets an option.
 * @param {string} name Option name
 * @param {*} value Option value
 * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (!ifNotSet || !this.options || this.options[name] === undefined)
        (this.options || (this.options = {}))[name] = value;
    return this;
};

/**
 * Sets a parsed option.
 * @param {string} name parsed Option name
 * @param {*} value Option value
 * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\empty, will add a new option with that value
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
    if (!this.parsedOptions) {
        this.parsedOptions = [];
    }
    var parsedOptions = this.parsedOptions;
    if (propName) {
        // If setting a sub property of an option then try to merge it
        // with an existing option
        var opt = parsedOptions.find(function (opt) {
            return Object.prototype.hasOwnProperty.call(opt, name);
        });
        if (opt) {
            // If we found an existing option - just merge the property value
            var newValue = opt[name];
            util.setProperty(newValue, propName, value);
        } else {
            // otherwise, create a new option, set it's property and add it to the list
            opt = {};
            opt[name] = util.setProperty({}, propName, value);
            parsedOptions.push(opt);
        }
    } else {
        // Always create a new option when setting the value of the option itself
        var newOpt = {};
        newOpt[name] = value;
        parsedOptions.push(newOpt);
    }
    return this;
};

/**
 * Sets multiple options.
 * @param {Object.<string,*>} options Options to set
 * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
    if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
            this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
};

/**
 * Converts this instance to its string representation.
 * @returns {string} Class name[, space, full name]
 */
ReflectionObject.prototype.toString = function toString() {
    var className = this.constructor.className,
        fullName  = this.fullName;
    if (fullName.length)
        return className + " " + fullName;
    return className;
};

// Sets up cyclic dependencies (called in index-light)
ReflectionObject._configure = function(Root_) {
    Root = Root_;
};
"use strict";
module.exports = OneOf;

// extends ReflectionObject
var ReflectionObject = require("./object");
((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

var Field = require("./field"),
    util  = require("./util");

/**
 * Constructs a new oneof instance.
 * @classdesc Reflected oneof.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Oneof name
 * @param {string[]|Object.<string,*>} [fieldNames] Field names
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function OneOf(name, fieldNames, options, comment) {
    if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = undefined;
    }
    ReflectionObject.call(this, name, options);

    /* istanbul ignore if */
    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");

    /**
     * Field names that belong to this oneof.
     * @type {string[]}
     */
    this.oneof = fieldNames || []; // toJSON, marker

    /**
     * Fields that belong to this oneof as an array for iteration.
     * @type {Field[]}
     * @readonly
     */
    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Oneof descriptor.
 * @interface IOneOf
 * @property {Array.<string>} oneof Oneof field names
 * @property {Object.<string,*>} [options] Oneof options
 */

/**
 * Constructs a oneof from a oneof descriptor.
 * @param {string} name Oneof name
 * @param {IOneOf} json Oneof descriptor
 * @returns {OneOf} Created oneof
 * @throws {TypeError} If arguments are invalid
 */
OneOf.fromJSON = function fromJSON(name, json) {
    return new OneOf(name, json.oneof, json.options, json.comment);
};

/**
 * Converts this oneof to a oneof descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IOneOf} Oneof descriptor
 */
OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , this.options,
        "oneof"   , this.oneof,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Adds the fields of the specified oneof to the parent if not already done so.
 * @param {OneOf} oneof The oneof
 * @returns {undefined}
 * @inner
 * @ignore
 */
function addFieldsToParent(oneof) {
    if (oneof.parent)
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
            if (!oneof.fieldsArray[i].parent)
                oneof.parent.add(oneof.fieldsArray[i]);
}

/**
 * Adds a field to this oneof and removes it from its current parent, if any.
 * @param {Field} field Field to add
 * @returns {OneOf} `this`
 */
OneOf.prototype.add = function add(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
    this.oneof.push(field.name);
    this.fieldsArray.push(field);
    field.partOf = this; // field.parent remains null
    addFieldsToParent(this);
    return this;
};

/**
 * Removes a field from this oneof and puts it back to the oneof's parent.
 * @param {Field} field Field to remove
 * @returns {OneOf} `this`
 */
OneOf.prototype.remove = function remove(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    var index = this.fieldsArray.indexOf(field);

    /* istanbul ignore if */
    if (index < 0)
        throw Error(field + " is not a member of " + this);

    this.fieldsArray.splice(index, 1);
    index = this.oneof.indexOf(field.name);

    /* istanbul ignore else */
    if (index > -1) // theoretical
        this.oneof.splice(index, 1);

    field.partOf = null;
    return this;
};

/**
 * @override
 */
OneOf.prototype.onAdd = function onAdd(parent) {
    ReflectionObject.prototype.onAdd.call(this, parent);
    var self = this;
    // Collect present fields
    for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
            field.partOf = self;
            self.fieldsArray.push(field);
        }
    }
    // Add not yet present fields
    addFieldsToParent(this);
};

/**
 * @override
 */
OneOf.prototype.onRemove = function onRemove(parent) {
    for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
            field.parent.remove(field);
    ReflectionObject.prototype.onRemove.call(this, parent);
};

/**
 * Decorator function as returned by {@link OneOf.d} (TypeScript).
 * @typedef OneOfDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} oneofName OneOf name
 * @returns {undefined}
 */

/**
 * OneOf decorator (TypeScript).
 * @function
 * @param {...string} fieldNames Field names
 * @returns {OneOfDecorator} Decorator function
 * @template T extends string
 */
OneOf.d = function decorateOneOf() {
    var fieldNames = new Array(arguments.length),
        index = 0;
    while (index < arguments.length)
        fieldNames[index] = arguments[index++];
    return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor)
            .add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
            get: util.oneOfGetter(fieldNames),
            set: util.oneOfSetter(fieldNames)
        });
    };
};
"use strict";
module.exports = parse;

parse.filename = null;
parse.defaults = { keepCase: false };

var tokenize  = require("./tokenize"),
    Root      = require("./root"),
    Type      = require("./type"),
    Field     = require("./field"),
    MapField  = require("./mapfield"),
    OneOf     = require("./oneof"),
    Enum      = require("./enum"),
    Service   = require("./service"),
    Method    = require("./method"),
    types     = require("./types"),
    util      = require("./util");

var base10Re    = /^[1-9][0-9]*$/,
    base10NegRe = /^-?[1-9][0-9]*$/,
    base16Re    = /^0[x][0-9a-fA-F]+$/,
    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,
    base8Re     = /^0[0-7]+$/,
    base8NegRe  = /^-?0[0-7]+$/,
    numberRe    = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
    typeRefRe   = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,
    fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;

/**
 * Result object returned from {@link parse}.
 * @interface IParserResult
 * @property {string|undefined} package Package name, if declared
 * @property {string[]|undefined} imports Imports, if any
 * @property {string[]|undefined} weakImports Weak imports, if any
 * @property {string|undefined} syntax Syntax, if specified (either `"proto2"` or `"proto3"`)
 * @property {Root} root Populated root instance
 */

/**
 * Options modifying the behavior of {@link parse}.
 * @interface IParseOptions
 * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case
 * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.
 * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.
 */

/**
 * Options modifying the behavior of JSON serialization.
 * @interface IToJSONOptions
 * @property {boolean} [keepComments=false] Serializes comments.
 */

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @param {string} source Source contents
 * @param {Root} root Root to populate
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 */
function parse(source, root, options) {
    /* eslint-disable callback-return */
    if (!(root instanceof Root)) {
        options = root;
        root = new Root();
    }
    if (!options)
        options = parse.defaults;

    var preferTrailingComment = options.preferTrailingComment || false;
    var tn = tokenize(source, options.alternateCommentMode || false),
        next = tn.next,
        push = tn.push,
        peek = tn.peek,
        skip = tn.skip,
        cmnt = tn.cmnt;

    var head = true,
        pkg,
        imports,
        weakImports,
        syntax,
        isProto3 = false;

    var ptr = root;

    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;

    /* istanbul ignore next */
    function illegal(token, name, insideTryCatch) {
        var filename = parse.filename;
        if (!insideTryCatch)
            parse.filename = null;
        return Error("illegal " + (name || "token") + " '" + token + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
    }

    function readString() {
        var values = [],
            token;
        do {
            /* istanbul ignore if */
            if ((token = next()) !== "\"" && token !== "'")
                throw illegal(token);

            values.push(next());
            skip(token);
            token = peek();
        } while (token === "\"" || token === "'");
        return values.join("");
    }

    function readValue(acceptTypeRef) {
        var token = next();
        switch (token) {
            case "'":
            case "\"":
                push(token);
                return readString();
            case "true": case "TRUE":
                return true;
            case "false": case "FALSE":
                return false;
        }
        try {
            return parseNumber(token, /* insideTryCatch */ true);
        } catch (e) {

            /* istanbul ignore else */
            if (acceptTypeRef && typeRefRe.test(token))
                return token;

            /* istanbul ignore next */
            throw illegal(token, "value");
        }
    }

    function readRanges(target, acceptStrings) {
        var token, start;
        do {
            if (acceptStrings && ((token = peek()) === "\"" || token === "'"))
                target.push(readString());
            else
                target.push([ start = parseId(next()), skip("to", true) ? parseId(next()) : start ]);
        } while (skip(",", true));
        var dummy = {options: undefined};
        dummy.setOption = function(name, value) {
          if (this.options === undefined) this.options = {};
          this.options[name] = value;
        };
        ifBlock(
            dummy,
            function parseRange_block(token) {
              /* istanbul ignore else */
              if (token === "option") {
                parseOption(dummy, token);  // skip
                skip(";");
              } else
                throw illegal(token);
            },
            function parseRange_line() {
              parseInlineOptions(dummy);  // skip
            });
    }

    function parseNumber(token, insideTryCatch) {
        var sign = 1;
        if (token.charAt(0) === "-") {
            sign = -1;
            token = token.substring(1);
        }
        switch (token) {
            case "inf": case "INF": case "Inf":
                return sign * Infinity;
            case "nan": case "NAN": case "Nan": case "NaN":
                return NaN;
            case "0":
                return 0;
        }
        if (base10Re.test(token))
            return sign * parseInt(token, 10);
        if (base16Re.test(token))
            return sign * parseInt(token, 16);
        if (base8Re.test(token))
            return sign * parseInt(token, 8);

        /* istanbul ignore else */
        if (numberRe.test(token))
            return sign * parseFloat(token);

        /* istanbul ignore next */
        throw illegal(token, "number", insideTryCatch);
    }

    function parseId(token, acceptNegative) {
        switch (token) {
            case "max": case "MAX": case "Max":
                return 536870911;
            case "0":
                return 0;
        }

        /* istanbul ignore if */
        if (!acceptNegative && token.charAt(0) === "-")
            throw illegal(token, "id");

        if (base10NegRe.test(token))
            return parseInt(token, 10);
        if (base16NegRe.test(token))
            return parseInt(token, 16);

        /* istanbul ignore else */
        if (base8NegRe.test(token))
            return parseInt(token, 8);

        /* istanbul ignore next */
        throw illegal(token, "id");
    }

    function parsePackage() {

        /* istanbul ignore if */
        if (pkg !== undefined)
            throw illegal("package");

        pkg = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(pkg))
            throw illegal(pkg, "name");

        ptr = ptr.define(pkg);
        skip(";");
    }

    function parseImport() {
        var token = peek();
        var whichImports;
        switch (token) {
            case "weak":
                whichImports = weakImports || (weakImports = []);
                next();
                break;
            case "public":
                next();
                // eslint-disable-next-line no-fallthrough
            default:
                whichImports = imports || (imports = []);
                break;
        }
        token = readString();
        skip(";");
        whichImports.push(token);
    }

    function parseSyntax() {
        skip("=");
        syntax = readString();
        isProto3 = syntax === "proto3";

        /* istanbul ignore if */
        if (!isProto3 && syntax !== "proto2")
            throw illegal(syntax, "syntax");

        skip(";");
    }

    function parseCommon(parent, token) {
        switch (token) {

            case "option":
                parseOption(parent, token);
                skip(";");
                return true;

            case "message":
                parseType(parent, token);
                return true;

            case "enum":
                parseEnum(parent, token);
                return true;

            case "service":
                parseService(parent, token);
                return true;

            case "extend":
                parseExtension(parent, token);
                return true;
        }
        return false;
    }

    function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
            if(typeof obj.comment !== "string") {
              obj.comment = cmnt(); // try block-type comment
            }
            obj.filename = parse.filename;
        }
        if (skip("{", true)) {
            var token;
            while ((token = next()) !== "}")
                fnIf(token);
            skip(";", true);
        } else {
            if (fnElse)
                fnElse();
            skip(";");
            if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
                obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment
        }
    }

    function parseType(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "type name");

        var type = new Type(token);
        ifBlock(type, function parseType_block(token) {
            if (parseCommon(type, token))
                return;

            switch (token) {

                case "map":
                    parseMapField(type, token);
                    break;

                case "required":
                case "repeated":
                    parseField(type, token);
                    break;

                case "optional":
                    /* istanbul ignore if */
                    if (isProto3) {
                        parseField(type, "proto3_optional");
                    } else {
                        parseField(type, "optional");
                    }
                    break;

                case "oneof":
                    parseOneOf(type, token);
                    break;

                case "extensions":
                    readRanges(type.extensions || (type.extensions = []));
                    break;

                case "reserved":
                    readRanges(type.reserved || (type.reserved = []), true);
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);

                    push(token);
                    parseField(type, "optional");
                    break;
            }
        });
        parent.add(type);
    }

    function parseField(parent, rule, extend) {
        var type = next();
        if (type === "group") {
            parseGroup(parent, rule);
            return;
        }
        // Type names can consume multiple tokens, in multiple variants:
        //    package.subpackage   field       tokens: "package.subpackage" [TYPE NAME ENDS HERE] "field"
        //    package . subpackage field       tokens: "package" "." "subpackage" [TYPE NAME ENDS HERE] "field"
        //    package.  subpackage field       tokens: "package." "subpackage" [TYPE NAME ENDS HERE] "field"
        //    package  .subpackage field       tokens: "package" ".subpackage" [TYPE NAME ENDS HERE] "field"
        // Keep reading tokens until we get a type name with no period at the end,
        // and the next token does not start with a period.
        while (type.endsWith(".") || peek().startsWith(".")) {
            type += next();
        }

        /* istanbul ignore if */
        if (!typeRefRe.test(type))
            throw illegal(type, "type");

        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        name = applyCase(name);
        skip("=");

        var field = new Field(name, parseId(next()), type, rule, extend);
        ifBlock(field, function parseField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseField_line() {
            parseInlineOptions(field);
        });

        if (rule === "proto3_optional") {
            // for proto3 optional fields, we create a single-member Oneof to mimic "optional" behavior
            var oneof = new OneOf("_" + name);
            field.setOption("proto3_optional", true);
            oneof.add(field);
            parent.add(oneof);
        } else {
            parent.add(field);
        }

        // JSON defaults to packed=true if not set so we have to set packed=false explicity when
        // parsing proto2 descriptors without the option, where applicable. This must be done for
        // all known packable types and anything that could be an enum (= is not a basic type).
        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))
            field.setOption("packed", false, /* ifNotSet */ true);
    }

    function parseGroup(parent, rule) {
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        var fieldName = util.lcFirst(name);
        if (name === fieldName)
            name = util.ucFirst(name);
        skip("=");
        var id = parseId(next());
        var type = new Type(name);
        type.group = true;
        var field = new Field(fieldName, id, name, rule);
        field.filename = parse.filename;
        ifBlock(type, function parseGroup_block(token) {
            switch (token) {

                case "option":
                    parseOption(type, token);
                    skip(";");
                    break;

                case "required":
                case "repeated":
                    parseField(type, token);
                    break;

                case "optional":
                    /* istanbul ignore if */
                    if (isProto3) {
                        parseField(type, "proto3_optional");
                    } else {
                        parseField(type, "optional");
                    }
                    break;

                case "message":
                    parseType(type, token);
                    break;

                case "enum":
                    parseEnum(type, token);
                    break;

                /* istanbul ignore next */
                default:
                    throw illegal(token); // there are no groups with proto3 semantics
            }
        });
        parent.add(type)
              .add(field);
    }

    function parseMapField(parent) {
        skip("<");
        var keyType = next();

        /* istanbul ignore if */
        if (types.mapKey[keyType] === undefined)
            throw illegal(keyType, "type");

        skip(",");
        var valueType = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(valueType))
            throw illegal(valueType, "type");

        skip(">");
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        skip("=");
        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseMapField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);
    }

    function parseOneOf(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var oneof = new OneOf(applyCase(token));
        ifBlock(oneof, function parseOneOf_block(token) {
            if (token === "option") {
                parseOption(oneof, token);
                skip(";");
            } else {
                push(token);
                parseField(oneof, "optional");
            }
        });
        parent.add(oneof);
    }

    function parseEnum(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var enm = new Enum(token);
        ifBlock(enm, function parseEnum_block(token) {
          switch(token) {
            case "option":
              parseOption(enm, token);
              skip(";");
              break;

            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              break;

            default:
              parseEnumValue(enm, token);
          }
        });
        parent.add(enm);
    }

    function parseEnumValue(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token))
            throw illegal(token, "name");

        skip("=");
        var value = parseId(next(), true),
            dummy = {
                options: undefined
            };
        dummy.setOption = function(name, value) {
            if (this.options === undefined)
                this.options = {};
            this.options[name] = value;
        };
        ifBlock(dummy, function parseEnumValue_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(dummy, token); // skip
                skip(";");
            } else
                throw illegal(token);

        }, function parseEnumValue_line() {
            parseInlineOptions(dummy); // skip
        });
        parent.add(token, value, dummy.comment, dummy.options);
    }

    function parseOption(parent, token) {
        var isCustom = skip("(", true);

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "name");

        var name = token;
        var option = name;
        var propName;

        if (isCustom) {
            skip(")");
            name = "(" + name + ")";
            option = name;
            token = peek();
            if (fqTypeRefRe.test(token)) {
                propName = token.slice(1); //remove '.' before property name
                name += token;
                next();
            }
        }
        skip("=");
        var optionValue = parseOptionValue(parent, name);
        setParsedOption(parent, option, optionValue, propName);
    }

    function parseOptionValue(parent, name) {
        // { a: "foo" b { c: "bar" } }
        if (skip("{", true)) {
            var objectResult = {};

            while (!skip("}", true)) {
                /* istanbul ignore if */
                if (!nameRe.test(token = next())) {
                    throw illegal(token, "name");
                }
                if (token === null) {
                  throw illegal(token, "end of input");
                }

                var value;
                var propName = token;

                skip(":", true);

                if (peek() === "{")
                    value = parseOptionValue(parent, name + "." + token);
                else if (peek() === "[") {
                    // option (my_option) = {
                    //     repeated_value: [ "foo", "bar" ]
                    // };
                    value = [];
                    var lastValue;
                    if (skip("[", true)) {
                        do {
                            lastValue = readValue(true);
                            value.push(lastValue);
                        } while (skip(",", true));
                        skip("]");
                        if (typeof lastValue !== "undefined") {
                            setOption(parent, name + "." + token, lastValue);
                        }
                    }
                } else {
                    value = readValue(true);
                    setOption(parent, name + "." + token, value);
                }

                var prevValue = objectResult[propName];

                if (prevValue)
                    value = [].concat(prevValue).concat(value);

                objectResult[propName] = value;

                // Semicolons and commas can be optional
                skip(",", true);
                skip(";", true);
            }

            return objectResult;
        }

        var simpleValue = readValue(true);
        setOption(parent, name, simpleValue);
        return simpleValue;
        // Does not enforce a delimiter to be universal
    }

    function setOption(parent, name, value) {
        if (parent.setOption)
            parent.setOption(name, value);
    }

    function setParsedOption(parent, name, value, propName) {
        if (parent.setParsedOption)
            parent.setParsedOption(name, value, propName);
    }

    function parseInlineOptions(parent) {
        if (skip("[", true)) {
            do {
                parseOption(parent, "option");
            } while (skip(",", true));
            skip("]");
        }
        return parent;
    }

    function parseService(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "service name");

        var service = new Service(token);
        ifBlock(service, function parseService_block(token) {
            if (parseCommon(service, token))
                return;

            /* istanbul ignore else */
            if (token === "rpc")
                parseMethod(service, token);
            else
                throw illegal(token);
        });
        parent.add(service);
    }

    function parseMethod(parent, token) {
        // Get the comment of the preceding line now (if one exists) in case the
        // method is defined across multiple lines.
        var commentText = cmnt();

        var type = token;

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var name = token,
            requestType, requestStream,
            responseType, responseStream;

        skip("(");
        if (skip("stream", true))
            requestStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        requestType = token;
        skip(")"); skip("returns"); skip("(");
        if (skip("stream", true))
            responseStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        responseType = token;
        skip(")");

        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
        method.comment = commentText;
        ifBlock(method, function parseMethod_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(method, token);
                skip(";");
            } else
                throw illegal(token);

        });
        parent.add(method);
    }

    function parseExtension(parent, token) {

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "reference");

        var reference = token;
        ifBlock(null, function parseExtension_block(token) {
            switch (token) {

                case "required":
                case "repeated":
                    parseField(parent, token, reference);
                    break;

                case "optional":
                    /* istanbul ignore if */
                    if (isProto3) {
                        parseField(parent, "proto3_optional", reference);
                    } else {
                        parseField(parent, "optional", reference);
                    }
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);
                    push(token);
                    parseField(parent, "optional", reference);
                    break;
            }
        });
    }

    var token;
    while ((token = next()) !== null) {
        switch (token) {

            case "package":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parsePackage();
                break;

            case "import":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseImport();
                break;

            case "syntax":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseSyntax();
                break;

            case "option":

                parseOption(ptr, token);
                skip(";");
                break;

            default:

                /* istanbul ignore else */
                if (parseCommon(ptr, token)) {
                    head = false;
                    continue;
                }

                /* istanbul ignore next */
                throw illegal(token);
        }
    }

    parse.filename = null;
    return {
        "package"     : pkg,
        "imports"     : imports,
         weakImports  : weakImports,
         syntax       : syntax,
         root         : root
    };
}

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @name parse
 * @function
 * @param {string} source Source contents
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 * @variation 2
 */
"use strict";
module.exports = BufferReader;

// extends Reader
var Reader = require("./reader");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = require("./util/minimal");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();
"use strict";
module.exports = Reader;

var util      = require("./util/minimal");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);

    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1
        var nativeBuffer = util.Buffer;
        return nativeBuffer
            ? nativeBuffer.alloc(0)
            : new this.buf.constructor(0);
    }
    return this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};
"use strict";
module.exports = Root;

// extends Namespace
var Namespace = require("./namespace");
((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

var Field   = require("./field"),
    Enum    = require("./enum"),
    OneOf   = require("./oneof"),
    util    = require("./util");

var Type,   // cyclic
    parse,  // might be excluded
    common; // "

/**
 * Constructs a new root namespace instance.
 * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
 * @extends NamespaceBase
 * @constructor
 * @param {Object.<string,*>} [options] Top level options
 */
function Root(options) {
    Namespace.call(this, "", options);

    /**
     * Deferred extension fields.
     * @type {Field[]}
     */
    this.deferred = [];

    /**
     * Resolved file names of loaded files.
     * @type {string[]}
     */
    this.files = [];
}

/**
 * Loads a namespace descriptor into a root namespace.
 * @param {INamespace} json Nameespace descriptor
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted
 * @returns {Root} Root namespace
 */
Root.fromJSON = function fromJSON(json, root) {
    if (!root)
        root = new Root();
    if (json.options)
        root.setOptions(json.options);
    return root.addJSON(json.nested);
};

/**
 * Resolves the path of an imported file, relative to the importing origin.
 * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
 * @function
 * @param {string} origin The file name of the importing file
 * @param {string} target The file name being imported
 * @returns {string|null} Resolved path to `target` or `null` to skip the file
 */
Root.prototype.resolvePath = util.path.resolve;

/**
 * Fetch content from file path or url
 * This method exists so you can override it with your own logic.
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.fetch = util.fetch;

// A symbol-like function to safely signal synchronous loading
/* istanbul ignore next */
function SYNC() {} // eslint-disable-line no-empty-function

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} options Parse options
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.load = function load(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    var self = this;
    if (!callback)
        return util.asPromise(load, self, filename, options);

    var sync = callback === SYNC; // undocumented

    // Finishes loading by calling the callback (exactly once)
    function finish(err, root) {
        /* istanbul ignore if */
        if (!callback)
            return;
        if (sync)
            throw err;
        var cb = callback;
        callback = null;
        cb(err, root);
    }

    // Bundled definition existence checking
    function getBundledFileName(filename) {
        var idx = filename.lastIndexOf("google/protobuf/");
        if (idx > -1) {
            var altname = filename.substring(idx);
            if (altname in common) return altname;
        }
        return null;
    }

    // Processes a single file
    function process(filename, source) {
        try {
            if (util.isString(source) && source.charAt(0) === "{")
                source = JSON.parse(source);
            if (!util.isString(source))
                self.setOptions(source.options).addJSON(source.nested);
            else {
                parse.filename = filename;
                var parsed = parse(source, self, options),
                    resolved,
                    i = 0;
                if (parsed.imports)
                    for (; i < parsed.imports.length; ++i)
                        if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i]))
                            fetch(resolved);
                if (parsed.weakImports)
                    for (i = 0; i < parsed.weakImports.length; ++i)
                        if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i]))
                            fetch(resolved, true);
            }
        } catch (err) {
            finish(err);
        }
        if (!sync && !queued)
            finish(null, self); // only once anyway
    }

    // Fetches a single file
    function fetch(filename, weak) {
        filename = getBundledFileName(filename) || filename;

        // Skip if already loaded / attempted
        if (self.files.indexOf(filename) > -1)
            return;
        self.files.push(filename);

        // Shortcut bundled definitions
        if (filename in common) {
            if (sync)
                process(filename, common[filename]);
            else {
                ++queued;
                setTimeout(function() {
                    --queued;
                    process(filename, common[filename]);
                });
            }
            return;
        }

        // Otherwise fetch from disk or network
        if (sync) {
            var source;
            try {
                source = util.fs.readFileSync(filename).toString("utf8");
            } catch (err) {
                if (!weak)
                    finish(err);
                return;
            }
            process(filename, source);
        } else {
            ++queued;
            self.fetch(filename, function(err, source) {
                --queued;
                /* istanbul ignore if */
                if (!callback)
                    return; // terminated meanwhile
                if (err) {
                    /* istanbul ignore else */
                    if (!weak)
                        finish(err);
                    else if (!queued) // can't be covered reliably
                        finish(null, self);
                    return;
                }
                process(filename, source);
            });
        }
    }
    var queued = 0;

    // Assembling the root namespace doesn't require working type
    // references anymore, so we can load everything in parallel
    if (util.isString(filename))
        filename = [ filename ];
    for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self.resolvePath("", filename[i]))
            fetch(resolved);

    if (sync)
        return self;
    if (!queued)
        finish(null, self);
    return undefined;
};
// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Promise<Root>} Promise
 * @variation 3
 */
// function load(filename:string, [options:IParseOptions]):Promise<Root>

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
 * @function Root#loadSync
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 */
Root.prototype.loadSync = function loadSync(filename, options) {
    if (!util.isNode)
        throw Error("not supported");
    return this.load(filename, options, SYNC);
};

/**
 * @override
 */
Root.prototype.resolveAll = function resolveAll() {
    if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
            return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
    return Namespace.prototype.resolveAll.call(this);
};

// only uppercased (and thus conflict-free) children are exposed, see below
var exposeRe = /^[A-Z]/;

/**
 * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
 * @param {Root} root Root instance
 * @param {Field} field Declaring extension field witin the declaring type
 * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
 * @inner
 * @ignore
 */
function tryHandleExtension(root, field) {
    var extendedType = field.parent.lookup(field.extend);
    if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
        //do not allow to extend same field twice to prevent the error
        if (extendedType.get(sisterField.name)) {
            return true;
        }
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
    }
    return false;
}

/**
 * Called when any object is added to this root or its sub-namespaces.
 * @param {ReflectionObject} object Object added
 * @returns {undefined}
 * @private
 */
Root.prototype._handleAdd = function _handleAdd(object) {
    if (object instanceof Field) {

        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)
            if (!tryHandleExtension(this, object))
                this.deferred.push(object);

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            object.parent[object.name] = object.values; // expose enum values as property of its parent

    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {

        if (object instanceof Type) // Try to handle any deferred extensions
            for (var i = 0; i < this.deferred.length;)
                if (tryHandleExtension(this, this.deferred[i]))
                    this.deferred.splice(i, 1);
                else
                    ++i;
        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace
            this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
            object.parent[object.name] = object; // expose namespace as property of its parent
    }

    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
    // properties of namespaces just like static code does. This allows using a .d.ts generated for
    // a static module with reflection-based solutions where the condition is met.
};

/**
 * Called when any object is removed from this root or its sub-namespaces.
 * @param {ReflectionObject} object Object removed
 * @returns {undefined}
 * @private
 */
Root.prototype._handleRemove = function _handleRemove(object) {
    if (object instanceof Field) {

        if (/* an extension field */ object.extend !== undefined) {
            if (/* already handled */ object.extensionField) { // remove its sister field
                object.extensionField.parent.remove(object.extensionField);
                object.extensionField = null;
            } else { // cancel the extension
                var index = this.deferred.indexOf(object);
                /* istanbul ignore else */
                if (index > -1)
                    this.deferred.splice(index, 1);
            }
        }

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose enum values

    } else if (object instanceof Namespace) {

        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace
            this._handleRemove(object._nestedArray[i]);

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose namespaces

    }
};

// Sets up cyclic dependencies (called in index-light)
Root._configure = function(Type_, parse_, common_) {
    Type   = Type_;
    parse  = parse_;
    common = common_;
};
"use strict";
module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available across modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = require("./rpc/service");
"use strict";
module.exports = Service;

var util = require("../util/minimal");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};
"use strict";
module.exports = Service;

// extends Namespace
var Namespace = require("./namespace");
((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

var Method = require("./method"),
    util   = require("./util"),
    rpc    = require("./rpc");

/**
 * Constructs a new service instance.
 * @classdesc Reflected service.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Service name
 * @param {Object.<string,*>} [options] Service options
 * @throws {TypeError} If arguments are invalid
 */
function Service(name, options) {
    Namespace.call(this, name, options);

    /**
     * Service methods.
     * @type {Object.<string,Method>}
     */
    this.methods = {}; // toJSON, marker

    /**
     * Cached methods as an array.
     * @type {Method[]|null}
     * @private
     */
    this._methodsArray = null;
}

/**
 * Service descriptor.
 * @interface IService
 * @extends INamespace
 * @property {Object.<string,IMethod>} methods Method descriptors
 */

/**
 * Constructs a service from a service descriptor.
 * @param {string} name Service name
 * @param {IService} json Service descriptor
 * @returns {Service} Created service
 * @throws {TypeError} If arguments are invalid
 */
Service.fromJSON = function fromJSON(name, json) {
    var service = new Service(name, json.options);
    /* istanbul ignore else */
    if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
            service.add(Method.fromJSON(names[i], json.methods[names[i]]));
    if (json.nested)
        service.addJSON(json.nested);
    service.comment = json.comment;
    return service;
};

/**
 * Converts this service to a service descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IService} Service descriptor
 */
Service.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , inherited && inherited.options || undefined,
        "methods" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},
        "nested"  , inherited && inherited.nested || undefined,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Methods of this service as an array for iteration.
 * @name Service#methodsArray
 * @type {Method[]}
 * @readonly
 */
Object.defineProperty(Service.prototype, "methodsArray", {
    get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
    }
});

function clearCache(service) {
    service._methodsArray = null;
    return service;
}

/**
 * @override
 */
Service.prototype.get = function get(name) {
    return util.getProp(this.methods, name)
        || Namespace.prototype.get.call(this, name);
};

/**
 * @override
 */
Service.prototype.resolveAll = function resolveAll() {
    var methods = this.methodsArray;
    for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
    return Namespace.prototype.resolve.call(this);
};

/**
 * @override
 */
Service.prototype.add = function add(object) {

    /* istanbul ignore if */
    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * @override
 */
Service.prototype.remove = function remove(object) {
    if (object instanceof Method) {

        /* istanbul ignore if */
        if (this.methods[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Creates a runtime service using the specified rpc implementation.
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
 */
Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r","c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
            m: method,
            q: method.resolvedRequestType.ctor,
            s: method.resolvedResponseType.ctor
        });
    }
    return rpcService;
};
"use strict";
module.exports = tokenize;

var delimRe        = /[\s{}=;:[\],'"()<>]/g,
    stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
    stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;

var setCommentRe = /^ *[*/]+ */,
    setCommentAltRe = /^\s*\*?\/*/,
    setCommentSplitRe = /\n/g,
    whitespaceRe = /\s/,
    unescapeRe = /\\(.?)/g;

var unescapeMap = {
    "0": "\0",
    "r": "\r",
    "n": "\n",
    "t": "\t"
};

/**
 * Unescapes a string.
 * @param {string} str String to unescape
 * @returns {string} Unescaped string
 * @property {Object.<string,string>} map Special characters map
 * @memberof tokenize
 */
function unescape(str) {
    return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
            case "\\":
            case "":
                return $1;
            default:
                return unescapeMap[$1] || "";
        }
    });
}

tokenize.unescape = unescape;

/**
 * Gets the next token and advances.
 * @typedef TokenizerHandleNext
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Peeks for the next token.
 * @typedef TokenizerHandlePeek
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Pushes a token back to the stack.
 * @typedef TokenizerHandlePush
 * @type {function}
 * @param {string} token Token
 * @returns {undefined}
 */

/**
 * Skips the next token.
 * @typedef TokenizerHandleSkip
 * @type {function}
 * @param {string} expected Expected token
 * @param {boolean} [optional=false] If optional
 * @returns {boolean} Whether the token matched
 * @throws {Error} If the token didn't match and is not optional
 */

/**
 * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
 * @typedef TokenizerHandleCmnt
 * @type {function}
 * @param {number} [line] Line number
 * @returns {string|null} Comment text or `null` if none
 */

/**
 * Handle object returned from {@link tokenize}.
 * @interface ITokenizerHandle
 * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)
 * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)
 * @property {TokenizerHandlePush} push Pushes a token back to the stack
 * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws
 * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any
 * @property {number} line Current line number
 */

/**
 * Tokenizes the given .proto source and returns an object with useful utility functions.
 * @param {string} source Source contents
 * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.
 * @returns {ITokenizerHandle} Tokenizer handle
 */
function tokenize(source, alternateCommentMode) {
    /* eslint-disable callback-return */
    source = source.toString();

    var offset = 0,
        length = source.length,
        line = 1,
        lastCommentLine = 0,
        comments = {};

    var stack = [];

    var stringDelim = null;

    /* istanbul ignore next */
    /**
     * Creates an error for illegal syntax.
     * @param {string} subject Subject
     * @returns {Error} Error created
     * @inner
     */
    function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
    }

    /**
     * Reads a string till its end.
     * @returns {string} String read
     * @inner
     */
    function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
            throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape(match[1]);
    }

    /**
     * Gets the character at `pos` within the source.
     * @param {number} pos Position
     * @returns {string} Character
     * @inner
     */
    function charAt(pos) {
        return source.charAt(pos);
    }

    /**
     * Sets the current comment text.
     * @param {number} start Start offset
     * @param {number} end End offset
     * @param {boolean} isLeading set if a leading comment
     * @returns {undefined}
     * @inner
     */
    function setComment(start, end, isLeading) {
        var comment = {
            type: source.charAt(start++),
            lineEmpty: false,
            leading: isLeading,
        };
        var lookback;
        if (alternateCommentMode) {
            lookback = 2;  // alternate comment parsing: "//" or "/*"
        } else {
            lookback = 3;  // "///" or "/**"
        }
        var commentOffset = start - lookback,
            c;
        do {
            if (--commentOffset < 0 ||
                    (c = source.charAt(commentOffset)) === "\n") {
                comment.lineEmpty = true;
                break;
            }
        } while (c === " " || c === "\t");
        var lines = source
            .substring(start, end)
            .split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
            lines[i] = lines[i]
                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "")
                .trim();
        comment.text = lines
            .join("\n")
            .trim();

        comments[line] = comment;
        lastCommentLine = line;
    }

    function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);

        // see if remaining line matches comment pattern
        var lineText = source.substring(startOffset, endOffset);
        var isComment = /^\s*\/\//.test(lineText);
        return isComment;
    }

    function findEndOfLine(cursor) {
        // find end of cursor's line
        var endOffset = cursor;
        while (endOffset < length && charAt(endOffset) !== "\n") {
            endOffset++;
        }
        return endOffset;
    }

    /**
     * Obtains the next token.
     * @returns {string|null} Next token or `null` on eof
     * @inner
     */
    function next() {
        if (stack.length > 0)
            return stack.shift();
        if (stringDelim)
            return readString();
        var repeat,
            prev,
            curr,
            start,
            isDoc,
            isLeadingComment = offset === 0;
        do {
            if (offset === length)
                return null;
            repeat = false;
            while (whitespaceRe.test(curr = charAt(offset))) {
                if (curr === "\n") {
                    isLeadingComment = true;
                    ++line;
                }
                if (++offset === length)
                    return null;
            }

            if (charAt(offset) === "/") {
                if (++offset === length) {
                    throw illegal("comment");
                }
                if (charAt(offset) === "/") { // Line
                    if (!alternateCommentMode) {
                        // check for triple-slash comment
                        isDoc = charAt(start = offset + 1) === "/";

                        while (charAt(++offset) !== "\n") {
                            if (offset === length) {
                                return null;
                            }
                        }
                        ++offset;
                        if (isDoc) {
                            setComment(start, offset - 1, isLeadingComment);
                            // Trailing comment cannot not be multi-line,
                            // so leading comment state should be reset to handle potential next comments
                            isLeadingComment = true;
                        }
                        ++line;
                        repeat = true;
                    } else {
                        // check for double-slash comments, consolidating consecutive lines
                        start = offset;
                        isDoc = false;
                        if (isDoubleSlashCommentLine(offset - 1)) {
                            isDoc = true;
                            do {
                                offset = findEndOfLine(offset);
                                if (offset === length) {
                                    break;
                                }
                                offset++;
                                if (!isLeadingComment) {
                                    // Trailing comment cannot not be multi-line
                                    break;
                                }
                            } while (isDoubleSlashCommentLine(offset));
                        } else {
                            offset = Math.min(length, findEndOfLine(offset) + 1);
                        }
                        if (isDoc) {
                            setComment(start, offset, isLeadingComment);
                            isLeadingComment = true;
                        }
                        line++;
                        repeat = true;
                    }
                } else if ((curr = charAt(offset)) === "*") { /* Block */
                    // check for /** (regular comment mode) or /* (alternate comment mode)
                    start = offset + 1;
                    isDoc = alternateCommentMode || charAt(start) === "*";
                    do {
                        if (curr === "\n") {
                            ++line;
                        }
                        if (++offset === length) {
                            throw illegal("comment");
                        }
                        prev = curr;
                        curr = charAt(offset);
                    } while (prev !== "*" || curr !== "/");
                    ++offset;
                    if (isDoc) {
                        setComment(start, offset - 2, isLeadingComment);
                        isLeadingComment = true;
                    }
                    repeat = true;
                } else {
                    return "/";
                }
            }
        } while (repeat);

        // offset !== length if we got here

        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
            while (end < length && !delimRe.test(charAt(end)))
                ++end;
        var token = source.substring(offset, offset = end);
        if (token === "\"" || token === "'")
            stringDelim = token;
        return token;
    }

    /**
     * Pushes a token back to the stack.
     * @param {string} token Token
     * @returns {undefined}
     * @inner
     */
    function push(token) {
        stack.push(token);
    }

    /**
     * Peeks for the next token.
     * @returns {string|null} Token or `null` on eof
     * @inner
     */
    function peek() {
        if (!stack.length) {
            var token = next();
            if (token === null)
                return null;
            push(token);
        }
        return stack[0];
    }

    /**
     * Skips a token.
     * @param {string} expected Expected token
     * @param {boolean} [optional=false] Whether the token is optional
     * @returns {boolean} `true` when skipped, `false` if not
     * @throws {Error} When a required token is not present
     * @inner
     */
    function skip(expected, optional) {
        var actual = peek(),
            equals = actual === expected;
        if (equals) {
            next();
            return true;
        }
        if (!optional)
            throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
    }

    /**
     * Gets a comment.
     * @param {number} [trailingLine] Line number if looking for a trailing comment
     * @returns {string|null} Comment text
     * @inner
     */
    function cmnt(trailingLine) {
        var ret = null;
        var comment;
        if (trailingLine === undefined) {
            comment = comments[line - 1];
            delete comments[line - 1];
            if (comment && (alternateCommentMode || comment.type === "*" || comment.lineEmpty)) {
                ret = comment.leading ? comment.text : null;
            }
        } else {
            /* istanbul ignore else */
            if (lastCommentLine < trailingLine) {
                peek();
            }
            comment = comments[trailingLine];
            delete comments[trailingLine];
            if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === "/")) {
                ret = comment.leading ? null : comment.text;
            }
        }
        return ret;
    }

    return Object.defineProperty({
        next: next,
        peek: peek,
        push: push,
        skip: skip,
        cmnt: cmnt
    }, "line", {
        get: function() { return line; }
    });
    /* eslint-enable callback-return */
}
"use strict";
module.exports = Type;

// extends Namespace
var Namespace = require("./namespace");
((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

var Enum      = require("./enum"),
    OneOf     = require("./oneof"),
    Field     = require("./field"),
    MapField  = require("./mapfield"),
    Service   = require("./service"),
    Message   = require("./message"),
    Reader    = require("./reader"),
    Writer    = require("./writer"),
    util      = require("./util"),
    encoder   = require("./encoder"),
    decoder   = require("./decoder"),
    verifier  = require("./verifier"),
    converter = require("./converter"),
    wrappers  = require("./wrappers");

/**
 * Constructs a new reflected message type instance.
 * @classdesc Reflected message type.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Message name
 * @param {Object.<string,*>} [options] Declared options
 */
function Type(name, options) {
    Namespace.call(this, name, options);

    /**
     * Message fields.
     * @type {Object.<string,Field>}
     */
    this.fields = {};  // toJSON, marker

    /**
     * Oneofs declared within this namespace, if any.
     * @type {Object.<string,OneOf>}
     */
    this.oneofs = undefined; // toJSON

    /**
     * Extension ranges, if any.
     * @type {number[][]}
     */
    this.extensions = undefined; // toJSON

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    /*?
     * Whether this type is a legacy group.
     * @type {boolean|undefined}
     */
    this.group = undefined; // toJSON

    /**
     * Cached fields by id.
     * @type {Object.<number,Field>|null}
     * @private
     */
    this._fieldsById = null;

    /**
     * Cached fields as an array.
     * @type {Field[]|null}
     * @private
     */
    this._fieldsArray = null;

    /**
     * Cached oneofs as an array.
     * @type {OneOf[]|null}
     * @private
     */
    this._oneofsArray = null;

    /**
     * Cached constructor.
     * @type {Constructor<{}>}
     * @private
     */
    this._ctor = null;
}

Object.defineProperties(Type.prototype, {

    /**
     * Message fields by id.
     * @name Type#fieldsById
     * @type {Object.<number,Field>}
     * @readonly
     */
    fieldsById: {
        get: function() {

            /* istanbul ignore if */
            if (this._fieldsById)
                return this._fieldsById;

            this._fieldsById = {};
            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
                var field = this.fields[names[i]],
                    id = field.id;

                /* istanbul ignore if */
                if (this._fieldsById[id])
                    throw Error("duplicate id " + id + " in " + this);

                this._fieldsById[id] = field;
            }
            return this._fieldsById;
        }
    },

    /**
     * Fields of this message as an array for iteration.
     * @name Type#fieldsArray
     * @type {Field[]}
     * @readonly
     */
    fieldsArray: {
        get: function() {
            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
    },

    /**
     * Oneofs of this message as an array for iteration.
     * @name Type#oneofsArray
     * @type {OneOf[]}
     * @readonly
     */
    oneofsArray: {
        get: function() {
            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
    },

    /**
     * The registered constructor, if any registered, otherwise a generic constructor.
     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
     * @name Type#ctor
     * @type {Constructor<{}>}
     */
    ctor: {
        get: function() {
            return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {

            // Ensure proper prototype
            var prototype = ctor.prototype;
            if (!(prototype instanceof Message)) {
                (ctor.prototype = new Message()).constructor = ctor;
                util.merge(ctor.prototype, prototype);
            }

            // Classes and messages reference their reflected type
            ctor.$type = ctor.prototype.$type = this;

            // Mix in static methods
            util.merge(ctor, Message, true);

            this._ctor = ctor;

            // Messages have non-enumerable default values on their prototype
            var i = 0;
            for (; i < /* initializes */ this.fieldsArray.length; ++i)
                this._fieldsArray[i].resolve(); // ensures a proper value

            // Messages have non-enumerable getters and setters for each virtual oneof field
            var ctorProperties = {};
            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)
                ctorProperties[this._oneofsArray[i].resolve().name] = {
                    get: util.oneOfGetter(this._oneofsArray[i].oneof),
                    set: util.oneOfSetter(this._oneofsArray[i].oneof)
                };
            if (i)
                Object.defineProperties(ctor.prototype, ctorProperties);
        }
    }
});

/**
 * Generates a constructor function for the specified type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
Type.generateConstructor = function generateConstructor(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["p"], mtype.name);
    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map) gen
            ("this%s={}", util.safeProp(field.name));
        else if (field.repeated) gen
            ("this%s=[]", util.safeProp(field.name));
    return gen
    ("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
        ("this[ks[i]]=p[ks[i]]");
    /* eslint-enable no-unexpected-multiline */
};

function clearCache(type) {
    type._fieldsById = type._fieldsArray = type._oneofsArray = null;
    delete type.encode;
    delete type.decode;
    delete type.verify;
    return type;
}

/**
 * Message type descriptor.
 * @interface IType
 * @extends INamespace
 * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
 * @property {Object.<string,IField>} fields Field descriptors
 * @property {number[][]} [extensions] Extension ranges
 * @property {Array.<number[]|string>} [reserved] Reserved ranges
 * @property {boolean} [group=false] Whether a legacy group or not
 */

/**
 * Creates a message type from a message type descriptor.
 * @param {string} name Message name
 * @param {IType} json Message type descriptor
 * @returns {Type} Created message type
 */
Type.fromJSON = function fromJSON(name, json) {
    var type = new Type(name, json.options);
    type.extensions = json.extensions;
    type.reserved = json.reserved;
    var names = Object.keys(json.fields),
        i = 0;
    for (; i < names.length; ++i)
        type.add(
            ( typeof json.fields[names[i]].keyType !== "undefined"
            ? MapField.fromJSON
            : Field.fromJSON )(names[i], json.fields[names[i]])
        );
    if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
    if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
            var nested = json.nested[names[i]];
            type.add( // most to least likely
                ( nested.id !== undefined
                ? Field.fromJSON
                : nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
    if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
    if (json.group)
        type.group = true;
    if (json.comment)
        type.comment = json.comment;
    return type;
};

/**
 * Converts this message type to a message type descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IType} Message type descriptor
 */
Type.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"    , inherited && inherited.options || undefined,
        "oneofs"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},
        "extensions" , this.extensions && this.extensions.length ? this.extensions : undefined,
        "reserved"   , this.reserved && this.reserved.length ? this.reserved : undefined,
        "group"      , this.group || undefined,
        "nested"     , inherited && inherited.nested || undefined,
        "comment"    , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
Type.prototype.resolveAll = function resolveAll() {
    var fields = this.fieldsArray, i = 0;
    while (i < fields.length)
        fields[i++].resolve();
    var oneofs = this.oneofsArray; i = 0;
    while (i < oneofs.length)
        oneofs[i++].resolve();
    return Namespace.prototype.resolveAll.call(this);
};

/**
 * @override
 */
Type.prototype.get = function get(name) {
    return util.getProp(this.fields, name)
        || util.getProp(this.oneofs, name)
        || util.getProp(this.nested, name)
        || null;
};

/**
 * Adds a nested object to this type.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
 */
Type.prototype.add = function add(object) {

    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Field && object.extend === undefined) {
        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
        // The root object takes care of adding distinct sister-fields to the respective extended
        // type instead.

        // avoids calling the getter if not absolutely necessary because it's called quite frequently
        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])
            throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
            throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
            throw Error("name '" + object.name + "' is reserved in " + this);

        if (object.parent)
            object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {
        if (!this.oneofs)
            this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * Removes a nested object from this type.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this type
 */
Type.prototype.remove = function remove(object) {
    if (object instanceof Field && object.extend === undefined) {
        // See Type#add for the reason why extension fields are excluded here.

        /* istanbul ignore if */
        if (!this.fields || this.fields[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {

        /* istanbul ignore if */
        if (!this.oneofs || this.oneofs[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<{}>} Message instance
 */
Type.prototype.create = function create(properties) {
    return new this.ctor(properties);
};

/**
 * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
 * @returns {Type} `this`
 */
Type.prototype.setup = function setup() {
    // Sets up everything at once so that the prototype chain does not have to be re-evaluated
    // multiple times (V8, soft-deopt prototype-check).

    var fullName = this.fullName,
        types    = [];
    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);

    // Replace setup methods with type-specific generated functions
    this.encode = encoder(this)({
        Writer : Writer,
        types  : types,
        util   : util
    });
    this.decode = decoder(this)({
        Reader : Reader,
        types  : types,
        util   : util
    });
    this.verify = verifier(this)({
        types : types,
        util  : util
    });
    this.fromObject = converter.fromObject(this)({
        types : types,
        util  : util
    });
    this.toObject = converter.toObject(this)({
        types : types,
        util  : util
    });

    // Inject custom wrappers for common types
    var wrapper = wrappers[fullName];
    if (wrapper) {
        var originalThis = Object.create(this);
        // if (wrapper.fromObject) {
            originalThis.fromObject = this.fromObject;
            this.fromObject = wrapper.fromObject.bind(originalThis);
        // }
        // if (wrapper.toObject) {
            originalThis.toObject = this.toObject;
            this.toObject = wrapper.toObject.bind(originalThis);
        // }
    }

    return this;
};

/**
 * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encode = function encode_setup(message, writer) {
    return this.setup().encode(message, writer); // overrides this method
};

/**
 * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
};

/**
 * Decodes a message of this type.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @param {number} [length] Length of the message, if known beforehand
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError<{}>} If required fields are missing
 */
Type.prototype.decode = function decode_setup(reader, length) {
    return this.setup().decode(reader, length); // overrides this method
};

/**
 * Decodes a message of this type preceeded by its byte length as a varint.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError} If required fields are missing
 */
Type.prototype.decodeDelimited = function decodeDelimited(reader) {
    if (!(reader instanceof Reader))
        reader = Reader.create(reader);
    return this.decode(reader, reader.uint32());
};

/**
 * Verifies that field values are valid and that required fields are present.
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {null|string} `null` if valid, otherwise the reason why it is not
 */
Type.prototype.verify = function verify_setup(message) {
    return this.setup().verify(message); // overrides this method
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object to convert
 * @returns {Message<{}>} Message instance
 */
Type.prototype.fromObject = function fromObject(object) {
    return this.setup().fromObject(object);
};

/**
 * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
 * @interface IConversionOptions
 * @property {Function} [longs] Long conversion type.
 * Valid values are `String` and `Number` (the global types).
 * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
 * @property {Function} [enums] Enum value conversion type.
 * Only valid value is `String` (the global type).
 * Defaults to copy the present value, which is the numeric id.
 * @property {Function} [bytes] Bytes value conversion type.
 * Valid values are `Array` and (a base64 encoded) `String` (the global types).
 * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
 * @property {boolean} [defaults=false] Also sets default values on the resulting object
 * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
 * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
 * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
 * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
 */

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 */
Type.prototype.toObject = function toObject(message, options) {
    return this.setup().toObject(message, options);
};

/**
 * Decorator function as returned by {@link Type.d} (TypeScript).
 * @typedef TypeDecorator
 * @type {function}
 * @param {Constructor<T>} target Target constructor
 * @returns {undefined}
 * @template T extends Message<T>
 */

/**
 * Type decorator (TypeScript).
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {TypeDecorator<T>} Decorator function
 * @template T extends Message<T>
 */
Type.d = function decorateType(typeName) {
    return function typeDecorator(target) {
        util.decorateType(target, typeName);
    };
};
"use strict";

/**
 * Common type constants.
 * @namespace
 */
var types = exports;

var util = require("./util");

var s = [
    "double",   // 0
    "float",    // 1
    "int32",    // 2
    "uint32",   // 3
    "sint32",   // 4
    "fixed32",  // 5
    "sfixed32", // 6
    "int64",    // 7
    "uint64",   // 8
    "sint64",   // 9
    "fixed64",  // 10
    "sfixed64", // 11
    "bool",     // 12
    "string",   // 13
    "bytes"     // 14
];

function bake(values, offset) {
    var i = 0, o = {};
    offset |= 0;
    while (i < values.length) o[s[i + offset]] = values[i++];
    return o;
}

/**
 * Basic type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 * @property {number} bytes=2 Ldelim wire type
 */
types.basic = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2,
    /* bytes    */ 2
]);

/**
 * Basic type defaults.
 * @type {Object.<string,*>}
 * @const
 * @property {number} double=0 Double default
 * @property {number} float=0 Float default
 * @property {number} int32=0 Int32 default
 * @property {number} uint32=0 Uint32 default
 * @property {number} sint32=0 Sint32 default
 * @property {number} fixed32=0 Fixed32 default
 * @property {number} sfixed32=0 Sfixed32 default
 * @property {number} int64=0 Int64 default
 * @property {number} uint64=0 Uint64 default
 * @property {number} sint64=0 Sint32 default
 * @property {number} fixed64=0 Fixed64 default
 * @property {number} sfixed64=0 Sfixed64 default
 * @property {boolean} bool=false Bool default
 * @property {string} string="" String default
 * @property {Array.<number>} bytes=Array(0) Bytes default
 * @property {null} message=null Message default
 */
types.defaults = bake([
    /* double   */ 0,
    /* float    */ 0,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 0,
    /* sfixed32 */ 0,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 0,
    /* sfixed64 */ 0,
    /* bool     */ false,
    /* string   */ "",
    /* bytes    */ util.emptyArray,
    /* message  */ null
]);

/**
 * Basic long type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 */
types.long = bake([
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1
], 7);

/**
 * Allowed types for map keys with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 */
types.mapKey = bake([
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2
], 2);

/**
 * Allowed types for packed repeated fields with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 */
types.packed = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0
]);
/**
 * Constructor type.
 * @interface Constructor
 * @extends Function
 * @template T
 * @tstype new(...params: any[]): T; prototype: T;
 */

/**
 * Properties type.
 * @typedef Properties
 * @template T
 * @type {Object.<string,*>}
 * @tstype { [P in keyof T]?: T[P] }
 */
"use strict";

/**
 * Various utility functions.
 * @namespace
 */
var util = module.exports = require("./util/minimal");

var roots = require("./roots");

var Type, // cyclic
    Enum;

util.codegen = require("@protobufjs/codegen");
util.fetch   = require("@protobufjs/fetch");
util.path    = require("@protobufjs/path");

/**
 * Node's fs module if available.
 * @type {Object.<string,*>}
 */
util.fs = util.inquire("fs");

/**
 * Converts an object's values to an array.
 * @param {Object.<string,*>} object Object to convert
 * @returns {Array.<*>} Converted array
 */
util.toArray = function toArray(object) {
    if (object) {
        var keys  = Object.keys(object),
            array = new Array(keys.length),
            index = 0;
        while (index < keys.length)
            array[index] = object[keys[index++]];
        return array;
    }
    return [];
};

/**
 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
 * @param {Array.<*>} array Array to convert
 * @returns {Object.<string,*>} Converted object
 */
util.toObject = function toObject(array) {
    var object = {},
        index  = 0;
    while (index < array.length) {
        var key = array[index++],
            val = array[index++];
        if (val !== undefined)
            object[key] = val;
    }
    return object;
};

var safePropBackslashRe = /\\/g,
    safePropQuoteRe     = /"/g;

/**
 * Tests whether the specified name is a reserved word in JS.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
util.isReserved = function isReserved(name) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
};

/**
 * Returns a safe property accessor for the specified property name.
 * @param {string} prop Property name
 * @returns {string} Safe accessor
 */
util.safeProp = function safeProp(prop) {
    if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
    return "." + prop;
};

/**
 * Returns the value of a property found directly in a given object.
 * @param {Object} object Source object
 * @param {string} prop Property name
 * @returns {*} Value or `undefined` if not set
 */
util.getProp = function get(object, prop) {
    return object && Object.prototype.hasOwnProperty.call(object, prop) ? object[prop] : undefined;
};

/**
 * Converts the first character of a string to upper case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.ucFirst = function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
};

var camelCaseRe = /_([a-z])/g;

/**
 * Converts a string to camel case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.camelCase = function camelCase(str) {
    return str.substring(0, 1)
         + str.substring(1)
               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });
};

/**
 * Compares reflected fields by id.
 * @param {Field} a First field
 * @param {Field} b Second field
 * @returns {number} Comparison value
 */
util.compareFieldsById = function compareFieldsById(a, b) {
    return a.id - b.id;
};

/**
 * Decorator helper for types (TypeScript).
 * @param {Constructor<T>} ctor Constructor function
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {Type} Reflected type
 * @template T extends Message<T>
 * @property {Root} root Decorators root
 */
util.decorateType = function decorateType(ctor, typeName) {

    /* istanbul ignore if */
    if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
            util.decorateRoot.remove(ctor.$type);
            ctor.$type.name = typeName;
            util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
    }

    /* istanbul ignore next */
    if (!Type)
        Type = require("./type");

    var type = new Type(typeName || ctor.name);
    util.decorateRoot.add(type);
    type.ctor = ctor; // sets up .encode, .decode etc.
    Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
    Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
    return type;
};

var decorateEnumIndex = 0;

/**
 * Decorator helper for enums (TypeScript).
 * @param {Object} object Enum object
 * @returns {Enum} Reflected enum
 */
util.decorateEnum = function decorateEnum(object) {

    /* istanbul ignore if */
    if (object.$type)
        return object.$type;

    /* istanbul ignore next */
    if (!Enum)
        Enum = require("./enum");

    var enm = new Enum("Enum" + decorateEnumIndex++, object);
    util.decorateRoot.add(enm);
    Object.defineProperty(object, "$type", { value: enm, enumerable: false });
    return enm;
};


/**
 * Sets the value of a property by property path. If a value already exists, it is turned to an array
 * @param {Object.<string,*>} dst Destination object
 * @param {string} path dot '.' delimited path of the property to set
 * @param {Object} value the value to set
 * @returns {Object.<string,*>} Destination object
 */
util.setProperty = function setProperty(dst, path, value) {
    function setProp(dst, path, value) {
        var part = path.shift();
        if (part === "__proto__" || part === "prototype") {
          return dst;
        }
        if (path.length > 0) {
            dst[part] = setProp(dst[part] || {}, path, value);
        } else {
            var prevValue = dst[part];
            if (prevValue)
                value = [].concat(prevValue).concat(value);
            dst[part] = value;
        }
        return dst;
    }

    if (typeof dst !== "object")
        throw TypeError("dst must be an object");
    if (!path)
        throw TypeError("path must be specified");

    path = path.split(".");
    return setProp(dst, path, value);
};

/**
 * Decorator root (TypeScript).
 * @name util.decorateRoot
 * @type {Root}
 * @readonly
 */
Object.defineProperty(util, "decorateRoot", {
    get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require("./root"))());
    }
});
"use strict";
module.exports = LongBits;

var util = require("../util/minimal");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};
"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require("@protobufjs/aspromise");

// converts to / from base64 encoded strings
util.base64 = require("@protobufjs/base64");

// base class of rpc.Service
util.EventEmitter = require("@protobufjs/eventemitter");

// float handling accross browsers
util.float = require("@protobufjs/float");

// requires modules optionally and hides the call from bundlers
util.inquire = require("@protobufjs/inquire");

// converts to / from utf8 encoded strings
util.utf8 = require("@protobufjs/utf8");

// provides a node-like buffer pool in the browser
util.pool = require("@protobufjs/pool");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require("./longbits");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
            value: CustomError,
            writable: true,
            enumerable: false,
            configurable: true,
        },
        name: {
            get: function get() { return name; },
            set: undefined,
            enumerable: false,
            // configurable: false would accurately preserve the behavior of
            // the original, but I'm guessing that was not intentional.
            // For an actual error subclass, this property would
            // be configurable.
            configurable: true,
        },
        toString: {
            value: function value() { return this.name + ": " + this.message; },
            writable: true,
            enumerable: false,
            configurable: true,
        },
    });

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};
"use strict";
module.exports = verifier;

var Enum      = require("./enum"),
    util      = require("./util");

function invalid(field, expected) {
    return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:"+field.keyType+"}" : "") + " expected";
}

/**
 * Generates a partial value verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyValue(gen, field, fieldIndex, ref) {
    /* eslint-disable no-unexpected-multiline */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(%s){", ref)
                ("default:")
                    ("return%j", invalid(field, "enum value"));
            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen
                ("case %i:", field.resolvedType.values[keys[j]]);
            gen
                    ("break")
            ("}");
        } else {
            gen
            ("{")
                ("var e=types[%i].verify(%s);", fieldIndex, ref)
                ("if(e)")
                    ("return%j+e", field.name + ".")
            ("}");
        }
    } else {
        switch (field.type) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32": gen
                ("if(!util.isInteger(%s))", ref)
                    ("return%j", invalid(field, "integer"));
                break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)
                    ("return%j", invalid(field, "integer|Long"));
                break;
            case "float":
            case "double": gen
                ("if(typeof %s!==\"number\")", ref)
                    ("return%j", invalid(field, "number"));
                break;
            case "bool": gen
                ("if(typeof %s!==\"boolean\")", ref)
                    ("return%j", invalid(field, "boolean"));
                break;
            case "string": gen
                ("if(!util.isString(%s))", ref)
                    ("return%j", invalid(field, "string"));
                break;
            case "bytes": gen
                ("if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)
                    ("return%j", invalid(field, "buffer"));
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a partial key verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyKey(gen, field, ref) {
    /* eslint-disable no-unexpected-multiline */
    switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32": gen
            ("if(!util.key32Re.test(%s))", ref)
                ("return%j", invalid(field, "integer key"));
            break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64": gen
            ("if(!util.key64Re.test(%s))", ref) // see comment above: x is ok, d is not
                ("return%j", invalid(field, "integer|Long key"));
            break;
        case "bool": gen
            ("if(!util.key2Re.test(%s))", ref)
                ("return%j", invalid(field, "boolean key"));
            break;
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a verifier specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function verifier(mtype) {
    /* eslint-disable no-unexpected-multiline */

    var gen = util.codegen(["m"], mtype.name + "$verify")
    ("if(typeof m!==\"object\"||m===null)")
        ("return%j", "object expected");
    var oneofs = mtype.oneofsArray,
        seenFirstField = {};
    if (oneofs.length) gen
    ("var p={}");

    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            ref   = "m" + util.safeProp(field.name);

        if (field.optional) gen
        ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null

        // map fields
        if (field.map) { gen
            ("if(!util.isObject(%s))", ref)
                ("return%j", invalid(field, "object"))
            ("var k=Object.keys(%s)", ref)
            ("for(var i=0;i<k.length;++i){");
                genVerifyKey(gen, field, "k[i]");
                genVerifyValue(gen, field, i, ref + "[k[i]]")
            ("}");

        // repeated fields
        } else if (field.repeated) { gen
            ("if(!Array.isArray(%s))", ref)
                ("return%j", invalid(field, "array"))
            ("for(var i=0;i<%s.length;++i){", ref);
                genVerifyValue(gen, field, i, ref + "[i]")
            ("}");

        // required or present fields
        } else {
            if (field.partOf) {
                var oneofProp = util.safeProp(field.partOf.name);
                if (seenFirstField[field.partOf.name] === 1) gen
            ("if(p%s===1)", oneofProp)
                ("return%j", field.partOf.name + ": multiple values");
                seenFirstField[field.partOf.name] = 1;
                gen
            ("p%s=1", oneofProp);
            }
            genVerifyValue(gen, field, i, ref);
        }
        if (field.optional) gen
        ("}");
    }
    return gen
    ("return null");
    /* eslint-enable no-unexpected-multiline */
}"use strict";

/**
 * Wrappers for common types.
 * @type {Object.<string,IWrapper>}
 * @const
 */
var wrappers = exports;

var Message = require("./message");

/**
 * From object converter part of an {@link IWrapper}.
 * @typedef WrapperFromObjectConverter
 * @type {function}
 * @param {Object.<string,*>} object Plain object
 * @returns {Message<{}>} Message instance
 * @this Type
 */

/**
 * To object converter part of an {@link IWrapper}.
 * @typedef WrapperToObjectConverter
 * @type {function}
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @this Type
 */

/**
 * Common type wrapper part of {@link wrappers}.
 * @interface IWrapper
 * @property {WrapperFromObjectConverter} [fromObject] From object converter
 * @property {WrapperToObjectConverter} [toObject] To object converter
 */

// Custom wrapper for Any
wrappers[".google.protobuf.Any"] = {

    fromObject: function(object) {

        // unwrap value type if mapped
        if (object && object["@type"]) {
             // Only use fully qualified type name after the last '/'
            var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type) {
                // type_url does not accept leading "."
                var type_url = object["@type"].charAt(0) === "." ?
                    object["@type"].slice(1) : object["@type"];
                // type_url prefix is optional, but path seperator is required
                if (type_url.indexOf("/") === -1) {
                    type_url = "/" + type_url;
                }
                return this.create({
                    type_url: type_url,
                    value: type.encode(type.fromObject(object)).finish()
                });
            }
        }

        return this.fromObject(object);
    },

    toObject: function(message, options) {

        // Default prefix
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name = "";

        // decode value if requested and unmapped
        if (options && options.json && message.type_url && message.value) {
            // Only use fully qualified type name after the last '/'
            name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
            // Separate the prefix used
            prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type)
                message = type.decode(message.value);
        }

        // wrap value if unmapped
        if (!(message instanceof this.ctor) && message instanceof Message) {
            var object = message.$type.toObject(message, options);
            var messageName = message.$type.fullName[0] === "." ?
                message.$type.fullName.slice(1) : message.$type.fullName;
            // Default to type.googleapis.com prefix if no prefix is used
            if (prefix === "") {
                prefix = googleApi;
            }
            name = prefix + messageName;
            object["@type"] = name;
            return object;
        }

        return this.toObject(message, options);
    }
};
"use strict";
module.exports = BufferWriter;

// extends Writer
var Writer = require("./writer");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = require("./util/minimal");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();
"use strict";
module.exports = Writer;

var util      = require("./util/minimal");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};
{
    "compilerOptions": {
        "target": "ES5",
        "experimentalDecorators": true,
        "emitDecoratorMetadata": true,
        "esModuleInterop": true,
    }
}export declare function apikey(get: (key: string) => string): [string, string][];
"use strict";
/*
    In order to use the "apikey" authentication type, you must implement:
        config.http.setHeader
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.apikey = void 0;
function apikey(get) {
    const key = get('key').trim();
    const value = get('value');
    if (!key) {
        throw new Error('Invalid "API Key" auth has an empty key');
    }
    return [[key, value]];
}
exports.apikey = apikey;
//# sourceMappingURL=apikey.js.map{"version":3,"file":"apikey.js","sourceRoot":"","sources":["../../src/auth-types/apikey.ts"],"names":[],"mappings":";AAAA;;;EAGE;;;AAEF,SAAgB,MAAM,CAAC,GAA4B;IAClD,MAAM,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,CAAC;IAC9B,MAAM,KAAK,GAAG,GAAG,CAAC,OAAO,CAAC,CAAC;IAE3B,IAAI,CAAC,GAAG,EAAE,CAAC;QACV,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAC;IAC5D,CAAC;IAED,OAAO,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC;AACvB,CAAC;AATD,wBASC"}export declare function awsv4(): [string, string][];
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.awsv4 = void 0;
function awsv4() {
    throw new Error('Authentication type "awsv4" has not yet been implemented');
}
exports.awsv4 = awsv4;
//# sourceMappingURL=awsv4.js.map{"version":3,"file":"awsv4.js","sourceRoot":"","sources":["../../src/auth-types/awsv4.ts"],"names":[],"mappings":";;;AAAA,SAAgB,KAAK;IACpB,MAAM,IAAI,KAAK,CAAC,0DAA0D,CAAC,CAAC;AAC7E,CAAC;AAFD,sBAEC"}export declare function basic(get: (key: string) => string): [string, string][];
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.basic = void 0;
const js_base64_1 = require("js-base64");
/*
    In order to use the "basic" authentication type, you must implement:
        config.http.setHeader
*/
function basic(get) {
    const key = 'Authorization';
    const value = `Basic ${js_base64_1.Base64.encode(get('username') + ':' + get('password'))}`;
    return [[key, value]];
}
exports.basic = basic;
//# sourceMappingURL=basic.js.map{"version":3,"file":"basic.js","sourceRoot":"","sources":["../../src/auth-types/basic.ts"],"names":[],"mappings":";;;AAAA,yCAAmC;AAEnC;;;EAGE;AAEF,SAAgB,KAAK,CAAC,GAA4B;IACjD,MAAM,GAAG,GAAG,eAAe,CAAC;IAC5B,MAAM,KAAK,GAAG,SAAS,kBAAM,CAAC,MAAM,CACnC,GAAG,CAAC,UAAU,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,UAAU,CAAC,CACvC,EAAE,CAAC;IAEJ,OAAO,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC;AACvB,CAAC;AAPD,sBAOC"}export declare function bearer(get: (key: string) => string): [string, string][];
"use strict";
/*
    In order to use the "bearer" authentication type, you must implement:
        config.http.setHeader
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.bearer = void 0;
function bearer(get) {
    const key = 'Authorization';
    const value = `Bearer ${get('token')}`;
    return [[key, value]];
}
exports.bearer = bearer;
//# sourceMappingURL=bearer.js.map{"version":3,"file":"bearer.js","sourceRoot":"","sources":["../../src/auth-types/bearer.ts"],"names":[],"mappings":";AAAA;;;EAGE;;;AAEF,SAAgB,MAAM,CAAC,GAA4B;IAClD,MAAM,GAAG,GAAG,eAAe,CAAC;IAC5B,MAAM,KAAK,GAAG,UAAU,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC;IAEvC,OAAO,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC;AACvB,CAAC;AALD,wBAKC"}export declare function edgegrid(): [string, string][];
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.edgegrid = void 0;
function edgegrid() {
    throw new Error('Authentication type "edgegrid" has not yet been implemented');
}
exports.edgegrid = edgegrid;
//# sourceMappingURL=edgegrid.js.map{"version":3,"file":"edgegrid.js","sourceRoot":"","sources":["../../src/auth-types/edgegrid.ts"],"names":[],"mappings":";;;AAAA,SAAgB,QAAQ;IACvB,MAAM,IAAI,KAAK,CACd,6DAA6D,CAC7D,CAAC;AACH,CAAC;AAJD,4BAIC"}import { Item } from '@postman/runtime.core';
import Auth from '..';
export declare function hawk(get: (key: string) => string, config: Auth.Config, item: Item): Promise<[string, string][]>;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hawk = void 0;
const postman_url_encoder_1 = __importDefault(require("postman-url-encoder"));
const create_hmac_1 = __importDefault(require("create-hmac"));
const create_hash_1 = __importDefault(require("create-hash"));
const config_util_1 = require("../config-util");
/*
    In order to use the "hawk" authentication type, you must implement:
        config.http.getURL
        config.http.getMethod
        config.http.getBody
        config.http.getHeader
        config.http.setHeader
*/
async function hawk(get, config, item) {
    const getURL = (0, config_util_1.useHTTPInterface)(config, 'getURL').bind(null, item);
    const getMethod = (0, config_util_1.useHTTPInterface)(config, 'getMethod').bind(null, item);
    const getBody = (0, config_util_1.useHTTPInterface)(config, 'getBody').bind(null, item);
    const getHeader = (0, config_util_1.useHTTPInterface)(config, 'getHeader').bind(null, item);
    const authId = get('authId');
    const authKey = get('authKey');
    if (!authId || !authKey) {
        return [];
    }
    const algorithm = get('algorithm');
    if (algorithm !== 'sha1' && algorithm !== 'sha256') {
        throw new Error(`Unsupported Hawk hashing algorithm: "${algorithm}"`);
    }
    let hash = '';
    if (get('includePayloadHash') === 'true') {
        hash = calculatePayloadHash(algorithm, getHeader('content-type') || '', await getBody());
    }
    const parsedURL = postman_url_encoder_1.default.toNodeUrl(getURL());
    const port = parsedURL.port || defaultPorts.get(parsedURL.protocol) || 443;
    const timestamp = Math.max(0, Number.parseInt(get('timestamp'), 10)) ||
        Math.floor(Date.now() / 1e3);
    const headerValue = calculateHeader({
        id: authId,
        key: authKey,
        algorithm,
    }, {
        ts: String(timestamp),
        nonce: get('nonce') || randomString(6),
        ext: get('extraData'),
        app: get('app'),
        dlg: get('delegation'),
        hash,
    }, {
        method: getMethod().toUpperCase(),
        resource: (parsedURL.pathname || '') + (parsedURL.search || ''),
        host: (parsedURL.hostname || '').toLowerCase(),
        port: String(port),
    });
    return [['Authorization', headerValue]];
}
exports.hawk = hawk;
// Calculates a Hawk request's Authorization header.
function calculateHeader(credentials, artifacts, target) {
    const attributes = [
        `Hawk id="${credentials.id}"`,
        `ts="${artifacts.ts}"`,
        `nonce="${artifacts.nonce}"`,
        `mac="${calculateMac(credentials, artifacts, target)}"`,
    ];
    if (artifacts.hash) {
        attributes.push(`hash="${artifacts.hash}"`);
    }
    if (artifacts.ext) {
        const ext = artifacts.ext.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
        attributes.push(`ext="${ext}"`);
    }
    if (artifacts.app) {
        attributes.push(`app="${artifacts.app}"`);
        artifacts.dlg && attributes.push(`dlg="${artifacts.dlg}"`);
    }
    return attributes.join(', ');
}
// Calculates a Hawk request's MAC digest.
function calculateMac(credentials, artifacts, target) {
    const lines = [
        'hawk.1.header',
        artifacts.ts,
        artifacts.nonce,
        target.method,
        target.resource,
        target.host,
        target.port,
        artifacts.hash,
        artifacts.ext.replace(/\\/g, '\\\\').replace(/\n/g, '\\n'),
    ];
    if (artifacts.app) {
        lines.push(artifacts.app);
        lines.push(artifacts.dlg);
    }
    return (0, create_hmac_1.default)(credentials.algorithm, credentials.key)
        .update(lines.map((str) => str + '\n').join(''))
        .digest('base64');
}
// Calculates a Hawk request's payload hash. Payload should be UTF-8 encoded.
function calculatePayloadHash(algorithm, contentType, payload) {
    return (0, create_hash_1.default)(algorithm)
        .update('hawk.1.payload')
        .update('\n')
        .update(contentType.split(';')[0].trim().toLowerCase())
        .update('\n')
        .update(payload)
        .update('\n')
        .digest('base64');
}
// Returns a random alpha-numeric ASCII string of the given length.
function randomString(length) {
    const TBL = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    const chars = [];
    for (let i = 0; i < length; ++i) {
        chars.push(TBL[(Math.random() * TBL.length) | 0]);
    }
    return chars.join('');
}
// Table of well-known default port numbers.
const defaultPorts = new Map([
    ['http:', 80],
    ['https:', 443],
    ['ws:', 80],
    ['wss:', 443],
]);
//# sourceMappingURL=hawk.js.map{"version":3,"file":"hawk.js","sourceRoot":"","sources":["../../src/auth-types/hawk.ts"],"names":[],"mappings":"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"}export * from './apikey';
export * from './awsv4';
export * from './basic';
export * from './bearer';
export * from './edgegrid';
export * from './hawk';
export * from './oauth1';
export * from './oauth2';
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./apikey"), exports);
__exportStar(require("./awsv4"), exports);
__exportStar(require("./basic"), exports);
__exportStar(require("./bearer"), exports);
__exportStar(require("./edgegrid"), exports);
__exportStar(require("./hawk"), exports);
__exportStar(require("./oauth1"), exports);
__exportStar(require("./oauth2"), exports);
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/auth-types/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,2CAAyB;AACzB,0CAAwB;AACxB,0CAAwB;AACxB,2CAAyB;AACzB,6CAA2B;AAC3B,yCAAuB;AACvB,2CAAyB;AACzB,2CAAyB"}export declare function oauth1(): [string, string][];
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.oauth1 = void 0;
function oauth1() {
    throw new Error('Authentication type "oauth1" has not yet been implemented');
}
exports.oauth1 = oauth1;
//# sourceMappingURL=oauth1.js.map{"version":3,"file":"oauth1.js","sourceRoot":"","sources":["../../src/auth-types/oauth1.ts"],"names":[],"mappings":";;;AAAA,SAAgB,MAAM;IACrB,MAAM,IAAI,KAAK,CAAC,2DAA2D,CAAC,CAAC;AAC9E,CAAC;AAFD,wBAEC"}export declare function oauth2(): [string, string][];
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.oauth2 = void 0;
function oauth2() {
    throw new Error('Authentication type "oauth2" has not yet been implemented');
}
exports.oauth2 = oauth2;
//# sourceMappingURL=oauth2.js.map{"version":3,"file":"oauth2.js","sourceRoot":"","sources":["../../src/auth-types/oauth2.ts"],"names":[],"mappings":";;;AAAA,SAAgB,MAAM;IACrB,MAAM,IAAI,KAAK,CAAC,2DAA2D,CAAC,CAAC;AAC9E,CAAC;AAFD,wBAEC"}import Auth from '.';
type HTTPInterface = NonNullable<Auth.Config['http']>;
export declare function useHTTPInterface<K extends keyof HTTPInterface>(config: Auth.Config, key: K): NonNullable<HTTPInterface[K]>;
export {};
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useHTTPInterface = void 0;
// Extracts a property of the config's HTTP interface, making sure it exists.
function useHTTPInterface(config, key) {
    const value = config.http?.[key];
    if (value == null) {
        throw new TypeError(`Auth extension configuration is missing "${key}"`);
    }
    return value;
}
exports.useHTTPInterface = useHTTPInterface;
//# sourceMappingURL=config-util.js.map{"version":3,"file":"config-util.js","sourceRoot":"","sources":["../src/config-util.ts"],"names":[],"mappings":";;;AAIA,6EAA6E;AAC7E,SAAgB,gBAAgB,CAC/B,MAAmB,EACnB,GAAM;IAEN,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC;IACjC,IAAI,KAAK,IAAI,IAAI,EAAE,CAAC;QACnB,MAAM,IAAI,SAAS,CAAC,4CAA4C,GAAG,GAAG,CAAC,CAAC;IACzE,CAAC;IACD,OAAO,KAAK,CAAC;AACd,CAAC;AATD,4CASC"}import Auth from '.';
declare const _default: (itemType: import("@postman/runtime.core/dist/item-type").default.WithExtension<Auth>) => {
    onBefore(item: import("@postman/runtime.core/dist/item").default.WithExtension<Auth>): Promise<import("@postman/runtime.core/dist/item").default.WithExtension<Auth> | undefined>;
};
export default _default;
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_util_1 = require("./config-util");
const authTypes = __importStar(require("./auth-types"));
exports.default = (function handler(itemType) {
    const { config } = itemType.getExtension('auth');
    const { supportedAuthTypes } = config;
    return {
        async onBefore(item) {
            const auth = item.extensions.auth;
            if (!auth) {
                return;
            }
            if (!supportedAuthTypes.includes(auth.type)) {
                throw new Error(`Unsupported auth type: "${auth.type}"`);
            }
            if (auth.type === 'noauth') {
                return;
            }
            const authSettings = auth[auth.type] ?? [];
            const getter = get.bind(null, authSettings);
            let results;
            switch (auth.type) {
                case 'basic':
                    results = authTypes.basic(getter);
                    break;
                case 'bearer':
                    results = authTypes.bearer(getter);
                    break;
                case 'apikey':
                    results = authTypes.apikey(getter);
                    break;
                case 'awsv4':
                    results = authTypes.awsv4();
                    break;
                case 'hawk':
                    results = await authTypes.hawk(getter, config, item);
                    break;
                case 'oauth1':
                    results = authTypes.oauth1();
                    break;
                case 'oauth2':
                    results = authTypes.oauth2();
                    break;
                case 'edgegrid':
                    results = authTypes.edgegrid();
                    break;
            }
            if (results.length) {
                const setHeader = (0, config_util_1.useHTTPInterface)(config, 'setHeader');
                for (const [key, value] of results) {
                    setHeader(item, key, value);
                }
            }
            return item;
        },
    };
});
// Case-insensitive key-value getter, always casts to string.
function get(kvPairs, key) {
    key = key.toLowerCase();
    const value = kvPairs.find((x) => x.key.toLowerCase() === key)?.value;
    return value == null ? '' : String(value);
}
//# sourceMappingURL=handler.js.map{"version":3,"file":"handler.js","sourceRoot":"","sources":["../src/handler.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AACA,+CAAiD;AACjD,wDAA0C;AAG1C,kBAAe,CAAC,SAAS,OAAO,CAAC,QAAQ;IACxC,MAAM,EAAE,MAAM,EAAE,GAAG,QAAQ,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;IACjD,MAAM,EAAE,kBAAkB,EAAE,GAAG,MAAM,CAAC;IAEtC,OAAO;QACN,KAAK,CAAC,QAAQ,CAAC,IAAI;YAClB,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;YAClC,IAAI,CAAC,IAAI,EAAE,CAAC;gBACX,OAAO;YACR,CAAC;YACD,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;gBAC7C,MAAM,IAAI,KAAK,CAAC,2BAA2B,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC;YAC1D,CAAC;YACD,IAAI,IAAI,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;gBAC5B,OAAO;YACR,CAAC;YAED,MAAM,YAAY,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;YAC3C,MAAM,MAAM,GAAG,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;YAC5C,IAAI,OAAqC,CAAC;YAE1C,QAAQ,IAAI,CAAC,IAAI,EAAE,CAAC;gBACnB,KAAK,OAAO;oBACX,OAAO,GAAG,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;oBAClC,MAAM;gBACP,KAAK,QAAQ;oBACZ,OAAO,GAAG,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;oBACnC,MAAM;gBACP,KAAK,QAAQ;oBACZ,OAAO,GAAG,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;oBACnC,MAAM;gBACP,KAAK,OAAO;oBACX,OAAO,GAAG,SAAS,CAAC,KAAK,EAAE,CAAC;oBAC5B,MAAM;gBACP,KAAK,MAAM;oBACV,OAAO,GAAG,MAAM,SAAS,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;oBACrD,MAAM;gBACP,KAAK,QAAQ;oBACZ,OAAO,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC;oBAC7B,MAAM;gBACP,KAAK,QAAQ;oBACZ,OAAO,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC;oBAC7B,MAAM;gBACP,KAAK,UAAU;oBACd,OAAO,GAAG,SAAS,CAAC,QAAQ,EAAE,CAAC;oBAC/B,MAAM;YACR,CAAC;YAED,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;gBACpB,MAAM,SAAS,GAAG,IAAA,8BAAgB,EAAC,MAAM,EAAE,WAAW,CAAC,CAAC;gBACxD,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,OAAO,EAAE,CAAC;oBACpC,SAAS,CAAC,IAAI,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;gBAC7B,CAAC;YACF,CAAC;YAED,OAAO,IAAI,CAAC;QACb,CAAC;KACD,CAAC;AACH,CAAmC,CAAC,CAAC;AAErC,6DAA6D;AAC7D,SAAS,GAAG,CAAC,OAA0C,EAAE,GAAW;IACnE,GAAG,GAAG,GAAG,CAAC,WAAW,EAAE,CAAC;IACxB,MAAM,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,WAAW,EAAE,KAAK,GAAG,CAAC,EAAE,KAAK,CAAC;IACtE,OAAO,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AAC3C,CAAC"}import { FromSchema } from 'json-schema-to-ts';
import { Extension, Item } from '@postman/runtime.core';
export interface PluginConfiguration {
    supportedAuthTypes: ReadonlyArray<'noauth' | 'awsv4' | 'basic' | 'bearer' | 'hawk' | 'oauth1' | 'oauth2' | 'apikey' | 'edgegrid'>;
    http?: {
        getURL?: (item: Item) => string;
        getMethod?: (item: Item) => string;
        getBody?: (item: Item) => Uint8Array | Promise<Uint8Array>;
        getHeader?: (item: Item, name: string) => string | undefined;
        setHeader?: (item: Item, name: string, value: string | undefined) => void;
    };
}
declare const definition: {
    name: "auth";
    summary: "Security credentials";
    schema: {
        readonly type: "object";
        readonly required: ["type"];
        readonly properties: {
            readonly type: {
                readonly type: "string";
                readonly enum: readonly ["noauth", "awsv4", "basic", "bearer", "hawk", "oauth1", "oauth2", "apikey", "edgegrid"];
            };
            readonly awsv4: {
                readonly $ref: "#/definitions/key-value-pairs";
            };
            readonly basic: {
                readonly $ref: "#/definitions/key-value-pairs";
            };
            readonly bearer: {
                readonly $ref: "#/definitions/key-value-pairs";
            };
            readonly hawk: {
                readonly $ref: "#/definitions/key-value-pairs";
            };
            readonly oauth1: {
                readonly $ref: "#/definitions/key-value-pairs";
            };
            readonly oauth2: {
                readonly $ref: "#/definitions/key-value-pairs";
            };
            readonly apikey: {
                readonly $ref: "#/definitions/key-value-pairs";
            };
            readonly edgegrid: {
                readonly $ref: "#/definitions/key-value-pairs";
            };
        };
        readonly additionalProperties: false;
        readonly definitions: {
            readonly 'key-value-pairs': {
                readonly type: "array";
                readonly items: {
                    readonly type: "object";
                    readonly required: ["key", "value"];
                    readonly properties: {
                        readonly key: {
                            readonly type: "string";
                        };
                        readonly value: {};
                    };
                    readonly additionalProperties: false;
                };
            };
        };
    };
};
declare namespace Auth {
    type Name = typeof definition.name;
    type Data = FromSchema<typeof definition.schema>;
    type Config = PluginConfiguration;
    const use: () => Extension.Specific<"auth", {
        awsv4?: {
            key: string;
            value: unknown;
        }[] | undefined;
        basic?: {
            key: string;
            value: unknown;
        }[] | undefined;
        bearer?: {
            key: string;
            value: unknown;
        }[] | undefined;
        hawk?: {
            key: string;
            value: unknown;
        }[] | undefined;
        oauth1?: {
            key: string;
            value: unknown;
        }[] | undefined;
        oauth2?: {
            key: string;
            value: unknown;
        }[] | undefined;
        apikey?: {
            key: string;
            value: unknown;
        }[] | undefined;
        edgegrid?: {
            key: string;
            value: unknown;
        }[] | undefined;
        type: "noauth" | "awsv4" | "basic" | "bearer" | "hawk" | "oauth1" | "oauth2" | "apikey" | "edgegrid";
    }, PluginConfiguration>;
}
type Auth = Extension.Specific<Auth.Name, Auth.Data, Auth.Config>;
export default Auth;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const json_schema_to_ts_1 = require("json-schema-to-ts");
const runtime_core_1 = require("@postman/runtime.core");
const handler_1 = __importDefault(require("./handler"));
const definition = (0, json_schema_to_ts_1.asConst)({
    name: 'auth',
    summary: 'Security credentials',
    schema: {
        type: 'object',
        required: ['type'],
        properties: {
            type: {
                type: 'string',
                enum: [
                    'noauth',
                    'awsv4',
                    'basic',
                    'bearer',
                    'hawk',
                    'oauth1',
                    'oauth2',
                    'apikey',
                    'edgegrid',
                ],
            },
            awsv4: {
                $ref: '#/definitions/key-value-pairs',
            },
            basic: {
                $ref: '#/definitions/key-value-pairs',
            },
            bearer: {
                $ref: '#/definitions/key-value-pairs',
            },
            hawk: {
                $ref: '#/definitions/key-value-pairs',
            },
            oauth1: {
                $ref: '#/definitions/key-value-pairs',
            },
            oauth2: {
                $ref: '#/definitions/key-value-pairs',
            },
            apikey: {
                $ref: '#/definitions/key-value-pairs',
            },
            edgegrid: {
                $ref: '#/definitions/key-value-pairs',
            },
        },
        additionalProperties: false,
        definitions: {
            'key-value-pairs': {
                type: 'array',
                items: {
                    type: 'object',
                    required: ['key', 'value'],
                    properties: {
                        key: {
                            type: 'string',
                        },
                        value: {},
                    },
                    additionalProperties: false,
                },
            },
        },
    },
});
var Auth;
(function (Auth) {
    Auth.use = runtime_core_1.Extension.define(definition, handler_1.default);
})(Auth || (Auth = {}));
exports.default = Auth;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;AAAA,yDAAoE;AACpE,wDAAwD;AACxD,wDAAgC;AAuBhC,MAAM,UAAU,GAAG,IAAA,2BAAO,EAAC;IAC1B,IAAI,EAAE,MAAM;IACZ,OAAO,EAAE,sBAAsB;IAC/B,MAAM,EAAE;QACP,IAAI,EAAE,QAAQ;QACd,QAAQ,EAAE,CAAC,MAAM,CAAC;QAClB,UAAU,EAAE;YACX,IAAI,EAAE;gBACL,IAAI,EAAE,QAAQ;gBACd,IAAI,EAAE;oBACL,QAAQ;oBACR,OAAO;oBACP,OAAO;oBACP,QAAQ;oBACR,MAAM;oBACN,QAAQ;oBACR,QAAQ;oBACR,QAAQ;oBACR,UAAU;iBACV;aACD;YACD,KAAK,EAAE;gBACN,IAAI,EAAE,+BAA+B;aACrC;YACD,KAAK,EAAE;gBACN,IAAI,EAAE,+BAA+B;aACrC;YACD,MAAM,EAAE;gBACP,IAAI,EAAE,+BAA+B;aACrC;YACD,IAAI,EAAE;gBACL,IAAI,EAAE,+BAA+B;aACrC;YACD,MAAM,EAAE;gBACP,IAAI,EAAE,+BAA+B;aACrC;YACD,MAAM,EAAE;gBACP,IAAI,EAAE,+BAA+B;aACrC;YACD,MAAM,EAAE;gBACP,IAAI,EAAE,+BAA+B;aACrC;YACD,QAAQ,EAAE;gBACT,IAAI,EAAE,+BAA+B;aACrC;SACD;QACD,oBAAoB,EAAE,KAAK;QAC3B,WAAW,EAAE;YACZ,iBAAiB,EAAE;gBAClB,IAAI,EAAE,OAAO;gBACb,KAAK,EAAE;oBACN,IAAI,EAAE,QAAQ;oBACd,QAAQ,EAAE,CAAC,KAAK,EAAE,OAAO,CAAC;oBAC1B,UAAU,EAAE;wBACX,GAAG,EAAE;4BACJ,IAAI,EAAE,QAAQ;yBACd;wBACD,KAAK,EAAE,EAAE;qBACT;oBACD,oBAAoB,EAAE,KAAK;iBAC3B;aACD;SACD;KAC6B;CAC/B,CAAC,CAAC;AAEH,IAAU,IAAI,CAKb;AALD,WAAU,IAAI;IAIA,QAAG,GAAG,wBAAS,CAAC,MAAM,CAAqB,UAAU,EAAE,iBAAO,CAAC,CAAC;AAC9E,CAAC,EALS,IAAI,KAAJ,IAAI,QAKb;AAGD,kBAAe,IAAI,CAAC"}3.0.5:
  date: 2021-08-16
  fixed bugs:
    - Fixed a bug where `encoder.encodeHost` throws in the browser
  chores:
    - Setup browser tests

3.0.4:
  date: 2021-08-09
  fixed bugs:
    - Fixed a bug where leading slashes are trimmed incorrectly
  chores:
    - Removed punycode fallback for Electron v3
    - Updated dependencies

3.0.3:
  date: 2021-07-25
  fixed bugs:
    - >-
      GH-133 Fixed a bug where slashes in the `file` protocol are handled
      incorrectly

3.0.2:
  date: 2021-07-14
  fixed bugs:
    - >-
      GH-130 Fixed a bug where extra slashes and backslashes in the protocol are
      not handled correctly
  chores:
    - Added secure codecov publish script
    - Updated dependencies

3.0.1:
  date: 2021-01-02
  chores:
    - Updated dependencies

3.0.0:
  date: 2020-10-04
  new features:
    - GH-48 Added URL parser module
  breaking changes:
    - GH-49 Dropped support for Node < v10
  chores:
    - GH-50 Convert EncodeSet to ES6 class
    - GH-52 Automated releases and publish process
    - GH-51 Automated gh-pages docs deployment
    - >-
      GH-49 Updated .npmignore to prevent the addition of tests and config files
      in the published package
    - GH-49 Added system test
    - GH-49 Moved postman-collection to dev-dependencies
    - GH-49 Updated nyc configuration
    - GH-49 Updated ESLint rules
    - GH-49 Updated dependencies

2.1.3:
  date: 2020-07-29
  fixed bugs:
    - >-
      GH-41 Fixed a bug where square brackets are not removed from IPv6 hostname
      on `toNodeURL()`
  chores:
    - Updated dependencies

2.1.2:
  date: 2020-07-13
  chores:
    - Updated dependencies

2.1.1:
  date: 2020-03-15
  fixed bugs:
    - GH-20 Removed `&` and `=` from QUERY_ENCODE_SET

2.1.0:
  date: 2020-03-02
  new features:
    - GH-11 Added an option to disable encoding on `toNodeUrl()`
    - >-
      GH-13 Added `resolveNodeUrl()` method to resolve target URL relative to a
      base URL
  fixed bugs:
    - >-
      GH-12 Fixed a bug where Node.js native `url.domainToASCII` was not working
      as expected in Electron v3
    - GH-10 Handle query parameters with empty key or value
    - >-
      GH-9 Fixed a bug where query params without value were changed to params
      with empty value while encoding single param

2.0.0:
  date: 2020-02-06
  new features:
    - Implementation of the WHATWG URL Standard
    - Introduces new `/encoder` module with various encoding helpers
    - Method `toNodeUrl()` now follows the WHATWG URL standard for encoding
  breaking changes:
    - Renamed legacy `toNodeUrl()` method to `toLegacyNodeUrl()`
    - |
      Changed `encode()` function to encode SPACE, ("), (#), (&), ('), (<),
      (=), and (>). In previous versions, it was encoding SPACE, (!), ("), ((),
      ()), (<), (>), (%), ('), and (*).
    - Deprecated `toLegacyNodeUrl()` in favor of `toNodeUrl()`
    - Deprecated `encode()` in favor of `encodeQueryParam()`
    - |
      Dropped support for following methods:
        -> percentEncode()
        -> isPreEncoded()
        -> isPreEncodedCharacter()
        -> charactersToPercentEncode()
  chores:
    - Updated dependencies
    - Update license from MIT to Apache-2.0

1.0.3:
  date: 2019-10-16
  chores:
    - Updated dependencies

1.0.2:
  date: 2019-04-08
  new features:
    - >-
      Added `toNodeUrl()` function to convert a string URL into Node's URL type
      object

1.0.1:
  date: 2017-02-01
  chore:
    - Updated package.json

1.0.0:
  date: 2017-02-01
  initial release:
    - Initial Release
/**
 * @fileoverview
 * An EncodeSet represents a set of characters that should be percent-encoded.
 *
 * Different characters need to be encoded in different parts of an URL.
 * For example, a literal ? question mark in an URLs path would indicate the
 * start of the query string. A question mark meant to be part of the path
 * therefore needs to be percent-encoded.
 * In the query string however, a question mark does not have any special
 * meaning and does not need to be percent-encoded.
 *
 * A few sets are defined in this module.
 * Use the {@link EncodeSet} class to define different ones.
 *
 * @see {@link https://url.spec.whatwg.org/#simple-encode-set}
 */

/**
 * A character (String), or character code (Number).
 *
 * @typedef {String|Number} Char
 */

/**
 * A Set or Array of {@link Char}(s).
 *
 * @typedef {Set.<Char>|Array.<Char>} CharSet
 */

const QUERY_ENCODE_CHARS = [' ', '"', '#', '\'', '<', '>'],
    FRAGMENT_EXTEND_CHARS = [' ', '"', '<', '>', '`'],
    PATH_EXTEND_CHARS = ['#', '?', '{', '}'],
    USERINFO_EXTEND_CHARS = ['/', ':', ';', '=', '@', '[', '\\', ']', '^', '|'];

/**
 * Returns a number representing the UTF-16 code unit value of the character.
 *
 * @private
 * @param {Char} char Character or character code
 * @returns {Number} Character code
 */
function charCode (char) {
    const code = (typeof char === 'string') ?
        // get char code from string
        char.charCodeAt(0) :
        // or, normalize char code using double Bitwise NOT
        // Refer: https://jsperf.com/truncating-decimals
        ~~char;

    // ensure UTF-16 range [0, 0xFFFF]
    return (code >= 0 && code <= 0xFFFF) ? code : 0;
}

/**
 * Extends the EncodeSet with the given characters.
 *
 * @note Mutates the input EncodeSet.
 *
 * @private
 * @param {EncodeSet} encodeSet Instance of EncodeSet
 * @param {CharSet} chars Character set to extend
 * @returns {EncodeSet} Given EncodeSet
 */
function extendEncodeSet (encodeSet, chars) {
    // special handling for Uint8Array chars which signify an existing encode
    // set used to extend the given encodeSet.
    if (chars instanceof Uint8Array) {
        // iterate over fixed / known size set
        encodeSet._set.forEach((encoded, index) => {
            if (!encoded && chars[index]) {
                // encode charCodeAt(index)
                encodeSet._set[index] = 1;
            }
        });

        return encodeSet;
    }

    // check if the input characters are iterable or not
    if (!(chars && typeof chars.forEach === 'function')) {
        return encodeSet;
    }

    chars.forEach((char) => {
        encodeSet.add(char);
    });

    return encodeSet;
}

/**
 * Represents a set of characters / bytes that should be percent-encoded.
 */
class EncodeSet {
    /**
     * @param {CharSet} chars Character set to encode
     */
    constructor (chars) {
        /**
         * Indexes in Uint8Array represents char codes for characters to encode.
         *
         * Size: 128, ASCII range [0, 0x7F]
         *
         * where,
         * 1 -> encode
         * 0 -> don't encode
         *
         * @private
         * @type {Uint8Array}
         */
        this._set = new Uint8Array(0x80);

        // encode C0 control codes [00, 0x1F] AND 0x7F
        this._set.fill(1, 0, 0x20); // 0 to 31
        this._set[0x7F] = 1; // 127

        /**
         * A Boolean indicating whether or not this EncodeSet is sealed.
         *
         * @private
         * @type {Boolean}
         */
        this._sealed = false;

        // extend this set with input characters
        extendEncodeSet(this, chars);
    }

    /**
     * Appends a new character to the EncodeSet.
     *
     * @example
     * var xyzEncodeSet = new EncodeSet(['x', 'y', 'z'])
     *
     * xyzEncodeSet
     *  .add('X')
     *  .add(89) // Y
     *  .add(0x5a) // Z
     *
     * @param {Char} char Character or character code
     * @returns {EncodeSet} Current EncodeSet
     */
    add (char) {
        // bail out if the EncodeSet is sealed
        if (this._sealed) {
            return this;
        }

        const code = charCode(char);

        // ensure ASCII range
        if (code < 0x80) {
            this._set[code] = 1;
        }

        // chaining
        return this;
    }

    /**
     * Returns a boolean asserting whether the given char code will be encoded in
     * the EncodeSet or not.
     *
     * @note Always encode C0 control codes in the range U+0000 to U+001F and U+007F
     * Refer: https://infra.spec.whatwg.org/#c0-control
     *
     * @example
     * var tildeEncodeSet = new EncodeSet(['~'])
     *
     * // returns true
     * tildeEncodeSet.has('~'.charCodeAt(0))
     *
     * // returns false
     * tildeEncodeSet.has(65) // A
     *
     * // returns true
     * tildeEncodeSet.has(31) // \u001f (control character)
     *
     * @param {Number} code Character code
     * @returns {Boolean} Returns true if the character with the specified char code
     * exists in the EncodeSet; otherwise false
     */
    has (code) {
        // encode if not in ASCII range (-, 0) OR (127, )
        if (code < 0 || code > 0x7F) {
            return true;
        }

        // encode if present in the set
        return Boolean(this._set[code]);
    }

    /**
     * Creates a copy of the current EncodeSet.
     *
     * @example
     * var set1 = new EncodeSet(['<', '>'])
     * var set1Copy = set1.clone().add('=')
     *
     * @returns {EncodeSet} New EncodeSet instance
     */
    clone () {
        return new EncodeSet(this._set);
    }

    /**
     * Seals the current EncodeSet to prevent new characters being added to it.
     *
     * @example
     * var set = new EncodeSet()
     *
     * set.add(95)
     * set.has(95) // returns true
     *
     * set.seal()
     * set.add(100)
     * set.has(100) // returns false
     *
     * @returns {EncodeSet} Current EncodeSet
     */
    seal () {
        this._sealed = true;

        try {
            // @note Cannot freeze array buffer views with elements.
            // So, rely upon the alternative `Object.seal` method and avoid mutations
            // via EncodeSet~add method.
            // Also, sealed Uint8Array enumerates faster in V8!
            Object.seal(this._set);
        }
        catch (_) {
            // silently swallow exceptions
        }

        return this;
    }

    /**
     * Creates a new EncodeSet by extending the input EncodeSet with additional
     * characters.
     *
     * @example
     * var fooEncodeSet = new EncodeSet(['f', 'o'])
     * var foobarEncodeSet = EncodeSet.extend(fooEncodeSet, new Set(['b', 'a', 'r']))
     *
     * @param {EncodeSet} encodeSet Instance of EncodeSet
     * @param {CharSet} chars Character set to encode
     * @returns {EncodeSet} Copy of given `encodeSet` with extended `chars`
     * @throws {TypeError} Argument `encodeSet` must be of type {@link EncodeSet}
     */
    static extend (encodeSet, chars) {
        if (!EncodeSet.isEncodeSet(encodeSet)) {
            throw new TypeError('Argument `encodeSet` must be EncodeSet');
        }

        // extend the cloned encodeSet to avoid mutations
        return extendEncodeSet(encodeSet.clone(), chars);
    }

    /**
     * Determines whether the input value is an EncodeSet or not.
     *
     * @example
     * // returns true
     * EncodeSet.isEncodeSet(new EncodeSet([40, 41]))
     *
     * // returns false
     * EncodeSet.isEncodeSet(new Set([28, 05]))
     *
     * @param {*} value The value to be tested
     * @returns {Boolean} true if the given value is an EncodeSet; otherwise, false
     */
    static isEncodeSet (value) {
        return Boolean(value) && (value instanceof EncodeSet);
    }
}

const // eslint-disable-line one-var

    /**
     * The C0 control percent-encode set are the C0 controls and all code points
     * greater than U+007E (~).
     *
     * @const
     * @type {EncodeSet}
     * @see {@link https://url.spec.whatwg.org/#c0-control-percent-encode-set}
     */
    C0_CONTROL_ENCODE_SET = new EncodeSet().seal(),

    /**
     * The fragment percent-encode set is the C0 control percent-encode set and
     * U+0020 SPACE, U+0022 ("), U+003C (<), U+003E (>), and U+0060 (`).
     *
     * @const
     * @type {EncodeSet}
     * @see {@link https://url.spec.whatwg.org/#fragment-percent-encode-set}
     */
    FRAGMENT_ENCODE_SET = EncodeSet.extend(C0_CONTROL_ENCODE_SET, FRAGMENT_EXTEND_CHARS).seal(),

    /**
     * The path percent-encode set is the fragment percent-encode set and
     * U+0023 (#), U+003F (?), U+007B ({), and U+007D (}).
     *
     * @const
     * @type {EncodeSet}
     * @see {@link https://url.spec.whatwg.org/#path-percent-encode-set}
     */
    PATH_ENCODE_SET = EncodeSet.extend(FRAGMENT_ENCODE_SET, PATH_EXTEND_CHARS).seal(),

    /**
     * The userinfo percent-encode set is the path percent-encode set and
     * U+002F (/), U+003A (:), U+003B (;), U+003D (=), U+0040 (@), U+005B ([),
     * U+005C (\), U+005D (]), U+005E (^), and U+007C (|).
     *
     * @const
     * @type {EncodeSet}
     * @see {@link https://url.spec.whatwg.org/#userinfo-percent-encode-set}
     */
    USERINFO_ENCODE_SET = EncodeSet.extend(PATH_ENCODE_SET, USERINFO_EXTEND_CHARS).seal(),

    /**
     * The query percent-encode set is the C0 control percent-encode set and
     * U+0020 SPACE, U+0022 ("), U+0023 (#), U+0027 ('), U+003C (<), and U+003E (>).
     *
     * @const
     * @type {EncodeSet}
     * @see {@link https://url.spec.whatwg.org/#query-state}
     */
    QUERY_ENCODE_SET = new EncodeSet(QUERY_ENCODE_CHARS).seal();

module.exports = {
    // EncodeSet class
    EncodeSet,

    // Constants
    PATH_ENCODE_SET,
    QUERY_ENCODE_SET,
    FRAGMENT_ENCODE_SET,
    USERINFO_ENCODE_SET,
    C0_CONTROL_ENCODE_SET
};
/**
 * This module helps to encode different URL components and expose utility
 * methods to percent-encode a given string using an {@link EncodeSet}.
 *
 * @example
 * const encoder = require('postman-url-encoder/encoder')
 *
 * // returns 'xn--48jwgn17gdel797d.com'
 * encoder.encodeHost('.com')
 *
 * @example <caption>Using EncodeSet</caption>
 * var EncodeSet = require('postman-url-encoder/encoder').EncodeSet
 *
 * var fragmentEncodeSet = new EncodeSet([' ', '"', '<', '>', '`'])
 *
 * // returns false
 * fragmentEncodeSet.has('['.charCodeAt(0))
 *
 * // returns true
 * fragmentEncodeSet.has('<'.charCodeAt(0))
 *
 * @module postman-url-encoder/encoder
 * @see {@link https://url.spec.whatwg.org/#url-representation}
 */

/**
 * @fileoverview
 * This module determines which of the reserved characters in the different
 * URL components should be percent-encoded and which can be safely used.
 *
 * The generic URI syntax consists of a hierarchical sequence of components
 * referred to as the scheme, authority, path, query, and fragment.
 *
 *      URI         = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
 *
 *      hier-part   = "//" authority path-abempty
 *                  / path-absolute
 *                  / path-rootless
 *                  / path-empty
 *
 *      authority   = [ userinfo "@" ] host [ ":" port ]
 *
 * @see {@link https://tools.ietf.org/html/rfc3986#section-2}
 * @see {@link https://tools.ietf.org/html/rfc3986#section-3}
 */

const encodeSet = require('./encode-set'),

    _percentEncode = require('./percent-encode').encode,
    _percentEncodeCharCode = require('./percent-encode').encodeCharCode,

    EncodeSet = encodeSet.EncodeSet,

    PATH_ENCODE_SET = encodeSet.PATH_ENCODE_SET,
    QUERY_ENCODE_SET = encodeSet.QUERY_ENCODE_SET,
    USERINFO_ENCODE_SET = encodeSet.USERINFO_ENCODE_SET,
    FRAGMENT_ENCODE_SET = encodeSet.FRAGMENT_ENCODE_SET,
    C0_CONTROL_ENCODE_SET = encodeSet.C0_CONTROL_ENCODE_SET,

    PARAM_VALUE_ENCODE_SET = EncodeSet.extend(QUERY_ENCODE_SET, ['&']).seal(),
    PARAM_KEY_ENCODE_SET = EncodeSet.extend(QUERY_ENCODE_SET, ['&', '=']).seal(),

    E = '',
    EQUALS = '=',
    AMPERSAND = '&',
    STRING = 'string',
    OBJECT = 'object',

    PATH_SEPARATOR = '/',
    DOMAIN_SEPARATOR = '.',

    /**
     * Returns the Punycode ASCII serialization of the domain.
     *
     * @private
     * @function
     * @param {String} domain domain name
     * @returns {String} punycode encoded domain name
     */
    domainToASCII = (function () {
        // @note `url.domainToASCII` returns empty string for invalid domain.
        const domainToASCII = require('url').domainToASCII;

        // use faster native `url` method in Node.js
        /* istanbul ignore next */
        if (typeof domainToASCII === 'function') {
            return domainToASCII;
        }

        // else, lazy load `punycode` dependency in browser
        /* istanbul ignore next */
        return require('punycode').toASCII;
    }());

/**
 * Returns the Punycode ASCII serialization of the domain.
 *
 * @note Returns input hostname on invalid domain.
 *
 * @example
 * // returns 'xn--fiq228c.com'
 * encodeHost('.com')
 *
 * // returns 'xn--48jwgn17gdel797d.com'
 * encodeHost(['', 'com'])
 *
 * // returns '127.0.0.1'
 * encodeHost('127.1')
 *
 * // returns 'xn--ivalid.com'
 * encodeHost('xn--ivalid.com')
 *
 * @param {String|String[]} hostName host or domain name
 * @returns {String} Punycode-encoded hostname
 */
function encodeHost (hostName) {
    if (Array.isArray(hostName)) {
        hostName = hostName.join(DOMAIN_SEPARATOR);
    }

    if (typeof hostName !== STRING) {
        return E;
    }

    // return input host name if `domainToASCII` returned an empty string
    return domainToASCII(hostName) || hostName;
}

/**
 * Encodes URL path or individual path segments.
 *
 * @example
 * // returns 'foo/bar&baz'
 * encodePath('foo/bar&baz')
 *
 * // returns 'foo/bar/%20%22%3C%3E%60%23%3F%7B%7D'
 * encodePath(['foo', 'bar', ' "<>\`#?{}'])
 *
 * @param {String|String[]} path Path or path segments
 * @returns {String} Percent-encoded path
 */
function encodePath (path) {
    if (Array.isArray(path) && path.length) {
        path = path.join(PATH_SEPARATOR);
    }

    if (typeof path !== STRING) {
        return E;
    }

    return _percentEncode(path, PATH_ENCODE_SET);
}

/**
 * Encodes URL userinfo (username / password) fields.
 *
 * @example
 * // returns 'info~%20%22%3C%3E%60%23%3F%7B%7D%2F%3A%3B%3D%40%5B%5C%5D%5E%7C'
 * encodeAuth('info~ "<>`#?{}/:;=@[\\]^|')
 *
 * @param {String} param Parameter to encode
 * @returns {String} Percent-encoded parameter
 */
function encodeUserInfo (param) {
    if (typeof param !== STRING) {
        return E;
    }

    return _percentEncode(param, USERINFO_ENCODE_SET);
}

/**
 * Encodes URL fragment identifier or hash.
 *
 * @example
 * // returns 'fragment#%20%22%3C%3E%60'
 * encodeHash('fragment# "<>`')
 *
 * @param {String} fragment Hash or fragment identifier to encode
 * @returns {String} Percent-encoded fragment
 */
function encodeFragment (fragment) {
    if (typeof fragment !== STRING) {
        return E;
    }

    return _percentEncode(fragment, FRAGMENT_ENCODE_SET);
}

/**
 * Encodes single query parameter and returns as a string.
 *
 * @example
 * // returns 'param%20%22%23%27%3C%3E'
 * encodeQueryParam('param "#\'<>')
 *
 * // returns 'foo=bar'
 * encodeQueryParam({ key: 'foo', value: 'bar' })
 *
 * @param {Object|String} param Query param to encode
 * @returns {String} Percent-encoded query param
 */
function encodeQueryParam (param) {
    if (!param) {
        return E;
    }

    if (typeof param === STRING) {
        return _percentEncode(param, QUERY_ENCODE_SET);
    }

    let key = param.key,
        value = param.value,
        result;

    if (typeof key === STRING) {
        result = _percentEncode(key, PARAM_KEY_ENCODE_SET);
    }
    else {
        result = E;
    }

    if (typeof value === STRING) {
        result += EQUALS + _percentEncode(value, PARAM_VALUE_ENCODE_SET);
    }

    return result;
}

/**
 * Encodes list of query parameters and returns encoded query string.
 *
 * @example
 * // returns 'foo=bar&=foo%26bar'
 * encodeQueryParams([{ key: 'foo', value: 'bar' }, { value: 'foo&bar' }])
 *
 * // returns 'q1=foo&q2=bar&q2=baz'
 * encodeQueryParams({ q1: 'foo', q2: ['bar', 'baz'] })
 *
 * @param {Object|Object[]} params Query params to encode
 * @returns {String} Percent-encoded query string
 */
function encodeQueryParams (params) {
    let i,
        j,
        ii,
        jj,
        paramKey,
        paramKeys,
        paramValue,
        result = E,
        notFirstParam = false;

    if (!(params && typeof params === OBJECT)) {
        return E;
    }

    // handle array of query params
    if (Array.isArray(params)) {
        for (i = 0, ii = params.length; i < ii; i++) {
            // @todo Add helper in PropertyList to filter disabled QueryParam
            if (!params[i] || params[i].disabled === true) {
                continue;
            }

            // don't add '&' for the very first enabled param
            notFirstParam && (result += AMPERSAND);
            notFirstParam = true;

            result += encodeQueryParam(params[i]);
        }

        return result;
    }

    // handle object with query params
    paramKeys = Object.keys(params);

    for (i = 0, ii = paramKeys.length; i < ii; i++) {
        paramKey = paramKeys[i];
        paramValue = params[paramKey];

        // { key: ['value1', 'value2', 'value3'] }
        if (Array.isArray(paramValue)) {
            for (j = 0, jj = paramValue.length; j < jj; j++) {
                notFirstParam && (result += AMPERSAND);
                notFirstParam = true;

                result += encodeQueryParam({ key: paramKey, value: paramValue[j] });
            }
        }
        // { key: 'value' }
        else {
            notFirstParam && (result += AMPERSAND);
            notFirstParam = true;

            result += encodeQueryParam({ key: paramKey, value: paramValue });
        }
    }

    return result;
}

/**
 * Percent-encode the given string with the given {@link EncodeSet}.
 *
 * @example <caption>Defaults to C0_CONTROL_ENCODE_SET</caption>
 * // returns 'foo %00 bar'
 * percentEncode('foo \u0000 bar')
 *
 * @example <caption>Encode literal @ using custom EncodeSet</caption>
 * // returns 'foo%40bar'
 * percentEncode('foo@bar', new EncodeSet(['@']))
 *
 * @param {String} value String to percent-encode
 * @param {EncodeSet} [encodeSet=C0_CONTROL_ENCODE_SET] EncodeSet to use for encoding
 * @returns {String} Percent-encoded string
 */
function percentEncode (value, encodeSet) {
    if (!(value && typeof value === STRING)) {
        return E;
    }

    // defaults to C0_CONTROL_ENCODE_SET
    if (!EncodeSet.isEncodeSet(encodeSet)) {
        encodeSet = C0_CONTROL_ENCODE_SET;
    }

    return _percentEncode(value, encodeSet);
}

/**
 * Percent encode a character with given code.
 *
 * @example
 * // returns '%20'
 * percentEncodeCharCode(32)
 *
 * @param {Number} code Character code
 * @returns {String} Percent-encoded character
 */
function percentEncodeCharCode (code) {
    // ensure [0x00, 0xFF] range
    if (!(Number.isInteger(code) && code >= 0 && code <= 0xFF)) {
        return E;
    }

    return _percentEncodeCharCode(code);
}

module.exports = {
    // URL components
    encodeHost,
    encodePath,
    encodeUserInfo,
    encodeFragment,
    encodeQueryParam,
    encodeQueryParams,

    /** @type EncodeSet */
    EncodeSet,

    // Utilities
    percentEncode,
    percentEncodeCharCode
};
/**
 * This modules provides simple percent (URI) encoding.
 *
 * @note Safety check for input types is not done intentionally as these
 * functions are invoked in the hot code path.
 *
 * @private
 * @module postman-url-encoder/encoder/percent-encode
 */

/**
 * @fileoverview
 * A percent-encoding mechanism is used to represent a data octet in a component
 * when that octet's corresponding character is outside the allowed set or is
 * being used as a delimiter of, or within, the component.
 * A percent-encoded octet is encoded as a character triplet, consisting of the
 * percent character "%" followed by the two hexadecimal digits representing
 * that octet's numeric value.
 *
 * For example, "%20" is the percent-encoding for the binary octet "00100000"
 * (ABNF: %x20), which in US-ASCII corresponds to the space character (SP).
 *
 * @see {@link https://en.wikipedia.org/wiki/Percent-encoding}
 * @see {@link https://tools.ietf.org/html/rfc3986#section-2.1}
 */

const E = '',
    ZERO = '0',
    PERCENT = '%';

/**
 * Checks if character with given code is valid hexadecimal digit or not.
 *
 * @private
 * @param {Number} byte Byte
 * @returns {Boolean}
 */
function isPreEncodedCharacter (byte) {
    return (byte >= 0x30 && byte <= 0x39) || // 0-9
        (byte >= 0x41 && byte <= 0x46) || // A-F
        (byte >= 0x61 && byte <= 0x66); // a-f
}

/**
 * Checks if character at given index in the buffer is already percent encoded or not.
 *
 * @private
 * @param {Buffer} buffer Buffer to check the character from
 * @param {Number} i Index of the character to check
 * @returns {Boolean} true if the character is encoded, false otherwise
 */
function isPreEncoded (buffer, i) {
    // if it is % check next two bytes for percent encode characters
    // looking for pattern %00 - %FF
    return buffer[i] === 0x25 && // %
        isPreEncodedCharacter(buffer[i + 1]) &&
        isPreEncodedCharacter(buffer[i + 2]);
}

/**
 * Percent encode a character with given code.
 *
 * @example
 * // returns '%20'
 * encodeCharCode(32)
 *
 * @param {Number} code Character code
 * @returns {String} Percent-encoded character
 */
function encodeCharCode (code) {
    let hex = code.toString(16).toUpperCase();

    (hex.length === 1) && (hex = ZERO + hex);

    return PERCENT + hex;
}

/**
 * Percent-encode the given string with the given {@link EncodeSet}.
 *
 * @example
 * // returns 'foo%40bar'
 * encode('foo@bar', new EncodeSet(['@']))
 *
 * @param {String} value String to percent-encode
 * @param {EncodeSet} encodeSet EncodeSet to use for encoding
 * @returns {String} Percent-encoded string
 */
function encode (value, encodeSet) {
    let i,
        ii,
        charCode,
        encoded = E,
        buffer = Buffer.from(value);

    for (i = 0, ii = buffer.length; i < ii; ++i) {
        // avoid double encoding
        if (i < ii - 2 && isPreEncoded(buffer, i)) {
            encoded += PERCENT + String.fromCharCode(buffer[++i], buffer[++i]);
            continue;
        }

        charCode = buffer[i];

        encoded += encodeSet.has(charCode) ?
            // encode if char code present in encodeSet
            encodeCharCode(charCode) :
            // or, append string from char code
            String.fromCharCode(charCode);
    }

    return encoded;
}

module.exports = {
    encode,
    encodeCharCode
};
/**
 * Implementation of the WHATWG URL Standard.
 *
 * @example
 * const urlEncoder = require('postman-url-encoder')
 *
 * // Encoding URL string to Node.js compatible Url object
 * urlEncoder.toNodeUrl('.com/foo&bar/{baz}?q=("foo")#`hash`')
 *
 * // Encoding URI component
 * urlEncoder.encode('qry trng')
 *
 * // Encoding query string object
 * urlEncoder.encodeQueryString({ q1: 'foo', q2: ['br', 'ba'] })
 *
 * @module postman-url-encoder
 * @see {@link https://url.spec.whatwg.org}
 */

const querystring = require('querystring'),

    legacy = require('./legacy'),
    parser = require('./parser'),
    encoder = require('./encoder'),
    QUERY_ENCODE_SET = require('./encoder/encode-set').QUERY_ENCODE_SET,

    E = '',
    COLON = ':',
    BACK_SLASH = '\\',
    DOUBLE_SLASH = '//',
    DOUBLE_BACK_SLASH = '\\\\',
    STRING = 'string',
    OBJECT = 'object',
    FUNCTION = 'function',
    DEFAULT_PROTOCOL = 'http',
    LEFT_SQUARE_BRACKET = '[',
    RIGHT_SQUARE_BRACKET = ']',

    PATH_SEPARATOR = '/',
    QUERY_SEPARATOR = '?',
    PARAMS_SEPARATOR = '&',
    SEARCH_SEPARATOR = '#',
    DOMAIN_SEPARATOR = '.',
    AUTH_CREDENTIALS_SEPARATOR = '@',

    // @note this regular expression is referred from Node.js URL parser
    PROTOCOL_RE = /^[a-z0-9.+-]+:(?:\/\/|\\\\)./i,

    /**
     * Protocols that always contain a // bit.
     *
     * @private
     * @see {@link https://github.com/nodejs/node/blob/v10.17.0/lib/url.js#L91}
     */
    SLASHED_PROTOCOLS = {
        'file:': true,
        'ftp:': true,
        'gopher:': true,
        'http:': true,
        'https:': true,
        'ws:': true,
        'wss:': true
    };

/**
 * Returns stringified URL from Url object but only includes parts till given
 * part name.
 *
 * @example
 * var url = 'http://postman.com/foo?q=v#hash';
 * getUrlTill(toNodeUrl(url), 'host')
 * // returns 'http://postman.com'
 *
 * @private
 * @param {Object} url base URL
 * @param {String} [urlPart='query'] one of ['host', 'pathname', 'query']
 */
function getUrlTill (url, urlPart) {
    let result = '';

    if (url.protocol) {
        result += url.protocol + DOUBLE_SLASH;
    }

    if (url.auth) {
        result += url.auth + AUTH_CREDENTIALS_SEPARATOR;
    }

    result += url.host || E;

    if (urlPart === 'host') { return result; }

    result += url.pathname;

    if (urlPart === 'pathname') { return result; }

    // urlPart must be query at this point
    return result + (url.search || E);
}

/**
 * Percent-encode the given string using QUERY_ENCODE_SET.
 *
 * @deprecated since version 2.0, use {@link encodeQueryParam} instead.
 *
 * @example
 * // returns 'foo%20%22%23%26%27%3C%3D%3E%20bar'
 * encode('foo "#&\'<=> bar')
 *
 * // returns ''
 * encode(['foobar'])
 *
 * @param {String} value String to percent-encode
 * @returns {String} Percent-encoded string
 */
function encode (value) {
    return encoder.percentEncode(value, QUERY_ENCODE_SET);
}

/**
 * Percent-encode the URL query string or x-www-form-urlencoded body object
 * according to RFC3986.
 *
 * @example
 * // returns 'q1=foo&q2=bar&q2=baz'
 * encodeQueryString({ q1: 'foo', q2: ['bar', 'baz'] })
 *
 * @param {Object} query Object representing query or urlencoded body
 * @returns {String} Percent-encoded string
 */
function encodeQueryString (query) {
    if (!(query && typeof query === OBJECT)) {
        return E;
    }

    // rely upon faster querystring module
    query = querystring.stringify(query);

    // encode characters not encoded by querystring.stringify() according to RFC3986.
    return query.replace(/[!'()*]/g, function (c) {
        return encoder.percentEncodeCharCode(c.charCodeAt(0));
    });
}

/**
 * Converts PostmanUrl / URL string into Node.js compatible Url object.
 *
 * @example <caption>Using URL string</caption>
 * toNodeUrl('.com/foo&bar/{baz}?q=("foo")#`hash`')
 * // returns
 * // {
 * //     protocol: 'http:',
 * //     slashes: true,
 * //     auth: null,
 * //     host: 'xn--48jwgn17gdel797d.com',
 * //     port: null,
 * //     hostname: 'xn--48jwgn17gdel797d.com',
 * //     hash: '#%60hash%60',
 * //     search: '?q=(%22foo%22)',
 * //     query: 'q=(%22foo%22)',
 * //     pathname: '/foo&bar/%7Bbaz%7D',
 * //     path: '/foo&bar/%7Bbaz%7D?q=(%22foo%22)',
 * //     href: 'http://xn--48jwgn17gdel797d.com/foo&bar/%7Bbaz%7D?q=(%22foo%22)#%60hash%60'
 * //  }
 *
 * @example <caption>Using PostmanUrl instance</caption>
 * toNodeUrl(new sdk.Url({
 *     host: 'example.com',
 *     query: [{ key: 'foo', value: 'bar & baz' }]
 * }))
 *
 * @param {PostmanUrl|String} url URL string or PostmanUrl object
 * @param {Boolean} disableEncoding Turn encoding off
 * @returns {Url} Node.js like parsed and encoded object
 */
function toNodeUrl (url, disableEncoding) {
    let nodeUrl = {
            protocol: null,
            slashes: null,
            auth: null,
            host: null,
            port: null,
            hostname: null,
            hash: null,
            search: null,
            query: null,
            pathname: null,
            path: null,
            href: E
        },
        port,
        hostname,
        pathname,
        authUser,
        queryParams,
        authPassword;

    // Check if PostmanUrl instance and prepare segments
    if (url && url.constructor && url.constructor._postman_propertyName === 'Url') {
        // @note getPath() always adds a leading '/', similar to Node.js API
        pathname = url.getPath();
        hostname = url.getHost().toLowerCase();

        if (url.query && url.query.count()) {
            queryParams = url.getQueryString({ ignoreDisabled: true });
            queryParams = disableEncoding ? queryParams : encoder.encodeQueryParam(queryParams);

            // either all the params are disabled or a single param is like { key: '' } (http://localhost?)
            // in that case, query separator ? must be included in the raw URL.
            // @todo Add helper in SDK to handle this
            if (queryParams === E) {
                // check if there's any enabled param, if so, set queryString to empty string
                // otherwise (all disabled), it will be set as undefined
                queryParams = url.query.find(function (param) { return !(param && param.disabled); }) && E;
            }
        }

        if (url.auth) {
            authUser = url.auth.user;
            authPassword = url.auth.password;
        }
    }
    // Parser URL string and prepare segments
    else if (typeof url === STRING) {
        url = parser.parse(url);

        pathname = PATH_SEPARATOR + (url.path || []).join(PATH_SEPARATOR);
        hostname = (url.host || []).join(DOMAIN_SEPARATOR).toLowerCase();
        queryParams = url.query && (queryParams = url.query.join(PARAMS_SEPARATOR)) &&
            (disableEncoding ? queryParams : encoder.encodeQueryParam(queryParams));
        authUser = (url.auth || [])[0];
        authPassword = (url.auth || [])[1];
    }
    // bail out with empty URL object for invalid input
    else {
        return nodeUrl;
    }

    // @todo Add helper in SDK to normalize port
    // eslint-disable-next-line no-eq-null, eqeqeq
    if (!(url.port == null) && typeof url.port.toString === FUNCTION) {
        port = url.port.toString();
    }

    // #protocol
    nodeUrl.protocol = (typeof url.protocol === STRING) ? url.protocol.toLowerCase() : DEFAULT_PROTOCOL;
    nodeUrl.protocol += COLON;

    // #slashes
    nodeUrl.slashes = SLASHED_PROTOCOLS[nodeUrl.protocol] || false;

    // #href = protocol://
    nodeUrl.href = nodeUrl.protocol + DOUBLE_SLASH;

    // #auth
    if (url.auth) {
        if (typeof authUser === STRING) {
            nodeUrl.auth = disableEncoding ? authUser : encoder.encodeUserInfo(authUser);
        }

        if (typeof authPassword === STRING) {
            !nodeUrl.auth && (nodeUrl.auth = E);
            nodeUrl.auth += COLON + (disableEncoding ? authPassword : encoder.encodeUserInfo(authPassword));
        }

        if (typeof nodeUrl.auth === STRING) {
            // #href = protocol://user:password@
            nodeUrl.href += nodeUrl.auth + AUTH_CREDENTIALS_SEPARATOR;
        }
    }

    // #host, #hostname
    nodeUrl.host = nodeUrl.hostname = hostname = encoder.encodeHost(hostname); // @note always encode hostname

    // #href = protocol://user:password@host.name
    nodeUrl.href += nodeUrl.hostname;

    // #port
    if (typeof port === STRING) {
        nodeUrl.port = port;

        // #host = (#hostname):(#port)
        nodeUrl.host = nodeUrl.hostname + COLON + port;

        // #href = protocol://user:password@host.name:port
        nodeUrl.href += COLON + port;
    }

    // #path, #pathname
    nodeUrl.path = nodeUrl.pathname = disableEncoding ? pathname : encoder.encodePath(pathname);

    // #href = protocol://user:password@host.name:port/p/a/t/h
    nodeUrl.href += nodeUrl.pathname;

    if (typeof queryParams === STRING) {
        // #query
        nodeUrl.query = queryParams;

        // #search
        nodeUrl.search = QUERY_SEPARATOR + nodeUrl.query;

        // #path = (#pathname)?(#search)
        nodeUrl.path = nodeUrl.pathname + nodeUrl.search;

        // #href = protocol://user:password@host.name:port/p/a/t/h?q=query
        nodeUrl.href += nodeUrl.search;
    }

    if (typeof url.hash === STRING) {
        // #hash
        nodeUrl.hash = SEARCH_SEPARATOR + (disableEncoding ? url.hash : encoder.encodeFragment(url.hash));

        // #href = protocol://user:password@host.name:port/p/a/t/h?q=query#hash
        nodeUrl.href += nodeUrl.hash;
    }

    // Finally apply Node.js shenanigans
    // # Remove square brackets from IPv6 #hostname
    // Refer: https://github.com/nodejs/node/blob/v12.18.3/lib/url.js#L399
    // Refer: https://github.com/nodejs/node/blob/v12.18.3/lib/internal/url.js#L1273
    if (hostname[0] === LEFT_SQUARE_BRACKET && hostname[hostname.length - 1] === RIGHT_SQUARE_BRACKET) {
        nodeUrl.hostname = hostname.slice(1, -1);
    }

    return nodeUrl;
}

/**
 * Resolves a relative URL with respect to given base URL.
 * This is a replacement method for Node's url.resolve() which is compatible
 * with URL object generated by toNodeUrl().
 *
 * @example
 * // returns 'http://postman.com/baz'
 * resolveNodeUrl('http://postman.com/foo/bar', '/baz')
 *
 * @param {Object|String} base URL string or toNodeUrl() object
 * @param {String} relative Relative URL to resolve
 * @returns {String} Resolved URL
 */
function resolveNodeUrl (base, relative) {
    // normalize arguments
    typeof base === STRING && (base = toNodeUrl(base));
    typeof relative !== STRING && (relative = E);

    // bail out if base is not an object
    if (!(base && typeof base === OBJECT)) {
        return relative;
    }

    let i,
        ii,
        index,
        baseHref,
        relative_0,
        relative_01,
        basePathname,
        requiredProps = ['protocol', 'auth', 'host', 'pathname', 'search', 'href'];

    // bail out if base is not like Node url object
    for (i = 0, ii = requiredProps.length; i < ii; i++) {
        if (!Object.hasOwnProperty.call(base, requiredProps[i])) {
            return relative;
        }
    }

    // cache base.href and base.pathname
    baseHref = base.href;
    basePathname = base.pathname;

    // cache relative's first two chars
    relative_0 = relative.slice(0, 1);
    relative_01 = relative.slice(0, 2);

    // @note relative can be one of
    // #1 empty string
    // #2 protocol relative, starts with // or \\
    // #3 path relative, starts with / or \
    // #4 just query or hash, starts with ? or #
    // #5 absolute URL, starts with :// or :\\
    // #6 free from path, with or without query and hash

    // #1 empty string
    if (!relative) {
        // return base as it is if there is no hash
        if ((index = baseHref.indexOf(SEARCH_SEPARATOR)) === -1) {
            return baseHref;
        }

        // else, return base without the hash
        return baseHref.slice(0, index);
    }

    // #2 protocol relative, starts with // or \\
    // @note \\ is not converted to //
    if (relative_01 === DOUBLE_SLASH || relative_01 === DOUBLE_BACK_SLASH) {
        return base.protocol + relative;
    }

    // #3 path relative, starts with / or \
    // @note \(s) are not converted to /
    if (relative_0 === PATH_SEPARATOR || relative_0 === BACK_SLASH) {
        return getUrlTill(base, 'host') + relative;
    }

    // #4 just hash, starts with #
    if (relative_0 === SEARCH_SEPARATOR) {
        return getUrlTill(base, 'query') + relative;
    }

    // #4 just query, starts with ?
    if (relative_0 === QUERY_SEPARATOR) {
        return getUrlTill(base, 'pathname') + relative;
    }

    // #5 absolute URL, starts with :// or :\\
    // @note :\\ is not converted to ://
    if (PROTOCOL_RE.test(relative)) {
        return relative;
    }

    // #6 free from path, with or without query and hash
    // remove last path segment form base path
    basePathname = basePathname.slice(0, basePathname.lastIndexOf(PATH_SEPARATOR) + 1);

    return getUrlTill(base, 'host') + basePathname + relative;
}

/**
 * Converts URL string into Node.js compatible Url object using the v1 encoder.
 *
 * @deprecated since version 2.0
 *
 * @param {String} url URL string
 * @returns {Url} Node.js compatible Url object
 */
function toLegacyNodeUrl (url) {
    return legacy.toNodeUrl(url);
}

module.exports = {
    encode,
    toNodeUrl,
    resolveNodeUrl,
    toLegacyNodeUrl,
    encodeQueryString
};
var url = require('url'),

    /**
     * @private
     * @const
     * @type {String}
     */
    E = '',

    /**
     * @private
     * @const
     * @type {String}
     */
    QUERY_SEPARATOR = '?',

    /**
     * @private
     * @const
     * @type {String}
     */
    AMPERSAND = '&',

    /**
     * @private
     * @const
     * @type {String}
     */
    EQUALS = '=',

    /**
     * @private
     * @const
     * @type {String}
     */
    PERCENT = '%',

    /**
     * @private
     * @const
     * @type {string}
     */
    ZERO = '0',

    /**
     * @private
     * @const
     * @type {string}
     */
    STRING = 'string',

    encoder;

encoder = {
    /**
     * Percent encode a character with given code.
     *
     * @param {Number} c - character code of the character to encode
     * @returns {String} - percent encoding of given character
     */
    percentEncode (c) {
        var hex = c.toString(16).toUpperCase();

        (hex.length === 1) && (hex = ZERO + hex);

        return PERCENT + hex;
    },

    /**
     * Checks if character at given index in the buffer is already percent encoded or not.
     *
     * @param {Buffer} buffer -
     * @param {Number} i -
     * @returns {Boolean}
     */
    isPreEncoded (buffer, i) {
        // If it is % check next two bytes for percent encode characters
        // looking for pattern %00 - %FF
        return (buffer[i] === 0x25 &&
            (encoder.isPreEncodedCharacter(buffer[i + 1]) &&
            encoder.isPreEncodedCharacter(buffer[i + 2]))
        );
    },

    /**
     * Checks if character with given code is valid hexadecimal digit or not.
     *
     * @param {Number} byte -
     * @returns {Boolean}
     */
    isPreEncodedCharacter (byte) {
        return (byte >= 0x30 && byte <= 0x39) || // 0-9
            (byte >= 0x41 && byte <= 0x46) || // A-F
            (byte >= 0x61 && byte <= 0x66); // a-f
    },

    /**
     * Checks whether given character should be percent encoded or not for fixture.
     *
     * @param {Number} byte -
     * @returns {Boolean}
     */
    charactersToPercentEncode (byte) {
        return (byte < 0x23 || byte > 0x7E || // Below # and after ~
            byte === 0x3C || byte === 0x3E || // > and <
            byte === 0x28 || byte === 0x29 || // ( and )
            byte === 0x25 || // %
            byte === 0x27 || // '
            byte === 0x2A // *
        );
    },

    /**
     * Percent encode a query string according to RFC 3986.
     * Note: This function is supposed to be used on top of node's inbuilt url encoding
     *       to solve issue https://github.com/nodejs/node/issues/8321
     *
     * @param {String} value -
     * @returns {String}
     */
    encode (value) {
        if (!value) { return E; }

        var buffer = Buffer.from(value),
            ret = E,
            i,
            ii;

        for (i = 0, ii = buffer.length; i < ii; ++i) {
            if (encoder.charactersToPercentEncode(buffer[i]) && !encoder.isPreEncoded(buffer, i)) {
                ret += encoder.percentEncode(buffer[i]);
            }
            else {
                ret += String.fromCodePoint(buffer[i]); // Only works in ES6 (available in Node v4+)
            }
        }

        return ret;
    }
};

/**
 * Parses a query string into an array, preserving parameter values
 *
 * @private
 * @param {String} string -
 * @returns {*}
 */
function parseQueryString (string) {
    var parts;

    if (typeof string === STRING) {
        parts = string.split(AMPERSAND);

        return parts.map(function (param, idx) {
            if (param === E && idx !== (parts.length - 1)) {
                return { key: null, value: null };
            }

            var index = (typeof param === STRING) ? param.indexOf(EQUALS) : -1,
                paramObj = {};

            // this means that there was no value for this key (not even blank,
            // so we store this info) and the value is set to null
            if (index < 0) {
                paramObj.key = param.substr(0, param.length);
                paramObj.value = null;
            }
            else {
                paramObj.key = param.substr(0, index);
                paramObj.value = param.substr(index + 1);
            }

            return paramObj;
        });
    }

    return [];
}

/**
 * Stringifies a query string, from an array of parameters
 *
 * @private
 * @param {Object[]} parameters -
 * @returns {string}
 */
function stringifyQueryParams (parameters) {
    return parameters ? parameters.map(function (param) {
        var key = param.key,
            value = param.value;

        if (value === undefined) {
            return E;
        }

        if (key === null) {
            key = E;
        }

        if (value === null) {
            return encoder.encode(key);
        }

        return encoder.encode(key) + EQUALS + encoder.encode(value);
    }).join(AMPERSAND) : E;
}

/**
 * Converts URL string into Node's Url object with encoded values
 *
 * @private
 * @param {String} urlString -
 * @returns {Url}
 */
function toNodeUrl (urlString) {
    var parsed = url.parse(urlString),
        rawQs = parsed.query,
        qs,
        search,
        path,
        str;

    if (!(rawQs && rawQs.length)) { return parsed; }

    qs = stringifyQueryParams(parseQueryString(rawQs));
    search = QUERY_SEPARATOR + qs;
    path = parsed.pathname + search;

    parsed.query = qs;
    parsed.search = search;
    parsed.path = path;

    str = url.format(parsed);

    // Parse again, because Node does not guarantee consistency of properties
    return url.parse(str);
}

module.exports = {
    toNodeUrl
};
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS
{
  "name": "postman-url-encoder",
  "version": "3.0.5",
  "description": "Implementation of the WHATWG URL Standard",
  "author": "Postman Inc.",
  "license": "Apache-2.0",
  "main": "index.js",
  "homepage": "https://github.com/postmanlabs/postman-url-encoder#readme",
  "bugs": {
    "url": "https://github.com/postmanlabs/postman-url-encoder/issues",
    "email": "help@postman.com"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/postman-url-encoder.git"
  },
  "keywords": [
    "postman",
    "url-encoder",
    "url-parser",
    "whatwg-url"
  ],
  "scripts": {
    "build-docs": "node npm/build-docs.js",
    "codecov": "node npm/publish-coverage.js",
    "release": "node npm/create-release.js",
    "test": "npm run test-lint && npm run test-unit && npm run test-browser",
    "test-benchmark": "node npm/test-benchmark.js",
    "test-browser": "node npm/test-browser.js",
    "test-lint": "node npm/test-lint.js",
    "test-system": "node npm/test-system.js",
    "test-unit": "nyc --nycrc-path=.nycrc.js node npm/test-unit.js"
  },
  "dependencies": {
    "punycode": "^2.1.1"
  },
  "devDependencies": {
    "@postman/csv-parse": "^4.0.2",
    "@postman/shipit": "^0.3.0",
    "async": "^3.2.1",
    "bipbip": "^0.4.2",
    "browserify": "^17.0.0",
    "chai": "^4.3.4",
    "chalk": "^4.1.2",
    "colors": "^1.4.0",
    "editorconfig": "^0.15.3",
    "eslint": "^7.32.0",
    "eslint-plugin-jsdoc": "^36.0.7",
    "eslint-plugin-lodash": "^7.3.0",
    "eslint-plugin-mocha": "^9.0.0",
    "eslint-plugin-security": "^1.4.0",
    "jsdoc": "^3.6.7",
    "karma": "^6.3.4",
    "karma-browserify": "^8.1.0",
    "karma-chrome-launcher": "^3.1.0",
    "karma-mocha": "^2.0.1",
    "karma-mocha-reporter": "^2.2.5",
    "mocha": "^9.0.3",
    "nyc": "^15.1.0",
    "parse-gitignore": "^1.0.1",
    "postman-collection": "^4.0.2",
    "postman-jsdoc-theme": "^0.0.3",
    "recursive-readdir": "^2.2.2",
    "shelljs": "^0.8.3",
    "watchify": "^4.0.0"
  },
  "engines": {
    "node": ">=10"
  }
}
/**
 * This module helps to break URL strings up into components
 * (protocol, auth, host, port, path, query, and hash) keeping the variables
 * intact.
 *
 * @example
 * const parser = require('postman-url-encoder/parser')
 *
 * // returns
 * // {
 * //   raw: 'protocol://{{user}}:{{p@ssw?rd}}@{{host.name}}.com:{{#port}}/p/a/t/h?q=query#hash',
 * //   protocol: 'protocol',
 * //   auth: [ '{{user}}', '{{p@ssw?rd}}' ],
 * //   host: [ '{{host.name}}', 'com' ],
 * //   port: '{{#port}}',
 * //   path: [ 'p', 'a', 't', 'h' ],
 * //   query: [ 'q=query' ],
 * //   hash: 'hash'
 * // }
 * parser.parse('protocol://{{user}}:{{p@ssw?rd}}@{{host.name}}.com:{{#port}}/p/a/t/h?q=query#hash')
 *
 * @module postman-url-encoder/parser
 */

const ReplacementTracker = require('./replacement-tracker'),

    REGEX_ALL_BACKSLASHES = /\\/g,
    REGEX_LEADING_SLASHES = /^\/+/,
    REGEX_ALL_VARIABLES = /{{[^{}]*[.:/?#@&\]][^{}]*}}/g,

    HASH_SEPARATOR = '#',
    PATH_SEPARATOR = '/',
    PORT_SEPARATOR = ':',
    AUTH_SEPARATOR = '@',
    QUERY_SEPARATOR = '?',
    DOMAIN_SEPARATOR = '.',
    PROTOCOL_SEPARATOR = '://',
    AUTH_SEGMENTS_SEPARATOR = ':',
    QUERY_SEGMENTS_SEPARATOR = '&',

    E = '',
    STRING = 'string',
    FILE_PROTOCOL = 'file',
    SAFE_REPLACE_CHAR = '_',
    CLOSING_SQUARE_BRACKET = ']',
    URL_PROPERTIES_ORDER = ['protocol', 'auth', 'host', 'port', 'path', 'query', 'hash'];

/**
 * Normalize the given string by replacing the variables which includes
 * reserved characters in its name.
 * The replaced characters are added to the given replacement tracker instance.
 *
 * @private
 * @param {String} str String to normalize
 * @param {ReplacementTracker} replacements ReplacementTracker instance
 * @returns {String} Normalized string
 */
function normalizeVariables (str, replacements) {
    let normalizedString = E,
        pointer = 0, // pointer till witch the string is normalized
        variable,
        match,
        index;

    // find all the instances of {{<variable>}} which includes reserved chars
    // "Hello {{user#name}}!!!"
    //   (pointer = 0)
    while ((match = REGEX_ALL_VARIABLES.exec(str)) !== null) {
        // {{user#name}}
        variable = match[0];

        // starting index of the {{variable}} in the string
        // "Hello {{user#name}}!!!"
        //         (index = 6)
        index = match.index;

        // [pointer, index) string is normalized + the safe replacement character
        // "Hello " + "_"
        normalizedString += str.slice(pointer, index) + SAFE_REPLACE_CHAR;

        // track the replacement done for the {{variable}}
        replacements.add(variable, index);

        // update the pointer
        // "Hello {{user#name}}!!!"
        //                      (pointer = 19)
        pointer = index + variable.length;
    }

    // avoid slicing the string in case of no matches
    if (pointer === 0) {
        return str;
    }

    // whatever left in the string is normalized as well
    /* istanbul ignore else */
    if (pointer < str.length) {
        // "Hello _" + "!!!"
        normalizedString += str.slice(pointer);
    }

    return normalizedString;
}

/**
 * Update replaced characters in the URL object with its original value.
 *
 * @private
 * @param {Object} url URL tracker object
 * @param {ReplacementTracker} replacements ReplacementTracker instance
 */
function applyReplacements (url, replacements) {
    let i,
        ii,
        prop;

    // traverse each URL property in the given order
    for (i = 0, ii = URL_PROPERTIES_ORDER.length; i < ii; ++i) {
        prop = url[URL_PROPERTIES_ORDER[i]];

        // bail out if the given property is not set (undefined or '')
        if (!(prop && prop.value)) {
            continue;
        }

        prop.value = replacements.apply(prop.value, prop.beginIndex, prop.endIndex);
    }

    return url;
}

/**
 * Parses the input string by decomposing the URL into constituent parts,
 * such as path, host, port, etc.
 *
 * @param {String} urlString The URL string to parse
 * @returns {Object} Parsed URL object
 */
function parse (urlString) {
    let url = {
            protocol: { value: undefined, beginIndex: 0, endIndex: 0 },
            auth: { value: undefined, beginIndex: 0, endIndex: 0 },
            host: { value: undefined, beginIndex: 0, endIndex: 0 },
            port: { value: undefined, beginIndex: 0, endIndex: 0 },
            path: { value: undefined, beginIndex: 0, endIndex: 0 },
            query: { value: undefined, beginIndex: 0, endIndex: 0 },
            hash: { value: undefined, beginIndex: 0, endIndex: 0 }
        },
        parsedUrl = {
            raw: urlString,
            protocol: undefined,
            auth: undefined,
            host: undefined,
            port: undefined,
            path: undefined,
            query: undefined,
            hash: undefined
        },
        replacements = new ReplacementTracker(),
        pointer = 0,
        _length,
        length,
        index,
        port;

    // bail out if input string is empty
    if (!(urlString && typeof urlString === STRING)) {
        return parsedUrl;
    }

    // trim leading whitespace characters
    parsedUrl.raw = urlString = urlString.trimLeft();

    // normalize the given string
    urlString = normalizeVariables(urlString, replacements);
    length = urlString.length;

    // 1. url.hash
    if ((index = urlString.indexOf(HASH_SEPARATOR)) !== -1) {
        // extract from the back
        url.hash.value = urlString.slice(index + 1);
        url.hash.beginIndex = pointer + index + 1;
        url.hash.endIndex = pointer + length;

        urlString = urlString.slice(0, (length = index));
    }

    // 2. url.query
    if ((index = urlString.indexOf(QUERY_SEPARATOR)) !== -1) {
        // extract from the back
        url.query.value = urlString.slice(index + 1).split(QUERY_SEGMENTS_SEPARATOR);
        url.query.beginIndex = pointer + index + 1;
        url.query.endIndex = pointer + length;

        urlString = urlString.slice(0, (length = index));
    }

    // 3. url.protocol
    urlString = urlString.replace(REGEX_ALL_BACKSLASHES, PATH_SEPARATOR); // sanitize slashes

    // @todo support `protocol:host/path` and `protocol:/host/path`
    if ((index = urlString.indexOf(PROTOCOL_SEPARATOR)) !== -1) {
        // extract from the front
        url.protocol.value = urlString.slice(0, index);
        url.protocol.beginIndex = pointer;
        url.protocol.endIndex = pointer + index;

        urlString = urlString.slice(index + 3);
        length -= index + 3;
        pointer += index + 3;

        // special handling for extra slashes in protocol e.g, http:///example.com
        _length = length; // length with leading slashes

        urlString = urlString.replace(REGEX_LEADING_SLASHES,
            (url.protocol.value.toLowerCase() === FILE_PROTOCOL) ?
                // file:////path -> file:///path
                PATH_SEPARATOR :
                // protocol:////host/path -> protocol://host/path
                E);

        length = urlString.length; // length without slashes
        pointer += _length - length; // update pointer
    }

    // 4. url.path
    if ((index = urlString.indexOf(PATH_SEPARATOR)) !== -1) {
        // extract from the back
        url.path.value = urlString.slice(index + 1).split(PATH_SEPARATOR);
        url.path.beginIndex = pointer + index + 1;
        url.path.endIndex = pointer + length;

        urlString = urlString.slice(0, (length = index));
    }

    // 5. url.auth
    if ((index = urlString.lastIndexOf(AUTH_SEPARATOR)) !== -1) {
        // extract from the front
        url.auth.value = urlString.slice(0, index);
        url.auth.beginIndex = pointer;
        url.auth.endIndex = pointer + index;

        urlString = urlString.slice(index + 1);
        length -= index + 1;
        pointer += index + 1;

        // separate username:password
        if ((index = url.auth.value.indexOf(AUTH_SEGMENTS_SEPARATOR)) !== -1) {
            url.auth.value = [url.auth.value.slice(0, index), url.auth.value.slice(index + 1)];
        }
        else {
            url.auth.value = [url.auth.value];
        }
    }

    // 6. url.port
    if ((index = urlString.lastIndexOf(PORT_SEPARATOR)) !== -1 &&
        // eslint-disable-next-line lodash/prefer-includes
        (port = urlString.slice(index + 1)).indexOf(CLOSING_SQUARE_BRACKET) === -1
    ) {
        // extract from the back
        url.port.value = port;
        url.port.beginIndex = pointer + index + 1;
        url.port.endIndex = pointer + length;

        urlString = urlString.slice(0, (length = index));
    }

    // 7. url.host
    if (urlString) {
        url.host.value = urlString.split(DOMAIN_SEPARATOR);
        url.host.beginIndex = pointer;
        url.host.endIndex = pointer + length;
    }

    // apply replacements back, if any
    replacements.count() && applyReplacements(url, replacements);

    // finally, prepare parsed url
    parsedUrl.protocol = url.protocol.value;
    parsedUrl.auth = url.auth.value;
    parsedUrl.host = url.host.value;
    parsedUrl.port = url.port.value;
    parsedUrl.path = url.path.value;
    parsedUrl.query = url.query.value;
    parsedUrl.hash = url.hash.value;

    return parsedUrl;
}

module.exports = {
    parse
};

/**
 * Tracks replacements done on a string and expose utility to patch replacements.
 *
 * @note due to performance reasons, it doesn't store the original string or
 * perform ops on the string.
 *
 * @private
 * @constructor
 */
class ReplacementTracker {
    constructor () {
        this.replacements = [];
        this._offset = 0;
        this._length = 0;
    }

    /**
     * Add new replacement to track.
     *
     * @param {String} value -
     * @param {Number} index -
     */
    add (value, index) {
        this.replacements.push({
            value: value,
            index: index - this._offset
        });

        this._offset += value.length - 1; // - 1 replaced character
        this._length++;
    }

    /**
     * Returns the total number of replacements.
     *
     * @returns {Number}
     */
    count () {
        return this._length;
    }

    /**
     * Finds the lower index of replacement position for a given value using inexact
     * binary search.
     *
     * @private
     * @param {Number} index -
     * @returns {Number}
     */
    _findLowerIndex (index) {
        let length = this.count(),
            start = 0,
            end = length - 1,
            mid;

        while (start <= end) {
            mid = (start + end) >> 1; // divide by 2

            if (this.replacements[mid].index >= index) {
                end = mid - 1;
            }
            else {
                start = mid + 1;
            }
        }

        return start >= length ? -1 : start;
    }

    /**
     * Patches a given string by apply all the applicable replacements done in the
     * given range.
     *
     * @private
     * @param {String} input -
     * @param {Number} beginIndex -
     * @param {Number} endIndex -
     * @returns {String}
     */
    _applyInString (input, beginIndex, endIndex) {
        let index,
            replacement,
            replacementIndex,
            replacementValue,
            offset = 0,
            length = this.count();

        // bail out if no replacements are done in the given range OR empty string
        if (!input || (index = this._findLowerIndex(beginIndex)) === -1) {
            return input;
        }

        do {
            replacement = this.replacements[index];
            replacementIndex = replacement.index;
            replacementValue = replacement.value;

            // bail out if all the replacements are done in the given range
            if (replacementIndex >= endIndex) {
                break;
            }

            replacementIndex = offset + replacementIndex - beginIndex;
            input = input.slice(0, replacementIndex) + replacementValue + input.slice(replacementIndex + 1);
            offset += replacementValue.length - 1;
        } while (++index < length);

        return input;
    }

    /**
     * Patches a given string or array of strings by apply all the applicable
     * replacements done in the given range.
     *
     * @param {String|String[]} input -
     * @param {Number} beginIndex -
     * @param {Number} endIndex -
     * @returns {String|String[]}
     */
    apply (input, beginIndex, endIndex) {
        let i,
            ii,
            length,
            _endIndex,
            _beginIndex,
            value = input;

        // apply replacements in string
        if (typeof input === 'string') {
            return this._applyInString(input, beginIndex, endIndex);
        }

        // apply replacements in the splitted string (Array)
        _beginIndex = beginIndex;

        // traverse all the segments until all the replacements are patched
        for (i = 0, ii = input.length; i < ii; ++i) {
            value = input[i];
            _endIndex = _beginIndex + (length = value.length);

            // apply replacements applicable for individual segment
            input[i] = this._applyInString(value, _beginIndex, _endIndex);
            _beginIndex += length + 1; // + 1 separator
        }

        return input;
    }
}

module.exports = ReplacementTracker;
# Postman URL Encoder [![Build Status](https://travis-ci.com/postmanlabs/postman-url-encoder.svg?branch=develop)](https://travis-ci.com/postmanlabs/postman-url-encoder) [![codecov](https://codecov.io/gh/postmanlabs/postman-url-encoder/branch/develop/graph/badge.svg)](https://codecov.io/gh/postmanlabs/postman-url-encoder)

Postman URL Encoder is a NodeJS module that provides various URL encoding related APIs. This module is created to
implement the [WHATWG URL specification](https://url.spec.whatwg.org/) to remove dependency on Node's URL APIs across
Postman systems. These APIs are useful to encode different parts (like hostname, path, query) of URL and convert
[PostmanUrl](http://www.postmanlabs.com/postman-collection/Url.html) object into
[Node's Url](https://nodejs.org/dist/latest-v10.x/docs/api/url.html#url_legacy_urlobject) like object.

## Installing the Postman URL Encoder

Postman URL Encoder can be installed using NPM or directly from the git repository within your NodeJS projects. If
installing from NPM, the following command installs the module and saves in your `package.json`

```terminal
> npm install postman-url-encoder --save
```

## Getting Started

Following example snippet shows how to convert [PostmanUrl](http://www.postmanlabs.com/postman-collection/Url.html)
object into [Node's Url](https://nodejs.org/dist/latest-v10.x/docs/api/url.html#url_legacy_urlobject) like object.

```javascript
var PostmanUrl = require('postman-collection').Url,
    pmEncoder = require('postman-url-encoder'),
    myUrl;

// Create PostmanUrl object
myUrl = new PostmanUrl('http://example.com/p/a/t/h?q1=v1');

// convert PostmanUrl object to Node's Url like object
myUrl = pmEncoder.toNodeUrl(myUrl));
// {
//   protocol: 'http:',
//   slashes: true,
//   auth: null,
//   host: 'example.com',
//   port: null,
//   hostname: 'example.com',
//   hash: null,
//   search: '?q1=v1',
//   query: 'q1=v1',
//   pathname: '/p/a/t/h',
//   path: '/p/a/t/h?q1=v1',
//   href: 'http://example.com/p/a/t/h?q1=v1'
// }
```

To know more about provided APIs, head over to [Postman URL Encoder Docs](http://www.postmanlabs.com/postman-url-encoder).
{
  "name": "@postman/runtime.auth",
  "version": "0.1.13",
  "license": "UNLICENSED",
  "description": "The Postman ItemType extension: 'auth'",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/extensions/auth#readme",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "dependencies": {
    "create-hash": "^1.2.0",
    "create-hmac": "^1.1.7",
    "js-base64": "^3.7.5",
    "json-schema-to-ts": "~2.7.2",
    "postman-url-encoder": "^3.0.5"
  },
  "peerDependencies": {
    "@postman/runtime.core": "^0.4.0"
  },
  "devDependencies": {
    "@types/create-hash": "^1.2.2",
    "@types/create-hmac": "^1.1.0"
  },
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest"
  }
}# Extension: `auth`

This package defines the Postman ItemType extension: `auth`.
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": ["create-hash", "create-hmac"]
	},
	"references": [{ "path": "../../core/core" }]
}
import { FromSchema } from 'json-schema-to-ts';
import { ItemType } from '@postman/runtime.core';
import Documentation from '@postman/runtime.documentation';
declare const definition: {
    name: "collection";
    summary: "Save your requests in a collection for reuse and sharing";
    schema: {
        readonly type: "object";
        readonly properties: {
            readonly variables: {
                readonly type: "array";
                readonly items: {
                    readonly type: "object";
                    readonly required: ["key", "value"];
                    readonly properties: {
                        readonly key: {
                            readonly type: "string";
                        };
                        readonly value: {
                            readonly type: "string";
                        };
                        readonly disabled: {
                            readonly type: "boolean";
                        };
                    };
                    readonly additionalProperties: false;
                };
            };
        };
        readonly additionalProperties: false;
    };
    constraints: [{
        constraint: "allow-child-types";
        allowed: ["folder", "ws-raw-request", "ws-socketio-request", "grpc-request", "graphql-request"];
    }, {
        constraint: "allow-extensions";
        allowed: ["documentation"];
    }, {
        constraint: "require-extensions";
        required: ["documentation"];
    }];
};
declare namespace Collection {
    type Payload = FromSchema<typeof definition.schema>;
    type Extensions = Documentation;
    const use: () => ItemType.Specific<{
        variables?: {
            disabled?: boolean | undefined;
            key: string;
            value: string;
        }[] | undefined;
    }, Documentation, unknown, never, never>;
}
type Collection = ItemType.Specific<Collection.Payload, Collection.Extensions>;
export default Collection;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const json_schema_to_ts_1 = require("json-schema-to-ts");
const runtime_core_1 = require("@postman/runtime.core");
const runtime_documentation_1 = __importDefault(require("@postman/runtime.documentation"));
const definition = (0, json_schema_to_ts_1.asConst)({
    name: 'collection',
    summary: 'Save your requests in a collection for reuse and sharing',
    schema: {
        type: 'object',
        properties: {
            variables: {
                type: 'array',
                items: {
                    type: 'object',
                    required: ['key', 'value'],
                    properties: {
                        key: {
                            type: 'string',
                        },
                        value: {
                            type: 'string',
                        },
                        disabled: {
                            type: 'boolean',
                        },
                    },
                    additionalProperties: false,
                },
            },
        },
        additionalProperties: false,
    },
    constraints: [
        {
            constraint: 'allow-child-types',
            allowed: [
                'folder',
                'ws-raw-request',
                'ws-socketio-request',
                'grpc-request',
                'graphql-request',
            ],
        },
        {
            constraint: 'allow-extensions',
            allowed: ['documentation'],
        },
        {
            constraint: 'require-extensions',
            required: ['documentation'],
        },
    ],
});
const extensions = [runtime_documentation_1.default.use().implement({})];
var Collection;
(function (Collection) {
    Collection.use = runtime_core_1.ItemType.define(definition, extensions);
})(Collection || (Collection = {}));
exports.default = Collection;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;AAAA,yDAAoE;AACpE,wDAAiD;AACjD,2FAA2D;AAE3D,MAAM,UAAU,GAAG,IAAA,2BAAO,EAAC;IAC1B,IAAI,EAAE,YAAY;IAClB,OAAO,EAAE,0DAA0D;IACnE,MAAM,EAAE;QACP,IAAI,EAAE,QAAQ;QACd,UAAU,EAAE;YACX,SAAS,EAAE;gBACV,IAAI,EAAE,OAAO;gBACb,KAAK,EAAE;oBACN,IAAI,EAAE,QAAQ;oBACd,QAAQ,EAAE,CAAC,KAAK,EAAE,OAAO,CAAC;oBAC1B,UAAU,EAAE;wBACX,GAAG,EAAE;4BACJ,IAAI,EAAE,QAAQ;yBACd;wBACD,KAAK,EAAE;4BACN,IAAI,EAAE,QAAQ;yBACd;wBACD,QAAQ,EAAE;4BACT,IAAI,EAAE,SAAS;yBACf;qBACD;oBACD,oBAAoB,EAAE,KAAK;iBAC3B;aACD;SACD;QACD,oBAAoB,EAAE,KAAK;KACG;IAC/B,WAAW,EAAE;QACZ;YACC,UAAU,EAAE,mBAAmB;YAC/B,OAAO,EAAE;gBACR,QAAQ;gBACR,gBAAgB;gBAChB,qBAAqB;gBACrB,cAAc;gBACd,iBAAiB;aACjB;SACD;QACD;YACC,UAAU,EAAE,kBAAkB;YAC9B,OAAO,EAAE,CAAC,eAAe,CAAC;SAC1B;QACD;YACC,UAAU,EAAE,oBAAoB;YAChC,QAAQ,EAAE,CAAC,eAAe,CAAC;SAC3B;KACD;CACD,CAAC,CAAC;AAEH,MAAM,UAAU,GAAG,CAAC,+BAAa,CAAC,GAAG,EAAE,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC;AAEvD,IAAU,UAAU,CAOnB;AAPD,WAAU,UAAU;IAGN,cAAG,GAAG,uBAAQ,CAAC,MAAM,CACjC,UAAU,EACV,UAAU,CACV,CAAC;AACH,CAAC,EAPS,UAAU,KAAV,UAAU,QAOnB;AAGD,kBAAe,UAAU,CAAC"}{
  "name": "@postman/runtime.collection",
  "version": "0.1.13",
  "license": "UNLICENSED",
  "description": "The Postman ItemType: 'collection'",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/item-types/collection#readme",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "dependencies": {
    "json-schema-to-ts": "~2.7.2"
  },
  "peerDependencies": {
    "@postman/runtime.core": "^0.4.0",
    "@postman/runtime.documentation": "^0.1.13"
  },
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest"
  }
}# ItemType: `collection`

This package defines the Postman ItemType: `collection`.
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": []
	},
	"references": [
		{ "path": "../../core/core" },
		{ "path": "../../extensions/documentation" }
	]
}
import * as z from 'zod';
import Item from './item';
import ItemType from './item-type';
export declare const ConstraintSchema: z.ZodDiscriminatedUnion<"constraint", [z.ZodObject<{
    constraint: z.ZodLiteral<"allow-extensions">;
    allowed: z.ZodArray<z.ZodString, "many">;
}, "strict", z.ZodTypeAny, {
    constraint: "allow-extensions";
    allowed: string[];
}, {
    constraint: "allow-extensions";
    allowed: string[];
}>, z.ZodObject<{
    constraint: z.ZodLiteral<"require-extensions">;
    required: z.ZodArray<z.ZodString, "many">;
}, "strict", z.ZodTypeAny, {
    constraint: "require-extensions";
    required: string[];
}, {
    constraint: "require-extensions";
    required: string[];
}>, z.ZodObject<{
    constraint: z.ZodLiteral<"allow-child-types">;
    allowed: z.ZodArray<z.ZodString, "many">;
}, "strict", z.ZodTypeAny, {
    constraint: "allow-child-types";
    allowed: string[];
}, {
    constraint: "allow-child-types";
    allowed: string[];
}>, z.ZodObject<{
    constraint: z.ZodLiteral<"block-child-types">;
    blocked: z.ZodArray<z.ZodString, "many">;
}, "strict", z.ZodTypeAny, {
    constraint: "block-child-types";
    blocked: string[];
}, {
    constraint: "block-child-types";
    blocked: string[];
}>, z.ZodObject<{
    constraint: z.ZodLiteral<"limit-children">;
    limit: z.ZodNumber;
}, "strict", z.ZodTypeAny, {
    constraint: "limit-children";
    limit: number;
}, {
    constraint: "limit-children";
    limit: number;
}>, z.ZodObject<{
    constraint: z.ZodLiteral<"limit-children-by-type">;
    limits: z.ZodRecord<z.ZodString, z.ZodNumber>;
}, "strict", z.ZodTypeAny, {
    constraint: "limit-children-by-type";
    limits: Record<string, number>;
}, {
    constraint: "limit-children-by-type";
    limits: Record<string, number>;
}>]>;
declare namespace Constraint {
    function isConstraint(value: unknown): value is Constraint;
    function asConstraint(value: unknown): Constraint;
    function isOk(item: Item, constraint: Readonly<Constraint>): boolean;
    function typeIsOk(itemType: ItemType, constraint: Readonly<Constraint>): boolean;
}
type Constraint = z.infer<typeof ConstraintSchema>;
export default Constraint;
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConstraintSchema = void 0;
const z = __importStar(require("zod"));
/*
    Constraints can be applied to ItemTypes to restrict what they can do.
*/
exports.ConstraintSchema = z.discriminatedUnion('constraint', [
    z
        .object({
        constraint: z.literal('allow-extensions'),
        allowed: z.array(z.string()),
    })
        .strict(),
    z
        .object({
        constraint: z.literal('require-extensions'),
        required: z.array(z.string()),
    })
        .strict(),
    z
        .object({
        constraint: z.literal('allow-child-types'),
        allowed: z.array(z.string()),
    })
        .strict(),
    z
        .object({
        constraint: z.literal('block-child-types'),
        blocked: z.array(z.string()),
    })
        .strict(),
    z
        .object({
        constraint: z.literal('limit-children'),
        limit: z.number().int().min(0),
    })
        .strict(),
    z
        .object({
        constraint: z.literal('limit-children-by-type'),
        limits: z.record(z.number().int().min(0)),
    })
        .strict(),
]);
var Constraint;
(function (Constraint) {
    function isConstraint(value) {
        return exports.ConstraintSchema.safeParse(value).success;
    }
    Constraint.isConstraint = isConstraint;
    function asConstraint(value) {
        return exports.ConstraintSchema.parse(value);
    }
    Constraint.asConstraint = asConstraint;
    function isOk(item, constraint) {
        switch (constraint.constraint) {
            case 'allow-extensions':
                for (const extensionName of Object.keys(item.extensions)) {
                    if (!constraint.allowed.includes(extensionName)) {
                        return false;
                    }
                }
                return true;
            case 'require-extensions':
                for (const extensionName of constraint.required) {
                    if (item.extensions[extensionName] === undefined) {
                        return false;
                    }
                }
                return true;
            case 'allow-child-types':
                for (const child of item.children) {
                    if (!constraint.allowed.includes(child.type)) {
                        return false;
                    }
                }
                return true;
            case 'block-child-types':
                for (const child of item.children) {
                    if (constraint.blocked.includes(child.type)) {
                        return false;
                    }
                }
                return true;
            case 'limit-children':
                if (item.children.length > constraint.limit) {
                    return false;
                }
                return true;
            case 'limit-children-by-type':
                for (const [type, limit] of Object.entries(constraint.limits)) {
                    let count = 0;
                    for (const child of item.children) {
                        if (child.type === type)
                            count += 1;
                    }
                    if (count > limit) {
                        return false;
                    }
                }
                return true;
        }
    }
    Constraint.isOk = isOk;
    function typeIsOk(itemType, constraint) {
        switch (constraint.constraint) {
            case 'allow-extensions':
                for (const { extension } of itemType.extensions) {
                    if (!constraint.allowed.includes(extension.name)) {
                        return false;
                    }
                }
                return true;
            case 'require-extensions':
                for (const extensionName of constraint.required) {
                    if (!itemType.extensions.find((x) => x.extension.name === extensionName)) {
                        return false;
                    }
                }
                return true;
            case 'allow-child-types':
            case 'block-child-types':
            case 'limit-children':
            case 'limit-children-by-type':
                return true;
        }
    }
    Constraint.typeIsOk = typeIsOk;
})(Constraint || (Constraint = {}));
exports.default = Constraint;
//# sourceMappingURL=constraint.js.map{"version":3,"file":"constraint.js","sourceRoot":"","sources":["../src/constraint.ts"],"names":[],"mappings":"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"}export default function createAsyncIterator<T>(initializer: (write: (value: T) => void) => Promise<void>): AsyncIterableIterator<T>;
"use strict";
/*
    Creates an async iterable iterator from the given initializer function.
    The initializer function is called immediately, with a "write()" function
    passed as its only parameter, which is used to populate the async iterator.
    The initializer function may return a promise, indicating when no more
    output will be generated. Unlike an async generator, this async iterator
    generates output eagerly, buffering output until it is consumed.
 */
Object.defineProperty(exports, "__esModule", { value: true });
function createAsyncIterator(initializer) {
    const requests = [];
    let buffer = [];
    let isEnded = false;
    let isDone = false;
    let isError = false;
    let error;
    const onWrite = (value) => {
        if (!isEnded) {
            if (requests.length) {
                requests.shift()({ value, done: false });
            }
            else {
                buffer.push(value);
            }
        }
    };
    const onFinish = () => {
        if (!buffer.length) {
            isDone = true;
            while (requests.length) {
                requests.shift()({ value: undefined, done: true });
            }
        }
    };
    const onCancel = (err) => {
        if (!isDone) {
            buffer = [];
            isEnded = true;
            isDone = true;
            isError = true;
            error = err;
            while (requests.length) {
                requests.shift()(Promise.reject(err));
            }
        }
    };
    new Promise((r) => r(initializer(onWrite))).then(() => {
        if (!isDone) {
            isEnded = true;
            onFinish();
        }
    }, onCancel);
    return {
        next() {
            return new Promise((resolve, reject) => {
                if (!isDone) {
                    if (buffer.length) {
                        resolve({ value: buffer.shift(), done: false });
                        isEnded && onFinish();
                    }
                    else {
                        requests.push(resolve);
                    }
                }
                else if (!isError) {
                    resolve({ value: undefined, done: true });
                }
                else {
                    reject(error);
                }
            });
        },
        return() {
            onCancel(new Error('Operation cancelled'));
            return Promise.resolve({ value: undefined, done: true });
        },
        throw(err) {
            onCancel(err);
            return Promise.reject(err);
        },
        [Symbol.asyncIterator]() {
            return this;
        },
    };
}
exports.default = createAsyncIterator;
//# sourceMappingURL=create-async-iterator.js.map{"version":3,"file":"create-async-iterator.js","sourceRoot":"","sources":["../src/create-async-iterator.ts"],"names":[],"mappings":"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"}import * as z from 'zod';
import { Event } from '@postman/runtime.event-channel';
import { StringLiteral, GetExtensionConfig } from './types';
import { RuntimeContext } from './runtime';
import ItemType from './item-type';
import Item from './item';
declare const isValid: unique symbol;
export declare const extensionHandler: unique symbol;
export declare const ExtensionDefinition: z.ZodObject<{
    name: z.ZodString;
    summary: z.ZodString;
    schema: z.ZodUnknown;
}, "strict", z.ZodTypeAny, {
    name: string;
    summary: string;
    schema?: unknown;
}, {
    name: string;
    summary: string;
    schema?: unknown;
}>;
declare abstract class Extension implements Extension.Definition {
    readonly name: string;
    readonly summary: string;
    readonly schema: unknown;
    readonly [isValid]: (value: unknown) => boolean;
    readonly [extensionHandler]: Extension.Handler;
    protected constructor(definition: Extension.Definition, handler?: Extension.Handler);
    isValid(value: unknown): boolean;
}
declare function SpecificExtension<N extends string = string, D = unknown, C = unknown>(definition: Extension.Definition & {
    name: StringLiteral<N>;
}, handler?: Extension.Handler<Extension.Specific<N, D, C>>): () => Extension.Specific<N, D, C>;
interface SpecificExtension<N extends string, D, C> extends Extension {
    readonly name: N;
    isValid(value: unknown): value is D;
    implement(c: C): Extension.Implementation<Extension.Specific<N, D, C>>;
}
declare namespace Extension {
    type Definition = z.infer<typeof ExtensionDefinition>;
    type Specific<N extends string, D, C> = SpecificExtension<N, D, C>;
    interface Handler<E extends Extension = Extension> {
        (itemType: ItemType.WithExtension<E>, context: RuntimeContext): void | Hooks<Item.WithExtension<E>> | Promise<void | Hooks<Item.WithExtension<E>>>;
    }
    interface Hooks<I extends Item = Item> {
        onBefore?(item: I): void | I | Promise<void | I>;
        onEvent?(event: Event): void;
        onAfter?(): void | Promise<void>;
    }
    class Implementation<E extends Extension = Extension> {
        readonly extension: E;
        readonly config: GetExtensionConfig<E>;
        constructor(extension: E, config: GetExtensionConfig<E>);
    }
    const define: typeof SpecificExtension;
}
export default Extension;
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtensionDefinition = exports.extensionHandler = void 0;
const z = __importStar(require("zod"));
const JSONSchema = __importStar(require("./json-schema"));
const singleton_1 = __importDefault(require("./singleton"));
const isValid = Symbol();
exports.extensionHandler = Symbol();
/*
    Extensions are used to represent pieces of data or behaviors that are common
    to multiple ItemTypes, typically because they come from some orthogonal
    domain. There are some built-in Extensions which are used internally by
    Postman, but arbitrary Extensions may be defined for arbitrary purposes.

    An Extension's "schema" is a JSON Schema that defines what data (of type D)
    can be stored by the Extension within individual items.

    An Extension's handler allows the Extension to perform arbitrary logic
    while executing an Item. For example, the Extension can modify the Item
    itself, or perform side-effects during execution.

    When an ItemType implements an Extension, it must provide a configuration
    (of type C) which allows the Extension's behavior to be specialized for
    different ItemTypes. This configuration acts as an interface between
    an ItemType (domain-specific) and the Extension (type-agnostic).
*/
exports.ExtensionDefinition = z
    .object({
    name: z.string().trim().min(1),
    summary: z.string().trim().min(1),
    schema: z.unknown(),
})
    .strict();
class Extension {
    constructor(definition, handler = () => { }) {
        // Runtime validation and sanitization.
        definition = exports.ExtensionDefinition.parse(definition);
        this.name = definition.name;
        this.summary = definition.summary;
        this.schema = definition.schema;
        this[isValid] = JSONSchema.compile(definition.schema);
        this[exports.extensionHandler] = handler;
    }
    isValid(value) {
        return this[isValid](value);
    }
}
/*
    When a new extension is defined, we generate a subclass of Extension, which
    has more specific type information and additional methods compared to the
    base class. We call this factory function "SpecificExtension" because it
    makes TypeScript's errors more clear to understand.

    N = the name of the extension, as a string literal type
    D = the type of data defined by the extension's JSON schema
    C = the configuration that must be provided by participating ItemTypes
*/
function SpecificExtension(definition, handler) {
    return (0, singleton_1.default)(class NewExtension extends Extension {
        constructor() {
            super(definition, handler);
            this.name = definition.name;
        }
        isValid(value) {
            return super.isValid(value);
        }
        implement(configuration) {
            return new Extension.Implementation(this, configuration);
        }
    });
}
/*
    Here are various exports that we attach to the Extension class namespace.
*/
(function (Extension) {
    class Implementation {
        constructor(extension, config) {
            this.extension = extension;
            this.config = config;
        }
    }
    Extension.Implementation = Implementation;
    Extension.define = SpecificExtension;
})(Extension || (Extension = {}));
exports.default = Extension;
//# sourceMappingURL=extension.js.map{"version":3,"file":"extension.js","sourceRoot":"","sources":["../src/extension.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,uCAAyB;AAEzB,0DAA4C;AAG5C,4DAAoC;AAIpC,MAAM,OAAO,GAAG,MAAM,EAAE,CAAC;AACZ,QAAA,gBAAgB,GAAG,MAAM,EAAE,CAAC;AAEzC;;;;;;;;;;;;;;;;;EAiBE;AAEW,QAAA,mBAAmB,GAAG,CAAC;KAClC,MAAM,CAAC;IACP,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;IAC9B,OAAO,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;IACjC,MAAM,EAAE,CAAC,CAAC,OAAO,EAAE;CACnB,CAAC;KACD,MAAM,EAAE,CAAC;AAEX,MAAe,SAAS;IAUvB,YACC,UAAgC,EAChC,UAA6B,GAAG,EAAE,GAAE,CAAC;QAErC,uCAAuC;QACvC,UAAU,GAAG,2BAAmB,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;QAEnD,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC;QAC5B,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC,OAAO,CAAC;QAClC,IAAI,CAAC,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC;QAChC,IAAI,CAAC,OAAO,CAAC,GAAG,UAAU,CAAC,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;QACtD,IAAI,CAAC,wBAAgB,CAAC,GAAG,OAAO,CAAC;IAClC,CAAC;IAED,OAAO,CAAC,KAAc;QACrB,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC,CAAC;IAC7B,CAAC;CACD;AAED;;;;;;;;;EASE;AAEF,SAAS,iBAAiB,CACzB,UAA6D,EAC7D,OAAwD;IAExD,OAAO,IAAA,mBAAS,EACf,MAAM,YAAa,SAAQ,SAAS;QAGnC;YACC,KAAK,CAAC,UAAU,EAAE,OAA4B,CAAC,CAAC;YAChD,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC;QAC7B,CAAC;QAEQ,OAAO,CAAC,KAAc;YAC9B,OAAO,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAC7B,CAAC;QAED,SAAS,CACR,aAAgB;YAEhB,OAAO,IAAI,SAAS,CAAC,cAAc,CAClC,IAAI,EACJ,aAAa,CACb,CAAC;QACH,CAAC;KACD,CACD,CAAC;AACH,CAAC;AAgBD;;EAEE;AAEF,WAAU,SAAS;IAoBlB,MAAa,cAAc;QAC1B,YACU,SAAY,EACZ,MAA6B;YAD7B,cAAS,GAAT,SAAS,CAAG;YACZ,WAAM,GAAN,MAAM,CAAuB;QACpC,CAAC;KACJ;IALY,wBAAc,iBAK1B,CAAA;IAEY,gBAAM,GAAG,iBAAiB,CAAC;AACzC,CAAC,EA5BS,SAAS,KAAT,SAAS,QA4BlB;AAED,kBAAe,SAAS,CAAC"}export { Event, EventChannel } from '@postman/runtime.event-channel';
export { default as Item } from './item';
export { default as ItemTree } from './item-tree';
export { default as ItemType } from './item-type';
export { default as Extension } from './extension';
export { default as Constraint } from './constraint';
export { default as Run } from './run';
export { Validator } from './validator';
export * from './runtime';
export * from './symbols';
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Validator = exports.Run = exports.Constraint = exports.Extension = exports.ItemType = exports.ItemTree = exports.Item = exports.EventChannel = void 0;
var runtime_event_channel_1 = require("@postman/runtime.event-channel");
Object.defineProperty(exports, "EventChannel", { enumerable: true, get: function () { return runtime_event_channel_1.EventChannel; } });
var item_1 = require("./item");
Object.defineProperty(exports, "Item", { enumerable: true, get: function () { return __importDefault(item_1).default; } });
var item_tree_1 = require("./item-tree");
Object.defineProperty(exports, "ItemTree", { enumerable: true, get: function () { return __importDefault(item_tree_1).default; } });
var item_type_1 = require("./item-type");
Object.defineProperty(exports, "ItemType", { enumerable: true, get: function () { return __importDefault(item_type_1).default; } });
var extension_1 = require("./extension");
Object.defineProperty(exports, "Extension", { enumerable: true, get: function () { return __importDefault(extension_1).default; } });
var constraint_1 = require("./constraint");
Object.defineProperty(exports, "Constraint", { enumerable: true, get: function () { return __importDefault(constraint_1).default; } });
var run_1 = require("./run");
Object.defineProperty(exports, "Run", { enumerable: true, get: function () { return __importDefault(run_1).default; } });
var validator_1 = require("./validator");
Object.defineProperty(exports, "Validator", { enumerable: true, get: function () { return validator_1.Validator; } });
__exportStar(require("./runtime"), exports);
__exportStar(require("./symbols"), exports);
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,wEAAqE;AAArD,qHAAA,YAAY,OAAA;AAC5B,+BAAyC;AAAhC,6GAAA,OAAO,OAAQ;AACxB,yCAAkD;AAAzC,sHAAA,OAAO,OAAY;AAC5B,yCAAkD;AAAzC,sHAAA,OAAO,OAAY;AAC5B,yCAAmD;AAA1C,uHAAA,OAAO,OAAa;AAC7B,2CAAqD;AAA5C,yHAAA,OAAO,OAAc;AAC9B,6BAAuC;AAA9B,2GAAA,OAAO,OAAO;AACvB,yCAAwC;AAA/B,sGAAA,SAAS,OAAA;AAClB,4CAA0B;AAC1B,4CAA0B"}import * as z from 'zod';
import LoneItem from './item';
export declare const ItemNodeSchema: z.ZodObject<Omit<{
    id: z.ZodString;
    type: z.ZodString;
    title: z.ZodString;
    createdAt: z.ZodString;
    children: z.ZodArray<z.ZodObject<{
        id: z.ZodString;
        type: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        type: string;
        id: string;
    }, {
        type: string;
        id: string;
    }>, "many">;
    payload: z.ZodUnknown;
    extensions: z.ZodRecord<z.ZodString, z.ZodUnknown>;
}, "children">, "strip", z.ZodTypeAny, {
    type: string;
    id: string;
    title: string;
    createdAt: string;
    extensions: Record<string, unknown>;
    payload?: unknown;
}, {
    type: string;
    id: string;
    title: string;
    createdAt: string;
    extensions: Record<string, unknown>;
    payload?: unknown;
}>;
type ItemNode = z.infer<typeof ItemNodeSchema>;
interface ItemTree {
    item: ItemNode;
    children: ItemTree[];
}
export declare const ItemTreeSchema: z.ZodSchema<ItemTree>;
declare namespace ItemTree {
    function isItemTree(value: unknown): value is ItemTree;
    function fromItems(items: ReadonlyArray<LoneItem>): ItemTree;
    function toItems(tree: ItemTree): LoneItem[];
    function toResolved(tree: ItemTree): ItemTree;
    type Item = ItemNode;
}
export default ItemTree;
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ItemTreeSchema = exports.ItemNodeSchema = void 0;
const z = __importStar(require("zod"));
const item_1 = require("./item");
/*
    An ItemTree is simply a hierarchical arrangement of Items. It is typically
    used to represent an entire Collection, but it can also be used to represent
    sub-trees within a Collection.
*/
exports.ItemNodeSchema = item_1.ItemSchema.omit({ children: true });
exports.ItemTreeSchema = z.lazy(() => z.object({
    item: exports.ItemNodeSchema,
    children: z.array(exports.ItemTreeSchema),
}));
var ItemTree;
(function (ItemTree) {
    function isItemTree(value) {
        return exports.ItemTreeSchema.safeParse(value).success;
    }
    ItemTree.isItemTree = isItemTree;
    function fromItems(items) {
        const subtrees = new Map();
        const unreferenced = new Set();
        // Clone the items, and treat them as plain JSON.
        items = JSON.parse(JSON.stringify(items));
        // Strip each item's "children" property, and create empty subtrees.
        for (const item of items) {
            const { children: _, ...treeItem } = item;
            if (subtrees.has(item.id)) {
                throw new Error(`Duplicate item "${item.id}"`);
            }
            subtrees.set(item.id, { item: treeItem, children: [] });
            unreferenced.add(item.id);
        }
        // Populate the children of each subtree.
        for (const item of items) {
            const subtree = subtrees.get(item.id);
            for (const childReference of item.children) {
                const child = subtrees.get(childReference.id);
                if (!child) {
                    throw new Error(`Missing child item "${childReference.id}"`);
                }
                if (!unreferenced.has(childReference.id)) {
                    throw new Error(`Multiple references to child item "${childReference.id}"`);
                }
                subtree.children.push(child);
                unreferenced.delete(childReference.id);
            }
        }
        // Determine the root item.
        if (!unreferenced.size) {
            throw new Error('Missing root item');
        }
        if (unreferenced.size > 1) {
            throw new Error('Multiples root items');
        }
        return subtrees.get(unreferenced.values().next().value);
    }
    ItemTree.fromItems = fromItems;
    function toItems(tree) {
        const items = [];
        // Clone the items, and treat them as plain JSON.
        tree = JSON.parse(JSON.stringify(tree));
        // Recursively unwrap each subtree.
        (function walk(subtree) {
            items.push({
                ...subtree.item,
                payload: subtree.item.payload,
                children: subtree.children.map((child) => ({
                    id: child.item.id,
                    type: child.item.type,
                })),
            });
            subtree.children.forEach(walk);
        })(tree);
        return items;
    }
    ItemTree.toItems = toItems;
    function toResolved(tree) {
        // Clone the items, and treat them as plain JSON.
        tree = JSON.parse(JSON.stringify(tree));
        // Recursively pass inherited Extensions down the tree.
        (function walk(subtree, auth, events) {
            const extensions = subtree.item.extensions;
            if (extensions.auth != null && extensions.auth.type !== 'noauth') {
                auth = extensions.auth;
            }
            if (extensions.events != null && extensions.events.length > 0) {
                if (events != null && events.length > 0) {
                    events = events.concat(extensions.events);
                }
                else {
                    events = extensions.events;
                }
            }
            if (auth !== extensions.auth && auth !== undefined) {
                extensions.auth = JSON.parse(JSON.stringify(auth));
            }
            if (events !== extensions.events && events !== undefined) {
                extensions.events = JSON.parse(JSON.stringify(events));
            }
            for (const child of subtree.children) {
                walk(child, auth, events);
            }
        })(tree, undefined, undefined);
        return tree;
    }
    ItemTree.toResolved = toResolved;
})(ItemTree || (ItemTree = {}));
exports.default = ItemTree;
//# sourceMappingURL=item-tree.js.map{"version":3,"file":"item-tree.js","sourceRoot":"","sources":["../src/item-tree.ts"],"names":[],"mappings":"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"}import * as z from 'zod';
import { EventChannel, Event } from '@postman/runtime.event-channel';
import { StringLiteral, SelectExtension, GetTypeConfig } from './types';
import { GetSentEvents, GetReceivedEvents } from './types';
import { RuntimeContext } from './runtime';
import Constraint from './constraint';
import Extension from './extension';
import Item from './item';
declare const isValidPayload: unique symbol;
export declare const itemHandler: unique symbol;
export declare const ItemTypeDefinition: z.ZodObject<{
    name: z.ZodString;
    summary: z.ZodString;
    schema: z.ZodUnknown;
    constraints: z.ZodArray<z.ZodDiscriminatedUnion<"constraint", [z.ZodObject<{
        constraint: z.ZodLiteral<"allow-extensions">;
        allowed: z.ZodArray<z.ZodString, "many">;
    }, "strict", z.ZodTypeAny, {
        constraint: "allow-extensions";
        allowed: string[];
    }, {
        constraint: "allow-extensions";
        allowed: string[];
    }>, z.ZodObject<{
        constraint: z.ZodLiteral<"require-extensions">;
        required: z.ZodArray<z.ZodString, "many">;
    }, "strict", z.ZodTypeAny, {
        constraint: "require-extensions";
        required: string[];
    }, {
        constraint: "require-extensions";
        required: string[];
    }>, z.ZodObject<{
        constraint: z.ZodLiteral<"allow-child-types">;
        allowed: z.ZodArray<z.ZodString, "many">;
    }, "strict", z.ZodTypeAny, {
        constraint: "allow-child-types";
        allowed: string[];
    }, {
        constraint: "allow-child-types";
        allowed: string[];
    }>, z.ZodObject<{
        constraint: z.ZodLiteral<"block-child-types">;
        blocked: z.ZodArray<z.ZodString, "many">;
    }, "strict", z.ZodTypeAny, {
        constraint: "block-child-types";
        blocked: string[];
    }, {
        constraint: "block-child-types";
        blocked: string[];
    }>, z.ZodObject<{
        constraint: z.ZodLiteral<"limit-children">;
        limit: z.ZodNumber;
    }, "strict", z.ZodTypeAny, {
        constraint: "limit-children";
        limit: number;
    }, {
        constraint: "limit-children";
        limit: number;
    }>, z.ZodObject<{
        constraint: z.ZodLiteral<"limit-children-by-type">;
        limits: z.ZodRecord<z.ZodString, z.ZodNumber>;
    }, "strict", z.ZodTypeAny, {
        constraint: "limit-children-by-type";
        limits: Record<string, number>;
    }, {
        constraint: "limit-children-by-type";
        limits: Record<string, number>;
    }>]>, "many">;
}, "strict", z.ZodTypeAny, {
    name: string;
    summary: string;
    constraints: ({
        constraint: "allow-extensions";
        allowed: string[];
    } | {
        constraint: "require-extensions";
        required: string[];
    } | {
        constraint: "allow-child-types";
        allowed: string[];
    } | {
        constraint: "block-child-types";
        blocked: string[];
    } | {
        constraint: "limit-children";
        limit: number;
    } | {
        constraint: "limit-children-by-type";
        limits: Record<string, number>;
    })[];
    schema?: unknown;
}, {
    name: string;
    summary: string;
    constraints: ({
        constraint: "allow-extensions";
        allowed: string[];
    } | {
        constraint: "require-extensions";
        required: string[];
    } | {
        constraint: "allow-child-types";
        allowed: string[];
    } | {
        constraint: "block-child-types";
        blocked: string[];
    } | {
        constraint: "limit-children";
        limit: number;
    } | {
        constraint: "limit-children-by-type";
        limits: Record<string, number>;
    })[];
    schema?: unknown;
}>;
export declare const ExtensionImplementationList: z.ZodArray<z.ZodType<Extension.Implementation<Extension>, z.ZodTypeDef, Extension.Implementation<Extension>>, "many">;
declare abstract class ItemType implements ItemType.Definition {
    readonly name: string;
    readonly summary: string;
    readonly schema: unknown;
    readonly constraints: Array<Constraint>;
    readonly extensions: ReadonlyArray<Extension.Implementation>;
    readonly [isValidPayload]: (value: unknown) => boolean;
    readonly [itemHandler]: ItemType.Handler | undefined;
    protected constructor(definition: ItemType.Definition, extensions?: ReadonlyArray<Extension.Implementation>, handler?: ItemType.Handler);
    isValidPayload(value: unknown): boolean;
}
declare function SpecificItemType<T = unknown, E extends Extension = never, C = unknown, S extends Event = never, R extends Event = never>(definition: ItemType.Definition, extensions?: ReadonlyArray<Extension.Implementation<E>>, handler?: ItemType.Handler<ItemType.Specific<T, E, C, S, R>>): () => ItemType.Specific<T, E, C, S, R>;
interface SpecificItemType<T, E extends Extension, C, S extends Event, R extends Event> extends ItemType {
    isValidPayload(value: unknown): value is T;
    getExtension<N extends E['name']>(name: StringLiteral<N>): Extension.Implementation<SelectExtension<N, E>>;
    implement(c: C): ItemType.Implementation<ItemType.Specific<T, E, C, S, R>>;
}
declare namespace ItemType {
    type Definition = z.infer<typeof ItemTypeDefinition>;
    type Specific<T, E extends Extension, C = unknown, S extends Event = never, R extends Event = never> = SpecificItemType<T, E, C, S, R>;
    type WithExtension<E extends Extension> = Specific<unknown, E, unknown>;
    type InnerChannel<Y extends ItemType> = EventChannel<GetReceivedEvents<Y>, GetSentEvents<Y>>;
    type OuterChannel<Y extends ItemType> = EventChannel<GetSentEvents<Y>, GetReceivedEvents<Y>>;
    interface Handler<Y extends ItemType = ItemType> {
        (item: Item.OfType<Y>, config: GetTypeConfig<Y>, context: RuntimeContext): Promise<void>;
    }
    class Implementation<Y extends ItemType = ItemType> {
        readonly itemType: Y;
        readonly config: GetTypeConfig<Y>;
        constructor(itemType: Y, config: GetTypeConfig<Y>);
    }
    const define: typeof SpecificItemType;
}
export default ItemType;
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtensionImplementationList = exports.ItemTypeDefinition = exports.itemHandler = void 0;
const z = __importStar(require("zod"));
const JSONSchema = __importStar(require("./json-schema"));
const constraint_1 = __importStar(require("./constraint"));
const singleton_1 = __importDefault(require("./singleton"));
const extension_1 = __importDefault(require("./extension"));
const isValidPayload = Symbol();
exports.itemHandler = Symbol();
/*
    ItemTypes classify the various items that make up a Collection in Postman.
    Through ItemTypes, items within a Collection can represent just about
    anything: folders, gRPC requests, example responses, saved messages, etc.

    An ItemType's "schema" is a JSON Schema that defines what data (of type T)
    can be stored within the Item's "payload" field, which represents "private"
    or "domain-specific" data which is only applicable to that specific ItemType
    (in contrast to Extensions). Postman provides many built-in ItemTypes, but
    arbitrary ItemTypes may be defined for arbitrary purposes.

    An ItemType may implement any number of Extensions, which are essentially
    reusable plugins for ItemTypes.

    Users who wish to execute items of a certain ItemType must provide a
    configuration (of type C) which allows the ItemType's behavior to be
    implemented/specialized for the user's environment.

    An ItemType's handler defines what happens when an Item is executed. Not all
    ItemTypes are executable; only executable ItemTypes need a handler. The
    handler must return an EventChannel<S, R>, where S is the union of types
    allowed for sent events (i.e., the events sendable by the user during
    execution), and R is the union of types allowed for received events (i.e.,
    the output of the execution).
*/
exports.ItemTypeDefinition = z
    .object({
    name: z.string().trim().min(1),
    summary: z.string().trim().min(1),
    schema: z.unknown(),
    constraints: z.array(constraint_1.ConstraintSchema),
})
    .strict();
exports.ExtensionImplementationList = z.array(z.instanceof(extension_1.default.Implementation));
class ItemType {
    constructor(definition, extensions = [], handler) {
        // Runtime validation and sanitization.
        definition = exports.ItemTypeDefinition.parse(definition);
        extensions = exports.ExtensionImplementationList.parse(extensions);
        this.name = definition.name;
        this.summary = definition.summary;
        this.schema = definition.schema;
        this.constraints = definition.constraints;
        this.extensions = extensions;
        this[isValidPayload] = JSONSchema.compile(definition.schema);
        this[exports.itemHandler] = handler;
        // Check for duplicate extensions and violated constraints.
        for (let i = 0; i < this.extensions.length; ++i) {
            const extensionName = this.extensions[i].extension.name;
            for (let j = i + 1; j < this.extensions.length; ++j) {
                if (extensionName === this.extensions[j].extension.name) {
                    throw new TypeError(`ItemType "${this.name}" has duplicate extension "${extensionName}"`);
                }
            }
        }
        for (const constraint of this.constraints) {
            if (!constraint_1.default.typeIsOk(this, constraint)) {
                throw new TypeError(`ItemType "${this.name}" violates constraint "${constraint.constraint}"`);
            }
        }
    }
    isValidPayload(value) {
        return this[isValidPayload](value);
    }
}
/*
    When a new ItemType is defined, we generate a subclass of ItemType, which
    has more specific type information and additional methods compared to the
    base class. We call this factory function "SpecificItemType" because it
    makes TypeScript's errors more clear to understand.

    T = the type of data defined by this ItemType's JSON schema
    E = a union of all extension types used by this ItemType (or else `never`)
    C = the configuration that must be provided by users of the ItemType
    S = the union of Event types allowed to be sent by the user during execution
    R = the union of Event types received by the user during execution
*/
function SpecificItemType(definition, extensions, handler) {
    return (0, singleton_1.default)(class NewItemType extends ItemType {
        constructor() {
            super(definition, extensions, handler);
        }
        isValidPayload(value) {
            return super.isValidPayload(value);
        }
        getExtension(name) {
            for (const impl of this.extensions) {
                if (impl.extension.name === name) {
                    return impl;
                }
            }
            throw new TypeError(`Extension "${name}" does not exist on ItemType "${this.name}"`);
        }
        implement(configuration) {
            return new ItemType.Implementation(this, configuration);
        }
    });
}
/*
    Here are various exports that we attach to the ItemType class namespace.
*/
(function (ItemType) {
    class Implementation {
        constructor(itemType, config) {
            this.itemType = itemType;
            this.config = config;
        }
    }
    ItemType.Implementation = Implementation;
    ItemType.define = SpecificItemType;
})(ItemType || (ItemType = {}));
exports.default = ItemType;
//# sourceMappingURL=item-type.js.map{"version":3,"file":"item-type.js","sourceRoot":"","sources":["../src/item-type.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,uCAAyB;AAEzB,0DAA4C;AAI5C,2DAA4D;AAC5D,4DAAoC;AACpC,4DAAoC;AAGpC,MAAM,cAAc,GAAG,MAAM,EAAE,CAAC;AACnB,QAAA,WAAW,GAAG,MAAM,EAAE,CAAC;AAEpC;;;;;;;;;;;;;;;;;;;;;;;;EAwBE;AAEW,QAAA,kBAAkB,GAAG,CAAC;KACjC,MAAM,CAAC;IACP,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;IAC9B,OAAO,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;IACjC,MAAM,EAAE,CAAC,CAAC,OAAO,EAAE;IACnB,WAAW,EAAE,CAAC,CAAC,KAAK,CAAC,6BAAgB,CAAC;CACtC,CAAC;KACD,MAAM,EAAE,CAAC;AAEE,QAAA,2BAA2B,GAAG,CAAC,CAAC,KAAK,CACjD,CAAC,CAAC,UAAU,CAAC,mBAAS,CAAC,cAAc,CAAC,CACtC,CAAC;AAEF,MAAe,QAAQ;IAYtB,YACC,UAA+B,EAC/B,aAAsD,EAAE,EACxD,OAA0B;QAE1B,uCAAuC;QACvC,UAAU,GAAG,0BAAkB,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;QAClD,UAAU,GAAG,mCAA2B,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;QAE3D,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC;QAC5B,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC,OAAO,CAAC;QAClC,IAAI,CAAC,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC;QAChC,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC,WAAW,CAAC;QAC1C,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,IAAI,CAAC,cAAc,CAAC,GAAG,UAAU,CAAC,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;QAC7D,IAAI,CAAC,mBAAW,CAAC,GAAG,OAAO,CAAC;QAE5B,2DAA2D;QAC3D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE,CAAC;YACjD,MAAM,aAAa,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC;YACxD,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE,CAAC;gBACrD,IAAI,aAAa,KAAK,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC;oBACzD,MAAM,IAAI,SAAS,CAClB,aAAa,IAAI,CAAC,IAAI,8BAA8B,aAAa,GAAG,CACpE,CAAC;gBACH,CAAC;YACF,CAAC;QACF,CAAC;QACD,KAAK,MAAM,UAAU,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;YAC3C,IAAI,CAAC,oBAAU,CAAC,QAAQ,CAAC,IAAI,EAAE,UAAU,CAAC,EAAE,CAAC;gBAC5C,MAAM,IAAI,SAAS,CAClB,aAAa,IAAI,CAAC,IAAI,0BAA0B,UAAU,CAAC,UAAU,GAAG,CACxE,CAAC;YACH,CAAC;QACF,CAAC;IACF,CAAC;IAED,cAAc,CAAC,KAAc;QAC5B,OAAO,IAAI,CAAC,cAAc,CAAC,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;CACD;AAED;;;;;;;;;;;EAWE;AAEF,SAAS,gBAAgB,CAOxB,UAA+B,EAC/B,UAAuD,EACvD,OAA4D;IAE5D,OAAO,IAAA,mBAAS,EACf,MAAM,WAAY,SAAQ,QAAQ;QACjC;YACC,KAAK,CAAC,UAAU,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;QACxC,CAAC;QAEQ,cAAc,CAAC,KAAc;YACrC,OAAO,KAAK,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;QACpC,CAAC;QAED,YAAY,CACX,IAAsB;YAEtB,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;gBACpC,IAAI,IAAI,CAAC,SAAS,CAAC,IAAI,KAAK,IAAI,EAAE,CAAC;oBAClC,OAAO,IAAuD,CAAC;gBAChE,CAAC;YACF,CAAC;YACD,MAAM,IAAI,SAAS,CAClB,cAAc,IAAI,iCAAiC,IAAI,CAAC,IAAI,GAAG,CAC/D,CAAC;QACH,CAAC;QAED,SAAS,CACR,aAAgB;YAEhB,OAAO,IAAI,QAAQ,CAAC,cAAc,CACjC,IAAI,EACJ,aAAa,CACb,CAAC;QACH,CAAC;KACD,CACD,CAAC;AACH,CAAC;AAwBD;;EAEE;AAEF,WAAU,QAAQ;IA+BjB,MAAa,cAAc;QAC1B,YACU,QAAW,EACX,MAAwB;YADxB,aAAQ,GAAR,QAAQ,CAAG;YACX,WAAM,GAAN,MAAM,CAAkB;QAC/B,CAAC;KACJ;IALY,uBAAc,iBAK1B,CAAA;IAEY,eAAM,GAAG,gBAAgB,CAAC;AACxC,CAAC,EAvCS,QAAQ,KAAR,QAAQ,QAuCjB;AAED,kBAAe,QAAQ,CAAC"}import * as z from 'zod';
import ItemType from './item-type';
import Extension from './extension';
import { GetExtensionData, GetTypeData, GetTypeExtensions } from './types';
export declare const ItemSchema: z.ZodObject<{
    id: z.ZodString;
    type: z.ZodString;
    title: z.ZodString;
    createdAt: z.ZodString;
    children: z.ZodArray<z.ZodObject<{
        id: z.ZodString;
        type: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        type: string;
        id: string;
    }, {
        type: string;
        id: string;
    }>, "many">;
    payload: z.ZodUnknown;
    extensions: z.ZodRecord<z.ZodString, z.ZodUnknown>;
}, "strip", z.ZodTypeAny, {
    type: string;
    id: string;
    title: string;
    createdAt: string;
    children: {
        type: string;
        id: string;
    }[];
    extensions: Record<string, unknown>;
    payload?: unknown;
}, {
    type: string;
    id: string;
    title: string;
    createdAt: string;
    children: {
        type: string;
        id: string;
    }[];
    extensions: Record<string, unknown>;
    payload?: unknown;
}>;
declare namespace Item {
    function isItem(value: unknown): value is Item;
    type WithExtension<E extends Extension> = Item<unknown, E>;
    type WithPayload<Y extends ItemType> = Item<GetTypeData<Y>>;
    type OfType<Y extends ItemType> = Item<GetTypeData<Y>, GetTypeExtensions<Y>>;
}
type Item<T = unknown, E extends Extension = never> = z.infer<typeof ItemSchema> & {
    payload: T;
    extensions: {
        [X in E as X['name']]?: GetExtensionData<X>;
    };
};
export default Item;
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ItemSchema = void 0;
const z = __importStar(require("zod"));
/*
    Items are the fundamental nodes that make up a Collection in Postman. Items
    can represent just about anything; each Item has a type, which determines
    what the Item represents (e.g., folders, gRPC requests, etc.). Items can
    have parent-child relationships, making them inherently tree-shaped.

    By default, the exported type `Item` represents a generic item, whose
    payload and extensions are unknown, but its type parameters (T and E) can be
    used to specify its type more precisely:
        T = the type of data within the item's "payload"
        E = a union of all extension types used by this item (or else `never`)

    However, rather than using the type parameters directly, it's recommended to
    use these helpers instead: `WithExtension`, `WithPayload`, `OfType`.

*/
exports.ItemSchema = z.object({
    id: z.string().trim().min(1),
    type: z.string().trim().min(1),
    title: z.string().trim().min(1).max(1024),
    createdAt: z.string().datetime(),
    children: z.array(z.object({
        id: z.string().trim().min(1),
        type: z.string().trim().min(1),
    })),
    payload: z.unknown(),
    extensions: z.record(z.unknown()),
});
var Item;
(function (Item) {
    function isItem(value) {
        return exports.ItemSchema.safeParse(value).success;
    }
    Item.isItem = isItem;
})(Item || (Item = {}));
exports.default = Item;
//# sourceMappingURL=item.js.map{"version":3,"file":"item.js","sourceRoot":"","sources":["../src/item.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,uCAAyB;AAKzB;;;;;;;;;;;;;;;EAeE;AAEW,QAAA,UAAU,GAAG,CAAC,CAAC,MAAM,CAAC;IAClC,EAAE,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;IAC5B,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;IAC9B,KAAK,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC;IACzC,SAAS,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;IAChC,QAAQ,EAAE,CAAC,CAAC,KAAK,CAChB,CAAC,CAAC,MAAM,CAAC;QACR,EAAE,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;QAC5B,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;KAC9B,CAAC,CACF;IACD,OAAO,EAAE,CAAC,CAAC,OAAO,EAAE;IACpB,UAAU,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC;CACjC,CAAC,CAAC;AAEH,IAAU,IAAI,CAWb;AAXD,WAAU,IAAI;IACb,SAAgB,MAAM,CAAC,KAAc;QACpC,OAAO,kBAAU,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC;IAC5C,CAAC;IAFe,WAAM,SAErB,CAAA;AAQF,CAAC,EAXS,IAAI,KAAJ,IAAI,QAWb;AAWD,kBAAe,IAAI,CAAC"}export type Validator<T> = (value: unknown) => value is T;
export declare function compile<T = unknown>(schema: unknown): Validator<T>;
export declare function compileCode(schema: unknown): string;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileCode = exports.compile = void 0;
const json_schema_draft_06_json_1 = __importDefault(require("ajv/dist/refs/json-schema-draft-06.json"));
const json_schema_draft_07_json_1 = __importDefault(require("ajv/dist/refs/json-schema-draft-07.json"));
const _2019_1 = __importDefault(require("ajv/dist/2019"));
const standalone_1 = __importDefault(require("ajv/dist/standalone"));
const ajv_formats_1 = __importDefault(require("ajv-formats"));
const ajv = new _2019_1.default({
    strictTypes: true,
    strictTuples: true,
    allowUnionTypes: true,
    useDefaults: true,
    addUsedSchema: false, // Since we never discard the ajv instance, this would be a memory leak
    inlineRefs: false, // Prevent super-linear memory usage
    code: { source: true }, // This is needed for standalone code generation
});
ajv.addMetaSchema(json_schema_draft_06_json_1.default);
ajv.addMetaSchema(json_schema_draft_07_json_1.default);
(0, ajv_formats_1.default)(ajv);
function compile(schema) {
    const validator = ajv.compile(schema);
    delete validator.source; // Source is only needed for standalone code generation
    return validator;
}
exports.compile = compile;
function compileCode(schema) {
    const validator = ajv.compile(schema);
    return (0, standalone_1.default)(ajv, validator);
}
exports.compileCode = compileCode;
//# sourceMappingURL=json-schema.js.map{"version":3,"file":"json-schema.js","sourceRoot":"","sources":["../src/json-schema.ts"],"names":[],"mappings":";;;;;;AAAA,wGAA8D;AAC9D,wGAA8D;AAC9D,0DAAqD;AACrD,qEAAiD;AACjD,8DAAqC;AAErC,MAAM,GAAG,GAAG,IAAI,eAAG,CAAC;IACnB,WAAW,EAAE,IAAI;IACjB,YAAY,EAAE,IAAI;IAClB,eAAe,EAAE,IAAI;IACrB,WAAW,EAAE,IAAI;IACjB,aAAa,EAAE,KAAK,EAAE,uEAAuE;IAC7F,UAAU,EAAE,KAAK,EAAE,oCAAoC;IACvD,IAAI,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE,gDAAgD;CACxE,CAAC,CAAC;AAEH,GAAG,CAAC,aAAa,CAAC,mCAAc,CAAC,CAAC;AAClC,GAAG,CAAC,aAAa,CAAC,mCAAc,CAAC,CAAC;AAClC,IAAA,qBAAU,EAAC,GAAG,CAAC,CAAC;AAIhB,SAAgB,OAAO,CAAc,MAAe;IACnD,MAAM,SAAS,GAAG,GAAG,CAAC,OAAO,CAAC,MAAyB,CAAC,CAAC;IACzD,OAAO,SAAS,CAAC,MAAM,CAAC,CAAC,uDAAuD;IAChF,OAAO,SAAyB,CAAC;AAClC,CAAC;AAJD,0BAIC;AAED,SAAgB,WAAW,CAAC,MAAe;IAC1C,MAAM,SAAS,GAAG,GAAG,CAAC,OAAO,CAAC,MAAyB,CAAC,CAAC;IACzD,OAAO,IAAA,oBAAc,EAAC,GAAG,EAAE,SAAS,CAAC,CAAC;AACvC,CAAC;AAHD,kCAGC"}import { EventChannel, Event } from '@postman/runtime.event-channel';
import { Runtime, RuntimeContextCore } from './runtime';
import Item from './item';
export declare const impls: unique symbol;
export default class Run {
    private readonly runtime;
    private readonly queue;
    readonly events: EventChannel.Any;
    private readonly context;
    private currentTask;
    private currentPosition;
    private isPaused;
    constructor(runtime: Runtime, context: RuntimeContextCore, queue: ReadonlyArray<Item>, startPaused: boolean);
    private execItem;
    resume(): void;
    pause(): Promise<void>;
    cancel(): void;
    get done(): boolean;
    get paused(): boolean;
    get waitingToPause(): boolean;
    [Symbol.asyncIterator](): AsyncIterator<Event>;
}
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.impls = void 0;
const runtime_event_channel_1 = require("@postman/runtime.event-channel");
const create_async_iterator_1 = __importDefault(require("./create-async-iterator"));
const extension_1 = require("./extension");
const item_type_1 = require("./item-type");
exports.impls = Symbol();
class Run {
    constructor(runtime, context, queue, startPaused) {
        this.runtime = runtime;
        this.queue = queue;
        this.events = new runtime_event_channel_1.EventChannel();
        this.currentTask = null;
        this.currentPosition = 0;
        this.isPaused = true;
        // Making event channel behave like an EventEmitter
        this.events.link(this.events);
        this.context = { ...context, events: this.events };
        if (!startPaused) {
            this.resume();
        }
    }
    async execItem(item) {
        const { context, events } = this;
        const onEventHandlers = [];
        try {
            // TODO: validate item against Runtime/Validator
            const impl = this.runtime[exports.impls].get(item.type);
            if (!impl) {
                return;
            }
            const { itemType } = impl;
            const mainHandler = itemType[item_type_1.itemHandler];
            if (typeof mainHandler !== 'function') {
                return;
            }
            await null; // Give consumers a chance to attach event listeners
            await events.emitSelf('internal:exec-begin', { item });
            const allHooks = [];
            for (const { extension } of itemType.extensions) {
                const handler = extension[extension_1.extensionHandler];
                if (typeof handler === 'function') {
                    const hooks = await handler(itemType, context);
                    if (events.closed)
                        return;
                    if (hooks != null) {
                        allHooks.push(hooks);
                    }
                }
            }
            // Attach event listeners to fire onEvent hooks. This needs to be
            // done before onBefore hooks are executed so that the any events
            // emitted during onBefore are also captured.
            for (const hooks of allHooks) {
                const onEvent = hooks?.onEvent;
                if (typeof onEvent === 'function') {
                    events.onAll(onEvent);
                    onEventHandlers.push(onEvent);
                }
            }
            for (const hooks of allHooks) {
                const onBefore = hooks?.onBefore;
                if (typeof onBefore === 'function') {
                    const newItem = await onBefore(item);
                    // TODO: allow the item execution to be skipped within onBefore hook
                    if (events.closed) {
                        // If the run was cancelled during the hook, just return.
                        return;
                    }
                    if (newItem != null) {
                        item = newItem;
                    }
                }
            }
            await mainHandler(item, impl.config, context);
            if (events.closed) {
                // If the run was cancelled during execution, just return.
                return;
            }
            for (const hooks of allHooks) {
                const onAfter = hooks?.onAfter;
                if (typeof onAfter === 'function') {
                    await onAfter();
                    if (events.closed) {
                        // If the run was cancelled during the hook, just return.
                        return;
                    }
                }
            }
            onEventHandlers.forEach((handler) => events.offAll(handler));
            await events.emitSelf('internal:exec-end', {});
        }
        catch (err) {
            await events.emitSelf('internal:error', err);
            events.close();
        }
    }
    // Unpauses the run, and starts executing the next task if there is no
    // current task. If there are no more tasks, the run is ended.
    resume() {
        this.isPaused = false;
        if (!this.currentTask && !this.events.closed) {
            const item = this.queue[this.currentPosition];
            if (item) {
                this.currentTask = this.execItem(item).then(() => {
                    this.currentTask = null;
                    this.currentPosition += 1;
                    this.isPaused || this.resume();
                });
            }
            else {
                this.events.close();
            }
        }
    }
    // Schedules the run to pause when the current task is finished. The
    // returned promise is fulfilled when the current task is finished.
    pause() {
        this.isPaused = true;
        if (this.currentTask) {
            return this.currentTask.then();
        }
        else {
            return Promise.resolve();
        }
    }
    // Cancels the run. Any futher events are ignored, and nothing more will be
    // executed after the current task is finished.
    cancel() {
        this.events.close();
    }
    get done() {
        return this.events.closed;
    }
    get paused() {
        return this.isPaused && !this.currentTask;
    }
    get waitingToPause() {
        return this.isPaused && !!this.currentTask;
    }
    [Symbol.asyncIterator]() {
        const iterator = (0, create_async_iterator_1.default)((write) => {
            return new Promise((resolve, reject) => {
                this.events.onAll(write);
                this.events.on('internal:error', (event) => reject(event.payload));
                this.events.onCleanup(() => resolve());
            });
        });
        return {
            next: async () => {
                return iterator.next();
            },
            throw: async (error) => {
                this.cancel();
                return iterator.throw(error);
            },
            return: async () => {
                this.cancel();
                return iterator.return();
            },
        };
    }
}
exports.default = Run;
//# sourceMappingURL=run.js.map{"version":3,"file":"run.js","sourceRoot":"","sources":["../src/run.ts"],"names":[],"mappings":"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"}import { type EventChannel } from '@postman/runtime.event-channel';
import { Variables, VariableScope } from '@postman/runtime.variable-scope';
import Item from './item';
import ItemTree from './item-tree';
import ItemType from './item-type';
import { Validator } from './validator';
import Run, { impls } from './run';
export declare class Runtime extends Validator {
    private readonly [impls];
    registerExecutableType(impl: ItemType.Implementation): this;
    execItem<Y extends ItemType = ItemType>(item: Item.OfType<Y>, options?: RuntimeOptions): Run;
    execTree(tree: ItemTree, options?: RuntimeOptions): Run;
}
export interface RuntimeContextCore {
    variables: Variables;
    locals: VariableScope;
    collectionVariables: VariableScope;
    environment: VariableScope;
    globals: VariableScope;
    secureContext: RuntimeOptions['secureContext'];
    proxy: RuntimeOptions['proxy'];
}
export interface RuntimeContext extends RuntimeContextCore {
    events: EventChannel.Any;
}
export interface RuntimeOptions {
    variables?: VariableOptions;
    secureContext?: ((url: string) => Promise<SecureContextOptions> | SecureContextOptions) | SecureContextOptions;
    proxy?: ((url: string, isSecure?: boolean) => Promise<ProxyOptions> | ProxyOptions) | ProxyOptions;
    startPaused?: boolean;
}
export interface VariableOptions {
    environment?: VariableScope.Definition | VariableScope.Values;
    globals?: VariableScope.Definition | VariableScope.Values;
    defaults?: VariableScope.Definition | VariableScope.Values;
    locals?: VariableScope.Definition | VariableScope.Values;
}
export interface ProxyOptions {
    url?: string;
    ignoreEnvironmentVariables?: boolean;
}
export interface SecureContextOptions {
    ca?: string | string[];
    crl?: string | string[];
    cert?: string | string[];
    key?: string | (string | KeyObject)[];
    pfx?: string | (string | PxfObject)[];
    passphrase?: string;
}
export interface KeyObject {
    pem: string;
    passphrase?: string;
}
export interface PxfObject {
    buf: string;
    passphrase?: string;
}
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Runtime = void 0;
const runtime_variable_scope_1 = require("@postman/runtime.variable-scope");
const item_1 = __importDefault(require("./item"));
const item_tree_1 = __importDefault(require("./item-tree"));
const validator_1 = require("./validator");
const run_1 = __importStar(require("./run"));
/*
    A Runtime is a subclass of Validator which is also capable of executing
    Items (and trees of Items). Instead of registering ItemTypes (as done in
    Validator), you provide an *implementation* of each ItemType that you want
    to execute.
*/
class Runtime extends validator_1.Validator {
    constructor() {
        super(...arguments);
        this[_a] = new Map();
    }
    registerExecutableType(impl) {
        super.registerType(impl.itemType);
        this[run_1.impls].set(impl.itemType.name, impl);
        return this;
    }
    execItem(item, options) {
        item = cloneAsJSON(item);
        if (!item_1.default.isItem(item)) {
            throw new TypeError('Invalid Item');
        }
        const context = getRuntimeContext(item, options);
        return new run_1.default(this, context, [item], Boolean(options?.startPaused));
    }
    execTree(tree, options) {
        tree = cloneAsJSON(tree);
        if (!item_tree_1.default.isItemTree(tree)) {
            throw new TypeError('Invalid ItemTree');
        }
        const context = getRuntimeContext(tree.item, options);
        return new run_1.default(this, context, item_tree_1.default.toItems(item_tree_1.default.toResolved(tree)), Boolean(options?.startPaused));
    }
}
exports.Runtime = Runtime;
_a = run_1.impls;
function cloneAsJSON(value) {
    const json = JSON.stringify(value);
    if (json !== undefined) {
        return JSON.parse(json);
    }
    return value;
}
function getVariableScope(variables) {
    return new runtime_variable_scope_1.VariableScope(variables
        ? Array.isArray(variables)
            ? { values: variables }
            : variables
        : { values: [] });
}
function getCollectionVariables(item) {
    const payload = item.payload;
    return getVariableScope(item.type === 'collection'
        ? payload?.variables
        : undefined);
}
function getRuntimeContext(item, options) {
    const locals = getVariableScope(options?.variables?.locals);
    const defaultVariables = getVariableScope(options?.variables?.defaults);
    const collectionVariables = getCollectionVariables(item);
    const environment = getVariableScope(options?.variables?.environment);
    const globals = getVariableScope(options?.variables?.globals);
    const variables = new runtime_variable_scope_1.Variables(locals, 
    // TODO: add data variables here
    environment, collectionVariables, globals, defaultVariables);
    return {
        variables,
        locals,
        collectionVariables,
        environment,
        globals,
        secureContext: options?.secureContext,
        proxy: options?.proxy,
    };
}
//# sourceMappingURL=runtime.js.map{"version":3,"file":"runtime.js","sourceRoot":"","sources":["../src/runtime.ts"],"names":[],"mappings":"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"}export default function singleton<T>(Class: new () => T): () => T;
"use strict";
/*
    This function takes a class, which should be treated like a singleton, and
    returns a lazy getter function which returns an instance of that class.
    Every time the getter is called, the same instance is returned.
*/
Object.defineProperty(exports, "__esModule", { value: true });
const nothing = Symbol();
function singleton(Class) {
    let instance = nothing;
    return () => {
        if (instance === nothing)
            instance = new Class();
        return instance;
    };
}
exports.default = singleton;
//# sourceMappingURL=singleton.js.map{"version":3,"file":"singleton.js","sourceRoot":"","sources":["../src/singleton.ts"],"names":[],"mappings":";AAAA;;;;EAIE;;AAEF,MAAM,OAAO,GAAG,MAAM,EAAE,CAAC;AAEzB,SAAwB,SAAS,CAAI,KAAkB;IACtD,IAAI,QAAQ,GAAuB,OAAO,CAAC;IAE3C,OAAO,GAAM,EAAE;QACd,IAAI,QAAQ,KAAK,OAAO;YAAE,QAAQ,GAAG,IAAI,KAAK,EAAE,CAAC;QACjD,OAAO,QAAQ,CAAC;IACjB,CAAC,CAAC;AACH,CAAC;AAPD,4BAOC"}export declare const STOP_RUN: unique symbol;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.STOP_RUN = void 0;
exports.STOP_RUN = Symbol('stop-run');
//# sourceMappingURL=symbols.js.map{"version":3,"file":"symbols.js","sourceRoot":"","sources":["../src/symbols.ts"],"names":[],"mappings":";;;AAAa,QAAA,QAAQ,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC"}import { Event } from '@postman/runtime.event-channel';
import Extension from './extension';
import ItemType from './item-type';
export type StringLiteral<T extends string> = T extends string ? string extends T ? never : T : never;
export type GetExtensionData<E extends Extension> = E extends Extension.Specific<any, infer D, any> ? D : E extends Extension ? unknown : never;
export type GetExtensionConfig<E extends Extension> = E extends Extension.Specific<any, any, infer C> ? C : E extends Extension ? unknown : never;
export type GetTypeData<Y extends ItemType> = Y extends ItemType.Specific<infer T, any, any, any, any> ? T : Y extends ItemType ? unknown : never;
export type GetTypeExtensions<Y extends ItemType> = Y extends ItemType.Specific<any, infer E, any, any, any> ? E : Y extends ItemType ? Extension : never;
export type GetTypeConfig<Y extends ItemType> = Y extends ItemType.Specific<any, any, infer C, any, any> ? C : Y extends ItemType ? unknown : never;
export type GetSentEvents<Y extends ItemType> = Y extends ItemType.Specific<any, any, any, infer S, any> ? S : Y extends ItemType ? Event : never;
export type GetReceivedEvents<Y extends ItemType> = Y extends ItemType.Specific<any, any, any, any, infer R> ? R : Y extends ItemType ? Event : never;
export type SelectExtension<N extends string, E extends Extension> = E['name'] extends N ? string extends N ? Extension : E : never;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=types.js.map{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":""}import Item from './item';
import ItemType from './item-type';
export declare class Validator {
    private readonly itemTypes;
    registerType(itemType: ItemType): this;
    getType(name: string): ItemType | undefined;
    eachType(): IterableIterator<ItemType>;
    validateItem(item: unknown): asserts item is Item;
    validateItemStrict(item: unknown): asserts item is Item;
    isKnownItem(item: Item): boolean;
    isCompletelyKnownItem(item: Item): boolean;
}
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Validator = void 0;
const item_1 = __importDefault(require("./item"));
const constraint_1 = __importDefault(require("./constraint"));
/*
    A Validator is a container for all your known ItemTypes. After registering
    all your ItemTypes, you can use the Validator to validate Items. Unknown
    ItemTypes and Extensions are ignored (i.e., they always pass validation),
    which is the desired behavior for most clients. However, in rare cases you
    may instead use strict validation to reject unknown ItemTypes and
    Extensions.
*/
class Validator {
    constructor() {
        this.itemTypes = new Map();
    }
    registerType(itemType) {
        if (this.itemTypes.has(itemType.name)) {
            throw new TypeError(`ItemType "${itemType.name}" already exists`);
        }
        this.itemTypes.set(itemType.name, itemType);
        return this;
    }
    getType(name) {
        return this.itemTypes.get(name);
    }
    eachType() {
        return this.itemTypes.values();
    }
    // Asserts that the given value is a valid item.
    validateItem(item) {
        if (!item_1.default.isItem(item)) {
            throw new Error('Invalid Item');
        }
        const itemType = this.itemTypes.get(item.type);
        if (itemType) {
            for (const constraint of itemType.constraints) {
                if (!constraint_1.default.isOk(item, constraint)) {
                    throw new Error(`Item violates constraint "${constraint.constraint}"`);
                }
            }
            if (!itemType.isValidPayload(item.payload)) {
                throw new Error(`Item violates the schema for ItemType "${itemType.name}"`);
            }
            for (const [extName, extData] of Object.entries(item.extensions)) {
                const impl = itemType.extensions.find((x) => x.extension.name === extName);
                if (impl && !impl.extension.isValid(extData)) {
                    throw new Error(`Item violates the schema for extension "${extName}"`);
                }
            }
        }
    }
    // Asserts that the given value is a valid item, and that its item type and
    // extensions are all known by this Validator.
    validateItemStrict(item) {
        this.validateItem(item);
        const itemType = this.itemTypes.get(item.type);
        if (!itemType) {
            throw new Error(`Unrecognized ItemType "${item.type}"`);
        }
        for (const extName of Object.keys(item.extensions)) {
            if (!itemType.extensions.find((x) => x.extension.name === extName)) {
                throw new Error(`Unrecognized extension "${extName}"`);
            }
        }
    }
    // Returns whether the given item's type is registered in this Validator.
    isKnownItem(item) {
        return this.itemTypes.has(item.type);
    }
    // Returns whether the given item's type, as well as all of its extensions,
    // are registered in this Validator.
    isCompletelyKnownItem(item) {
        const itemType = this.itemTypes.get(item.type);
        if (!itemType) {
            return false;
        }
        for (const extName of Object.keys(item.extensions)) {
            if (!itemType.extensions.find((x) => x.extension.name === extName)) {
                return false;
            }
        }
        return true;
    }
}
exports.Validator = Validator;
//# sourceMappingURL=validator.js.map{"version":3,"file":"validator.js","sourceRoot":"","sources":["../src/validator.ts"],"names":[],"mappings":"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"}{
  "name": "@postman/runtime.core",
  "version": "0.4.0",
  "license": "UNLICENSED",
  "description": "The core runtime framework, defining concepts such as ItemTypes and Extensions",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/core/core#readme",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "dependencies": {
    "ajv": "^8.12.0",
    "ajv-formats": "^2.1.1",
    "zod": "^3.21.4",
    "@postman/runtime.variable-scope": "^0.2.0",
    "@postman/runtime.event-channel": "^0.2.0"
  },
  "devDependencies": {
    "json-schema-to-ts": "~2.7.2"
  },
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest"
  }
}# Runtime core

This is the core runtime framework, defining concepts such as ItemTypes and Extensions, and providing the ability to validate and execute Items (and trees of Items). These concepts are very general, but they are used by Postman to represent Collections, and are central to Postman's ability to represent any type of request/protocol.
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": []
	},
	"references": [
		{ "path": "../event-channel" },
		{ "path": "../variable-scope" }
	]
}
import { FromSchema } from 'json-schema-to-ts';
import { Extension } from '@postman/runtime.core';
export interface PluginConfiguration {
}
declare const definition: {
    name: "documentation";
    summary: "Document your items";
    schema: {
        readonly type: "object";
        readonly required: ["content"];
        readonly properties: {
            readonly content: {
                readonly type: "string";
            };
            readonly summary: {
                readonly type: "string";
                readonly maxLength: 140;
            };
        };
        readonly additionalProperties: false;
    };
};
declare namespace Documentation {
    type Name = typeof definition.name;
    type Data = FromSchema<typeof definition.schema>;
    type Config = PluginConfiguration;
    const use: () => Extension.Specific<"documentation", {
        summary?: string | undefined;
        content: string;
    }, PluginConfiguration>;
}
type Documentation = Extension.Specific<Documentation.Name, Documentation.Data, Documentation.Config>;
export default Documentation;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const json_schema_to_ts_1 = require("json-schema-to-ts");
const runtime_core_1 = require("@postman/runtime.core");
const definition = (0, json_schema_to_ts_1.asConst)({
    name: 'documentation',
    summary: 'Document your items',
    schema: {
        type: 'object',
        required: ['content'],
        properties: {
            content: {
                type: 'string',
            },
            summary: {
                type: 'string',
                maxLength: 140,
            },
        },
        additionalProperties: false,
    },
});
var Documentation;
(function (Documentation) {
    Documentation.use = runtime_core_1.Extension.define(definition);
})(Documentation || (Documentation = {}));
exports.default = Documentation;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;AAAA,yDAAoE;AACpE,wDAAkD;AAIlD,MAAM,UAAU,GAAG,IAAA,2BAAO,EAAC;IAC1B,IAAI,EAAE,eAAe;IACrB,OAAO,EAAE,qBAAqB;IAC9B,MAAM,EAAE;QACP,IAAI,EAAE,QAAQ;QACd,QAAQ,EAAE,CAAC,SAAS,CAAC;QACrB,UAAU,EAAE;YACX,OAAO,EAAE;gBACR,IAAI,EAAE,QAAQ;aACd;YACD,OAAO,EAAE;gBACR,IAAI,EAAE,QAAQ;gBACd,SAAS,EAAE,GAAG;aACd;SACD;QACD,oBAAoB,EAAE,KAAK;KACG;CAC/B,CAAC,CAAC;AAEH,IAAU,aAAa,CAKtB;AALD,WAAU,aAAa;IAIT,iBAAG,GAAG,wBAAS,CAAC,MAAM,CAAqB,UAAU,CAAC,CAAC;AACrE,CAAC,EALS,aAAa,KAAb,aAAa,QAKtB;AAOD,kBAAe,aAAa,CAAC"}{
  "name": "@postman/runtime.documentation",
  "version": "0.1.13",
  "license": "UNLICENSED",
  "description": "The Postman ItemType extension: 'documentation'",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/extensions/documentation#readme",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "dependencies": {
    "json-schema-to-ts": "~2.7.2"
  },
  "peerDependencies": {
    "@postman/runtime.core": "^0.4.0"
  },
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest"
  }
}# Extension: `documentation`

This package defines the Postman ItemType extension: `documentation`.
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": []
	},
	"references": [{ "path": "../../core/core" }]
}
interface Event<N extends string = string, T = unknown> {
    type: N;
    timestamp: string;
    payload: T;
}
declare namespace Event {
    type Any = Event<string, any>;
}
declare class EventChannel<Sent extends Event = never, Received extends Event = never> {
    private isClosed;
    private peer;
    private eventQueue;
    private eventHandlers;
    private cleanupCallbacks;
    private receive;
    get closed(): boolean;
    on<N extends Received['type']>(eventType: N, callback: (event: Received & {
        type: N;
    }) => void): this;
    off<N extends Received['type']>(eventType: N, callback: (event: Received & {
        type: N;
    }) => void): this;
    onAll(callback: (event: Received) => void): this;
    offAll(callback: (event: Received) => void): this;
    onCleanup(callback: () => void): this;
    offCleanup(callback: () => void): this;
    send(event: Sent): void;
    emit<N extends Sent['type']>(eventType: N, payload: (Sent & {
        type: N;
    })['payload']): void;
    emitSelf<N extends Received['type']>(eventType: N, payload: (Received & {
        type: N;
    })['payload']): Promise<void>;
    close(): void;
    link(peer: EventChannel<Received, Sent>): void;
    unlink(peer: EventChannel<Received, Sent>): void;
}
declare namespace EventChannel {
    type Any = EventChannel<Event.Any, Event.Any>;
    function specific<S extends Event, R extends Event>(channel: EventChannel.Any): EventChannel<S, R>;
}

export { Event, EventChannel };
interface Event<N extends string = string, T = unknown> {
    type: N;
    timestamp: string;
    payload: T;
}
declare class EventChannel<Sent extends Event = never, Received extends Event = never> {
    private isClosed;
    private peer;
    private eventQueue;
    private eventHandlers;
    private cleanupCallbacks;
    private receive;
    get closed(): boolean;
    on<N extends Received['type']>(eventType: N, callback: (event: Received & {
        type: N;
    }) => void): this;
    off<N extends Received['type']>(eventType: N, callback: (event: Received & {
        type: N;
    }) => void): this;
    onAll(callback: (event: Received) => void): this;
    offAll(callback: (event: Received) => void): this;
    onCleanup(callback: () => void): this;
    offCleanup(callback: () => void): this;
    send(event: Sent): void;
    emit<N extends Sent['type']>(eventType: N, payload: (Sent & {
        type: N;
    })['payload']): void;
    emitSelf<N extends Received['type']>(eventType: N, payload: (Received & {
        type: N;
    })['payload']): Promise<void>;
    close(): void;
    link(peer: EventChannel<Received, Sent>): void;
    unlink(peer: EventChannel<Received, Sent>): void;
}
declare namespace Event {
    type Any = Event<string, any>;
}
declare namespace EventChannel {
    type Any = EventChannel<Event.Any, Event.Any>;
    function specific<S extends Event, R extends Event>(channel: EventChannel.Any): EventChannel<S, R>;
}
export { Event, EventChannel };
"use strict";
/*
    An EventChannel is a bidrectional communication channel that communicates
    with its peer by sending and receiving standardized events. Each event has a
    type (string), a timestamp (ISO-formatted string), and a payload (anything).

    An EventChannel is meant to be "linked" with another EventChannel, causing
    any events sent on one to be received on the other, and vice-versa. Each
    EventChannel can only have one linked peer at a time. Unless a peer is
    linked, EventChannels will queue any events that they emit.

    EventChannels can be "closed", after which they cannot send or receive any
    more events. When an EventChannel is closed, its linked peer is also closed,
    which prevents resource leaks and unnecessary tasks continuing after the
    user is no longer interested in them. EventChannels can register "cleanup"
    callbacks which will be invoked when the EventChannel becomes closed.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventChannel = void 0;
class EventChannel {
    constructor() {
        this.isClosed = false;
        this.peer = null;
        this.eventQueue = [];
        this.eventHandlers = [];
        this.cleanupCallbacks = [];
    }
    receive(event) {
        if (this.isClosed) {
            return;
        }
        for (const handler of this.eventHandlers) {
            // Handle events in their own event loop ticks.
            Promise.resolve(event).then(handler.wrapped);
        }
    }
    get closed() {
        return this.isClosed;
    }
    on(eventType, callback) {
        if (this.isClosed) {
            return this;
        }
        const wrapped = (event) => {
            if (!this.isClosed && event.type === eventType) {
                callback(event);
            }
        };
        this.eventHandlers.push({ wrapped, original: callback, eventType });
        return this;
    }
    off(eventType, callback) {
        for (let i = 0; i < this.eventHandlers.length; ++i) {
            const handler = this.eventHandlers[i];
            if (handler.original === callback && handler.eventType === eventType) {
                this.eventHandlers.splice(i, 1);
                break;
            }
        }
        return this;
    }
    onAll(callback) {
        if (this.isClosed) {
            return this;
        }
        const wrapped = (event) => {
            if (!this.isClosed) {
                callback(event);
            }
        };
        this.eventHandlers.push({ wrapped, original: callback, eventType: null });
        return this;
    }
    offAll(callback) {
        for (let i = 0; i < this.eventHandlers.length; ++i) {
            const handler = this.eventHandlers[i];
            if (handler.original === callback && handler.eventType === null) {
                this.eventHandlers.splice(i, 1);
                break;
            }
        }
        return this;
    }
    onCleanup(callback) {
        if (this.isClosed) {
            Promise.resolve().then(callback); // Already closed; cleanup immediately
        }
        else {
            this.cleanupCallbacks.push(callback);
        }
        return this;
    }
    offCleanup(callback) {
        const index = this.cleanupCallbacks.indexOf(callback);
        if (index !== -1) {
            this.cleanupCallbacks.splice(index, 1);
        }
        return this;
    }
    send(event) {
        if (this.isClosed) {
            return;
        }
        if (this.peer) {
            this.peer.receive(event);
        }
        else {
            this.eventQueue.push(event);
        }
    }
    emit(eventType, payload) {
        this.send({
            type: eventType,
            timestamp: new Date().toISOString(),
            payload,
        });
    }
    async emitSelf(eventType, payload) {
        // The user might want to call close() immediately after emitSelf(),
        // which would prevent this event from actually being emitted, since
        // events are emitted asynchronously. Therefore, we await a Promise,
        // giving the user an opportunity to wait until a point when the event
        // has actually been emitted.
        await new Promise((resolve) => {
            this.on(eventType, resolve);
            this.receive({
                type: eventType,
                timestamp: new Date().toISOString(),
                payload,
            });
            this.off(eventType, resolve);
        });
    }
    close() {
        if (this.isClosed) {
            return;
        }
        this.isClosed = true;
        this.eventHandlers = [];
        while (this.cleanupCallbacks.length) {
            // Handle cleanup callbacks in their own event loop ticks.
            Promise.resolve().then(this.cleanupCallbacks.shift());
        }
        // Closing an EventChannel causes its peer to close too, but we do it
        // asynchronously so events emitted earlier in the tick are still sent.
        // Also, it's important to do this after all cleanup callbacks, so the
        // cleanup callbacks have a chance to unlink the peer, if desired.
        const peer = this.peer;
        if (peer && !peer.isClosed) {
            Promise.resolve().then(() => {
                // The peer can change, so we make sure it's the same peer.
                if (peer === this.peer) {
                    peer.close();
                }
            });
        }
    }
    link(peer) {
        if (this.peer) {
            throw new TypeError('This EventChannel already has a linked peer');
        }
        if (peer.peer) {
            throw new TypeError('The peer EventChannel already has a linked peer');
        }
        this.peer = peer;
        peer.peer = this;
        while (this.eventQueue.length) {
            peer.receive(this.eventQueue.shift());
        }
        while (peer.eventQueue.length) {
            this.receive(peer.eventQueue.shift());
        }
        // Closing an EventChannel causes its peer to close too, but we do it
        // asynchronously so events emitted earlier in the tick are still sent.
        if (this.isClosed !== peer.isClosed) {
            Promise.resolve().then(() => {
                // The peers can change, so we make sure they're the same.
                if (peer === this.peer) {
                    peer.close();
                    this.close();
                }
            });
        }
    }
    unlink(peer) {
        // We require that the linked peer be passed explicitly, to prevent
        // against race conditions of linking/unlinking/re-linking.
        if (this.peer !== peer) {
            return;
        }
        peer.peer = null;
        this.peer = null;
    }
}
exports.EventChannel = EventChannel;
(function (EventChannel) {
    function specific(channel) {
        return channel;
    }
    EventChannel.specific = specific;
})(EventChannel || (exports.EventChannel = EventChannel = {}));
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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"}// src/index.ts
var EventChannel = class {
  constructor() {
    this.isClosed = false;
    this.peer = null;
    this.eventQueue = [];
    this.eventHandlers = [];
    this.cleanupCallbacks = [];
  }
  receive(event) {
    if (this.isClosed) {
      return;
    }
    for (const handler of this.eventHandlers) {
      Promise.resolve(event).then(handler.wrapped);
    }
  }
  get closed() {
    return this.isClosed;
  }
  on(eventType, callback) {
    if (this.isClosed) {
      return this;
    }
    const wrapped = (event) => {
      if (!this.isClosed && event.type === eventType) {
        callback(event);
      }
    };
    this.eventHandlers.push({ wrapped, original: callback, eventType });
    return this;
  }
  off(eventType, callback) {
    for (let i = 0; i < this.eventHandlers.length; ++i) {
      const handler = this.eventHandlers[i];
      if (handler?.original === callback && handler?.eventType === eventType) {
        this.eventHandlers.splice(i, 1);
        break;
      }
    }
    return this;
  }
  onAll(callback) {
    if (this.isClosed) {
      return this;
    }
    const wrapped = (event) => {
      if (!this.isClosed) {
        callback(event);
      }
    };
    this.eventHandlers.push({ wrapped, original: callback, eventType: null });
    return this;
  }
  offAll(callback) {
    for (let i = 0; i < this.eventHandlers.length; ++i) {
      const handler = this.eventHandlers[i];
      if (handler?.original === callback && handler?.eventType === null) {
        this.eventHandlers.splice(i, 1);
        break;
      }
    }
    return this;
  }
  onCleanup(callback) {
    if (this.isClosed) {
      Promise.resolve().then(callback);
    } else {
      this.cleanupCallbacks.push(callback);
    }
    return this;
  }
  offCleanup(callback) {
    const index = this.cleanupCallbacks.indexOf(callback);
    if (index !== -1) {
      this.cleanupCallbacks.splice(index, 1);
    }
    return this;
  }
  send(event) {
    if (this.isClosed) {
      return;
    }
    if (this.peer) {
      this.peer.receive(event);
    } else {
      this.eventQueue.push(event);
    }
  }
  emit(eventType, payload) {
    this.send({
      type: eventType,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      payload
    });
  }
  async emitSelf(eventType, payload) {
    await new Promise((resolve) => {
      this.on(eventType, resolve);
      this.receive({
        type: eventType,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        payload
      });
      this.off(eventType, resolve);
    });
  }
  close() {
    if (this.isClosed) {
      return;
    }
    this.isClosed = true;
    this.eventHandlers = [];
    while (this.cleanupCallbacks.length) {
      Promise.resolve().then(this.cleanupCallbacks.shift());
    }
    const peer = this.peer;
    if (peer && !peer.isClosed) {
      Promise.resolve().then(() => {
        if (peer === this.peer) {
          peer.close();
        }
      });
    }
  }
  link(peer) {
    if (this.peer) {
      throw new TypeError("This EventChannel already has a linked peer");
    }
    if (peer.peer) {
      throw new TypeError("The peer EventChannel already has a linked peer");
    }
    this.peer = peer;
    peer.peer = this;
    while (this.eventQueue.length) {
      peer.receive(this.eventQueue.shift());
    }
    while (peer.eventQueue.length) {
      this.receive(peer.eventQueue.shift());
    }
    if (this.isClosed !== peer.isClosed) {
      Promise.resolve().then(() => {
        if (peer === this.peer) {
          peer.close();
          this.close();
        }
      });
    }
  }
  unlink(peer) {
    if (this.peer !== peer) {
      return;
    }
    peer.peer = null;
    this.peer = null;
  }
};
((EventChannel2) => {
  function specific(channel) {
    return channel;
  }
  EventChannel2.specific = specific;
})(EventChannel || (EventChannel = {}));
export {
  EventChannel
};
{
  "name": "@postman/runtime.event-channel",
  "version": "0.2.0",
  "license": "UNLICENSED",
  "description": "An event-based bidirectional communication channel",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/core/event-channel#readme",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest"
  }
}# event-channel

A bidirectional communication channel, where each peer communicates by sending and receiving standardized events.
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": []
	}
}
import { type Event } from '@postman/runtime.event-channel';
import type Events from '.';
import type { Item } from '@postman/runtime.core';
declare const _default: (itemType: import("@postman/runtime.core").ItemType.WithExtension<Events>, context: import("@postman/runtime.core").RuntimeContext) => Promise<{
    onBefore(i: Item.WithExtension<Events>): Promise<void>;
    onEvent(event: Event): void;
    onAfter(): Promise<void>;
}>;
export default _default;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sandbox_1 = require("./sandbox");
exports.default = (async function handler(itemType, context) {
    let item;
    let itemContext = {};
    const { config } = itemType.getExtension('events');
    const { supportedListeners, template, setContext } = config;
    const sandbox = await (0, sandbox_1.getSandbox)(context);
    sandbox.register(itemType.name, template);
    async function execute(supportedEvent) {
        const events = item.extensions.events;
        if (!events)
            return;
        const eventsToExecute = events.filter((e) => e.listen === supportedEvent);
        if (!eventsToExecute.length)
            return;
        for (const event of eventsToExecute) {
            await sandbox.execute(itemType.name, event, itemContext);
        }
    }
    return {
        async onBefore(i) {
            // Store the item for other hooks to use
            item = i;
            itemContext = setContext(itemContext, item);
            const supportedEvent = supportedListeners?.onBefore;
            if (!supportedEvent)
                return;
            await execute(supportedEvent);
        },
        onEvent(event) {
            itemContext = setContext(itemContext, item, event);
            const supportedEvent = supportedListeners?.onEvent?.[event.type];
            if (!supportedEvent)
                return;
            execute(supportedEvent);
        },
        async onAfter() {
            // Even though sandbox executes scripts via a queue,
            // explicitly wait for it to complete all `onEvent` scripts
            // as `onAfter` hook might not have any scripts to execute
            // which then would cause the hook to resolve before completion.
            await sandbox.waitForCompletion();
            itemContext = setContext(itemContext, item);
            const supportedEvent = supportedListeners?.onAfter;
            if (!supportedEvent)
                return;
            await execute(supportedEvent);
        },
    };
});
//# sourceMappingURL=handler.js.map{"version":3,"file":"handler.js","sourceRoot":"","sources":["../src/handler.ts"],"names":[],"mappings":";;AAAA,uCAAuC;AAMvC,mBAAgB,KAAK,UAAU,OAAO,CAAC,QAAQ,EAAE,OAAO;IACvD,IAAI,IAAgC,CAAC;IACrC,IAAI,WAAW,GAAgB,EAAE,CAAC;IAElC,MAAM,EAAE,MAAM,EAAE,GAAG,QAAQ,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;IACnD,MAAM,EAAE,kBAAkB,EAAE,QAAQ,EAAE,UAAU,EAAE,GAAG,MAAM,CAAC;IAE5D,MAAM,OAAO,GAAG,MAAM,IAAA,oBAAU,EAAC,OAAO,CAAC,CAAC;IAC1C,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IAE1C,KAAK,UAAU,OAAO,CAAC,cAAsB;QAC5C,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC;QACtC,IAAI,CAAC,MAAM;YAAE,OAAO;QAEpB,MAAM,eAAe,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,KAAK,cAAc,CAAC,CAAC;QAC1E,IAAI,CAAC,eAAe,CAAC,MAAM;YAAE,OAAO;QAEpC,KAAK,MAAM,KAAK,IAAI,eAAe,EAAE,CAAC;YACrC,MAAM,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,WAAW,CAAC,CAAC;QAC1D,CAAC;IACF,CAAC;IAED,OAAO;QACN,KAAK,CAAC,QAAQ,CAAC,CAAC;YACf,wCAAwC;YACxC,IAAI,GAAG,CAAC,CAAC;YACT,WAAW,GAAG,UAAU,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;YAE5C,MAAM,cAAc,GAAG,kBAAkB,EAAE,QAAQ,CAAC;YACpD,IAAI,CAAC,cAAc;gBAAE,OAAO;YAE5B,MAAM,OAAO,CAAC,cAAc,CAAC,CAAC;QAC/B,CAAC;QACD,OAAO,CAAC,KAAY;YACnB,WAAW,GAAG,UAAU,CAAC,WAAW,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;YAEnD,MAAM,cAAc,GAAG,kBAAkB,EAAE,OAAO,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YACjE,IAAI,CAAC,cAAc;gBAAE,OAAO;YAE5B,OAAO,CAAC,cAAc,CAAC,CAAC;QACzB,CAAC;QACD,KAAK,CAAC,OAAO;YACZ,oDAAoD;YACpD,2DAA2D;YAC3D,0DAA0D;YAC1D,gEAAgE;YAChE,MAAM,OAAO,CAAC,iBAAiB,EAAE,CAAC;YAElC,WAAW,GAAG,UAAU,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;YAE5C,MAAM,cAAc,GAAG,kBAAkB,EAAE,OAAO,CAAC;YACnD,IAAI,CAAC,cAAc;gBAAE,OAAO;YAE5B,MAAM,OAAO,CAAC,cAAc,CAAC,CAAC;QAC/B,CAAC;KACD,CAAC;AACH,CAAsC,EAAC"}import { FromSchema } from 'json-schema-to-ts';
import { Event, Extension, Item } from '@postman/runtime.core';
import type { ItemContext } from './sandbox/sandbox-types';
export interface PluginConfiguration {
    supportedListeners: {
        onBefore?: string;
        onEvent?: Record<string, string>;
        onAfter?: string;
    };
    template: Readonly<string>;
    setContext: (prevContext: ItemContext, item: Item, event?: Event) => ItemContext;
}
declare const definition: {
    name: "events";
    summary: "Script hooks for collection execution";
    schema: {
        readonly type: "array";
        readonly items: {
            readonly type: "object";
            readonly required: ["listen"];
            readonly properties: {
                readonly listen: {
                    readonly type: "string";
                };
                readonly script: {
                    readonly type: "object";
                    readonly required: ["exec"];
                    readonly properties: {
                        readonly exec: {
                            readonly type: "string";
                        };
                        readonly type: {
                            readonly type: "string";
                            readonly enum: readonly ["text/javascript"];
                        };
                    };
                    readonly additionalProperties: false;
                };
            };
            readonly additionalProperties: false;
        };
    };
};
declare namespace Events {
    type Name = typeof definition.name;
    type Data = FromSchema<typeof definition.schema>;
    type Config = PluginConfiguration;
    const use: () => Extension.Specific<"events", {
        script?: {
            type?: "text/javascript" | undefined;
            exec: string;
        } | undefined;
        listen: string;
    }[], PluginConfiguration>;
}
type Events = Extension.Specific<Events.Name, Events.Data, Events.Config>;
export default Events;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const json_schema_to_ts_1 = require("json-schema-to-ts");
const runtime_core_1 = require("@postman/runtime.core");
const handler_1 = __importDefault(require("./handler"));
const definition = (0, json_schema_to_ts_1.asConst)({
    name: 'events',
    summary: 'Script hooks for collection execution',
    schema: {
        type: 'array',
        items: {
            type: 'object',
            required: ['listen'],
            properties: {
                listen: {
                    type: 'string',
                },
                script: {
                    type: 'object',
                    required: ['exec'],
                    properties: {
                        exec: {
                            type: 'string',
                        },
                        type: {
                            type: 'string',
                            enum: ['text/javascript'],
                        },
                    },
                    additionalProperties: false,
                },
            },
            additionalProperties: false,
        },
    },
});
var Events;
(function (Events) {
    Events.use = runtime_core_1.Extension.define(definition, handler_1.default);
})(Events || (Events = {}));
exports.default = Events;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;AAAA,yDAAoE;AACpE,wDAA+D;AAC/D,wDAAgC;AAkBhC,MAAM,UAAU,GAAG,IAAA,2BAAO,EAAC;IAC1B,IAAI,EAAE,QAAQ;IACd,OAAO,EAAE,uCAAuC;IAChD,MAAM,EAAE;QACP,IAAI,EAAE,OAAO;QACb,KAAK,EAAE;YACN,IAAI,EAAE,QAAQ;YACd,QAAQ,EAAE,CAAC,QAAQ,CAAC;YACpB,UAAU,EAAE;gBACX,MAAM,EAAE;oBACP,IAAI,EAAE,QAAQ;iBACd;gBACD,MAAM,EAAE;oBACP,IAAI,EAAE,QAAQ;oBACd,QAAQ,EAAE,CAAC,MAAM,CAAC;oBAClB,UAAU,EAAE;wBACX,IAAI,EAAE;4BACL,IAAI,EAAE,QAAQ;yBACd;wBACD,IAAI,EAAE;4BACL,IAAI,EAAE,QAAQ;4BACd,IAAI,EAAE,CAAC,iBAAiB,CAAC;yBACzB;qBACD;oBACD,oBAAoB,EAAE,KAAK;iBAC3B;aACD;YACD,oBAAoB,EAAE,KAAK;SAC3B;KAC6B;CAC/B,CAAC,CAAC;AAEH,IAAU,MAAM,CAKf;AALD,WAAU,MAAM;IAIF,UAAG,GAAG,wBAAS,CAAC,MAAM,CAAqB,UAAU,EAAE,iBAAO,CAAC,CAAC;AAC9E,CAAC,EALS,MAAM,KAAN,MAAM,QAKf;AAGD,kBAAe,MAAM,CAAC"}export default class AsyncQueue {
    private queue;
    private running;
    private isKilled;
    push(task: () => Promise<void>, callback: (e?: unknown) => void): void;
    kill(): void;
    drain(): Promise<unknown>;
    private run;
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class AsyncQueue {
    constructor() {
        this.queue = [];
        this.running = false;
        this.isKilled = false;
    }
    push(task, callback) {
        if (this.isKilled) {
            throw new Error('Queue is killed. Cannot push new tasks.');
        }
        const wrappedTask = async () => {
            try {
                await task();
                callback();
            }
            catch (e) {
                callback(e);
            }
        };
        this.queue.push(wrappedTask);
        this.run();
    }
    kill() {
        this.queue = [];
        this.running = false;
        this.isKilled = true;
    }
    async drain() {
        const completionTask = async () => { };
        return new Promise((resolve) => {
            this.push(completionTask, resolve);
        });
    }
    async run() {
        if (this.running) {
            return;
        }
        this.running = true;
        while (this.queue.length > 0) {
            const task = this.queue.shift();
            await task();
        }
        this.running = false;
    }
}
exports.default = AsyncQueue;
//# sourceMappingURL=async-task-queue.js.map{"version":3,"file":"async-task-queue.js","sourceRoot":"","sources":["../../src/sandbox/async-task-queue.ts"],"names":[],"mappings":";;AAAA,MAAqB,UAAU;IAA/B;QACS,UAAK,GAA+B,EAAE,CAAC;QACvC,YAAO,GAAG,KAAK,CAAC;QAChB,aAAQ,GAAG,KAAK,CAAC;IAgD1B,CAAC;IA9CA,IAAI,CAAC,IAAyB,EAAE,QAA+B;QAC9D,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YACnB,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAC;QAC5D,CAAC;QAED,MAAM,WAAW,GAAG,KAAK,IAAI,EAAE;YAC9B,IAAI,CAAC;gBACJ,MAAM,IAAI,EAAE,CAAC;gBACb,QAAQ,EAAE,CAAC;YACZ,CAAC;YAAC,OAAO,CAAC,EAAE,CAAC;gBACZ,QAAQ,CAAC,CAAC,CAAC,CAAC;YACb,CAAC;QACF,CAAC,CAAC;QAEF,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC7B,IAAI,CAAC,GAAG,EAAE,CAAC;IACZ,CAAC;IAED,IAAI;QACH,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;QAChB,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;QACrB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;IACtB,CAAC;IAED,KAAK,CAAC,KAAK;QACV,MAAM,cAAc,GAAG,KAAK,IAAI,EAAE,GAAE,CAAC,CAAC;QAEtC,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;YAC9B,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,OAAO,CAAC,CAAC;QACpC,CAAC,CAAC,CAAC;IACJ,CAAC;IAEO,KAAK,CAAC,GAAG;QAChB,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC;YAClB,OAAO;QACR,CAAC;QAED,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QAEpB,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC9B,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;YAChC,MAAM,IAAK,EAAE,CAAC;QACf,CAAC;QAED,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;IACtB,CAAC;CACD;AAnDD,6BAmDC"}export default class AutoIncrementID {
    private nextID;
    constructor();
    generateID(): string;
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class AutoIncrementID {
    constructor() {
        this.nextID = 1;
    }
    generateID() {
        const id = this.nextID++;
        return id.toString();
    }
}
exports.default = AutoIncrementID;
//# sourceMappingURL=auto-increment-id.js.map{"version":3,"file":"auto-increment-id.js","sourceRoot":"","sources":["../../src/sandbox/auto-increment-id.ts"],"names":[],"mappings":";;AAAA,MAAqB,eAAe;IAGnC;QACC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;IACjB,CAAC;IAED,UAAU;QACT,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;QACzB,OAAO,EAAE,CAAC,QAAQ,EAAE,CAAC;IACtB,CAAC;CACD;AAXD,kCAWC"}import { ItemContext } from './sandbox-types';
import type Events from '..';
import { type RuntimeContext } from '@postman/runtime.core';
export declare function getSandbox(runContext: RuntimeContext): Promise<SandboxClient>;
declare class SandboxClient {
    private readonly runContext;
    private sandboxFleet;
    private asyncScriptError;
    private source;
    private readonly queue;
    private readonly cleanups;
    private readonly idGenerator;
    constructor(runContext: RuntimeContext);
    init(): Promise<this>;
    register(templateName: string, template: string): void;
    execute(templateName: string, event: Events.Data[number], itemContext: ItemContext): Promise<void>;
    waitForCompletion(): Promise<void>;
    private get isStopped();
    private getContext;
    private emit;
    private attachListeners;
    private removeListeners;
    private _execute;
    private dispose;
}
export {};
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSandbox = getSandbox;
const postman_sandbox_1 = __importDefault(require("postman-sandbox"));
const runtime_core_1 = require("@postman/runtime.core");
const async_task_queue_1 = __importDefault(require("./async-task-queue"));
const auto_increment_id_1 = __importDefault(require("./auto-increment-id"));
const sandboxMap = new WeakMap();
async function getSandbox(runContext) {
    let sandbox = sandboxMap.get(runContext);
    if (!sandbox) {
        sandbox = await new SandboxClient(runContext).init();
        sandboxMap.set(runContext, sandbox);
    }
    return sandbox;
}
class SandboxClient {
    constructor(runContext) {
        this.runContext = runContext;
        this.asyncScriptError = null;
        this.source = null;
        this.queue = new async_task_queue_1.default();
        this.cleanups = [];
        this.idGenerator = new auto_increment_id_1.default();
    }
    async init() {
        this.sandboxFleet = await promisify(postman_sandbox_1.default.createContextFleet)({}, { disabledAPIs: ['cookies', 'visualizer', 'execution'] }, { serializeLogs: true });
        this.runContext.events.onCleanup(() => this.dispose());
        return this;
    }
    register(templateName, template) {
        if (this.sandboxFleet.isRegistered(templateName)) {
            return;
        }
        this.sandboxFleet.register(templateName, template);
    }
    async execute(templateName, event, itemContext) {
        // Add validation on arguments
        // TODO: Cast event into PostmanEvent
        if (!event.script?.exec?.trim()) {
            return;
        }
        const task = () => this._execute(templateName, event, {
            ...itemContext,
            ...variablesToSandbox(this.runContext),
        });
        return new Promise((resolve) => {
            this.queue.push(task, () => {
                this.source = null;
                resolve();
            });
        });
    }
    async waitForCompletion() {
        await this.queue.drain();
    }
    get isStopped() {
        return this.runContext.events.closed;
    }
    async getContext(templateName) {
        return promisify(this.sandboxFleet.getContext.bind(this.sandboxFleet))(templateName);
    }
    emit(type, data, stopRun = false) {
        if (this.isStopped)
            return;
        if (this.source === null) {
            throw new Error('Cannot emit event without a source');
        }
        const event = { data, source: this.source };
        if (stopRun)
            event[runtime_core_1.STOP_RUN] = stopRun;
        this.runContext.events.emit(type, event);
    }
    attachListeners(context, eventId) {
        // ASSERTION
        const assertion = `execution.assertion.${eventId}`;
        context.on(assertion, (_, assertions) => {
            this.emit('extension:events:assertion', { assertions });
        });
        this.cleanups.push(() => context.removeAllListeners(assertion));
        // ERROR
        const asyncError = `execution.error.${eventId}`;
        context.once(asyncError, (_, e) => {
            // Caching the error originating from execution of async scripts.
            // These errors do not show up in the callback of `sandbox.execute()`.
            // Using `once` so that we only store the first error in case of multiple errors.
            this.asyncScriptError = e;
        });
        this.cleanups.push(() => context.removeAllListeners(asyncError));
        // CONSOLE
        // NOTE: This is global listener and might cause issues
        // if we enable parallel execution of scripts on same context.
        context.on('console', (_, level, messages) => {
            this.emit('extension:events:console', { level, messages });
        });
        this.cleanups.push(() => context.removeAllListeners('console'));
        // HTTP REQUEST
        const httpRequest = `execution.request.${eventId}`;
        context.on(httpRequest, (_, id, eventId, request) => {
            this.emit('extension:events:http-request', { id, eventId, request });
        });
        this.cleanups.push(() => context.removeAllListeners(httpRequest));
        // HTTP RESPONSE
        const { events } = this.runContext;
        const httpResponse = 'extension:events:http-response';
        const sandboxHttpResponse = `execution.response.${eventId}`;
        const onHTTPResponse = ({ payload }) => {
            if (this.isStopped)
                return;
            if (payload.id !== eventId)
                return;
            context.dispatch(sandboxHttpResponse, payload.eventId, payload.err, payload.response);
        };
        events.on(httpResponse, onHTTPResponse);
        this.cleanups.push(() => events.off(httpResponse, onHTTPResponse));
        this.cleanups.push(() => context.removeAllListeners(sandboxHttpResponse));
    }
    removeListeners() {
        this.cleanups.forEach((cleanup) => cleanup());
    }
    async _execute(templateName, event, executionContext) {
        if (this.isStopped)
            return;
        let err = null;
        let result = null;
        const eventId = this.idGenerator.generateID();
        this.source = {
            id: eventId,
            name: event.listen,
        };
        this.emit('extension:events:exec-begin');
        const sandboxContext = await this.getContext(templateName);
        if (this.isStopped)
            return;
        this.attachListeners(sandboxContext, eventId);
        try {
            result = await promisify(sandboxContext.execute.bind(sandboxContext))(event, {
                id: eventId,
                context: executionContext,
                legacy: {
                    _itemId: executionContext?.request?.id,
                    _itemName: executionContext?.request?.name,
                    // TODO: populate these values
                    _itemPath: null,
                    _eventItemName: null,
                },
            });
        }
        catch (e) {
            err = e;
        }
        this.removeListeners();
        if (this.isStopped)
            return;
        if (err || this.asyncScriptError) {
            this.emit('extension:events:error', { error: err || this.asyncScriptError }, true);
            this.asyncScriptError = null;
            return;
        }
        if (result) {
            const variables = variablesFromSandbox(result);
            objectKeys(variables).forEach((key) => this.runContext[key].put(variables[key]));
        }
        this.emit('extension:events:exec-end', { result });
    }
    dispose() {
        this.queue.kill();
        this.removeListeners();
        this.sandboxFleet.disposeAll();
        sandboxMap.delete(this.runContext);
    }
}
function promisify(fn) {
    return (...args) => new Promise((resolve, reject) => {
        fn(...args, (err, result) => {
            if (err) {
                return reject(err);
            }
            resolve(result);
        });
    });
}
const variablesToSandbox = (runContext) => {
    return {
        _variables: runContext.locals.toJSON(),
        environment: runContext.environment.toJSON(),
        globals: runContext.globals.toJSON(),
        collectionVariables: runContext.collectionVariables.toJSON(),
    };
};
const variablesFromSandbox = (result) => {
    return {
        locals: result._variables?.values,
        environment: result.environment?.values,
        globals: result.globals?.values,
        collectionVariables: result.collectionVariables?.values,
    };
};
// Like Object.keys, but unsound in interest of more convenience
const objectKeys = (obj) => Object.keys(obj);
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/sandbox/index.ts"],"names":[],"mappings":"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"}import type { ExecutionContext } from 'postman-sandbox';
import { Event, STOP_RUN } from '@postman/runtime.core';
export type ItemContext = Pick<ExecutionContext, 'request' | 'response'>;
export interface SentEvent {
    data: unknown;
    source: {
        id: string;
        name?: string;
    };
    [STOP_RUN]?: boolean;
}
export type HTTPResponseEvent = Event<'extension:events:http-response', {
    id: string;
    eventId: string;
    err: unknown;
    response: unknown;
}>;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const runtime_core_1 = require("@postman/runtime.core");
//# sourceMappingURL=sandbox-types.js.map{"version":3,"file":"sandbox-types.js","sourceRoot":"","sources":["../../src/sandbox/sandbox-types.ts"],"names":[],"mappings":";;AAEA,wDAAwD"}{
  "name": "@postman/runtime.events",
  "version": "0.2.0",
  "license": "UNLICENSED",
  "description": "The Postman ItemType extension: 'events'",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/extensions/events#readme",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "dependencies": {
    "json-schema-to-ts": "~2.7.2",
    "postman-sandbox": "6.0.0"
  },
  "peerDependencies": {
    "@postman/runtime.core": "^0.4.0",
    "@postman/runtime.event-channel": "^0.2.0"
  },
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest"
  }
}# Extension: `events`

This package defines the Postman ItemType extension: `events`.
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": []
	},
	"references": [{ "path": "../../core/core" }]
}
import { FromSchema } from 'json-schema-to-ts';
import { ItemType } from '@postman/runtime.core';
import Documentation from '@postman/runtime.documentation';
declare const definition: {
    name: "folder";
    summary: "Organize your stuff with hierarchical folders";
    schema: {
        readonly type: "object";
        readonly additionalProperties: false;
    };
    constraints: [{
        constraint: "allow-child-types";
        allowed: ["folder", "ws-raw-request", "ws-socketio-request", "grpc-request", "graphql-request"];
    }, {
        constraint: "allow-extensions";
        allowed: ["documentation"];
    }];
};
declare namespace Folder {
    type Payload = FromSchema<typeof definition.schema>;
    type Extensions = Documentation;
    const use: () => ItemType.Specific<{}, Documentation, unknown, never, never>;
}
type Folder = ItemType.Specific<Folder.Payload, Folder.Extensions>;
export default Folder;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const json_schema_to_ts_1 = require("json-schema-to-ts");
const runtime_core_1 = require("@postman/runtime.core");
const runtime_documentation_1 = __importDefault(require("@postman/runtime.documentation"));
const definition = (0, json_schema_to_ts_1.asConst)({
    name: 'folder',
    summary: 'Organize your stuff with hierarchical folders',
    schema: {
        type: 'object',
        additionalProperties: false,
    },
    constraints: [
        {
            constraint: 'allow-child-types',
            allowed: [
                'folder',
                'ws-raw-request',
                'ws-socketio-request',
                'grpc-request',
                'graphql-request',
            ],
        },
        {
            constraint: 'allow-extensions',
            allowed: ['documentation'],
        },
    ],
});
const extensions = [runtime_documentation_1.default.use().implement({})];
var Folder;
(function (Folder) {
    Folder.use = runtime_core_1.ItemType.define(definition, extensions);
})(Folder || (Folder = {}));
exports.default = Folder;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;AAAA,yDAAoE;AACpE,wDAAiD;AACjD,2FAA2D;AAE3D,MAAM,UAAU,GAAG,IAAA,2BAAO,EAAC;IAC1B,IAAI,EAAE,QAAQ;IACd,OAAO,EAAE,+CAA+C;IACxD,MAAM,EAAE;QACP,IAAI,EAAE,QAAQ;QACd,oBAAoB,EAAE,KAAK;KACG;IAC/B,WAAW,EAAE;QACZ;YACC,UAAU,EAAE,mBAAmB;YAC/B,OAAO,EAAE;gBACR,QAAQ;gBACR,gBAAgB;gBAChB,qBAAqB;gBACrB,cAAc;gBACd,iBAAiB;aACjB;SACD;QACD;YACC,UAAU,EAAE,kBAAkB;YAC9B,OAAO,EAAE,CAAC,eAAe,CAAC;SAC1B;KACD;CACD,CAAC,CAAC;AAEH,MAAM,UAAU,GAAG,CAAC,+BAAa,CAAC,GAAG,EAAE,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC;AAEvD,IAAU,MAAM,CAOf;AAPD,WAAU,MAAM;IAGF,UAAG,GAAG,uBAAQ,CAAC,MAAM,CACjC,UAAU,EACV,UAAU,CACV,CAAC;AACH,CAAC,EAPS,MAAM,KAAN,MAAM,QAOf;AAGD,kBAAe,MAAM,CAAC"}{
  "name": "@postman/runtime.folder",
  "version": "0.1.13",
  "license": "UNLICENSED",
  "description": "The Postman ItemType: 'folder'",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/item-types/folder#readme",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "dependencies": {
    "json-schema-to-ts": "~2.7.2"
  },
  "peerDependencies": {
    "@postman/runtime.core": "^0.4.0",
    "@postman/runtime.documentation": "^0.1.13"
  },
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest"
  }
}# ItemType: `folder`

This package defines the Postman ItemType: `folder`.
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": []
	},
	"references": [
		{ "path": "../../core/core" },
		{ "path": "../../extensions/documentation" }
	]
}
/// <reference path="../src/types.d.ts" />
/// <reference types="node" />
/// <reference types="node/tls" />
import * as tls from 'tls';
import * as grpc from '@postman/grpc-js';
import { Invocation } from './invocation';
export interface ClientOptions {
    url: string;
    descriptor: unknown;
    includeDefaultFields?: boolean;
    channelOptions?: ChannelOptions;
    callOptions?: CallOptions;
    tlsOptions?: TLSOptions;
    proxy?: string;
}
export interface TLSOptions {
    rejectUnauthorized?: boolean;
    secureContext?: tls.SecureContext | tls.SecureContextOptions;
}
export interface InvokeOptions {
    metadata?: Metadata;
    message?: string;
    callOptions?: CallOptions;
}
export type Metadata = ReadonlyArray<Readonly<[string, string | Uint8Array]>>;
export type ChannelOptions = grpc.ChannelOptions;
export type CallOptions = {
    connectionTimeout?: number;
} | {
    deadline?: grpc.Deadline;
};
export declare class Client {
    private readonly methods;
    constructor(options: ClientOptions);
    invoke(method: string, options?: InvokeOptions): Invocation;
}
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const grpc = __importStar(require("@postman/grpc-js"));
const ProtoLoader = __importStar(require("@postman/proto-loader"));
const get_1 = __importDefault(require("lodash/get"));
const json_bigint_string_1 = __importDefault(require("json-bigint-string"));
const runtime_grpc_utils_1 = require("@postman/runtime.grpc-utils");
const runtime_grpc_utils_2 = require("@postman/runtime.grpc-utils");
const utilities_1 = require("./utilities");
const metadata_1 = require("./metadata");
const invocation_1 = require("./invocation");
/*
    A Client is instantiated from a Protobuf descriptor, and is capable
    of invoking all methods defined within the descriptor.
*/
class Client {
    constructor(options) {
        const parsedURL = (0, runtime_grpc_utils_2.parseURL)(options.url);
        const jsonDescriptor = (0, runtime_grpc_utils_2.toJSONDescriptor)(options.descriptor);
        const definition = new runtime_grpc_utils_1.Definition(jsonDescriptor);
        // These options are used to instantiate each Service.
        const clientOptions = (0, utilities_1.getClientOptions)(parsedURL, options.channelOptions);
        const channelCredentials = (0, utilities_1.getChannelCredentials)(Boolean(parsedURL.isTLS || options.tlsOptions), options.tlsOptions || {});
        if (options.proxy) {
            (0, utilities_1.setupProxy)(options.proxy);
        }
        const hierarchy = grpc.loadPackageDefinition(ProtoLoader.fromJSON(jsonDescriptor, {
            ...PROTOBUF_OPTIONS,
            defaults: Boolean(options.includeDefaultFields),
        }));
        // Extract each method, instantiating each Service in the process.
        const methods = new Map();
        const services = new Map();
        for (const [methodPath, methodDefinition] of definition.methods) {
            const keyPath = methodPath.split('.');
            const methodName = keyPath.pop() || '';
            const servicePath = keyPath.join('.');
            let service = services.get(servicePath);
            if (!service) {
                const Service = (0, get_1.default)(hierarchy, keyPath);
                if (typeof Service !== 'function' ||
                    typeof Service.serviceName !== 'string') {
                    throw new TypeError(`Failed to find gRPC service: "${servicePath}"`);
                }
                service = new Service(parsedURL.host, channelCredentials, clientOptions);
                services.set(servicePath, service);
            }
            const fn = service[methodName];
            if (typeof fn !== 'function') {
                throw new TypeError(`Failed to find gRPC method: "${methodPath}"`);
            }
            methods.set(methodPath, { def: methodDefinition, fn: fn.bind(service) });
        }
        this.methods = methods;
    }
    invoke(method, options = {}) {
        const methodInfo = this.methods.get(method);
        if (!methodInfo) {
            throw new Error(`Method "${method}" does not exist`);
        }
        let message;
        if (options.message != null) {
            if (!methodInfo.def.requestType.validate(options.message)) {
                throw new Error('Message violates its Protobuf type definition');
            }
            message = Object.setPrototypeOf(json_bigint_string_1.default.parse(options.message), null);
        }
        return new invocation_1.Invocation(methodInfo.def, methodInfo.fn, (0, metadata_1.wrapMetadata)(options.metadata || []), (0, utilities_1.getCallOptions)(options.callOptions || {}), message);
    }
}
exports.Client = Client;
const PROTOBUF_OPTIONS = {
    keepCase: true,
    alternateCommentMode: true,
    json: true,
    enums: String,
    bytes: String,
    longs: String,
};
//# sourceMappingURL=client.js.map{"version":3,"file":"client.js","sourceRoot":"","sources":["../src/client.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,uDAAyC;AACzC,mEAAqD;AACrD,qDAAmC;AACnC,4EAA4C;AAC5C,oEAAiE;AACjE,oEAAyE;AACzE,2CAKqB;AACrB,yCAA0C;AAC1C,6CAA0C;AAmC1C;;;EAGE;AAEF,MAAa,MAAM;IAGlB,YAAY,OAAsB;QACjC,MAAM,SAAS,GAAG,IAAA,6BAAQ,EAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACxC,MAAM,cAAc,GAAG,IAAA,qCAAgB,EAAC,OAAO,CAAC,UAAU,CAAC,CAAC;QAC5D,MAAM,UAAU,GAAG,IAAI,+BAAU,CAAC,cAAc,CAAC,CAAC;QAElD,sDAAsD;QACtD,MAAM,aAAa,GAAG,IAAA,4BAAgB,EAAC,SAAS,EAAE,OAAO,CAAC,cAAc,CAAC,CAAC;QAC1E,MAAM,kBAAkB,GAAG,IAAA,iCAAqB,EAC/C,OAAO,CAAC,SAAS,CAAC,KAAK,IAAI,OAAO,CAAC,UAAU,CAAC,EAC9C,OAAO,CAAC,UAAU,IAAI,EAAE,CACxB,CAAC;QAEF,IAAI,OAAO,CAAC,KAAK,EAAE,CAAC;YACnB,IAAA,sBAAU,EAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAC3B,CAAC;QAED,MAAM,SAAS,GAAG,IAAI,CAAC,qBAAqB,CAC3C,WAAW,CAAC,QAAQ,CAAC,cAAc,EAAE;YACpC,GAAG,gBAAgB;YACnB,QAAQ,EAAE,OAAO,CAAC,OAAO,CAAC,oBAAoB,CAAC;SAC/C,CAAC,CACF,CAAC;QAEF,kEAAkE;QAClE,MAAM,OAAO,GAA4B,IAAI,GAAG,EAAE,CAAC;QACnD,MAAM,QAAQ,GAAyB,IAAI,GAAG,EAAE,CAAC;QACjD,KAAK,MAAM,CAAC,UAAU,EAAE,gBAAgB,CAAC,IAAI,UAAU,CAAC,OAAO,EAAE,CAAC;YACjE,MAAM,OAAO,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YACtC,MAAM,UAAU,GAAG,OAAO,CAAC,GAAG,EAAE,IAAI,EAAE,CAAC;YACvC,MAAM,WAAW,GAAG,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YAEtC,IAAI,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;YACxC,IAAI,CAAC,OAAO,EAAE,CAAC;gBACd,MAAM,OAAO,GAAG,IAAA,aAAS,EAAC,SAAS,EAAE,OAAO,CAAC,CAAC;gBAE9C,IACC,OAAO,OAAO,KAAK,UAAU;oBAC7B,OAAO,OAAO,CAAC,WAAW,KAAK,QAAQ,EACtC,CAAC;oBACF,MAAM,IAAI,SAAS,CAAC,iCAAiC,WAAW,GAAG,CAAC,CAAC;gBACtE,CAAC;gBAED,OAAO,GAAG,IAAK,OAAyC,CACvD,SAAS,CAAC,IAAI,EACd,kBAAkB,EAClB,aAAa,CACb,CAAC;gBAEF,QAAQ,CAAC,GAAG,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;YACpC,CAAC;YAED,MAAM,EAAE,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;YAC/B,IAAI,OAAO,EAAE,KAAK,UAAU,EAAE,CAAC;gBAC9B,MAAM,IAAI,SAAS,CAAC,gCAAgC,UAAU,GAAG,CAAC,CAAC;YACpE,CAAC;YAED,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,EAAE,GAAG,EAAE,gBAAgB,EAAE,EAAE,EAAE,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;QAC1E,CAAC;QAED,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACxB,CAAC;IAED,MAAM,CAAC,MAAc,EAAE,UAAyB,EAAE;QACjD,MAAM,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAC5C,IAAI,CAAC,UAAU,EAAE,CAAC;YACjB,MAAM,IAAI,KAAK,CAAC,WAAW,MAAM,kBAAkB,CAAC,CAAC;QACtD,CAAC;QAED,IAAI,OAAY,CAAC;QACjB,IAAI,OAAO,CAAC,OAAO,IAAI,IAAI,EAAE,CAAC;YAC7B,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,WAAW,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC;gBAC3D,MAAM,IAAI,KAAK,CAAC,+CAA+C,CAAC,CAAC;YAClE,CAAC;YACD,OAAO,GAAG,MAAM,CAAC,cAAc,CAAC,4BAAU,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC,CAAC;QAC1E,CAAC;QAED,OAAO,IAAI,uBAAU,CACpB,UAAU,CAAC,GAAG,EACd,UAAU,CAAC,EAAE,EACb,IAAA,uBAAY,EAAC,OAAO,CAAC,QAAQ,IAAI,EAAE,CAAC,EACpC,IAAA,0BAAc,EAAC,OAAO,CAAC,WAAW,IAAI,EAAE,CAAC,EACzC,OAAO,CACP,CAAC;IACH,CAAC;CACD;AAvFD,wBAuFC;AAED,MAAM,gBAAgB,GAAG;IACxB,QAAQ,EAAE,IAAI;IACd,oBAAoB,EAAE,IAAI;IAC1B,IAAI,EAAE,IAAI;IACV,KAAK,EAAE,MAAM;IACb,KAAK,EAAE,MAAM;IACb,KAAK,EAAE,MAAM;CACb,CAAC"}import { ClientOptions, InvokeOptions } from './client';
import { Invocation } from './invocation';
export * from './invocation';
export * from './client';
export interface ShorthandInvokeOptions extends ClientOptions, InvokeOptions {
    method: string;
}
export declare function invoke(options: ShorthandInvokeOptions): Invocation;
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.invoke = void 0;
const client_1 = require("./client");
__exportStar(require("./invocation"), exports);
__exportStar(require("./client"), exports);
function invoke(options) {
    return new client_1.Client(options).invoke(options.method, options);
}
exports.invoke = invoke;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,qCAAgE;AAEhE,+CAA6B;AAC7B,2CAAyB;AAMzB,SAAgB,MAAM,CAAC,OAA+B;IACrD,OAAO,IAAI,eAAM,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AAC5D,CAAC;AAFD,wBAEC"}/// <reference types="node" />
import { EventEmitter } from 'events';
import { Method, MethodKind } from '@postman/runtime.grpc-utils';
import * as grpc from '@postman/grpc-js';
import { Metadata } from './client';
export declare class Invocation extends EventEmitter {
    readonly kind: MethodKind;
    private readonly validate;
    private readonly call;
    private readonly timer;
    constructor(method: Method, fn: Function, metadata: grpc.Metadata, callOptions: grpc.CallOptions, message: any);
    write(json: string): void;
    end(): void;
    cancel(): void;
}
export interface Invocation {
    on(eventName: 'response', listener: (this: Invocation, response: any) => void): this;
    once(eventName: 'response', listener: (this: Invocation, response: any) => void): this;
    addListener(eventName: 'response', listener: (this: Invocation, response: any) => void): this;
    emit(eventName: 'response', response: any): boolean;
    on(eventName: 'metadata', listener: (this: Invocation, metadata: Metadata) => void): this;
    once(eventName: 'metadata', listener: (this: Invocation, metadata: Metadata) => void): this;
    addListener(eventName: 'metadata', listener: (this: Invocation, metadata: Metadata) => void): this;
    emit(eventName: 'metadata', metadata: Metadata): boolean;
    on(eventName: 'status', listener: (this: Invocation, status: Status) => void): this;
    once(eventName: 'status', listener: (this: Invocation, status: Status) => void): this;
    addListener(eventName: 'status', listener: (this: Invocation, status: Status) => void): this;
    emit(eventName: 'status', status: Status): boolean;
    on(eventName: 'error', listener: (this: Invocation, error: unknown) => void): this;
    once(eventName: 'error', listener: (this: Invocation, error: unknown) => void): this;
    addListener(eventName: 'error', listener: (this: Invocation, error: unknown) => void): this;
    emit(eventName: 'error', error: unknown): boolean;
}
export interface Status {
    code: number;
    message: string;
    metadata: Metadata;
    timings: {
        total: number;
    };
}
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Invocation = void 0;
const events_1 = require("events");
const json_bigint_string_1 = __importDefault(require("json-bigint-string"));
const metadata_1 = require("./metadata");
const response_timer_1 = __importDefault(require("./response-timer"));
/*
    Invocation represents an in-flight GRPC method call. It will typically emit
    one "metadata" event (headers), one "status" events (with trailers), and
    either one or N "response" events, depending on the kind of method.

    For "client-stream" and "bidi" methods, you are expected to eventually call
    "end()", after sending some number of messages via "write()".
*/
class Invocation extends events_1.EventEmitter {
    constructor(method, fn, metadata, callOptions, message) {
        super();
        this.kind = method.kind;
        this.validate = method.requestType.validate.bind(method.requestType);
        this.timer = new response_timer_1.default();
        const callback = (err, response) => {
            if (err != null)
                err.metadata || this.emit('error', err);
            else
                this.emit('response', response);
        };
        switch (this.kind) {
            case 'unary':
                if (message === undefined) {
                    throw new TypeError('A message is required for unary methods');
                }
                this.call = fn(message, metadata, callOptions, callback);
                break;
            case 'client-stream':
                this.call = fn(metadata, callOptions, callback);
                if (message !== undefined) {
                    this.call.write(message);
                }
                break;
            case 'server-stream':
                if (message === undefined) {
                    throw new TypeError('A message is required for server-streaming');
                }
                this.call = fn(message, metadata, callOptions);
                break;
            case 'bidi':
                this.call = fn(metadata, callOptions);
                if (message !== undefined) {
                    this.call.write(message);
                }
                break;
        }
        this.timer.begin();
        this.call
            .on('metadata', (metadata) => {
            this.emit('metadata', (0, metadata_1.unwrapMetadata)(metadata));
        })
            .on('status', (status) => {
            this.emit('status', {
                code: status.code,
                message: status.details,
                metadata: (0, metadata_1.unwrapMetadata)(status.metadata),
                timings: { total: this.timer.resolve() },
            });
        })
            .on('data', (response) => {
            this.emit('response', response);
        })
            .on('error', (err) => {
            this.timer.end();
            if (!err.metadata) {
                this.emit('error', err);
            }
        });
    }
    write(json) {
        if (this.kind !== 'client-stream' && this.kind !== 'bidi') {
            throw new TypeError('Cannot stream messages in this type of method');
        }
        if (!this.validate(json)) {
            throw new Error('Message violates its Protobuf type definition');
        }
        const call = this.call;
        if (call.writable) {
            call.write(Object.setPrototypeOf(json_bigint_string_1.default.parse(json), null));
        }
    }
    end() {
        if (this.kind !== 'client-stream' && this.kind !== 'bidi') {
            throw new TypeError('Cannot stream messages in this type of method');
        }
        const call = this.call;
        if (call.writable) {
            call.end();
        }
    }
    cancel() {
        this.call.cancel();
    }
}
exports.Invocation = Invocation;
//# sourceMappingURL=invocation.js.map{"version":3,"file":"invocation.js","sourceRoot":"","sources":["../src/invocation.ts"],"names":[],"mappings":"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"}import * as grpc from '@postman/grpc-js';
import { Metadata } from './client';
export declare function wrapMetadata(rawMetadata: Metadata): grpc.Metadata;
export declare function unwrapMetadata(grpcMetadata: grpc.Metadata): Metadata;
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unwrapMetadata = exports.wrapMetadata = void 0;
const grpc = __importStar(require("@postman/grpc-js"));
/*
    Converts between raw metadata pairs and grpc.Metadata.
*/
function wrapMetadata(rawMetadata) {
    const grpcMetadata = new grpc.Metadata();
    for (const [key, value] of rawMetadata) {
        let result;
        if (key.toLowerCase().endsWith('-bin')) {
            if (!(value instanceof Uint8Array)) {
                throw new TypeError('Metadata ending in "-bin" must be a Uint8Array');
            }
            result = Buffer.from(value.buffer, value.byteOffset, value.byteLength);
        }
        else {
            if (typeof value !== 'string') {
                throw new TypeError('Metadata must be a string');
            }
            result = value;
        }
        grpcMetadata.add(key, result);
    }
    return grpcMetadata;
}
exports.wrapMetadata = wrapMetadata;
function unwrapMetadata(grpcMetadata) {
    const rawMetadata = [];
    for (const [key, values] of Object.entries(grpcMetadata.toJSON())) {
        for (const value of values) {
            rawMetadata.push([key, value]);
        }
    }
    return rawMetadata;
}
exports.unwrapMetadata = unwrapMetadata;
//# sourceMappingURL=metadata.js.map{"version":3,"file":"metadata.js","sourceRoot":"","sources":["../src/metadata.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,uDAAyC;AAGzC;;EAEE;AAEF,SAAgB,YAAY,CAAC,WAAqB;IACjD,MAAM,YAAY,GAAG,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;IAEzC,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,WAAW,EAAE,CAAC;QACxC,IAAI,MAAuB,CAAC;QAE5B,IAAI,GAAG,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC;YACxC,IAAI,CAAC,CAAC,KAAK,YAAY,UAAU,CAAC,EAAE,CAAC;gBACpC,MAAM,IAAI,SAAS,CAAC,gDAAgD,CAAC,CAAC;YACvE,CAAC;YACD,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,UAAU,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;QACxE,CAAC;aAAM,CAAC;YACP,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;gBAC/B,MAAM,IAAI,SAAS,CAAC,2BAA2B,CAAC,CAAC;YAClD,CAAC;YACD,MAAM,GAAG,KAAK,CAAC;QAChB,CAAC;QAED,YAAY,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;IAC/B,CAAC;IAED,OAAO,YAAY,CAAC;AACrB,CAAC;AAtBD,oCAsBC;AAED,SAAgB,cAAc,CAAC,YAA2B;IACzD,MAAM,WAAW,GAAoC,EAAE,CAAC;IAExD,KAAK,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC;QACnE,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;YAC5B,WAAW,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC;QAChC,CAAC;IACF,CAAC;IAED,OAAO,WAAW,CAAC;AACpB,CAAC;AAVD,wCAUC"}export default class ResponseTimer {
    private startTime;
    private endTime;
    begin(): void;
    end(): void;
    resolve(): number;
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_perf_hooks_1 = require("node:perf_hooks");
class ResponseTimer {
    begin() {
        this.startTime = node_perf_hooks_1.performance.now();
    }
    end() {
        this.endTime = node_perf_hooks_1.performance.now();
    }
    resolve() {
        if (this.startTime === undefined) {
            throw new Error('Timer has not been started');
        }
        if (this.endTime === undefined) {
            this.end();
        }
        const total = this.endTime - this.startTime;
        this.startTime = undefined;
        this.startTime = undefined;
        return total;
    }
}
exports.default = ResponseTimer;
//# sourceMappingURL=response-timer.js.map{"version":3,"file":"response-timer.js","sourceRoot":"","sources":["../src/response-timer.ts"],"names":[],"mappings":";;AAAA,qDAA8C;AAE9C,MAAqB,aAAa;IAIjC,KAAK;QACJ,IAAI,CAAC,SAAS,GAAG,6BAAW,CAAC,GAAG,EAAE,CAAC;IACpC,CAAC;IAED,GAAG;QACF,IAAI,CAAC,OAAO,GAAG,6BAAW,CAAC,GAAG,EAAE,CAAC;IAClC,CAAC;IAED,OAAO;QACN,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,EAAE,CAAC;YAClC,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;QAC/C,CAAC;QAED,IAAI,IAAI,CAAC,OAAO,KAAK,SAAS,EAAE,CAAC;YAChC,IAAI,CAAC,GAAG,EAAE,CAAC;QACZ,CAAC;QAED,MAAM,KAAK,GAAG,IAAI,CAAC,OAAQ,GAAG,IAAI,CAAC,SAAS,CAAC;QAC7C,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAE3B,OAAO,KAAK,CAAC;IACd,CAAC;CACD;AA3BD,gCA2BC"}import * as grpc from '@postman/grpc-js';
import { ParsedURL } from '@postman/runtime.grpc-utils';
import { TLSOptions, CallOptions } from './client';
export declare function getChannelCredentials(isTLS: boolean, { rejectUnauthorized, secureContext }: TLSOptions): grpc.ChannelCredentials;
export declare function getClientOptions(parsedURL: ParsedURL, settings: grpc.ChannelOptions | null | undefined): grpc.ClientOptions;
export declare function getCallOptions(options: CallOptions): grpc.CallOptions;
/**
 * Setup proxy by setting 'grpc_proxy' environment variable.
 * @param url - The URL of the proxy server.
 */
export declare function setupProxy(url: string): void;
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupProxy = exports.getCallOptions = exports.getClientOptions = exports.getChannelCredentials = void 0;
const tls = __importStar(require("tls"));
const grpc = __importStar(require("@postman/grpc-js"));
// Generates customized ChannelCredentials.
function getChannelCredentials(isTLS, { rejectUnauthorized, secureContext }) {
    if (!isTLS) {
        return grpc.credentials.createInsecure();
    }
    if (!(secureContext instanceof tls.SecureContext)) {
        const { ca, ...options } = secureContext || {};
        secureContext = tls.createSecureContext(options);
        if (ca)
            secureContext.context.addCACert(ca);
    }
    const channelCreds = grpc.credentials.createFromSecureContext(secureContext);
    channelCreds.connectionOptions.rejectUnauthorized = !!rejectUnauthorized;
    return channelCreds;
}
exports.getChannelCredentials = getChannelCredentials;
// Generates ClientOptions with support for URL pathnames.
function getClientOptions(parsedURL, settings) {
    return {
        ...settings,
        channelFactoryOverride: (address, credentials, options) => {
            if (parsedURL.pathname && parsedURL.pathname !== '/') {
                return new PathAwareChannel(parsedURL.host, credentials, options, parsedURL.pathname);
            }
            return new grpc.Channel(address, credentials, options);
        },
    };
}
exports.getClientOptions = getClientOptions;
function getCallOptions(options) {
    const callOptions = {};
    if ('deadline' in options) {
        callOptions.deadline = options.deadline;
    }
    else if ('connectionTimeout' in options && options.connectionTimeout) {
        if (typeof options.connectionTimeout !== 'number') {
            throw new TypeError('Invalid connection timeout. Must be a number.');
        }
        callOptions.deadline = Date.now() + options.connectionTimeout;
    }
    return callOptions;
}
exports.getCallOptions = getCallOptions;
/**
 * Setup proxy by setting 'grpc_proxy' environment variable.
 * @param url - The URL of the proxy server.
 */
function setupProxy(url) {
    process.env.grpc_proxy = url;
}
exports.setupProxy = setupProxy;
class PathAwareChannel extends grpc.Channel {
    constructor(target, credentials, options, _prefix) {
        super(target, credentials, options);
        this._prefix = _prefix;
    }
    createCall(method, ...args) {
        return super.createCall(`${this._prefix}${method}`, ...args);
    }
}
//# sourceMappingURL=utilities.js.map{"version":3,"file":"utilities.js","sourceRoot":"","sources":["../src/utilities.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,yCAA2B;AAC3B,uDAAyC;AAIzC,2CAA2C;AAC3C,SAAgB,qBAAqB,CACpC,KAAc,EACd,EAAE,kBAAkB,EAAE,aAAa,EAAc;IAEjD,IAAI,CAAC,KAAK,EAAE,CAAC;QACZ,OAAO,IAAI,CAAC,WAAW,CAAC,cAAc,EAAE,CAAC;IAC1C,CAAC;IAED,IAAI,CAAC,CAAC,aAAa,YAAY,GAAG,CAAC,aAAa,CAAC,EAAE,CAAC;QACnD,MAAM,EAAE,EAAE,EAAE,GAAG,OAAO,EAAE,GAAG,aAAa,IAAI,EAAE,CAAC;QAC/C,aAAa,GAAG,GAAG,CAAC,mBAAmB,CAAC,OAAO,CAAC,CAAC;QACjD,IAAI,EAAE;YAAE,aAAa,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;IAC7C,CAAC;IAED,MAAM,YAAY,GAAG,IAAI,CAAC,WAAW,CAAC,uBAAuB,CAAC,aAAa,CAAC,CAAC;IAC7E,YAAY,CAAC,iBAAiB,CAAC,kBAAkB,GAAG,CAAC,CAAC,kBAAkB,CAAC;IACzE,OAAO,YAAY,CAAC;AACrB,CAAC;AAjBD,sDAiBC;AAED,0DAA0D;AAC1D,SAAgB,gBAAgB,CAC/B,SAAoB,EACpB,QAAgD;IAEhD,OAAO;QACN,GAAG,QAAQ;QACX,sBAAsB,EAAE,CAAC,OAAO,EAAE,WAAW,EAAE,OAAO,EAAE,EAAE;YACzD,IAAI,SAAS,CAAC,QAAQ,IAAI,SAAS,CAAC,QAAQ,KAAK,GAAG,EAAE,CAAC;gBACtD,OAAO,IAAI,gBAAgB,CAC1B,SAAS,CAAC,IAAI,EACd,WAAW,EACX,OAAO,EACP,SAAS,CAAC,QAAQ,CAClB,CAAC;YACH,CAAC;YAED,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,WAAW,EAAE,OAAO,CAAC,CAAC;QACxD,CAAC;KACD,CAAC;AACH,CAAC;AAnBD,4CAmBC;AAED,SAAgB,cAAc,CAAC,OAAoB;IAClD,MAAM,WAAW,GAAqB,EAAE,CAAC;IAEzC,IAAI,UAAU,IAAI,OAAO,EAAE,CAAC;QAC3B,WAAW,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;IACzC,CAAC;SAAM,IAAI,mBAAmB,IAAI,OAAO,IAAI,OAAO,CAAC,iBAAiB,EAAE,CAAC;QACxE,IAAI,OAAO,OAAO,CAAC,iBAAiB,KAAK,QAAQ,EAAE,CAAC;YACnD,MAAM,IAAI,SAAS,CAAC,+CAA+C,CAAC,CAAC;QACtE,CAAC;QAED,WAAW,CAAC,QAAQ,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,OAAO,CAAC,iBAAiB,CAAC;IAC/D,CAAC;IAED,OAAO,WAAW,CAAC;AACpB,CAAC;AAdD,wCAcC;AAED;;;GAGG;AACH,SAAgB,UAAU,CAAC,GAAW;IACrC,OAAO,CAAC,GAAG,CAAC,UAAU,GAAG,GAAG,CAAC;AAC9B,CAAC;AAFD,gCAEC;AAED,MAAM,gBAAiB,SAAQ,IAAI,CAAC,OAAO;IAC1C,YACC,MAAW,EACX,WAAgB,EAChB,OAAY,EACK,OAAe;QAEhC,KAAK,CAAC,MAAM,EAAE,WAAW,EAAE,OAAO,CAAC,CAAC;QAFnB,YAAO,GAAP,OAAO,CAAQ;IAGjC,CAAC;IAEQ,UAAU,CAAC,MAAc,EAAE,GAAG,IAA0B;QAChE,OAAO,KAAK,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,OAAO,GAAG,MAAM,EAAE,EAAE,GAAG,IAAI,CAAC,CAAC;IAC9D,CAAC;CACD"}{
  "name": "@postman/runtime.grpc-client",
  "version": "0.2.5",
  "license": "UNLICENSED",
  "description": "A simple gRPC client for Node.js",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/clients/grpc-client#readme",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "dependencies": {
    "@postman/grpc-js": "^1.11.0-postman.1",
    "@postman/proto-loader": "^0.7.13-postman.3",
    "json-bigint-string": "^1.0.0",
    "lodash": "^4.17.21",
    "@postman/runtime.grpc-utils": "^0.2.3"
  },
  "devDependencies": {
    "@types/lodash": "^4.14.194",
    "@types/node": "^20.0.0"
  },
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest"
  }
}# grpc-client

A simple gRPC client for Node.js
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist"
	},
	"references": [{ "path": "../../utilities/grpc-utils" }]
}
import Schema from '@postman/runtime.schema';
import { SecureContextOptions } from '@postman/runtime.core';
import { Metadata } from './metadata';
export interface GRPCAgent {
    invoke(options: InvokeOptions): GRPCInvocation | Promise<GRPCInvocation>;
    resolveSchema(schema: Schema.Data, options: ResolveOptions): unknown | Promise<unknown>;
}
export interface GRPCInvocation {
    write(json: string): void | Promise<void>;
    end(): void | Promise<void>;
    cancel(): void | Promise<void>;
    on(eventName: 'response', listener: (response: any) => void): this;
    on(eventName: 'metadata', listener: (metadata: Metadata) => void): this;
    on(eventName: 'status', listener: (status: Status) => void): this;
    on(eventName: 'error', listener: (error: unknown) => void): this;
}
export interface Status {
    code: number;
    message: string;
    metadata: Metadata;
    timings: {
        total: number;
    };
}
export interface InvokeOptions {
    url: string;
    descriptor: unknown;
    method: string;
    metadata: Metadata;
    message?: string;
    includeDefaultFields: boolean;
    channelOptions: ChannelOptions;
    callOptions: CallOptions;
    tlsOptions?: TLSOptions;
    proxy?: string;
}
export interface ResolveOptions {
    url: string;
    metadata: Metadata;
    channelOptions: ChannelOptions;
    callOptions: CallOptions;
    tlsOptions?: TLSOptions;
    proxy?: string;
}
export interface ChannelOptions {
    'grpc.ssl_target_name_override'?: string;
    'grpc.primary_user_agent'?: string;
    'grpc.secondary_user_agent'?: string;
    'grpc.default_authority'?: string;
    'grpc.keepalive_time_ms'?: number;
    'grpc.keepalive_timeout_ms'?: number;
    'grpc.keepalive_permit_without_calls'?: number;
    'grpc.service_config'?: string;
    'grpc.max_concurrent_streams'?: number;
    'grpc.initial_reconnect_backoff_ms'?: number;
    'grpc.max_reconnect_backoff_ms'?: number;
    'grpc.use_local_subchannel_pool'?: number;
    'grpc.max_send_message_length'?: number;
    'grpc.max_receive_message_length'?: number;
    'grpc.enable_http_proxy'?: number;
    'grpc.http_connect_target'?: string;
    'grpc.http_connect_creds'?: string;
    'grpc.default_compression_algorithm'?: 0 | 1 | 2;
    'grpc.enable_channelz'?: number;
    'grpc.dns_min_time_between_resolutions_ms'?: number;
    'grpc.enable_retries'?: number;
    'grpc.per_rpc_retry_buffer_size'?: number;
    'grpc.retry_buffer_size'?: number;
    'grpc.max_connection_age_ms'?: number;
    'grpc.max_connection_age_grace_ms'?: number;
    'grpc-node.max_session_memory'?: number;
    'grpc.service_config_disable_resolution'?: number;
    'grpc.client_idle_timeout_ms'?: number;
}
export type CallOptions = {
    connectionTimeout?: number;
};
export interface TLSOptions {
    rejectUnauthorized?: boolean;
    secureContext?: SecureContextOptions;
}
export type { SecureContextOptions };
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=agent.js.map{"version":3,"file":"agent.js","sourceRoot":"","sources":["../src/agent.ts"],"names":[],"mappings":""}import { FromSchema } from 'json-schema-to-ts';
import { Event } from '@postman/runtime.core';
declare const definition: {
    'sent-request-header': {
        schema: {
            readonly type: "object";
            readonly required: ["metadata", "isRequestStreamed", "isResponseStreamed"];
            readonly properties: {
                readonly metadata: {
                    readonly type: "array";
                    readonly items: {
                        readonly type: "object";
                        readonly required: ["key", "value"];
                        readonly properties: {
                            readonly key: {
                                readonly type: "string";
                            };
                            readonly value: {
                                readonly type: "string";
                            };
                        };
                        readonly additionalProperties: false;
                    };
                };
                readonly isRequestStreamed: {
                    readonly type: "boolean";
                };
                readonly isResponseStreamed: {
                    readonly type: "boolean";
                };
            };
            readonly additionalProperties: false;
        };
    };
    'received-response-header': {
        schema: {
            readonly type: "object";
            readonly required: ["metadata"];
            readonly properties: {
                readonly metadata: {
                    readonly type: "array";
                    readonly items: {
                        readonly type: "object";
                        readonly required: ["key", "value"];
                        readonly properties: {
                            readonly key: {
                                readonly type: "string";
                            };
                            readonly value: {
                                readonly type: "string";
                            };
                        };
                        readonly additionalProperties: false;
                    };
                };
            };
            readonly additionalProperties: false;
        };
    };
    'sent-request-data': {
        schema: {
            readonly type: "object";
            readonly required: ["data"];
            readonly properties: {
                readonly data: {
                    readonly type: "object";
                };
            };
            readonly additionalProperties: false;
        };
    };
    'received-response-data': {
        schema: {
            readonly type: "object";
            readonly required: ["data"];
            readonly properties: {
                readonly data: {
                    readonly type: "object";
                };
            };
            readonly additionalProperties: false;
        };
    };
    status: {
        schema: {
            readonly type: "object";
            readonly required: ["statusCode", "statusMessage", "metadata"];
            readonly properties: {
                readonly statusCode: {
                    readonly type: "integer";
                    readonly minimum: 0;
                };
                readonly statusMessage: {
                    readonly type: "string";
                };
                readonly metadata: {
                    readonly type: "array";
                    readonly items: {
                        readonly type: "object";
                        readonly required: ["key", "value"];
                        readonly properties: {
                            readonly key: {
                                readonly type: "string";
                            };
                            readonly value: {
                                readonly type: "string";
                            };
                        };
                        readonly additionalProperties: false;
                    };
                };
                readonly timings: {
                    readonly type: "object";
                    readonly required: ["total"];
                    readonly properties: {
                        readonly total: {
                            readonly type: "number";
                            readonly minimum: 0;
                        };
                    };
                    readonly additionalProperties: false;
                };
            };
            readonly additionalProperties: false;
        };
    };
    'internal:error': {
        schema: {
            type: "object";
            required: ["message"];
            properties: {
                message: {
                    type: "string";
                };
            };
        };
    };
    'internal:transient-error': {
        schema: {
            type: "object";
            required: ["message"];
            properties: {
                message: {
                    type: "string";
                };
            };
        };
    };
};
export type SentRequestHeader = Event<'sent-request-header', FromSchema<(typeof definition)['sent-request-header']['schema']>>;
export type ReceivedResponseHeader = Event<'received-response-header', FromSchema<(typeof definition)['received-response-header']['schema']>>;
export type SentRequestData = Event<'sent-request-data', FromSchema<(typeof definition)['sent-request-data']['schema']>>;
export type ReceivedResponseData = Event<'received-response-data', FromSchema<(typeof definition)['received-response-data']['schema']>>;
export type Status = Event<'status', FromSchema<(typeof definition)['status']['schema']>>;
export type InternalError = Event<'internal:error', FromSchema<(typeof definition)['internal:error']['schema']>>;
export type InternalTransientError = Event<'internal:transient-error', FromSchema<(typeof definition)['internal:transient-error']['schema']>>;
export type Write = Event<'write', {
    json: string;
}>;
export type End = Event<'end'>;
export type Cancel = Event<'cancel'>;
export {};
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const json_schema_to_ts_1 = require("json-schema-to-ts");
// TODO: this JSON schema is not currently being used at runtime
const definition = (0, json_schema_to_ts_1.asConst)({
    'sent-request-header': {
        schema: {
            type: 'object',
            required: ['metadata', 'isRequestStreamed', 'isResponseStreamed'],
            properties: {
                metadata: {
                    type: 'array',
                    items: {
                        type: 'object',
                        required: ['key', 'value'],
                        properties: {
                            key: {
                                type: 'string',
                            },
                            value: {
                                type: 'string',
                            },
                        },
                        additionalProperties: false,
                    },
                },
                isRequestStreamed: {
                    type: 'boolean',
                },
                isResponseStreamed: {
                    type: 'boolean',
                },
            },
            additionalProperties: false,
        },
    },
    'received-response-header': {
        schema: {
            type: 'object',
            required: ['metadata'],
            properties: {
                metadata: {
                    type: 'array',
                    items: {
                        type: 'object',
                        required: ['key', 'value'],
                        properties: {
                            key: {
                                type: 'string',
                            },
                            value: {
                                type: 'string',
                            },
                        },
                        additionalProperties: false,
                    },
                },
            },
            additionalProperties: false,
        },
    },
    'sent-request-data': {
        schema: {
            type: 'object',
            required: ['data'],
            properties: {
                data: {
                    type: 'object',
                },
            },
            additionalProperties: false,
        },
    },
    'received-response-data': {
        schema: {
            type: 'object',
            required: ['data'],
            properties: {
                data: {
                    type: 'object',
                },
            },
            additionalProperties: false,
        },
    },
    status: {
        schema: {
            type: 'object',
            required: ['statusCode', 'statusMessage', 'metadata'],
            properties: {
                statusCode: {
                    type: 'integer',
                    minimum: 0,
                },
                statusMessage: {
                    type: 'string',
                },
                metadata: {
                    type: 'array',
                    items: {
                        type: 'object',
                        required: ['key', 'value'],
                        properties: {
                            key: {
                                type: 'string',
                            },
                            value: {
                                type: 'string',
                            },
                        },
                        additionalProperties: false,
                    },
                },
                timings: {
                    type: 'object',
                    required: ['total'],
                    properties: {
                        total: {
                            type: 'number',
                            minimum: 0,
                        },
                    },
                    additionalProperties: false,
                },
            },
            additionalProperties: false,
        },
    },
    'internal:error': {
        schema: {
            type: 'object',
            required: ['message'],
            properties: {
                message: {
                    type: 'string',
                },
            },
        },
    },
    'internal:transient-error': {
        schema: {
            type: 'object',
            required: ['message'],
            properties: {
                message: {
                    type: 'string',
                },
            },
        },
    },
});
//# sourceMappingURL=events.js.map{"version":3,"file":"events.js","sourceRoot":"","sources":["../src/events.ts"],"names":[],"mappings":"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"}import { Item } from '@postman/runtime.core';
declare const config: {
    supportedAuthTypes: ("basic" | "bearer" | "apikey" | "noauth")[];
    http: {
        setHeader(item: Item, name: string, value: string | undefined): void;
    };
};
export default config;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const config = {
    supportedAuthTypes: ['noauth', 'basic', 'bearer', 'apikey'],
    http: {
        setHeader(item, name, value) {
            const { payload } = item;
            payload.metadata = payload.metadata.filter((x) => x.key !== name);
            if (value !== undefined) {
                payload.metadata.push({ key: name, value });
            }
        },
    },
};
exports.default = config;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/extensions/auth/index.ts"],"names":[],"mappings":";;AAIA,MAAM,MAAM,GAAG;IACd,kBAAkB,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,QAAQ,EAAE,QAAQ,CAAC;IAC3D,IAAI,EAAE;QACL,SAAS,CAAC,IAAU,EAAE,IAAY,EAAE,KAAyB;YAC5D,MAAM,EAAE,OAAO,EAAE,GAAG,IAAgC,CAAC;YACrD,OAAO,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,GAAG,KAAK,IAAI,CAAC,CAAC;YAClE,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;gBACzB,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC;YAC7C,CAAC;QACF,CAAC;KACD;CACqB,CAAC;AAExB,kBAAe,MAAM,CAAC"}import { Item, Event } from '@postman/runtime.core';
import Auth from '@postman/runtime.auth';
declare const _default: (prevContext: Partial<{
    request: Partial<{
        id: string;
        name: string;
        url: string;
        auth: Auth.Data;
        metadata: {
            key: string;
            value: string;
        }[];
        methodPath: string;
        messages: {
            data: Record<string, any>;
            timestamp?: string;
        }[];
    }>;
    response: Partial<{
        responseTime: number;
        statusCode: number;
        metadata: {
            key: string;
            value: string;
        }[];
        trailers: {
            key: string;
            value: string;
        }[];
        messages: {
            data: Record<string, any>;
            timestamp: string;
        }[];
    }>;
}> | undefined, item: Item, event?: Event) => {
    request: {
        id?: string | undefined;
        name?: string | undefined;
        url?: string | undefined;
        auth?: {
            awsv4?: {
                key: string;
                value: unknown;
            }[] | undefined;
            basic?: {
                key: string;
                value: unknown;
            }[] | undefined;
            bearer?: {
                key: string;
                value: unknown;
            }[] | undefined;
            hawk?: {
                key: string;
                value: unknown;
            }[] | undefined;
            oauth1?: {
                key: string;
                value: unknown;
            }[] | undefined;
            oauth2?: {
                key: string;
                value: unknown;
            }[] | undefined;
            apikey?: {
                key: string;
                value: unknown;
            }[] | undefined;
            edgegrid?: {
                key: string;
                value: unknown;
            }[] | undefined;
            type: "awsv4" | "basic" | "bearer" | "hawk" | "oauth1" | "oauth2" | "apikey" | "edgegrid" | "noauth";
        } | undefined;
        metadata?: {
            key: string;
            value: string;
        }[] | undefined;
        methodPath?: string | undefined;
        messages?: {
            data: Record<string, any>;
            timestamp?: string;
        }[] | undefined;
    };
    response: {
        responseTime?: number | undefined;
        statusCode?: number | undefined;
        metadata?: {
            key: string;
            value: string;
        }[] | undefined;
        trailers?: {
            key: string;
            value: string;
        }[] | undefined;
        messages?: {
            data: Record<string, any>;
            timestamp: string;
        }[] | undefined;
    };
};
export default _default;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const runtime_grpc_utils_1 = require("@postman/runtime.grpc-utils");
exports.default = (prevContext = {}, item, event) => {
    const { payload, extensions } = item;
    const receivedEvent = event;
    const itemContext = {
        request: { ...prevContext.request },
        response: { ...prevContext.response },
    };
    if (prevContext.request === undefined) {
        const definition = new runtime_grpc_utils_1.Definition(payload.methodDescriptor);
        const methodKind = definition.methods.get(payload.methodPath)?.kind;
        itemContext.request = {
            id: item.id,
            name: item.title,
            url: payload.url,
            auth: extensions.auth,
            metadata: payload.metadata,
            methodPath: payload.methodPath,
            messages: methodKind === 'unary' || methodKind === 'server-stream' ?
                [{ data: payload.message }]
                : [],
        };
    }
    switch (receivedEvent?.type) {
        case 'sent-request-header':
            itemContext.request = {
                ...prevContext.request,
                // Update request context to have resolved values
                url: payload.url,
                auth: extensions.auth,
                metadata: payload.metadata,
            };
            break;
        case 'sent-request-data':
            const prevMessage = prevContext.request?.messages ?? [];
            itemContext.request.messages = [...prevMessage];
            if (prevMessage.length === 1 && !prevMessage[0].timestamp) {
                itemContext.request.messages = [];
            }
            itemContext.request.messages.push({
                data: receivedEvent.payload.data,
                timestamp: receivedEvent.timestamp,
            });
            break;
        case 'received-response-header':
            itemContext.response.metadata = receivedEvent.payload.metadata;
            break;
        case 'received-response-data':
            itemContext.response.messages = [
                ...(prevContext.response?.messages ?? []),
            ];
            itemContext.response.messages.push({
                data: receivedEvent.payload.data,
                timestamp: receivedEvent.timestamp,
            });
            break;
        case 'status':
            itemContext.response.statusCode = receivedEvent.payload.statusCode;
            itemContext.response.trailers = receivedEvent.payload.metadata;
            const responseTime = receivedEvent.payload.timings?.total;
            itemContext.response.responseTime =
                typeof responseTime === 'number' ? Math.ceil(responseTime) : undefined;
            break;
    }
    return itemContext;
};
//# sourceMappingURL=execution-context.js.map{"version":3,"file":"execution-context.js","sourceRoot":"","sources":["../../../src/extensions/events/execution-context.ts"],"names":[],"mappings":"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"}import Events from '@postman/runtime.events';
declare const config: Events.Config;
export default config;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const sandbox_template_1 = __importDefault(require("./sandbox-template"));
const execution_context_1 = __importDefault(require("./execution-context"));
const config = {
    supportedListeners: {
        onBefore: 'beforeInvoke',
        onEvent: {
            status: 'afterResponse',
        },
    },
    template: sandbox_template_1.default,
    setContext: execution_context_1.default,
};
exports.default = config;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/extensions/events/index.ts"],"names":[],"mappings":";;;;;AACA,0EAA0C;AAC1C,4EAAsD;AAEtD,MAAM,MAAM,GAAkB;IAC7B,kBAAkB,EAAE;QACnB,QAAQ,EAAE,cAAc;QACxB,OAAO,EAAE;YACR,MAAM,EAAE,eAAe;SACvB;KACD;IACD,QAAQ,EAAR,0BAAQ;IACR,UAAU,EAAE,2BAAmB;CAC/B,CAAC;AAEF,kBAAe,MAAM,CAAC"}declare const template = "\n\tconst Ajv = require('ajv');\n\tconst chai = require('chai');\n\tconst _ = require('lodash');\n\tconst { Property, PropertyList, RequestAuth, Url } = require('postman-collection');\n\n\tclass Metadata extends Property {\n\t\tconstructor (options = {}) {\n\t\t\tsuper(options);\n\n\t\t\tthis.key = options.key;\n\t\t\tthis.value = options.value;\n\t\t\tthis.disabled = options.disabled;\n\t\t}\n\n\t\ttoString () {\n\t\t\treturn this.key + ': ' + this.value;\n\t\t}\n\n\t\tvalueOf () {\n\t\t\treturn this.value;\n\t\t}\n\n\t\tstatic _postman_propertyIndexKey = 'key';\n\t\tstatic _postman_propertyIndexCaseInsensitive = true;\n\t\tstatic _postman_propertyAllowsMultipleValues = true;\n\n\t\tstatic parse (metadataString) {\n\t\t\tconst metadata = [],\n\t\t\t\tregexes = {\n\t\t\t\t\tmetadata: /^(\\S+):(.*)$/gm,\n\t\t\t\t\tfold: /\\r\\n([ \\t])/g,\n\t\t\t\t\ttrim: /^\\s*(.*\\S)?\\s*$/\n\t\t\t\t};\n\t\t\tlet match = regexes.metadata.exec(metadataString);\n\n\t\t\tmetadataString = metadataString.toString().replace(regexes.fold, '$1');\n\n\t\t\twhile (match) {\n\t\t\t\tmetadata.push({\n\t\t\t\t\tkey: match[1],\n\t\t\t\t\tvalue: match[2].replace(regexes.trim, '$1')\n\t\t\t\t});\n\t\t\t\tmatch = regexes.metadata.exec(metadataString);\n\t\t\t}\n\n\t\t\treturn metadata;\n\t\t}\n\n\t\tstatic parseSingle (metadata) {\n\t\t\tif (!_.isString(metadata)) { return { key: '', value: '' }; }\n\n\t\t\tlet index = metadata.indexOf(':');\n\t\t\t(index < 0) && (index = metadata.length);\n\n\t\t\tconst key = metadata.substr(0, index),\n\t\t\t\tvalue = metadata.substr(index + 1);\n\n\t\t\treturn {\n\t\t\t\tkey: _.trim(key),\n\t\t\t\tvalue: _.trim(value)\n\t\t\t};\n\t\t}\n\n\t\tstatic unparse (metadata, separator = '\\r\\n') {\n\t\t\tif (!_.isArray(metadata) && !PropertyList.isPropertyList(metadata)) {\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\treturn metadata.reduce((acc, m) => {\n\t\t\t\tif (m && !m.disabled) {\n\t\t\t\t\tacc += Metadata.unparseSingle(m) + separator;\n\t\t\t\t}\n\n\t\t\t\treturn acc;\n\t\t\t}, '');\n\t\t}\n\n\t\tstatic unparseSingle (metadata) {\n\t\t\tif (!_.isObject(metadata)) { return ''; }\n\n\t\t\treturn metadata.key + ': ' + metadata.value;\n\t\t}\n\t}\n\n\tclass Message extends Property {\n\t\tconstructor(options = {}) {\n\t\t\tsuper(options);\n\n\t\t\tthis.data = options.data;\n\n\t\t\tif (!_.isNil(options.timestamp)) {\n\t\t\t\tthis.timestamp = new Date(options.timestamp);\n\t\t\t}\n\t\t}\n\n\t\ttoString () {\n\t\t\treturn JSON.stringify(this.data);\n\t\t}\n\n\t\tvalueOf () {\n\t\t\treturn this.data;\n\t\t}\n\t}\n\n\tconst messageTo = {\n\t\tget () {\n\t\t\tconst assertion = chai.expect(this.members.map(m => m.data));\n\n\t\t\tchai.util.flag(assertion, 'messageList', true);\n\n\t\t\treturn assertion.to;\n\t\t}\n\t};\n\n\tfunction prepareMessages (messages) {\n\t\treturn messages ? messages.map((message) => new Message(message)) : [];\n\t}\n\n\tclass Request extends Property {\n\t\tconstructor(options = {}) {\n\t\t\tsuper(options);\n\n\t\t\tthis.url = new Url(options.url);\n\t\t\tthis.methodPath = options.methodPath;\n\t\t\tthis.auth = new RequestAuth(options.auth);\n\t\t\tthis.metadata = new PropertyList(Metadata, this, options.metadata);\n\t\t\tthis.messages = new PropertyList(Message, this, prepareMessages(options.messages));\n\n\t\t\tthis.messages._postman_proprtyIsSerialisedAsPlural = true;\n\n\t\t\tObject.defineProperty(this.messages, 'to', messageTo);\n\t\t}\n\n\t\tstatic isRequest (obj) {\n\t\t\treturn (obj instanceof Request);\n\t\t}\n\t}\n\n\tclass Response extends Property {\n\t\tconstructor(options = {}) {\n\t\t\tsuper(options);\n\n\t\t\tthis.statusCode = options.statusCode;\n\t\t\tthis.responseTime = options.responseTime;\n\t\t\tthis.metadata = new PropertyList(Metadata, this, options.metadata);\n\t\t\tthis.trailers = new PropertyList(Metadata, this, options.trailers);\n\t\t\tthis.messages = new PropertyList(Message, this, prepareMessages(options.messages));\n\n\t\t\tthis.messages._postman_proprtyIsSerialisedAsPlural = true;\n\n\t\t\tObject.defineProperty(this.messages, 'to', messageTo);\n\t\t}\n\n\t\tstatic isResponse (obj) {\n\t\t\treturn (obj instanceof Response);\n\t\t}\n\t}\n\n\tfunction initializeExecution (target, context) {\n\t\tswitch (target) {\n\t\t\tcase 'beforeInvoke':\n\t\t\t\treturn {\n\t\t\t\t\trequest: new Request(context.request)\n\t\t\t\t};\n\n\t\t\tcase 'afterResponse':\n\t\t\t\treturn {\n\t\t\t\t\trequest: new Request(context.request),\n\t\t\t\t\tresponse: new Response(context.response)\n\t\t\t\t};\n\t\t}\n\t}\n\n\tfunction chaiPlugin (chai) {\n\t\tconst Assertion = chai.Assertion;\n\n\t\tAssertion.addProperty('postmanRequest', function () {\n\t\t\tthis.assert(Request.isRequest(this._obj),\n\t\t\t\t'expecting a postman request object but got #{this}',\n\t\t\t\t'not expecting a postman request object');\n\t\t});\n\n\t\tAssertion.addProperty('postmanResponse', function () {\n\t\t\tthis.assert(Response.isResponse(this._obj),\n\t\t\t\t'expecting a postman response object but got #{this}',\n\t\t\t\t'not expecting a postman response object');\n\t\t});\n\n\t\tAssertion.addProperty('postmanRequestOrResponse', function () {\n\t\t\tthis.assert(Response.isResponse(this._obj) || Request.isRequest(this._obj),\n\t\t\t\t'expecting a postman request or response object but got #{this}',\n\t\t\t\t'not expecting a postman request or response object');\n\t\t});\n\n\t\tAssertion.addProperty('ok', function () {\n\t\t\t// If asserted object is not response, use underlying 'ok'\n\t\t\tif (!Response.isResponse(this._obj)) {\n\t\t\t\tthis.assert(chai.util.flag(this, 'object'),\n\t\t\t\t\t'expected #{this} to be truthy',\n\t\t\t\t\t'expected #{this} to be falsy');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst expectedStatusCode = 0;\n\t\t\tconst actualStatusCode = this._obj.statusCode;\n\n\t\t\tthis.assert(actualStatusCode === expectedStatusCode,\n\t\t\t\t'expected response to have status code #{exp} but got #{act}',\n\t\t\t\t'expected response to not have status code #{act}',\n\t\t\t\texpectedStatusCode, actualStatusCode);\n\t\t});\n\n\t\tAssertion.addMethod('statusCode', function (statusCode) {\n\t\t\tnew Assertion(this._obj).to.be.postmanResponse;\n\n\t\t\tthis.assert(this._obj.statusCode === statusCode,\n\t\t\t\t'expected response to have status code #{exp} but got #{act}',\n\t\t\t\t'expected response to not have status code #{act}',\n\t\t\t\tstatusCode, this._obj.statusCode);\n\t\t});\n\n\t\tAssertion.addMethod('metadata', function (mKey, mValue) {\n\t\t\tnew Assertion(this._obj).to.be.postmanRequestOrResponse;\n\t\t\tnew Assertion(this._obj).to.have.property('metadata');\n\n\t\t\tconst ror = Request.isRequest(this._obj) ? 'request' : 'response';\n\n\t\t\tthis.assert(this._obj.metadata.has(mKey),\n\t\t\t\t\"expected \" + ror + \" to have metadata with key '\" + mKey + \"'\",\n\t\t\t\t\"expected \" + ror + \" to not have metadata with key '\" + mKey + \"'\",\n\t\t\t\ttrue, this._obj.metadata.has(mKey));\n\n\t\t\t// In case no check is done on value\n\t\t\tif (arguments.length < 2) { return; }\n\n\t\t\tthis.assert(this._obj.metadata.one(mKey).value === mValue,\n\t\t\t\t\"expected '\" + mKey + \"' \" + ror + \" metadata to be #{exp} but got #{act}\",\n\t\t\t\t\"expected '\" + mKey + \"' \" + ror + \" metadata to not be #{act}\",\n\t\t\t\tmValue, this._obj.metadata.one(mKey).value);\n\t\t});\n\n\t\tAssertion.addMethod('trailer', function (tKey, tValue) {\n\t\t\tnew Assertion(this._obj).to.be.postmanResponse;\n\t\t\tnew Assertion(this._obj).to.have.property('trailers');\n\n\t\t\tthis.assert(this._obj.trailers.has(tKey),\n\t\t\t\t\"expected response to have trailer with key '\" + tKey + \"'\",\n\t\t\t\t\"expected response to not have trailer with key '\" + tKey + \"'\",\n\t\t\t\ttrue, this._obj.trailers.has(tKey));\n\n\t\t\t// In case no check is done on value\n\t\t\tif (arguments.length < 2) { return; }\n\n\t\t\tthis.assert(this._obj.trailers.one(tKey).value === tValue,\n\t\t\t\t\"expected '\" + tKey + \"' response trailer to be #{exp} but got #{act}\",\n\t\t\t\t\"expected '\" + tKey + \"' response trailer to not be #{act}\",\n\t\t\t\ttValue, this._obj.trailers.one(tKey).value);\n\t\t});\n\n\t\tAssertion.addChainableMethod('responseTime', function (value) {\n\t\t\tconst actualTime = chai.util.flag(this, 'number');\n\n\t\t\tnew Assertion(actualTime).to.be.a('number');\n\n\t\t\targuments.length && this.assert(actualTime === value,\n\t\t\t\t'expected response time to be #{exp} but got #{act}',\n\t\t\t\t'expected response time to not be #{act}', value, actualTime);\n\t\t}, function () {\n\t\t\tnew Assertion(this._obj).to.be.postmanResponse;\n\t\t\tnew Assertion(this._obj).to.have.property('responseTime').a('number');\n\n\t\t\tchai.util.flag(this, 'number', this._obj.responseTime);\n\t\t\tthis._obj = this._obj.responseTime;\n\t\t});\n\n\t\tAssertion.addMethod('jsonSchema', function (schema, options) {\n\t\t\tnew Assertion(schema).to.be.an('object');\n\n\t\t\tconst ajvOptions = {\n\t\t\t\tallErrors: true,\n\t\t\t\tlogger: false,\n\t\t\t\t...options\n\t\t\t};\n\t\t\tconst isMessageList = chai.util.flag(this, 'messageList');\n\n\t\t\tif (isMessageList) {\n\t\t\t\tthis._obj.forEach((msg) => {\n\t\t\t\t\tconst ajv = new Ajv(ajvOptions);\n\t\t\t\t\tconst valid = ajv.validate(schema, msg);\n\n\t\t\t\t\tthis.assert(\n\t\t\t\t\t\tvalid && !ajv.errors,\n\t\t\t\t\t\t\"expected message(s) to satisfy schema but found following errors: \\n\" + ajv.errorsText(),\n\t\t\t\t\t\t\"expected message(s) to not satisfy schema\",\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tvalid\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst ajv = new Ajv(ajvOptions);\n\t\t\t\tconst valid = ajv.validate(schema, this._obj);\n\n\t\t\t\tthis.assert(\n\t\t\t\t\tvalid && !ajv.errors,\n\t\t\t\t\t\"expected object to satisfy the schema but found following errors: \\n\" + ajv.errorsText(),\n\t\t\t\t\t\"expected object to not satisfy the schema\",\n\t\t\t\t\ttrue,\n\t\t\t\t\tvalid\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\n\t\tAssertion.addMethod('message', function (value) {\n\t\t\tnew Assertion(this._obj).to.be.postmanRequestOrResponse;\n\t\t\tnew Assertion(this._obj).to.have.property('messages');\n\t\t\tnew Assertion(value).to.be.a('object');\n\n\t\t\tthis.assert(\n\t\t\t\t_.some(this._obj.messages.members, (msg) => _.isEqual(msg.data, value)),\n\t\t\t\t'expected message(s) to have #{exp}',\n\t\t\t\t'expected message(s) to not have #{exp}',\n\t\t\t\tvalue,\n\t\t\t\tnull\n\t\t\t);\n\t\t});\n\n\t\tAssertion.overwriteMethod('property', function (_super) {\n\t\t\treturn function (key, value) {\n\t\t\t\tconst isMessageList = chai.util.flag(this, 'messageList');\n\n\t\t\t\tif (isMessageList) {\n\t\t\t\t\tnew Assertion(key).to.be.a('string');\n\n\t\t\t\t\tconst args = [key];\n\n\t\t\t\t\targuments.length === 2 && args.push(value);\n\n\t\t\t\t\tthis._obj.forEach((msg) => new Assertion(msg).to.have.deep.nested.property(...args));\n\t\t\t\t} else {\n\t\t\t\t\t_super.apply(this, arguments);\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\n\t\tAssertion.overwriteChainableMethod('include', function (_super) {\n\t\t\treturn function (value) {\n\t\t\t\tconst isMessageList = chai.util.flag(this, 'messageList');\n\n\t\t\t\tif (isMessageList) {\n\t\t\t\t\tnew Assertion(value).to.be.a('object');\n\n\t\t\t\t\tthis.assert(\n\t\t\t\t\t\t_.some(this._obj, value),\n\t\t\t\t\t\t'expected some messages to include #{exp}',\n\t\t\t\t\t\t'expected some messages to not include #{exp}',\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tnull\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t_super.apply(this, arguments);\n\t\t\t\t}\n\t\t\t};\n\t\t}, function (_super) {\n\t\t\treturn function () {\n\t\t\t\t_super.apply(this, arguments);\n\t\t\t};\n\t\t});\n\t}\n\n\tmodule.exports = {\n\t\tinitializeExecution,\n\t\tchaiPlugin\n\t};\n";
export default template;
"use strict";
// @ts-nocheck
Object.defineProperty(exports, "__esModule", { value: true });
const template = `
	const Ajv = require('ajv');
	const chai = require('chai');
	const _ = require('lodash');
	const { Property, PropertyList, RequestAuth, Url } = require('postman-collection');

	class Metadata extends Property {
		constructor (options = {}) {
			super(options);

			this.key = options.key;
			this.value = options.value;
			this.disabled = options.disabled;
		}

		toString () {
			return this.key + ': ' + this.value;
		}

		valueOf () {
			return this.value;
		}

		static _postman_propertyIndexKey = 'key';
		static _postman_propertyIndexCaseInsensitive = true;
		static _postman_propertyAllowsMultipleValues = true;

		static parse (metadataString) {
			const metadata = [],
				regexes = {
					metadata: /^(\\S+):(.*)$/gm,
					fold: /\\r\\n([ \\t])/g,
					trim: /^\\s*(.*\\S)?\\s*$/
				};
			let match = regexes.metadata.exec(metadataString);

			metadataString = metadataString.toString().replace(regexes.fold, '$1');

			while (match) {
				metadata.push({
					key: match[1],
					value: match[2].replace(regexes.trim, '$1')
				});
				match = regexes.metadata.exec(metadataString);
			}

			return metadata;
		}

		static parseSingle (metadata) {
			if (!_.isString(metadata)) { return { key: '', value: '' }; }

			let index = metadata.indexOf(':');
			(index < 0) && (index = metadata.length);

			const key = metadata.substr(0, index),
				value = metadata.substr(index + 1);

			return {
				key: _.trim(key),
				value: _.trim(value)
			};
		}

		static unparse (metadata, separator = '\\r\\n') {
			if (!_.isArray(metadata) && !PropertyList.isPropertyList(metadata)) {
				return '';
			}

			return metadata.reduce((acc, m) => {
				if (m && !m.disabled) {
					acc += Metadata.unparseSingle(m) + separator;
				}

				return acc;
			}, '');
		}

		static unparseSingle (metadata) {
			if (!_.isObject(metadata)) { return ''; }

			return metadata.key + ': ' + metadata.value;
		}
	}

	class Message extends Property {
		constructor(options = {}) {
			super(options);

			this.data = options.data;

			if (!_.isNil(options.timestamp)) {
				this.timestamp = new Date(options.timestamp);
			}
		}

		toString () {
			return JSON.stringify(this.data);
		}

		valueOf () {
			return this.data;
		}
	}

	const messageTo = {
		get () {
			const assertion = chai.expect(this.members.map(m => m.data));

			chai.util.flag(assertion, 'messageList', true);

			return assertion.to;
		}
	};

	function prepareMessages (messages) {
		return messages ? messages.map((message) => new Message(message)) : [];
	}

	class Request extends Property {
		constructor(options = {}) {
			super(options);

			this.url = new Url(options.url);
			this.methodPath = options.methodPath;
			this.auth = new RequestAuth(options.auth);
			this.metadata = new PropertyList(Metadata, this, options.metadata);
			this.messages = new PropertyList(Message, this, prepareMessages(options.messages));

			this.messages._postman_proprtyIsSerialisedAsPlural = true;

			Object.defineProperty(this.messages, 'to', messageTo);
		}

		static isRequest (obj) {
			return (obj instanceof Request);
		}
	}

	class Response extends Property {
		constructor(options = {}) {
			super(options);

			this.statusCode = options.statusCode;
			this.responseTime = options.responseTime;
			this.metadata = new PropertyList(Metadata, this, options.metadata);
			this.trailers = new PropertyList(Metadata, this, options.trailers);
			this.messages = new PropertyList(Message, this, prepareMessages(options.messages));

			this.messages._postman_proprtyIsSerialisedAsPlural = true;

			Object.defineProperty(this.messages, 'to', messageTo);
		}

		static isResponse (obj) {
			return (obj instanceof Response);
		}
	}

	function initializeExecution (target, context) {
		switch (target) {
			case 'beforeInvoke':
				return {
					request: new Request(context.request)
				};

			case 'afterResponse':
				return {
					request: new Request(context.request),
					response: new Response(context.response)
				};
		}
	}

	function chaiPlugin (chai) {
		const Assertion = chai.Assertion;

		Assertion.addProperty('postmanRequest', function () {
			this.assert(Request.isRequest(this._obj),
				'expecting a postman request object but got #{this}',
				'not expecting a postman request object');
		});

		Assertion.addProperty('postmanResponse', function () {
			this.assert(Response.isResponse(this._obj),
				'expecting a postman response object but got #{this}',
				'not expecting a postman response object');
		});

		Assertion.addProperty('postmanRequestOrResponse', function () {
			this.assert(Response.isResponse(this._obj) || Request.isRequest(this._obj),
				'expecting a postman request or response object but got #{this}',
				'not expecting a postman request or response object');
		});

		Assertion.addProperty('ok', function () {
			// If asserted object is not response, use underlying 'ok'
			if (!Response.isResponse(this._obj)) {
				this.assert(chai.util.flag(this, 'object'),
					'expected #{this} to be truthy',
					'expected #{this} to be falsy');

				return;
			}

			const expectedStatusCode = 0;
			const actualStatusCode = this._obj.statusCode;

			this.assert(actualStatusCode === expectedStatusCode,
				'expected response to have status code #{exp} but got #{act}',
				'expected response to not have status code #{act}',
				expectedStatusCode, actualStatusCode);
		});

		Assertion.addMethod('statusCode', function (statusCode) {
			new Assertion(this._obj).to.be.postmanResponse;

			this.assert(this._obj.statusCode === statusCode,
				'expected response to have status code #{exp} but got #{act}',
				'expected response to not have status code #{act}',
				statusCode, this._obj.statusCode);
		});

		Assertion.addMethod('metadata', function (mKey, mValue) {
			new Assertion(this._obj).to.be.postmanRequestOrResponse;
			new Assertion(this._obj).to.have.property('metadata');

			const ror = Request.isRequest(this._obj) ? 'request' : 'response';

			this.assert(this._obj.metadata.has(mKey),
				"expected " + ror + " to have metadata with key '" + mKey + "'",
				"expected " + ror + " to not have metadata with key '" + mKey + "'",
				true, this._obj.metadata.has(mKey));

			// In case no check is done on value
			if (arguments.length < 2) { return; }

			this.assert(this._obj.metadata.one(mKey).value === mValue,
				"expected '" + mKey + "' " + ror + " metadata to be #{exp} but got #{act}",
				"expected '" + mKey + "' " + ror + " metadata to not be #{act}",
				mValue, this._obj.metadata.one(mKey).value);
		});

		Assertion.addMethod('trailer', function (tKey, tValue) {
			new Assertion(this._obj).to.be.postmanResponse;
			new Assertion(this._obj).to.have.property('trailers');

			this.assert(this._obj.trailers.has(tKey),
				"expected response to have trailer with key '" + tKey + "'",
				"expected response to not have trailer with key '" + tKey + "'",
				true, this._obj.trailers.has(tKey));

			// In case no check is done on value
			if (arguments.length < 2) { return; }

			this.assert(this._obj.trailers.one(tKey).value === tValue,
				"expected '" + tKey + "' response trailer to be #{exp} but got #{act}",
				"expected '" + tKey + "' response trailer to not be #{act}",
				tValue, this._obj.trailers.one(tKey).value);
		});

		Assertion.addChainableMethod('responseTime', function (value) {
			const actualTime = chai.util.flag(this, 'number');

			new Assertion(actualTime).to.be.a('number');

			arguments.length && this.assert(actualTime === value,
				'expected response time to be #{exp} but got #{act}',
				'expected response time to not be #{act}', value, actualTime);
		}, function () {
			new Assertion(this._obj).to.be.postmanResponse;
			new Assertion(this._obj).to.have.property('responseTime').a('number');

			chai.util.flag(this, 'number', this._obj.responseTime);
			this._obj = this._obj.responseTime;
		});

		Assertion.addMethod('jsonSchema', function (schema, options) {
			new Assertion(schema).to.be.an('object');

			const ajvOptions = {
				allErrors: true,
				logger: false,
				...options
			};
			const isMessageList = chai.util.flag(this, 'messageList');

			if (isMessageList) {
				this._obj.forEach((msg) => {
					const ajv = new Ajv(ajvOptions);
					const valid = ajv.validate(schema, msg);

					this.assert(
						valid && !ajv.errors,
						"expected message(s) to satisfy schema but found following errors: \\n" + ajv.errorsText(),
						"expected message(s) to not satisfy schema",
						true,
						valid
					);
				});
			} else {
				const ajv = new Ajv(ajvOptions);
				const valid = ajv.validate(schema, this._obj);

				this.assert(
					valid && !ajv.errors,
					"expected object to satisfy the schema but found following errors: \\n" + ajv.errorsText(),
					"expected object to not satisfy the schema",
					true,
					valid
				);
			}
		});

		Assertion.addMethod('message', function (value) {
			new Assertion(this._obj).to.be.postmanRequestOrResponse;
			new Assertion(this._obj).to.have.property('messages');
			new Assertion(value).to.be.a('object');

			this.assert(
				_.some(this._obj.messages.members, (msg) => _.isEqual(msg.data, value)),
				'expected message(s) to have #{exp}',
				'expected message(s) to not have #{exp}',
				value,
				null
			);
		});

		Assertion.overwriteMethod('property', function (_super) {
			return function (key, value) {
				const isMessageList = chai.util.flag(this, 'messageList');

				if (isMessageList) {
					new Assertion(key).to.be.a('string');

					const args = [key];

					arguments.length === 2 && args.push(value);

					this._obj.forEach((msg) => new Assertion(msg).to.have.deep.nested.property(...args));
				} else {
					_super.apply(this, arguments);
				}
			};
		});

		Assertion.overwriteChainableMethod('include', function (_super) {
			return function (value) {
				const isMessageList = chai.util.flag(this, 'messageList');

				if (isMessageList) {
					new Assertion(value).to.be.a('object');

					this.assert(
						_.some(this._obj, value),
						'expected some messages to include #{exp}',
						'expected some messages to not include #{exp}',
						value,
						null
					);
				} else {
					_super.apply(this, arguments);
				}
			};
		}, function (_super) {
			return function () {
				_super.apply(this, arguments);
			};
		});
	}

	module.exports = {
		initializeExecution,
		chaiPlugin
	};
`;
exports.default = template;
//# sourceMappingURL=sandbox-template.js.map{"version":3,"file":"sandbox-template.js","sourceRoot":"","sources":["../../../src/extensions/events/sandbox-template.ts"],"names":[],"mappings":";AAAA,cAAc;;AAEd,MAAM,QAAQ,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuXhB,CAAC;AAEF,kBAAe,QAAQ,CAAC"}declare const config: {
    replaceInFields: string[];
};
export default config;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const config = {
    replaceInFields: [
        'payload.url',
        'payload.message.content',
        'payload.metadata',
        'payload.settings',
        'extensions.auth',
    ],
};
exports.default = config;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/extensions/variables/index.ts"],"names":[],"mappings":";;AAEA,MAAM,MAAM,GAAG;IACd,eAAe,EAAE;QAChB,aAAa;QACb,yBAAyB;QACzB,kBAAkB;QAClB,kBAAkB;QAClB,iBAAiB;KACjB;CAC0B,CAAC;AAE7B,kBAAe,MAAM,CAAC"}import GRPCRequest from '.';
declare const _default: (item: import("@postman/runtime.core").Item.OfType<GRPCRequest>, agent: import("./agent").GRPCAgent, context: import("@postman/runtime.core").RuntimeContext) => Promise<void>;
export default _default;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const json_bigint_string_1 = __importDefault(require("json-bigint-string"));
const strip_json_comments_1 = __importDefault(require("strip-json-comments"));
const runtime_core_1 = require("@postman/runtime.core");
const runtime_grpc_utils_1 = require("@postman/runtime.grpc-utils");
const lodash_lite_1 = require("./lodash-lite");
const metadata_1 = require("./metadata");
exports.default = (async function handler(item, agent, context) {
    const { isTLS } = (0, runtime_grpc_utils_1.parseURL)(item.payload.url);
    const settings = item.payload.settings || {};
    const metadata = (0, metadata_1.toRawMetadata)(item.payload.metadata);
    const events = runtime_core_1.EventChannel.specific(context.events);
    const proxyOptions = typeof context.proxy === 'function' ?
        await context.proxy(item.payload.url, settings.secureConnection)
        : context.proxy;
    const channelOptions = {
        'grpc.max_send_message_length': -1,
        'grpc.max_receive_message_length': settings.maxResponseMessageSize ?
            settings.maxResponseMessageSize * 1024 * 1024
            : -1,
        'grpc.ssl_target_name_override': settings.serverNameOverride || '',
        'grpc.enable_http_proxy': proxyOptions?.ignoreEnvironmentVariables && !proxyOptions?.url ? 0 : 1,
    };
    const callOptions = {
        connectionTimeout: settings.connectionTimeout || Infinity,
    };
    const tlsOptions = isTLS || settings.secureConnection ?
        {
            rejectUnauthorized: Boolean(settings.strictSSL),
            secureContext: typeof context.secureContext === 'function' ?
                await context.secureContext(item.payload.url)
                : context.secureContext,
        }
        : undefined;
    let descriptor;
    if (item.extensions.schema && item.extensions.schema.source !== 'none') {
        descriptor = await agent.resolveSchema(item.extensions.schema, {
            url: item.payload.url,
            channelOptions: { ...channelOptions },
            callOptions: { ...callOptions },
            tlsOptions: { ...tlsOptions },
            proxy: proxyOptions?.url,
            metadata: [...metadata],
        });
    }
    if (!descriptor) {
        if (item.payload.methodDescriptor) {
            descriptor = item.payload.methodDescriptor;
        }
        else {
            throw new Error('Missing service definition');
        }
    }
    const jsonDescriptor = (0, runtime_grpc_utils_1.toJSONDescriptor)(descriptor);
    const definition = new runtime_grpc_utils_1.Definition(jsonDescriptor);
    const method = definition.methods.get(item.payload.methodPath);
    if (!method) {
        throw new Error(`Method not found: "${item.payload.methodPath}"`);
    }
    const prepareMessage = (message) => {
        let normalizedMsg = (0, strip_json_comments_1.default)(message.trim(), { whitespace: false }) || '{}';
        try {
            // We are parsing the message twice here.
            // Once to normalize and once to validate it.
            // TODO: Consider a better way to handle this.
            const parsedMessage = JSON.parse(normalizedMsg);
            // Both object and array representation of Map fields
            // are accepted for backward compatibility. This coverts
            // to object representation to comply with actual descriptor
            method.requestType.jsonSchema.mapFields?.forEach((path) => {
                const val = (0, lodash_lite_1.get)(parsedMessage, path);
                if (Array.isArray(val)) {
                    (0, lodash_lite_1.set)(parsedMessage, path, val.reduce((acc, item) => {
                        acc[item.key] = item.value;
                        return acc;
                    }, {}));
                }
            });
            normalizedMsg = JSON.stringify(parsedMessage);
        }
        catch (e) {
            // fallthrough, to be handled by validation
        }
        if (!method.requestType.validate(normalizedMsg)) {
            throw new Error('Message violates its Protobuf type definition');
        }
        return normalizedMsg;
    };
    let message;
    if (method.kind === 'unary' || method.kind === 'server-stream') {
        message = prepareMessage(item.payload.message.content);
    }
    const invocation = await agent.invoke({
        url: item.payload.url,
        descriptor: jsonDescriptor,
        method: item.payload.methodPath,
        includeDefaultFields: Boolean(settings.includeDefaultFields ?? true),
        proxy: proxyOptions?.url,
        channelOptions,
        callOptions,
        tlsOptions,
        metadata,
        message,
    });
    events.emit('sent-request-header', {
        metadata: (0, metadata_1.toItemMetadata)(metadata),
        isRequestStreamed: ['client-stream', 'bidi'].includes(method.kind),
        isResponseStreamed: ['server-stream', 'bidi'].includes(method.kind),
    });
    if (message !== undefined) {
        events.emit('sent-request-data', { data: json_bigint_string_1.default.parse(message) });
    }
    const onEnd = () => invocation.end();
    const onCancel = () => invocation.cancel();
    const onWrite = async (event) => {
        try {
            const message = event.payload.json;
            const resolvedMessage = prepareMessage(context.variables.replaceIn(message));
            await invocation.write(resolvedMessage);
            events.emit('sent-request-data', {
                data: json_bigint_string_1.default.parse(resolvedMessage),
            });
        }
        catch (err) {
            events.emit('internal:transient-error', err);
        }
    };
    return new Promise((resolve) => {
        const onDone = () => {
            invocation.cancel();
            events.off('write', onWrite).off('end', onEnd).off('cancel', onCancel);
            resolve();
        };
        events
            .on('write', onWrite)
            .on('end', onEnd)
            .on('cancel', onCancel)
            .onCleanup(onDone);
        invocation
            .on('response', (data) => {
            events.emit('received-response-data', { data });
        })
            .on('metadata', (metadata) => {
            events.emit('received-response-header', {
                metadata: (0, metadata_1.toItemMetadata)(metadata),
            });
        })
            .on('status', (status) => {
            events.emit('status', {
                statusCode: status.code,
                statusMessage: status.message,
                metadata: (0, metadata_1.toItemMetadata)(status.metadata),
                timings: status.timings,
            });
            onDone();
        })
            .on('error', (err) => {
            events.emit('internal:error', err);
            onDone();
        });
    });
});
//# sourceMappingURL=handler.js.map{"version":3,"file":"handler.js","sourceRoot":"","sources":["../src/handler.ts"],"names":[],"mappings":"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"}import { FromSchema } from 'json-schema-to-ts';
import { ItemType } from '@postman/runtime.core';
import Documentation from '@postman/runtime.documentation';
import Variables from '@postman/runtime.variables';
import Schema from '@postman/runtime.schema';
import Auth from '@postman/runtime.auth';
import Events from '@postman/runtime.events';
import { GRPCAgent } from './agent';
import * as GRPCEvents from './events';
export * as GRPCEvents from './events';
export * from './agent';
declare const definition: {
    name: "grpc-request";
    summary: "gRPC Request";
    schema: {
        readonly type: "object";
        readonly required: ["url", "methodPath", "message", "metadata"];
        readonly properties: {
            readonly url: {
                readonly type: "string";
            };
            readonly methodPath: {
                readonly type: "string";
            };
            readonly methodDescriptor: {
                readonly type: "string";
            };
            readonly message: {
                readonly type: "object";
                readonly required: ["content"];
                readonly properties: {
                    readonly content: {
                        readonly type: "string";
                    };
                };
                readonly additionalProperties: false;
            };
            readonly metadata: {
                readonly type: "array";
                readonly items: {
                    readonly type: "object";
                    readonly required: ["key", "value"];
                    readonly properties: {
                        readonly key: {
                            readonly type: "string";
                        };
                        readonly value: {
                            readonly type: "string";
                        };
                        readonly description: {
                            readonly type: "string";
                        };
                        readonly disabled: {
                            readonly type: "boolean";
                        };
                    };
                    readonly additionalProperties: false;
                };
            };
            readonly settings: {
                readonly type: "object";
                readonly properties: {
                    readonly secureConnection: {
                        readonly type: "boolean";
                    };
                    readonly strictSSL: {
                        readonly type: "boolean";
                    };
                    readonly serverNameOverride: {
                        readonly type: "string";
                    };
                    readonly maxResponseMessageSize: {
                        readonly type: "number";
                    };
                    readonly includeDefaultFields: {
                        readonly type: "boolean";
                    };
                    readonly connectionTimeout: {
                        readonly type: "number";
                    };
                };
                readonly additionalProperties: false;
            };
        };
        readonly additionalProperties: false;
    };
    constraints: [{
        constraint: "allow-child-types";
        allowed: ["grpc-example"];
    }, {
        constraint: "allow-extensions";
        allowed: ["auth", "schema", "events", "documentation", "variables"];
    }];
};
declare namespace GRPCRequest {
    type Payload = FromSchema<typeof definition.schema>;
    type Extensions = Documentation | Schema | Variables | Auth | Events;
    type Config = GRPCAgent;
    type SentEvents = GRPCEvents.Write | GRPCEvents.End | GRPCEvents.Cancel;
    type ReceivedEvents = GRPCEvents.SentRequestHeader | GRPCEvents.ReceivedResponseHeader | GRPCEvents.SentRequestData | GRPCEvents.ReceivedResponseData | GRPCEvents.Status | GRPCEvents.InternalError | GRPCEvents.InternalTransientError;
    const use: () => ItemType.Specific<{
        methodDescriptor?: string | undefined;
        settings?: {
            secureConnection?: boolean | undefined;
            strictSSL?: boolean | undefined;
            serverNameOverride?: string | undefined;
            maxResponseMessageSize?: number | undefined;
            includeDefaultFields?: boolean | undefined;
            connectionTimeout?: number | undefined;
        } | undefined;
        url: string;
        methodPath: string;
        message: {
            content: string;
        };
        metadata: {
            description?: string | undefined;
            disabled?: boolean | undefined;
            key: string;
            value: string;
        }[];
    }, Extensions, GRPCAgent, SentEvents, ReceivedEvents>;
}
type GRPCRequest = ItemType.Specific<GRPCRequest.Payload, GRPCRequest.Extensions, GRPCRequest.Config, GRPCRequest.SentEvents, GRPCRequest.ReceivedEvents>;
export default GRPCRequest;
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GRPCEvents = void 0;
const json_schema_to_ts_1 = require("json-schema-to-ts");
const runtime_core_1 = require("@postman/runtime.core");
const runtime_documentation_1 = __importDefault(require("@postman/runtime.documentation"));
const runtime_variables_1 = __importDefault(require("@postman/runtime.variables"));
const runtime_schema_1 = __importDefault(require("@postman/runtime.schema"));
const runtime_auth_1 = __importDefault(require("@postman/runtime.auth"));
const runtime_events_1 = __importDefault(require("@postman/runtime.events"));
const handler_1 = __importDefault(require("./handler"));
const auth_1 = __importDefault(require("./extensions/auth"));
const events_1 = __importDefault(require("./extensions/events"));
const variables_1 = __importDefault(require("./extensions/variables"));
exports.GRPCEvents = __importStar(require("./events"));
__exportStar(require("./agent"), exports);
const definition = (0, json_schema_to_ts_1.asConst)({
    name: 'grpc-request',
    summary: 'gRPC Request',
    schema: {
        type: 'object',
        required: ['url', 'methodPath', 'message', 'metadata'],
        properties: {
            url: {
                type: 'string',
            },
            methodPath: {
                type: 'string',
            },
            methodDescriptor: {
                type: 'string',
            },
            message: {
                type: 'object',
                required: ['content'],
                properties: {
                    content: {
                        type: 'string',
                    },
                },
                additionalProperties: false,
            },
            metadata: {
                type: 'array',
                items: {
                    type: 'object',
                    required: ['key', 'value'],
                    properties: {
                        key: {
                            type: 'string',
                        },
                        value: {
                            type: 'string',
                        },
                        description: {
                            type: 'string',
                        },
                        disabled: {
                            type: 'boolean',
                        },
                    },
                    additionalProperties: false,
                },
            },
            settings: {
                type: 'object',
                properties: {
                    secureConnection: {
                        type: 'boolean',
                    },
                    strictSSL: {
                        type: 'boolean',
                    },
                    serverNameOverride: {
                        type: 'string',
                    },
                    maxResponseMessageSize: {
                        type: 'number',
                    },
                    includeDefaultFields: {
                        type: 'boolean',
                    },
                    connectionTimeout: {
                        type: 'number',
                    },
                },
                additionalProperties: false,
            },
        },
        additionalProperties: false,
    },
    constraints: [
        {
            constraint: 'allow-child-types',
            allowed: ['grpc-example'],
        },
        {
            constraint: 'allow-extensions',
            allowed: ['auth', 'schema', 'events', 'documentation', 'variables'],
        },
    ],
});
const extensions = [
    runtime_documentation_1.default.use().implement({}),
    runtime_schema_1.default.use().implement({}),
    runtime_events_1.default.use().implement(events_1.default),
    runtime_variables_1.default.use().implement(variables_1.default),
    runtime_auth_1.default.use().implement(auth_1.default),
];
var GRPCRequest;
(function (GRPCRequest) {
    GRPCRequest.use = runtime_core_1.ItemType.define(definition, extensions, handler_1.default);
})(GRPCRequest || (GRPCRequest = {}));
exports.default = GRPCRequest;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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"}export declare function get(obj: object, path: string): any | undefined;
export declare function set<T extends Record<string, any>>(obj: T, path: string, value: any): T;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.get = get;
exports.set = set;
// Toned down version of lodash.get
// This only does not support array indexes in path
function get(obj, path) {
    if (!obj || typeof obj !== 'object' || !path || typeof path !== 'string') {
        return undefined;
    }
    const keys = path.split('.');
    if (!keys.length)
        return undefined;
    let result = obj;
    for (const key of keys) {
        if (result === undefined) {
            return undefined;
        }
        result = result[key];
    }
    return result;
}
// Toned down version of lodash.set
// This only does not support array indexes in path
function set(obj, path, value) {
    if (!obj || typeof obj !== 'object' || !path || typeof path !== 'string') {
        return obj;
    }
    const keys = path.split('.');
    if (!keys.length)
        return obj;
    let result = obj;
    for (let i = 0; i < keys.length - 1; i++) {
        const k = keys[i];
        if (!isSafeProperty(result, k)) {
            return obj;
        }
        if (result[k] == null || typeof result[k] !== 'object') {
            result[k] = Object.create(null);
        }
        result = result[k];
    }
    const lastKey = keys[keys.length - 1];
    if (isSafeProperty(result, lastKey)) {
        result[lastKey] = value;
    }
    return obj;
}
function isSafeProperty(obj, prop) {
    if (prop === '__proto__') {
        return false;
    }
    if (prop === 'constructor' && !Object.hasOwn(obj, prop)) {
        return false;
    }
    return true;
}
//# sourceMappingURL=lodash-lite.js.map{"version":3,"file":"lodash-lite.js","sourceRoot":"","sources":["../src/lodash-lite.ts"],"names":[],"mappings":";;AAEA,kBAmBC;AAID,kBAiCC;AA1DD,mCAAmC;AACnC,mDAAmD;AACnD,SAAgB,GAAG,CAAC,GAAW,EAAE,IAAY;IAC5C,IAAI,CAAC,GAAG,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,CAAC,IAAI,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE,CAAC;QAC1E,OAAO,SAAS,CAAC;IAClB,CAAC;IAED,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAE7B,IAAI,CAAC,IAAI,CAAC,MAAM;QAAE,OAAO,SAAS,CAAC;IAEnC,IAAI,MAAM,GAAQ,GAAG,CAAC;IACtB,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE,CAAC;QACxB,IAAI,MAAM,KAAK,SAAS,EAAE,CAAC;YAC1B,OAAO,SAAS,CAAC;QAClB,CAAC;QAED,MAAM,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;IACtB,CAAC;IAED,OAAO,MAAM,CAAC;AACf,CAAC;AAED,mCAAmC;AACnC,mDAAmD;AACnD,SAAgB,GAAG,CAClB,GAAM,EACN,IAAY,EACZ,KAAU;IAEV,IAAI,CAAC,GAAG,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,CAAC,IAAI,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE,CAAC;QAC1E,OAAO,GAAG,CAAC;IACZ,CAAC;IAED,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAE7B,IAAI,CAAC,IAAI,CAAC,MAAM;QAAE,OAAO,GAAG,CAAC;IAE7B,IAAI,MAAM,GAAwB,GAAG,CAAC;IACtC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QAC1C,MAAM,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;QAElB,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC;YAChC,OAAO,GAAG,CAAC;QACZ,CAAC;QAED,IAAI,MAAM,CAAC,CAAC,CAAC,IAAI,IAAI,IAAI,OAAO,MAAM,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE,CAAC;YACxD,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACjC,CAAC;QACD,MAAM,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;IACpB,CAAC;IAED,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACtC,IAAI,cAAc,CAAC,MAAM,EAAE,OAAO,CAAC,EAAE,CAAC;QACrC,MAAM,CAAC,OAAO,CAAC,GAAG,KAAK,CAAC;IACzB,CAAC;IAED,OAAO,GAAG,CAAC;AACZ,CAAC;AAED,SAAS,cAAc,CAAC,GAAwB,EAAE,IAAY;IAC7D,IAAI,IAAI,KAAK,WAAW,EAAE,CAAC;QAC1B,OAAO,KAAK,CAAC;IACd,CAAC;IAED,IAAI,IAAI,KAAK,aAAa,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,EAAE,CAAC;QACzD,OAAO,KAAK,CAAC;IACd,CAAC;IAED,OAAO,IAAI,CAAC;AACb,CAAC"}import GRPCRequest from '.';
export type PostmanMetadata = GRPCRequest.Payload['metadata'];
export type Metadata = ReadonlyArray<Readonly<[string, string | Uint8Array]>>;
export declare function toRawMetadata(metadata: PostmanMetadata): Metadata;
export declare function toItemMetadata(rawMetadata: Metadata): PostmanMetadata;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toRawMetadata = toRawMetadata;
exports.toItemMetadata = toItemMetadata;
const js_base64_1 = require("js-base64");
/*
    Converts between Postman-formatted metadata and raw metadata.
*/
function toRawMetadata(metadata) {
    const rawMetadata = [];
    for (const { key, value, disabled } of metadata) {
        if (!disabled) {
            let rawValue = String(value || '');
            if (key.toLowerCase().endsWith('-bin')) {
                if (/^[a-zA-Z0-9+/=]*\s*$/.test(rawValue)) {
                    rawValue = js_base64_1.Base64.toUint8Array(rawValue);
                }
                else {
                    throw new Error('Metadata ending in "-bin" must be base64');
                }
            }
            rawMetadata.push([key, rawValue]);
        }
    }
    return rawMetadata;
}
function toItemMetadata(rawMetadata) {
    const metadata = [];
    for (const [key, rawValue] of rawMetadata) {
        let value;
        if (rawValue instanceof Uint8Array) {
            value = js_base64_1.Base64.fromUint8Array(rawValue);
        }
        else {
            value = rawValue;
        }
        metadata.push({ key, value });
    }
    return metadata;
}
//# sourceMappingURL=metadata.js.map{"version":3,"file":"metadata.js","sourceRoot":"","sources":["../src/metadata.ts"],"names":[],"mappings":";;AAUA,sCAoBC;AAED,wCAgBC;AAhDD,yCAAmC;AAMnC;;EAEE;AAEF,SAAgB,aAAa,CAAC,QAAyB;IACtD,MAAM,WAAW,GAAoC,EAAE,CAAC;IAExD,KAAK,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ,EAAE,IAAI,QAAQ,EAAE,CAAC;QACjD,IAAI,CAAC,QAAQ,EAAE,CAAC;YACf,IAAI,QAAQ,GAAwB,MAAM,CAAC,KAAK,IAAI,EAAE,CAAC,CAAC;YAExD,IAAI,GAAG,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC;gBACxC,IAAI,sBAAsB,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC;oBAC3C,QAAQ,GAAG,kBAAM,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;gBAC1C,CAAC;qBAAM,CAAC;oBACP,MAAM,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;gBAC7D,CAAC;YACF,CAAC;YAED,WAAW,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC,CAAC;QACnC,CAAC;IACF,CAAC;IAED,OAAO,WAAW,CAAC;AACpB,CAAC;AAED,SAAgB,cAAc,CAAC,WAAqB;IACnD,MAAM,QAAQ,GAAoB,EAAE,CAAC;IAErC,KAAK,MAAM,CAAC,GAAG,EAAE,QAAQ,CAAC,IAAI,WAAW,EAAE,CAAC;QAC3C,IAAI,KAAa,CAAC;QAElB,IAAI,QAAQ,YAAY,UAAU,EAAE,CAAC;YACpC,KAAK,GAAG,kBAAM,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;QACzC,CAAC;aAAM,CAAC;YACP,KAAK,GAAG,QAAQ,CAAC;QAClB,CAAC;QAED,QAAQ,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,CAAC,CAAC;IAC/B,CAAC;IAED,OAAO,QAAQ,CAAC;AACjB,CAAC"}{
  "name": "@postman/runtime.grpc-request",
  "version": "0.2.10",
  "license": "UNLICENSED",
  "description": "The Postman ItemType: 'grpc-request'",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/item-types/grpc-request#readme",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "dependencies": {
    "js-base64": "^3.7.5",
    "json-bigint-string": "^1.0.0",
    "json-schema-to-ts": "~2.7.2",
    "strip-json-comments": "^3.1.1",
    "@postman/runtime.grpc-utils": "^0.2.3"
  },
  "peerDependencies": {
    "@postman/runtime.documentation": "^0.1.13",
    "@postman/runtime.core": "^0.4.0",
    "@postman/runtime.auth": "^0.1.13",
    "@postman/runtime.events": "^0.2.0",
    "@postman/runtime.variables": "^0.1.13",
    "@postman/runtime.schema": "^0.1.13"
  },
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest"
  }
}# ItemType: `grpc-request`

This package defines the Postman ItemType: `grpc-request`.
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": [],
		"lib": ["es2022"],
	},
	"references": [
		{ "path": "../../core/core" },
		{ "path": "../../extensions/auth" },
		{ "path": "../../extensions/documentation" },
		{ "path": "../../extensions/schema" },
		{ "path": "../../extensions/variables" }
	]
}
{
  "nested": {
    "google": {
      "nested": {
        "api": {
          "nested": {
            "http": {
              "type": "HttpRule",
              "id": 72295728,
              "extend": "google.protobuf.MethodOptions"
            },
            "HttpRule": {
              "oneofs": {
                "pattern": {
                  "oneof": [
                    "get",
                    "put",
                    "post",
                    "delete",
                    "patch",
                    "custom"
                  ]
                }
              },
              "fields": {
                "get": {
                  "type": "string",
                  "id": 2
                },
                "put": {
                  "type": "string",
                  "id": 3
                },
                "post": {
                  "type": "string",
                  "id": 4
                },
                "delete": {
                  "type": "string",
                  "id": 5
                },
                "patch": {
                  "type": "string",
                  "id": 6
                },
                "custom": {
                  "type": "CustomHttpPattern",
                  "id": 8
                },
                "selector": {
                  "type": "string",
                  "id": 1
                },
                "body": {
                  "type": "string",
                  "id": 7
                },
                "additional_bindings": {
                  "rule": "repeated",
                  "type": "HttpRule",
                  "id": 11
                }
              }
            }
          }
        },
        "protobuf": {
          "nested": {
            "MethodOptions": {
              "fields": {},
              "extensions": [
                [
                  1000,
                  536870911
                ]
              ]
            }
          }
        }
      }
    }
  }
}
syntax = "proto3";

package google.api;

import "google/api/http.proto";
import "google/protobuf/descriptor.proto";

extend google.protobuf.MethodOptions {

    HttpRule http = 72295728;
}
{
  "nested": {
    "google": {
      "nested": {
        "api": {
          "nested": {
            "Http": {
              "fields": {
                "rules": {
                  "rule": "repeated",
                  "type": "HttpRule",
                  "id": 1
                }
              }
            },
            "HttpRule": {
              "oneofs": {
                "pattern": {
                  "oneof": [
                    "get",
                    "put",
                    "post",
                    "delete",
                    "patch",
                    "custom"
                  ]
                }
              },
              "fields": {
                "get": {
                  "type": "string",
                  "id": 2
                },
                "put": {
                  "type": "string",
                  "id": 3
                },
                "post": {
                  "type": "string",
                  "id": 4
                },
                "delete": {
                  "type": "string",
                  "id": 5
                },
                "patch": {
                  "type": "string",
                  "id": 6
                },
                "custom": {
                  "type": "CustomHttpPattern",
                  "id": 8
                },
                "selector": {
                  "type": "string",
                  "id": 1
                },
                "body": {
                  "type": "string",
                  "id": 7
                },
                "additional_bindings": {
                  "rule": "repeated",
                  "type": "HttpRule",
                  "id": 11
                }
              }
            },
            "CustomHttpPattern": {
              "fields": {
                "kind": {
                  "type": "string",
                  "id": 1
                },
                "path": {
                  "type": "string",
                  "id": 2
                }
              }
            }
          }
        }
      }
    }
  }
}
syntax = "proto3";

package google.api;

message Http {

    repeated HttpRule rules = 1;
}

message HttpRule {

    oneof pattern {

        string get = 2;
        string put = 3;
        string post = 4;
        string delete = 5;
        string patch = 6;
        CustomHttpPattern custom = 8;
    }

    string selector = 1;
    string body = 7;
    repeated HttpRule additional_bindings = 11;
}

message CustomHttpPattern {

    string kind = 1;
    string path = 2;
}{
  "nested": {
    "google": {
      "nested": {
        "protobuf": {
          "nested": {
            "Api": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "methods": {
                  "rule": "repeated",
                  "type": "Method",
                  "id": 2
                },
                "options": {
                  "rule": "repeated",
                  "type": "Option",
                  "id": 3
                },
                "version": {
                  "type": "string",
                  "id": 4
                },
                "source_context": {
                  "type": "SourceContext",
                  "id": 5
                },
                "mixins": {
                  "rule": "repeated",
                  "type": "Mixin",
                  "id": 6
                },
                "syntax": {
                  "type": "Syntax",
                  "id": 7
                }
              }
            },
            "Method": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "request_type_url": {
                  "type": "string",
                  "id": 2
                },
                "request_streaming": {
                  "type": "bool",
                  "id": 3
                },
                "response_type_url": {
                  "type": "string",
                  "id": 4
                },
                "response_streaming": {
                  "type": "bool",
                  "id": 5
                },
                "options": {
                  "rule": "repeated",
                  "type": "Option",
                  "id": 6
                },
                "syntax": {
                  "type": "Syntax",
                  "id": 7
                }
              }
            },
            "Mixin": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "root": {
                  "type": "string",
                  "id": 2
                }
              }
            },
            "SourceContext": {
              "fields": {
                "file_name": {
                  "type": "string",
                  "id": 1
                }
              }
            },
            "Option": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "value": {
                  "type": "Any",
                  "id": 2
                }
              }
            },
            "Syntax": {
              "values": {
                "SYNTAX_PROTO2": 0,
                "SYNTAX_PROTO3": 1
              }
            }
          }
        }
      }
    }
  }
}
syntax = "proto3";

package google.protobuf;

import "google/protobuf/source_context.proto";
import "google/protobuf/type.proto";

message Api {

    string name = 1;
    repeated Method methods = 2;
    repeated Option options = 3;
    string version = 4;
    SourceContext source_context = 5;
    repeated Mixin mixins = 6;
    Syntax syntax = 7;
}

message Method {

    string name = 1;
    string request_type_url = 2;
    bool request_streaming = 3;
    string response_type_url = 4;
    bool response_streaming = 5;
    repeated Option options = 6;
    Syntax syntax = 7;
}

message Mixin {

    string name = 1;
    string root = 2;
}
{
  "nested": {
    "google": {
      "nested": {
        "protobuf": {
          "nested": {
            "FileDescriptorSet": {
              "fields": {
                "file": {
                  "rule": "repeated",
                  "type": "FileDescriptorProto",
                  "id": 1,
                  "options": {
                    "packed": false
                  }
                }
              }
            },
            "FileDescriptorProto": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "package": {
                  "type": "string",
                  "id": 2
                },
                "dependency": {
                  "rule": "repeated",
                  "type": "string",
                  "id": 3
                },
                "public_dependency": {
                  "rule": "repeated",
                  "type": "int32",
                  "id": 10,
                  "options": {
                    "packed": false
                  }
                },
                "weak_dependency": {
                  "rule": "repeated",
                  "type": "int32",
                  "id": 11,
                  "options": {
                    "packed": false
                  }
                },
                "message_type": {
                  "rule": "repeated",
                  "type": "DescriptorProto",
                  "id": 4,
                  "options": {
                    "packed": false
                  }
                },
                "enum_type": {
                  "rule": "repeated",
                  "type": "EnumDescriptorProto",
                  "id": 5,
                  "options": {
                    "packed": false
                  }
                },
                "service": {
                  "rule": "repeated",
                  "type": "ServiceDescriptorProto",
                  "id": 6,
                  "options": {
                    "packed": false
                  }
                },
                "extension": {
                  "rule": "repeated",
                  "type": "FieldDescriptorProto",
                  "id": 7,
                  "options": {
                    "packed": false
                  }
                },
                "options": {
                  "type": "FileOptions",
                  "id": 8
                },
                "source_code_info": {
                  "type": "SourceCodeInfo",
                  "id": 9
                },
                "syntax": {
                  "type": "string",
                  "id": 12
                }
              }
            },
            "DescriptorProto": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "field": {
                  "rule": "repeated",
                  "type": "FieldDescriptorProto",
                  "id": 2,
                  "options": {
                    "packed": false
                  }
                },
                "extension": {
                  "rule": "repeated",
                  "type": "FieldDescriptorProto",
                  "id": 6,
                  "options": {
                    "packed": false
                  }
                },
                "nested_type": {
                  "rule": "repeated",
                  "type": "DescriptorProto",
                  "id": 3,
                  "options": {
                    "packed": false
                  }
                },
                "enum_type": {
                  "rule": "repeated",
                  "type": "EnumDescriptorProto",
                  "id": 4,
                  "options": {
                    "packed": false
                  }
                },
                "extension_range": {
                  "rule": "repeated",
                  "type": "ExtensionRange",
                  "id": 5,
                  "options": {
                    "packed": false
                  }
                },
                "oneof_decl": {
                  "rule": "repeated",
                  "type": "OneofDescriptorProto",
                  "id": 8,
                  "options": {
                    "packed": false
                  }
                },
                "options": {
                  "type": "MessageOptions",
                  "id": 7
                },
                "reserved_range": {
                  "rule": "repeated",
                  "type": "ReservedRange",
                  "id": 9,
                  "options": {
                    "packed": false
                  }
                },
                "reserved_name": {
                  "rule": "repeated",
                  "type": "string",
                  "id": 10
                }
              },
              "nested": {
                "ExtensionRange": {
                  "fields": {
                    "start": {
                      "type": "int32",
                      "id": 1
                    },
                    "end": {
                      "type": "int32",
                      "id": 2
                    }
                  }
                },
                "ReservedRange": {
                  "fields": {
                    "start": {
                      "type": "int32",
                      "id": 1
                    },
                    "end": {
                      "type": "int32",
                      "id": 2
                    }
                  }
                }
              }
            },
            "FieldDescriptorProto": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "number": {
                  "type": "int32",
                  "id": 3
                },
                "label": {
                  "type": "Label",
                  "id": 4
                },
                "type": {
                  "type": "Type",
                  "id": 5
                },
                "type_name": {
                  "type": "string",
                  "id": 6
                },
                "extendee": {
                  "type": "string",
                  "id": 2
                },
                "default_value": {
                  "type": "string",
                  "id": 7
                },
                "oneof_index": {
                  "type": "int32",
                  "id": 9
                },
                "json_name": {
                  "type": "string",
                  "id": 10
                },
                "options": {
                  "type": "FieldOptions",
                  "id": 8
                }
              },
              "nested": {
                "Type": {
                  "values": {
                    "TYPE_DOUBLE": 1,
                    "TYPE_FLOAT": 2,
                    "TYPE_INT64": 3,
                    "TYPE_UINT64": 4,
                    "TYPE_INT32": 5,
                    "TYPE_FIXED64": 6,
                    "TYPE_FIXED32": 7,
                    "TYPE_BOOL": 8,
                    "TYPE_STRING": 9,
                    "TYPE_GROUP": 10,
                    "TYPE_MESSAGE": 11,
                    "TYPE_BYTES": 12,
                    "TYPE_UINT32": 13,
                    "TYPE_ENUM": 14,
                    "TYPE_SFIXED32": 15,
                    "TYPE_SFIXED64": 16,
                    "TYPE_SINT32": 17,
                    "TYPE_SINT64": 18
                  }
                },
                "Label": {
                  "values": {
                    "LABEL_OPTIONAL": 1,
                    "LABEL_REQUIRED": 2,
                    "LABEL_REPEATED": 3
                  }
                }
              }
            },
            "OneofDescriptorProto": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "options": {
                  "type": "OneofOptions",
                  "id": 2
                }
              }
            },
            "EnumDescriptorProto": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "value": {
                  "rule": "repeated",
                  "type": "EnumValueDescriptorProto",
                  "id": 2,
                  "options": {
                    "packed": false
                  }
                },
                "options": {
                  "type": "EnumOptions",
                  "id": 3
                }
              }
            },
            "EnumValueDescriptorProto": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "number": {
                  "type": "int32",
                  "id": 2
                },
                "options": {
                  "type": "EnumValueOptions",
                  "id": 3
                }
              }
            },
            "ServiceDescriptorProto": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "method": {
                  "rule": "repeated",
                  "type": "MethodDescriptorProto",
                  "id": 2,
                  "options": {
                    "packed": false
                  }
                },
                "options": {
                  "type": "ServiceOptions",
                  "id": 3
                }
              }
            },
            "MethodDescriptorProto": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "input_type": {
                  "type": "string",
                  "id": 2
                },
                "output_type": {
                  "type": "string",
                  "id": 3
                },
                "options": {
                  "type": "MethodOptions",
                  "id": 4
                },
                "client_streaming": {
                  "type": "bool",
                  "id": 5
                },
                "server_streaming": {
                  "type": "bool",
                  "id": 6
                }
              }
            },
            "FileOptions": {
              "fields": {
                "java_package": {
                  "type": "string",
                  "id": 1
                },
                "java_outer_classname": {
                  "type": "string",
                  "id": 8
                },
                "java_multiple_files": {
                  "type": "bool",
                  "id": 10
                },
                "java_generate_equals_and_hash": {
                  "type": "bool",
                  "id": 20,
                  "options": {
                    "deprecated": true
                  }
                },
                "java_string_check_utf8": {
                  "type": "bool",
                  "id": 27
                },
                "optimize_for": {
                  "type": "OptimizeMode",
                  "id": 9,
                  "options": {
                    "default": "SPEED"
                  }
                },
                "go_package": {
                  "type": "string",
                  "id": 11
                },
                "cc_generic_services": {
                  "type": "bool",
                  "id": 16
                },
                "java_generic_services": {
                  "type": "bool",
                  "id": 17
                },
                "py_generic_services": {
                  "type": "bool",
                  "id": 18
                },
                "deprecated": {
                  "type": "bool",
                  "id": 23
                },
                "cc_enable_arenas": {
                  "type": "bool",
                  "id": 31
                },
                "objc_class_prefix": {
                  "type": "string",
                  "id": 36
                },
                "csharp_namespace": {
                  "type": "string",
                  "id": 37
                },
                "uninterpreted_option": {
                  "rule": "repeated",
                  "type": "UninterpretedOption",
                  "id": 999,
                  "options": {
                    "packed": false
                  }
                }
              },
              "extensions": [
                [
                  1000,
                  536870911
                ]
              ],
              "reserved": [
                [
                  38,
                  38
                ]
              ],
              "nested": {
                "OptimizeMode": {
                  "values": {
                    "SPEED": 1,
                    "CODE_SIZE": 2,
                    "LITE_RUNTIME": 3
                  }
                }
              }
            },
            "MessageOptions": {
              "fields": {
                "message_set_wire_format": {
                  "type": "bool",
                  "id": 1
                },
                "no_standard_descriptor_accessor": {
                  "type": "bool",
                  "id": 2
                },
                "deprecated": {
                  "type": "bool",
                  "id": 3
                },
                "map_entry": {
                  "type": "bool",
                  "id": 7
                },
                "uninterpreted_option": {
                  "rule": "repeated",
                  "type": "UninterpretedOption",
                  "id": 999,
                  "options": {
                    "packed": false
                  }
                }
              },
              "extensions": [
                [
                  1000,
                  536870911
                ]
              ],
              "reserved": [
                [
                  8,
                  8
                ]
              ]
            },
            "FieldOptions": {
              "fields": {
                "ctype": {
                  "type": "CType",
                  "id": 1,
                  "options": {
                    "default": "STRING"
                  }
                },
                "packed": {
                  "type": "bool",
                  "id": 2
                },
                "jstype": {
                  "type": "JSType",
                  "id": 6,
                  "options": {
                    "default": "JS_NORMAL"
                  }
                },
                "lazy": {
                  "type": "bool",
                  "id": 5
                },
                "deprecated": {
                  "type": "bool",
                  "id": 3
                },
                "weak": {
                  "type": "bool",
                  "id": 10
                },
                "uninterpreted_option": {
                  "rule": "repeated",
                  "type": "UninterpretedOption",
                  "id": 999,
                  "options": {
                    "packed": false
                  }
                }
              },
              "extensions": [
                [
                  1000,
                  536870911
                ]
              ],
              "reserved": [
                [
                  4,
                  4
                ]
              ],
              "nested": {
                "CType": {
                  "values": {
                    "STRING": 0,
                    "CORD": 1,
                    "STRING_PIECE": 2
                  }
                },
                "JSType": {
                  "values": {
                    "JS_NORMAL": 0,
                    "JS_STRING": 1,
                    "JS_NUMBER": 2
                  }
                }
              }
            },
            "OneofOptions": {
              "fields": {
                "uninterpreted_option": {
                  "rule": "repeated",
                  "type": "UninterpretedOption",
                  "id": 999,
                  "options": {
                    "packed": false
                  }
                }
              },
              "extensions": [
                [
                  1000,
                  536870911
                ]
              ]
            },
            "EnumOptions": {
              "fields": {
                "allow_alias": {
                  "type": "bool",
                  "id": 2
                },
                "deprecated": {
                  "type": "bool",
                  "id": 3
                },
                "uninterpreted_option": {
                  "rule": "repeated",
                  "type": "UninterpretedOption",
                  "id": 999,
                  "options": {
                    "packed": false
                  }
                }
              },
              "extensions": [
                [
                  1000,
                  536870911
                ]
              ]
            },
            "EnumValueOptions": {
              "fields": {
                "deprecated": {
                  "type": "bool",
                  "id": 1
                },
                "uninterpreted_option": {
                  "rule": "repeated",
                  "type": "UninterpretedOption",
                  "id": 999,
                  "options": {
                    "packed": false
                  }
                }
              },
              "extensions": [
                [
                  1000,
                  536870911
                ]
              ]
            },
            "ServiceOptions": {
              "fields": {
                "deprecated": {
                  "type": "bool",
                  "id": 33
                },
                "uninterpreted_option": {
                  "rule": "repeated",
                  "type": "UninterpretedOption",
                  "id": 999,
                  "options": {
                    "packed": false
                  }
                }
              },
              "extensions": [
                [
                  1000,
                  536870911
                ]
              ]
            },
            "MethodOptions": {
              "fields": {
                "deprecated": {
                  "type": "bool",
                  "id": 33
                },
                "uninterpreted_option": {
                  "rule": "repeated",
                  "type": "UninterpretedOption",
                  "id": 999,
                  "options": {
                    "packed": false
                  }
                }
              },
              "extensions": [
                [
                  1000,
                  536870911
                ]
              ]
            },
            "UninterpretedOption": {
              "fields": {
                "name": {
                  "rule": "repeated",
                  "type": "NamePart",
                  "id": 2,
                  "options": {
                    "packed": false
                  }
                },
                "identifier_value": {
                  "type": "string",
                  "id": 3
                },
                "positive_int_value": {
                  "type": "uint64",
                  "id": 4
                },
                "negative_int_value": {
                  "type": "int64",
                  "id": 5
                },
                "double_value": {
                  "type": "double",
                  "id": 6
                },
                "string_value": {
                  "type": "bytes",
                  "id": 7
                },
                "aggregate_value": {
                  "type": "string",
                  "id": 8
                }
              },
              "nested": {
                "NamePart": {
                  "fields": {
                    "name_part": {
                      "rule": "required",
                      "type": "string",
                      "id": 1
                    },
                    "is_extension": {
                      "rule": "required",
                      "type": "bool",
                      "id": 2
                    }
                  }
                }
              }
            },
            "SourceCodeInfo": {
              "fields": {
                "location": {
                  "rule": "repeated",
                  "type": "Location",
                  "id": 1,
                  "options": {
                    "packed": false
                  }
                }
              },
              "nested": {
                "Location": {
                  "fields": {
                    "path": {
                      "rule": "repeated",
                      "type": "int32",
                      "id": 1,
                      "options": {
                        "packed": true
                      }
                    },
                    "span": {
                      "rule": "repeated",
                      "type": "int32",
                      "id": 2,
                      "options": {
                        "packed": true
                      }
                    },
                    "leading_comments": {
                      "type": "string",
                      "id": 3
                    },
                    "trailing_comments": {
                      "type": "string",
                      "id": 4
                    },
                    "leading_detached_comments": {
                      "rule": "repeated",
                      "type": "string",
                      "id": 6
                    }
                  }
                }
              }
            },
            "GeneratedCodeInfo": {
              "fields": {
                "annotation": {
                  "rule": "repeated",
                  "type": "Annotation",
                  "id": 1,
                  "options": {
                    "packed": false
                  }
                }
              },
              "nested": {
                "Annotation": {
                  "fields": {
                    "path": {
                      "rule": "repeated",
                      "type": "int32",
                      "id": 1,
                      "options": {
                        "packed": true
                      }
                    },
                    "source_file": {
                      "type": "string",
                      "id": 2
                    },
                    "begin": {
                      "type": "int32",
                      "id": 3
                    },
                    "end": {
                      "type": "int32",
                      "id": 4
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
syntax = "proto2";

package google.protobuf;

message FileDescriptorSet {

    repeated FileDescriptorProto file = 1;
}

message FileDescriptorProto {

    optional string name = 1;
    optional string package = 2;
    repeated string dependency = 3;
    repeated int32 public_dependency = 10;
    repeated int32 weak_dependency = 11;
    repeated DescriptorProto message_type = 4;
    repeated EnumDescriptorProto enum_type = 5;
    repeated ServiceDescriptorProto service = 6;
    repeated FieldDescriptorProto extension = 7;
    optional FileOptions options = 8;
    optional SourceCodeInfo source_code_info = 9;
    optional string syntax = 12;
}

message DescriptorProto {

    optional string name = 1;
    repeated FieldDescriptorProto field = 2;
    repeated FieldDescriptorProto extension = 6;
    repeated DescriptorProto nested_type = 3;
    repeated EnumDescriptorProto enum_type = 4;
    repeated ExtensionRange extension_range = 5;
    repeated OneofDescriptorProto oneof_decl = 8;
    optional MessageOptions options = 7;
    repeated ReservedRange reserved_range = 9;
    repeated string reserved_name = 10;

    message ExtensionRange {

        optional int32 start = 1;
        optional int32 end = 2;
    }

    message ReservedRange {

        optional int32 start = 1;
        optional int32 end = 2;
    }
}

message FieldDescriptorProto {

    optional string name = 1;
    optional int32 number = 3;
    optional Label label = 4;
    optional Type type = 5;
    optional string type_name = 6;
    optional string extendee = 2;
    optional string default_value = 7;
    optional int32 oneof_index = 9;
    optional string json_name = 10;
    optional FieldOptions options = 8;

    enum Type {

        TYPE_DOUBLE = 1;
        TYPE_FLOAT = 2;
        TYPE_INT64 = 3;
        TYPE_UINT64 = 4;
        TYPE_INT32 = 5;
        TYPE_FIXED64 = 6;
        TYPE_FIXED32 = 7;
        TYPE_BOOL = 8;
        TYPE_STRING = 9;
        TYPE_GROUP = 10;
        TYPE_MESSAGE = 11;
        TYPE_BYTES = 12;
        TYPE_UINT32 = 13;
        TYPE_ENUM = 14;
        TYPE_SFIXED32 = 15;
        TYPE_SFIXED64 = 16;
        TYPE_SINT32 = 17;
        TYPE_SINT64 = 18;
    }

    enum Label {

        LABEL_OPTIONAL = 1;
        LABEL_REQUIRED = 2;
        LABEL_REPEATED = 3;
    }
}

message OneofDescriptorProto {

    optional string name = 1;
    optional OneofOptions options = 2;
}

message EnumDescriptorProto {

    optional string name = 1;
    repeated EnumValueDescriptorProto value = 2;
    optional EnumOptions options = 3;
}

message EnumValueDescriptorProto {

    optional string name = 1;
    optional int32 number = 2;
    optional EnumValueOptions options = 3;
}

message ServiceDescriptorProto {

    optional string name = 1;
    repeated MethodDescriptorProto method = 2;
    optional ServiceOptions options = 3;
}

message MethodDescriptorProto {

    optional string name = 1;
    optional string input_type = 2;
    optional string output_type = 3;
    optional MethodOptions options = 4;
    optional bool client_streaming = 5;
    optional bool server_streaming = 6;
}

message FileOptions {

    optional string java_package = 1;
    optional string java_outer_classname = 8;
    optional bool java_multiple_files = 10;
    optional bool java_generate_equals_and_hash = 20 [deprecated=true];
    optional bool java_string_check_utf8 = 27;
    optional OptimizeMode optimize_for = 9 [default=SPEED];
    optional string go_package = 11;
    optional bool cc_generic_services = 16;
    optional bool java_generic_services = 17;
    optional bool py_generic_services = 18;
    optional bool deprecated = 23;
    optional bool cc_enable_arenas = 31;
    optional string objc_class_prefix = 36;
    optional string csharp_namespace = 37;
    repeated UninterpretedOption uninterpreted_option = 999;

    enum OptimizeMode {

        SPEED = 1;
        CODE_SIZE = 2;
        LITE_RUNTIME = 3;
    }

    extensions 1000 to max;

    reserved 38;
}

message MessageOptions {

    optional bool message_set_wire_format = 1;
    optional bool no_standard_descriptor_accessor = 2;
    optional bool deprecated = 3;
    optional bool map_entry = 7;
    repeated UninterpretedOption uninterpreted_option = 999;

    extensions 1000 to max;

    reserved 8;
}

message FieldOptions {

    optional CType ctype = 1 [default=STRING];
    optional bool packed = 2;
    optional JSType jstype = 6 [default=JS_NORMAL];
    optional bool lazy = 5;
    optional bool deprecated = 3;
    optional bool weak = 10;
    repeated UninterpretedOption uninterpreted_option = 999;

    enum CType {

        STRING = 0;
        CORD = 1;
        STRING_PIECE = 2;
    }

    enum JSType {

        JS_NORMAL = 0;
        JS_STRING = 1;
        JS_NUMBER = 2;
    }

    extensions 1000 to max;

    reserved 4;
}

message OneofOptions {

    repeated UninterpretedOption uninterpreted_option = 999;

    extensions 1000 to max;
}

message EnumOptions {

    optional bool allow_alias = 2;
    optional bool deprecated = 3;
    repeated UninterpretedOption uninterpreted_option = 999;

    extensions 1000 to max;
}

message EnumValueOptions {

    optional bool deprecated = 1;
    repeated UninterpretedOption uninterpreted_option = 999;

    extensions 1000 to max;
}

message ServiceOptions {

    optional bool deprecated = 33;
    repeated UninterpretedOption uninterpreted_option = 999;

    extensions 1000 to max;
}

message MethodOptions {

    optional bool deprecated = 33;
    repeated UninterpretedOption uninterpreted_option = 999;

    extensions 1000 to max;
}

message UninterpretedOption {

    repeated NamePart name = 2;
    optional string identifier_value = 3;
    optional uint64 positive_int_value = 4;
    optional int64 negative_int_value = 5;
    optional double double_value = 6;
    optional bytes string_value = 7;
    optional string aggregate_value = 8;

    message NamePart {

        required string name_part = 1;
        required bool is_extension = 2;
    }
}

message SourceCodeInfo {

    repeated Location location = 1;

    message Location {

        repeated int32 path = 1 [packed=true];
        repeated int32 span = 2 [packed=true];
        optional string leading_comments = 3;
        optional string trailing_comments = 4;
        repeated string leading_detached_comments = 6;
    }
}

message GeneratedCodeInfo {

    repeated Annotation annotation = 1;

    message Annotation {

        repeated int32 path = 1 [packed=true];
        optional string source_file = 2;
        optional int32 begin = 3;
        optional int32 end = 4;
    }
}
{
  "nested": {
    "google": {
      "nested": {
        "protobuf": {
          "nested": {
            "SourceContext": {
              "fields": {
                "file_name": {
                  "type": "string",
                  "id": 1
                }
              }
            }
          }
        }
      }
    }
  }
}
syntax = "proto3";

package google.protobuf;

message SourceContext {
    string file_name = 1;
}
{
  "nested": {
    "google": {
      "nested": {
        "protobuf": {
          "nested": {
            "Type": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "fields": {
                  "rule": "repeated",
                  "type": "Field",
                  "id": 2
                },
                "oneofs": {
                  "rule": "repeated",
                  "type": "string",
                  "id": 3
                },
                "options": {
                  "rule": "repeated",
                  "type": "Option",
                  "id": 4
                },
                "source_context": {
                  "type": "SourceContext",
                  "id": 5
                },
                "syntax": {
                  "type": "Syntax",
                  "id": 6
                }
              }
            },
            "Field": {
              "fields": {
                "kind": {
                  "type": "Kind",
                  "id": 1
                },
                "cardinality": {
                  "type": "Cardinality",
                  "id": 2
                },
                "number": {
                  "type": "int32",
                  "id": 3
                },
                "name": {
                  "type": "string",
                  "id": 4
                },
                "type_url": {
                  "type": "string",
                  "id": 6
                },
                "oneof_index": {
                  "type": "int32",
                  "id": 7
                },
                "packed": {
                  "type": "bool",
                  "id": 8
                },
                "options": {
                  "rule": "repeated",
                  "type": "Option",
                  "id": 9
                },
                "json_name": {
                  "type": "string",
                  "id": 10
                },
                "default_value": {
                  "type": "string",
                  "id": 11
                }
              },
              "nested": {
                "Kind": {
                  "values": {
                    "TYPE_UNKNOWN": 0,
                    "TYPE_DOUBLE": 1,
                    "TYPE_FLOAT": 2,
                    "TYPE_INT64": 3,
                    "TYPE_UINT64": 4,
                    "TYPE_INT32": 5,
                    "TYPE_FIXED64": 6,
                    "TYPE_FIXED32": 7,
                    "TYPE_BOOL": 8,
                    "TYPE_STRING": 9,
                    "TYPE_GROUP": 10,
                    "TYPE_MESSAGE": 11,
                    "TYPE_BYTES": 12,
                    "TYPE_UINT32": 13,
                    "TYPE_ENUM": 14,
                    "TYPE_SFIXED32": 15,
                    "TYPE_SFIXED64": 16,
                    "TYPE_SINT32": 17,
                    "TYPE_SINT64": 18
                  }
                },
                "Cardinality": {
                  "values": {
                    "CARDINALITY_UNKNOWN": 0,
                    "CARDINALITY_OPTIONAL": 1,
                    "CARDINALITY_REQUIRED": 2,
                    "CARDINALITY_REPEATED": 3
                  }
                }
              }
            },
            "Enum": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "enumvalue": {
                  "rule": "repeated",
                  "type": "EnumValue",
                  "id": 2
                },
                "options": {
                  "rule": "repeated",
                  "type": "Option",
                  "id": 3
                },
                "source_context": {
                  "type": "SourceContext",
                  "id": 4
                },
                "syntax": {
                  "type": "Syntax",
                  "id": 5
                }
              }
            },
            "EnumValue": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "number": {
                  "type": "int32",
                  "id": 2
                },
                "options": {
                  "rule": "repeated",
                  "type": "Option",
                  "id": 3
                }
              }
            },
            "Option": {
              "fields": {
                "name": {
                  "type": "string",
                  "id": 1
                },
                "value": {
                  "type": "Any",
                  "id": 2
                }
              }
            },
            "Syntax": {
              "values": {
                "SYNTAX_PROTO2": 0,
                "SYNTAX_PROTO3": 1
              }
            },
            "Any": {
              "fields": {
                "type_url": {
                  "type": "string",
                  "id": 1
                },
                "value": {
                  "type": "bytes",
                  "id": 2
                }
              }
            },
            "SourceContext": {
              "fields": {
                "file_name": {
                  "type": "string",
                  "id": 1
                }
              }
            }
          }
        }
      }
    }
  }
}
syntax = "proto3";

package google.protobuf;

import "google/protobuf/any.proto";
import "google/protobuf/source_context.proto";

message Type {

    string name = 1;
    repeated Field fields = 2;
    repeated string oneofs = 3;
    repeated Option options = 4;
    SourceContext source_context = 5;
    Syntax syntax = 6;
}

message Field {

    Kind kind = 1;
    Cardinality cardinality = 2;
    int32 number = 3;
    string name = 4;
    string type_url = 6;
    int32 oneof_index = 7;
    bool packed = 8;
    repeated Option options = 9;
    string json_name = 10;
    string default_value = 11;

    enum Kind {

        TYPE_UNKNOWN = 0;
        TYPE_DOUBLE = 1;
        TYPE_FLOAT = 2;
        TYPE_INT64 = 3;
        TYPE_UINT64 = 4;
        TYPE_INT32 = 5;
        TYPE_FIXED64 = 6;
        TYPE_FIXED32 = 7;
        TYPE_BOOL = 8;
        TYPE_STRING = 9;
        TYPE_GROUP = 10;
        TYPE_MESSAGE = 11;
        TYPE_BYTES = 12;
        TYPE_UINT32 = 13;
        TYPE_ENUM = 14;
        TYPE_SFIXED32 = 15;
        TYPE_SFIXED64 = 16;
        TYPE_SINT32 = 17;
        TYPE_SINT64 = 18;
    }

    enum Cardinality {

        CARDINALITY_UNKNOWN = 0;
        CARDINALITY_OPTIONAL = 1;
        CARDINALITY_REQUIRED = 2;
        CARDINALITY_REPEATED = 3;
    }
}

message Enum {

    string name = 1;
    repeated EnumValue enumvalue = 2;
    repeated Option options = 3;
    SourceContext source_context = 4;
    Syntax syntax = 5;
}

message EnumValue {

    string name = 1;
    int32 number = 2;
    repeated Option options = 3;
}

message Option {

    string name = 1;
    Any value = 2;
}

enum Syntax {

    SYNTAX_PROTO2 = 0;
    SYNTAX_PROTO3 = 1;
}
{
  "nested": {
    "google": {
      "nested": {
        "rpc": {
          "nested": {
            "RetryInfo": {
              "fields": {
                "retry_delay": {
                  "type": "Duration",
                  "id": 1
                }
              },
              "nested": {
                "Duration": {
                  "fields": {
                    "seconds": {
                      "type": "int64",
                      "id": 1
                    },
                    "nanos": {
                      "type": "int32",
                      "id": 2
                    }
                  }
                }
              }
            },
            "DebugInfo": {
              "fields": {
                "stack_entries": {
                  "rule": "repeated",
                  "type": "string",
                  "id": 1
                },
                "detail": {
                  "type": "string",
                  "id": 2
                }
              }
            },
            "QuotaFailure": {
              "fields": {
                "violations": {
                  "rule": "repeated",
                  "type": "Violation",
                  "id": 1
                }
              },
              "nested": {
                "Violation": {
                  "fields": {
                    "subject": {
                      "type": "string",
                      "id": 1
                    },
                    "description": {
                      "type": "string",
                      "id": 2
                    }
                  }
                }
              }
            },
            "ErrorInfo": {
              "fields": {
                "reason": {
                  "type": "string",
                  "id": 1
                },
                "domain": {
                  "type": "string",
                  "id": 2
                },
                "metadata": {
                  "keyType": "string",
                  "type": "string",
                  "id": 3
                }
              }
            },
            "PreconditionFailure": {
              "fields": {
                "violations": {
                  "rule": "repeated",
                  "type": "Violation",
                  "id": 1
                }
              },
              "nested": {
                "Violation": {
                  "fields": {
                    "type": {
                      "type": "string",
                      "id": 1
                    },
                    "subject": {
                      "type": "string",
                      "id": 2
                    },
                    "description": {
                      "type": "string",
                      "id": 3
                    }
                  }
                }
              }
            },
            "BadRequest": {
              "fields": {
                "field_violations": {
                  "rule": "repeated",
                  "type": "FieldViolation",
                  "id": 1
                }
              },
              "nested": {
                "FieldViolation": {
                  "fields": {
                    "field": {
                      "type": "string",
                      "id": 1
                    },
                    "description": {
                      "type": "string",
                      "id": 2
                    }
                  }
                }
              }
            },
            "RequestInfo": {
              "fields": {
                "request_id": {
                  "type": "string",
                  "id": 1
                },
                "serving_data": {
                  "type": "string",
                  "id": 2
                }
              }
            },
            "ResourceInfo": {
              "fields": {
                "resource_type": {
                  "type": "string",
                  "id": 1
                },
                "resource_name": {
                  "type": "string",
                  "id": 2
                },
                "owner": {
                  "type": "string",
                  "id": 3
                },
                "description": {
                  "type": "string",
                  "id": 4
                }
              }
            },
            "Help": {
              "fields": {
                "links": {
                  "rule": "repeated",
                  "type": "Link",
                  "id": 1
                }
              },
              "nested": {
                "Link": {
                  "fields": {
                    "description": {
                      "type": "string",
                      "id": 1
                    },
                    "url": {
                      "type": "string",
                      "id": 2
                    }
                  }
                }
              }
            },
            "LocalizedMessage": {
              "fields": {
                "locale": {
                  "type": "string",
                  "id": 1
                },
                "message": {
                  "type": "string",
                  "id": 2
                }
              }
            }
          }
        }
      }
    }
  }
}
syntax = "proto3";

package google.rpc;

message RetryInfo {
  message Duration {
    int64 seconds = 1;
    int32 nanos = 2;
  }

  Duration retry_delay = 1;
}

message DebugInfo {
  repeated string stack_entries = 1;
  string detail = 2;
}

message QuotaFailure {
  message Violation {
    string subject = 1;
    string description = 2;
  }

  repeated Violation violations = 1;
}

message ErrorInfo {
  string reason = 1;
  string domain = 2;
  map<string, string> metadata = 3;
}

message PreconditionFailure {
  message Violation {
    string type = 1;
    string subject = 2;
    string description = 3;
  }

  repeated Violation violations = 1;
}

message BadRequest {
  message FieldViolation {
    string field = 1;
    string description = 2;
  }

  repeated FieldViolation field_violations = 1;
}

message RequestInfo {
  string request_id = 1;
  string serving_data = 2;
}

message ResourceInfo {
  string resource_type = 1;
  string resource_name = 2;
  string owner = 3;
  string description = 4;
}

message Help {
  message Link {
    string description = 1;
    string url = 2;
  }

  repeated Link links = 1;
}

message LocalizedMessage {
  string locale = 1;
  string message = 2;
}
{
  "nested": {
    "google": {
      "nested": {
        "protobuf": {
          "nested": {
            "Any": {
              "fields": {
                "type_url": {
                  "type": "string",
                  "id": 1
                },
                "value": {
                  "type": "bytes",
                  "id": 2
                }
              }
            }
          }
        },
        "rpc": {
          "nested": {
            "Status": {
              "fields": {
                "code": {
                  "type": "int32",
                  "id": 1
                },
                "message": {
                  "type": "string",
                  "id": 2
                },
                "details": {
                  "rule": "repeated",
                  "type": "google.protobuf.Any",
                  "id": 3
                }
              }
            }
          }
        }
      }
    }
  }
}
syntax = "proto3";

package google.rpc;

import "google/protobuf/any.proto";

message Status {
  int32 code = 1;
  string message = 2;
  repeated google.protobuf.Any details = 3;
}
import * as Protobuf from '@postman/protobufjs';
export type MethodKind = 'unary' | 'client-stream' | 'server-stream' | 'bidi';
export declare class Definition {
    readonly methods: ReadonlyMap<string, Method>;
    constructor(descriptor: unknown);
}
export declare class Method {
    readonly name: string;
    readonly comment: string | null;
    readonly kind: MethodKind;
    readonly requestType: Type;
    readonly responseType: Type;
    constructor(node: Protobuf.Method);
}
export declare class Type {
    readonly name: string;
    readonly comment: string | null;
    readonly astNode: Protobuf.Type;
    private _jsonSchema;
    constructor(node: Protobuf.Type);
    get jsonSchema(): any;
    validate(json: string): boolean;
}
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Type = exports.Method = exports.Definition = void 0;
const ajv_1 = __importDefault(require("ajv"));
const Protobuf = __importStar(require("@postman/protobufjs"));
const descriptors_1 = require("./descriptors");
const generate_json_schema_1 = __importDefault(require("./generate-json-schema"));
// A Definition represents a parsed Protobuf descriptor, and contains
// information about all methods defined within the descriptor.
class Definition {
    constructor(descriptor) {
        const jsonDescriptor = (0, descriptors_1.toJSONDescriptor)(descriptor);
        const root = Protobuf.Root.fromJSON(jsonDescriptor).resolveAll();
        const methods = new Map();
        (function walk(node) {
            if (node instanceof Protobuf.Service) {
                for (const methodNode of node.methodsArray) {
                    const method = new Method(methodNode);
                    methods.set(method.name, method);
                }
            }
            else if (node instanceof Protobuf.Namespace) {
                node.nestedArray.forEach(walk);
            }
        })(root);
        this.methods = methods;
    }
}
exports.Definition = Definition;
class Method {
    constructor(node) {
        if (!node.resolvedRequestType || !node.resolvedResponseType) {
            throw new TypeError('The given AST node must be fully resolved');
        }
        this.name = node.fullName.replace(/^\./, '');
        this.comment = node.comment;
        this.kind =
            node.requestStream ?
                node.responseStream ?
                    'bidi'
                    : 'client-stream'
                : node.responseStream ? 'server-stream'
                    : 'unary';
        this.requestType = new Type(node.resolvedRequestType);
        this.responseType = new Type(node.resolvedResponseType);
    }
}
exports.Method = Method;
class Type {
    constructor(node) {
        if (!node.resolved) {
            throw new TypeError('The given AST node must be fully resolved');
        }
        this.name = node.fullName.replace(/^\./, '');
        this.comment = node.comment;
        this.astNode = node;
    }
    get jsonSchema() {
        if (this._jsonSchema === undefined) {
            this._jsonSchema = (0, generate_json_schema_1.default)(this.astNode);
        }
        return this._jsonSchema;
    }
    validate(json) {
        if (typeof json !== 'string') {
            // This provides a better error for non-TypeScript applications.
            throw new TypeError('Expected Protobuf message to be a JSON string');
        }
        const validate = new ajv_1.default({ strict: false }).compile(this.jsonSchema);
        try {
            return validate(JSON.parse(json));
        }
        catch (_) {
            return false;
        }
    }
}
exports.Type = Type;
//# sourceMappingURL=definition.js.map{"version":3,"file":"definition.js","sourceRoot":"","sources":["../src/definition.ts"],"names":[],"mappings":"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"}export declare function toJSONDescriptor(descriptor: unknown): object;
export declare function toBinaryDescriptor(descriptor: unknown): Uint8Array;
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toBinaryDescriptor = exports.toJSONDescriptor = void 0;
const Protobuf = __importStar(require("@postman/protobufjs"));
const descriptor_1 = require("@postman/protobufjs/ext/descriptor");
const js_base64_1 = require("js-base64");
const TO_JSON_OPTIONS = { keepComments: true };
// Accepts either a JSON descriptor, a binary descriptor, or a base-64-encoded
// binary descriptor, and returns a parsed JSON descriptor.
function toJSONDescriptor(descriptor) {
    if (typeof descriptor === 'string') {
        if (descriptor.startsWith('{')) {
            descriptor = JSON.parse(descriptor);
        }
        else if (/^[a-zA-Z0-9+/=]+\s*$/.test(descriptor)) {
            descriptor = js_base64_1.Base64.toUint8Array(descriptor);
        }
    }
    if (descriptor instanceof Uint8Array) {
        return Protobuf.Root.fromDescriptor(descriptor, {
            useMapField: true,
        }).toJSON(TO_JSON_OPTIONS);
    }
    if (typeof descriptor === 'object' &&
        descriptor !== null &&
        typeof descriptor.nested === 'object' &&
        descriptor.nested !== null) {
        return descriptor;
    }
    throw new TypeError('Invalid Protobuf descriptor');
}
exports.toJSONDescriptor = toJSONDescriptor;
// Accepts either a JSON descriptor, a binary descriptor, or a base-64-encoded
// binary descriptor, and returns a binary descriptor.
function toBinaryDescriptor(descriptor) {
    const jsonDescriptor = toJSONDescriptor(descriptor);
    const root = Protobuf.Root.fromJSON(jsonDescriptor);
    root.resolveAll();
    return descriptor_1.FileDescriptorSet.encode(root.toDescriptor()).finish();
}
exports.toBinaryDescriptor = toBinaryDescriptor;
//# sourceMappingURL=descriptors.js.map{"version":3,"file":"descriptors.js","sourceRoot":"","sources":["../src/descriptors.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,8DAAgD;AAChD,mEAAuE;AACvE,yCAAmC;AAEnC,MAAM,eAAe,GAAG,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC;AAE/C,8EAA8E;AAC9E,2DAA2D;AAC3D,SAAgB,gBAAgB,CAAC,UAAmB;IACnD,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE,CAAC;QACpC,IAAI,UAAU,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE,CAAC;YAChC,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;QACrC,CAAC;aAAM,IAAI,sBAAsB,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC;YACpD,UAAU,GAAG,kBAAM,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;QAC9C,CAAC;IACF,CAAC;IAED,IAAI,UAAU,YAAY,UAAU,EAAE,CAAC;QACtC,OAAO,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,UAAU,EAAE;YAC/C,WAAW,EAAE,IAAI;SACjB,CAAC,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC;IAC5B,CAAC;IAED,IACC,OAAO,UAAU,KAAK,QAAQ;QAC9B,UAAU,KAAK,IAAI;QACnB,OAAQ,UAAkB,CAAC,MAAM,KAAK,QAAQ;QAC7C,UAAkB,CAAC,MAAM,KAAK,IAAI,EAClC,CAAC;QACF,OAAO,UAAU,CAAC;IACnB,CAAC;IAED,MAAM,IAAI,SAAS,CAAC,6BAA6B,CAAC,CAAC;AACpD,CAAC;AAzBD,4CAyBC;AAED,8EAA8E;AAC9E,sDAAsD;AACtD,SAAgB,kBAAkB,CAAC,UAAmB;IACrD,MAAM,cAAc,GAAG,gBAAgB,CAAC,UAAU,CAAC,CAAC;IACpD,MAAM,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;IACpD,IAAI,CAAC,UAAU,EAAE,CAAC;IAClB,OAAO,8BAAiB,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC;AAC/D,CAAC;AALD,gDAKC"}import Protobuf from '@postman/protobufjs';
export default function generateJSONSchema(rootType: Protobuf.Type): any;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const protobufjs_1 = __importDefault(require("@postman/protobufjs"));
const js_base64_1 = require("js-base64");
// Generates a JSON Schema that describes the given Protobuf.Type.
function generateJSONSchema(rootType) {
    const definitions = {};
    const jsonPointers = new Map();
    const requiredByUser = new Set();
    const mapFieldPaths = [];
    const currFieldPath = [];
    return {
        $schema: 'http://json-schema.org/draft-07/schema',
        definitions,
        ...declareSchema(rootType),
        // caching the paths to map fields so that we can
        // efficiently sanitize the payload at runtime
        mapFields: mapFieldPaths,
    };
    // Returns a (memoized) subschema that describes the given Type or Enum.
    function declareSchema(type) {
        let jsonPointer = jsonPointers.get(type);
        if (!jsonPointer) {
            jsonPointer = `#/definitions/${type.fullName}`;
            jsonPointers.set(type, jsonPointer);
            definitions[type.fullName] = generateSchema(type);
        }
        return { $ref: jsonPointer };
    }
    // Generates a new (not memoized) subschema from the given Type or Enum.
    function generateSchema(type) {
        if (type instanceof protobufjs_1.default.Enum) {
            const enumValues = [
                ...Object.keys(type.values), // Enum names (strings)
                ...Object.values(type.values), // Enum ids (integers)
                null,
            ];
            return {
                enum: Array.from(new Set(enumValues)),
                title: `enum ${type.name}`,
                description: `${Object.entries(type.values)
                    .map(([k, v]) => `${JSON.stringify(k)} (${v})`)
                    .join(' | ')}`,
                default: type.valuesById[0] || 0,
            };
        }
        if (type instanceof protobufjs_1.default.Type) {
            let isEmpty = true;
            const properties = {};
            const required = [];
            for (const field of Object.values(type.fields)) {
                isEmpty = false;
                currFieldPath.push(field.name);
                applyField(field, properties, required);
                currFieldPath.pop();
            }
            if (!isEmpty) {
                // Only non-empty message types are actually required. Everything else has a default value.
                requiredByUser.add(type);
            }
            return {
                type: isEmpty ? ['object', 'null'] : 'object',
                properties,
                required,
                additionalProperties: { title: 'Unknown field' },
                title: `message ${type.name}`,
                description: `{ ${Object.keys(type.fields).join(', ')} }`,
                default: {},
            };
        }
        console.warn(`Unrecognized Protobuf class: ${type && type.constructor.name}`);
        return {};
    }
    // Augments a "properties" object and "required" array with a given field.
    function applyField(field, properties, required) {
        let schema;
        if (field.resolvedType) {
            schema = declareSchema(field.resolvedType);
        }
        else {
            schema = getKnownSchema(field.type);
            schema.title = field.type;
            schema.default = normalizeProtobufValue(field.typeDefault);
        }
        if (field.map) {
            const keyType = field.keyType;
            schema = {
                oneOf: [
                    // JSON representation
                    {
                        type: ['object', 'null'],
                        additionalProperties: schema,
                        title: `map<${keyType}, ${field.type}>`,
                        default: {},
                    },
                    // Array representation for backward compatibility
                    // Due to how we previously decoded map fields, we need to support this
                    {
                        type: ['array', 'null'],
                        items: {
                            type: 'object',
                            properties: {
                                key: (() => {
                                    const keySchema = getKnownSchema(keyType);
                                    keySchema.title = keyType;
                                    return keySchema;
                                })(),
                                value: schema,
                            },
                            required: ['key', 'value'],
                            additionalProperties: false,
                        },
                        title: `repeated { "key: ${keyType}, "value": ${field.type} }`,
                        default: [],
                    },
                ],
                title: `map<${keyType}, ${field.type}>`,
                default: {},
            };
            mapFieldPaths.push(currFieldPath.join('.'));
        }
        else if (field.repeated) {
            schema = {
                type: ['array', 'null'],
                items: schema,
                title: `repeated ${field.type}`,
                default: [],
            };
        }
        else if (field.required) {
            if (requiredByUser.has(field.resolvedType)) {
                required.push(field.name);
            }
        }
        properties[field.name] = schema;
    }
}
exports.default = generateJSONSchema;
// Returns the subschema of a well-known Protobuf type.
function getKnownSchema(typeName) {
    switch (typeName) {
        case 'bool':
            return {
                type: ['boolean', 'null'],
            };
        case 'string':
            return {
                type: ['string', 'null'],
            };
        case 'bytes':
            return {
                type: ['string', 'array', 'null'],
                pattern: '^([a-zA-Z0-9+/]{4})*([a-zA-Z0-9+/]{2}(==)?|[a-zA-Z0-9+/]{3}=?)?$',
                items: {
                    type: 'integer',
                    default: 0,
                    minimum: 0,
                    maximum: 255,
                },
                description: 'A string of base64, or an array of numbers between 0 and 255',
            };
        case 'int32':
        case 'sint32':
        case 'sfixed32':
            return {
                type: ['integer', 'null'],
                minimum: -0x80000000,
                maximum: 0x7fffffff,
                description: 'An integer between -2147483648 and 2147483647',
            };
        case 'uint32':
        case 'fixed32':
            return {
                type: ['integer', 'null'],
                minimum: 0,
                maximum: 0xffffffff,
                description: 'An integer between 0 and 4294967295',
            };
        case 'int64':
        case 'sint64':
        case 'sfixed64':
            return {
                type: ['integer', 'string', 'null'],
                minimum: Number(0n - 2n ** 63n), // This is not precise, due to JavaScript
                maximum: Number(2n ** 63n - 1n), // This is not precise, due to JavaScript
                pattern: '^[0-9]+$', // Can't enforce numeric limits on strings
                description: 'An integer between -9223372036854775808 and 9223372036854775807',
            };
        case 'uint64':
        case 'fixed64':
            return {
                type: ['integer', 'string', 'null'],
                minimum: 0,
                maximum: Number(2n ** 64n - 1n), // This is not precise, due to JavaScript
                pattern: '^[0-9]+$', // Can't enforce numeric limits on strings
                description: 'An integer between 0 and 18446744073709551615',
            };
        case 'float':
        case 'double':
            return {
                anyOf: [
                    { type: ['number', 'null'] },
                    { type: 'string', enum: ['NaN', 'Infinity', '-Infinity'] },
                ],
                description: 'A number, or one of the strings "NaN", "Infinity", or "-Infinity"',
            };
        default:
            console.warn(`Unrecognized Protobuf type: ${typeName}`);
            return {};
    }
}
// Convert a Protobuf runtime value into a canonical JSON value.
function normalizeProtobufValue(value) {
    if (protobufjs_1.default.util.Long.isLong(value)) {
        return value.toString(10);
    }
    if (value instanceof Uint8Array) {
        return js_base64_1.Base64.fromUint8Array(value);
    }
    if (Array.isArray(value)) {
        return js_base64_1.Base64.fromUint8Array(new Uint8Array(value));
    }
    return value;
}
//# sourceMappingURL=generate-json-schema.js.map{"version":3,"file":"generate-json-schema.js","sourceRoot":"","sources":["../src/generate-json-schema.ts"],"names":[],"mappings":"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"}export * from './definition';
export * from './descriptors';
export * from './prune-descriptor';
export * from './parse-url';
export * from './status-details';
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const long_1 = __importDefault(require("long"));
const Protobuf = __importStar(require("@postman/protobufjs"));
// Needed for browser builds.
Protobuf.util.Long = long_1.default;
Protobuf.configure();
__exportStar(require("./definition"), exports);
__exportStar(require("./descriptors"), exports);
__exportStar(require("./prune-descriptor"), exports);
__exportStar(require("./parse-url"), exports);
__exportStar(require("./status-details"), exports);
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,gDAAwB;AACxB,8DAAgD;AAEhD,6BAA6B;AAC7B,QAAQ,CAAC,IAAI,CAAC,IAAI,GAAG,cAAI,CAAC;AAC1B,QAAQ,CAAC,SAAS,EAAE,CAAC;AAErB,+CAA6B;AAC7B,gDAA8B;AAC9B,qDAAmC;AACnC,8CAA4B;AAC5B,mDAAiC"}export interface ParsedURL {
    host: string;
    pathname: string;
    isTLS: boolean;
}
export declare function parseURL(str: string): ParsedURL;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseURL = void 0;
/*
    Parses a string URL and validates that it is appropriate for GRPC.
*/
function parseURL(str) {
    str = String(str); // For non-TypeScript applications
    if (!/^[a-z0-9+.-]+:\/\//i.test(str)) {
        str = `grpc://${str}`; // Default protocol
    }
    let url;
    try {
        url = new URL(str);
    }
    catch (_) {
        throw new Error(`Invalid URL "${str}"`);
    }
    if (url.protocol !== 'unix:' &&
        url.protocol !== 'grpc:' &&
        url.protocol !== 'http:' &&
        url.protocol !== 'https:') {
        throw new Error(`Invalid protocol "${url.protocol}//", try "grpc://" instead`);
    }
    return {
        host: url.protocol === 'unix:' ? url.href : url.host,
        pathname: url.protocol === 'unix:' ? '' : url.pathname,
        isTLS: url.protocol === 'https:',
    };
}
exports.parseURL = parseURL;
//# sourceMappingURL=parse-url.js.map{"version":3,"file":"parse-url.js","sourceRoot":"","sources":["../src/parse-url.ts"],"names":[],"mappings":";;;AAMA;;EAEE;AAEF,SAAgB,QAAQ,CAAC,GAAW;IACnC,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,kCAAkC;IAErD,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;QACtC,GAAG,GAAG,UAAU,GAAG,EAAE,CAAC,CAAC,mBAAmB;IAC3C,CAAC;IAED,IAAI,GAAG,CAAC;IACR,IAAI,CAAC;QACJ,GAAG,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;IACpB,CAAC;IAAC,OAAO,CAAC,EAAE,CAAC;QACZ,MAAM,IAAI,KAAK,CAAC,gBAAgB,GAAG,GAAG,CAAC,CAAC;IACzC,CAAC;IAED,IACC,GAAG,CAAC,QAAQ,KAAK,OAAO;QACxB,GAAG,CAAC,QAAQ,KAAK,OAAO;QACxB,GAAG,CAAC,QAAQ,KAAK,OAAO;QACxB,GAAG,CAAC,QAAQ,KAAK,QAAQ,EACxB,CAAC;QACF,MAAM,IAAI,KAAK,CACd,qBAAqB,GAAG,CAAC,QAAQ,4BAA4B,CAC7D,CAAC;IACH,CAAC;IAED,OAAO;QACN,IAAI,EAAE,GAAG,CAAC,QAAQ,KAAK,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI;QACpD,QAAQ,EAAE,GAAG,CAAC,QAAQ,KAAK,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,QAAQ;QACtD,KAAK,EAAE,GAAG,CAAC,QAAQ,KAAK,QAAQ;KAChC,CAAC;AACH,CAAC;AA9BD,4BA8BC"}export declare function pruneDescriptor(descriptor: unknown, methodPath: string): object;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pruneDescriptor = void 0;
const protobufjs_1 = __importDefault(require("@postman/protobufjs"));
const definition_1 = require("./definition");
const descriptors_1 = require("./descriptors");
// Given a Protobuf descriptor, this generates a new descriptor that only
// contains the entities that are required by the given method. This method
// always returns the descriptor in parsed JSON format.
function pruneDescriptor(descriptor, methodPath) {
    const jsonDescriptor = (0, descriptors_1.toJSONDescriptor)(descriptor);
    const definition = new definition_1.Definition(jsonDescriptor);
    const method = definition.methods.get(methodPath);
    if (!method) {
        throw new Error(`Method "${methodPath}" does not exist`);
    }
    // Recursively traverse Type/Enum references reachable from the Method node,
    // and remember each reachable entity's path from the root namespace.
    const paths = new Set(['.' + methodPath]);
    function visit(node) {
        if (node instanceof protobufjs_1.default.Enum) {
            paths.add(node.fullName);
        }
        else if (node instanceof protobufjs_1.default.Type) {
            if (!paths.has(node.fullName)) {
                paths.add(node.fullName);
                node.fieldsArray
                    .concat(...node.oneofsArray.map((oneof) => oneof.fieldsArray))
                    .forEach((field) => {
                    if (field.declaringField) {
                        paths.add(field.declaringField.fullName);
                    }
                    if (field.map) {
                        visit(field.resolvedKeyType);
                    }
                    visit(field.resolvedType);
                });
            }
        }
        else if (node != null) {
            console.warn(`Unrecognized Protobuf class: ${node && node.constructor.name}`);
        }
    }
    visit(method.requestType.astNode);
    visit(method.responseType.astNode);
    // Make a clone of the JSON descriptor, but with only the relevant paths.
    const prunedDescriptor = traverseAndPluck(jsonDescriptor, 
    // Split each string path into an array, trimming the leading ".".
    Array.from(paths).map((x) => x.split('.').slice(1)));
    // Make sure the method descriptor is valid, with no missing references.
    try {
        protobufjs_1.default.Root.fromJSON(prunedDescriptor).resolveAll();
    }
    catch (err) {
        throw new Error(`Unable to generate pruned method descriptor for "${methodPath}":\n` +
            JSON.stringify(jsonDescriptor, null, 4) +
            '\n\n' +
            `Original stack trace:\n${err.stack}`);
    }
    return prunedDescriptor;
}
exports.pruneDescriptor = pruneDescriptor;
// Clones a Protobuf JSON descriptor, with only the relevant key paths.
function traverseAndPluck(namespaceObject, paths, isItselfRelevant = false) {
    // Prevent mutations on the original object.
    namespaceObject = { ...namespaceObject };
    if (namespaceObject.nested || namespaceObject.methods) {
        if (namespaceObject.nested) {
            namespaceObject.nested = pluck(namespaceObject.nested, paths);
        }
        if (namespaceObject.methods) {
            namespaceObject.methods = pluck(namespaceObject.methods, paths);
        }
        // If this namespace is only relevant due to it containing relevant
        // children, then we must strip its fields, so they don't cause
        // false-positive "missing reference" errors.
        if (!isItselfRelevant) {
            if (namespaceObject.fields) {
                namespaceObject.fields = {};
            }
            if (namespaceObject.oneofs) {
                namespaceObject.oneofs = {};
            }
        }
    }
    return namespaceObject;
}
// Repeated logic used by traverseAndPluck().
function pluck(obj, paths) {
    const relevantKeys = new Map();
    for (const [key, ...childPath] of paths) {
        if (relevantKeys.has(key)) {
            relevantKeys.get(key).push(childPath);
        }
        else {
            relevantKeys.set(key, [childPath]);
        }
    }
    const plucked = {};
    for (const key of Object.keys(obj)) {
        if (relevantKeys.has(key)) {
            const childPathsRaw = relevantKeys.get(key);
            const childPaths = childPathsRaw.filter((path) => path.length);
            const isItselfRelevant = childPathsRaw.some((path) => !path.length);
            plucked[key] = traverseAndPluck(obj[key], childPaths, isItselfRelevant);
        }
    }
    return plucked;
}
//# sourceMappingURL=prune-descriptor.js.map{"version":3,"file":"prune-descriptor.js","sourceRoot":"","sources":["../src/prune-descriptor.ts"],"names":[],"mappings":";;;;;;AAAA,qEAA2C;AAC3C,6CAA0C;AAC1C,+CAAiD;AAEjD,yEAAyE;AACzE,2EAA2E;AAC3E,uDAAuD;AACvD,SAAgB,eAAe,CAC9B,UAAmB,EACnB,UAAkB;IAElB,MAAM,cAAc,GAAG,IAAA,8BAAgB,EAAC,UAAU,CAAC,CAAC;IACpD,MAAM,UAAU,GAAG,IAAI,uBAAU,CAAC,cAAc,CAAC,CAAC;IAClD,MAAM,MAAM,GAAG,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;IAElD,IAAI,CAAC,MAAM,EAAE,CAAC;QACb,MAAM,IAAI,KAAK,CAAC,WAAW,UAAU,kBAAkB,CAAC,CAAC;IAC1D,CAAC;IAED,4EAA4E;IAC5E,qEAAqE;IACrE,MAAM,KAAK,GAAG,IAAI,GAAG,CAAC,CAAC,GAAG,GAAG,UAAU,CAAC,CAAC,CAAC;IAC1C,SAAS,KAAK,CAAC,IAAkD;QAChE,IAAI,IAAI,YAAY,oBAAQ,CAAC,IAAI,EAAE,CAAC;YACnC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC1B,CAAC;aAAM,IAAI,IAAI,YAAY,oBAAQ,CAAC,IAAI,EAAE,CAAC;YAC1C,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC;gBAC/B,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBACzB,IAAI,CAAC,WAAW;qBACd,MAAM,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;qBAC7D,OAAO,CAAC,CAAC,KAAyB,EAAE,EAAE;oBACtC,IAAI,KAAK,CAAC,cAAc,EAAE,CAAC;wBAC1B,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;oBAC1C,CAAC;oBACD,IAAI,KAAK,CAAC,GAAG,EAAE,CAAC;wBACf,KAAK,CAAE,KAA2B,CAAC,eAAe,CAAC,CAAC;oBACrD,CAAC;oBACD,KAAK,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;gBAC3B,CAAC,CAAC,CAAC;YACL,CAAC;QACF,CAAC;aAAM,IAAI,IAAI,IAAI,IAAI,EAAE,CAAC;YACzB,OAAO,CAAC,IAAI,CACX,gCAAgC,IAAI,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,CAC/D,CAAC;QACH,CAAC;IACF,CAAC;IAED,KAAK,CAAC,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;IAClC,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;IAEnC,yEAAyE;IACzE,MAAM,gBAAgB,GAAG,gBAAgB,CACxC,cAAc;IACd,kEAAkE;IAClE,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CACnD,CAAC;IAEF,wEAAwE;IACxE,IAAI,CAAC;QACJ,oBAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC,UAAU,EAAE,CAAC;IACvD,CAAC;IAAC,OAAO,GAAQ,EAAE,CAAC;QACnB,MAAM,IAAI,KAAK,CACd,oDAAoD,UAAU,MAAM;YACnE,IAAI,CAAC,SAAS,CAAC,cAAc,EAAE,IAAI,EAAE,CAAC,CAAC;YACvC,MAAM;YACN,0BAA0B,GAAG,CAAC,KAAK,EAAE,CACtC,CAAC;IACH,CAAC;IAED,OAAO,gBAAgB,CAAC;AACzB,CAAC;AA/DD,0CA+DC;AAED,uEAAuE;AACvE,SAAS,gBAAgB,CACxB,eAAoB,EACpB,KAA2C,EAC3C,mBAA4B,KAAK;IAEjC,4CAA4C;IAC5C,eAAe,GAAG,EAAE,GAAG,eAAe,EAAE,CAAC;IAEzC,IAAI,eAAe,CAAC,MAAM,IAAI,eAAe,CAAC,OAAO,EAAE,CAAC;QACvD,IAAI,eAAe,CAAC,MAAM,EAAE,CAAC;YAC5B,eAAe,CAAC,MAAM,GAAG,KAAK,CAAC,eAAe,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;QAC/D,CAAC;QACD,IAAI,eAAe,CAAC,OAAO,EAAE,CAAC;YAC7B,eAAe,CAAC,OAAO,GAAG,KAAK,CAAC,eAAe,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QACjE,CAAC;QAED,mEAAmE;QACnE,+DAA+D;QAC/D,6CAA6C;QAC7C,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACvB,IAAI,eAAe,CAAC,MAAM,EAAE,CAAC;gBAC5B,eAAe,CAAC,MAAM,GAAG,EAAE,CAAC;YAC7B,CAAC;YACD,IAAI,eAAe,CAAC,MAAM,EAAE,CAAC;gBAC5B,eAAe,CAAC,MAAM,GAAG,EAAE,CAAC;YAC7B,CAAC;QACF,CAAC;IACF,CAAC;IAED,OAAO,eAAe,CAAC;AACxB,CAAC;AAED,6CAA6C;AAC7C,SAAS,KAAK,CACb,GAAwB,EACxB,KAA2C;IAE3C,MAAM,YAAY,GAAyC,IAAI,GAAG,EAAE,CAAC;IACrE,KAAK,MAAM,CAAC,GAAG,EAAE,GAAG,SAAS,CAAC,IAAI,KAAK,EAAE,CAAC;QACzC,IAAI,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC;YAC3B,YAAY,CAAC,GAAG,CAAC,GAAG,CAAE,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACxC,CAAC;aAAM,CAAC;YACP,YAAY,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACpC,CAAC;IACF,CAAC;IAED,MAAM,OAAO,GAAwB,EAAE,CAAC;IACxC,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;QACpC,IAAI,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC;YAC3B,MAAM,aAAa,GAAG,YAAY,CAAC,GAAG,CAAC,GAAG,CAAE,CAAC;YAC7C,MAAM,UAAU,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC/D,MAAM,gBAAgB,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACpE,OAAO,CAAC,GAAG,CAAC,GAAG,gBAAgB,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,UAAU,EAAE,gBAAgB,CAAC,CAAC;QACzE,CAAC;IACF,CAAC;IAED,OAAO,OAAO,CAAC;AAChB,CAAC"}export declare function unwrapStatusDetails(metadata: {
    key: string;
    value: string;
}[]): {
    [k: string]: any;
} | undefined;
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unwrapStatusDetails = void 0;
const Protobuf = __importStar(require("@postman/protobufjs"));
const js_base64_1 = require("js-base64");
const status_json_1 = __importDefault(require("../definitions/google/rpc/status.json"));
const error_details_json_1 = __importDefault(require("../definitions/google/rpc/error_details.json"));
const BASE64_RE = /^[a-zA-Z0-9+/=]*\s*$/;
let Status;
function unwrapStatusDetails(metadata) {
    const details = metadata.find((m) => m.key === 'grpc-status-details-bin')?.value;
    if (!details)
        return;
    if (!BASE64_RE.test(details)) {
        throw new Error('Invalid base64 string for "grpc-status-details-bin" key');
    }
    Status = Status ?? loadStatusType();
    if (!Status) {
        throw new Error('Failed to load google.rpc.Status');
    }
    return Status.decode(js_base64_1.Base64.toUint8Array(details)).toJSON();
}
exports.unwrapStatusDetails = unwrapStatusDetails;
function loadStatusType() {
    const root = new Protobuf.Root();
    root.addJSON(status_json_1.default.nested);
    root.addJSON(error_details_json_1.default.nested);
    return root.lookupType('google.rpc.Status');
}
//# sourceMappingURL=status-details.js.map{"version":3,"file":"status-details.js","sourceRoot":"","sources":["../src/status-details.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,8DAAgD;AAChD,yCAAmC;AACnC,wFAAiE;AACjE,sGAA+E;AAE/E,MAAM,SAAS,GAAG,sBAAsB,CAAC;AACzC,IAAI,MAAqB,CAAC;AAE1B,SAAgB,mBAAmB,CAClC,QAGG;IAEH,MAAM,OAAO,GAAG,QAAQ,CAAC,IAAI,CAC5B,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,GAAG,KAAK,yBAAyB,CAC1C,EAAE,KAAK,CAAC;IAET,IAAI,CAAC,OAAO;QAAE,OAAO;IACrB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC;QAC9B,MAAM,IAAI,KAAK,CAAC,yDAAyD,CAAC,CAAC;IAC5E,CAAC;IAED,MAAM,GAAG,MAAM,IAAI,cAAc,EAAE,CAAC;IACpC,IAAI,CAAC,MAAM,EAAE,CAAC;QACb,MAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;IACrD,CAAC;IAED,OAAO,MAAM,CAAC,MAAM,CAAC,kBAAM,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC;AAC7D,CAAC;AArBD,kDAqBC;AAED,SAAS,cAAc;IACtB,MAAM,IAAI,GAAG,IAAI,QAAQ,CAAC,IAAI,EAAE,CAAC;IAEjC,IAAI,CAAC,OAAO,CAAC,qBAAY,CAAC,MAAM,CAAC,CAAC;IAClC,IAAI,CAAC,OAAO,CAAC,4BAAmB,CAAC,MAAM,CAAC,CAAC;IACzC,OAAO,IAAI,CAAC,UAAU,CAAC,mBAAmB,CAAC,CAAC;AAC7C,CAAC"}{
  "name": "@postman/runtime.grpc-utils",
  "version": "0.2.3",
  "license": "UNLICENSED",
  "description": "Utilities for working with gRPC and Protobuf",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/utilities/grpc-utils#readme",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "dependencies": {
    "@postman/protobufjs": "^7.3.2-postman.3",
    "ajv": "^8.12.0",
    "js-base64": "^3.7.5",
    "long": "^5.2.3"
  },
  "files": [
    "*.js",
    "*.json",
    "definitions/**/*.{json,proto}",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest"
  }
}# grpc-utils

This package contains utilities for working with gRPC and Protobuf.
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": []
	}
}
import { SecureContextOptions } from '@postman/runtime.core';
import { Connection } from './connection';
export type ClientOptions = {
    url: string;
    tlsOptions?: tlsOptions | null;
    mqttOptions?: MQTTClientOptions | null;
};
export type tlsOptions = {
    rejectUnauthorized?: boolean;
    secureContext?: SecureContextOptions;
};
export type MQTTClientOptions = {
    clientId?: string;
    version?: 4 | 5;
    cleanSession?: boolean;
    keepAlive?: number;
    autoReconnect?: boolean;
    properties?: {
        sessionExpiryInterval?: number;
        receiveMaximum?: number;
        maximumPacketSize?: number;
        userProperties?: Array<{
            key: string;
            value: string;
            disabled?: boolean;
            description?: string;
        }>;
    };
    lastWill?: {
        payload?: string;
        topic?: string;
        qos?: number;
        retain?: boolean;
        properties?: {
            payloadFormatIndicator?: boolean;
            messageExpiryInterval?: number;
            willDelayInterval?: number;
            responseTopic?: string;
            correlationData?: string;
            contentType?: string;
            userProperties?: Array<{
                key: string;
                value: string;
            }>;
        };
    };
    username?: string;
    password?: string;
};
export declare class Client {
    private client;
    constructor(options: ClientOptions);
    connect(): Connection;
}
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const mqtt = __importStar(require("mqtt/dist/mqtt"));
const runtime_mqtt_utils_1 = require("@postman/runtime.mqtt-utils");
const connection_1 = require("./connection");
const custom_stream_1 = require("./custom-stream");
const utilities_1 = require("./utilities");
/*
    An MQTT Client capable of connecting to a broker, publishing messages,
    subscribing to topics, and receiving messages.

    Instantiates the client and connects to the broker using a Connection object.
*/
class Client {
    constructor(options) {
        this.client = null;
        const { tlsOptions, mqttOptions } = options;
        const parsedURL = (0, runtime_mqtt_utils_1.parseURL)(options.url);
        let clientOptions = (0, utilities_1.validateSettings)(parsedURL, mqttOptions);
        if (parsedURL.isTLS && tlsOptions) {
            clientOptions = {
                ...clientOptions,
                ...tlsOptions,
            };
        }
        // Create the client, but don't connect yet
        try {
            this.client = new mqtt.Client(() => (0, custom_stream_1.customStream)({ parsedURL, tlsOptions }), { ...clientOptions, manualConnect: true });
        }
        catch (err) {
            throw new Error(`Unable to create mqtt client: ${err}`);
        }
    }
    connect() {
        if (!this.client) {
            throw new Error('Client is not initialized');
        }
        return new connection_1.Connection(this.client);
    }
}
exports.Client = Client;
//# sourceMappingURL=client.js.map{"version":3,"file":"client.js","sourceRoot":"","sources":["../src/client.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,qDAAuC;AAEvC,oEAAuD;AACvD,6CAA0C;AAC1C,mDAA+C;AAC/C,2CAA+C;AAmD/C;;;;;EAKE;AAEF,MAAa,MAAM;IAGlB,YAAY,OAAsB;QAF1B,WAAM,GAA2B,IAAI,CAAC;QAG7C,MAAM,EAAE,UAAU,EAAE,WAAW,EAAE,GAAG,OAAO,CAAC;QAC5C,MAAM,SAAS,GAAG,IAAA,6BAAQ,EAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACxC,IAAI,aAAa,GAAG,IAAA,4BAAgB,EAAC,SAAS,EAAE,WAAW,CAAC,CAAC;QAE7D,IAAI,SAAS,CAAC,KAAK,IAAI,UAAU,EAAE,CAAC;YACnC,aAAa,GAAG;gBACf,GAAG,aAAa;gBAChB,GAAG,UAAU;aACb,CAAC;QACH,CAAC;QACD,2CAA2C;QAC3C,IAAI,CAAC;YACJ,IAAI,CAAC,MAAM,GAAG,IAAI,IAAI,CAAC,MAAM,CAC5B,GAAG,EAAE,CAAC,IAAA,4BAAY,EAAC,EAAE,SAAS,EAAE,UAAU,EAAE,CAAC,EAC7C,EAAE,GAAG,aAAa,EAAE,aAAa,EAAE,IAAI,EAAE,CACzC,CAAC;QACH,CAAC;QAAC,OAAO,GAAG,EAAE,CAAC;YACd,MAAM,IAAI,KAAK,CAAC,iCAAiC,GAAG,EAAE,CAAC,CAAC;QACzD,CAAC;IACF,CAAC;IAED,OAAO;QACN,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC;YAClB,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC;QAC9C,CAAC;QAED,OAAO,IAAI,uBAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACpC,CAAC;CACD;AAhCD,wBAgCC"}import { AgentPublishOptions, AgentSubscribeOptions } from '@postman/runtime.mqtt-utils';
import { EventEmitter } from 'events';
import * as mqtt from 'mqtt/dist/mqtt';
export declare class Connection extends EventEmitter {
    private client;
    private reconnectCount;
    constructor(client: mqtt.MqttClient);
    publish(topic: string, message: string | Buffer | Uint8Array, options: AgentPublishOptions): void;
    subscribe(topic: string, options: AgentSubscribeOptions): void;
    unsubscribe(topic: string): void;
    disconnect(force?: boolean, options?: Partial<mqtt.IDisconnectPacket>): void;
    getClient(): mqtt.MqttClient;
    isConnected(): boolean;
    /**
     * Checks for message IDs from the broker that don't correspond to an outgoing handshake.
     * Emits and error and disconnects the client if an error is found.
     * @param packet Packet to be checked for outgoing message ID.
     * @returns Disconnect packet if an error is found, undefined otherwise.
     */
    checkForBadMessageIds(packet: mqtt.Packet): {
        reasonCode: number;
        properties: {
            reasonString: string;
        };
    } | undefined;
}
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connection = void 0;
const runtime_mqtt_utils_1 = require("@postman/runtime.mqtt-utils");
const events_1 = require("events");
const mqtt = __importStar(require("mqtt/dist/mqtt"));
const utilities_1 = require("./utilities");
const RECONNECT_ATTEMPTS_LIMIT = 3;
/*
    Connection represents an active MQTT connection to a broker. It is responsible
    for maintaining the underlying TCP socket or websocket, and for dispatching events to the
    appropriate handlers.

    The connection returns a stream to the consumer that listens for calls from the consumer
    and emits client events.
*/
class Connection extends events_1.EventEmitter {
    constructor(client) {
        super();
        this.reconnectCount = 0;
        this.client = client;
        this.client
            .on('packetreceive', (packet) => {
            this.emit('incoming-packet', (0, runtime_mqtt_utils_1.parsePacket)(packet));
            const disconnectPacket = this.checkForBadMessageIds(packet);
            if (disconnectPacket) {
                this.emit('mqtt-error', new mqtt.ErrorWithReasonCode(disconnectPacket.properties.reasonString, disconnectPacket.reasonCode), disconnectPacket);
            }
        })
            .on('packetsend', (packet) => {
            this.emit('outgoing-packet', (0, runtime_mqtt_utils_1.parsePacket)(packet));
        })
            .on('error', (err) => {
            // Error with reason code is an error code in an MQTT packet.
            if (err instanceof mqtt.ErrorWithReasonCode) {
                // Currently two events will be emitted for this error.
                // A packetreceive event with the packet and an mqtt-error event with the error.
                this.emit('mqtt-error', err);
            }
            else {
                this.emit('error', err);
            }
        })
            .on('reconnect', () => {
            if (this.reconnectCount >= RECONNECT_ATTEMPTS_LIMIT) {
                this.client.end();
                return;
            }
            this.reconnectCount++;
            this.emit('reconnect', this.reconnectCount);
        })
            .on('connect', () => {
            // The 'packetreceive' event will handle sending the relevant information to the consumer.
            // Might change this in the future for a bit more control and error handling.
            // Reconnected connections will receive another connack packet, so we need to reset the count.
            this.reconnectCount = 0;
        })
            .on('close', () => {
            this.emit('close');
        });
        this.client.connect();
    }
    publish(topic, message, options) {
        if (!topic || topic === '') {
            throw new Error('Topic is required');
        }
        // Transform options to mqtt publish options
        const publishOptions = {
            qos: options.qos,
            retain: options.retain,
        };
        if (options.properties) {
            const { userProperties, correlationData, ...properties } = options.properties;
            const clientProperties = properties;
            if (correlationData) {
                clientProperties.correlationData = Buffer.from(correlationData);
            }
            if (userProperties) {
                clientProperties.userProperties =
                    (0, utilities_1.transformUserProperties)(userProperties);
            }
            publishOptions.properties = clientProperties;
        }
        // This is to work with mqttjs types, however it will accept a Uint8Array
        this.client.publish(topic, message, publishOptions);
    }
    subscribe(topic, options) {
        const { qos = 0, settings, userProperties } = options;
        const { noLocal: nl, retainAsPublished: rap, retainHandling: rh, subscriptionIdentifier, } = settings ?? {};
        const subscribeOptions = { qos, nl, rap, rh };
        if (userProperties) {
            const transformedUserProperties = (0, utilities_1.transformUserProperties)(userProperties);
            if (Object.keys(transformedUserProperties).length > 0) {
                subscribeOptions.properties = {
                    ...subscribeOptions.properties,
                    userProperties: transformedUserProperties,
                };
            }
        }
        if (subscriptionIdentifier) {
            subscribeOptions.properties = {
                ...subscribeOptions.properties,
                subscriptionIdentifier,
            };
        }
        this.client.subscribe(topic, JSON.parse(JSON.stringify(subscribeOptions)));
    }
    unsubscribe(topic) {
        this.client.unsubscribe(topic);
    }
    disconnect(force = false, options) {
        this.client.end(force, options);
    }
    getClient() {
        return this.client;
    }
    isConnected() {
        return this.client.connected;
    }
    /**
     * Checks for message IDs from the broker that don't correspond to an outgoing handshake.
     * Emits and error and disconnects the client if an error is found.
     * @param packet Packet to be checked for outgoing message ID.
     * @returns Disconnect packet if an error is found, undefined otherwise.
     */
    checkForBadMessageIds(packet) {
        // [APICLIENT-1055] Fixes a bug where client would be unable to connect if broker received an ack with an invalid messageId.
        if (Object.keys(this.client.outgoing).length &&
            (packet.cmd === 'puback' || packet.cmd === 'pubrec') &&
            packet.messageId && !this.client.outgoing.hasOwnProperty(packet.messageId)) {
            return {
                reasonCode: 152,
                properties: {
                    reasonString: 'Server sent an ack packet with an invalid messageId.',
                }
            };
        }
        return undefined;
    }
}
exports.Connection = Connection;
//# sourceMappingURL=connection.js.map{"version":3,"file":"connection.js","sourceRoot":"","sources":["../src/connection.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,oEAIqC;AACrC,mCAAsC;AACtC,qDAAuC;AACvC,2CAAsD;AAEtD,MAAM,wBAAwB,GAAG,CAAC,CAAC;AAEnC;;;;;;;EAOE;AAEF,MAAa,UAAW,SAAQ,qBAAY;IAI3C,YAAY,MAAuB;QAClC,KAAK,EAAE,CAAC;QAHD,mBAAc,GAAW,CAAC,CAAC;QAIlC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QAErB,IAAI,CAAC,MAAM;aACT,EAAE,CAAC,eAAe,EAAE,CAAC,MAAM,EAAE,EAAE;YAC/B,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,IAAA,gCAAW,EAAC,MAAM,CAAC,CAAC,CAAC;YAClD,MAAM,gBAAgB,GAAG,IAAI,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC;YAC5D,IAAI,gBAAgB,EAAE,CAAC;gBACtB,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,IAAI,IAAI,CAAC,mBAAmB,CAAC,gBAAgB,CAAC,UAAU,CAAC,YAAY,EAAE,gBAAgB,CAAC,UAAU,CAAC,EAAE,gBAAgB,CAAC,CAAC;YAChJ,CAAC;QACF,CAAC,CAAC;aACD,EAAE,CAAC,YAAY,EAAE,CAAC,MAAM,EAAE,EAAE;YAC5B,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,IAAA,gCAAW,EAAC,MAAM,CAAC,CAAC,CAAC;QACnD,CAAC,CAAC;aACD,EAAE,CAAC,OAAO,EAAE,CAAC,GAAG,EAAE,EAAE;YACpB,6DAA6D;YAC7D,IAAI,GAAG,YAAY,IAAI,CAAC,mBAAmB,EAAE,CAAC;gBAC7C,uDAAuD;gBACvD,gFAAgF;gBAChF,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,GAAG,CAAC,CAAC;YAC9B,CAAC;iBAAM,CAAC;gBACP,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;YACzB,CAAC;QACF,CAAC,CAAC;aACD,EAAE,CAAC,WAAW,EAAE,GAAG,EAAE;YACrB,IAAI,IAAI,CAAC,cAAc,IAAI,wBAAwB,EAAE,CAAC;gBACrD,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC;gBAClB,OAAO;YACR,CAAC;YAED,IAAI,CAAC,cAAc,EAAE,CAAC;YACtB,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;QAC7C,CAAC,CAAC;aACD,EAAE,CAAC,SAAS,EAAE,GAAG,EAAE;YACnB,0FAA0F;YAC1F,6EAA6E;YAE7E,8FAA8F;YAC9F,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC;QACzB,CAAC,CAAC;aACD,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE;YACjB,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACpB,CAAC,CAAC,CAAC;QAEJ,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;IACvB,CAAC;IAED,OAAO,CACN,KAAa,EACb,OAAqC,EACrC,OAA4B;QAE5B,IAAI,CAAC,KAAK,IAAI,KAAK,KAAK,EAAE,EAAE,CAAC;YAC5B,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;QACtC,CAAC;QAED,4CAA4C;QAC5C,MAAM,cAAc,GAA+B;YAClD,GAAG,EAAE,OAAO,CAAC,GAAG;YAChB,MAAM,EAAE,OAAO,CAAC,MAAM;SACtB,CAAC;QAEF,IAAI,OAAO,CAAC,UAAU,EAAE,CAAC;YACxB,MAAM,EAAE,cAAc,EAAE,eAAe,EAAE,GAAG,UAAU,EAAE,GACvD,OAAO,CAAC,UAAU,CAAC;YACpB,MAAM,gBAAgB,GACrB,UAAU,CAAC;YAEZ,IAAI,eAAe,EAAE,CAAC;gBACrB,gBAAgB,CAAC,eAAe,GAAG,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;YACjE,CAAC;YAED,IAAI,cAAc,EAAE,CAAC;gBACpB,gBAAgB,CAAC,cAAc;oBAC9B,IAAA,mCAAuB,EAAC,cAAc,CAAC,CAAC;YAC1C,CAAC;YAED,cAAc,CAAC,UAAU,GAAG,gBAAgB,CAAC;QAC9C,CAAC;QAED,yEAAyE;QACzE,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,OAA0B,EAAE,cAAc,CAAC,CAAC;IACxE,CAAC;IAED,SAAS,CAAC,KAAa,EAAE,OAA8B;QACtD,MAAM,EAAE,GAAG,GAAG,CAAC,EAAE,QAAQ,EAAE,cAAc,EAAE,GAAG,OAAO,CAAC;QACtD,MAAM,EACL,OAAO,EAAE,EAAE,EACX,iBAAiB,EAAE,GAAG,EACtB,cAAc,EAAE,EAAE,EAClB,sBAAsB,GACtB,GAAG,QAAQ,IAAI,EAAE,CAAC;QACnB,MAAM,gBAAgB,GAAiC,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC;QAE5E,IAAI,cAAc,EAAE,CAAC;YACpB,MAAM,yBAAyB,GAAG,IAAA,mCAAuB,EAAC,cAAc,CAAC,CAAC;YAE1E,IAAI,MAAM,CAAC,IAAI,CAAC,yBAAyB,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACvD,gBAAgB,CAAC,UAAU,GAAG;oBAC7B,GAAG,gBAAgB,CAAC,UAAU;oBAC9B,cAAc,EAAE,yBAAyB;iBACzC,CAAC;YACH,CAAC;QACF,CAAC;QAED,IAAI,sBAAsB,EAAE,CAAC;YAC5B,gBAAgB,CAAC,UAAU,GAAG;gBAC7B,GAAG,gBAAgB,CAAC,UAAU;gBAC9B,sBAAsB;aACtB,CAAC;QACH,CAAC;QAED,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC;IAC5E,CAAC;IAED,WAAW,CAAC,KAAa;QACxB,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;IAChC,CAAC;IAED,UAAU,CAAC,KAAK,GAAG,KAAK,EAAE,OAAyC;QAClE,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;IACjC,CAAC;IAED,SAAS;QACR,OAAO,IAAI,CAAC,MAAM,CAAC;IACpB,CAAC;IAED,WAAW;QACV,OAAO,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC;IAC9B,CAAC;IAED;;;;;OAKG;IACH,qBAAqB,CAAC,MAAmB;QACxC,4HAA4H;QAC5H,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,MAAM;YAC3C,CAAC,MAAM,CAAC,GAAG,KAAK,QAAQ,IAAI,MAAM,CAAC,GAAG,KAAK,QAAQ,CAAC;YACpD,MAAM,CAAC,SAAS,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,cAAc,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC;YAC7E,OAAO;gBACN,UAAU,EAAE,GAAG;gBACf,UAAU,EAAE;oBACX,YAAY,EAAE,sDAAsD;iBACpE;aACD,CAAC;QACH,CAAC;QACD,OAAO,SAAS,CAAC;IAClB,CAAC;CACD;AA5JD,gCA4JC"}import { ParsedURL } from '@postman/runtime.mqtt-utils';
import { tlsOptions } from './client';
export type CustomStreamArgs = {
    parsedURL: ParsedURL;
    tlsOptions?: tlsOptions | null;
};
export declare function customStream(options: CustomStreamArgs): any;
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.customStream = customStream;
const postman_ws_1 = __importDefault(require("postman-ws"));
const tls = __importStar(require("tls"));
const net = __importStar(require("net"));
function customStream(options) {
    const { parsedURL, tlsOptions } = options;
    const { isTLS, protocol, host, port: portString } = parsedURL;
    const { rejectUnauthorized, secureContext } = tlsOptions ?? {};
    const port = portString ? Number(portString) : 1883;
    let stream;
    try {
        if (protocol === 'ws' || protocol === 'wss') {
            const webSocket = new postman_ws_1.default(parsedURL.url, ['mqtt'], {
                rejectUnauthorized,
                ...secureContext,
            });
            stream = postman_ws_1.default.createWebSocketStream(webSocket);
        }
        else if (isTLS) {
            stream = tls.connect({
                port: port,
                host,
                rejectUnauthorized,
                ...secureContext,
            });
        }
        else {
            stream = net.createConnection({ port, host });
        }
        return stream;
    }
    catch (err) {
        throw new Error(`Unable to build socket: ${err}`);
    }
}
//# sourceMappingURL=custom-stream.js.map{"version":3,"file":"custom-stream.js","sourceRoot":"","sources":["../src/custom-stream.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAeA,oCA+BC;AA9CD,4DAAmC;AACnC,yCAA2B;AAC3B,yCAA2B;AAa3B,SAAgB,YAAY,CAAC,OAAyB;IACrD,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,GAAG,OAAO,CAAC;IAC1C,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE,UAAU,EAAE,GAAG,SAAS,CAAC;IAC9D,MAAM,EAAE,kBAAkB,EAAE,aAAa,EAAE,GAAG,UAAU,IAAI,EAAE,CAAC;IAC/D,MAAM,IAAI,GAAG,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;IAEpD,IAAI,MAAW,CAAC;IAEhB,IAAI,CAAC;QACJ,IAAI,QAAQ,KAAK,IAAI,IAAI,QAAQ,KAAK,KAAK,EAAE,CAAC;YAC7C,MAAM,SAAS,GAAG,IAAI,oBAAS,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,EAAE;gBACxD,kBAAkB;gBAClB,GAAG,aAAa;aAChB,CAAC,CAAC;YAEH,MAAM,GAAG,oBAAS,CAAC,qBAAqB,CAAC,SAAS,CAAC,CAAC;QACrD,CAAC;aAAM,IAAI,KAAK,EAAE,CAAC;YAClB,MAAM,GAAG,GAAG,CAAC,OAAO,CAAC;gBACpB,IAAI,EAAE,IAAI;gBACV,IAAI;gBACJ,kBAAkB;gBAClB,GAAG,aAAa;aAChB,CAAC,CAAC;QACJ,CAAC;aAAM,CAAC;YACP,MAAM,GAAG,GAAG,CAAC,gBAAgB,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;QAC/C,CAAC;QAED,OAAO,MAAM,CAAC;IACf,CAAC;IAAC,OAAO,GAAG,EAAE,CAAC;QACd,MAAM,IAAI,KAAK,CAAC,2BAA2B,GAAG,EAAE,CAAC,CAAC;IACnD,CAAC;AACF,CAAC"}import { ClientOptions } from './client';
import { Connection } from './connection';
export * from './client';
export * from './connection';
export declare function connect(options: ClientOptions): Connection;
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.connect = connect;
const client_1 = require("./client");
__exportStar(require("./client"), exports);
__exportStar(require("./connection"), exports);
function connect(options) {
    return new client_1.Client(options).connect();
}
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAKA,0BAEC;AAPD,qCAAiD;AAEjD,2CAAyB;AACzB,+CAA6B;AAE7B,SAAgB,OAAO,CAAC,OAAsB;IAC7C,OAAO,IAAI,eAAM,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CAAC;AACtC,CAAC"}import { ParsedURL } from '@postman/runtime.mqtt-utils';
import { MQTTClientOptions } from './client';
export type ConnectionOptions = Omit<MQTTClientOptions, 'cleanSession' | 'properties' | 'version'> & {
    protocol: ParsedURL['protocol'];
    protocolVersion?: 4 | 5;
    clean: boolean;
    properties?: {
        sessionExpiryInterval?: number;
        receiveMaximum?: number;
        maximumPacketSize?: number;
        userProperties?: UserProperties;
    };
    will?: Omit<MQTTClientOptions['lastWill'], 'properties' | 'payload'> & {
        topic: string;
        payload: Buffer;
        properties?: {
            payloadFormatIndicator?: boolean;
            messageExpiryInterval?: number;
            willDelayInterval?: number;
            responseTopic?: string;
            correlationData?: Buffer;
            contentType?: string;
            userProperties?: UserProperties;
        };
    };
};
export type UserProperties = Record<string, string>;
export declare function validateSettings(url: ParsedURL, mqttOptions: MQTTClientOptions | null | undefined): ConnectionOptions;
export declare function transformUserProperties(userProperties?: Array<{
    key: string;
    value: string | boolean | number;
    disabled?: boolean;
}>): UserProperties;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateSettings = validateSettings;
exports.transformUserProperties = transformUserProperties;
// Check MQTT client options and validate them
function validateSettings(url, mqttOptions) {
    if (!mqttOptions) {
        return {
            protocol: url.protocol,
            clean: false,
        };
    }
    // Check if there is a conflict between the clean setting and the clientId
    if (!mqttOptions.clientId && mqttOptions.cleanSession) {
        throw new Error('Unable to set clean to true when clientId is not provided');
    }
    // Extract options and properties that need to be updated for use by the client
    const { cleanSession, properties, lastWill, version, ...restOptions } = mqttOptions;
    const { userProperties, ...restProperties } = properties || {};
    const { payload, properties: willProperties, ...will } = lastWill || {};
    const { userProperties: willUserProperties, correlationData, ...restWillProperties } = willProperties || {};
    const options = restOptions;
    options.protocol = url.protocol;
    options.clean = mqttOptions.cleanSession ?? false;
    options.protocolVersion = version ?? 4;
    if (lastWill) {
        if (!lastWill.topic) {
            throw new Error('Will topic is required');
        }
        options.will = {
            payload: Buffer.from(payload ?? ''),
            ...will,
            topic: lastWill.topic,
        };
    }
    // Update properties and will properties if the protocol version is 5
    if (version === 5) {
        const transformedUserProperties = transformUserProperties(userProperties);
        options.properties = {
            ...restProperties,
            // Spreading empty object to avoid undefined properties
            ...(Object.keys(transformedUserProperties).length !== 0 ?
                { userProperties: transformedUserProperties }
                : {}),
        };
        if (options.will) {
            const transformedWillUserProperties = transformUserProperties(willUserProperties);
            options.will = {
                ...options.will,
                properties: {
                    ...restWillProperties,
                    ...(correlationData ?
                        { correlationData: Buffer.from(correlationData) }
                        : {}),
                    ...(Object.keys(transformedWillUserProperties).length != 0 ?
                        { userProperties: transformedWillUserProperties }
                        : {}),
                },
            };
        }
    }
    return optionsTypeGuard(options) ?
        { ...options }
        : { protocol: url.protocol ?? 'mqtt', clean: false };
}
// Transform UserProperties into an object with key-value pairs
function transformUserProperties(userProperties) {
    if (!userProperties || userProperties.length === 0)
        return {};
    return userProperties.reduce((acc, { key, value, disabled = false }) => {
        if (!disabled && value && value !== '') {
            acc[key] = value.toString();
        }
        return acc;
    }, {});
}
// Type guard for ConnectionOptions
function optionsTypeGuard(options) {
    return (options instanceof Object &&
        'protocol' in options &&
        Boolean(options?.protocol) &&
        'clean' in options);
}
//# sourceMappingURL=utilities.js.map{"version":3,"file":"utilities.js","sourceRoot":"","sources":["../src/utilities.ts"],"names":[],"mappings":"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"}#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const commist_1 = __importDefault(require("commist"));
const help_me_1 = __importDefault(require("help-me"));
const pub_1 = __importDefault(require("./pub"));
const sub_1 = __importDefault(require("./sub"));
const version = require('../../package.json').version;
const helpMe = (0, help_me_1.default)({
    dir: path_1.default.join(__dirname, '../../', 'help'),
    ext: '.txt',
});
const commist = (0, commist_1.default)();
commist.register('publish', pub_1.default);
commist.register('pub', pub_1.default);
commist.register('subscribe', sub_1.default);
commist.register('sub', sub_1.default);
commist.register('version', () => {
    console.log('MQTT.js version:', version);
});
commist.register('help', helpMe.toStdout);
if (commist.parse(process.argv.slice(2)) !== null) {
    console.log('No such command:', process.argv[2], '\n');
    helpMe.toStdout();
}
//# sourceMappingURL=mqtt.js.map#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const readable_stream_1 = require("readable-stream");
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const concat_stream_1 = __importDefault(require("concat-stream"));
const help_me_1 = __importDefault(require("help-me"));
const minimist_1 = __importDefault(require("minimist"));
const split2_1 = __importDefault(require("split2"));
const mqtt_1 = require("../mqtt");
const stream_1 = require("stream");
const helpMe = (0, help_me_1.default)({
    dir: path_1.default.join(__dirname, '../../', 'help'),
});
function send(args) {
    const client = (0, mqtt_1.connect)(args);
    client.on('connect', () => {
        client.publish(args.topic, args.message, args, (err) => {
            if (err) {
                console.warn(err);
            }
            client.end();
        });
    });
    client.on('error', (err) => {
        console.warn(err);
        client.end();
    });
}
function multisend(args) {
    const client = (0, mqtt_1.connect)(args);
    const sender = new readable_stream_1.Writable({
        objectMode: true,
    });
    sender._write = (line, enc, cb) => {
        client.publish(args.topic, line.trim(), args, cb);
    };
    client.on('connect', () => {
        (0, stream_1.pipeline)(process.stdin, (0, split2_1.default)(), sender, (err) => {
            client.end();
            if (err) {
                throw err;
            }
        });
    });
}
function start(args) {
    var _a, _b;
    const parsedArgs = (0, minimist_1.default)(args, {
        string: [
            'hostname',
            'username',
            'password',
            'key',
            'cert',
            'ca',
            'message',
            'clientId',
            'i',
            'id',
        ],
        boolean: ['stdin', 'retain', 'help', 'insecure', 'multiline'],
        alias: {
            port: 'p',
            hostname: ['h', 'host'],
            topic: 't',
            message: 'm',
            qos: 'q',
            clientId: ['i', 'id'],
            retain: 'r',
            username: 'u',
            password: 'P',
            stdin: 's',
            multiline: 'M',
            protocol: ['C', 'l'],
            help: 'H',
            ca: 'cafile',
        },
        default: {
            host: 'localhost',
            qos: 0,
            retain: false,
            topic: '',
            message: '',
        },
    });
    if (parsedArgs.help) {
        return helpMe.toStdout('publish');
    }
    if (parsedArgs.key) {
        parsedArgs.key = fs_1.default.readFileSync(parsedArgs.key);
    }
    if (parsedArgs.cert) {
        parsedArgs.cert = fs_1.default.readFileSync(parsedArgs.cert);
    }
    if (parsedArgs.ca) {
        parsedArgs.ca = fs_1.default.readFileSync(parsedArgs.ca);
    }
    if (parsedArgs.key && parsedArgs.cert && !parsedArgs.protocol) {
        parsedArgs.protocol = 'mqtts';
    }
    if (parsedArgs.port) {
        if (typeof parsedArgs.port !== 'number') {
            console.warn("# Port: number expected, '%s' was given.", typeof parsedArgs.port);
            return;
        }
    }
    if (parsedArgs['will-topic']) {
        parsedArgs.will = {};
        parsedArgs.will.topic = parsedArgs['will-topic'];
        parsedArgs.will.payload = parsedArgs['will-message'];
        parsedArgs.will.qos = parsedArgs['will-qos'];
        parsedArgs.will.retain = parsedArgs['will-retain'];
    }
    if (parsedArgs.insecure) {
        parsedArgs.rejectUnauthorized = false;
    }
    parsedArgs.topic = (_a = (parsedArgs.topic || parsedArgs._.shift())) === null || _a === void 0 ? void 0 : _a.toString();
    parsedArgs.message = (_b = (parsedArgs.message || parsedArgs._.shift())) === null || _b === void 0 ? void 0 : _b.toString();
    if (!parsedArgs.topic) {
        console.error('missing topic\n');
        return helpMe.toStdout('publish');
    }
    if (parsedArgs.stdin) {
        if (parsedArgs.multiline) {
            multisend(parsedArgs);
        }
        else {
            process.stdin.pipe((0, concat_stream_1.default)((data) => {
                parsedArgs.message = data;
                send(parsedArgs);
            }));
        }
    }
    else {
        send(parsedArgs);
    }
}
exports.default = start;
if (require.main === module) {
    start(process.argv.slice(2));
}
//# sourceMappingURL=pub.js.map#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const minimist_1 = __importDefault(require("minimist"));
const help_me_1 = __importDefault(require("help-me"));
const mqtt_1 = require("../mqtt");
const helpMe = (0, help_me_1.default)({
    dir: path_1.default.join(__dirname, '../../', 'help'),
});
function start(args) {
    const parsedArgs = (0, minimist_1.default)(args, {
        string: [
            'hostname',
            'username',
            'password',
            'key',
            'cert',
            'ca',
            'clientId',
            'i',
            'id',
        ],
        boolean: ['stdin', 'help', 'clean', 'insecure'],
        alias: {
            port: 'p',
            hostname: ['h', 'host'],
            topic: 't',
            qos: 'q',
            clean: 'c',
            keepalive: 'k',
            clientId: ['i', 'id'],
            username: 'u',
            password: 'P',
            protocol: ['C', 'l'],
            verbose: 'v',
            help: '-H',
            ca: 'cafile',
        },
        default: {
            host: 'localhost',
            qos: 0,
            retain: false,
            clean: true,
            keepAlive: 30,
        },
    });
    if (parsedArgs.help) {
        return helpMe.toStdout('subscribe');
    }
    parsedArgs.topic = parsedArgs.topic || parsedArgs._.shift();
    if (!parsedArgs.topic) {
        console.error('missing topic\n');
        return helpMe.toStdout('subscribe');
    }
    if (parsedArgs.key) {
        parsedArgs.key = fs_1.default.readFileSync(parsedArgs.key);
    }
    if (parsedArgs.cert) {
        parsedArgs.cert = fs_1.default.readFileSync(parsedArgs.cert);
    }
    if (parsedArgs.ca) {
        parsedArgs.ca = fs_1.default.readFileSync(parsedArgs.ca);
    }
    if (parsedArgs.key && parsedArgs.cert && !parsedArgs.protocol) {
        parsedArgs.protocol = 'mqtts';
    }
    if (parsedArgs.insecure) {
        parsedArgs.rejectUnauthorized = false;
    }
    if (parsedArgs.port) {
        if (typeof parsedArgs.port !== 'number') {
            console.warn("# Port: number expected, '%s' was given.", typeof parsedArgs.port);
            return;
        }
    }
    if (parsedArgs['will-topic']) {
        parsedArgs.will = {};
        parsedArgs.will.topic = parsedArgs['will-topic'];
        parsedArgs.will.payload = parsedArgs['will-message'];
        parsedArgs.will.qos = parsedArgs['will-qos'];
        parsedArgs.will.retain = parsedArgs['will-retain'];
    }
    parsedArgs.keepAlive = parsedArgs['keep-alive'];
    const client = (0, mqtt_1.connect)(parsedArgs);
    client.on('connect', () => {
        client.subscribe(parsedArgs.topic, { qos: parsedArgs.qos }, (err, result) => {
            if (err) {
                console.error(err);
                process.exit(1);
            }
            result.forEach((sub) => {
                if (sub.qos > 2) {
                    console.error('subscription negated to', sub.topic, 'with code', sub.qos);
                    process.exit(1);
                }
            });
        });
    });
    client.on('message', (topic, payload) => {
        if (parsedArgs.verbose) {
            console.log(topic, payload.toString());
        }
        else {
            console.log(payload.toString());
        }
    });
    client.on('error', (err) => {
        console.warn(err);
        client.end();
    });
}
exports.default = start;
if (require.main === module) {
    start(process.argv.slice(2));
}
//# sourceMappingURL=sub.js.map// Project: https://github.com/isaacs/node-lru-cache
// Based initially on @types/lru-cache
// https://github.com/DefinitelyTyped/DefinitelyTyped
// used under the terms of the MIT License, shown below.
//
// DefinitelyTyped license:
// ------
// MIT License
//
// Copyright (c) Microsoft Corporation.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE
// ------
//
// Changes by Isaac Z. Schlueter released under the terms found in the
// LICENSE file within this project.

/**
 * Integer greater than 0, representing some number of milliseconds, or the
 * time at which a TTL started counting from.
 */
declare type LRUMilliseconds = number

/**
 * An integer greater than 0, reflecting the calculated size of items
 */
declare type LRUSize = number

/**
 * An integer greater than 0, reflecting a number of items
 */
declare type LRUCount = number

declare class LRUCache<K, V> implements Iterable<[K, V]> {
  constructor(options: LRUCache.Options<K, V>)

  /**
   * Number of items in the cache.
   * Alias for {@link size}
   *
   * @deprecated since 7.0 use {@link size} instead
   */
  public readonly length: LRUCount

  public readonly max: LRUCount
  public readonly maxSize: LRUSize
  public readonly maxEntrySize: LRUSize
  public readonly sizeCalculation:
    | LRUCache.SizeCalculator<K, V>
    | undefined
  public readonly dispose: LRUCache.Disposer<K, V>
  /**
   * @since 7.4.0
   */
  public readonly disposeAfter: LRUCache.Disposer<K, V> | null
  public readonly noDisposeOnSet: boolean
  public readonly ttl: LRUMilliseconds
  public readonly ttlResolution: LRUMilliseconds
  public readonly ttlAutopurge: boolean
  public readonly allowStale: boolean
  public readonly updateAgeOnGet: boolean
  /**
   * @since 7.11.0
   */
  public readonly noDeleteOnStaleGet: boolean
  /**
   * @since 7.6.0
   */
  public readonly fetchMethod: LRUCache.Fetcher<K, V> | null

  /**
   * The total number of items held in the cache at the current moment.
   */
  public readonly size: LRUCount

  /**
   * The total size of items in cache when using size tracking.
   */
  public readonly calculatedSize: LRUSize

  /**
   * Add a value to the cache.
   */
  public set(
    key: K,
    value: V,
    options?: LRUCache.SetOptions<K, V>
  ): this

  /**
   * Return a value from the cache. Will update the recency of the cache entry
   * found.
   *
   * If the key is not found, {@link get} will return `undefined`. This can be
   * confusing when setting values specifically to `undefined`, as in
   * `cache.set(key, undefined)`. Use {@link has} to determine whether a key is
   * present in the cache at all.
   */
  public get(key: K, options?: LRUCache.GetOptions<V>): V | undefined

  /**
   * Like {@link get} but doesn't update recency or delete stale items.
   * Returns `undefined` if the item is stale, unless {@link allowStale} is set
   * either on the cache or in the options object.
   */
  public peek(key: K, options?: LRUCache.PeekOptions): V | undefined

  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Will not update item age unless {@link updateAgeOnHas} is set in the
   * options or constructor.
   */
  public has(key: K, options?: LRUCache.HasOptions<V>): boolean

  /**
   * Deletes a key out of the cache.
   * Returns true if the key was deleted, false otherwise.
   */
  public delete(key: K): boolean

  /**
   * Clear the cache entirely, throwing away all values.
   */
  public clear(): void

  /**
   * Delete any stale entries. Returns true if anything was removed, false
   * otherwise.
   */
  public purgeStale(): boolean

  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to Array.find().  fn is called as fn(value, key, cache).
   */
  public find(
    callbackFn: (
      value: V,
      key: K,
      cache: this
    ) => boolean | undefined | void,
    options?: LRUCache.GetOptions<V>
  ): V | undefined

  /**
   * Call the supplied function on each item in the cache, in order from
   * most recently used to least recently used.  fn is called as
   * fn(value, key, cache).  Does not update age or recenty of use.
   */
  public forEach<T = this>(
    callbackFn: (this: T, value: V, key: K, cache: this) => void,
    thisArg?: T
  ): void

  /**
   * The same as {@link forEach} but items are iterated over in reverse
   * order.  (ie, less recently used items are iterated over first.)
   */
  public rforEach<T = this>(
    callbackFn: (this: T, value: V, key: K, cache: this) => void,
    thisArg?: T
  ): void

  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  public keys(): Generator<K, void, void>

  /**
   * Inverse order version of {@link keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  public rkeys(): Generator<K, void, void>

  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  public values(): Generator<V, void, void>

  /**
   * Inverse order version of {@link values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  public rvalues(): Generator<V, void, void>

  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  public entries(): Generator<[K, V], void, void>

  /**
   * Inverse order version of {@link entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  public rentries(): Generator<[K, V], void, void>

  /**
   * Iterating over the cache itself yields the same results as
   * {@link entries}
   */
  public [Symbol.iterator](): Generator<[K, V], void, void>

  /**
   * Return an array of [key, entry] objects which can be passed to
   * cache.load()
   */
  public dump(): Array<[K, LRUCache.Entry<V>]>

  /**
   * Reset the cache and load in the items in entries in the order listed.
   * Note that the shape of the resulting cache may be different if the
   * same options are not used in both caches.
   */
  public load(
    cacheEntries: ReadonlyArray<[K, LRUCache.Entry<V>]>
  ): void

  /**
   * Evict the least recently used item, returning its value or `undefined`
   * if cache is empty.
   */
  public pop(): V | undefined

  /**
   * Deletes a key out of the cache.
   *
   * @deprecated since 7.0 use delete() instead
   */
  public del(key: K): boolean

  /**
   * Clear the cache entirely, throwing away all values.
   *
   * @deprecated since 7.0 use clear() instead
   */
  public reset(): void

  /**
   * Manually iterates over the entire cache proactively pruning old entries.
   *
   * @deprecated since 7.0 use purgeStale() instead
   */
  public prune(): boolean

  /**
   * Make an asynchronous cached fetch using the {@link fetchMethod} function.
   *
   * If multiple fetches for the same key are issued, then they will all be
   * coalesced into a single call to fetchMethod.
   *
   * Note that this means that handling options such as
   * {@link allowStaleOnFetchAbort}, {@link signal}, and
   * {@link allowStaleOnFetchRejection} will be determined by the FIRST fetch()
   * call for a given key.
   *
   * This is a known (fixable) shortcoming which will be addresed on when
   * someone complains about it, as the fix would involve added complexity and
   * may not be worth the costs for this edge case.
   *
   * since: 7.6.0
   */
  public fetch(
    key: K,
    options?: LRUCache.FetchOptions<K, V>
  ): Promise<V>

  /**
   * since: 7.6.0
   */
  public getRemainingTTL(key: K): LRUMilliseconds
}

declare namespace LRUCache {
  type DisposeReason = 'evict' | 'set' | 'delete'

  type SizeCalculator<K, V> = (value: V, key: K) => LRUSize
  type Disposer<K, V> = (
    value: V,
    key: K,
    reason: DisposeReason
  ) => void
  type Fetcher<K, V> = (
    key: K,
    staleValue: V | undefined,
    options: FetcherOptions<K, V>
  ) => Promise<V | void | undefined> | V | void | undefined

  interface DeprecatedOptions<K, V> {
    /**
     * alias for ttl
     *
     * @deprecated since 7.0 use options.ttl instead
     */
    maxAge?: LRUMilliseconds

    /**
     * alias for {@link sizeCalculation}
     *
     * @deprecated since 7.0 use {@link sizeCalculation} instead
     */
    length?: SizeCalculator<K, V>

    /**
     * alias for allowStale
     *
     * @deprecated since 7.0 use options.allowStale instead
     */
    stale?: boolean
  }

  interface LimitedByCount {
    /**
     * The number of most recently used items to keep.
     * Note that we may store fewer items than this if maxSize is hit.
     */
    max: LRUCount
  }

  type MaybeMaxEntrySizeLimit<K, V> =
    | {
        /**
         * The maximum allowed size for any single item in the cache.
         *
         * If a larger item is passed to {@link set} or returned by a
         * {@link fetchMethod}, then it will not be stored in the cache.
         */
        maxEntrySize: LRUSize
        sizeCalculation?: SizeCalculator<K, V>
      }
    | {}

  interface LimitedBySize<K, V> {
    /**
     * If you wish to track item size, you must provide a maxSize
     * note that we still will only keep up to max *actual items*,
     * if max is set, so size tracking may cause fewer than max items
     * to be stored.  At the extreme, a single item of maxSize size
     * will cause everything else in the cache to be dropped when it
     * is added.  Use with caution!
     *
     * Note also that size tracking can negatively impact performance,
     * though for most cases, only minimally.
     */
    maxSize: LRUSize

    /**
     * Function to calculate size of items.  Useful if storing strings or
     * buffers or other items where memory size depends on the object itself.
     *
     * Items larger than {@link maxEntrySize} will not be stored in the cache.
     *
     * Note that when {@link maxSize} or {@link maxEntrySize} are set, every
     * item added MUST have a size specified, either via a `sizeCalculation` in
     * the constructor, or `sizeCalculation` or {@link size} options to
     * {@link set}.
     */
    sizeCalculation?: SizeCalculator<K, V>
  }

  interface LimitedByTTL {
    /**
     * Max time in milliseconds for items to live in cache before they are
     * considered stale.  Note that stale items are NOT preemptively removed
     * by default, and MAY live in the cache, contributing to its LRU max,
     * long after they have expired.
     *
     * Also, as this cache is optimized for LRU/MRU operations, some of
     * the staleness/TTL checks will reduce performance, as they will incur
     * overhead by deleting items.
     *
     * Must be an integer number of ms, defaults to 0, which means "no TTL"
     */
    ttl: LRUMilliseconds

    /**
     * Boolean flag to tell the cache to not update the TTL when
     * setting a new value for an existing key (ie, when updating a value
     * rather than inserting a new value).  Note that the TTL value is
     * _always_ set (if provided) when adding a new entry into the cache.
     *
     * @default false
     * @since 7.4.0
     */
    noUpdateTTL?: boolean

    /**
     * Minimum amount of time in ms in which to check for staleness.
     * Defaults to 1, which means that the current time is checked
     * at most once per millisecond.
     *
     * Set to 0 to check the current time every time staleness is tested.
     * (This reduces performance, and is theoretically unnecessary.)
     *
     * Setting this to a higher value will improve performance somewhat
     * while using ttl tracking, albeit at the expense of keeping stale
     * items around a bit longer than their TTLs would indicate.
     *
     * @default 1
     * @since 7.1.0
     */
    ttlResolution?: LRUMilliseconds

    /**
     * Preemptively remove stale items from the cache.
     * Note that this may significantly degrade performance,
     * especially if the cache is storing a large number of items.
     * It is almost always best to just leave the stale items in
     * the cache, and let them fall out as new items are added.
     *
     * Note that this means that {@link allowStale} is a bit pointless,
     * as stale items will be deleted almost as soon as they expire.
     *
     * Use with caution!
     *
     * @default false
     * @since 7.1.0
     */
    ttlAutopurge?: boolean

    /**
     * Return stale items from {@link get} before disposing of them.
     * Return stale values from {@link fetch} while performing a call
     * to the {@link fetchMethod} in the background.
     *
     * @default false
     */
    allowStale?: boolean

    /**
     * Update the age of items on {@link get}, renewing their TTL
     *
     * @default false
     */
    updateAgeOnGet?: boolean

    /**
     * Do not delete stale items when they are retrieved with {@link get}.
     * Note that the {@link get} return value will still be `undefined` unless
     * allowStale is true.
     *
     * @default false
     * @since 7.11.0
     */
    noDeleteOnStaleGet?: boolean

    /**
     * Update the age of items on {@link has}, renewing their TTL
     *
     * @default false
     */
    updateAgeOnHas?: boolean
  }

  type SafetyBounds<K, V> =
    | LimitedByCount
    | LimitedBySize<K, V>
    | LimitedByTTL

  // options shared by all three of the limiting scenarios
  interface SharedOptions<K, V> {
    /**
     * Function that is called on items when they are dropped from the cache.
     * This can be handy if you want to close file descriptors or do other
     * cleanup tasks when items are no longer accessible. Called with `key,
     * value`.  It's called before actually removing the item from the
     * internal cache, so it is *NOT* safe to re-add them.
     * Use {@link disposeAfter} if you wish to dispose items after they have
     * been full removed, when it is safe to add them back to the cache.
     */
    dispose?: Disposer<K, V>

    /**
     * The same as dispose, but called *after* the entry is completely
     * removed and the cache is once again in a clean state.  It is safe to
     * add an item right back into the cache at this point.
     * However, note that it is *very* easy to inadvertently create infinite
     * recursion this way.
     *
     * @since 7.3.0
     */
    disposeAfter?: Disposer<K, V>

    /**
     * Set to true to suppress calling the dispose() function if the entry
     * key is still accessible within the cache.
     * This may be overridden by passing an options object to {@link set}.
     *
     * @default false
     */
    noDisposeOnSet?: boolean

    /**
     * Function that is used to make background asynchronous fetches.  Called
     * with `fetchMethod(key, staleValue, { signal, options, context })`.
     *
     * If `fetchMethod` is not provided, then {@link fetch} is
     * equivalent to `Promise.resolve(cache.get(key))`.
     *
     * The `fetchMethod` should ONLY return `undefined` in cases where the
     * abort controller has sent an abort signal.
     *
     * @since 7.6.0
     */
    fetchMethod?: LRUCache.Fetcher<K, V>

    /**
     * Set to true to suppress the deletion of stale data when a
     * {@link fetchMethod} throws an error or returns a rejected promise
     *
     * This may be overridden in the {@link fetchMethod}.
     *
     * @default false
     * @since 7.10.0
     */
    noDeleteOnFetchRejection?: boolean

    /**
     * Set to true to allow returning stale data when a {@link fetchMethod}
     * throws an error or returns a rejected promise. Note that this
     * differs from using {@link allowStale} in that stale data will
     * ONLY be returned in the case that the fetch fails, not any other
     * times.
     *
     * This may be overridden in the {@link fetchMethod}.
     *
     * @default false
     * @since 7.16.0
     */
    allowStaleOnFetchRejection?: boolean

    /**
     *
     * Set to true to ignore the `abort` event emitted by the `AbortSignal`
     * object passed to {@link fetchMethod}, and still cache the
     * resulting resolution value, as long as it is not `undefined`.
     *
     * When used on its own, this means aborted {@link fetch} calls are not
     * immediately resolved or rejected when they are aborted, and instead take
     * the full time to await.
     *
     * When used with {@link allowStaleOnFetchAbort}, aborted {@link fetch}
     * calls will resolve immediately to their stale cached value or
     * `undefined`, and will continue to process and eventually update the
     * cache when they resolve, as long as the resulting value is not
     * `undefined`, thus supporting a "return stale on timeout while
     * refreshing" mechanism by passing `AbortSignal.timeout(n)` as the signal.
     *
     * **Note**: regardless of this setting, an `abort` event _is still emitted
     * on the `AbortSignal` object_, so may result in invalid results when
     * passed to other underlying APIs that use AbortSignals.
     *
     * This may be overridden in the {@link fetchMethod} or the call to
     * {@link fetch}.
     *
     * @default false
     * @since 7.17.0
     */
    ignoreFetchAbort?: boolean

    /**
     * Set to true to return a stale value from the cache when the
     * `AbortSignal` passed to the {@link fetchMethod} dispatches an `'abort'`
     * event, whether user-triggered, or due to internal cache behavior.
     *
     * Unless {@link ignoreFetchAbort} is also set, the underlying
     * {@link fetchMethod} will still be considered canceled, and its return
     * value will be ignored and not cached.
     *
     * This may be overridden in the {@link fetchMethod} or the call to
     * {@link fetch}.
     *
     * @default false
     * @since 7.17.0
     */
    allowStaleOnFetchAbort?: boolean

    /**
     * Set to any value in the constructor or {@link fetch} options to
     * pass arbitrary data to the {@link fetchMethod} in the {@link context}
     * options field.
     *
     * @since 7.12.0
     */
    fetchContext?: any
  }

  type Options<K, V> = SharedOptions<K, V> &
    DeprecatedOptions<K, V> &
    SafetyBounds<K, V> &
    MaybeMaxEntrySizeLimit<K, V>

  /**
   * options which override the options set in the LRUCache constructor
   * when making calling {@link set}.
   */
  interface SetOptions<K, V> {
    /**
     * A value for the size of the entry, prevents calls to
     * {@link sizeCalculation}.
     *
     * Items larger than {@link maxEntrySize} will not be stored in the cache.
     *
     * Note that when {@link maxSize} or {@link maxEntrySize} are set, every
     * item added MUST have a size specified, either via a `sizeCalculation` in
     * the constructor, or {@link sizeCalculation} or `size` options to
     * {@link set}.
     */
    size?: LRUSize
    /**
     * Overrides the {@link sizeCalculation} method set in the constructor.
     *
     * Items larger than {@link maxEntrySize} will not be stored in the cache.
     *
     * Note that when {@link maxSize} or {@link maxEntrySize} are set, every
     * item added MUST have a size specified, either via a `sizeCalculation` in
     * the constructor, or `sizeCalculation` or {@link size} options to
     * {@link set}.
     */
    sizeCalculation?: SizeCalculator<K, V>
    ttl?: LRUMilliseconds
    start?: LRUMilliseconds
    noDisposeOnSet?: boolean
    noUpdateTTL?: boolean
    status?: Status<V>
  }

  /**
   * options which override the options set in the LRUCAche constructor
   * when calling {@link has}.
   */
  interface HasOptions<V> {
    updateAgeOnHas?: boolean
    status: Status<V>
  }

  /**
   * options which override the options set in the LRUCache constructor
   * when calling {@link get}.
   */
  interface GetOptions<V> {
    allowStale?: boolean
    updateAgeOnGet?: boolean
    noDeleteOnStaleGet?: boolean
    status?: Status<V>
  }

  /**
   * options which override the options set in the LRUCache constructor
   * when calling {@link peek}.
   */
  interface PeekOptions {
    allowStale?: boolean
  }

  /**
   * Options object passed to the {@link fetchMethod}
   *
   * May be mutated by the {@link fetchMethod} to affect the behavior of the
   * resulting {@link set} operation on resolution, or in the case of
   * {@link noDeleteOnFetchRejection}, {@link ignoreFetchAbort}, and
   * {@link allowStaleOnFetchRejection}, the handling of failure.
   */
  interface FetcherFetchOptions<K, V> {
    allowStale?: boolean
    updateAgeOnGet?: boolean
    noDeleteOnStaleGet?: boolean
    size?: LRUSize
    sizeCalculation?: SizeCalculator<K, V>
    ttl?: LRUMilliseconds
    noDisposeOnSet?: boolean
    noUpdateTTL?: boolean
    noDeleteOnFetchRejection?: boolean
    allowStaleOnFetchRejection?: boolean
    ignoreFetchAbort?: boolean
    allowStaleOnFetchAbort?: boolean
    status?: Status<V>
  }

  /**
   * Status object that may be passed to {@link fetch}, {@link get},
   * {@link set}, and {@link has}.
   */
  interface Status<V> {
    /**
     * The status of a set() operation.
     *
     * - add: the item was not found in the cache, and was added
     * - update: the item was in the cache, with the same value provided
     * - replace: the item was in the cache, and replaced
     * - miss: the item was not added to the cache for some reason
     */
    set?: 'add' | 'update' | 'replace' | 'miss'

    /**
     * the ttl stored for the item, or undefined if ttls are not used.
     */
    ttl?: LRUMilliseconds

    /**
     * the start time for the item, or undefined if ttls are not used.
     */
    start?: LRUMilliseconds

    /**
     * The timestamp used for TTL calculation
     */
    now?: LRUMilliseconds

    /**
     * the remaining ttl for the item, or undefined if ttls are not used.
     */
    remainingTTL?: LRUMilliseconds

    /**
     * The calculated size for the item, if sizes are used.
     */
    size?: LRUSize

    /**
     * A flag indicating that the item was not stored, due to exceeding the
     * {@link maxEntrySize}
     */
    maxEntrySizeExceeded?: true

    /**
     * The old value, specified in the case of `set:'update'` or
     * `set:'replace'`
     */
    oldValue?: V

    /**
     * The results of a {@link has} operation
     *
     * - hit: the item was found in the cache
     * - stale: the item was found in the cache, but is stale
     * - miss: the item was not found in the cache
     */
    has?: 'hit' | 'stale' | 'miss'

    /**
     * The status of a {@link fetch} operation.
     * Note that this can change as the underlying fetch() moves through
     * various states.
     *
     * - inflight: there is another fetch() for this key which is in process
     * - get: there is no fetchMethod, so {@link get} was called.
     * - miss: the item is not in cache, and will be fetched.
     * - hit: the item is in the cache, and was resolved immediately.
     * - stale: the item is in the cache, but stale.
     * - refresh: the item is in the cache, and not stale, but
     *   {@link forceRefresh} was specified.
     */
    fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'

    /**
     * The {@link fetchMethod} was called
     */
    fetchDispatched?: true

    /**
     * The cached value was updated after a successful call to fetchMethod
     */
    fetchUpdated?: true

    /**
     * The reason for a fetch() rejection.  Either the error raised by the
     * {@link fetchMethod}, or the reason for an AbortSignal.
     */
    fetchError?: Error

    /**
     * The fetch received an abort signal
     */
    fetchAborted?: true

    /**
     * The abort signal received was ignored, and the fetch was allowed to
     * continue.
     */
    fetchAbortIgnored?: true

    /**
     * The fetchMethod promise resolved successfully
     */
    fetchResolved?: true

    /**
     * The fetchMethod promise was rejected
     */
    fetchRejected?: true

    /**
     * The status of a {@link get} operation.
     *
     * - fetching: The item is currently being fetched.  If a previous value is
     *   present and allowed, that will be returned.
     * - stale: The item is in the cache, and is stale.
     * - hit: the item is in the cache
     * - miss: the item is not in the cache
     */
    get?: 'stale' | 'hit' | 'miss'

    /**
     * A fetch or get operation returned a stale value.
     */
    returnedStale?: true
  }

  /**
   * options which override the options set in the LRUCache constructor
   * when calling {@link fetch}.
   *
   * This is the union of GetOptions and SetOptions, plus
   * {@link noDeleteOnFetchRejection}, {@link allowStaleOnFetchRejection},
   * {@link forceRefresh}, and {@link fetchContext}
   */
  interface FetchOptions<K, V> extends FetcherFetchOptions<K, V> {
    forceRefresh?: boolean
    fetchContext?: any
    signal?: AbortSignal
    status?: Status<V>
  }

  interface FetcherOptions<K, V> {
    signal: AbortSignal
    options: FetcherFetchOptions<K, V>
    /**
     * Object provided in the {@link fetchContext} option
     */
    context: any
  }

  interface Entry<V> {
    value: V
    ttl?: LRUMilliseconds
    size?: LRUSize
    start?: LRUMilliseconds
  }
}

export = LRUCache
const perf =
  typeof performance === 'object' &&
  performance &&
  typeof performance.now === 'function'
    ? performance
    : Date

const hasAbortController = typeof AbortController === 'function'

// minimal backwards-compatibility polyfill
// this doesn't have nearly all the checks and whatnot that
// actual AbortController/Signal has, but it's enough for
// our purposes, and if used properly, behaves the same.
const AC = hasAbortController
  ? AbortController
  : class AbortController {
      constructor() {
        this.signal = new AS()
      }
      abort(reason = new Error('This operation was aborted')) {
        this.signal.reason = this.signal.reason || reason
        this.signal.aborted = true
        this.signal.dispatchEvent({
          type: 'abort',
          target: this.signal,
        })
      }
    }

const hasAbortSignal = typeof AbortSignal === 'function'
// Some polyfills put this on the AC class, not global
const hasACAbortSignal = typeof AC.AbortSignal === 'function'
const AS = hasAbortSignal
  ? AbortSignal
  : hasACAbortSignal
  ? AC.AbortController
  : class AbortSignal {
      constructor() {
        this.reason = undefined
        this.aborted = false
        this._listeners = []
      }
      dispatchEvent(e) {
        if (e.type === 'abort') {
          this.aborted = true
          this.onabort(e)
          this._listeners.forEach(f => f(e), this)
        }
      }
      onabort() {}
      addEventListener(ev, fn) {
        if (ev === 'abort') {
          this._listeners.push(fn)
        }
      }
      removeEventListener(ev, fn) {
        if (ev === 'abort') {
          this._listeners = this._listeners.filter(f => f !== fn)
        }
      }
    }

const warned = new Set()
const deprecatedOption = (opt, instead) => {
  const code = `LRU_CACHE_OPTION_${opt}`
  if (shouldWarn(code)) {
    warn(code, `${opt} option`, `options.${instead}`, LRUCache)
  }
}
const deprecatedMethod = (method, instead) => {
  const code = `LRU_CACHE_METHOD_${method}`
  if (shouldWarn(code)) {
    const { prototype } = LRUCache
    const { get } = Object.getOwnPropertyDescriptor(prototype, method)
    warn(code, `${method} method`, `cache.${instead}()`, get)
  }
}
const deprecatedProperty = (field, instead) => {
  const code = `LRU_CACHE_PROPERTY_${field}`
  if (shouldWarn(code)) {
    const { prototype } = LRUCache
    const { get } = Object.getOwnPropertyDescriptor(prototype, field)
    warn(code, `${field} property`, `cache.${instead}`, get)
  }
}

const emitWarning = (...a) => {
  typeof process === 'object' &&
  process &&
  typeof process.emitWarning === 'function'
    ? process.emitWarning(...a)
    : console.error(...a)
}

const shouldWarn = code => !warned.has(code)

const warn = (code, what, instead, fn) => {
  warned.add(code)
  const msg = `The ${what} is deprecated. Please use ${instead} instead.`
  emitWarning(msg, 'DeprecationWarning', code, fn)
}

const isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n)

/* istanbul ignore next - This is a little bit ridiculous, tbh.
 * The maximum array length is 2^32-1 or thereabouts on most JS impls.
 * And well before that point, you're caching the entire world, I mean,
 * that's ~32GB of just integers for the next/prev links, plus whatever
 * else to hold that many keys and values.  Just filling the memory with
 * zeroes at init time is brutal when you get that big.
 * But why not be complete?
 * Maybe in the future, these limits will have expanded. */
const getUintArray = max =>
  !isPosInt(max)
    ? null
    : max <= Math.pow(2, 8)
    ? Uint8Array
    : max <= Math.pow(2, 16)
    ? Uint16Array
    : max <= Math.pow(2, 32)
    ? Uint32Array
    : max <= Number.MAX_SAFE_INTEGER
    ? ZeroArray
    : null

class ZeroArray extends Array {
  constructor(size) {
    super(size)
    this.fill(0)
  }
}

class Stack {
  constructor(max) {
    if (max === 0) {
      return []
    }
    const UintArray = getUintArray(max)
    this.heap = new UintArray(max)
    this.length = 0
  }
  push(n) {
    this.heap[this.length++] = n
  }
  pop() {
    return this.heap[--this.length]
  }
}

class LRUCache {
  constructor(options = {}) {
    const {
      max = 0,
      ttl,
      ttlResolution = 1,
      ttlAutopurge,
      updateAgeOnGet,
      updateAgeOnHas,
      allowStale,
      dispose,
      disposeAfter,
      noDisposeOnSet,
      noUpdateTTL,
      maxSize = 0,
      maxEntrySize = 0,
      sizeCalculation,
      fetchMethod,
      fetchContext,
      noDeleteOnFetchRejection,
      noDeleteOnStaleGet,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
    } = options

    // deprecated options, don't trigger a warning for getting them if
    // the thing being passed in is another LRUCache we're copying.
    const { length, maxAge, stale } =
      options instanceof LRUCache ? {} : options

    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError('max option must be a nonnegative integer')
    }

    const UintArray = max ? getUintArray(max) : Array
    if (!UintArray) {
      throw new Error('invalid max value: ' + max)
    }

    this.max = max
    this.maxSize = maxSize
    this.maxEntrySize = maxEntrySize || this.maxSize
    this.sizeCalculation = sizeCalculation || length
    if (this.sizeCalculation) {
      if (!this.maxSize && !this.maxEntrySize) {
        throw new TypeError(
          'cannot set sizeCalculation without setting maxSize or maxEntrySize'
        )
      }
      if (typeof this.sizeCalculation !== 'function') {
        throw new TypeError('sizeCalculation set to non-function')
      }
    }

    this.fetchMethod = fetchMethod || null
    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {
      throw new TypeError(
        'fetchMethod must be a function if specified'
      )
    }

    this.fetchContext = fetchContext
    if (!this.fetchMethod && fetchContext !== undefined) {
      throw new TypeError(
        'cannot set fetchContext without fetchMethod'
      )
    }

    this.keyMap = new Map()
    this.keyList = new Array(max).fill(null)
    this.valList = new Array(max).fill(null)
    this.next = new UintArray(max)
    this.prev = new UintArray(max)
    this.head = 0
    this.tail = 0
    this.free = new Stack(max)
    this.initialFill = 1
    this.size = 0

    if (typeof dispose === 'function') {
      this.dispose = dispose
    }
    if (typeof disposeAfter === 'function') {
      this.disposeAfter = disposeAfter
      this.disposed = []
    } else {
      this.disposeAfter = null
      this.disposed = null
    }
    this.noDisposeOnSet = !!noDisposeOnSet
    this.noUpdateTTL = !!noUpdateTTL
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort
    this.ignoreFetchAbort = !!ignoreFetchAbort

    // NB: maxEntrySize is set to maxSize if it's set
    if (this.maxEntrySize !== 0) {
      if (this.maxSize !== 0) {
        if (!isPosInt(this.maxSize)) {
          throw new TypeError(
            'maxSize must be a positive integer if specified'
          )
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError(
          'maxEntrySize must be a positive integer if specified'
        )
      }
      this.initializeSizeTracking()
    }

    this.allowStale = !!allowStale || !!stale
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet
    this.updateAgeOnGet = !!updateAgeOnGet
    this.updateAgeOnHas = !!updateAgeOnHas
    this.ttlResolution =
      isPosInt(ttlResolution) || ttlResolution === 0
        ? ttlResolution
        : 1
    this.ttlAutopurge = !!ttlAutopurge
    this.ttl = ttl || maxAge || 0
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError(
          'ttl must be a positive integer if specified'
        )
      }
      this.initializeTTLTracking()
    }

    // do not allow completely unbounded caches
    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
      throw new TypeError(
        'At least one of max, maxSize, or ttl is required'
      )
    }
    if (!this.ttlAutopurge && !this.max && !this.maxSize) {
      const code = 'LRU_CACHE_UNBOUNDED'
      if (shouldWarn(code)) {
        warned.add(code)
        const msg =
          'TTL caching without ttlAutopurge, max, or maxSize can ' +
          'result in unbounded memory consumption.'
        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)
      }
    }

    if (stale) {
      deprecatedOption('stale', 'allowStale')
    }
    if (maxAge) {
      deprecatedOption('maxAge', 'ttl')
    }
    if (length) {
      deprecatedOption('length', 'sizeCalculation')
    }
  }

  getRemainingTTL(key) {
    return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0
  }

  initializeTTLTracking() {
    this.ttls = new ZeroArray(this.max)
    this.starts = new ZeroArray(this.max)

    this.setItemTTL = (index, ttl, start = perf.now()) => {
      this.starts[index] = ttl !== 0 ? start : 0
      this.ttls[index] = ttl
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.isStale(index)) {
            this.delete(this.keyList[index])
          }
        }, ttl + 1)
        /* istanbul ignore else - unref() not supported on all platforms */
        if (t.unref) {
          t.unref()
        }
      }
    }

    this.updateItemAge = index => {
      this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0
    }

    this.statusTTL = (status, index) => {
      if (status) {
        status.ttl = this.ttls[index]
        status.start = this.starts[index]
        status.now = cachedNow || getNow()
        status.remainingTTL = status.now + status.ttl - status.start
      }
    }

    // debounce calls to perf.now() to 1s so we're not hitting
    // that costly call repeatedly.
    let cachedNow = 0
    const getNow = () => {
      const n = perf.now()
      if (this.ttlResolution > 0) {
        cachedNow = n
        const t = setTimeout(
          () => (cachedNow = 0),
          this.ttlResolution
        )
        /* istanbul ignore else - not available on all platforms */
        if (t.unref) {
          t.unref()
        }
      }
      return n
    }

    this.getRemainingTTL = key => {
      const index = this.keyMap.get(key)
      if (index === undefined) {
        return 0
      }
      return this.ttls[index] === 0 || this.starts[index] === 0
        ? Infinity
        : this.starts[index] +
            this.ttls[index] -
            (cachedNow || getNow())
    }

    this.isStale = index => {
      return (
        this.ttls[index] !== 0 &&
        this.starts[index] !== 0 &&
        (cachedNow || getNow()) - this.starts[index] >
          this.ttls[index]
      )
    }
  }
  updateItemAge(_index) {}
  statusTTL(_status, _index) {}
  setItemTTL(_index, _ttl, _start) {}
  isStale(_index) {
    return false
  }

  initializeSizeTracking() {
    this.calculatedSize = 0
    this.sizes = new ZeroArray(this.max)
    this.removeItemSize = index => {
      this.calculatedSize -= this.sizes[index]
      this.sizes[index] = 0
    }
    this.requireSize = (k, v, size, sizeCalculation) => {
      // provisionally accept background fetches.
      // actual value size will be checked when they return.
      if (this.isBackgroundFetch(v)) {
        return 0
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== 'function') {
            throw new TypeError('sizeCalculation must be a function')
          }
          size = sizeCalculation(v, k)
          if (!isPosInt(size)) {
            throw new TypeError(
              'sizeCalculation return invalid (expect positive integer)'
            )
          }
        } else {
          throw new TypeError(
            'invalid size value (must be positive integer). ' +
              'When maxSize or maxEntrySize is used, sizeCalculation or size ' +
              'must be set.'
          )
        }
      }
      return size
    }
    this.addItemSize = (index, size, status) => {
      this.sizes[index] = size
      if (this.maxSize) {
        const maxSize = this.maxSize - this.sizes[index]
        while (this.calculatedSize > maxSize) {
          this.evict(true)
        }
      }
      this.calculatedSize += this.sizes[index]
      if (status) {
        status.entrySize = size
        status.totalCalculatedSize = this.calculatedSize
      }
    }
  }
  removeItemSize(_index) {}
  addItemSize(_index, _size) {}
  requireSize(_k, _v, size, sizeCalculation) {
    if (size || sizeCalculation) {
      throw new TypeError(
        'cannot set size without setting maxSize or maxEntrySize on cache'
      )
    }
  }

  *indexes({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i = this.tail; true; ) {
        if (!this.isValidIndex(i)) {
          break
        }
        if (allowStale || !this.isStale(i)) {
          yield i
        }
        if (i === this.head) {
          break
        } else {
          i = this.prev[i]
        }
      }
    }
  }

  *rindexes({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i = this.head; true; ) {
        if (!this.isValidIndex(i)) {
          break
        }
        if (allowStale || !this.isStale(i)) {
          yield i
        }
        if (i === this.tail) {
          break
        } else {
          i = this.next[i]
        }
      }
    }
  }

  isValidIndex(index) {
    return (
      index !== undefined &&
      this.keyMap.get(this.keyList[index]) === index
    )
  }

  *entries() {
    for (const i of this.indexes()) {
      if (
        this.valList[i] !== undefined &&
        this.keyList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield [this.keyList[i], this.valList[i]]
      }
    }
  }
  *rentries() {
    for (const i of this.rindexes()) {
      if (
        this.valList[i] !== undefined &&
        this.keyList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield [this.keyList[i], this.valList[i]]
      }
    }
  }

  *keys() {
    for (const i of this.indexes()) {
      if (
        this.keyList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield this.keyList[i]
      }
    }
  }
  *rkeys() {
    for (const i of this.rindexes()) {
      if (
        this.keyList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield this.keyList[i]
      }
    }
  }

  *values() {
    for (const i of this.indexes()) {
      if (
        this.valList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield this.valList[i]
      }
    }
  }
  *rvalues() {
    for (const i of this.rindexes()) {
      if (
        this.valList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield this.valList[i]
      }
    }
  }

  [Symbol.iterator]() {
    return this.entries()
  }

  find(fn, getOptions) {
    for (const i of this.indexes()) {
      const v = this.valList[i]
      const value = this.isBackgroundFetch(v)
        ? v.__staleWhileFetching
        : v
      if (value === undefined) continue
      if (fn(value, this.keyList[i], this)) {
        return this.get(this.keyList[i], getOptions)
      }
    }
  }

  forEach(fn, thisp = this) {
    for (const i of this.indexes()) {
      const v = this.valList[i]
      const value = this.isBackgroundFetch(v)
        ? v.__staleWhileFetching
        : v
      if (value === undefined) continue
      fn.call(thisp, value, this.keyList[i], this)
    }
  }

  rforEach(fn, thisp = this) {
    for (const i of this.rindexes()) {
      const v = this.valList[i]
      const value = this.isBackgroundFetch(v)
        ? v.__staleWhileFetching
        : v
      if (value === undefined) continue
      fn.call(thisp, value, this.keyList[i], this)
    }
  }

  get prune() {
    deprecatedMethod('prune', 'purgeStale')
    return this.purgeStale
  }

  purgeStale() {
    let deleted = false
    for (const i of this.rindexes({ allowStale: true })) {
      if (this.isStale(i)) {
        this.delete(this.keyList[i])
        deleted = true
      }
    }
    return deleted
  }

  dump() {
    const arr = []
    for (const i of this.indexes({ allowStale: true })) {
      const key = this.keyList[i]
      const v = this.valList[i]
      const value = this.isBackgroundFetch(v)
        ? v.__staleWhileFetching
        : v
      if (value === undefined) continue
      const entry = { value }
      if (this.ttls) {
        entry.ttl = this.ttls[i]
        // always dump the start relative to a portable timestamp
        // it's ok for this to be a bit slow, it's a rare operation.
        const age = perf.now() - this.starts[i]
        entry.start = Math.floor(Date.now() - age)
      }
      if (this.sizes) {
        entry.size = this.sizes[i]
      }
      arr.unshift([key, entry])
    }
    return arr
  }

  load(arr) {
    this.clear()
    for (const [key, entry] of arr) {
      if (entry.start) {
        // entry.start is a portable timestamp, but we may be using
        // node's performance.now(), so calculate the offset.
        // it's ok for this to be a bit slow, it's a rare operation.
        const age = Date.now() - entry.start
        entry.start = perf.now() - age
      }
      this.set(key, entry.value, entry)
    }
  }

  dispose(_v, _k, _reason) {}

  set(
    k,
    v,
    {
      ttl = this.ttl,
      start,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      status,
    } = {}
  ) {
    size = this.requireSize(k, v, size, sizeCalculation)
    // if the item doesn't fit, don't do anything
    // NB: maxEntrySize set to maxSize by default
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = 'miss'
        status.maxEntrySizeExceeded = true
      }
      // have to delete, in case a background fetch is there already.
      // in non-async cases, this is a no-op
      this.delete(k)
      return this
    }
    let index = this.size === 0 ? undefined : this.keyMap.get(k)
    if (index === undefined) {
      // addition
      index = this.newIndex()
      this.keyList[index] = k
      this.valList[index] = v
      this.keyMap.set(k, index)
      this.next[this.tail] = index
      this.prev[index] = this.tail
      this.tail = index
      this.size++
      this.addItemSize(index, size, status)
      if (status) {
        status.set = 'add'
      }
      noUpdateTTL = false
    } else {
      // update
      this.moveToTail(index)
      const oldVal = this.valList[index]
      if (v !== oldVal) {
        if (this.isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error('replaced'))
        } else {
          if (!noDisposeOnSet) {
            this.dispose(oldVal, k, 'set')
            if (this.disposeAfter) {
              this.disposed.push([oldVal, k, 'set'])
            }
          }
        }
        this.removeItemSize(index)
        this.valList[index] = v
        this.addItemSize(index, size, status)
        if (status) {
          status.set = 'replace'
          const oldValue =
            oldVal && this.isBackgroundFetch(oldVal)
              ? oldVal.__staleWhileFetching
              : oldVal
          if (oldValue !== undefined) status.oldValue = oldValue
        }
      } else if (status) {
        status.set = 'update'
      }
    }
    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
      this.initializeTTLTracking()
    }
    if (!noUpdateTTL) {
      this.setItemTTL(index, ttl, start)
    }
    this.statusTTL(status, index)
    if (this.disposeAfter) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
    return this
  }

  newIndex() {
    if (this.size === 0) {
      return this.tail
    }
    if (this.size === this.max && this.max !== 0) {
      return this.evict(false)
    }
    if (this.free.length !== 0) {
      return this.free.pop()
    }
    // initial fill, just keep writing down the list
    return this.initialFill++
  }

  pop() {
    if (this.size) {
      const val = this.valList[this.head]
      this.evict(true)
      return val
    }
  }

  evict(free) {
    const head = this.head
    const k = this.keyList[head]
    const v = this.valList[head]
    if (this.isBackgroundFetch(v)) {
      v.__abortController.abort(new Error('evicted'))
    } else {
      this.dispose(v, k, 'evict')
      if (this.disposeAfter) {
        this.disposed.push([v, k, 'evict'])
      }
    }
    this.removeItemSize(head)
    // if we aren't about to use the index, then null these out
    if (free) {
      this.keyList[head] = null
      this.valList[head] = null
      this.free.push(head)
    }
    this.head = this.next[head]
    this.keyMap.delete(k)
    this.size--
    return head
  }

  has(k, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined) {
      if (!this.isStale(index)) {
        if (updateAgeOnHas) {
          this.updateItemAge(index)
        }
        if (status) status.has = 'hit'
        this.statusTTL(status, index)
        return true
      } else if (status) {
        status.has = 'stale'
        this.statusTTL(status, index)
      }
    } else if (status) {
      status.has = 'miss'
    }
    return false
  }

  // like get(), but without any LRU updating or TTL expiration
  peek(k, { allowStale = this.allowStale } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined && (allowStale || !this.isStale(index))) {
      const v = this.valList[index]
      // either stale and allowed, or forcing a refresh of non-stale value
      return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v
    }
  }

  backgroundFetch(k, index, options, context) {
    const v = index === undefined ? undefined : this.valList[index]
    if (this.isBackgroundFetch(v)) {
      return v
    }
    const ac = new AC()
    if (options.signal) {
      options.signal.addEventListener('abort', () =>
        ac.abort(options.signal.reason)
      )
    }
    const fetchOpts = {
      signal: ac.signal,
      options,
      context,
    }
    const cb = (v, updateCache = false) => {
      const { aborted } = ac.signal
      const ignoreAbort = options.ignoreFetchAbort && v !== undefined
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true
          options.status.fetchError = ac.signal.reason
          if (ignoreAbort) options.status.fetchAbortIgnored = true
        } else {
          options.status.fetchResolved = true
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason)
      }
      // either we didn't abort, and are still here, or we did, and ignored
      if (this.valList[index] === p) {
        if (v === undefined) {
          if (p.__staleWhileFetching) {
            this.valList[index] = p.__staleWhileFetching
          } else {
            this.delete(k)
          }
        } else {
          if (options.status) options.status.fetchUpdated = true
          this.set(k, v, fetchOpts.options)
        }
      }
      return v
    }
    const eb = er => {
      if (options.status) {
        options.status.fetchRejected = true
        options.status.fetchError = er
      }
      return fetchFail(er)
    }
    const fetchFail = er => {
      const { aborted } = ac.signal
      const allowStaleAborted =
        aborted && options.allowStaleOnFetchAbort
      const allowStale =
        allowStaleAborted || options.allowStaleOnFetchRejection
      const noDelete = allowStale || options.noDeleteOnFetchRejection
      if (this.valList[index] === p) {
        // if we allow stale on fetch rejections, then we need to ensure that
        // the stale value is not removed from the cache when the fetch fails.
        const del = !noDelete || p.__staleWhileFetching === undefined
        if (del) {
          this.delete(k)
        } else if (!allowStaleAborted) {
          // still replace the *promise* with the stale value,
          // since we are done with the promise at this point.
          // leave it untouched if we're still waiting for an
          // aborted background fetch that hasn't yet returned.
          this.valList[index] = p.__staleWhileFetching
        }
      }
      if (allowStale) {
        if (options.status && p.__staleWhileFetching !== undefined) {
          options.status.returnedStale = true
        }
        return p.__staleWhileFetching
      } else if (p.__returned === p) {
        throw er
      }
    }
    const pcall = (res, rej) => {
      this.fetchMethod(k, v, fetchOpts).then(v => res(v), rej)
      // ignored, we go until we finish, regardless.
      // defer check until we are actually aborting,
      // so fetchMethod can override.
      ac.signal.addEventListener('abort', () => {
        if (
          !options.ignoreFetchAbort ||
          options.allowStaleOnFetchAbort
        ) {
          res()
          // when it eventually resolves, update the cache.
          if (options.allowStaleOnFetchAbort) {
            res = v => cb(v, true)
          }
        }
      })
    }
    if (options.status) options.status.fetchDispatched = true
    const p = new Promise(pcall).then(cb, eb)
    p.__abortController = ac
    p.__staleWhileFetching = v
    p.__returned = null
    if (index === undefined) {
      // internal, don't expose status.
      this.set(k, p, { ...fetchOpts.options, status: undefined })
      index = this.keyMap.get(k)
    } else {
      this.valList[index] = p
    }
    return p
  }

  isBackgroundFetch(p) {
    return (
      p &&
      typeof p === 'object' &&
      typeof p.then === 'function' &&
      Object.prototype.hasOwnProperty.call(
        p,
        '__staleWhileFetching'
      ) &&
      Object.prototype.hasOwnProperty.call(p, '__returned') &&
      (p.__returned === p || p.__returned === null)
    )
  }

  // this takes the union of get() and set() opts, because it does both
  async fetch(
    k,
    {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      fetchContext = this.fetchContext,
      forceRefresh = false,
      status,
      signal,
    } = {}
  ) {
    if (!this.fetchMethod) {
      if (status) status.fetch = 'get'
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status,
      })
    }

    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal,
    }

    let index = this.keyMap.get(k)
    if (index === undefined) {
      if (status) status.fetch = 'miss'
      const p = this.backgroundFetch(k, index, options, fetchContext)
      return (p.__returned = p)
    } else {
      // in cache, maybe already fetching
      const v = this.valList[index]
      if (this.isBackgroundFetch(v)) {
        const stale =
          allowStale && v.__staleWhileFetching !== undefined
        if (status) {
          status.fetch = 'inflight'
          if (stale) status.returnedStale = true
        }
        return stale ? v.__staleWhileFetching : (v.__returned = v)
      }

      // if we force a refresh, that means do NOT serve the cached value,
      // unless we are already in the process of refreshing the cache.
      const isStale = this.isStale(index)
      if (!forceRefresh && !isStale) {
        if (status) status.fetch = 'hit'
        this.moveToTail(index)
        if (updateAgeOnGet) {
          this.updateItemAge(index)
        }
        this.statusTTL(status, index)
        return v
      }

      // ok, it is stale or a forced refresh, and not already fetching.
      // refresh the cache.
      const p = this.backgroundFetch(k, index, options, fetchContext)
      const hasStale = p.__staleWhileFetching !== undefined
      const staleVal = hasStale && allowStale
      if (status) {
        status.fetch = hasStale && isStale ? 'stale' : 'refresh'
        if (staleVal && isStale) status.returnedStale = true
      }
      return staleVal ? p.__staleWhileFetching : (p.__returned = p)
    }
  }

  get(
    k,
    {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      status,
    } = {}
  ) {
    const index = this.keyMap.get(k)
    if (index !== undefined) {
      const value = this.valList[index]
      const fetching = this.isBackgroundFetch(value)
      this.statusTTL(status, index)
      if (this.isStale(index)) {
        if (status) status.get = 'stale'
        // delete only if not an in-flight background fetch
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k)
          }
          if (status) status.returnedStale = allowStale
          return allowStale ? value : undefined
        } else {
          if (status) {
            status.returnedStale =
              allowStale && value.__staleWhileFetching !== undefined
          }
          return allowStale ? value.__staleWhileFetching : undefined
        }
      } else {
        if (status) status.get = 'hit'
        // if we're currently fetching it, we don't actually have it yet
        // it's not stale, which means this isn't a staleWhileRefetching.
        // If it's not stale, and fetching, AND has a __staleWhileFetching
        // value, then that means the user fetched with {forceRefresh:true},
        // so it's safe to return that value.
        if (fetching) {
          return value.__staleWhileFetching
        }
        this.moveToTail(index)
        if (updateAgeOnGet) {
          this.updateItemAge(index)
        }
        return value
      }
    } else if (status) {
      status.get = 'miss'
    }
  }

  connect(p, n) {
    this.prev[n] = p
    this.next[p] = n
  }

  moveToTail(index) {
    // if tail already, nothing to do
    // if head, move head to next[index]
    // else
    //   move next[prev[index]] to next[index] (head has no prev)
    //   move prev[next[index]] to prev[index]
    // prev[index] = tail
    // next[tail] = index
    // tail = index
    if (index !== this.tail) {
      if (index === this.head) {
        this.head = this.next[index]
      } else {
        this.connect(this.prev[index], this.next[index])
      }
      this.connect(this.tail, index)
      this.tail = index
    }
  }

  get del() {
    deprecatedMethod('del', 'delete')
    return this.delete
  }

  delete(k) {
    let deleted = false
    if (this.size !== 0) {
      const index = this.keyMap.get(k)
      if (index !== undefined) {
        deleted = true
        if (this.size === 1) {
          this.clear()
        } else {
          this.removeItemSize(index)
          const v = this.valList[index]
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('deleted'))
          } else {
            this.dispose(v, k, 'delete')
            if (this.disposeAfter) {
              this.disposed.push([v, k, 'delete'])
            }
          }
          this.keyMap.delete(k)
          this.keyList[index] = null
          this.valList[index] = null
          if (index === this.tail) {
            this.tail = this.prev[index]
          } else if (index === this.head) {
            this.head = this.next[index]
          } else {
            this.next[this.prev[index]] = this.next[index]
            this.prev[this.next[index]] = this.prev[index]
          }
          this.size--
          this.free.push(index)
        }
      }
    }
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
    return deleted
  }

  clear() {
    for (const index of this.rindexes({ allowStale: true })) {
      const v = this.valList[index]
      if (this.isBackgroundFetch(v)) {
        v.__abortController.abort(new Error('deleted'))
      } else {
        const k = this.keyList[index]
        this.dispose(v, k, 'delete')
        if (this.disposeAfter) {
          this.disposed.push([v, k, 'delete'])
        }
      }
    }

    this.keyMap.clear()
    this.valList.fill(null)
    this.keyList.fill(null)
    if (this.ttls) {
      this.ttls.fill(0)
      this.starts.fill(0)
    }
    if (this.sizes) {
      this.sizes.fill(0)
    }
    this.head = 0
    this.tail = 0
    this.initialFill = 1
    this.free.length = 0
    this.calculatedSize = 0
    this.size = 0
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
  }

  get reset() {
    deprecatedMethod('reset', 'clear')
    return this.clear
  }

  get length() {
    deprecatedProperty('length', 'size')
    return this.size
  }

  static get AbortController() {
    return AC
  }
  static get AbortSignal() {
    return AS
  }
}

module.exports = LRUCache
const perf =
  typeof performance === 'object' &&
  performance &&
  typeof performance.now === 'function'
    ? performance
    : Date

const hasAbortController = typeof AbortController === 'function'

// minimal backwards-compatibility polyfill
// this doesn't have nearly all the checks and whatnot that
// actual AbortController/Signal has, but it's enough for
// our purposes, and if used properly, behaves the same.
const AC = hasAbortController
  ? AbortController
  : class AbortController {
      constructor() {
        this.signal = new AS()
      }
      abort(reason = new Error('This operation was aborted')) {
        this.signal.reason = this.signal.reason || reason
        this.signal.aborted = true
        this.signal.dispatchEvent({
          type: 'abort',
          target: this.signal,
        })
      }
    }

const hasAbortSignal = typeof AbortSignal === 'function'
// Some polyfills put this on the AC class, not global
const hasACAbortSignal = typeof AC.AbortSignal === 'function'
const AS = hasAbortSignal
  ? AbortSignal
  : hasACAbortSignal
  ? AC.AbortController
  : class AbortSignal {
      constructor() {
        this.reason = undefined
        this.aborted = false
        this._listeners = []
      }
      dispatchEvent(e) {
        if (e.type === 'abort') {
          this.aborted = true
          this.onabort(e)
          this._listeners.forEach(f => f(e), this)
        }
      }
      onabort() {}
      addEventListener(ev, fn) {
        if (ev === 'abort') {
          this._listeners.push(fn)
        }
      }
      removeEventListener(ev, fn) {
        if (ev === 'abort') {
          this._listeners = this._listeners.filter(f => f !== fn)
        }
      }
    }

const warned = new Set()
const deprecatedOption = (opt, instead) => {
  const code = `LRU_CACHE_OPTION_${opt}`
  if (shouldWarn(code)) {
    warn(code, `${opt} option`, `options.${instead}`, LRUCache)
  }
}
const deprecatedMethod = (method, instead) => {
  const code = `LRU_CACHE_METHOD_${method}`
  if (shouldWarn(code)) {
    const { prototype } = LRUCache
    const { get } = Object.getOwnPropertyDescriptor(prototype, method)
    warn(code, `${method} method`, `cache.${instead}()`, get)
  }
}
const deprecatedProperty = (field, instead) => {
  const code = `LRU_CACHE_PROPERTY_${field}`
  if (shouldWarn(code)) {
    const { prototype } = LRUCache
    const { get } = Object.getOwnPropertyDescriptor(prototype, field)
    warn(code, `${field} property`, `cache.${instead}`, get)
  }
}

const emitWarning = (...a) => {
  typeof process === 'object' &&
  process &&
  typeof process.emitWarning === 'function'
    ? process.emitWarning(...a)
    : console.error(...a)
}

const shouldWarn = code => !warned.has(code)

const warn = (code, what, instead, fn) => {
  warned.add(code)
  const msg = `The ${what} is deprecated. Please use ${instead} instead.`
  emitWarning(msg, 'DeprecationWarning', code, fn)
}

const isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n)

/* istanbul ignore next - This is a little bit ridiculous, tbh.
 * The maximum array length is 2^32-1 or thereabouts on most JS impls.
 * And well before that point, you're caching the entire world, I mean,
 * that's ~32GB of just integers for the next/prev links, plus whatever
 * else to hold that many keys and values.  Just filling the memory with
 * zeroes at init time is brutal when you get that big.
 * But why not be complete?
 * Maybe in the future, these limits will have expanded. */
const getUintArray = max =>
  !isPosInt(max)
    ? null
    : max <= Math.pow(2, 8)
    ? Uint8Array
    : max <= Math.pow(2, 16)
    ? Uint16Array
    : max <= Math.pow(2, 32)
    ? Uint32Array
    : max <= Number.MAX_SAFE_INTEGER
    ? ZeroArray
    : null

class ZeroArray extends Array {
  constructor(size) {
    super(size)
    this.fill(0)
  }
}

class Stack {
  constructor(max) {
    if (max === 0) {
      return []
    }
    const UintArray = getUintArray(max)
    this.heap = new UintArray(max)
    this.length = 0
  }
  push(n) {
    this.heap[this.length++] = n
  }
  pop() {
    return this.heap[--this.length]
  }
}

class LRUCache {
  constructor(options = {}) {
    const {
      max = 0,
      ttl,
      ttlResolution = 1,
      ttlAutopurge,
      updateAgeOnGet,
      updateAgeOnHas,
      allowStale,
      dispose,
      disposeAfter,
      noDisposeOnSet,
      noUpdateTTL,
      maxSize = 0,
      maxEntrySize = 0,
      sizeCalculation,
      fetchMethod,
      fetchContext,
      noDeleteOnFetchRejection,
      noDeleteOnStaleGet,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
    } = options

    // deprecated options, don't trigger a warning for getting them if
    // the thing being passed in is another LRUCache we're copying.
    const { length, maxAge, stale } =
      options instanceof LRUCache ? {} : options

    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError('max option must be a nonnegative integer')
    }

    const UintArray = max ? getUintArray(max) : Array
    if (!UintArray) {
      throw new Error('invalid max value: ' + max)
    }

    this.max = max
    this.maxSize = maxSize
    this.maxEntrySize = maxEntrySize || this.maxSize
    this.sizeCalculation = sizeCalculation || length
    if (this.sizeCalculation) {
      if (!this.maxSize && !this.maxEntrySize) {
        throw new TypeError(
          'cannot set sizeCalculation without setting maxSize or maxEntrySize'
        )
      }
      if (typeof this.sizeCalculation !== 'function') {
        throw new TypeError('sizeCalculation set to non-function')
      }
    }

    this.fetchMethod = fetchMethod || null
    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {
      throw new TypeError(
        'fetchMethod must be a function if specified'
      )
    }

    this.fetchContext = fetchContext
    if (!this.fetchMethod && fetchContext !== undefined) {
      throw new TypeError(
        'cannot set fetchContext without fetchMethod'
      )
    }

    this.keyMap = new Map()
    this.keyList = new Array(max).fill(null)
    this.valList = new Array(max).fill(null)
    this.next = new UintArray(max)
    this.prev = new UintArray(max)
    this.head = 0
    this.tail = 0
    this.free = new Stack(max)
    this.initialFill = 1
    this.size = 0

    if (typeof dispose === 'function') {
      this.dispose = dispose
    }
    if (typeof disposeAfter === 'function') {
      this.disposeAfter = disposeAfter
      this.disposed = []
    } else {
      this.disposeAfter = null
      this.disposed = null
    }
    this.noDisposeOnSet = !!noDisposeOnSet
    this.noUpdateTTL = !!noUpdateTTL
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort
    this.ignoreFetchAbort = !!ignoreFetchAbort

    // NB: maxEntrySize is set to maxSize if it's set
    if (this.maxEntrySize !== 0) {
      if (this.maxSize !== 0) {
        if (!isPosInt(this.maxSize)) {
          throw new TypeError(
            'maxSize must be a positive integer if specified'
          )
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError(
          'maxEntrySize must be a positive integer if specified'
        )
      }
      this.initializeSizeTracking()
    }

    this.allowStale = !!allowStale || !!stale
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet
    this.updateAgeOnGet = !!updateAgeOnGet
    this.updateAgeOnHas = !!updateAgeOnHas
    this.ttlResolution =
      isPosInt(ttlResolution) || ttlResolution === 0
        ? ttlResolution
        : 1
    this.ttlAutopurge = !!ttlAutopurge
    this.ttl = ttl || maxAge || 0
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError(
          'ttl must be a positive integer if specified'
        )
      }
      this.initializeTTLTracking()
    }

    // do not allow completely unbounded caches
    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
      throw new TypeError(
        'At least one of max, maxSize, or ttl is required'
      )
    }
    if (!this.ttlAutopurge && !this.max && !this.maxSize) {
      const code = 'LRU_CACHE_UNBOUNDED'
      if (shouldWarn(code)) {
        warned.add(code)
        const msg =
          'TTL caching without ttlAutopurge, max, or maxSize can ' +
          'result in unbounded memory consumption.'
        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)
      }
    }

    if (stale) {
      deprecatedOption('stale', 'allowStale')
    }
    if (maxAge) {
      deprecatedOption('maxAge', 'ttl')
    }
    if (length) {
      deprecatedOption('length', 'sizeCalculation')
    }
  }

  getRemainingTTL(key) {
    return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0
  }

  initializeTTLTracking() {
    this.ttls = new ZeroArray(this.max)
    this.starts = new ZeroArray(this.max)

    this.setItemTTL = (index, ttl, start = perf.now()) => {
      this.starts[index] = ttl !== 0 ? start : 0
      this.ttls[index] = ttl
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.isStale(index)) {
            this.delete(this.keyList[index])
          }
        }, ttl + 1)
        /* istanbul ignore else - unref() not supported on all platforms */
        if (t.unref) {
          t.unref()
        }
      }
    }

    this.updateItemAge = index => {
      this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0
    }

    this.statusTTL = (status, index) => {
      if (status) {
        status.ttl = this.ttls[index]
        status.start = this.starts[index]
        status.now = cachedNow || getNow()
        status.remainingTTL = status.now + status.ttl - status.start
      }
    }

    // debounce calls to perf.now() to 1s so we're not hitting
    // that costly call repeatedly.
    let cachedNow = 0
    const getNow = () => {
      const n = perf.now()
      if (this.ttlResolution > 0) {
        cachedNow = n
        const t = setTimeout(
          () => (cachedNow = 0),
          this.ttlResolution
        )
        /* istanbul ignore else - not available on all platforms */
        if (t.unref) {
          t.unref()
        }
      }
      return n
    }

    this.getRemainingTTL = key => {
      const index = this.keyMap.get(key)
      if (index === undefined) {
        return 0
      }
      return this.ttls[index] === 0 || this.starts[index] === 0
        ? Infinity
        : this.starts[index] +
            this.ttls[index] -
            (cachedNow || getNow())
    }

    this.isStale = index => {
      return (
        this.ttls[index] !== 0 &&
        this.starts[index] !== 0 &&
        (cachedNow || getNow()) - this.starts[index] >
          this.ttls[index]
      )
    }
  }
  updateItemAge(_index) {}
  statusTTL(_status, _index) {}
  setItemTTL(_index, _ttl, _start) {}
  isStale(_index) {
    return false
  }

  initializeSizeTracking() {
    this.calculatedSize = 0
    this.sizes = new ZeroArray(this.max)
    this.removeItemSize = index => {
      this.calculatedSize -= this.sizes[index]
      this.sizes[index] = 0
    }
    this.requireSize = (k, v, size, sizeCalculation) => {
      // provisionally accept background fetches.
      // actual value size will be checked when they return.
      if (this.isBackgroundFetch(v)) {
        return 0
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== 'function') {
            throw new TypeError('sizeCalculation must be a function')
          }
          size = sizeCalculation(v, k)
          if (!isPosInt(size)) {
            throw new TypeError(
              'sizeCalculation return invalid (expect positive integer)'
            )
          }
        } else {
          throw new TypeError(
            'invalid size value (must be positive integer). ' +
              'When maxSize or maxEntrySize is used, sizeCalculation or size ' +
              'must be set.'
          )
        }
      }
      return size
    }
    this.addItemSize = (index, size, status) => {
      this.sizes[index] = size
      if (this.maxSize) {
        const maxSize = this.maxSize - this.sizes[index]
        while (this.calculatedSize > maxSize) {
          this.evict(true)
        }
      }
      this.calculatedSize += this.sizes[index]
      if (status) {
        status.entrySize = size
        status.totalCalculatedSize = this.calculatedSize
      }
    }
  }
  removeItemSize(_index) {}
  addItemSize(_index, _size) {}
  requireSize(_k, _v, size, sizeCalculation) {
    if (size || sizeCalculation) {
      throw new TypeError(
        'cannot set size without setting maxSize or maxEntrySize on cache'
      )
    }
  }

  *indexes({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i = this.tail; true; ) {
        if (!this.isValidIndex(i)) {
          break
        }
        if (allowStale || !this.isStale(i)) {
          yield i
        }
        if (i === this.head) {
          break
        } else {
          i = this.prev[i]
        }
      }
    }
  }

  *rindexes({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i = this.head; true; ) {
        if (!this.isValidIndex(i)) {
          break
        }
        if (allowStale || !this.isStale(i)) {
          yield i
        }
        if (i === this.tail) {
          break
        } else {
          i = this.next[i]
        }
      }
    }
  }

  isValidIndex(index) {
    return (
      index !== undefined &&
      this.keyMap.get(this.keyList[index]) === index
    )
  }

  *entries() {
    for (const i of this.indexes()) {
      if (
        this.valList[i] !== undefined &&
        this.keyList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield [this.keyList[i], this.valList[i]]
      }
    }
  }
  *rentries() {
    for (const i of this.rindexes()) {
      if (
        this.valList[i] !== undefined &&
        this.keyList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield [this.keyList[i], this.valList[i]]
      }
    }
  }

  *keys() {
    for (const i of this.indexes()) {
      if (
        this.keyList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield this.keyList[i]
      }
    }
  }
  *rkeys() {
    for (const i of this.rindexes()) {
      if (
        this.keyList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield this.keyList[i]
      }
    }
  }

  *values() {
    for (const i of this.indexes()) {
      if (
        this.valList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield this.valList[i]
      }
    }
  }
  *rvalues() {
    for (const i of this.rindexes()) {
      if (
        this.valList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield this.valList[i]
      }
    }
  }

  [Symbol.iterator]() {
    return this.entries()
  }

  find(fn, getOptions) {
    for (const i of this.indexes()) {
      const v = this.valList[i]
      const value = this.isBackgroundFetch(v)
        ? v.__staleWhileFetching
        : v
      if (value === undefined) continue
      if (fn(value, this.keyList[i], this)) {
        return this.get(this.keyList[i], getOptions)
      }
    }
  }

  forEach(fn, thisp = this) {
    for (const i of this.indexes()) {
      const v = this.valList[i]
      const value = this.isBackgroundFetch(v)
        ? v.__staleWhileFetching
        : v
      if (value === undefined) continue
      fn.call(thisp, value, this.keyList[i], this)
    }
  }

  rforEach(fn, thisp = this) {
    for (const i of this.rindexes()) {
      const v = this.valList[i]
      const value = this.isBackgroundFetch(v)
        ? v.__staleWhileFetching
        : v
      if (value === undefined) continue
      fn.call(thisp, value, this.keyList[i], this)
    }
  }

  get prune() {
    deprecatedMethod('prune', 'purgeStale')
    return this.purgeStale
  }

  purgeStale() {
    let deleted = false
    for (const i of this.rindexes({ allowStale: true })) {
      if (this.isStale(i)) {
        this.delete(this.keyList[i])
        deleted = true
      }
    }
    return deleted
  }

  dump() {
    const arr = []
    for (const i of this.indexes({ allowStale: true })) {
      const key = this.keyList[i]
      const v = this.valList[i]
      const value = this.isBackgroundFetch(v)
        ? v.__staleWhileFetching
        : v
      if (value === undefined) continue
      const entry = { value }
      if (this.ttls) {
        entry.ttl = this.ttls[i]
        // always dump the start relative to a portable timestamp
        // it's ok for this to be a bit slow, it's a rare operation.
        const age = perf.now() - this.starts[i]
        entry.start = Math.floor(Date.now() - age)
      }
      if (this.sizes) {
        entry.size = this.sizes[i]
      }
      arr.unshift([key, entry])
    }
    return arr
  }

  load(arr) {
    this.clear()
    for (const [key, entry] of arr) {
      if (entry.start) {
        // entry.start is a portable timestamp, but we may be using
        // node's performance.now(), so calculate the offset.
        // it's ok for this to be a bit slow, it's a rare operation.
        const age = Date.now() - entry.start
        entry.start = perf.now() - age
      }
      this.set(key, entry.value, entry)
    }
  }

  dispose(_v, _k, _reason) {}

  set(
    k,
    v,
    {
      ttl = this.ttl,
      start,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      status,
    } = {}
  ) {
    size = this.requireSize(k, v, size, sizeCalculation)
    // if the item doesn't fit, don't do anything
    // NB: maxEntrySize set to maxSize by default
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = 'miss'
        status.maxEntrySizeExceeded = true
      }
      // have to delete, in case a background fetch is there already.
      // in non-async cases, this is a no-op
      this.delete(k)
      return this
    }
    let index = this.size === 0 ? undefined : this.keyMap.get(k)
    if (index === undefined) {
      // addition
      index = this.newIndex()
      this.keyList[index] = k
      this.valList[index] = v
      this.keyMap.set(k, index)
      this.next[this.tail] = index
      this.prev[index] = this.tail
      this.tail = index
      this.size++
      this.addItemSize(index, size, status)
      if (status) {
        status.set = 'add'
      }
      noUpdateTTL = false
    } else {
      // update
      this.moveToTail(index)
      const oldVal = this.valList[index]
      if (v !== oldVal) {
        if (this.isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error('replaced'))
        } else {
          if (!noDisposeOnSet) {
            this.dispose(oldVal, k, 'set')
            if (this.disposeAfter) {
              this.disposed.push([oldVal, k, 'set'])
            }
          }
        }
        this.removeItemSize(index)
        this.valList[index] = v
        this.addItemSize(index, size, status)
        if (status) {
          status.set = 'replace'
          const oldValue =
            oldVal && this.isBackgroundFetch(oldVal)
              ? oldVal.__staleWhileFetching
              : oldVal
          if (oldValue !== undefined) status.oldValue = oldValue
        }
      } else if (status) {
        status.set = 'update'
      }
    }
    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
      this.initializeTTLTracking()
    }
    if (!noUpdateTTL) {
      this.setItemTTL(index, ttl, start)
    }
    this.statusTTL(status, index)
    if (this.disposeAfter) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
    return this
  }

  newIndex() {
    if (this.size === 0) {
      return this.tail
    }
    if (this.size === this.max && this.max !== 0) {
      return this.evict(false)
    }
    if (this.free.length !== 0) {
      return this.free.pop()
    }
    // initial fill, just keep writing down the list
    return this.initialFill++
  }

  pop() {
    if (this.size) {
      const val = this.valList[this.head]
      this.evict(true)
      return val
    }
  }

  evict(free) {
    const head = this.head
    const k = this.keyList[head]
    const v = this.valList[head]
    if (this.isBackgroundFetch(v)) {
      v.__abortController.abort(new Error('evicted'))
    } else {
      this.dispose(v, k, 'evict')
      if (this.disposeAfter) {
        this.disposed.push([v, k, 'evict'])
      }
    }
    this.removeItemSize(head)
    // if we aren't about to use the index, then null these out
    if (free) {
      this.keyList[head] = null
      this.valList[head] = null
      this.free.push(head)
    }
    this.head = this.next[head]
    this.keyMap.delete(k)
    this.size--
    return head
  }

  has(k, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined) {
      if (!this.isStale(index)) {
        if (updateAgeOnHas) {
          this.updateItemAge(index)
        }
        if (status) status.has = 'hit'
        this.statusTTL(status, index)
        return true
      } else if (status) {
        status.has = 'stale'
        this.statusTTL(status, index)
      }
    } else if (status) {
      status.has = 'miss'
    }
    return false
  }

  // like get(), but without any LRU updating or TTL expiration
  peek(k, { allowStale = this.allowStale } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined && (allowStale || !this.isStale(index))) {
      const v = this.valList[index]
      // either stale and allowed, or forcing a refresh of non-stale value
      return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v
    }
  }

  backgroundFetch(k, index, options, context) {
    const v = index === undefined ? undefined : this.valList[index]
    if (this.isBackgroundFetch(v)) {
      return v
    }
    const ac = new AC()
    if (options.signal) {
      options.signal.addEventListener('abort', () =>
        ac.abort(options.signal.reason)
      )
    }
    const fetchOpts = {
      signal: ac.signal,
      options,
      context,
    }
    const cb = (v, updateCache = false) => {
      const { aborted } = ac.signal
      const ignoreAbort = options.ignoreFetchAbort && v !== undefined
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true
          options.status.fetchError = ac.signal.reason
          if (ignoreAbort) options.status.fetchAbortIgnored = true
        } else {
          options.status.fetchResolved = true
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason)
      }
      // either we didn't abort, and are still here, or we did, and ignored
      if (this.valList[index] === p) {
        if (v === undefined) {
          if (p.__staleWhileFetching) {
            this.valList[index] = p.__staleWhileFetching
          } else {
            this.delete(k)
          }
        } else {
          if (options.status) options.status.fetchUpdated = true
          this.set(k, v, fetchOpts.options)
        }
      }
      return v
    }
    const eb = er => {
      if (options.status) {
        options.status.fetchRejected = true
        options.status.fetchError = er
      }
      return fetchFail(er)
    }
    const fetchFail = er => {
      const { aborted } = ac.signal
      const allowStaleAborted =
        aborted && options.allowStaleOnFetchAbort
      const allowStale =
        allowStaleAborted || options.allowStaleOnFetchRejection
      const noDelete = allowStale || options.noDeleteOnFetchRejection
      if (this.valList[index] === p) {
        // if we allow stale on fetch rejections, then we need to ensure that
        // the stale value is not removed from the cache when the fetch fails.
        const del = !noDelete || p.__staleWhileFetching === undefined
        if (del) {
          this.delete(k)
        } else if (!allowStaleAborted) {
          // still replace the *promise* with the stale value,
          // since we are done with the promise at this point.
          // leave it untouched if we're still waiting for an
          // aborted background fetch that hasn't yet returned.
          this.valList[index] = p.__staleWhileFetching
        }
      }
      if (allowStale) {
        if (options.status && p.__staleWhileFetching !== undefined) {
          options.status.returnedStale = true
        }
        return p.__staleWhileFetching
      } else if (p.__returned === p) {
        throw er
      }
    }
    const pcall = (res, rej) => {
      this.fetchMethod(k, v, fetchOpts).then(v => res(v), rej)
      // ignored, we go until we finish, regardless.
      // defer check until we are actually aborting,
      // so fetchMethod can override.
      ac.signal.addEventListener('abort', () => {
        if (
          !options.ignoreFetchAbort ||
          options.allowStaleOnFetchAbort
        ) {
          res()
          // when it eventually resolves, update the cache.
          if (options.allowStaleOnFetchAbort) {
            res = v => cb(v, true)
          }
        }
      })
    }
    if (options.status) options.status.fetchDispatched = true
    const p = new Promise(pcall).then(cb, eb)
    p.__abortController = ac
    p.__staleWhileFetching = v
    p.__returned = null
    if (index === undefined) {
      // internal, don't expose status.
      this.set(k, p, { ...fetchOpts.options, status: undefined })
      index = this.keyMap.get(k)
    } else {
      this.valList[index] = p
    }
    return p
  }

  isBackgroundFetch(p) {
    return (
      p &&
      typeof p === 'object' &&
      typeof p.then === 'function' &&
      Object.prototype.hasOwnProperty.call(
        p,
        '__staleWhileFetching'
      ) &&
      Object.prototype.hasOwnProperty.call(p, '__returned') &&
      (p.__returned === p || p.__returned === null)
    )
  }

  // this takes the union of get() and set() opts, because it does both
  async fetch(
    k,
    {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      fetchContext = this.fetchContext,
      forceRefresh = false,
      status,
      signal,
    } = {}
  ) {
    if (!this.fetchMethod) {
      if (status) status.fetch = 'get'
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status,
      })
    }

    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal,
    }

    let index = this.keyMap.get(k)
    if (index === undefined) {
      if (status) status.fetch = 'miss'
      const p = this.backgroundFetch(k, index, options, fetchContext)
      return (p.__returned = p)
    } else {
      // in cache, maybe already fetching
      const v = this.valList[index]
      if (this.isBackgroundFetch(v)) {
        const stale =
          allowStale && v.__staleWhileFetching !== undefined
        if (status) {
          status.fetch = 'inflight'
          if (stale) status.returnedStale = true
        }
        return stale ? v.__staleWhileFetching : (v.__returned = v)
      }

      // if we force a refresh, that means do NOT serve the cached value,
      // unless we are already in the process of refreshing the cache.
      const isStale = this.isStale(index)
      if (!forceRefresh && !isStale) {
        if (status) status.fetch = 'hit'
        this.moveToTail(index)
        if (updateAgeOnGet) {
          this.updateItemAge(index)
        }
        this.statusTTL(status, index)
        return v
      }

      // ok, it is stale or a forced refresh, and not already fetching.
      // refresh the cache.
      const p = this.backgroundFetch(k, index, options, fetchContext)
      const hasStale = p.__staleWhileFetching !== undefined
      const staleVal = hasStale && allowStale
      if (status) {
        status.fetch = hasStale && isStale ? 'stale' : 'refresh'
        if (staleVal && isStale) status.returnedStale = true
      }
      return staleVal ? p.__staleWhileFetching : (p.__returned = p)
    }
  }

  get(
    k,
    {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      status,
    } = {}
  ) {
    const index = this.keyMap.get(k)
    if (index !== undefined) {
      const value = this.valList[index]
      const fetching = this.isBackgroundFetch(value)
      this.statusTTL(status, index)
      if (this.isStale(index)) {
        if (status) status.get = 'stale'
        // delete only if not an in-flight background fetch
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k)
          }
          if (status) status.returnedStale = allowStale
          return allowStale ? value : undefined
        } else {
          if (status) {
            status.returnedStale =
              allowStale && value.__staleWhileFetching !== undefined
          }
          return allowStale ? value.__staleWhileFetching : undefined
        }
      } else {
        if (status) status.get = 'hit'
        // if we're currently fetching it, we don't actually have it yet
        // it's not stale, which means this isn't a staleWhileRefetching.
        // If it's not stale, and fetching, AND has a __staleWhileFetching
        // value, then that means the user fetched with {forceRefresh:true},
        // so it's safe to return that value.
        if (fetching) {
          return value.__staleWhileFetching
        }
        this.moveToTail(index)
        if (updateAgeOnGet) {
          this.updateItemAge(index)
        }
        return value
      }
    } else if (status) {
      status.get = 'miss'
    }
  }

  connect(p, n) {
    this.prev[n] = p
    this.next[p] = n
  }

  moveToTail(index) {
    // if tail already, nothing to do
    // if head, move head to next[index]
    // else
    //   move next[prev[index]] to next[index] (head has no prev)
    //   move prev[next[index]] to prev[index]
    // prev[index] = tail
    // next[tail] = index
    // tail = index
    if (index !== this.tail) {
      if (index === this.head) {
        this.head = this.next[index]
      } else {
        this.connect(this.prev[index], this.next[index])
      }
      this.connect(this.tail, index)
      this.tail = index
    }
  }

  get del() {
    deprecatedMethod('del', 'delete')
    return this.delete
  }

  delete(k) {
    let deleted = false
    if (this.size !== 0) {
      const index = this.keyMap.get(k)
      if (index !== undefined) {
        deleted = true
        if (this.size === 1) {
          this.clear()
        } else {
          this.removeItemSize(index)
          const v = this.valList[index]
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('deleted'))
          } else {
            this.dispose(v, k, 'delete')
            if (this.disposeAfter) {
              this.disposed.push([v, k, 'delete'])
            }
          }
          this.keyMap.delete(k)
          this.keyList[index] = null
          this.valList[index] = null
          if (index === this.tail) {
            this.tail = this.prev[index]
          } else if (index === this.head) {
            this.head = this.next[index]
          } else {
            this.next[this.prev[index]] = this.next[index]
            this.prev[this.next[index]] = this.prev[index]
          }
          this.size--
          this.free.push(index)
        }
      }
    }
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
    return deleted
  }

  clear() {
    for (const index of this.rindexes({ allowStale: true })) {
      const v = this.valList[index]
      if (this.isBackgroundFetch(v)) {
        v.__abortController.abort(new Error('deleted'))
      } else {
        const k = this.keyList[index]
        this.dispose(v, k, 'delete')
        if (this.disposeAfter) {
          this.disposed.push([v, k, 'delete'])
        }
      }
    }

    this.keyMap.clear()
    this.valList.fill(null)
    this.keyList.fill(null)
    if (this.ttls) {
      this.ttls.fill(0)
      this.starts.fill(0)
    }
    if (this.sizes) {
      this.sizes.fill(0)
    }
    this.head = 0
    this.tail = 0
    this.initialFill = 1
    this.free.length = 0
    this.calculatedSize = 0
    this.size = 0
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
  }

  get reset() {
    deprecatedMethod('reset', 'clear')
    return this.clear
  }

  get length() {
    deprecatedProperty('length', 'size')
    return this.size
  }

  static get AbortController() {
    return AC
  }
  static get AbortSignal() {
    return AS
  }
}

export default LRUCache
The ISC License

Copyright (c) 2010-2023 Isaac Z. Schlueter and Contributors

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
{
  "name": "lru-cache",
  "description": "A cache object that deletes the least-recently-used items.",
  "version": "7.18.3",
  "author": "Isaac Z. Schlueter <i@izs.me>",
  "keywords": [
    "mru",
    "lru",
    "cache"
  ],
  "sideEffects": false,
  "scripts": {
    "build": "npm run prepare",
    "pretest": "npm run prepare",
    "presnap": "npm run prepare",
    "prepare": "node ./scripts/transpile-to-esm.js",
    "size": "size-limit",
    "test": "tap",
    "snap": "tap",
    "preversion": "npm test",
    "postversion": "npm publish",
    "prepublishOnly": "git push origin --follow-tags",
    "format": "prettier --write .",
    "typedoc": "typedoc ./index.d.ts"
  },
  "type": "commonjs",
  "main": "./index.js",
  "module": "./index.mjs",
  "types": "./index.d.ts",
  "exports": {
    ".": {
      "import": {
        "types": "./index.d.ts",
        "default": "./index.mjs"
      },
      "require": {
        "types": "./index.d.ts",
        "default": "./index.js"
      }
    },
    "./package.json": "./package.json"
  },
  "repository": "git://github.com/isaacs/node-lru-cache.git",
  "devDependencies": {
    "@size-limit/preset-small-lib": "^7.0.8",
    "@types/node": "^17.0.31",
    "@types/tap": "^15.0.6",
    "benchmark": "^2.1.4",
    "c8": "^7.11.2",
    "clock-mock": "^1.0.6",
    "eslint-config-prettier": "^8.5.0",
    "prettier": "^2.6.2",
    "size-limit": "^7.0.8",
    "tap": "^16.3.4",
    "ts-node": "^10.7.0",
    "tslib": "^2.4.0",
    "typedoc": "^0.23.24",
    "typescript": "^4.6.4"
  },
  "license": "ISC",
  "files": [
    "index.js",
    "index.mjs",
    "index.d.ts"
  ],
  "engines": {
    "node": ">=12"
  },
  "prettier": {
    "semi": false,
    "printWidth": 70,
    "tabWidth": 2,
    "useTabs": false,
    "singleQuote": true,
    "jsxSingleQuote": false,
    "bracketSameLine": true,
    "arrowParens": "avoid",
    "endOfLine": "lf"
  },
  "tap": {
    "nyc-arg": [
      "--include=index.js"
    ],
    "node-arg": [
      "--expose-gc",
      "--require",
      "ts-node/register"
    ],
    "ts": false
  },
  "size-limit": [
    {
      "path": "./index.js"
    }
  ]
}
# lru-cache

A cache object that deletes the least-recently-used items.

Specify a max number of the most recently used items that you
want to keep, and this cache will keep that many of the most
recently accessed items.

This is not primarily a TTL cache, and does not make strong TTL
guarantees. There is no preemptive pruning of expired items by
default, but you _may_ set a TTL on the cache or on a single
`set`. If you do so, it will treat expired items as missing, and
delete them when fetched. If you are more interested in TTL
caching than LRU caching, check out
[@isaacs/ttlcache](http://npm.im/@isaacs/ttlcache).

As of version 7, this is one of the most performant LRU
implementations available in JavaScript, and supports a wide
diversity of use cases. However, note that using some of the
features will necessarily impact performance, by causing the
cache to have to do more work. See the "Performance" section
below.

## Installation

```bash
npm install lru-cache --save
```

## Usage

```js
// hybrid module, either works
import LRUCache from 'lru-cache'
// or:
const LRUCache = require('lru-cache')

// At least one of 'max', 'ttl', or 'maxSize' is required, to prevent
// unsafe unbounded storage.
//
// In most cases, it's best to specify a max for performance, so all
// the required memory allocation is done up-front.
//
// All the other options are optional, see the sections below for
// documentation on what each one does.  Most of them can be
// overridden for specific items in get()/set()
const options = {
  max: 500,

  // for use with tracking overall storage size
  maxSize: 5000,
  sizeCalculation: (value, key) => {
    return 1
  },

  // for use when you need to clean up something when objects
  // are evicted from the cache
  dispose: (value, key) => {
    freeFromMemoryOrWhatever(value)
  },

  // how long to live in ms
  ttl: 1000 * 60 * 5,

  // return stale items before removing from cache?
  allowStale: false,

  updateAgeOnGet: false,
  updateAgeOnHas: false,

  // async method to use for cache.fetch(), for
  // stale-while-revalidate type of behavior
  fetchMethod: async (key, staleValue, { options, signal }) => {},
}

const cache = new LRUCache(options)

cache.set('key', 'value')
cache.get('key') // "value"

// non-string keys ARE fully supported
// but note that it must be THE SAME object, not
// just a JSON-equivalent object.
var someObject = { a: 1 }
cache.set(someObject, 'a value')
// Object keys are not toString()-ed
cache.set('[object Object]', 'a different value')
assert.equal(cache.get(someObject), 'a value')
// A similar object with same keys/values won't work,
// because it's a different object identity
assert.equal(cache.get({ a: 1 }), undefined)

cache.clear() // empty the cache
```

If you put more stuff in it, then items will fall out.

## Options

### `max`

The maximum number of items that remain in the cache (assuming no
TTL pruning or explicit deletions). Note that fewer items may be
stored if size calculation is used, and `maxSize` is exceeded.
This must be a positive finite intger.

At least one of `max`, `maxSize`, or `TTL` is required. This
must be a positive integer if set.

**It is strongly recommended to set a `max` to prevent unbounded
growth of the cache.** See "Storage Bounds Safety" below.

### `maxSize`

Set to a positive integer to track the sizes of items added to
the cache, and automatically evict items in order to stay below
this size. Note that this may result in fewer than `max` items
being stored.

Attempting to add an item to the cache whose calculated size is
greater that this amount will be a no-op. The item will not be
cached, and no other items will be evicted.

Optional, must be a positive integer if provided.

Sets `maxEntrySize` to the same value, unless a different value
is provided for `maxEntrySize`.

At least one of `max`, `maxSize`, or `TTL` is required. This
must be a positive integer if set.

Even if size tracking is enabled, **it is strongly recommended to
set a `max` to prevent unbounded growth of the cache.** See
"Storage Bounds Safety" below.

### `maxEntrySize`

Set to a positive integer to track the sizes of items added to
the cache, and prevent caching any item over a given size.
Attempting to add an item whose calculated size is greater than
this amount will be a no-op. The item will not be cached, and no
other items will be evicted.

Optional, must be a positive integer if provided. Defaults to
the value of `maxSize` if provided.

### `sizeCalculation`

Function used to calculate the size of stored items. If you're
storing strings or buffers, then you probably want to do
something like `n => n.length`. The item is passed as the first
argument, and the key is passed as the second argument.

This may be overridden by passing an options object to
`cache.set()`.

Requires `maxSize` to be set.

If the `size` (or return value of `sizeCalculation`) for a given
entry is greater than `maxEntrySize`, then the item will not be
added to the cache.

Deprecated alias: `length`

### `fetchMethod`

Function that is used to make background asynchronous fetches.
Called with `fetchMethod(key, staleValue, { signal, options,
context })`. May return a Promise.

If `fetchMethod` is not provided, then `cache.fetch(key)` is
equivalent to `Promise.resolve(cache.get(key))`.

The `signal` object is an `AbortSignal` if that's available in
the global object, otherwise it's a pretty close polyfill.

If at any time, `signal.aborted` is set to `true`, or if the
`signal.onabort` method is called, or if it emits an `'abort'`
event which you can listen to with `addEventListener`, then that
means that the fetch should be abandoned. This may be passed
along to async functions aware of AbortController/AbortSignal
behavior.

The `fetchMethod` should **only** return `undefined` or a Promise
resolving to `undefined` if the AbortController signaled an
`abort` event. In all other cases, it should return or resolve
to a value suitable for adding to the cache.

The `options` object is a union of the options that may be
provided to `set()` and `get()`. If they are modified, then that
will result in modifying the settings to `cache.set()` when the
value is resolved, and in the case of `noDeleteOnFetchRejection`
and `allowStaleOnFetchRejection`, the handling of `fetchMethod`
failures.

For example, a DNS cache may update the TTL based on the value
returned from a remote DNS server by changing `options.ttl` in
the `fetchMethod`.

### `fetchContext`

Arbitrary data that can be passed to the `fetchMethod` as the
`context` option.

Note that this will only be relevant when the `cache.fetch()`
call needs to call `fetchMethod()`. Thus, any data which will
meaningfully vary the fetch response needs to be present in the
key. This is primarily intended for including `x-request-id`
headers and the like for debugging purposes, which do not affect
the `fetchMethod()` response.

### `noDeleteOnFetchRejection`

If a `fetchMethod` throws an error or returns a rejected promise,
then by default, any existing stale value will be removed from
the cache.

If `noDeleteOnFetchRejection` is set to `true`, then this
behavior is suppressed, and the stale value remains in the cache
in the case of a rejected `fetchMethod`.

This is important in cases where a `fetchMethod` is _only_ called
as a background update while the stale value is returned, when
`allowStale` is used.

This is implicitly in effect when `allowStaleOnFetchRejection` is
set.

This may be set in calls to `fetch()`, or defaulted on the
constructor, or overridden by modifying the options object in the
`fetchMethod`.

### `allowStaleOnFetchRejection`

Set to true to return a stale value from the cache when a
`fetchMethod` throws an error or returns a rejected Promise.

If a `fetchMethod` fails, and there is no stale value available,
the `fetch()` will resolve to `undefined`. Ie, all `fetchMethod`
errors are suppressed.

Implies `noDeleteOnFetchRejection`.

This may be set in calls to `fetch()`, or defaulted on the
constructor, or overridden by modifying the options object in the
`fetchMethod`.

### `allowStaleOnFetchAbort`

Set to true to return a stale value from the cache when the
`AbortSignal` passed to the `fetchMethod` dispatches an `'abort'`
event, whether user-triggered, or due to internal cache behavior.

Unless `ignoreFetchAbort` is also set, the underlying
`fetchMethod` will still be considered canceled, and its return
value will be ignored and not cached.

### `ignoreFetchAbort`

Set to true to ignore the `abort` event emitted by the
`AbortSignal` object passed to `fetchMethod`, and still cache the
resulting resolution value, as long as it is not `undefined`.

When used on its own, this means aborted `fetch()` calls are not
immediately resolved or rejected when they are aborted, and
instead take the full time to await.

When used with `allowStaleOnFetchAbort`, aborted `fetch()` calls
will resolve immediately to their stale cached value or
`undefined`, and will continue to process and eventually update
the cache when they resolve, as long as the resulting value is
not `undefined`, thus supporting a "return stale on timeout while
refreshing" mechanism by passing `AbortSignal.timeout(n)` as the
signal.

For example:

```js
const c = new LRUCache({
  ttl: 100,
  ignoreFetchAbort: true,
  allowStaleOnFetchAbort: true,
  fetchMethod: async (key, oldValue, { signal }) => {
    // note: do NOT pass the signal to fetch()!
    // let's say this fetch can take a long time.
    const res = await fetch(`https://slow-backend-server/${key}`)
    return await res.json()
  },
})

// this will return the stale value after 100ms, while still
// updating in the background for next time.
const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })
```

**Note**: regardless of this setting, an `abort` event _is still
emitted on the `AbortSignal` object_, so may result in invalid
results when passed to other underlying APIs that use
AbortSignals.

This may be overridden on the `fetch()` call or in the
`fetchMethod` itself.

### `dispose`

Function that is called on items when they are dropped from the
cache, as `this.dispose(value, key, reason)`.

This can be handy if you want to close file descriptors or do
other cleanup tasks when items are no longer stored in the cache.

**NOTE**: It is called _before_ the item has been fully removed
from the cache, so if you want to put it right back in, you need
to wait until the next tick. If you try to add it back in during
the `dispose()` function call, it will break things in subtle and
weird ways.

Unlike several other options, this may _not_ be overridden by
passing an option to `set()`, for performance reasons. If
disposal functions may vary between cache entries, then the
entire list must be scanned on every cache swap, even if no
disposal function is in use.

The `reason` will be one of the following strings, corresponding
to the reason for the item's deletion:

- `evict` Item was evicted to make space for a new addition
- `set` Item was overwritten by a new value
- `delete` Item was removed by explicit `cache.delete(key)` or by
  calling `cache.clear()`, which deletes everything.

The `dispose()` method is _not_ called for canceled calls to
`fetchMethod()`. If you wish to handle evictions, overwrites,
and deletes of in-flight asynchronous fetches, you must use the
`AbortSignal` provided.

Optional, must be a function.

### `disposeAfter`

The same as `dispose`, but called _after_ the entry is completely
removed and the cache is once again in a clean state.

It is safe to add an item right back into the cache at this
point. However, note that it is _very_ easy to inadvertently
create infinite recursion in this way.

The `disposeAfter()` method is _not_ called for canceled calls to
`fetchMethod()`. If you wish to handle evictions, overwrites,
and deletes of in-flight asynchronous fetches, you must use the
`AbortSignal` provided.

### `noDisposeOnSet`

Set to `true` to suppress calling the `dispose()` function if the
entry key is still accessible within the cache.

This may be overridden by passing an options object to
`cache.set()`.

Boolean, default `false`. Only relevant if `dispose` or
`disposeAfter` options are set.

### `ttl`

Max time to live for items before they are considered stale.
Note that stale items are NOT preemptively removed by default,
and MAY live in the cache, contributing to its LRU max, long
after they have expired.

Also, as this cache is optimized for LRU/MRU operations, some of
the staleness/TTL checks will reduce performance.

This is not primarily a TTL cache, and does not make strong TTL
guarantees. There is no pre-emptive pruning of expired items,
but you _may_ set a TTL on the cache, and it will treat expired
items as missing when they are fetched, and delete them.

Optional, but must be a positive integer in ms if specified.

This may be overridden by passing an options object to
`cache.set()`.

At least one of `max`, `maxSize`, or `TTL` is required. This
must be a positive integer if set.

Even if ttl tracking is enabled, **it is strongly recommended to
set a `max` to prevent unbounded growth of the cache.** See
"Storage Bounds Safety" below.

If ttl tracking is enabled, and `max` and `maxSize` are not set,
and `ttlAutopurge` is not set, then a warning will be emitted
cautioning about the potential for unbounded memory consumption.

Deprecated alias: `maxAge`

### `noUpdateTTL`

Boolean flag to tell the cache to not update the TTL when setting
a new value for an existing key (ie, when updating a value rather
than inserting a new value). Note that the TTL value is _always_
set (if provided) when adding a new entry into the cache.

This may be passed as an option to `cache.set()`.

Boolean, default false.

### `ttlResolution`

Minimum amount of time in ms in which to check for staleness.
Defaults to `1`, which means that the current time is checked at
most once per millisecond.

Set to `0` to check the current time every time staleness is
tested.

Note that setting this to a higher value _will_ improve
performance somewhat while using ttl tracking, albeit at the
expense of keeping stale items around a bit longer than intended.

### `ttlAutopurge`

Preemptively remove stale items from the cache.

Note that this may _significantly_ degrade performance,
especially if the cache is storing a large number of items. It
is almost always best to just leave the stale items in the cache,
and let them fall out as new items are added.

Note that this means that `allowStale` is a bit pointless, as
stale items will be deleted almost as soon as they expire.

Use with caution!

Boolean, default `false`

### `allowStale`

By default, if you set `ttl`, it'll only delete stale items from
the cache when you `get(key)`. That is, it's not preemptively
pruning items.

If you set `allowStale:true`, it'll return the stale value as
well as deleting it. If you don't set this, then it'll return
`undefined` when you try to get a stale entry.

Note that when a stale entry is fetched, _even if it is returned
due to `allowStale` being set_, it is removed from the cache
immediately. You can immediately put it back in the cache if you
wish, thus resetting the TTL.

This may be overridden by passing an options object to
`cache.get()`. The `cache.has()` method will always return
`false` for stale items.

Boolean, default false, only relevant if `ttl` is set.

Deprecated alias: `stale`

### `noDeleteOnStaleGet`

When using time-expiring entries with `ttl`, by default stale
items will be removed from the cache when the key is accessed
with `cache.get()`.

Setting `noDeleteOnStaleGet` to `true` will cause stale items to
remain in the cache, until they are explicitly deleted with
`cache.delete(key)`, or retrieved with `noDeleteOnStaleGet` set
to `false`.

This may be overridden by passing an options object to
`cache.get()`.

Boolean, default false, only relevant if `ttl` is set.

### `updateAgeOnGet`

When using time-expiring entries with `ttl`, setting this to
`true` will make each item's age reset to 0 whenever it is
retrieved from cache with `get()`, causing it to not expire. (It
can still fall out of cache based on recency of use, of course.)

This may be overridden by passing an options object to
`cache.get()`.

Boolean, default false, only relevant if `ttl` is set.

### `updateAgeOnHas`

When using time-expiring entries with `ttl`, setting this to
`true` will make each item's age reset to 0 whenever its presence
in the cache is checked with `has()`, causing it to not expire.
(It can still fall out of cache based on recency of use, of
course.)

This may be overridden by passing an options object to
`cache.has()`.

Boolean, default false, only relevant if `ttl` is set.

## API

### `new LRUCache(options)`

Create a new LRUCache. All options are documented above, and are
on the cache as public members.

### `cache.max`, `cache.maxSize`, `cache.allowStale`,

`cache.noDisposeOnSet`, `cache.sizeCalculation`, `cache.dispose`,
`cache.maxSize`, `cache.ttl`, `cache.updateAgeOnGet`,
`cache.updateAgeOnHas`

All option names are exposed as public members on the cache
object.

These are intended for read access only. Changing them during
program operation can cause undefined behavior.

### `cache.size`

The total number of items held in the cache at the current
moment.

### `cache.calculatedSize`

The total size of items in cache when using size tracking.

### `set(key, value, [{ size, sizeCalculation, ttl, noDisposeOnSet, start, status }])`

Add a value to the cache.

Optional options object may contain `ttl` and `sizeCalculation`
as described above, which default to the settings on the cache
object.

If `start` is provided, then that will set the effective start
time for the TTL calculation. Note that this must be a previous
value of `performance.now()` if supported, or a previous value of
`Date.now()` if not.

Options object may also include `size`, which will prevent
calling the `sizeCalculation` function and just use the specified
number if it is a positive integer, and `noDisposeOnSet` which
will prevent calling a `dispose` function in the case of
overwrites.

If the `size` (or return value of `sizeCalculation`) for a given
entry is greater than `maxEntrySize`, then the item will not be
added to the cache.

Will update the recency of the entry.

Returns the cache object.

For the usage of the `status` option, see **Status Tracking**
below.

### `get(key, { updateAgeOnGet, allowStale, status } = {}) => value`

Return a value from the cache.

Will update the recency of the cache entry found.

If the key is not found, `get()` will return `undefined`. This
can be confusing when setting values specifically to `undefined`,
as in `cache.set(key, undefined)`. Use `cache.has()` to
determine whether a key is present in the cache at all.

For the usage of the `status` option, see **Status Tracking**
below.

### `async fetch(key, options = {}) => Promise`

The following options are supported:

- `updateAgeOnGet`
- `allowStale`
- `size`
- `sizeCalculation`
- `ttl`
- `noDisposeOnSet`
- `forceRefresh`
- `status` - See **Status Tracking** below.
- `signal` - AbortSignal can be used to cancel the `fetch()`.
  Note that the `signal` option provided to the `fetchMethod` is
  a different object, because it must also respond to internal
  cache state changes, but aborting this signal will abort the
  one passed to `fetchMethod` as well.
- `fetchContext` - sets the `context` option passed to the
  underlying `fetchMethod`.

If the value is in the cache and not stale, then the returned
Promise resolves to the value.

If not in the cache, or beyond its TTL staleness, then
`fetchMethod(key, staleValue, { options, signal, context })` is
called, and the value returned will be added to the cache once
resolved.

If called with `allowStale`, and an asynchronous fetch is
currently in progress to reload a stale value, then the former
stale value will be returned.

If called with `forceRefresh`, then the cached item will be
re-fetched, even if it is not stale. However, if `allowStale` is
set, then the old value will still be returned. This is useful
in cases where you want to force a reload of a cached value. If
a background fetch is already in progress, then `forceRefresh`
has no effect.

Multiple fetches for the same `key` will only call `fetchMethod`
a single time, and all will be resolved when the value is
resolved, even if different options are used.

If `fetchMethod` is not specified, then this is effectively an
alias for `Promise.resolve(cache.get(key))`.

When the fetch method resolves to a value, if the fetch has not
been aborted due to deletion, eviction, or being overwritten,
then it is added to the cache using the options provided.

If the key is evicted or deleted before the `fetchMethod`
resolves, then the AbortSignal passed to the `fetchMethod` will
receive an `abort` event, and the promise returned by `fetch()`
will reject with the reason for the abort.

If a `signal` is passed to the `fetch()` call, then aborting the
signal will abort the fetch and cause the `fetch()` promise to
reject with the reason provided.

### `peek(key, { allowStale } = {}) => value`

Like `get()` but doesn't update recency or delete stale items.

Returns `undefined` if the item is stale, unless `allowStale` is
set either on the cache or in the options object.

### `has(key, { updateAgeOnHas, status } = {}) => Boolean`

Check if a key is in the cache, without updating the recency of
use. Age is updated if `updateAgeOnHas` is set to `true` in
either the options or the constructor.

Will return `false` if the item is stale, even though it is
technically in the cache.  The difference can be determined (if
it matters) by using a `status` argument, and inspecting the
`has` field.

For the usage of the `status` option, see **Status Tracking**
below.

### `delete(key)`

Deletes a key out of the cache.

Returns `true` if the key was deleted, `false` otherwise.

### `clear()`

Clear the cache entirely, throwing away all values.

Deprecated alias: `reset()`

### `keys()`

Return a generator yielding the keys in the cache, in order from
most recently used to least recently used.

### `rkeys()`

Return a generator yielding the keys in the cache, in order from
least recently used to most recently used.

### `values()`

Return a generator yielding the values in the cache, in order
from most recently used to least recently used.

### `rvalues()`

Return a generator yielding the values in the cache, in order
from least recently used to most recently used.

### `entries()`

Return a generator yielding `[key, value]` pairs, in order from
most recently used to least recently used.

### `rentries()`

Return a generator yielding `[key, value]` pairs, in order from
least recently used to most recently used.

### `find(fn, [getOptions])`

Find a value for which the supplied `fn` method returns a truthy
value, similar to `Array.find()`.

`fn` is called as `fn(value, key, cache)`.

The optional `getOptions` are applied to the resulting `get()` of
the item found.

### `dump()`

Return an array of `[key, entry]` objects which can be passed to
`cache.load()`

The `start` fields are calculated relative to a portable
`Date.now()` timestamp, even if `performance.now()` is available.

Stale entries are always included in the `dump`, even if
`allowStale` is false.

Note: this returns an actual array, not a generator, so it can be
more easily passed around.

### `load(entries)`

Reset the cache and load in the items in `entries` in the order
listed. Note that the shape of the resulting cache may be
different if the same options are not used in both caches.

The `start` fields are assumed to be calculated relative to a
portable `Date.now()` timestamp, even if `performance.now()` is
available.

### `purgeStale()`

Delete any stale entries. Returns `true` if anything was
removed, `false` otherwise.

Deprecated alias: `prune`

### `getRemainingTTL(key)`

Return the number of ms left in the item's TTL. If item is not
in cache, returns `0`. Returns `Infinity` if item is in cache
without a defined TTL.

### `forEach(fn, [thisp])`

Call the `fn` function with each set of `fn(value, key, cache)`
in the LRU cache, from most recent to least recently used.

Does not affect recency of use.

If `thisp` is provided, function will be called in the
`this`-context of the provided object.

### `rforEach(fn, [thisp])`

Same as `cache.forEach(fn, thisp)`, but in order from least
recently used to most recently used.

### `pop()`

Evict the least recently used item, returning its value.

Returns `undefined` if cache is empty.

### Internal Methods and Properties

In order to optimize performance as much as possible, "private"
members and methods are exposed on the object as normal
properties, rather than being accessed via Symbols, private
members, or closure variables.

**Do not use or rely on these.** They will change or be removed
without notice. They will cause undefined behavior if used
inappropriately. There is no need or reason to ever call them
directly.

This documentation is here so that it is especially clear that
this not "undocumented" because someone forgot; it _is_
documented, and the documentation is telling you not to do it.

**Do not report bugs that stem from using these properties.**
They will be ignored.

- `initializeTTLTracking()` Set up the cache for tracking TTLs
- `updateItemAge(index)` Called when an item age is updated, by
  internal ID
- `setItemTTL(index)` Called when an item ttl is updated, by
  internal ID
- `isStale(index)` Called to check an item's staleness, by
  internal ID
- `initializeSizeTracking()` Set up the cache for tracking item
  size. Called automatically when a size is specified.
- `removeItemSize(index)` Updates the internal size calculation
  when an item is removed or modified, by internal ID
- `addItemSize(index)` Updates the internal size calculation when
  an item is added or modified, by internal ID
- `indexes()` An iterator over the non-stale internal IDs, from
  most recently to least recently used.
- `rindexes()` An iterator over the non-stale internal IDs, from
  least recently to most recently used.
- `newIndex()` Create a new internal ID, either reusing a deleted
  ID, evicting the least recently used ID, or walking to the end
  of the allotted space.
- `evict()` Evict the least recently used internal ID, returning
  its ID. Does not do any bounds checking.
- `connect(p, n)` Connect the `p` and `n` internal IDs in the
  linked list.
- `moveToTail(index)` Move the specified internal ID to the most
  recently used position.
- `keyMap` Map of keys to internal IDs
- `keyList` List of keys by internal ID
- `valList` List of values by internal ID
- `sizes` List of calculated sizes by internal ID
- `ttls` List of TTL values by internal ID
- `starts` List of start time values by internal ID
- `next` Array of "next" pointers by internal ID
- `prev` Array of "previous" pointers by internal ID
- `head` Internal ID of least recently used item
- `tail` Internal ID of most recently used item
- `free` Stack of deleted internal IDs

## Status Tracking

Occasionally, it may be useful to track the internal behavior of
the cache, particularly for logging, debugging, or for behavior
within the `fetchMethod`.  To do this, you can pass a `status`
object to the `get()`, `set()`, `has()`, and `fetch()` methods.

The `status` option should be a plain JavaScript object.

The following fields will be set appropriately:

```ts
interface Status<V> {
  /**
   * The status of a set() operation.
   *
   * - add: the item was not found in the cache, and was added
   * - update: the item was in the cache, with the same value provided
   * - replace: the item was in the cache, and replaced
   * - miss: the item was not added to the cache for some reason
   */
  set?: 'add' | 'update' | 'replace' | 'miss'

  /**
   * the ttl stored for the item, or undefined if ttls are not used.
   */
  ttl?: LRUMilliseconds

  /**
   * the start time for the item, or undefined if ttls are not used.
   */
  start?: LRUMilliseconds

  /**
   * The timestamp used for TTL calculation
   */
  now?: LRUMilliseconds

  /**
   * the remaining ttl for the item, or undefined if ttls are not used.
   */
  remainingTTL?: LRUMilliseconds

  /**
   * The calculated size for the item, if sizes are used.
   */
  size?: LRUSize

  /**
   * A flag indicating that the item was not stored, due to exceeding the
   * {@link maxEntrySize}
   */
  maxEntrySizeExceeded?: true

  /**
   * The old value, specified in the case of `set:'update'` or
   * `set:'replace'`
   */
  oldValue?: V

  /**
   * The results of a {@link has} operation
   *
   * - hit: the item was found in the cache
   * - stale: the item was found in the cache, but is stale
   * - miss: the item was not found in the cache
   */
  has?: 'hit' | 'stale' | 'miss'

  /**
   * The status of a {@link fetch} operation.
   * Note that this can change as the underlying fetch() moves through
   * various states.
   *
   * - inflight: there is another fetch() for this key which is in process
   * - get: there is no fetchMethod, so {@link get} was called.
   * - miss: the item is not in cache, and will be fetched.
   * - hit: the item is in the cache, and was resolved immediately.
   * - stale: the item is in the cache, but stale.
   * - refresh: the item is in the cache, and not stale, but
   *   {@link forceRefresh} was specified.
   */
  fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'

  /**
   * The {@link fetchMethod} was called
   */
  fetchDispatched?: true

  /**
   * The cached value was updated after a successful call to fetchMethod
   */
  fetchUpdated?: true

  /**
   * The reason for a fetch() rejection.  Either the error raised by the
   * {@link fetchMethod}, or the reason for an AbortSignal.
   */
  fetchError?: Error

  /**
   * The fetch received an abort signal
   */
  fetchAborted?: true

  /**
   * The abort signal received was ignored, and the fetch was allowed to
   * continue.
   */
  fetchAbortIgnored?: true

  /**
   * The fetchMethod promise resolved successfully
   */
  fetchResolved?: true

  /**
   * The results of the fetchMethod promise were stored in the cache
   */
  fetchUpdated?: true

  /**
   * The fetchMethod promise was rejected
   */
  fetchRejected?: true

  /**
   * The status of a {@link get} operation.
   *
   * - fetching: The item is currently being fetched.  If a previous value is
   *   present and allowed, that will be returned.
   * - stale: The item is in the cache, and is stale.
   * - hit: the item is in the cache
   * - miss: the item is not in the cache
   */
  get?: 'stale' | 'hit' | 'miss'

  /**
   * A fetch or get operation returned a stale value.
   */
  returnedStale?: true
}
```

## Storage Bounds Safety

This implementation aims to be as flexible as possible, within
the limits of safe memory consumption and optimal performance.

At initial object creation, storage is allocated for `max` items.
If `max` is set to zero, then some performance is lost, and item
count is unbounded. Either `maxSize` or `ttl` _must_ be set if
`max` is not specified.

If `maxSize` is set, then this creates a safe limit on the
maximum storage consumed, but without the performance benefits of
pre-allocation. When `maxSize` is set, every item _must_ provide
a size, either via the `sizeCalculation` method provided to the
constructor, or via a `size` or `sizeCalculation` option provided
to `cache.set()`. The size of every item _must_ be a positive
integer.

If neither `max` nor `maxSize` are set, then `ttl` tracking must
be enabled. Note that, even when tracking item `ttl`, items are
_not_ preemptively deleted when they become stale, unless
`ttlAutopurge` is enabled. Instead, they are only purged the
next time the key is requested. Thus, if `ttlAutopurge`, `max`,
and `maxSize` are all not set, then the cache will potentially
grow unbounded.

In this case, a warning is printed to standard error. Future
versions may require the use of `ttlAutopurge` if `max` and
`maxSize` are not specified.

If you truly wish to use a cache that is bound _only_ by TTL
expiration, consider using a `Map` object, and calling
`setTimeout` to delete entries when they expire. It will perform
much better than an LRU cache.

Here is an implementation you may use, under the same
[license](./LICENSE) as this package:

```js
// a storage-unbounded ttl cache that is not an lru-cache
const cache = {
  data: new Map(),
  timers: new Map(),
  set: (k, v, ttl) => {
    if (cache.timers.has(k)) {
      clearTimeout(cache.timers.get(k))
    }
    cache.timers.set(
      k,
      setTimeout(() => cache.delete(k), ttl)
    )
    cache.data.set(k, v)
  },
  get: k => cache.data.get(k),
  has: k => cache.data.has(k),
  delete: k => {
    if (cache.timers.has(k)) {
      clearTimeout(cache.timers.get(k))
    }
    cache.timers.delete(k)
    return cache.data.delete(k)
  },
  clear: () => {
    cache.data.clear()
    for (const v of cache.timers.values()) {
      clearTimeout(v)
    }
    cache.timers.clear()
  },
}
```

If that isn't to your liking, check out
[@isaacs/ttlcache](http://npm.im/@isaacs/ttlcache).

## Performance

As of January 2022, version 7 of this library is one of the most
performant LRU cache implementations in JavaScript.

Benchmarks can be extremely difficult to get right. In
particular, the performance of set/get/delete operations on
objects will vary _wildly_ depending on the type of key used. V8
is highly optimized for objects with keys that are short strings,
especially integer numeric strings. Thus any benchmark which
tests _solely_ using numbers as keys will tend to find that an
object-based approach performs the best.

Note that coercing _anything_ to strings to use as object keys is
unsafe, unless you can be 100% certain that no other type of
value will be used. For example:

```js
const myCache = {}
const set = (k, v) => (myCache[k] = v)
const get = k => myCache[k]

set({}, 'please hang onto this for me')
set('[object Object]', 'oopsie')
```

Also beware of "Just So" stories regarding performance. Garbage
collection of large (especially: deep) object graphs can be
incredibly costly, with several "tipping points" where it
increases exponentially. As a result, putting that off until
later can make it much worse, and less predictable. If a library
performs well, but only in a scenario where the object graph is
kept shallow, then that won't help you if you are using large
objects as keys.

In general, when attempting to use a library to improve
performance (such as a cache like this one), it's best to choose
an option that will perform well in the sorts of scenarios where
you'll actually use it.

This library is optimized for repeated gets and minimizing
eviction time, since that is the expected need of a LRU. Set
operations are somewhat slower on average than a few other
options, in part because of that optimization. It is assumed
that you'll be caching some costly operation, ideally as rarely
as possible, so optimizing set over get would be unwise.

If performance matters to you:

1. If it's at all possible to use small integer values as keys,
   and you can guarantee that no other types of values will be
   used as keys, then do that, and use a cache such as
   [lru-fast](https://npmjs.com/package/lru-fast), or
   [mnemonist's
   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache)
   which uses an Object as its data store.
2. Failing that, if at all possible, use short non-numeric
   strings (ie, less than 256 characters) as your keys, and use
   [mnemonist's
   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache).
3. If the types of your keys will be long strings, strings that
   look like floats, `null`, objects, or some mix of types, or if
   you aren't sure, then this library will work well for you.
4. Do not use a `dispose` function, size tracking, or especially
   ttl behavior, unless absolutely needed. These features are
   convenient, and necessary in some use cases, and every attempt
   has been made to make the performance impact minimal, but it
   isn't nothing.

## Breaking Changes in Version 7

This library changed to a different algorithm and internal data
structure in version 7, yielding significantly better
performance, albeit with some subtle changes as a result.

If you were relying on the internals of LRUCache in version 6 or
before, it probably will not work in version 7 and above.

For more info, see the [change log](CHANGELOG.md).
#!/usr/bin/env node
export {};
#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const commist_1 = __importDefault(require("commist"));
const help_me_1 = __importDefault(require("help-me"));
const pub_1 = __importDefault(require("./pub"));
const sub_1 = __importDefault(require("./sub"));
const version = require('../../package.json').version;
const helpMe = (0, help_me_1.default)({
    dir: path_1.default.join(__dirname, '../../', 'help'),
    ext: '.txt',
});
const commist = (0, commist_1.default)();
commist.register('publish', pub_1.default);
commist.register('pub', pub_1.default);
commist.register('subscribe', sub_1.default);
commist.register('sub', sub_1.default);
commist.register('version', () => {
    console.log('MQTT.js version:', version);
});
commist.register('help', helpMe.toStdout);
if (commist.parse(process.argv.slice(2)) !== null) {
    console.log('No such command:', process.argv[2], '\n');
    helpMe.toStdout();
}
//# sourceMappingURL=mqtt.js.map{"version":3,"file":"mqtt.js","sourceRoot":"","sources":["../../src/bin/mqtt.ts"],"names":[],"mappings":";;;;;;AAQA,gDAAuB;AACvB,sDAA6B;AAC7B,sDAA0B;AAC1B,gDAA2B;AAC3B,gDAA6B;AAG7B,MAAM,OAAO,GAAG,OAAO,CAAC,oBAAoB,CAAC,CAAC,OAAO,CAAA;AAErD,MAAM,MAAM,GAAG,IAAA,iBAAI,EAAC;IACnB,GAAG,EAAE,cAAI,CAAC,IAAI,CAAC,SAAS,EAAE,QAAQ,EAAE,MAAM,CAAC;IAC3C,GAAG,EAAE,MAAM;CACX,CAAC,CAAA;AAEF,MAAM,OAAO,GAAG,IAAA,iBAAO,GAAE,CAAA;AAEzB,OAAO,CAAC,QAAQ,CAAC,SAAS,EAAE,aAAO,CAAC,CAAA;AACpC,OAAO,CAAC,QAAQ,CAAC,KAAK,EAAE,aAAO,CAAC,CAAA;AAEhC,OAAO,CAAC,QAAQ,CAAC,WAAW,EAAE,aAAS,CAAC,CAAA;AACxC,OAAO,CAAC,QAAQ,CAAC,KAAK,EAAE,aAAS,CAAC,CAAA;AAElC,OAAO,CAAC,QAAQ,CAAC,SAAS,EAAE,GAAG,EAAE;IAChC,OAAO,CAAC,GAAG,CAAC,kBAAkB,EAAE,OAAO,CAAC,CAAA;AACzC,CAAC,CAAC,CAAA;AACF,OAAO,CAAC,QAAQ,CAAC,MAAM,EAAE,MAAM,CAAC,QAAQ,CAAC,CAAA;AAEzC,IAAI,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;IAClD,OAAO,CAAC,GAAG,CAAC,kBAAkB,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAA;IACtD,MAAM,CAAC,QAAQ,EAAE,CAAA;CACjB"}#!/usr/bin/env node
export default function start(args: string[]): any;
#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const readable_stream_1 = require("readable-stream");
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const concat_stream_1 = __importDefault(require("concat-stream"));
const help_me_1 = __importDefault(require("help-me"));
const minimist_1 = __importDefault(require("minimist"));
const split2_1 = __importDefault(require("split2"));
const mqtt_1 = require("../mqtt");
const stream_1 = require("stream");
const helpMe = (0, help_me_1.default)({
    dir: path_1.default.join(__dirname, '../../', 'help'),
});
function send(args) {
    const client = (0, mqtt_1.connect)(args);
    client.on('connect', () => {
        client.publish(args.topic, args.message, args, (err) => {
            if (err) {
                console.warn(err);
            }
            client.end();
        });
    });
    client.on('error', (err) => {
        console.warn(err);
        client.end();
    });
}
function multisend(args) {
    const client = (0, mqtt_1.connect)(args);
    const sender = new readable_stream_1.Writable({
        objectMode: true,
    });
    sender._write = (line, enc, cb) => {
        client.publish(args.topic, line.trim(), args, cb);
    };
    client.on('connect', () => {
        (0, stream_1.pipeline)(process.stdin, (0, split2_1.default)(), sender, (err) => {
            client.end();
            if (err) {
                throw err;
            }
        });
    });
}
function start(args) {
    var _a, _b;
    const parsedArgs = (0, minimist_1.default)(args, {
        string: [
            'hostname',
            'username',
            'password',
            'key',
            'cert',
            'ca',
            'message',
            'clientId',
            'i',
            'id',
        ],
        boolean: ['stdin', 'retain', 'help', 'insecure', 'multiline'],
        alias: {
            port: 'p',
            hostname: ['h', 'host'],
            topic: 't',
            message: 'm',
            qos: 'q',
            clientId: ['i', 'id'],
            retain: 'r',
            username: 'u',
            password: 'P',
            stdin: 's',
            multiline: 'M',
            protocol: ['C', 'l'],
            help: 'H',
            ca: 'cafile',
        },
        default: {
            host: 'localhost',
            qos: 0,
            retain: false,
            topic: '',
            message: '',
        },
    });
    if (parsedArgs.help) {
        return helpMe.toStdout('publish');
    }
    if (parsedArgs.key) {
        parsedArgs.key = fs_1.default.readFileSync(parsedArgs.key);
    }
    if (parsedArgs.cert) {
        parsedArgs.cert = fs_1.default.readFileSync(parsedArgs.cert);
    }
    if (parsedArgs.ca) {
        parsedArgs.ca = fs_1.default.readFileSync(parsedArgs.ca);
    }
    if (parsedArgs.key && parsedArgs.cert && !parsedArgs.protocol) {
        parsedArgs.protocol = 'mqtts';
    }
    if (parsedArgs.port) {
        if (typeof parsedArgs.port !== 'number') {
            console.warn("# Port: number expected, '%s' was given.", typeof parsedArgs.port);
            return;
        }
    }
    if (parsedArgs['will-topic']) {
        parsedArgs.will = {};
        parsedArgs.will.topic = parsedArgs['will-topic'];
        parsedArgs.will.payload = parsedArgs['will-message'];
        parsedArgs.will.qos = parsedArgs['will-qos'];
        parsedArgs.will.retain = parsedArgs['will-retain'];
    }
    if (parsedArgs.insecure) {
        parsedArgs.rejectUnauthorized = false;
    }
    parsedArgs.topic = (_a = (parsedArgs.topic || parsedArgs._.shift())) === null || _a === void 0 ? void 0 : _a.toString();
    parsedArgs.message = (_b = (parsedArgs.message || parsedArgs._.shift())) === null || _b === void 0 ? void 0 : _b.toString();
    if (!parsedArgs.topic) {
        console.error('missing topic\n');
        return helpMe.toStdout('publish');
    }
    if (parsedArgs.stdin) {
        if (parsedArgs.multiline) {
            multisend(parsedArgs);
        }
        else {
            process.stdin.pipe((0, concat_stream_1.default)((data) => {
                parsedArgs.message = data;
                send(parsedArgs);
            }));
        }
    }
    else {
        send(parsedArgs);
    }
}
exports.default = start;
if (require.main === module) {
    start(process.argv.slice(2));
}
//# sourceMappingURL=pub.js.map{"version":3,"file":"pub.js","sourceRoot":"","sources":["../../src/bin/pub.ts"],"names":[],"mappings":"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"}#!/usr/bin/env node
export default function start(args: string[]): any;
#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const minimist_1 = __importDefault(require("minimist"));
const help_me_1 = __importDefault(require("help-me"));
const mqtt_1 = require("../mqtt");
const helpMe = (0, help_me_1.default)({
    dir: path_1.default.join(__dirname, '../../', 'help'),
});
function start(args) {
    const parsedArgs = (0, minimist_1.default)(args, {
        string: [
            'hostname',
            'username',
            'password',
            'key',
            'cert',
            'ca',
            'clientId',
            'i',
            'id',
        ],
        boolean: ['stdin', 'help', 'clean', 'insecure'],
        alias: {
            port: 'p',
            hostname: ['h', 'host'],
            topic: 't',
            qos: 'q',
            clean: 'c',
            keepalive: 'k',
            clientId: ['i', 'id'],
            username: 'u',
            password: 'P',
            protocol: ['C', 'l'],
            verbose: 'v',
            help: '-H',
            ca: 'cafile',
        },
        default: {
            host: 'localhost',
            qos: 0,
            retain: false,
            clean: true,
            keepAlive: 30,
        },
    });
    if (parsedArgs.help) {
        return helpMe.toStdout('subscribe');
    }
    parsedArgs.topic = parsedArgs.topic || parsedArgs._.shift();
    if (!parsedArgs.topic) {
        console.error('missing topic\n');
        return helpMe.toStdout('subscribe');
    }
    if (parsedArgs.key) {
        parsedArgs.key = fs_1.default.readFileSync(parsedArgs.key);
    }
    if (parsedArgs.cert) {
        parsedArgs.cert = fs_1.default.readFileSync(parsedArgs.cert);
    }
    if (parsedArgs.ca) {
        parsedArgs.ca = fs_1.default.readFileSync(parsedArgs.ca);
    }
    if (parsedArgs.key && parsedArgs.cert && !parsedArgs.protocol) {
        parsedArgs.protocol = 'mqtts';
    }
    if (parsedArgs.insecure) {
        parsedArgs.rejectUnauthorized = false;
    }
    if (parsedArgs.port) {
        if (typeof parsedArgs.port !== 'number') {
            console.warn("# Port: number expected, '%s' was given.", typeof parsedArgs.port);
            return;
        }
    }
    if (parsedArgs['will-topic']) {
        parsedArgs.will = {};
        parsedArgs.will.topic = parsedArgs['will-topic'];
        parsedArgs.will.payload = parsedArgs['will-message'];
        parsedArgs.will.qos = parsedArgs['will-qos'];
        parsedArgs.will.retain = parsedArgs['will-retain'];
    }
    parsedArgs.keepAlive = parsedArgs['keep-alive'];
    const client = (0, mqtt_1.connect)(parsedArgs);
    client.on('connect', () => {
        client.subscribe(parsedArgs.topic, { qos: parsedArgs.qos }, (err, result) => {
            if (err) {
                console.error(err);
                process.exit(1);
            }
            result.forEach((sub) => {
                if (sub.qos > 2) {
                    console.error('subscription negated to', sub.topic, 'with code', sub.qos);
                    process.exit(1);
                }
            });
        });
    });
    client.on('message', (topic, payload) => {
        if (parsedArgs.verbose) {
            console.log(topic, payload.toString());
        }
        else {
            console.log(payload.toString());
        }
    });
    client.on('error', (err) => {
        console.warn(err);
        client.end();
    });
}
exports.default = start;
if (require.main === module) {
    start(process.argv.slice(2));
}
//# sourceMappingURL=sub.js.map{"version":3,"file":"sub.js","sourceRoot":"","sources":["../../src/bin/sub.ts"],"names":[],"mappings":"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"}/// <reference types="node" />
/// <reference types="node" />
import { IAuthPacket, IConnackPacket, IDisconnectPacket, IPublishPacket, ISubscribePacket, Packet, QoS, IConnectPacket } from 'mqtt-packet';
import { IMessageIdProvider } from './default-message-id-provider';
import { DuplexOptions } from 'readable-stream';
import Store, { IStore } from './store';
import { ClientOptions } from 'ws';
import { ClientRequestArgs } from 'http';
import { DoneCallback, ErrorWithReasonCode, IStream, StreamBuilder, VoidCallback } from './shared';
import { TypedEventEmitter } from './TypedEmitter';
export type MqttProtocol = 'wss' | 'ws' | 'mqtt' | 'mqtts' | 'tcp' | 'ssl' | 'wx' | 'wxs' | 'ali' | 'alis';
export type StorePutCallback = () => void;
export interface ISecureClientOptions {
    key?: string | string[] | Buffer | Buffer[] | any[];
    keyPath?: string;
    cert?: string | string[] | Buffer | Buffer[];
    certPath?: string;
    ca?: string | string[] | Buffer | Buffer[];
    caPaths?: string | string[];
    rejectUnauthorized?: boolean;
    ALPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array;
}
export type AckHandler = (topic: string, message: Buffer, packet: any, cb: (error: Error | number, code?: number) => void) => void;
export interface IClientOptions extends ISecureClientOptions {
    encoding?: BufferEncoding;
    browserBufferSize?: number;
    binary?: boolean;
    my?: any;
    manualConnect?: boolean;
    authPacket?: Partial<IAuthPacket>;
    writeCache?: boolean;
    servername?: string;
    defaultProtocol?: MqttProtocol;
    query?: Record<string, string>;
    auth?: string;
    customHandleAcks?: AckHandler;
    port?: number;
    host?: string;
    hostname?: string;
    path?: string;
    protocol?: MqttProtocol;
    wsOptions?: ClientOptions | ClientRequestArgs | DuplexOptions;
    reconnectPeriod?: number;
    connectTimeout?: number;
    incomingStore?: IStore;
    outgoingStore?: IStore;
    queueQoSZero?: boolean;
    log?: (...args: any[]) => void;
    autoUseTopicAlias?: boolean;
    autoAssignTopicAlias?: boolean;
    reschedulePings?: boolean;
    servers?: Array<{
        host: string;
        port: number;
        protocol?: 'wss' | 'ws' | 'mqtt' | 'mqtts' | 'tcp' | 'ssl' | 'wx' | 'wxs';
    }>;
    resubscribe?: boolean;
    transformWsUrl?: (url: string, options: IClientOptions, client: MqttClient) => string;
    createWebsocket?: (url: string, websocketSubProtocols: string[], options: IClientOptions) => any;
    messageIdProvider?: IMessageIdProvider;
    browserBufferTimeout?: number;
    objectMode?: boolean;
    clientId?: string;
    protocolVersion?: IConnectPacket['protocolVersion'];
    protocolId?: IConnectPacket['protocolId'];
    clean?: boolean;
    keepalive?: number;
    username?: string;
    password?: Buffer | string;
    will?: IConnectPacket['will'];
    properties?: IConnectPacket['properties'];
}
export interface IClientPublishOptions {
    qos?: QoS;
    retain?: boolean;
    dup?: boolean;
    properties?: IPublishPacket['properties'];
    cbStorePut?: StorePutCallback;
}
export interface IClientReconnectOptions {
    incomingStore?: Store;
    outgoingStore?: Store;
}
export interface IClientSubscribeProperties {
    properties?: ISubscribePacket['properties'];
}
export interface IClientSubscribeOptions extends IClientSubscribeProperties {
    qos: QoS;
    nl?: boolean;
    rap?: boolean;
    rh?: number;
}
export interface ISubscriptionRequest extends IClientSubscribeOptions {
    topic: string;
}
export interface ISubscriptionGrant extends Omit<ISubscriptionRequest, 'qos' | 'properties'> {
    qos: QoS | 128;
}
export type ISubscriptionMap = {
    [topic: string]: IClientSubscribeOptions;
} & {
    resubscribe?: boolean;
};
export { IConnackPacket, IDisconnectPacket, IPublishPacket, Packet };
export type OnConnectCallback = (packet: IConnackPacket) => void;
export type OnDisconnectCallback = (packet: IDisconnectPacket) => void;
export type ClientSubscribeCallback = (err: Error | null, granted: ISubscriptionGrant[]) => void;
export type OnMessageCallback = (topic: string, payload: Buffer, packet: IPublishPacket) => void;
export type OnPacketCallback = (packet: Packet) => void;
export type OnCloseCallback = () => void;
export type OnErrorCallback = (error: Error | ErrorWithReasonCode) => void;
export type PacketCallback = (error?: Error, packet?: Packet) => any;
export type CloseCallback = (error?: Error) => void;
export interface MqttClientEventCallbacks {
    connect: OnConnectCallback;
    message: OnMessageCallback;
    packetsend: OnPacketCallback;
    packetreceive: OnPacketCallback;
    disconnect: OnDisconnectCallback;
    error: OnErrorCallback;
    close: OnCloseCallback;
    end: VoidCallback;
    reconnect: VoidCallback;
    offline: VoidCallback;
    outgoingEmpty: VoidCallback;
}
export default class MqttClient extends TypedEventEmitter<MqttClientEventCallbacks> {
    connected: boolean;
    disconnecting: boolean;
    disconnected: boolean;
    reconnecting: boolean;
    incomingStore: IStore;
    outgoingStore: IStore;
    options: IClientOptions;
    queueQoSZero: boolean;
    _reconnectCount: number;
    log: (...args: any[]) => void;
    messageIdProvider: IMessageIdProvider;
    pingResp: boolean;
    outgoing: Record<number, {
        volatile: boolean;
        cb: (err: Error, packet?: Packet) => void;
    }>;
    messageIdToTopic: Record<number, string[]>;
    noop: (error?: any) => void;
    pingTimer: any;
    stream: IStream;
    queue: {
        packet: Packet;
        cb: PacketCallback;
    }[];
    private streamBuilder;
    private _resubscribeTopics;
    private connackTimer;
    private reconnectTimer;
    private _storeProcessing;
    private _packetIdsDuringStoreProcessing;
    private _storeProcessingQueue;
    private _firstConnection;
    private topicAliasRecv;
    private topicAliasSend;
    private _deferredReconnect;
    private connackPacket;
    static defaultId(): string;
    constructor(streamBuilder: StreamBuilder, options: IClientOptions);
    handleAuth(packet: IAuthPacket, callback: PacketCallback): void;
    handleMessage(packet: IPublishPacket, callback: DoneCallback): void;
    private _nextId;
    getLastMessageId(): number;
    connect(): this;
    publish(topic: string, message: string | Buffer): MqttClient;
    publish(topic: string, message: string | Buffer, callback?: PacketCallback): MqttClient;
    publish(topic: string, message: string | Buffer, opts?: IClientPublishOptions, callback?: PacketCallback): MqttClient;
    publishAsync(topic: string, message: string | Buffer): Promise<Packet | undefined>;
    publishAsync(topic: string, message: string | Buffer, opts?: IClientPublishOptions): Promise<Packet | undefined>;
    subscribe(topicObject: string | string[] | ISubscriptionMap): MqttClient;
    subscribe(topicObject: string | string[] | ISubscriptionMap, callback?: ClientSubscribeCallback): MqttClient;
    subscribe(topicObject: string | string[] | ISubscriptionMap, opts?: IClientSubscribeOptions | IClientSubscribeProperties): MqttClient;
    subscribe(topicObject: string | string[] | ISubscriptionMap, opts?: IClientSubscribeOptions | IClientSubscribeProperties, callback?: ClientSubscribeCallback): MqttClient;
    subscribeAsync(topicObject: string | string[] | ISubscriptionMap): Promise<ISubscriptionGrant[]>;
    subscribeAsync(topicObject: string | string[] | ISubscriptionMap, opts?: IClientSubscribeOptions | IClientSubscribeProperties): Promise<ISubscriptionGrant[]>;
    unsubscribe(topic: string | string[]): MqttClient;
    unsubscribe(topic: string | string[], opts?: IClientSubscribeOptions): MqttClient;
    unsubscribe(topic: string | string[], callback?: PacketCallback): MqttClient;
    unsubscribe(topic: string | string[], opts?: IClientSubscribeOptions, callback?: PacketCallback): MqttClient;
    unsubscribeAsync(topic: string | string[]): Promise<Packet | undefined>;
    unsubscribeAsync(topic: string | string[], opts?: IClientSubscribeOptions): Promise<Packet | undefined>;
    end(cb?: DoneCallback): MqttClient;
    end(force?: boolean): MqttClient;
    end(opts?: Partial<IDisconnectPacket>, cb?: DoneCallback): MqttClient;
    end(force?: boolean, cb?: DoneCallback): MqttClient;
    end(force?: boolean, opts?: Partial<IDisconnectPacket>, cb?: DoneCallback): MqttClient;
    endAsync(): Promise<void>;
    endAsync(force?: boolean): Promise<void>;
    endAsync(opts?: Partial<IDisconnectPacket>): Promise<void>;
    endAsync(force?: boolean, opts?: Partial<IDisconnectPacket>): Promise<void>;
    removeOutgoingMessage(messageId: number): MqttClient;
    reconnect(opts?: Pick<IClientOptions, 'incomingStore' | 'outgoingStore'>): MqttClient;
    private _flushVolatile;
    private _flush;
    private _removeTopicAliasAndRecoverTopicName;
    private _checkDisconnecting;
    private _reconnect;
    private _setupReconnect;
    private _clearReconnect;
    private _cleanUp;
    private _storeAndSend;
    private _applyTopicAlias;
    private _noop;
    private _writePacket;
    private _sendPacket;
    private _storePacket;
    private _setupPingTimer;
    private _shiftPingInterval;
    private _checkPing;
    private _resubscribe;
    private _onConnect;
    private _invokeStoreProcessingQueue;
    private _invokeAllStoreProcessingQueue;
    private _flushStoreProcessingQueue;
    private _removeOutgoingAndStoreMessage;
}
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const topic_alias_recv_1 = __importDefault(require("./topic-alias-recv"));
const mqtt_packet_1 = __importDefault(require("mqtt-packet"));
const default_message_id_provider_1 = __importDefault(require("./default-message-id-provider"));
const readable_stream_1 = require("readable-stream");
const reinterval_1 = __importDefault(require("reinterval"));
const default_1 = __importDefault(require("rfdc/default"));
const validations = __importStar(require("./validations"));
const debug_1 = __importDefault(require("debug"));
const store_1 = __importDefault(require("./store"));
const handlers_1 = __importDefault(require("./handlers"));
const TypedEmitter_1 = require("./TypedEmitter");
const nextTick = process
    ? process.nextTick
    : (callback) => {
        setTimeout(callback, 0);
    };
const setImmediate = global.setImmediate ||
    ((...args) => {
        const callback = args.shift();
        nextTick(() => {
            callback(...args);
        });
    });
const defaultConnectOptions = {
    keepalive: 60,
    reschedulePings: true,
    protocolId: 'MQTT',
    protocolVersion: 4,
    reconnectPeriod: 1000,
    connectTimeout: 30 * 1000,
    clean: true,
    resubscribe: true,
    writeCache: true,
};
const socketErrors = [
    'ECONNREFUSED',
    'EADDRINUSE',
    'ECONNRESET',
    'ENOTFOUND',
    'ETIMEDOUT',
];
class MqttClient extends TypedEmitter_1.TypedEventEmitter {
    static defaultId() {
        return `mqttjs_${Math.random().toString(16).substr(2, 8)}`;
    }
    constructor(streamBuilder, options) {
        super();
        this.options = options || {};
        for (const k in defaultConnectOptions) {
            if (typeof this.options[k] === 'undefined') {
                this.options[k] = defaultConnectOptions[k];
            }
            else {
                this.options[k] = options[k];
            }
        }
        this.log = this.options.log || (0, debug_1.default)('mqttjs:client');
        this.noop = this._noop.bind(this);
        this.log('MqttClient :: options.protocol', options.protocol);
        this.log('MqttClient :: options.protocolVersion', options.protocolVersion);
        this.log('MqttClient :: options.username', options.username);
        this.log('MqttClient :: options.keepalive', options.keepalive);
        this.log('MqttClient :: options.reconnectPeriod', options.reconnectPeriod);
        this.log('MqttClient :: options.rejectUnauthorized', options.rejectUnauthorized);
        this.log('MqttClient :: options.properties.topicAliasMaximum', options.properties
            ? options.properties.topicAliasMaximum
            : undefined);
        this.options.clientId =
            typeof options.clientId === 'string'
                ? options.clientId
                : MqttClient.defaultId();
        this.log('MqttClient :: clientId', this.options.clientId);
        this.options.customHandleAcks =
            options.protocolVersion === 5 && options.customHandleAcks
                ? options.customHandleAcks
                : (...args) => {
                    args[3](null, 0);
                };
        if (!this.options.writeCache) {
            mqtt_packet_1.default.writeToStream.cacheNumbers = false;
        }
        this.streamBuilder = streamBuilder;
        this.messageIdProvider =
            typeof this.options.messageIdProvider === 'undefined'
                ? new default_message_id_provider_1.default()
                : this.options.messageIdProvider;
        this.outgoingStore = options.outgoingStore || new store_1.default();
        this.incomingStore = options.incomingStore || new store_1.default();
        this.queueQoSZero =
            options.queueQoSZero === undefined ? true : options.queueQoSZero;
        this._resubscribeTopics = {};
        this.messageIdToTopic = {};
        this.pingTimer = null;
        this.connected = false;
        this.disconnecting = false;
        this.reconnecting = false;
        this.queue = [];
        this.connackTimer = null;
        this.reconnectTimer = null;
        this._storeProcessing = false;
        this._packetIdsDuringStoreProcessing = {};
        this._storeProcessingQueue = [];
        this.outgoing = {};
        this._firstConnection = true;
        if (options.properties && options.properties.topicAliasMaximum > 0) {
            if (options.properties.topicAliasMaximum > 0xffff) {
                this.log('MqttClient :: options.properties.topicAliasMaximum is out of range');
            }
            else {
                this.topicAliasRecv = new topic_alias_recv_1.default(options.properties.topicAliasMaximum);
            }
        }
        this.on('connect', () => {
            const { queue } = this;
            const deliver = () => {
                const entry = queue.shift();
                this.log('deliver :: entry %o', entry);
                let packet = null;
                if (!entry) {
                    this._resubscribe();
                    return;
                }
                packet = entry.packet;
                this.log('deliver :: call _sendPacket for %o', packet);
                let send = true;
                if (packet.messageId && packet.messageId !== 0) {
                    if (!this.messageIdProvider.register(packet.messageId)) {
                        send = false;
                    }
                }
                if (send) {
                    this._sendPacket(packet, (err) => {
                        if (entry.cb) {
                            entry.cb(err);
                        }
                        deliver();
                    });
                }
                else {
                    this.log('messageId: %d has already used. The message is skipped and removed.', packet.messageId);
                    deliver();
                }
            };
            this.log('connect :: sending queued packets');
            deliver();
        });
        this.on('close', () => {
            this.log('close :: connected set to `false`');
            this.connected = false;
            this.log('close :: clearing connackTimer');
            clearTimeout(this.connackTimer);
            this.log('close :: clearing ping timer');
            if (this.pingTimer !== null) {
                this.pingTimer.clear();
                this.pingTimer = null;
            }
            if (this.topicAliasRecv) {
                this.topicAliasRecv.clear();
            }
            this.log('close :: calling _setupReconnect');
            this._setupReconnect();
        });
        if (!this.options.manualConnect) {
            this.log('MqttClient :: setting up stream');
            this.connect();
        }
    }
    handleAuth(packet, callback) {
        callback();
    }
    handleMessage(packet, callback) {
        callback();
    }
    _nextId() {
        return this.messageIdProvider.allocate();
    }
    getLastMessageId() {
        return this.messageIdProvider.getLastAllocated();
    }
    connect() {
        var _a;
        const writable = new readable_stream_1.Writable();
        const parser = mqtt_packet_1.default.parser(this.options);
        let completeParse = null;
        const packets = [];
        this.log('connect :: calling method to clear reconnect');
        this._clearReconnect();
        this.log('connect :: using streamBuilder provided to client to create stream');
        this.stream = this.streamBuilder(this);
        parser.on('packet', (packet) => {
            this.log('parser :: on packet push to packets array.');
            packets.push(packet);
        });
        const work = () => {
            this.log('work :: getting next packet in queue');
            const packet = packets.shift();
            if (packet) {
                this.log('work :: packet pulled from queue');
                (0, handlers_1.default)(this, packet, nextTickWork);
            }
            else {
                this.log('work :: no packets in queue');
                const done = completeParse;
                completeParse = null;
                this.log('work :: done flag is %s', !!done);
                if (done)
                    done();
            }
        };
        const nextTickWork = () => {
            if (packets.length) {
                nextTick(work);
            }
            else {
                const done = completeParse;
                completeParse = null;
                done();
            }
        };
        writable._write = (buf, enc, done) => {
            completeParse = done;
            this.log('writable stream :: parsing buffer');
            parser.parse(buf);
            work();
        };
        const streamErrorHandler = (error) => {
            this.log('streamErrorHandler :: error', error.message);
            if (socketErrors.includes(error.code)) {
                this.log('streamErrorHandler :: emitting error');
                this.emit('error', error);
            }
            else {
                this.noop(error);
            }
        };
        this.log('connect :: pipe stream to writable stream');
        this.stream.pipe(writable);
        this.stream.on('error', streamErrorHandler);
        this.stream.on('close', () => {
            this.log('(%s)stream :: on close', this.options.clientId);
            this._flushVolatile();
            this.log('stream: emit close to MqttClient');
            this.emit('close');
        });
        this.log('connect: sending packet `connect`');
        const connectPacket = {
            cmd: 'connect',
            protocolId: this.options.protocolId,
            protocolVersion: this.options.protocolVersion,
            clean: this.options.clean,
            clientId: this.options.clientId,
            keepalive: this.options.keepalive,
            username: this.options.username,
            password: this.options.password,
            properties: this.options.properties,
        };
        if (this.options.will) {
            connectPacket.will = Object.assign(Object.assign({}, this.options.will), { payload: (_a = this.options.will) === null || _a === void 0 ? void 0 : _a.payload });
        }
        if (this.topicAliasRecv) {
            if (!connectPacket.properties) {
                connectPacket.properties = {};
            }
            if (this.topicAliasRecv) {
                connectPacket.properties.topicAliasMaximum =
                    this.topicAliasRecv.max;
            }
        }
        this._writePacket(connectPacket);
        parser.on('error', this.emit.bind(this, 'error'));
        if (this.options.properties) {
            if (!this.options.properties.authenticationMethod &&
                this.options.properties.authenticationData) {
                this.end(() => this.emit('error', new Error('Packet has no Authentication Method')));
                return this;
            }
            if (this.options.properties.authenticationMethod &&
                this.options.authPacket &&
                typeof this.options.authPacket === 'object') {
                const authPacket = Object.assign({ cmd: 'auth', reasonCode: 0 }, this.options.authPacket);
                this._writePacket(authPacket);
            }
        }
        this.stream.setMaxListeners(1000);
        clearTimeout(this.connackTimer);
        this.connackTimer = setTimeout(() => {
            this.log('!!connectTimeout hit!! Calling _cleanUp with force `true`');
            this._cleanUp(true);
        }, this.options.connectTimeout);
        return this;
    }
    publish(topic, message, opts, callback) {
        this.log('publish :: message `%s` to topic `%s`', message, topic);
        const { options } = this;
        if (typeof opts === 'function') {
            callback = opts;
            opts = null;
        }
        opts = opts || {};
        const defaultOpts = {
            qos: 0,
            retain: false,
            dup: false,
        };
        opts = Object.assign(Object.assign({}, defaultOpts), opts);
        const { qos, retain, dup, properties, cbStorePut } = opts;
        if (this._checkDisconnecting(callback)) {
            return this;
        }
        const publishProc = () => {
            let messageId = 0;
            if (qos === 1 || qos === 2) {
                messageId = this._nextId();
                if (messageId === null) {
                    this.log('No messageId left');
                    return false;
                }
            }
            const packet = {
                cmd: 'publish',
                topic,
                payload: message,
                qos,
                retain,
                messageId,
                dup,
            };
            if (options.protocolVersion === 5) {
                packet.properties = properties;
            }
            this.log('publish :: qos', qos);
            switch (qos) {
                case 1:
                case 2:
                    this.outgoing[packet.messageId] = {
                        volatile: false,
                        cb: callback || this.noop,
                    };
                    this.log('MqttClient:publish: packet cmd: %s', packet.cmd);
                    this._sendPacket(packet, undefined, cbStorePut);
                    break;
                default:
                    this.log('MqttClient:publish: packet cmd: %s', packet.cmd);
                    this._sendPacket(packet, callback, cbStorePut);
                    break;
            }
            return true;
        };
        if (this._storeProcessing ||
            this._storeProcessingQueue.length > 0 ||
            !publishProc()) {
            this._storeProcessingQueue.push({
                invoke: publishProc,
                cbStorePut: opts.cbStorePut,
                callback,
            });
        }
        return this;
    }
    publishAsync(topic, message, opts) {
        return new Promise((resolve, reject) => {
            this.publish(topic, message, opts, (err, packet) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(packet);
                }
            });
        });
    }
    subscribe(topicObject, opts, callback) {
        const version = this.options.protocolVersion;
        if (typeof opts === 'function') {
            callback = opts;
        }
        callback = callback || this.noop;
        let resubscribe = false;
        let topicsList = [];
        if (typeof topicObject === 'string') {
            topicObject = [topicObject];
            topicsList = topicObject;
        }
        else if (Array.isArray(topicObject)) {
            topicsList = topicObject;
        }
        else if (typeof topicObject === 'object') {
            resubscribe = topicObject.resubscribe;
            delete topicObject.resubscribe;
            topicsList = Object.keys(topicObject);
        }
        const invalidTopic = validations.validateTopics(topicsList);
        if (invalidTopic !== null) {
            setImmediate(callback, new Error(`Invalid topic ${invalidTopic}`));
            return this;
        }
        if (this._checkDisconnecting(callback)) {
            this.log('subscribe: discconecting true');
            return this;
        }
        const defaultOpts = {
            qos: 0,
        };
        if (version === 5) {
            defaultOpts.nl = false;
            defaultOpts.rap = false;
            defaultOpts.rh = 0;
        }
        opts = Object.assign(Object.assign({}, defaultOpts), opts);
        const properties = opts.properties;
        const subs = [];
        const parseSub = (topic, subOptions) => {
            subOptions = (subOptions || opts);
            if (!Object.prototype.hasOwnProperty.call(this._resubscribeTopics, topic) ||
                this._resubscribeTopics[topic].qos < subOptions.qos ||
                resubscribe) {
                const currentOpts = {
                    topic,
                    qos: subOptions.qos,
                };
                if (version === 5) {
                    currentOpts.nl = subOptions.nl;
                    currentOpts.rap = subOptions.rap;
                    currentOpts.rh = subOptions.rh;
                    currentOpts.properties = properties;
                }
                this.log('subscribe: pushing topic `%s` and qos `%s` to subs list', currentOpts.topic, currentOpts.qos);
                subs.push(currentOpts);
            }
        };
        if (Array.isArray(topicObject)) {
            topicObject.forEach((topic) => {
                this.log('subscribe: array topic %s', topic);
                parseSub(topic);
            });
        }
        else {
            Object.keys(topicObject).forEach((topic) => {
                this.log('subscribe: object topic %s, %o', topic, topicObject[topic]);
                parseSub(topic, topicObject[topic]);
            });
        }
        if (!subs.length) {
            callback(null, []);
            return this;
        }
        const subscribeProc = () => {
            const messageId = this._nextId();
            if (messageId === null) {
                this.log('No messageId left');
                return false;
            }
            const packet = {
                cmd: 'subscribe',
                subscriptions: subs,
                messageId,
            };
            if (properties) {
                packet.properties = properties;
            }
            if (this.options.resubscribe) {
                this.log('subscribe :: resubscribe true');
                const topics = [];
                subs.forEach((sub) => {
                    if (this.options.reconnectPeriod > 0) {
                        const topic = { qos: sub.qos };
                        if (version === 5) {
                            topic.nl = sub.nl || false;
                            topic.rap = sub.rap || false;
                            topic.rh = sub.rh || 0;
                            topic.properties = sub.properties;
                        }
                        this._resubscribeTopics[sub.topic] = topic;
                        topics.push(sub.topic);
                    }
                });
                this.messageIdToTopic[packet.messageId] = topics;
            }
            this.outgoing[packet.messageId] = {
                volatile: true,
                cb(err, packet2) {
                    if (!err) {
                        const { granted } = packet2;
                        for (let i = 0; i < granted.length; i += 1) {
                            subs[i].qos = granted[i];
                        }
                    }
                    callback(err, subs);
                },
            };
            this.log('subscribe :: call _sendPacket');
            this._sendPacket(packet);
            return true;
        };
        if (this._storeProcessing ||
            this._storeProcessingQueue.length > 0 ||
            !subscribeProc()) {
            this._storeProcessingQueue.push({
                invoke: subscribeProc,
                callback,
            });
        }
        return this;
    }
    subscribeAsync(topicObject, opts) {
        return new Promise((resolve, reject) => {
            this.subscribe(topicObject, opts, (err, granted) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(granted);
                }
            });
        });
    }
    unsubscribe(topic, opts, callback) {
        if (typeof topic === 'string') {
            topic = [topic];
        }
        if (typeof opts === 'function') {
            callback = opts;
        }
        callback = callback || this.noop;
        const invalidTopic = validations.validateTopics(topic);
        if (invalidTopic !== null) {
            setImmediate(callback, new Error(`Invalid topic ${invalidTopic}`));
            return this;
        }
        if (this._checkDisconnecting(callback)) {
            return this;
        }
        const unsubscribeProc = () => {
            const messageId = this._nextId();
            if (messageId === null) {
                this.log('No messageId left');
                return false;
            }
            const packet = {
                cmd: 'unsubscribe',
                messageId,
                unsubscriptions: [],
            };
            if (typeof topic === 'string') {
                packet.unsubscriptions = [topic];
            }
            else if (Array.isArray(topic)) {
                packet.unsubscriptions = topic;
            }
            if (this.options.resubscribe) {
                packet.unsubscriptions.forEach((topic2) => {
                    delete this._resubscribeTopics[topic2];
                });
            }
            if (typeof opts === 'object' && opts.properties) {
                packet.properties = opts.properties;
            }
            this.outgoing[packet.messageId] = {
                volatile: true,
                cb: callback,
            };
            this.log('unsubscribe: call _sendPacket');
            this._sendPacket(packet);
            return true;
        };
        if (this._storeProcessing ||
            this._storeProcessingQueue.length > 0 ||
            !unsubscribeProc()) {
            this._storeProcessingQueue.push({
                invoke: unsubscribeProc,
                callback,
            });
        }
        return this;
    }
    unsubscribeAsync(topic, opts) {
        return new Promise((resolve, reject) => {
            this.unsubscribe(topic, opts, (err, packet) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(packet);
                }
            });
        });
    }
    end(force, opts, cb) {
        this.log('end :: (%s)', this.options.clientId);
        if (force == null || typeof force !== 'boolean') {
            cb = cb || opts;
            opts = force;
            force = false;
        }
        if (typeof opts !== 'object') {
            cb = cb || opts;
            opts = null;
        }
        this.log('end :: cb? %s', !!cb);
        if (!cb || typeof cb !== 'function') {
            cb = this.noop;
        }
        const closeStores = () => {
            this.log('end :: closeStores: closing incoming and outgoing stores');
            this.disconnected = true;
            this.incomingStore.close((e1) => {
                this.outgoingStore.close((e2) => {
                    this.log('end :: closeStores: emitting end');
                    this.emit('end');
                    if (cb) {
                        const err = e1 || e2;
                        this.log('end :: closeStores: invoking callback with args');
                        cb(err);
                    }
                });
            });
            if (this._deferredReconnect) {
                this._deferredReconnect();
            }
        };
        const finish = () => {
            this.log('end :: (%s) :: finish :: calling _cleanUp with force %s', this.options.clientId, force);
            this._cleanUp(force, () => {
                this.log('end :: finish :: calling process.nextTick on closeStores');
                nextTick(closeStores);
            }, opts);
        };
        if (this.disconnecting) {
            cb();
            return this;
        }
        this._clearReconnect();
        this.disconnecting = true;
        if (!force && Object.keys(this.outgoing).length > 0) {
            this.log('end :: (%s) :: calling finish in 10ms once outgoing is empty', this.options.clientId);
            this.once('outgoingEmpty', setTimeout.bind(null, finish, 10));
        }
        else {
            this.log('end :: (%s) :: immediately calling finish', this.options.clientId);
            finish();
        }
        return this;
    }
    endAsync(force, opts) {
        return new Promise((resolve, reject) => {
            this.end(force, opts, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
    removeOutgoingMessage(messageId) {
        if (this.outgoing[messageId]) {
            const { cb } = this.outgoing[messageId];
            this._removeOutgoingAndStoreMessage(messageId, () => {
                cb(new Error('Message removed'));
            });
        }
        return this;
    }
    reconnect(opts) {
        this.log('client reconnect');
        const f = () => {
            if (opts) {
                this.options.incomingStore = opts.incomingStore;
                this.options.outgoingStore = opts.outgoingStore;
            }
            else {
                this.options.incomingStore = null;
                this.options.outgoingStore = null;
            }
            this.incomingStore = this.options.incomingStore || new store_1.default();
            this.outgoingStore = this.options.outgoingStore || new store_1.default();
            this.disconnecting = false;
            this.disconnected = false;
            this._deferredReconnect = null;
            this._reconnect();
        };
        if (this.disconnecting && !this.disconnected) {
            this._deferredReconnect = f;
        }
        else {
            f();
        }
        return this;
    }
    _flushVolatile() {
        if (this.outgoing) {
            this.log('_flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function');
            Object.keys(this.outgoing).forEach((messageId) => {
                if (this.outgoing[messageId].volatile &&
                    typeof this.outgoing[messageId].cb === 'function') {
                    this.outgoing[messageId].cb(new Error('Connection closed'));
                    delete this.outgoing[messageId];
                }
            });
        }
    }
    _flush() {
        if (this.outgoing) {
            this.log('_flush: queue exists? %b', !!this.outgoing);
            Object.keys(this.outgoing).forEach((messageId) => {
                if (typeof this.outgoing[messageId].cb === 'function') {
                    this.outgoing[messageId].cb(new Error('Connection closed'));
                    delete this.outgoing[messageId];
                }
            });
        }
    }
    _removeTopicAliasAndRecoverTopicName(packet) {
        let alias;
        if (packet.properties) {
            alias = packet.properties.topicAlias;
        }
        let topic = packet.topic.toString();
        this.log('_removeTopicAliasAndRecoverTopicName :: alias %d, topic %o', alias, topic);
        if (topic.length === 0) {
            if (typeof alias === 'undefined') {
                return new Error('Unregistered Topic Alias');
            }
            topic = this.topicAliasSend.getTopicByAlias(alias);
            if (typeof topic === 'undefined') {
                return new Error('Unregistered Topic Alias');
            }
            packet.topic = topic;
        }
        if (alias) {
            delete packet.properties.topicAlias;
        }
    }
    _checkDisconnecting(callback) {
        if (this.disconnecting) {
            if (callback && callback !== this.noop) {
                callback(new Error('client disconnecting'));
            }
            else {
                this.emit('error', new Error('client disconnecting'));
            }
        }
        return this.disconnecting;
    }
    _reconnect() {
        this.log('_reconnect: emitting reconnect to client');
        this.emit('reconnect');
        if (this.connected) {
            this.end(() => {
                this.connect();
            });
            this.log('client already connected. disconnecting first.');
        }
        else {
            this.log('_reconnect: calling connect');
            this.connect();
        }
    }
    _setupReconnect() {
        if (!this.disconnecting &&
            !this.reconnectTimer &&
            this.options.reconnectPeriod > 0) {
            if (!this.reconnecting) {
                this.log('_setupReconnect :: emit `offline` state');
                this.emit('offline');
                this.log('_setupReconnect :: set `reconnecting` to `true`');
                this.reconnecting = true;
            }
            this.log('_setupReconnect :: setting reconnectTimer for %d ms', this.options.reconnectPeriod);
            this.reconnectTimer = setInterval(() => {
                this.log('reconnectTimer :: reconnect triggered!');
                this._reconnect();
            }, this.options.reconnectPeriod);
        }
        else {
            this.log('_setupReconnect :: doing nothing...');
        }
    }
    _clearReconnect() {
        this.log('_clearReconnect : clearing reconnect timer');
        if (this.reconnectTimer) {
            clearInterval(this.reconnectTimer);
            this.reconnectTimer = null;
        }
    }
    _cleanUp(forced, done, opts = {}) {
        if (done) {
            this.log('_cleanUp :: done callback provided for on stream close');
            this.stream.on('close', done);
        }
        this.log('_cleanUp :: forced? %s', forced);
        if (forced) {
            if (this.options.reconnectPeriod === 0 && this.options.clean) {
                this._flush();
            }
            this.log('_cleanUp :: (%s) :: destroying stream', this.options.clientId);
            this.stream.destroy();
        }
        else {
            const packet = Object.assign({ cmd: 'disconnect' }, opts);
            this.log('_cleanUp :: (%s) :: call _sendPacket with disconnect packet', this.options.clientId);
            this._sendPacket(packet, () => {
                this.log('_cleanUp :: (%s) :: destroying stream', this.options.clientId);
                setImmediate(() => {
                    this.stream.end(() => {
                        this.log('_cleanUp :: (%s) :: stream destroyed', this.options.clientId);
                    });
                });
            });
        }
        if (!this.disconnecting) {
            this.log('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.');
            this._clearReconnect();
            this._setupReconnect();
        }
        if (this.pingTimer !== null) {
            this.log('_cleanUp :: clearing pingTimer');
            this.pingTimer.clear();
            this.pingTimer = null;
        }
        if (done && !this.connected) {
            this.log('_cleanUp :: (%s) :: removing stream `done` callback `close` listener', this.options.clientId);
            this.stream.removeListener('close', done);
            done();
        }
    }
    _storeAndSend(packet, cb, cbStorePut) {
        this.log('storeAndSend :: store packet with cmd %s to outgoingStore', packet.cmd);
        let storePacket = packet;
        let err;
        if (storePacket.cmd === 'publish') {
            storePacket = (0, default_1.default)(packet);
            err = this._removeTopicAliasAndRecoverTopicName(storePacket);
            if (err) {
                return cb && cb(err);
            }
        }
        this.outgoingStore.put(storePacket, (err2) => {
            if (err2) {
                return cb && cb(err2);
            }
            cbStorePut();
            this._writePacket(packet, cb);
        });
    }
    _applyTopicAlias(packet) {
        if (this.options.protocolVersion === 5) {
            if (packet.cmd === 'publish') {
                let alias;
                if (packet.properties) {
                    alias = packet.properties.topicAlias;
                }
                const topic = packet.topic.toString();
                if (this.topicAliasSend) {
                    if (alias) {
                        if (topic.length !== 0) {
                            this.log('applyTopicAlias :: register topic: %s - alias: %d', topic, alias);
                            if (!this.topicAliasSend.put(topic, alias)) {
                                this.log('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias);
                                return new Error('Sending Topic Alias out of range');
                            }
                        }
                    }
                    else if (topic.length !== 0) {
                        if (this.options.autoAssignTopicAlias) {
                            alias = this.topicAliasSend.getAliasByTopic(topic);
                            if (alias) {
                                packet.topic = '';
                                packet.properties = Object.assign(Object.assign({}, packet.properties), { topicAlias: alias });
                                this.log('applyTopicAlias :: auto assign(use) topic: %s - alias: %d', topic, alias);
                            }
                            else {
                                alias = this.topicAliasSend.getLruAlias();
                                this.topicAliasSend.put(topic, alias);
                                packet.properties = Object.assign(Object.assign({}, packet.properties), { topicAlias: alias });
                                this.log('applyTopicAlias :: auto assign topic: %s - alias: %d', topic, alias);
                            }
                        }
                        else if (this.options.autoUseTopicAlias) {
                            alias = this.topicAliasSend.getAliasByTopic(topic);
                            if (alias) {
                                packet.topic = '';
                                packet.properties = Object.assign(Object.assign({}, packet.properties), { topicAlias: alias });
                                this.log('applyTopicAlias :: auto use topic: %s - alias: %d', topic, alias);
                            }
                        }
                    }
                }
                else if (alias) {
                    this.log('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias);
                    return new Error('Sending Topic Alias out of range');
                }
            }
        }
    }
    _noop(err) {
        this.log('noop ::', err);
    }
    _writePacket(packet, cb) {
        this.log('_writePacket :: packet: %O', packet);
        this.log('_writePacket :: emitting `packetsend`');
        this.emit('packetsend', packet);
        this._shiftPingInterval();
        this.log('_writePacket :: writing to stream');
        const result = mqtt_packet_1.default.writeToStream(packet, this.stream, this.options);
        this.log('_writePacket :: writeToStream result %s', result);
        if (!result && cb && cb !== this.noop) {
            this.log('_writePacket :: handle events on `drain` once through callback.');
            this.stream.once('drain', cb);
        }
        else if (cb) {
            this.log('_writePacket :: invoking cb');
            cb();
        }
    }
    _sendPacket(packet, cb, cbStorePut, noStore) {
        this.log('_sendPacket :: (%s) ::  start', this.options.clientId);
        cbStorePut = cbStorePut || this.noop;
        cb = cb || this.noop;
        const err = this._applyTopicAlias(packet);
        if (err) {
            cb(err);
            return;
        }
        if (!this.connected) {
            if (packet.cmd === 'auth') {
                this._writePacket(packet, cb);
                return;
            }
            this.log('_sendPacket :: client not connected. Storing packet offline.');
            this._storePacket(packet, cb, cbStorePut);
            return;
        }
        if (noStore) {
            this._writePacket(packet, cb);
            return;
        }
        switch (packet.cmd) {
            case 'publish':
                break;
            case 'pubrel':
                this._storeAndSend(packet, cb, cbStorePut);
                return;
            default:
                this._writePacket(packet, cb);
                return;
        }
        switch (packet.qos) {
            case 2:
            case 1:
                this._storeAndSend(packet, cb, cbStorePut);
                break;
            case 0:
            default:
                this._writePacket(packet, cb);
                break;
        }
        this.log('_sendPacket :: (%s) ::  end', this.options.clientId);
    }
    _storePacket(packet, cb, cbStorePut) {
        this.log('_storePacket :: packet: %o', packet);
        this.log('_storePacket :: cb? %s', !!cb);
        cbStorePut = cbStorePut || this.noop;
        let storePacket = packet;
        if (storePacket.cmd === 'publish') {
            storePacket = (0, default_1.default)(packet);
            const err = this._removeTopicAliasAndRecoverTopicName(storePacket);
            if (err) {
                return cb && cb(err);
            }
        }
        const qos = storePacket.qos || 0;
        if ((qos === 0 && this.queueQoSZero) || storePacket.cmd !== 'publish') {
            this.queue.push({ packet: storePacket, cb });
        }
        else if (qos > 0) {
            cb = this.outgoing[storePacket.messageId]
                ? this.outgoing[storePacket.messageId].cb
                : null;
            this.outgoingStore.put(storePacket, (err) => {
                if (err) {
                    return cb && cb(err);
                }
                cbStorePut();
            });
        }
        else if (cb) {
            cb(new Error('No connection to broker'));
        }
    }
    _setupPingTimer() {
        this.log('_setupPingTimer :: keepalive %d (seconds)', this.options.keepalive);
        if (!this.pingTimer && this.options.keepalive) {
            this.pingResp = true;
            this.pingTimer = (0, reinterval_1.default)(() => {
                this._checkPing();
            }, this.options.keepalive * 1000);
        }
    }
    _shiftPingInterval() {
        if (this.pingTimer &&
            this.options.keepalive &&
            this.options.reschedulePings) {
            this.pingTimer.reschedule(this.options.keepalive * 1000);
        }
    }
    _checkPing() {
        this.log('_checkPing :: checking ping...');
        if (this.pingResp) {
            this.log('_checkPing :: ping response received. Clearing flag and sending `pingreq`');
            this.pingResp = false;
            this._sendPacket({ cmd: 'pingreq' });
        }
        else {
            this.log('_checkPing :: calling _cleanUp with force true');
            this._cleanUp(true);
        }
    }
    _resubscribe() {
        this.log('_resubscribe');
        const _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics);
        if (!this._firstConnection &&
            (this.options.clean ||
                (this.options.protocolVersion >= 4 &&
                    !this.connackPacket.sessionPresent)) &&
            _resubscribeTopicsKeys.length > 0) {
            if (this.options.resubscribe) {
                if (this.options.protocolVersion === 5) {
                    this.log('_resubscribe: protocolVersion 5');
                    for (let topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {
                        const resubscribeTopic = {};
                        resubscribeTopic[_resubscribeTopicsKeys[topicI]] =
                            this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];
                        resubscribeTopic.resubscribe = true;
                        this.subscribe(resubscribeTopic, {
                            properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]]
                                .properties,
                        });
                    }
                }
                else {
                    this._resubscribeTopics.resubscribe = true;
                    this.subscribe(this._resubscribeTopics);
                }
            }
            else {
                this._resubscribeTopics = {};
            }
        }
        this._firstConnection = false;
    }
    _onConnect(packet) {
        if (this.disconnected) {
            this.emit('connect', packet);
            return;
        }
        this.connackPacket = packet;
        this.messageIdProvider.clear();
        this._setupPingTimer();
        this.connected = true;
        const startStreamProcess = () => {
            let outStore = this.outgoingStore.createStream();
            const remove = () => {
                outStore.destroy();
                outStore = null;
                this._flushStoreProcessingQueue();
                clearStoreProcessing();
            };
            const clearStoreProcessing = () => {
                this._storeProcessing = false;
                this._packetIdsDuringStoreProcessing = {};
            };
            this.once('close', remove);
            outStore.on('error', (err) => {
                clearStoreProcessing();
                this._flushStoreProcessingQueue();
                this.removeListener('close', remove);
                this.emit('error', err);
            });
            const storeDeliver = () => {
                if (!outStore) {
                    return;
                }
                const packet2 = outStore.read(1);
                let cb;
                if (!packet2) {
                    outStore.once('readable', storeDeliver);
                    return;
                }
                this._storeProcessing = true;
                if (this._packetIdsDuringStoreProcessing[packet2.messageId]) {
                    storeDeliver();
                    return;
                }
                if (!this.disconnecting && !this.reconnectTimer) {
                    cb = this.outgoing[packet2.messageId]
                        ? this.outgoing[packet2.messageId].cb
                        : null;
                    this.outgoing[packet2.messageId] = {
                        volatile: false,
                        cb(err, status) {
                            if (cb) {
                                cb(err, status);
                            }
                            storeDeliver();
                        },
                    };
                    this._packetIdsDuringStoreProcessing[packet2.messageId] =
                        true;
                    if (this.messageIdProvider.register(packet2.messageId)) {
                        this._sendPacket(packet2, undefined, undefined, true);
                    }
                    else {
                        this.log('messageId: %d has already used.', packet2.messageId);
                    }
                }
                else if (outStore.destroy) {
                    outStore.destroy();
                }
            };
            outStore.on('end', () => {
                let allProcessed = true;
                for (const id in this._packetIdsDuringStoreProcessing) {
                    if (!this._packetIdsDuringStoreProcessing[id]) {
                        allProcessed = false;
                        break;
                    }
                }
                if (allProcessed) {
                    clearStoreProcessing();
                    this.removeListener('close', remove);
                    this._invokeAllStoreProcessingQueue();
                    this.emit('connect', packet);
                }
                else {
                    startStreamProcess();
                }
            });
            storeDeliver();
        };
        startStreamProcess();
    }
    _invokeStoreProcessingQueue() {
        if (!this._storeProcessing && this._storeProcessingQueue.length > 0) {
            const f = this._storeProcessingQueue[0];
            if (f && f.invoke()) {
                this._storeProcessingQueue.shift();
                return true;
            }
        }
        return false;
    }
    _invokeAllStoreProcessingQueue() {
        while (this._invokeStoreProcessingQueue()) {
        }
    }
    _flushStoreProcessingQueue() {
        for (const f of this._storeProcessingQueue) {
            if (f.cbStorePut)
                f.cbStorePut(new Error('Connection closed'));
            if (f.callback)
                f.callback(new Error('Connection closed'));
        }
        this._storeProcessingQueue.splice(0);
    }
    _removeOutgoingAndStoreMessage(messageId, cb) {
        delete this.outgoing[messageId];
        this.outgoingStore.del({ messageId }, (err, packet) => {
            cb(err, packet);
            this.messageIdProvider.deallocate(messageId);
            this._invokeStoreProcessingQueue();
        });
    }
}
exports.default = MqttClient;
//# sourceMappingURL=client.js.map{"version":3,"file":"client.js","sourceRoot":"","sources":["../../src/lib/client.ts"],"names":[],"mappings":"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"}import { StreamBuilder } from '../shared';
declare const buildStream: StreamBuilder;
export default buildStream;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("buffer");
const readable_stream_1 = require("readable-stream");
const duplexify_1 = __importDefault(require("duplexify"));
let my;
let proxy;
let stream;
let isInitialized = false;
function buildProxy() {
    const _proxy = new readable_stream_1.Transform();
    _proxy._write = (chunk, encoding, next) => {
        my.sendSocketMessage({
            data: chunk.buffer,
            success() {
                next();
            },
            fail() {
                next(new Error());
            },
        });
    };
    _proxy._flush = (done) => {
        my.closeSocket({
            success() {
                done();
            },
        });
    };
    return _proxy;
}
function setDefaultOpts(opts) {
    if (!opts.hostname) {
        opts.hostname = 'localhost';
    }
    if (!opts.path) {
        opts.path = '/';
    }
    if (!opts.wsOptions) {
        opts.wsOptions = {};
    }
}
function buildUrl(opts, client) {
    const protocol = opts.protocol === 'alis' ? 'wss' : 'ws';
    let url = `${protocol}://${opts.hostname}${opts.path}`;
    if (opts.port && opts.port !== 80 && opts.port !== 443) {
        url = `${protocol}://${opts.hostname}:${opts.port}${opts.path}`;
    }
    if (typeof opts.transformWsUrl === 'function') {
        url = opts.transformWsUrl(url, opts, client);
    }
    return url;
}
function bindEventHandler() {
    if (isInitialized)
        return;
    isInitialized = true;
    my.onSocketOpen(() => {
        stream.setReadable(proxy);
        stream.setWritable(proxy);
        stream.emit('connect');
    });
    my.onSocketMessage((res) => {
        if (typeof res.data === 'string') {
            const buffer = buffer_1.Buffer.from(res.data, 'base64');
            proxy.push(buffer);
        }
        else {
            const reader = new FileReader();
            reader.addEventListener('load', () => {
                let data = reader.result;
                if (data instanceof ArrayBuffer)
                    data = buffer_1.Buffer.from(data);
                else
                    data = buffer_1.Buffer.from(data, 'utf8');
                proxy.push(data);
            });
            reader.readAsArrayBuffer(res.data);
        }
    });
    my.onSocketClose(() => {
        stream.end();
        stream.destroy();
    });
    my.onSocketError((res) => {
        stream.destroy(res);
    });
}
const buildStream = (client, opts) => {
    opts.hostname = opts.hostname || opts.host;
    if (!opts.hostname) {
        throw new Error('Could not determine host. Specify host manually.');
    }
    const websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3
        ? 'mqttv3.1'
        : 'mqtt';
    setDefaultOpts(opts);
    const url = buildUrl(opts, client);
    my = opts.my;
    my.connectSocket({
        url,
        protocols: websocketSubProtocol,
    });
    proxy = buildProxy();
    stream = duplexify_1.default.obj();
    bindEventHandler();
    return stream;
};
exports.default = buildStream;
//# sourceMappingURL=ali.js.map{"version":3,"file":"ali.js","sourceRoot":"","sources":["../../../src/lib/connect/ali.ts"],"names":[],"mappings":"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"}import MqttClient, { IClientOptions } from '../client';
declare function connect(brokerUrl: string): MqttClient;
declare function connect(opts: IClientOptions): MqttClient;
declare function connect(brokerUrl: string, opts?: IClientOptions): MqttClient;
declare function connectAsync(brokerUrl: string): Promise<MqttClient>;
declare function connectAsync(opts: IClientOptions): Promise<MqttClient>;
declare function connectAsync(brokerUrl: string, opts?: IClientOptions): Promise<MqttClient>;
export default connect;
export { connectAsync };
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.connectAsync = void 0;
const debug_1 = __importDefault(require("debug"));
const url_1 = __importDefault(require("url"));
const client_1 = __importDefault(require("../client"));
const is_browser_1 = __importDefault(require("../is-browser"));
const debug = (0, debug_1.default)('mqttjs');
const protocols = {};
if (!is_browser_1.default) {
    protocols.mqtt = require('./tcp').default;
    protocols.tcp = require('./tcp').default;
    protocols.ssl = require('./tls').default;
    protocols.tls = protocols.ssl;
    protocols.mqtts = require('./tls').default;
}
else {
    protocols.wx = require('./wx').default;
    protocols.wxs = require('./wx').default;
    protocols.ali = require('./ali').default;
    protocols.alis = require('./ali').default;
}
protocols.ws = require('./ws').default;
protocols.wss = require('./ws').default;
function parseAuthOptions(opts) {
    let matches;
    if (opts.auth) {
        matches = opts.auth.match(/^(.+):(.+)$/);
        if (matches) {
            opts.username = matches[1];
            opts.password = matches[2];
        }
        else {
            opts.username = opts.auth;
        }
    }
}
function connect(brokerUrl, opts) {
    debug('connecting to an MQTT broker...');
    if (typeof brokerUrl === 'object' && !opts) {
        opts = brokerUrl;
        brokerUrl = '';
    }
    opts = opts || {};
    if (brokerUrl && typeof brokerUrl === 'string') {
        const parsed = url_1.default.parse(brokerUrl, true);
        if (parsed.port != null) {
            parsed.port = Number(parsed.port);
        }
        opts = Object.assign(Object.assign({}, parsed), opts);
        if (opts.protocol === null) {
            throw new Error('Missing protocol');
        }
        opts.protocol = opts.protocol.replace(/:$/, '');
    }
    parseAuthOptions(opts);
    if (opts.query && typeof opts.query.clientId === 'string') {
        opts.clientId = opts.query.clientId;
    }
    if (opts.cert && opts.key) {
        if (opts.protocol) {
            if (['mqtts', 'wss', 'wxs', 'alis'].indexOf(opts.protocol) === -1) {
                switch (opts.protocol) {
                    case 'mqtt':
                        opts.protocol = 'mqtts';
                        break;
                    case 'ws':
                        opts.protocol = 'wss';
                        break;
                    case 'wx':
                        opts.protocol = 'wxs';
                        break;
                    case 'ali':
                        opts.protocol = 'alis';
                        break;
                    default:
                        throw new Error(`Unknown protocol for secure connection: "${opts.protocol}"!`);
                }
            }
        }
        else {
            throw new Error('Missing secure protocol key');
        }
    }
    if (!protocols[opts.protocol]) {
        const isSecure = ['mqtts', 'wss'].indexOf(opts.protocol) !== -1;
        opts.protocol = [
            'mqtt',
            'mqtts',
            'ws',
            'wss',
            'wx',
            'wxs',
            'ali',
            'alis',
        ].filter((key, index) => {
            if (isSecure && index % 2 === 0) {
                return false;
            }
            return typeof protocols[key] === 'function';
        })[0];
    }
    if (opts.clean === false && !opts.clientId) {
        throw new Error('Missing clientId for unclean clients');
    }
    if (opts.protocol) {
        opts.defaultProtocol = opts.protocol;
    }
    function wrapper(client) {
        if (opts.servers) {
            if (!client._reconnectCount ||
                client._reconnectCount === opts.servers.length) {
                client._reconnectCount = 0;
            }
            opts.host = opts.servers[client._reconnectCount].host;
            opts.port = opts.servers[client._reconnectCount].port;
            opts.protocol = !opts.servers[client._reconnectCount].protocol
                ? opts.defaultProtocol
                : opts.servers[client._reconnectCount].protocol;
            opts.hostname = opts.host;
            client._reconnectCount++;
        }
        debug('calling streambuilder for', opts.protocol);
        return protocols[opts.protocol](client, opts);
    }
    const client = new client_1.default(wrapper, opts);
    client.on('error', () => {
    });
    return client;
}
function connectAsync(brokerUrl, opts, allowRetries = true) {
    return new Promise((resolve, reject) => {
        const client = connect(brokerUrl, opts);
        const promiseResolutionListeners = {
            connect: (connack) => {
                removePromiseResolutionListeners();
                resolve(client);
            },
            end: () => {
                removePromiseResolutionListeners();
                resolve(client);
            },
            error: (err) => {
                removePromiseResolutionListeners();
                client.end();
                reject(err);
            },
        };
        if (allowRetries === false) {
            promiseResolutionListeners.close = () => {
                promiseResolutionListeners.error(new Error("Couldn't connect to server"));
            };
        }
        function removePromiseResolutionListeners() {
            Object.keys(promiseResolutionListeners).forEach((eventName) => {
                client.off(eventName, promiseResolutionListeners[eventName]);
            });
        }
        Object.keys(promiseResolutionListeners).forEach((eventName) => {
            client.on(eventName, promiseResolutionListeners[eventName]);
        });
    });
}
exports.connectAsync = connectAsync;
exports.default = connect;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/lib/connect/index.ts"],"names":[],"mappings":"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"}import { StreamBuilder } from '../shared';
declare const buildStream: StreamBuilder;
export default buildStream;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const net_1 = __importDefault(require("net"));
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('mqttjs:tcp');
const buildStream = (client, opts) => {
    opts.port = opts.port || 1883;
    opts.hostname = opts.hostname || opts.host || 'localhost';
    const { port } = opts;
    const host = opts.hostname;
    debug('port %d and host %s', port, host);
    return net_1.default.createConnection(port, host);
};
exports.default = buildStream;
//# sourceMappingURL=tcp.js.map{"version":3,"file":"tcp.js","sourceRoot":"","sources":["../../../src/lib/connect/tcp.ts"],"names":[],"mappings":";;;;;AAEA,8CAAqB;AACrB,kDAA0B;AAG1B,MAAM,KAAK,GAAG,IAAA,eAAM,EAAC,YAAY,CAAC,CAAA;AAKlC,MAAM,WAAW,GAAkB,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE;IACnD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,IAAI,IAAI,CAAA;IAC7B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,IAAI,IAAI,WAAW,CAAA;IAEzD,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,CAAA;IACrB,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAA;IAE1B,KAAK,CAAC,qBAAqB,EAAE,IAAI,EAAE,IAAI,CAAC,CAAA;IACxC,OAAO,aAAG,CAAC,gBAAgB,CAAC,IAAI,EAAE,IAAI,CAAC,CAAA;AACxC,CAAC,CAAA;AAED,kBAAe,WAAW,CAAA"}import { StreamBuilder } from '../shared';
declare const buildStream: StreamBuilder;
export default buildStream;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tls_1 = __importDefault(require("tls"));
const net_1 = __importDefault(require("net"));
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('mqttjs:tls');
const buildStream = (client, opts) => {
    opts.port = opts.port || 8883;
    opts.host = opts.hostname || opts.host || 'localhost';
    if (net_1.default.isIP(opts.host) === 0) {
        opts.servername = opts.host;
    }
    opts.rejectUnauthorized = opts.rejectUnauthorized !== false;
    delete opts.path;
    debug('port %d host %s rejectUnauthorized %b', opts.port, opts.host, opts.rejectUnauthorized);
    const connection = tls_1.default.connect(opts);
    connection.on('secureConnect', () => {
        if (opts.rejectUnauthorized && !connection.authorized) {
            connection.emit('error', new Error('TLS not authorized'));
        }
        else {
            connection.removeListener('error', handleTLSerrors);
        }
    });
    function handleTLSerrors(err) {
        if (opts.rejectUnauthorized) {
            client.emit('error', err);
        }
        connection.end();
    }
    connection.on('error', handleTLSerrors);
    return connection;
};
exports.default = buildStream;
//# sourceMappingURL=tls.js.map{"version":3,"file":"tls.js","sourceRoot":"","sources":["../../../src/lib/connect/tls.ts"],"names":[],"mappings":";;;;;AAAA,8CAAqB;AACrB,8CAAqB;AACrB,kDAA0B;AAG1B,MAAM,KAAK,GAAG,IAAA,eAAM,EAAC,YAAY,CAAC,CAAA;AAElC,MAAM,WAAW,GAAkB,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE;IACnD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,IAAI,IAAI,CAAA;IAC7B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,IAAI,IAAI,WAAW,CAAA;IAErD,IAAI,aAAG,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;QAC9B,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,IAAI,CAAA;KAC3B;IAED,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,kBAAkB,KAAK,KAAK,CAAA;IAE3D,OAAO,IAAI,CAAC,IAAI,CAAA;IAEhB,KAAK,CACJ,uCAAuC,EACvC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,kBAAkB,CACvB,CAAA;IAED,MAAM,UAAU,GAAG,aAAG,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA;IACpC,UAAU,CAAC,EAAE,CAAC,eAAe,EAAE,GAAG,EAAE;QACnC,IAAI,IAAI,CAAC,kBAAkB,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE;YACtD,UAAU,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC,CAAA;SACzD;aAAM;YACN,UAAU,CAAC,cAAc,CAAC,OAAO,EAAE,eAAe,CAAC,CAAA;SACnD;IACF,CAAC,CAAC,CAAA;IAEF,SAAS,eAAe,CAAC,GAAU;QAElC,IAAI,IAAI,CAAC,kBAAkB,EAAE;YAC5B,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,CAAC,CAAA;SACzB;QAOD,UAAU,CAAC,GAAG,EAAE,CAAA;IACjB,CAAC;IAED,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,eAAe,CAAC,CAAA;IACvC,OAAO,UAAU,CAAA;AAClB,CAAC,CAAA;AAED,kBAAe,WAAW,CAAA"}import { StreamBuilder } from '../shared';
declare const _default: StreamBuilder;
export default _default;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("buffer");
const ws_1 = __importDefault(require("ws"));
const debug_1 = __importDefault(require("debug"));
const duplexify_1 = __importDefault(require("duplexify"));
const readable_stream_1 = require("readable-stream");
const is_browser_1 = __importDefault(require("../is-browser"));
const debug = (0, debug_1.default)('mqttjs:ws');
const WSS_OPTIONS = [
    'rejectUnauthorized',
    'ca',
    'cert',
    'key',
    'pfx',
    'passphrase',
];
function buildUrl(opts, client) {
    let url = `${opts.protocol}://${opts.hostname}:${opts.port}${opts.path}`;
    if (typeof opts.transformWsUrl === 'function') {
        url = opts.transformWsUrl(url, opts, client);
    }
    return url;
}
function setDefaultOpts(opts) {
    const options = opts;
    if (!opts.hostname) {
        options.hostname = 'localhost';
    }
    if (!opts.port) {
        if (opts.protocol === 'wss') {
            options.port = 443;
        }
        else {
            options.port = 80;
        }
    }
    if (!opts.path) {
        options.path = '/';
    }
    if (!opts.wsOptions) {
        options.wsOptions = {};
    }
    if (!is_browser_1.default && opts.protocol === 'wss') {
        WSS_OPTIONS.forEach((prop) => {
            if (Object.prototype.hasOwnProperty.call(opts, prop) &&
                !Object.prototype.hasOwnProperty.call(opts.wsOptions, prop)) {
                options.wsOptions[prop] = opts[prop];
            }
        });
    }
    return options;
}
function setDefaultBrowserOpts(opts) {
    const options = setDefaultOpts(opts);
    if (!options.hostname) {
        options.hostname = options.host;
    }
    if (!options.hostname) {
        if (typeof document === 'undefined') {
            throw new Error('Could not determine host. Specify host manually.');
        }
        const parsed = new URL(document.URL);
        options.hostname = parsed.hostname;
        if (!options.port) {
            options.port = Number(parsed.port);
        }
    }
    if (options.objectMode === undefined) {
        options.objectMode = !(options.binary === true || options.binary === undefined);
    }
    return options;
}
function createWebSocket(client, url, opts) {
    debug('createWebSocket');
    debug(`protocol: ${opts.protocolId} ${opts.protocolVersion}`);
    const websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3
        ? 'mqttv3.1'
        : 'mqtt';
    debug(`creating new Websocket for url: ${url} and protocol: ${websocketSubProtocol}`);
    let socket;
    if (opts.createWebsocket) {
        socket = opts.createWebsocket(url, [websocketSubProtocol], opts);
    }
    else {
        socket = new ws_1.default(url, [websocketSubProtocol], opts.wsOptions);
    }
    return socket;
}
function createBrowserWebSocket(client, opts) {
    const websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3
        ? 'mqttv3.1'
        : 'mqtt';
    const url = buildUrl(opts, client);
    let socket;
    if (opts.createWebsocket) {
        socket = opts.createWebsocket(url, [websocketSubProtocol], opts);
    }
    else {
        socket = new WebSocket(url, [websocketSubProtocol]);
    }
    socket.binaryType = 'arraybuffer';
    return socket;
}
const streamBuilder = (client, opts) => {
    debug('streamBuilder');
    const options = setDefaultOpts(opts);
    const url = buildUrl(options, client);
    const socket = createWebSocket(client, url, options);
    const webSocketStream = ws_1.default.createWebSocketStream(socket, options.wsOptions);
    webSocketStream['url'] = url;
    socket.on('close', () => {
        webSocketStream.destroy();
    });
    return webSocketStream;
};
const browserStreamBuilder = (client, opts) => {
    debug('browserStreamBuilder');
    let stream;
    const options = setDefaultBrowserOpts(opts);
    const bufferSize = options.browserBufferSize || 1024 * 512;
    const bufferTimeout = opts.browserBufferTimeout || 1000;
    const coerceToBuffer = !opts.objectMode;
    const socket = createBrowserWebSocket(client, opts);
    const proxy = buildProxy(opts, socketWriteBrowser, socketEndBrowser);
    if (!opts.objectMode) {
        proxy._writev = writev;
    }
    proxy.on('close', () => {
        socket.close();
    });
    const eventListenerSupport = typeof socket.addEventListener !== 'undefined';
    if (socket.readyState === socket.OPEN) {
        stream = proxy;
    }
    else {
        stream = (0, duplexify_1.default)(undefined, undefined, opts);
        if (!opts.objectMode) {
            stream._writev = writev;
        }
        if (eventListenerSupport) {
            socket.addEventListener('open', onOpen);
        }
        else {
            socket.onopen = onOpen;
        }
    }
    stream.socket = socket;
    if (eventListenerSupport) {
        socket.addEventListener('close', onClose);
        socket.addEventListener('error', onError);
        socket.addEventListener('message', onMessage);
    }
    else {
        socket.onclose = onClose;
        socket.onerror = onError;
        socket.onmessage = onMessage;
    }
    function buildProxy(pOptions, socketWrite, socketEnd) {
        const _proxy = new readable_stream_1.Transform({
            objectMode: pOptions.objectMode,
        });
        _proxy._write = socketWrite;
        _proxy._flush = socketEnd;
        return _proxy;
    }
    function onOpen() {
        stream.setReadable(proxy);
        stream.setWritable(proxy);
        stream.emit('connect');
    }
    function onClose() {
        stream.end();
        stream.destroy();
    }
    function onError(err) {
        stream.destroy(err);
    }
    function onMessage(event) {
        let { data } = event;
        if (data instanceof ArrayBuffer)
            data = buffer_1.Buffer.from(data);
        else
            data = buffer_1.Buffer.from(data, 'utf8');
        proxy.push(data);
    }
    function writev(chunks, cb) {
        const buffers = new Array(chunks.length);
        for (let i = 0; i < chunks.length; i++) {
            if (typeof chunks[i].chunk === 'string') {
                buffers[i] = buffer_1.Buffer.from(chunks[i], 'utf8');
            }
            else {
                buffers[i] = chunks[i].chunk;
            }
        }
        this._write(buffer_1.Buffer.concat(buffers), 'binary', cb);
    }
    function socketWriteBrowser(chunk, enc, next) {
        if (socket.bufferedAmount > bufferSize) {
            setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next);
        }
        if (coerceToBuffer && typeof chunk === 'string') {
            chunk = buffer_1.Buffer.from(chunk, 'utf8');
        }
        try {
            socket.send(chunk);
        }
        catch (err) {
            return next(err);
        }
        next();
    }
    function socketEndBrowser(done) {
        socket.close();
        done();
    }
    return stream;
};
exports.default = is_browser_1.default ? browserStreamBuilder : streamBuilder;
//# sourceMappingURL=ws.js.map{"version":3,"file":"ws.js","sourceRoot":"","sources":["../../../src/lib/connect/ws.ts"],"names":[],"mappings":"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"}import { StreamBuilder } from '../shared';
declare const buildStream: StreamBuilder;
export default buildStream;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("buffer");
const readable_stream_1 = require("readable-stream");
const duplexify_1 = __importDefault(require("duplexify"));
let socketTask;
let proxy;
let stream;
function buildProxy() {
    const _proxy = new readable_stream_1.Transform();
    _proxy._write = (chunk, encoding, next) => {
        socketTask.send({
            data: chunk.buffer,
            success() {
                next();
            },
            fail(errMsg) {
                next(new Error(errMsg));
            },
        });
    };
    _proxy._flush = (done) => {
        socketTask.close({
            success() {
                done();
            },
        });
    };
    return _proxy;
}
function setDefaultOpts(opts) {
    if (!opts.hostname) {
        opts.hostname = 'localhost';
    }
    if (!opts.path) {
        opts.path = '/';
    }
    if (!opts.wsOptions) {
        opts.wsOptions = {};
    }
}
function buildUrl(opts, client) {
    const protocol = opts.protocol === 'wxs' ? 'wss' : 'ws';
    let url = `${protocol}://${opts.hostname}${opts.path}`;
    if (opts.port && opts.port !== 80 && opts.port !== 443) {
        url = `${protocol}://${opts.hostname}:${opts.port}${opts.path}`;
    }
    if (typeof opts.transformWsUrl === 'function') {
        url = opts.transformWsUrl(url, opts, client);
    }
    return url;
}
function bindEventHandler() {
    socketTask.onOpen(() => {
        stream.setReadable(proxy);
        stream.setWritable(proxy);
        stream.emit('connect');
    });
    socketTask.onMessage((res) => {
        let { data } = res;
        if (data instanceof ArrayBuffer)
            data = buffer_1.Buffer.from(data);
        else
            data = buffer_1.Buffer.from(data, 'utf8');
        proxy.push(data);
    });
    socketTask.onClose(() => {
        stream.emit('close');
        stream.end();
        stream.destroy();
    });
    socketTask.onError((res) => {
        stream.destroy(new Error(res.errMsg));
    });
}
const buildStream = (client, opts) => {
    opts.hostname = opts.hostname || opts.host;
    if (!opts.hostname) {
        throw new Error('Could not determine host. Specify host manually.');
    }
    const websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3
        ? 'mqttv3.1'
        : 'mqtt';
    setDefaultOpts(opts);
    const url = buildUrl(opts, client);
    socketTask = wx.connectSocket({
        url,
        protocols: [websocketSubProtocol],
    });
    proxy = buildProxy();
    stream = duplexify_1.default.obj();
    stream._destroy = (err, cb) => {
        socketTask.close({
            success() {
                if (cb)
                    cb(err);
            },
        });
    };
    const destroyRef = stream.destroy;
    stream.destroy = () => {
        stream.destroy = destroyRef;
        setTimeout(() => {
            socketTask.close({
                fail() {
                    stream._destroy(new Error());
                },
            });
        }, 0);
    };
    bindEventHandler();
    return stream;
};
exports.default = buildStream;
//# sourceMappingURL=wx.js.map{"version":3,"file":"wx.js","sourceRoot":"","sources":["../../../src/lib/connect/wx.ts"],"names":[],"mappings":"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"}export interface IMessageIdProvider {
    allocate(): number | null;
    getLastAllocated(): number | null;
    register(num: number): boolean;
    deallocate(num: number): void;
    clear(): void;
}
export default class DefaultMessageIdProvider implements IMessageIdProvider {
    private nextId;
    constructor();
    allocate(): number;
    getLastAllocated(): number;
    register(messageId: number): boolean;
    deallocate(messageId: number): void;
    clear(): void;
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class DefaultMessageIdProvider {
    constructor() {
        this.nextId = Math.max(1, Math.floor(Math.random() * 65535));
    }
    allocate() {
        const id = this.nextId++;
        if (this.nextId === 65536) {
            this.nextId = 1;
        }
        return id;
    }
    getLastAllocated() {
        return this.nextId === 1 ? 65535 : this.nextId - 1;
    }
    register(messageId) {
        return true;
    }
    deallocate(messageId) { }
    clear() { }
}
exports.default = DefaultMessageIdProvider;
//# sourceMappingURL=default-message-id-provider.js.map{"version":3,"file":"default-message-id-provider.js","sourceRoot":"","sources":["../../src/lib/default-message-id-provider.ts"],"names":[],"mappings":";;AAwCA,MAAqB,wBAAwB;IAG5C;QAKC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,KAAK,CAAC,CAAC,CAAA;IAC7D,CAAC;IAQD,QAAQ;QAEP,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAA;QAExB,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,EAAE;YAC1B,IAAI,CAAC,MAAM,GAAG,CAAC,CAAA;SACf;QACD,OAAO,EAAE,CAAA;IACV,CAAC;IAOD,gBAAgB;QACf,OAAO,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAA;IACnD,CAAC;IAQD,QAAQ,CAAC,SAAiB;QACzB,OAAO,IAAI,CAAA;IACZ,CAAC;IAOD,UAAU,CAAC,SAAiB,IAAG,CAAC;IAMhC,KAAK,KAAI,CAAC;CACV;AA1DD,2CA0DC"}import { PacketHandler } from '../shared';
export declare const ReasonCodes: {
    0: string;
    1: string;
    2: string;
    3: string;
    4: string;
    5: string;
    16: string;
    17: string;
    128: string;
    129: string;
    130: string;
    131: string;
    132: string;
    133: string;
    134: string;
    135: string;
    136: string;
    137: string;
    138: string;
    139: string;
    140: string;
    141: string;
    142: string;
    143: string;
    144: string;
    145: string;
    146: string;
    147: string;
    148: string;
    149: string;
    150: string;
    151: string;
    152: string;
    153: string;
    154: string;
    155: string;
    156: string;
    157: string;
    158: string;
    159: string;
    160: string;
    161: string;
    162: string;
};
declare const handleAck: PacketHandler;
export default handleAck;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReasonCodes = void 0;
exports.ReasonCodes = {
    0: '',
    1: 'Unacceptable protocol version',
    2: 'Identifier rejected',
    3: 'Server unavailable',
    4: 'Bad username or password',
    5: 'Not authorized',
    16: 'No matching subscribers',
    17: 'No subscription existed',
    128: 'Unspecified error',
    129: 'Malformed Packet',
    130: 'Protocol Error',
    131: 'Implementation specific error',
    132: 'Unsupported Protocol Version',
    133: 'Client Identifier not valid',
    134: 'Bad User Name or Password',
    135: 'Not authorized',
    136: 'Server unavailable',
    137: 'Server busy',
    138: 'Banned',
    139: 'Server shutting down',
    140: 'Bad authentication method',
    141: 'Keep Alive timeout',
    142: 'Session taken over',
    143: 'Topic Filter invalid',
    144: 'Topic Name invalid',
    145: 'Packet identifier in use',
    146: 'Packet Identifier not found',
    147: 'Receive Maximum exceeded',
    148: 'Topic Alias invalid',
    149: 'Packet too large',
    150: 'Message rate too high',
    151: 'Quota exceeded',
    152: 'Administrative action',
    153: 'Payload format invalid',
    154: 'Retain not supported',
    155: 'QoS not supported',
    156: 'Use another server',
    157: 'Server moved',
    158: 'Shared Subscriptions not supported',
    159: 'Connection rate exceeded',
    160: 'Maximum connect time',
    161: 'Subscription Identifiers not supported',
    162: 'Wildcard Subscriptions not supported',
};
const handleAck = (client, packet) => {
    const { messageId } = packet;
    const type = packet.cmd;
    let response = null;
    const cb = client.outgoing[messageId] ? client.outgoing[messageId].cb : null;
    let err;
    if (!cb) {
        client.log('_handleAck :: Server sent an ack in error. Ignoring.');
        return;
    }
    client.log('_handleAck :: packet type', type);
    switch (type) {
        case 'pubcomp':
        case 'puback': {
            const pubackRC = packet.reasonCode;
            if (pubackRC && pubackRC > 0 && pubackRC !== 16) {
                err = new Error(`Publish error: ${exports.ReasonCodes[pubackRC]}`);
                err.code = pubackRC;
                client['_removeOutgoingAndStoreMessage'](messageId, () => {
                    cb(err, packet);
                });
            }
            else {
                client['_removeOutgoingAndStoreMessage'](messageId, cb);
            }
            break;
        }
        case 'pubrec': {
            response = {
                cmd: 'pubrel',
                qos: 2,
                messageId,
            };
            const pubrecRC = packet.reasonCode;
            if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {
                err = new Error(`Publish error: ${exports.ReasonCodes[pubrecRC]}`);
                err.code = pubrecRC;
                client['_removeOutgoingAndStoreMessage'](messageId, () => {
                    cb(err, packet);
                });
            }
            else {
                client['_sendPacket'](response);
            }
            break;
        }
        case 'suback': {
            delete client.outgoing[messageId];
            client.messageIdProvider.deallocate(messageId);
            const granted = packet.granted;
            for (let grantedI = 0; grantedI < granted.length; grantedI++) {
                if ((granted[grantedI] & 0x80) !== 0) {
                    const topics = client.messageIdToTopic[messageId];
                    if (topics) {
                        topics.forEach((topic) => {
                            delete client['_resubscribeTopics'][topic];
                        });
                    }
                }
            }
            delete client.messageIdToTopic[messageId];
            client['_invokeStoreProcessingQueue']();
            cb(null, packet);
            break;
        }
        case 'unsuback': {
            delete client.outgoing[messageId];
            client.messageIdProvider.deallocate(messageId);
            client['_invokeStoreProcessingQueue']();
            cb(null);
            break;
        }
        default:
            client.emit('error', new Error('unrecognized packet type'));
    }
    if (client.disconnecting && Object.keys(client.outgoing).length === 0) {
        client.emit('outgoingEmpty');
    }
};
exports.default = handleAck;
//# sourceMappingURL=ack.js.map{"version":3,"file":"ack.js","sourceRoot":"","sources":["../../../src/lib/handlers/ack.ts"],"names":[],"mappings":"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"}import { PacketHandler } from '../shared';
declare const handleAuth: PacketHandler;
export default handleAuth;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const shared_1 = require("../shared");
const ack_1 = require("./ack");
const handleAuth = (client, packet) => {
    const { options } = client;
    const version = options.protocolVersion;
    const rc = version === 5 ? packet.reasonCode : packet.returnCode;
    if (version !== 5) {
        const err = new shared_1.ErrorWithReasonCode(`Protocol error: Auth packets are only supported in MQTT 5. Your version:${version}`, rc);
        client.emit('error', err);
        return;
    }
    client.handleAuth(packet, (err, packet2) => {
        if (err) {
            client.emit('error', err);
            return;
        }
        if (rc === 24) {
            client.reconnecting = false;
            client['_sendPacket'](packet2);
        }
        else {
            const error = new shared_1.ErrorWithReasonCode(`Connection refused: ${ack_1.ReasonCodes[rc]}`, rc);
            client.emit('error', error);
        }
    });
};
exports.default = handleAuth;
//# sourceMappingURL=auth.js.map{"version":3,"file":"auth.js","sourceRoot":"","sources":["../../../src/lib/handlers/auth.ts"],"names":[],"mappings":";;AACA,sCAA8D;AAC9D,+BAAmC;AAEnC,MAAM,UAAU,GAAkB,CACjC,MAAM,EACN,MAA4C,EAC3C,EAAE;IACH,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAA;IAC1B,MAAM,OAAO,GAAG,OAAO,CAAC,eAAe,CAAA;IACvC,MAAM,EAAE,GAAG,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,CAAA;IAEhE,IAAI,OAAO,KAAK,CAAC,EAAE;QAClB,MAAM,GAAG,GAAG,IAAI,4BAAmB,CAClC,2EAA2E,OAAO,EAAE,EACpF,EAAE,CACF,CAAA;QACD,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,CAAC,CAAA;QACzB,OAAM;KACN;IAED,MAAM,CAAC,UAAU,CAChB,MAAM,EACN,CAAC,GAAwB,EAAE,OAAoB,EAAE,EAAE;QAClD,IAAI,GAAG,EAAE;YACR,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,CAAC,CAAA;YACzB,OAAM;SACN;QAED,IAAI,EAAE,KAAK,EAAE,EAAE;YACd,MAAM,CAAC,YAAY,GAAG,KAAK,CAAA;YAC3B,MAAM,CAAC,aAAa,CAAC,CAAC,OAAO,CAAC,CAAA;SAC9B;aAAM;YACN,MAAM,KAAK,GAAG,IAAI,4BAAmB,CACpC,uBAAuB,iBAAW,CAAC,EAAE,CAAC,EAAE,EACxC,EAAE,CACF,CAAA;YACD,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAA;SAC3B;IACF,CAAC,CACD,CAAA;AACF,CAAC,CAAA;AAED,kBAAe,UAAU,CAAA"}import { PacketHandler } from '../shared';
declare const handleConnack: PacketHandler;
export default handleConnack;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ack_1 = require("./ack");
const topic_alias_send_1 = __importDefault(require("../topic-alias-send"));
const shared_1 = require("../shared");
const handleConnack = (client, packet) => {
    client.log('_handleConnack');
    const { options } = client;
    const version = options.protocolVersion;
    const rc = version === 5 ? packet.reasonCode : packet.returnCode;
    clearTimeout(client['connackTimer']);
    delete client['topicAliasSend'];
    if (packet.properties) {
        if (packet.properties.topicAliasMaximum) {
            if (packet.properties.topicAliasMaximum > 0xffff) {
                client.emit('error', new Error('topicAliasMaximum from broker is out of range'));
                return;
            }
            if (packet.properties.topicAliasMaximum > 0) {
                client['topicAliasSend'] = new topic_alias_send_1.default(packet.properties.topicAliasMaximum);
            }
        }
        if (packet.properties.serverKeepAlive && options.keepalive) {
            options.keepalive = packet.properties.serverKeepAlive;
            client['_shiftPingInterval']();
        }
        if (packet.properties.maximumPacketSize) {
            if (!options.properties) {
                options.properties = {};
            }
            options.properties.maximumPacketSize =
                packet.properties.maximumPacketSize;
        }
    }
    if (rc === 0) {
        client.reconnecting = false;
        client['_onConnect'](packet);
    }
    else if (rc > 0) {
        const err = new shared_1.ErrorWithReasonCode(`Connection refused: ${ack_1.ReasonCodes[rc]}`, rc);
        client.emit('error', err);
    }
};
exports.default = handleConnack;
//# sourceMappingURL=connack.js.map{"version":3,"file":"connack.js","sourceRoot":"","sources":["../../../src/lib/handlers/connack.ts"],"names":[],"mappings":";;;;;AAAA,+BAAmC;AACnC,2EAAgD;AAChD,sCAA8D;AAG9D,MAAM,aAAa,GAAkB,CAAC,MAAM,EAAE,MAAsB,EAAE,EAAE;IACvE,MAAM,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAA;IAC5B,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAA;IAC1B,MAAM,OAAO,GAAG,OAAO,CAAC,eAAe,CAAA;IACvC,MAAM,EAAE,GAAG,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,CAAA;IAEhE,YAAY,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC,CAAA;IACpC,OAAO,MAAM,CAAC,gBAAgB,CAAC,CAAA;IAE/B,IAAI,MAAM,CAAC,UAAU,EAAE;QACtB,IAAI,MAAM,CAAC,UAAU,CAAC,iBAAiB,EAAE;YACxC,IAAI,MAAM,CAAC,UAAU,CAAC,iBAAiB,GAAG,MAAM,EAAE;gBACjD,MAAM,CAAC,IAAI,CACV,OAAO,EACP,IAAI,KAAK,CAAC,+CAA+C,CAAC,CAC1D,CAAA;gBACD,OAAM;aACN;YACD,IAAI,MAAM,CAAC,UAAU,CAAC,iBAAiB,GAAG,CAAC,EAAE;gBAC5C,MAAM,CAAC,gBAAgB,CAAC,GAAG,IAAI,0BAAc,CAC5C,MAAM,CAAC,UAAU,CAAC,iBAAiB,CACnC,CAAA;aACD;SACD;QACD,IAAI,MAAM,CAAC,UAAU,CAAC,eAAe,IAAI,OAAO,CAAC,SAAS,EAAE;YAC3D,OAAO,CAAC,SAAS,GAAG,MAAM,CAAC,UAAU,CAAC,eAAe,CAAA;YACrD,MAAM,CAAC,oBAAoB,CAAC,EAAE,CAAA;SAC9B;QACD,IAAI,MAAM,CAAC,UAAU,CAAC,iBAAiB,EAAE;YACxC,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE;gBACxB,OAAO,CAAC,UAAU,GAAG,EAAE,CAAA;aACvB;YACD,OAAO,CAAC,UAAU,CAAC,iBAAiB;gBACnC,MAAM,CAAC,UAAU,CAAC,iBAAiB,CAAA;SACpC;KACD;IAED,IAAI,EAAE,KAAK,CAAC,EAAE;QACb,MAAM,CAAC,YAAY,GAAG,KAAK,CAAA;QAC3B,MAAM,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC,CAAA;KAC5B;SAAM,IAAI,EAAE,GAAG,CAAC,EAAE;QAClB,MAAM,GAAG,GAAG,IAAI,4BAAmB,CAClC,uBAAuB,iBAAW,CAAC,EAAE,CAAC,EAAE,EACxC,EAAE,CACF,CAAA;QACD,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,CAAC,CAAA;KACzB;AACF,CAAC,CAAA;AAED,kBAAe,aAAa,CAAA"}import { PacketHandler } from '../shared';
declare const handle: PacketHandler;
export default handle;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const publish_1 = __importDefault(require("./publish"));
const auth_1 = __importDefault(require("./auth"));
const connack_1 = __importDefault(require("./connack"));
const ack_1 = __importDefault(require("./ack"));
const pubrel_1 = __importDefault(require("./pubrel"));
const handle = (client, packet, done) => {
    const { options } = client;
    if (options.protocolVersion === 5 &&
        options.properties &&
        options.properties.maximumPacketSize &&
        options.properties.maximumPacketSize < packet.length) {
        client.emit('error', new Error(`exceeding packets size ${packet.cmd}`));
        client.end({
            reasonCode: 149,
            properties: { reasonString: 'Maximum packet size was exceeded' },
        });
        return client;
    }
    client.log('_handlePacket :: emitting packetreceive');
    client.emit('packetreceive', packet);
    switch (packet.cmd) {
        case 'publish':
            (0, publish_1.default)(client, packet, done);
            break;
        case 'puback':
        case 'pubrec':
        case 'pubcomp':
        case 'suback':
        case 'unsuback':
            (0, ack_1.default)(client, packet);
            done();
            break;
        case 'pubrel':
            (0, pubrel_1.default)(client, packet, done);
            break;
        case 'connack':
            (0, connack_1.default)(client, packet);
            done();
            break;
        case 'auth':
            (0, auth_1.default)(client, packet);
            done();
            break;
        case 'pingresp':
            client.pingResp = true;
            done();
            break;
        case 'disconnect':
            client.emit('disconnect', packet);
            done();
            break;
        default:
            client.log('_handlePacket :: unknown command');
            done();
            break;
    }
};
exports.default = handle;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/lib/handlers/index.ts"],"names":[],"mappings":";;;;;AAAA,wDAAqC;AACrC,kDAA+B;AAC/B,wDAAqC;AACrC,gDAA6B;AAC7B,sDAAmC;AAGnC,MAAM,MAAM,GAAkB,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE;IACtD,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAA;IAE1B,IACC,OAAO,CAAC,eAAe,KAAK,CAAC;QAC7B,OAAO,CAAC,UAAU;QAClB,OAAO,CAAC,UAAU,CAAC,iBAAiB;QACpC,OAAO,CAAC,UAAU,CAAC,iBAAiB,GAAG,MAAM,CAAC,MAAM,EACnD;QACD,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,KAAK,CAAC,0BAA0B,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAA;QACvE,MAAM,CAAC,GAAG,CAAC;YACV,UAAU,EAAE,GAAG;YACf,UAAU,EAAE,EAAE,YAAY,EAAE,kCAAkC,EAAE;SAChE,CAAC,CAAA;QACF,OAAO,MAAM,CAAA;KACb;IACD,MAAM,CAAC,GAAG,CAAC,yCAAyC,CAAC,CAAA;IACrD,MAAM,CAAC,IAAI,CAAC,eAAe,EAAE,MAAM,CAAC,CAAA;IAEpC,QAAQ,MAAM,CAAC,GAAG,EAAE;QACnB,KAAK,SAAS;YACb,IAAA,iBAAa,EAAC,MAAM,EAAE,MAAM,EAAE,IAAI,CAAC,CAAA;YACnC,MAAK;QACN,KAAK,QAAQ,CAAC;QACd,KAAK,QAAQ,CAAC;QACd,KAAK,SAAS,CAAC;QACf,KAAK,QAAQ,CAAC;QACd,KAAK,UAAU;YACd,IAAA,aAAS,EAAC,MAAM,EAAE,MAAM,CAAC,CAAA;YACzB,IAAI,EAAE,CAAA;YACN,MAAK;QACN,KAAK,QAAQ;YACZ,IAAA,gBAAY,EAAC,MAAM,EAAE,MAAM,EAAE,IAAI,CAAC,CAAA;YAClC,MAAK;QACN,KAAK,SAAS;YACb,IAAA,iBAAa,EAAC,MAAM,EAAE,MAAM,CAAC,CAAA;YAC7B,IAAI,EAAE,CAAA;YACN,MAAK;QACN,KAAK,MAAM;YACV,IAAA,cAAU,EAAC,MAAM,EAAE,MAAM,CAAC,CAAA;YAC1B,IAAI,EAAE,CAAA;YACN,MAAK;QACN,KAAK,UAAU;YAEd,MAAM,CAAC,QAAQ,GAAG,IAAI,CAAA;YACtB,IAAI,EAAE,CAAA;YACN,MAAK;QACN,KAAK,YAAY;YAChB,MAAM,CAAC,IAAI,CAAC,YAAY,EAAE,MAAM,CAAC,CAAA;YACjC,IAAI,EAAE,CAAA;YACN,MAAK;QACN;YAEC,MAAM,CAAC,GAAG,CAAC,kCAAkC,CAAC,CAAA;YAC9C,IAAI,EAAE,CAAA;YACN,MAAK;KACN;AACF,CAAC,CAAA;AAED,kBAAe,MAAM,CAAA"}import { PacketHandler } from '../shared';
declare const handlePublish: PacketHandler;
export default handlePublish;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153];
const handlePublish = (client, packet, done) => {
    client.log('handlePublish: packet %o', packet);
    done = typeof done !== 'undefined' ? done : client.noop;
    let topic = packet.topic.toString();
    const message = packet.payload;
    const { qos } = packet;
    const { messageId } = packet;
    const { options } = client;
    if (client.options.protocolVersion === 5) {
        let alias;
        if (packet.properties) {
            alias = packet.properties.topicAlias;
        }
        if (typeof alias !== 'undefined') {
            if (topic.length === 0) {
                if (alias > 0 && alias <= 0xffff) {
                    const gotTopic = client['topicAliasRecv'].getTopicByAlias(alias);
                    if (gotTopic) {
                        topic = gotTopic;
                        client.log('handlePublish :: topic complemented by alias. topic: %s - alias: %d', topic, alias);
                    }
                    else {
                        client.log('handlePublish :: unregistered topic alias. alias: %d', alias);
                        client.emit('error', new Error('Received unregistered Topic Alias'));
                        return;
                    }
                }
                else {
                    client.log('handlePublish :: topic alias out of range. alias: %d', alias);
                    client.emit('error', new Error('Received Topic Alias is out of range'));
                    return;
                }
            }
            else if (client['topicAliasRecv'].put(topic, alias)) {
                client.log('handlePublish :: registered topic: %s - alias: %d', topic, alias);
            }
            else {
                client.log('handlePublish :: topic alias out of range. alias: %d', alias);
                client.emit('error', new Error('Received Topic Alias is out of range'));
                return;
            }
        }
    }
    client.log('handlePublish: qos %d', qos);
    switch (qos) {
        case 2: {
            options.customHandleAcks(topic, message, packet, (error, code) => {
                if (typeof error === 'number') {
                    code = error;
                    error = null;
                }
                if (error) {
                    return client.emit('error', error);
                }
                if (validReasonCodes.indexOf(code) === -1) {
                    return client.emit('error', new Error('Wrong reason code for pubrec'));
                }
                if (code) {
                    client['_sendPacket']({ cmd: 'pubrec', messageId, reasonCode: code }, done);
                }
                else {
                    client.incomingStore.put(packet, () => {
                        client['_sendPacket']({ cmd: 'pubrec', messageId }, done);
                    });
                }
            });
            break;
        }
        case 1: {
            options.customHandleAcks(topic, message, packet, (error, code) => {
                if (typeof error === 'number') {
                    code = error;
                    error = null;
                }
                if (error) {
                    return client.emit('error', error);
                }
                if (validReasonCodes.indexOf(code) === -1) {
                    return client.emit('error', new Error('Wrong reason code for puback'));
                }
                if (!code) {
                    client.emit('message', topic, message, packet);
                }
                client.handleMessage(packet, (err) => {
                    if (err) {
                        return done && done(err);
                    }
                    client['_sendPacket']({ cmd: 'puback', messageId, reasonCode: code }, done);
                });
            });
            break;
        }
        case 0:
            client.emit('message', topic, message, packet);
            client.handleMessage(packet, done);
            break;
        default:
            client.log('handlePublish: unknown QoS. Doing nothing.');
            break;
    }
};
exports.default = handlePublish;
//# sourceMappingURL=publish.js.map{"version":3,"file":"publish.js","sourceRoot":"","sources":["../../../src/lib/handlers/publish.ts"],"names":[],"mappings":"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"}import { PacketHandler } from '../shared';
declare const handlePubrel: PacketHandler;
export default handlePubrel;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const handlePubrel = (client, packet, done) => {
    client.log('handling pubrel packet');
    const callback = typeof done !== 'undefined' ? done : client.noop;
    const { messageId } = packet;
    const comp = { cmd: 'pubcomp', messageId };
    client.incomingStore.get(packet, (err, pub) => {
        if (!err) {
            client.emit('message', pub.topic, pub.payload, pub);
            client.handleMessage(pub, (err2) => {
                if (err2) {
                    return callback(err2);
                }
                client.incomingStore.del(pub, client.noop);
                client['_sendPacket'](comp, callback);
            });
        }
        else {
            client['_sendPacket'](comp, callback);
        }
    });
};
exports.default = handlePubrel;
//# sourceMappingURL=pubrel.js.map{"version":3,"file":"pubrel.js","sourceRoot":"","sources":["../../../src/lib/handlers/pubrel.ts"],"names":[],"mappings":";;AAGA,MAAM,YAAY,GAAkB,CAAC,MAAM,EAAE,MAAqB,EAAE,IAAI,EAAE,EAAE;IAC3E,MAAM,CAAC,GAAG,CAAC,wBAAwB,CAAC,CAAA;IACpC,MAAM,QAAQ,GAAG,OAAO,IAAI,KAAK,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAA;IACjE,MAAM,EAAE,SAAS,EAAE,GAAG,MAAM,CAAA;IAE5B,MAAM,IAAI,GAAmB,EAAE,GAAG,EAAE,SAAS,EAAE,SAAS,EAAE,CAAA;IAE1D,MAAM,CAAC,aAAa,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,GAAmB,EAAE,EAAE;QAC7D,IAAI,CAAC,GAAG,EAAE;YACT,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,OAAiB,EAAE,GAAG,CAAC,CAAA;YAC7D,MAAM,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC,IAAI,EAAE,EAAE;gBAClC,IAAI,IAAI,EAAE;oBACT,OAAO,QAAQ,CAAC,IAAI,CAAC,CAAA;iBACrB;gBACD,MAAM,CAAC,aAAa,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,IAAI,CAAC,CAAA;gBAC1C,MAAM,CAAC,aAAa,CAAC,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAA;YACtC,CAAC,CAAC,CAAA;SACF;aAAM;YACN,MAAM,CAAC,aAAa,CAAC,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAA;SACrC;IACF,CAAC,CAAC,CAAA;AACH,CAAC,CAAA;AAED,kBAAe,YAAY,CAAA"}declare const isBrowser: boolean;
export default isBrowser;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const isBrowser = (typeof window !== 'undefined' && typeof window.document !== 'undefined') ||
    (typeof self === 'object' &&
        self.constructor &&
        self.constructor.name === 'DedicatedWorkerGlobalScope') ||
    (typeof navigator !== 'undefined' && navigator.product === 'ReactNative');
exports.default = isBrowser;
//# sourceMappingURL=is-browser.js.map{"version":3,"file":"is-browser.js","sourceRoot":"","sources":["../../src/lib/is-browser.ts"],"names":[],"mappings":";;AAAA,MAAM,SAAS,GACd,CAAC,OAAO,MAAM,KAAK,WAAW,IAAI,OAAO,MAAM,CAAC,QAAQ,KAAK,WAAW,CAAC;IAEzE,CAAC,OAAO,IAAI,KAAK,QAAQ;QAExB,IAAI,CAAC,WAAW;QAEhB,IAAI,CAAC,WAAW,CAAC,IAAI,KAAK,4BAA4B,CAAC;IACxD,CAAC,OAAO,SAAS,KAAK,WAAW,IAAI,SAAS,CAAC,OAAO,KAAK,aAAa,CAAC,CAAA;AAE1E,kBAAe,SAAS,CAAA"}/// <reference types="node" />
import type { Packet } from 'mqtt-packet';
import type { Duplex } from 'stream';
import type MqttClient from './client';
import type { IClientOptions } from './client';
export type DoneCallback = (error?: Error) => void;
export type GenericCallback<T> = (error?: Error, result?: T) => void;
export type VoidCallback = () => void;
export type IStream = Duplex;
export type StreamBuilder = (client: MqttClient, opts?: IClientOptions) => IStream;
export type Callback = () => void;
export type PacketHandler = (client: MqttClient, packet: Packet, done?: DoneCallback) => void;
export declare class ErrorWithReasonCode extends Error {
    code: number;
    constructor(message: string, code: number);
}
export type Constructor<T = {}> = new (...args: any[]) => T;
export declare function applyMixin(target: Constructor, mixin: Constructor, includeConstructor?: boolean): void;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyMixin = exports.ErrorWithReasonCode = void 0;
class ErrorWithReasonCode extends Error {
    constructor(message, code) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ErrorWithReasonCode.prototype);
        Object.getPrototypeOf(this).name = 'ErrorWithReasonCode';
    }
}
exports.ErrorWithReasonCode = ErrorWithReasonCode;
function applyMixin(target, mixin, includeConstructor = false) {
    var _a;
    const inheritanceChain = [mixin];
    while (true) {
        const current = inheritanceChain[0];
        const base = Object.getPrototypeOf(current);
        if (base === null || base === void 0 ? void 0 : base.prototype) {
            inheritanceChain.unshift(base);
        }
        else {
            break;
        }
    }
    for (const ctor of inheritanceChain) {
        for (const prop of Object.getOwnPropertyNames(ctor.prototype)) {
            if (includeConstructor || prop !== 'constructor') {
                Object.defineProperty(target.prototype, prop, (_a = Object.getOwnPropertyDescriptor(ctor.prototype, prop)) !== null && _a !== void 0 ? _a : Object.create(null));
            }
        }
    }
}
exports.applyMixin = applyMixin;
//# sourceMappingURL=shared.js.map{"version":3,"file":"shared.js","sourceRoot":"","sources":["../../src/lib/shared.ts"],"names":[],"mappings":";;;AA0BA,MAAa,mBAAoB,SAAQ,KAAK;IAG7C,YAAmB,OAAe,EAAE,IAAY;QAC/C,KAAK,CAAC,OAAO,CAAC,CAAA;QACd,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;QAGhB,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,mBAAmB,CAAC,SAAS,CAAC,CAAA;QAC1D,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,IAAI,GAAG,qBAAqB,CAAA;IACzD,CAAC;CACD;AAXD,kDAWC;AAKD,SAAgB,UAAU,CACzB,MAAmB,EACnB,KAAkB,EAClB,kBAAkB,GAAG,KAAK;;IAG1B,MAAM,gBAAgB,GAAkB,CAAC,KAAK,CAAC,CAAA;IAE/C,OAAO,IAAI,EAAE;QACZ,MAAM,OAAO,GAAG,gBAAgB,CAAC,CAAC,CAAC,CAAA;QACnC,MAAM,IAAI,GAAG,MAAM,CAAC,cAAc,CAAC,OAAO,CAAC,CAAA;QAC3C,IAAI,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,SAAS,EAAE;YACpB,gBAAgB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA;SAC9B;aAAM;YACN,MAAK;SACL;KACD;IACD,KAAK,MAAM,IAAI,IAAI,gBAAgB,EAAE;QACpC,KAAK,MAAM,IAAI,IAAI,MAAM,CAAC,mBAAmB,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE;YAE9D,IAAI,kBAAkB,IAAI,IAAI,KAAK,aAAa,EAAE;gBACjD,MAAM,CAAC,cAAc,CACpB,MAAM,CAAC,SAAS,EAChB,IAAI,EACJ,MAAA,MAAM,CAAC,wBAAwB,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,mCACpD,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CACpB,CAAA;aACD;SACD;KACD;AACF,CAAC;AA9BD,gCA8BC"}import { Readable } from 'readable-stream';
import { Packet } from 'mqtt-packet';
import { DoneCallback } from './shared';
export interface IStoreOptions {
    clean?: boolean;
}
export type PacketCallback = (error?: Error, packet?: Packet) => void;
export interface IStore {
    put(packet: Packet, cb: DoneCallback): IStore;
    createStream(): Readable;
    del(packet: Pick<Packet, 'messageId'>, cb: PacketCallback): IStore;
    get(packet: Pick<Packet, 'messageId'>, cb: PacketCallback): IStore;
    close(cb: DoneCallback): void;
}
export default class Store implements IStore {
    private options;
    private _inflights;
    constructor(options?: IStoreOptions);
    put(packet: Packet, cb: DoneCallback): this;
    createStream(): Readable;
    del(packet: Pick<Packet, 'messageId'>, cb: PacketCallback): this;
    get(packet: Pick<Packet, 'messageId'>, cb: PacketCallback): this;
    close(cb: DoneCallback): void;
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const readable_stream_1 = require("readable-stream");
const streamsOpts = { objectMode: true };
const defaultStoreOptions = {
    clean: true,
};
class Store {
    constructor(options) {
        this.options = options || {};
        this.options = Object.assign(Object.assign({}, defaultStoreOptions), options);
        this._inflights = new Map();
    }
    put(packet, cb) {
        this._inflights.set(packet.messageId, packet);
        if (cb) {
            cb();
        }
        return this;
    }
    createStream() {
        const stream = new readable_stream_1.Readable(streamsOpts);
        const values = [];
        let destroyed = false;
        let i = 0;
        this._inflights.forEach((value, key) => {
            values.push(value);
        });
        stream._read = () => {
            if (!destroyed && i < values.length) {
                stream.push(values[i++]);
            }
            else {
                stream.push(null);
            }
        };
        stream.destroy = (err) => {
            if (destroyed) {
                return;
            }
            destroyed = true;
            setTimeout(() => {
                stream.emit('close');
            }, 0);
            return stream;
        };
        return stream;
    }
    del(packet, cb) {
        const toDelete = this._inflights.get(packet.messageId);
        if (toDelete) {
            this._inflights.delete(packet.messageId);
            cb(null, toDelete);
        }
        else if (cb) {
            cb(new Error('missing packet'));
        }
        return this;
    }
    get(packet, cb) {
        const storedPacket = this._inflights.get(packet.messageId);
        if (storedPacket) {
            cb(null, storedPacket);
        }
        else if (cb) {
            cb(new Error('missing packet'));
        }
        return this;
    }
    close(cb) {
        if (this.options.clean) {
            this._inflights = null;
        }
        if (cb) {
            cb();
        }
    }
}
exports.default = Store;
//# sourceMappingURL=store.js.map{"version":3,"file":"store.js","sourceRoot":"","sources":["../../src/lib/store.ts"],"names":[],"mappings":"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"}export default class TopicAliasRecv {
    private aliasToTopic;
    max: number;
    length: number;
    constructor(max: number);
    put(topic: string, alias: number): boolean;
    getTopicByAlias(alias: number): string;
    clear(): void;
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class TopicAliasRecv {
    constructor(max) {
        this.aliasToTopic = {};
        this.max = max;
    }
    put(topic, alias) {
        if (alias === 0 || alias > this.max) {
            return false;
        }
        this.aliasToTopic[alias] = topic;
        this.length = Object.keys(this.aliasToTopic).length;
        return true;
    }
    getTopicByAlias(alias) {
        return this.aliasToTopic[alias];
    }
    clear() {
        this.aliasToTopic = {};
    }
}
exports.default = TopicAliasRecv;
//# sourceMappingURL=topic-alias-recv.js.map{"version":3,"file":"topic-alias-recv.js","sourceRoot":"","sources":["../../src/lib/topic-alias-recv.ts"],"names":[],"mappings":";;AAKA,MAAqB,cAAc;IAOlC,YAAY,GAAW;QACtB,IAAI,CAAC,YAAY,GAAG,EAAE,CAAA;QACtB,IAAI,CAAC,GAAG,GAAG,GAAG,CAAA;IACf,CAAC;IAQD,GAAG,CAAC,KAAa,EAAE,KAAa;QAC/B,IAAI,KAAK,KAAK,CAAC,IAAI,KAAK,GAAG,IAAI,CAAC,GAAG,EAAE;YACpC,OAAO,KAAK,CAAA;SACZ;QACD,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,KAAK,CAAA;QAChC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,MAAM,CAAA;QACnD,OAAO,IAAI,CAAA;IACZ,CAAC;IAOD,eAAe,CAAC,KAAa;QAC5B,OAAO,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAA;IAChC,CAAC;IAKD,KAAK;QACJ,IAAI,CAAC,YAAY,GAAG,EAAE,CAAA;IACvB,CAAC;CACD;AA1CD,iCA0CC"}export default class TopicAliasSend {
    private aliasToTopic;
    private topicToAlias;
    private max;
    private numberAllocator;
    length: number;
    constructor(max: number);
    put(topic: string, alias: number): boolean;
    getTopicByAlias(alias: number): string;
    getAliasByTopic(topic: string): number | undefined;
    clear(): void;
    getLruAlias(): number;
}
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lru_cache_1 = __importDefault(require("lru-cache"));
const number_allocator_1 = require("number-allocator");
class TopicAliasSend {
    constructor(max) {
        if (max > 0) {
            this.aliasToTopic = new lru_cache_1.default({ max });
            this.topicToAlias = {};
            this.numberAllocator = new number_allocator_1.NumberAllocator(1, max);
            this.max = max;
            this.length = 0;
        }
    }
    put(topic, alias) {
        if (alias === 0 || alias > this.max) {
            return false;
        }
        const entry = this.aliasToTopic.get(alias);
        if (entry) {
            delete this.topicToAlias[entry];
        }
        this.aliasToTopic.set(alias, topic);
        this.topicToAlias[topic] = alias;
        this.numberAllocator.use(alias);
        this.length = this.aliasToTopic.size;
        return true;
    }
    getTopicByAlias(alias) {
        return this.aliasToTopic.get(alias);
    }
    getAliasByTopic(topic) {
        const alias = this.topicToAlias[topic];
        if (typeof alias !== 'undefined') {
            this.aliasToTopic.get(alias);
        }
        return alias;
    }
    clear() {
        this.aliasToTopic.clear();
        this.topicToAlias = {};
        this.numberAllocator.clear();
        this.length = 0;
    }
    getLruAlias() {
        const alias = this.numberAllocator.firstVacant();
        if (alias)
            return alias;
        return [...this.aliasToTopic.keys()][this.aliasToTopic.size - 1];
    }
}
exports.default = TopicAliasSend;
//# sourceMappingURL=topic-alias-send.js.map{"version":3,"file":"topic-alias-send.js","sourceRoot":"","sources":["../../src/lib/topic-alias-send.ts"],"names":[],"mappings":";;;;;AAGA,0DAAgC;AAChC,uDAAkD;AAOlD,MAAqB,cAAc;IAWlC,YAAY,GAAW;QACtB,IAAI,GAAG,GAAG,CAAC,EAAE;YACZ,IAAI,CAAC,YAAY,GAAG,IAAI,mBAAQ,CAAiB,EAAE,GAAG,EAAE,CAAC,CAAA;YACzD,IAAI,CAAC,YAAY,GAAG,EAAE,CAAA;YACtB,IAAI,CAAC,eAAe,GAAG,IAAI,kCAAe,CAAC,CAAC,EAAE,GAAG,CAAC,CAAA;YAClD,IAAI,CAAC,GAAG,GAAG,GAAG,CAAA;YACd,IAAI,CAAC,MAAM,GAAG,CAAC,CAAA;SACf;IACF,CAAC;IAQD,GAAG,CAAC,KAAa,EAAE,KAAa;QAC/B,IAAI,KAAK,KAAK,CAAC,IAAI,KAAK,GAAG,IAAI,CAAC,GAAG,EAAE;YACpC,OAAO,KAAK,CAAA;SACZ;QACD,MAAM,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;QAC1C,IAAI,KAAK,EAAE;YACV,OAAO,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAA;SAC/B;QACD,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,KAAK,EAAE,KAAK,CAAC,CAAA;QACnC,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,KAAK,CAAA;QAChC,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;QAC/B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAA;QACpC,OAAO,IAAI,CAAA;IACZ,CAAC;IAOD,eAAe,CAAC,KAAa;QAC5B,OAAO,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;IACpC,CAAC;IAOD,eAAe,CAAC,KAAa;QAC5B,MAAM,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAA;QACtC,IAAI,OAAO,KAAK,KAAK,WAAW,EAAE;YACjC,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;SAC5B;QACD,OAAO,KAAK,CAAA;IACb,CAAC;IAKD,KAAK;QACJ,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,CAAA;QACzB,IAAI,CAAC,YAAY,GAAG,EAAE,CAAA;QACtB,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAA;QAC5B,IAAI,CAAC,MAAM,GAAG,CAAC,CAAA;IAChB,CAAC;IAMD,WAAW;QACV,MAAM,KAAK,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE,CAAA;QAChD,IAAI,KAAK;YAAE,OAAO,KAAK,CAAA;QAEvB,OAAO,CAAC,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,GAAG,CAAC,CAAC,CAAA;IACjE,CAAC;CACD;AApFD,iCAoFC"}export type EventHandler = ((arg1: any, arg2: any, arg3: any, arg4: any) => void) | ((arg1: any, arg2: any, arg3: any) => void) | ((arg1: any, arg2: any) => void) | ((arg1: any) => void) | ((...args: any[]) => void);
export interface TypedEventEmitter<TEvents extends Record<keyof TEvents, EventHandler>> {
    on<TEvent extends keyof TEvents>(event: TEvent, callback: TEvents[TEvent]): this;
    once<TEvent extends keyof TEvents>(event: TEvent, callback: TEvents[TEvent]): this;
    prependListener<TEvent extends keyof TEvents>(event: TEvent, callback: TEvents[TEvent]): this;
    prependOnceListener<TEvent extends keyof TEvents>(event: TEvent, callback: TEvents[TEvent]): this;
    removeListener<TEvent extends keyof TEvents>(event: TEvent, callback: TEvents[TEvent]): this;
    off<TEvent extends keyof TEvents>(event: TEvent, callback: TEvents[TEvent]): this;
    removeAllListeners(event?: keyof TEvents): this;
    emit<TEvent extends keyof TEvents>(event: TEvent, ...args: Parameters<TEvents[TEvent]>): boolean;
    setMaxListeners(n: number): this;
    getMaxListeners(): number;
    listeners<TEvent extends keyof TEvents>(eventName: TEvent): TEvents[TEvent][];
    rawListeners<TEvent extends keyof TEvents>(eventName: TEvent): TEvents[TEvent][];
    listenerCount<TEvent extends keyof TEvents>(event: TEvent, listener?: TEvents[TEvent]): number;
    eventNames(): Array<keyof TEvents>;
}
export declare class TypedEventEmitter<TEvents extends Record<keyof TEvents, EventHandler>> {
}
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypedEventEmitter = void 0;
const events_1 = __importDefault(require("events"));
const shared_1 = require("./shared");
class TypedEventEmitter {
}
exports.TypedEventEmitter = TypedEventEmitter;
(0, shared_1.applyMixin)(TypedEventEmitter, events_1.default);
//# sourceMappingURL=TypedEmitter.js.map{"version":3,"file":"TypedEmitter.js","sourceRoot":"","sources":["../../src/lib/TypedEmitter.ts"],"names":[],"mappings":";;;;;;AAAA,oDAAiC;AACjC,qCAAqC;AAgErC,MAAa,iBAAiB;CAE1B;AAFJ,8CAEI;AAGJ,IAAA,mBAAU,EAAC,iBAAiB,EAAE,gBAAY,CAAC,CAAA"}import { IMessageIdProvider } from './default-message-id-provider';
export default class UniqueMessageIdProvider implements IMessageIdProvider {
    private numberAllocator;
    private lastId;
    constructor();
    allocate(): number;
    getLastAllocated(): number;
    register(messageId: number): boolean;
    deallocate(messageId: number): void;
    clear(): void;
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const number_allocator_1 = require("number-allocator");
class UniqueMessageIdProvider {
    constructor() {
        this.numberAllocator = new number_allocator_1.NumberAllocator(1, 65535);
    }
    allocate() {
        this.lastId = this.numberAllocator.alloc();
        return this.lastId;
    }
    getLastAllocated() {
        return this.lastId;
    }
    register(messageId) {
        return this.numberAllocator.use(messageId);
    }
    deallocate(messageId) {
        this.numberAllocator.free(messageId);
    }
    clear() {
        this.numberAllocator.clear();
    }
}
exports.default = UniqueMessageIdProvider;
//# sourceMappingURL=unique-message-id-provider.js.map{"version":3,"file":"unique-message-id-provider.js","sourceRoot":"","sources":["../../src/lib/unique-message-id-provider.ts"],"names":[],"mappings":";;AAAA,uDAAkD;AAOlD,MAAqB,uBAAuB;IAK3C;QACC,IAAI,CAAC,eAAe,GAAG,IAAI,kCAAe,CAAC,CAAC,EAAE,KAAK,CAAC,CAAA;IACrD,CAAC;IASD,QAAQ;QACP,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAA;QAC1C,OAAO,IAAI,CAAC,MAAM,CAAA;IACnB,CAAC;IAOD,gBAAgB;QACf,OAAO,IAAI,CAAC,MAAM,CAAA;IACnB,CAAC;IAQD,QAAQ,CAAC,SAAiB;QACzB,OAAO,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,SAAS,CAAY,CAAA;IACtD,CAAC;IAOD,UAAU,CAAC,SAAiB;QAC3B,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;IACrC,CAAC;IAMD,KAAK;QACJ,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAA;IAC7B,CAAC;CACD;AAxDD,0CAwDC"}export declare function validateTopic(topic: string): boolean;
export declare function validateTopics(topics: string[]): string;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateTopics = exports.validateTopic = void 0;
function validateTopic(topic) {
    const parts = topic.split('/');
    for (let i = 0; i < parts.length; i++) {
        if (parts[i] === '+') {
            continue;
        }
        if (parts[i] === '#') {
            return i === parts.length - 1;
        }
        if (parts[i].indexOf('+') !== -1 || parts[i].indexOf('#') !== -1) {
            return false;
        }
    }
    return true;
}
exports.validateTopic = validateTopic;
function validateTopics(topics) {
    if (topics.length === 0) {
        return 'empty_topic_list';
    }
    for (let i = 0; i < topics.length; i++) {
        if (!validateTopic(topics[i])) {
            return topics[i];
        }
    }
    return null;
}
exports.validateTopics = validateTopics;
//# sourceMappingURL=validations.js.map{"version":3,"file":"validations.js","sourceRoot":"","sources":["../../src/lib/validations.ts"],"names":[],"mappings":";;;AASA,SAAgB,aAAa,CAAC,KAAa;IAC1C,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;IAE9B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACtC,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;YACrB,SAAQ;SACR;QAED,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;YAErB,OAAO,CAAC,KAAK,KAAK,CAAC,MAAM,GAAG,CAAC,CAAA;SAC7B;QAED,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;YACjE,OAAO,KAAK,CAAA;SACZ;KACD;IAED,OAAO,IAAI,CAAA;AACZ,CAAC;AAnBD,sCAmBC;AAOD,SAAgB,cAAc,CAAC,MAAgB;IAC9C,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;QACxB,OAAO,kBAAkB,CAAA;KACzB;IACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACvC,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;YAC9B,OAAO,MAAM,CAAC,CAAC,CAAC,CAAA;SAChB;KACD;IACD,OAAO,IAAI,CAAA;AACZ,CAAC;AAVD,wCAUC"}import MqttClient from './lib/client';
import DefaultMessageIdProvider from './lib/default-message-id-provider';
import UniqueMessageIdProvider from './lib/unique-message-id-provider';
import Store, { IStore } from './lib/store';
import connect, { connectAsync } from './lib/connect';
export declare const Client: typeof MqttClient;
export { connect, connectAsync, MqttClient, Store, DefaultMessageIdProvider, UniqueMessageIdProvider, IStore, };
export * from './lib/client';
export * from './lib/shared';
export { ReasonCodes } from './lib/handlers/ack';
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReasonCodes = exports.UniqueMessageIdProvider = exports.DefaultMessageIdProvider = exports.Store = exports.MqttClient = exports.connectAsync = exports.connect = exports.Client = void 0;
const client_1 = __importDefault(require("./lib/client"));
exports.MqttClient = client_1.default;
const default_message_id_provider_1 = __importDefault(require("./lib/default-message-id-provider"));
exports.DefaultMessageIdProvider = default_message_id_provider_1.default;
const unique_message_id_provider_1 = __importDefault(require("./lib/unique-message-id-provider"));
exports.UniqueMessageIdProvider = unique_message_id_provider_1.default;
const store_1 = __importDefault(require("./lib/store"));
exports.Store = store_1.default;
const connect_1 = __importStar(require("./lib/connect"));
exports.connect = connect_1.default;
Object.defineProperty(exports, "connectAsync", { enumerable: true, get: function () { return connect_1.connectAsync; } });
exports.Client = client_1.default;
__exportStar(require("./lib/client"), exports);
__exportStar(require("./lib/shared"), exports);
var ack_1 = require("./lib/handlers/ack");
Object.defineProperty(exports, "ReasonCodes", { enumerable: true, get: function () { return ack_1.ReasonCodes; } });
//# sourceMappingURL=mqtt.js.map{"version":3,"file":"mqtt.js","sourceRoot":"","sources":["../src/mqtt.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA,0DAAqC;AAUpC,qBAVM,gBAAU,CAUN;AATX,oGAAwE;AAWvE,mCAXM,qCAAwB,CAWN;AAVzB,kGAAsE;AAWrE,kCAXM,oCAAuB,CAWN;AAVxB,wDAA2C;AAQ1C,gBARM,eAAK,CAQN;AAPN,yDAAqD;AAIpD,kBAJM,iBAAO,CAIN;AACP,6FALiB,sBAAY,OAKjB;AAHA,QAAA,MAAM,GAAG,gBAAU,CAAA;AAUhC,+CAA4B;AAC5B,+CAA4B;AAC5B,0CAAgD;AAAvC,kGAAA,WAAW,OAAA"}{"program":{"fileNames":["../node_modules/typescript/lib/lib.es5.d.ts","../node_modules/typescript/lib/lib.es2015.d.ts","../node_modules/typescript/lib/lib.es2016.d.ts","../node_modules/typescript/lib/lib.es2017.d.ts","../node_modules/typescript/lib/lib.es2018.d.ts","../node_modules/typescript/lib/lib.es2019.d.ts","../node_modules/typescript/lib/lib.es2020.d.ts","../node_modules/typescript/lib/lib.dom.d.ts","../node_modules/typescript/lib/lib.dom.iterable.d.ts","../node_modules/typescript/lib/lib.webworker.importscripts.d.ts","../node_modules/typescript/lib/lib.scripthost.d.ts","../node_modules/typescript/lib/lib.es2015.core.d.ts","../node_modules/typescript/lib/lib.es2015.collection.d.ts","../node_modules/typescript/lib/lib.es2015.generator.d.ts","../node_modules/typescript/lib/lib.es2015.iterable.d.ts","../node_modules/typescript/lib/lib.es2015.promise.d.ts","../node_modules/typescript/lib/lib.es2015.proxy.d.ts","../node_modules/typescript/lib/lib.es2015.reflect.d.ts","../node_modules/typescript/lib/lib.es2015.symbol.d.ts","../node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts","../node_modules/typescript/lib/lib.es2016.array.include.d.ts","../node_modules/typescript/lib/lib.es2017.date.d.ts","../node_modules/typescript/lib/lib.es2017.object.d.ts","../node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts","../node_modules/typescript/lib/lib.es2017.string.d.ts","../node_modules/typescript/lib/lib.es2017.intl.d.ts","../node_modules/typescript/lib/lib.es2017.typedarrays.d.ts","../node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts","../node_modules/typescript/lib/lib.es2018.asynciterable.d.ts","../node_modules/typescript/lib/lib.es2018.intl.d.ts","../node_modules/typescript/lib/lib.es2018.promise.d.ts","../node_modules/typescript/lib/lib.es2018.regexp.d.ts","../node_modules/typescript/lib/lib.es2019.array.d.ts","../node_modules/typescript/lib/lib.es2019.object.d.ts","../node_modules/typescript/lib/lib.es2019.string.d.ts","../node_modules/typescript/lib/lib.es2019.symbol.d.ts","../node_modules/typescript/lib/lib.es2019.intl.d.ts","../node_modules/typescript/lib/lib.es2020.bigint.d.ts","../node_modules/typescript/lib/lib.es2020.date.d.ts","../node_modules/typescript/lib/lib.es2020.promise.d.ts","../node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts","../node_modules/typescript/lib/lib.es2020.string.d.ts","../node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts","../node_modules/typescript/lib/lib.es2020.intl.d.ts","../node_modules/typescript/lib/lib.es2020.number.d.ts","../node_modules/typescript/lib/lib.esnext.intl.d.ts","../node_modules/typescript/lib/lib.decorators.d.ts","../node_modules/typescript/lib/lib.decorators.legacy.d.ts","../node_modules/typescript/lib/lib.es2017.full.d.ts","../src/lib/topic-alias-recv.ts","../node_modules/mqtt-packet/types/index.d.ts","../src/lib/default-message-id-provider.ts","../node_modules/@types/node/assert.d.ts","../node_modules/@types/node/assert/strict.d.ts","../node_modules/buffer/index.d.ts","../node_modules/undici-types/header.d.ts","../node_modules/undici-types/readable.d.ts","../node_modules/undici-types/file.d.ts","../node_modules/undici-types/fetch.d.ts","../node_modules/undici-types/formdata.d.ts","../node_modules/undici-types/connector.d.ts","../node_modules/undici-types/client.d.ts","../node_modules/undici-types/errors.d.ts","../node_modules/undici-types/dispatcher.d.ts","../node_modules/undici-types/global-dispatcher.d.ts","../node_modules/undici-types/global-origin.d.ts","../node_modules/undici-types/pool-stats.d.ts","../node_modules/undici-types/pool.d.ts","../node_modules/undici-types/handlers.d.ts","../node_modules/undici-types/balanced-pool.d.ts","../node_modules/undici-types/agent.d.ts","../node_modules/undici-types/mock-interceptor.d.ts","../node_modules/undici-types/mock-agent.d.ts","../node_modules/undici-types/mock-client.d.ts","../node_modules/undici-types/mock-pool.d.ts","../node_modules/undici-types/mock-errors.d.ts","../node_modules/undici-types/proxy-agent.d.ts","../node_modules/undici-types/api.d.ts","../node_modules/undici-types/cookies.d.ts","../node_modules/undici-types/patch.d.ts","../node_modules/undici-types/filereader.d.ts","../node_modules/undici-types/diagnostics-channel.d.ts","../node_modules/undici-types/websocket.d.ts","../node_modules/undici-types/content-type.d.ts","../node_modules/undici-types/cache.d.ts","../node_modules/undici-types/interceptors.d.ts","../node_modules/undici-types/index.d.ts","../node_modules/@types/node/globals.d.ts","../node_modules/@types/node/async_hooks.d.ts","../node_modules/@types/node/buffer.d.ts","../node_modules/@types/node/child_process.d.ts","../node_modules/@types/node/cluster.d.ts","../node_modules/@types/node/console.d.ts","../node_modules/@types/node/constants.d.ts","../node_modules/@types/node/crypto.d.ts","../node_modules/@types/node/dgram.d.ts","../node_modules/@types/node/diagnostics_channel.d.ts","../node_modules/@types/node/dns.d.ts","../node_modules/@types/node/dns/promises.d.ts","../node_modules/@types/node/domain.d.ts","../node_modules/@types/node/dom-events.d.ts","../node_modules/@types/node/events.d.ts","../node_modules/@types/node/fs.d.ts","../node_modules/@types/node/fs/promises.d.ts","../node_modules/@types/node/http.d.ts","../node_modules/@types/node/http2.d.ts","../node_modules/@types/node/https.d.ts","../node_modules/@types/node/inspector.d.ts","../node_modules/@types/node/module.d.ts","../node_modules/@types/node/net.d.ts","../node_modules/@types/node/os.d.ts","../node_modules/@types/node/path.d.ts","../node_modules/@types/node/perf_hooks.d.ts","../node_modules/@types/node/process.d.ts","../node_modules/@types/node/punycode.d.ts","../node_modules/@types/node/querystring.d.ts","../node_modules/@types/node/readline.d.ts","../node_modules/@types/node/readline/promises.d.ts","../node_modules/@types/node/repl.d.ts","../node_modules/@types/node/stream.d.ts","../node_modules/@types/node/stream/promises.d.ts","../node_modules/@types/node/stream/consumers.d.ts","../node_modules/@types/node/stream/web.d.ts","../node_modules/@types/node/string_decoder.d.ts","../node_modules/@types/node/test.d.ts","../node_modules/@types/node/timers.d.ts","../node_modules/@types/node/timers/promises.d.ts","../node_modules/@types/node/tls.d.ts","../node_modules/@types/node/trace_events.d.ts","../node_modules/@types/node/tty.d.ts","../node_modules/@types/node/url.d.ts","../node_modules/@types/node/util.d.ts","../node_modules/@types/node/v8.d.ts","../node_modules/@types/node/vm.d.ts","../node_modules/@types/node/wasi.d.ts","../node_modules/@types/node/worker_threads.d.ts","../node_modules/@types/node/zlib.d.ts","../node_modules/@types/node/globals.global.d.ts","../node_modules/@types/node/index.d.ts","../node_modules/@types/readable-stream/node_modules/safe-buffer/index.d.ts","../node_modules/@types/readable-stream/index.d.ts","../src/lib/validations.ts","../src/lib/shared.ts","../src/lib/store.ts","../src/lib/handlers/publish.ts","../src/lib/handlers/ack.ts","../src/lib/handlers/auth.ts","../node_modules/lru-cache/index.d.ts","../node_modules/number-allocator/types/lib/number-allocator.d.ts","../node_modules/number-allocator/types/index.d.ts","../src/lib/topic-alias-send.ts","../src/lib/handlers/connack.ts","../src/lib/handlers/pubrel.ts","../src/lib/handlers/index.ts","../node_modules/@types/ws/index.d.ts","../src/lib/TypedEmitter.ts","../src/lib/client.ts","../src/lib/unique-message-id-provider.ts","../src/lib/is-browser.ts","../src/lib/connect/index.ts","../src/mqtt.ts","../src/bin/pub.ts","../src/bin/sub.ts","../src/bin/mqtt.ts","../node_modules/@types/duplexify/index.d.ts","../src/lib/connect/ali.ts","../src/lib/connect/tcp.ts","../src/lib/connect/tls.ts","../src/lib/connect/ws.ts","../src/lib/connect/wx.ts"],"fileInfos":[{"version":"2ac9cdcfb8f8875c18d14ec5796a8b029c426f73ad6dc3ffb580c228b58d1c44","affectsGlobalScope":true},"45b7ab580deca34ae9729e97c13cfd999df04416a79116c3bfb483804f85ded4","dc48272d7c333ccf58034c0026162576b7d50ea0e69c3b9292f803fc20720fd5","9a68c0c07ae2fa71b44384a839b7b8d81662a236d4b9ac30916718f7510b1b2d","5e1c4c362065a6b95ff952c0eab010f04dcd2c3494e813b493ecfd4fcb9fc0d8","68d73b4a11549f9c0b7d352d10e91e5dca8faa3322bfb77b661839c42b1ddec7","5efce4fc3c29ea84e8928f97adec086e3dc876365e0982cc8479a07954a3efd4",{"version":"0075fa5ceda385bcdf3488e37786b5a33be730e8bc4aa3cf1e78c63891752ce8","affectsGlobalScope":true},{"version":"35299ae4a62086698444a5aaee27fc7aa377c68cbb90b441c9ace246ffd05c97","affectsGlobalScope":true},{"version":"c5c5565225fce2ede835725a92a28ece149f83542aa4866cfb10290bff7b8996","affectsGlobalScope":true},{"version":"7d2dbc2a0250400af0809b0ad5f84686e84c73526de931f84560e483eb16b03c","affectsGlobalScope":true},{"version":"f296963760430fb65b4e5d91f0ed770a91c6e77455bacf8fa23a1501654ede0e","affectsGlobalScope":true},{"version":"09226e53d1cfda217317074a97724da3e71e2c545e18774484b61562afc53cd2","affectsGlobalScope":true},{"version":"4443e68b35f3332f753eacc66a04ac1d2053b8b035a0e0ac1d455392b5e243b3","affectsGlobalScope":true},{"version":"8b41361862022eb72fcc8a7f34680ac842aca802cf4bc1f915e8c620c9ce4331","affectsGlobalScope":true},{"version":"f7bd636ae3a4623c503359ada74510c4005df5b36de7f23e1db8a5c543fd176b","affectsGlobalScope":true},{"version":"ce691fb9e5c64efb9547083e4a34091bcbe5bdb41027e310ebba8f7d96a98671","affectsGlobalScope":true},{"version":"8d697a2a929a5fcb38b7a65594020fcef05ec1630804a33748829c5ff53640d0","affectsGlobalScope":true},{"version":"0c20f4d2358eb679e4ae8a4432bdd96c857a2960fd6800b21ec4008ec59d60ea","affectsGlobalScope":true},{"version":"93495ff27b8746f55d19fcbcdbaccc99fd95f19d057aed1bd2c0cafe1335fbf0","affectsGlobalScope":true},{"version":"82d0d8e269b9eeac02c3bd1c9e884e85d483fcb2cd168bccd6bc54df663da031","affectsGlobalScope":true},{"version":"38f0219c9e23c915ef9790ab1d680440d95419ad264816fa15009a8851e79119","affectsGlobalScope":true},{"version":"b8deab98702588840be73d67f02412a2d45a417a3c097b2e96f7f3a42ac483d1","affectsGlobalScope":true},{"version":"4738f2420687fd85629c9efb470793bb753709c2379e5f85bc1815d875ceadcd","affectsGlobalScope":true},{"version":"2f11ff796926e0832f9ae148008138ad583bd181899ab7dd768a2666700b1893","affectsGlobalScope":true},{"version":"376d554d042fb409cb55b5cbaf0b2b4b7e669619493c5d18d5fa8bd67273f82a","affectsGlobalScope":true},{"version":"9fc46429fbe091ac5ad2608c657201eb68b6f1b8341bd6d670047d32ed0a88fa","affectsGlobalScope":true},{"version":"61c37c1de663cf4171e1192466e52c7a382afa58da01b1dc75058f032ddf0839","affectsGlobalScope":true},{"version":"c4138a3dd7cd6cf1f363ca0f905554e8d81b45844feea17786cdf1626cb8ea06","affectsGlobalScope":true},{"version":"6ff3e2452b055d8f0ec026511c6582b55d935675af67cdb67dd1dc671e8065df","affectsGlobalScope":true},{"version":"03de17b810f426a2f47396b0b99b53a82c1b60e9cba7a7edda47f9bb077882f4","affectsGlobalScope":true},{"version":"8184c6ddf48f0c98429326b428478ecc6143c27f79b79e85740f17e6feb090f1","affectsGlobalScope":true},{"version":"261c4d2cf86ac5a89ad3fb3fafed74cbb6f2f7c1d139b0540933df567d64a6ca","affectsGlobalScope":true},{"version":"6af1425e9973f4924fca986636ac19a0cf9909a7e0d9d3009c349e6244e957b6","affectsGlobalScope":true},{"version":"576711e016cf4f1804676043e6a0a5414252560eb57de9faceee34d79798c850","affectsGlobalScope":true},{"version":"89c1b1281ba7b8a96efc676b11b264de7a8374c5ea1e6617f11880a13fc56dc6","affectsGlobalScope":true},{"version":"15a630d6817718a2ddd7088c4f83e4673fde19fa992d2eae2cf51132a302a5d3","affectsGlobalScope":true},{"version":"b7e9f95a7387e3f66be0ed6db43600c49cec33a3900437ce2fd350d9b7cb16f2","affectsGlobalScope":true},{"version":"01e0ee7e1f661acedb08b51f8a9b7d7f959e9cdb6441360f06522cc3aea1bf2e","affectsGlobalScope":true},{"version":"ac17a97f816d53d9dd79b0d235e1c0ed54a8cc6a0677e9a3d61efb480b2a3e4e","affectsGlobalScope":true},{"version":"bf14a426dbbf1022d11bd08d6b8e709a2e9d246f0c6c1032f3b2edb9a902adbe","affectsGlobalScope":true},{"version":"ec0104fee478075cb5171e5f4e3f23add8e02d845ae0165bfa3f1099241fa2aa","affectsGlobalScope":true},{"version":"2b72d528b2e2fe3c57889ca7baef5e13a56c957b946906d03767c642f386bbc3","affectsGlobalScope":true},{"version":"9cc66b0513ad41cb5f5372cca86ef83a0d37d1c1017580b7dace3ea5661836df","affectsGlobalScope":true},{"version":"368af93f74c9c932edd84c58883e736c9e3d53cec1fe24c0b0ff451f529ceab1","affectsGlobalScope":true},{"version":"307c8b7ebbd7f23a92b73a4c6c0a697beca05b06b036c23a34553e5fe65e4fdc","affectsGlobalScope":true},{"version":"f35a831e4f0fe3b3697f4a0fe0e3caa7624c92b78afbecaf142c0f93abfaf379","affectsGlobalScope":true},{"version":"782dec38049b92d4e85c1585fbea5474a219c6984a35b004963b00beb1aab538","affectsGlobalScope":true},"994c234848afc14a2586b6565777f4c0b05dc479ede0a041bfd5becf6dceb586",{"version":"74a1b1b51145ec6b12aa832439549e5fb574f55cb02d1110083d58503ffa9ddc","signature":"d9e01bc3c8435835b8fccab53fa802278abee8442a81ecc7d467516d0fb8c3a3"},"516a41dd4880e7d32b10f7fa8fdfe3adf54a1e592aba3ee153c5512381ff6133",{"version":"57eaacc58f9b4bb35309912a825b3e29dd7ee179011cf97915bfb32d2eb5ae4b","signature":"fe7a0a744b32b5ece036d9964d9f13bbd49b41f1acb88ec52581855e05fb81f0"},"09df3b4f1c937f02e7fee2836d4c4d7a63e66db70fd4d4e97126f4542cc21d9d","7394959e5a741b185456e1ef5d64599c36c60a323207450991e7a42e08911419","818f832a8e29ca7e128dcde810a9ff8cbc3754010474e29fff0a5ed95adae032","5929864ce17fba74232584d90cb721a89b7ad277220627cc97054ba15a98ea8f","7180c03fd3cb6e22f911ce9ba0f8a7008b1a6ddbe88ccf16a9c8140ef9ac1686","25c8056edf4314820382a5fdb4bb7816999acdcb929c8f75e3f39473b87e85bc","54cb85a47d760da1c13c00add10d26b5118280d44d58e6908d8e89abbd9d7725","3e4825171442666d31c845aeb47fcd34b62e14041bb353ae2b874285d78482aa","adda9e3915c6bf15e360356a41d950881a51dbe44f9a6088155836b040820663","b4855526ac5a822d6e0005e4b62ee49c599bf89897e4109135283d660e60291c","e9775e97ac4877aebf963a0289c81abe76d1ec9a2a7778dbe637e5151f25c5f3","471e1da5a78350bc55ef8cef24eb3aca6174143c281b8b214ca2beda51f5e04a","cadc8aced301244057c4e7e73fbcae534b0f5b12a37b150d80e5a45aa4bebcbd","385aab901643aa54e1c36f5ef3107913b10d1b5bb8cbcd933d4263b80a0d7f20","9670d44354bab9d9982eca21945686b5c24a3f893db73c0dae0fd74217a4c219","db3435f3525cd785bf21ec6769bf8da7e8a776be1a99e2e7efb5f244a2ef5fee","c3b170c45fc031db31f782e612adf7314b167e60439d304b49e704010e7bafe5","40383ebef22b943d503c6ce2cb2e060282936b952a01bea5f9f493d5fb487cc7","80ad053918e96087d9da8d092ff9f90520c9fc199c8bfd9340266dd8f38f364e","3a84b7cb891141824bd00ef8a50b6a44596aded4075da937f180c90e362fe5f6","13f6f39e12b1518c6650bbb220c8985999020fe0f21d818e28f512b7771d00f9","9b5369969f6e7175740bf51223112ff209f94ba43ecd3bb09eefff9fd675624a","4fe9e626e7164748e8769bbf74b538e09607f07ed17c2f20af8d680ee49fc1da","24515859bc0b836719105bb6cc3d68255042a9f02a6022b3187948b204946bd2","33203609eba548914dc83ddf6cadbc0bcb6e8ef89f6d648ca0908ae887f9fcc5","0db18c6e78ea846316c012478888f33c11ffadab9efd1cc8bcc12daded7a60b6","89167d696a849fce5ca508032aabfe901c0868f833a8625d5a9c6e861ef935d2","e53a3c2a9f624d90f24bf4588aacd223e7bec1b9d0d479b68d2f4a9e6011147f","339dc5265ee5ed92e536a93a04c4ebbc2128f45eeec6ed29f379e0085283542c","9f0a92164925aa37d4a5d9dd3e0134cff8177208dba55fd2310cd74beea40ee2","8bfdb79bf1a9d435ec48d9372dc93291161f152c0865b81fc0b2694aedb4578d","2e85db9e6fd73cfa3d7f28e0ab6b55417ea18931423bd47b409a96e4a169e8e6","c46e079fe54c76f95c67fb89081b3e399da2c7d109e7dca8e4b58d83e332e605","d32275be3546f252e3ad33976caf8c5e842c09cb87d468cb40d5f4cf092d1acc","d70119390aece1794bf4988f10ea750d13455f5286977d35027d43dd2e9841cf",{"version":"4d719cfab49ae4045d15cb6bed0f38ad3d7d6eb7f277d2603502a0f862ca3182","affectsGlobalScope":true},"cce1f5f86974c1e916ec4a8cab6eec9aa8e31e8148845bf07fbaa8e1d97b1a2c",{"version":"5a856afb15f9dc9983faa391dde989826995a33983c1cccb173e9606688e9709","affectsGlobalScope":true},"546ab07e19116d935ad982e76a223275b53bff7771dab94f433b7ab04652936e","7b43160a49cf2c6082da0465876c4a0b164e160b81187caeb0a6ca7a281e85ba",{"version":"aefb5a4a209f756b580eb53ea771cca8aad411603926f307a5e5b8ec6b16dcf6","affectsGlobalScope":true},"a40826e8476694e90da94aa008283a7de50d1dafd37beada623863f1901cb7fb","f5a8b7ec4b798c88679194a8ebc25dcb6f5368e6e5811fcda9fe12b0d445b8db","b86e1a45b29437f3a99bad4147cb9fe2357617e8008c0484568e5bb5138d6e13","b5b719a47968cd61a6f83f437236bb6fe22a39223b6620da81ef89f5d7a78fb7","42c431e7965b641106b5e25ab3283aa4865ca7bb9909610a2abfa6226e4348be","0b7e732af0a9599be28c091d6bd1cb22c856ec0d415d4749c087c3881ca07a56","b7fe70be794e13d1b7940e318b8770cd1fb3eced7707805318a2e3aaac2c3e9e",{"version":"2c71199d1fc83bf17636ad5bf63a945633406b7b94887612bba4ef027c662b3e","affectsGlobalScope":true},{"version":"8d6138a264ddc6f94f16e99d4e117a2d6eb31b217891cf091b6437a2f114d561","affectsGlobalScope":true},"3b4c85eea12187de9929a76792b98406e8778ce575caca8c574f06da82622c54","f788131a39c81e0c9b9e463645dd7132b5bc1beb609b0e31e5c1ceaea378b4df","0c236069ce7bded4f6774946e928e4b3601894d294054af47a553f7abcafe2c1","21894466693f64957b9bd4c80fa3ec7fdfd4efa9d1861e070aca23f10220c9b2","396a8939b5e177542bdf9b5262b4eee85d29851b2d57681fa9d7eae30e225830","21773f5ac69ddf5a05636ba1f50b5239f4f2d27e4420db147fc2f76a5ae598ac",{"version":"6ec93c745c5e3e25e278fa35451bf18ef857f733de7e57c15e7920ac463baa2a","affectsGlobalScope":true},"91f8b5abcdff8f9ecb9656b9852878718416fb7700b2c4fad8331e5b97c080bb","30c2ec6abf6aaa60eb4f32fb1235531506b7961c6d1bdc7430711aec8fd85295","0f05c06ff6196958d76b865ae17245b52d8fe01773626ac3c43214a2458ea7b7",{"version":"308b84e1943ef30015469770e931eb21b795348893b2a6562ca54ea8f0b3c41c","affectsGlobalScope":true},{"version":"d48009cbe8a30a504031cc82e1286f78fed33b7a42abf7602c23b5547b382563","affectsGlobalScope":true},"7aaeb5e62f90e1b2be0fc4844df78cdb1be15c22b427bc6c39d57308785b8f10","3ba30205a029ebc0c91d7b1ab4da73f6277d730ca1fc6692d5a9144c6772c76b","d8dba11dc34d50cb4202de5effa9a1b296d7a2f4a029eec871f894bddfb6430d","8b71dd18e7e63b6f991b511a201fad7c3bf8d1e0dd98acb5e3d844f335a73634","01d8e1419c84affad359cc240b2b551fb9812b450b4d3d456b64cda8102d4f60","458b216959c231df388a5de9dcbcafd4b4ca563bc3784d706d0455467d7d4942","269929a24b2816343a178008ac9ae9248304d92a8ba8e233055e0ed6dbe6ef71","93452d394fdd1dc551ec62f5042366f011a00d342d36d50793b3529bfc9bd633","f8c87b19eae111f8720b0345ab301af8d81add39621b63614dfc2d15fd6f140a","831c22d257717bf2cbb03afe9c4bcffc5ccb8a2074344d4238bf16d3a857bb12",{"version":"24ba151e213906027e2b1f5223d33575a3612b0234a0e2b56119520bbe0e594b","affectsGlobalScope":true},{"version":"cbf046714f3a3ba2544957e1973ac94aa819fa8aa668846fa8de47eb1c41b0b2","affectsGlobalScope":true},"aa34c3aa493d1c699601027c441b9664547c3024f9dbab1639df7701d63d18fa","eae74e3d50820f37c72c0679fed959cd1e63c98f6a146a55b8c4361582fa6a52","7c651f8dce91a927ab62925e73f190763574c46098f2b11fb8ddc1b147a6709a","7440ab60f4cb031812940cc38166b8bb6fbf2540cfe599f87c41c08011f0c1df",{"version":"aed89e3c18f4c659ee8153a76560dffda23e2d801e1e60d7a67abd84bc555f8d","affectsGlobalScope":true},{"version":"0ed13c80faeb2b7160bffb4926ff299c468e67a37a645b3ae0917ba0db633c1b","affectsGlobalScope":true},"e393915d3dc385e69c0e2390739c87b2d296a610662eb0b1cb85224e55992250","2f940651c2f30e6b29f8743fae3f40b7b1c03615184f837132b56ea75edad08b","5749c327c3f789f658072f8340786966c8b05ea124a56c1d8d60e04649495a4d",{"version":"c9d62b2a51b2ff166314d8be84f6881a7fcbccd37612442cf1c70d27d5352f50","affectsGlobalScope":true},"e7dbf5716d76846c7522e910896c5747b6df1abd538fee8f5291bdc843461795",{"version":"ab9b9a36e5284fd8d3bf2f7d5fcbc60052f25f27e4d20954782099282c60d23e","affectsGlobalScope":true},"b510d0a18e3db42ac9765d26711083ec1e8b4e21caaca6dc4d25ae6e8623f447","5e379df3d61561c2ed7789b5995b9ba2143bbba21a905e2381e16efe7d1fa424","5063340a1e00ad01370d3651bf17d08b1211b0999482c2b0682dc75724c4bbca",{"version":"a304eeb4af7da6e42add80ea0d05a26f18381a77425d4ab64c68d67a4a163e4a","signature":"d362c467594726a6b77d3b909cb03461910dfd1349eb120d7bc7ea2db527029c"},{"version":"3eb4cce2212bf15c8768a6348d79703526a9aa5b99130eebb3be0582fcde07dc","signature":"3a13aedc5a44d78bdd15f91086224ecd20aef159b5911fc0dfa87b561fee301c"},{"version":"78e1ea2cf544a7fed421464517cf18f26faf02f129fda929a0bd7d17261d9d6b","signature":"f7e5c2d8eab74862142be9976d1ea8bd9e41f5b159db0c29ef2fb021643af89f"},{"version":"77bc6034b2354d71fef5d4525d99f9dde4c8d54669cfeaaa71488c256ca5671e","signature":"fab1462b8f80ab59f8a819561c73d0a628be020b6eef0290459733ad2df48083"},{"version":"7c0afb97be886c87df27bd34f3953262f6ceb27d5ffeebad44b52eceb6c56c88","signature":"601f6fdb2ac7a40b1992f1ca626cfa9e25cd9346b07faae53e86852a57ef9c92"},{"version":"ea2bc8b49612a14dcd4cb6f0c4c426dc6134dbca946eeb228b842a9b44495b01","signature":"2fc124af69825e5fe5493144975ade76595c02b625807f080e6aebb89a3ed8aa"},"69fad132b41289d40e3d373ad0ef1065cbae26c78f11d2f1aa574a3eb9b7cb7e","6e38c29a10b721dd13135e12b36cb6ddf7235184309a4ca2ca55840ff788e801","205829fd4cf42685af09c55f45ba58fa5a58072befadb63d5f4700382a596857",{"version":"859a6800868d032d5d22f16490c60308d36ffb71342e429b1e526bf681df5161","signature":"3fa6f0bf95bc927ca8b131232aa7efbf0cad0a8009ca0f7a8771375b45dc7868"},{"version":"67e6236911082a4ca2b128942c082f7b7b856f7dbbaed6526a5977e427d89ed2","signature":"b390116b99d4511f668e82188377a80bd6866e925517b22a5336ece35117a14c"},{"version":"1a731e747e0591a729641ff3d295e7fe30e8318e3d0a34c24d6e2b3bbae46c5d","signature":"531fe22704e1df7d98d548c37cce7e112171763d210cbfd6bb57164f07a63b5c"},{"version":"5c36aae8b9ec0cf77e61ff6e837c9889af413ff3106969c1f5351b87dee86ff2","signature":"68e517185e7057ed4b04d1e5f6304d2b7277fd3f2ee663dfd3fd5c829a429913"},"5562230b6ae4f2205fddf46ab28518d4b0a5727c1e04d4f568c76d0271ae3293",{"version":"150d1d4f4a0b4c6df9f2912b6c02534c49a62a3df6aa8fb2f149813caf11043e","signature":"f5958982fb8d178282ae264d74bcd3a3253a2680f1ed9d61ab808d59a931b0cc"},{"version":"5382609f2f43d9fc33730bc9225795abbad815a80e2a6c153e303a5c49dea45f","signature":"f4887ca9bcb350d8a9114e854ddc281c53f17034539b6ebb2690b7c7af6fde6f"},{"version":"dca75a24fea525c9af400001408947306b4dbdc72e1059845e77d886428b734d","signature":"1aa4ababe2598a733d1ce94cca92bae9c43da13413046eb455dcc10fbf959414"},{"version":"eee09c0481f69d5011d065ab9f8465408939b4a03acf0312e9df283066b42016","signature":"4b7cfe5da2cd52781aed3942adbc0b467c2549a220b45078a4df664982c62839"},{"version":"d335e4ed3057ce819c785ab13141f7817895a6ab5902b42a8eb22294b93b4ca4","signature":"0e52db4b6080295052bd4f6224a7563d5f86b134e0e3e6e0da60f79181c64f7e"},{"version":"1b265a58e07603f9de7385bb250566bc395cc6260f767cf9fbe7f508ec5b59d8","signature":"b69eba6664b53e2c965e4b504bf06f2d752b099f85122f6e45cd2f18fb23dbc9"},{"version":"05625025a45feda496e63076351d8621f7eeb709c585da1f61435b53b2dc356f","signature":"65a9f45dd5303d2ac9cd544e648d10e63df21adbdf0b63d1941e478ea50ddd45"},{"version":"029118852bebe63c6fd380e34e0855d4f356efdee346b4337acf54daeb4ff571","signature":"65a9f45dd5303d2ac9cd544e648d10e63df21adbdf0b63d1941e478ea50ddd45"},{"version":"d1594aae5064c6116c4ebd8091f122d9de1331eed4f5a2a4be892b54435dcfeb","signature":"43e818adf60173644896298637f47b01d5819b17eda46eaa32d0c7d64724d012"},"f6e4d465828539e051c5c1a40ee835fd954ce5cfc45de8e31ac1561bad5d947b",{"version":"6e8b204e701e028ec34bc44a7f8b9ec74bf7a3fab311e433938725e181c9a351","signature":"131f74ecc6f4866c4d5fae52c5ff2fb850d3240d9323b50dc1665910bccab607"},{"version":"99d3f6029327600c72ad8d3261096a5f4f5e3cb481732f411e4389213ecbed45","signature":"131f74ecc6f4866c4d5fae52c5ff2fb850d3240d9323b50dc1665910bccab607"},{"version":"b0d4a12e33ba9c4edc7ad162b1c35f221d4c47c2a1526c2c11f776b6f0494ff8","signature":"131f74ecc6f4866c4d5fae52c5ff2fb850d3240d9323b50dc1665910bccab607"},{"version":"90e6d52946500ea640bad362c7fc01b8802a28ce4bdf49e419ad0eb412b23a81","signature":"1c1fff0ed17bd032eea18bac39ff67036d1cded872deef808b52ba2dac839d69"},{"version":"d9b8c27fb5b1874fa2316d8a28f9df346688787ed40d15c28e93407c5737e2cc","signature":"131f74ecc6f4866c4d5fae52c5ff2fb850d3240d9323b50dc1665910bccab607"}],"root":[50,52,[142,147],[151,154],[156,164],[166,170]],"options":{"allowSyntheticDefaultImports":true,"declaration":true,"emitDecoratorMetadata":true,"esModuleInterop":true,"experimentalDecorators":true,"module":1,"outDir":"./","removeComments":true,"skipLibCheck":true,"sourceMap":true,"target":4},"fileIdsList":[[120,132,139],[53,132],[89,132],[90,95,123,132],[91,102,103,110,120,131,132],[91,92,102,110,132],[93,132],[94,95,103,111,132],[95,120,128,132],[96,98,102,110,132],[97,132],[98,99,132],[102,132],[100,102,132],[89,102,132],[102,103,104,120,131,132],[102,103,104,117,120,123,132],[87,132,136],[132],[98,102,105,110,120,131,132],[102,103,105,106,110,120,128,131,132],[105,107,120,128,131,132],[53,54,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138],[102,108,132],[109,131,132,136],[98,102,110,120,132],[111,132],[112,132],[89,113,132],[114,130,132,136],[115,132],[116,132],[102,117,118,132],[117,119,132,134],[90,102,120,121,122,123,132],[90,120,122,132],[120,121,132],[123,132],[124,132],[89,120,132],[102,126,127,132],[126,127,132],[95,110,120,128,132],[129,132],[110,130,132],[90,105,116,131,132],[95,132],[120,132,133],[109,132,134],[132,135],[90,95,102,104,113,120,131,132,134,136],[120,132,137],[132,139,140],[102,105,107,120,128,131,132,137,139],[132,149],[64,68,131,132],[64,120,131,132],[59,132],[61,64,128,131,132],[110,128,132],[132,139],[59,132,139],[61,64,110,131,132],[56,57,60,63,90,102,120,131,132],[56,62,132],[60,64,90,123,131,132,139],[90,132,139],[80,90,132,139],[58,59,132,139],[64,132],[58,59,60,61,62,63,64,65,66,68,69,70,71,72,73,74,75,76,77,78,79,81,82,83,84,85,86,132],[64,71,72,132],[62,64,72,73,132],[63,132],[56,59,64,132],[64,68,72,73,132],[68,132],[62,64,67,131,132],[56,61,62,64,68,71,132],[90,120,132],[59,64,80,90,132,136,139],[112,132,162,163],[103,112,120,132,141,157,161],[103,112,132,157,161],[102,132,143],[50,51,52,105,132,141,142,143,144,151,154,155,156],[90,132,141,143,157,165],[131,132,143,157,159],[110,132,141,143],[110,128,132,143],[90,132,141,143,155,157,159,165],[132,143],[51,132,143,146],[51,132,143,146,151],[132,143,145,146,147,152,153],[51,132,143],[51,120,132,157],[51,132,141,143],[132,148,150],[52,132,150],[52,132,143,144,146,157,158,160],[51,52,105,141,143,144,155,156],[143],[157],[51,120,157],[51,141,143],[52],[52,143,144,146,157,158,160]],"referencedMap":[[165,1],[53,2],[54,2],[89,3],[90,4],[91,5],[92,6],[93,7],[94,8],[95,9],[96,10],[97,11],[98,12],[99,12],[101,13],[100,14],[102,15],[103,16],[104,17],[88,18],[138,19],[105,20],[106,21],[107,22],[139,23],[108,24],[109,25],[110,26],[111,27],[112,28],[113,29],[114,30],[115,31],[116,32],[117,33],[118,33],[119,34],[120,35],[122,36],[121,37],[123,38],[124,39],[125,40],[126,41],[127,42],[128,43],[129,44],[130,45],[131,46],[132,47],[133,48],[134,49],[135,50],[136,51],[137,52],[141,53],[140,19],[155,54],[55,19],[148,19],[51,19],[150,55],[149,19],[47,19],[48,19],[8,19],[9,19],[13,19],[12,19],[2,19],[14,19],[15,19],[16,19],[17,19],[18,19],[19,19],[20,19],[21,19],[3,19],[4,19],[22,19],[49,19],[26,19],[23,19],[24,19],[25,19],[27,19],[28,19],[29,19],[5,19],[30,19],[31,19],[32,19],[33,19],[6,19],[37,19],[34,19],[35,19],[36,19],[38,19],[7,19],[39,19],[44,19],[45,19],[40,19],[41,19],[42,19],[43,19],[1,19],[46,19],[11,19],[10,19],[71,56],[78,57],[70,56],[85,58],[62,59],[61,60],[84,61],[79,62],[82,63],[64,64],[63,65],[59,66],[58,67],[81,68],[60,69],[65,70],[66,19],[69,70],[56,19],[87,71],[86,70],[73,72],[74,73],[76,74],[72,75],[75,76],[80,61],[67,77],[68,78],[77,79],[57,80],[83,81],[164,82],[162,83],[163,84],[156,85],[157,86],[166,87],[160,88],[167,89],[168,90],[169,91],[170,87],[52,19],[146,92],[147,93],[152,94],[154,95],[145,96],[153,96],[159,19],[143,97],[144,98],[50,19],[151,99],[158,100],[142,19],[161,101]],"exportedModulesMap":[[165,1],[53,2],[54,2],[89,3],[90,4],[91,5],[92,6],[93,7],[94,8],[95,9],[96,10],[97,11],[98,12],[99,12],[101,13],[100,14],[102,15],[103,16],[104,17],[88,18],[138,19],[105,20],[106,21],[107,22],[139,23],[108,24],[109,25],[110,26],[111,27],[112,28],[113,29],[114,30],[115,31],[116,32],[117,33],[118,33],[119,34],[120,35],[122,36],[121,37],[123,38],[124,39],[125,40],[126,41],[127,42],[128,43],[129,44],[130,45],[131,46],[132,47],[133,48],[134,49],[135,50],[136,51],[137,52],[141,53],[140,19],[155,54],[55,19],[148,19],[51,19],[150,55],[149,19],[47,19],[48,19],[8,19],[9,19],[13,19],[12,19],[2,19],[14,19],[15,19],[16,19],[17,19],[18,19],[19,19],[20,19],[21,19],[3,19],[4,19],[22,19],[49,19],[26,19],[23,19],[24,19],[25,19],[27,19],[28,19],[29,19],[5,19],[30,19],[31,19],[32,19],[33,19],[6,19],[37,19],[34,19],[35,19],[36,19],[38,19],[7,19],[39,19],[44,19],[45,19],[40,19],[41,19],[42,19],[43,19],[1,19],[46,19],[11,19],[10,19],[71,56],[78,57],[70,56],[85,58],[62,59],[61,60],[84,61],[79,62],[82,63],[64,64],[63,65],[59,66],[58,67],[81,68],[60,69],[65,70],[66,19],[69,70],[56,19],[87,71],[86,70],[73,72],[74,73],[76,74],[72,75],[75,76],[80,61],[67,77],[68,78],[77,79],[57,80],[83,81],[157,102],[166,103],[160,104],[167,103],[168,103],[169,103],[170,103],[146,103],[147,103],[152,103],[154,103],[145,103],[153,103],[143,105],[144,106],[158,107],[161,108]],"semanticDiagnosticsPerFile":[165,53,54,89,90,91,92,93,94,95,96,97,98,99,101,100,102,103,104,88,138,105,106,107,139,108,109,110,111,112,113,114,115,116,117,118,119,120,122,121,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,141,140,155,55,148,51,150,149,47,48,8,9,13,12,2,14,15,16,17,18,19,20,21,3,4,22,49,26,23,24,25,27,28,29,5,30,31,32,33,6,37,34,35,36,38,7,39,44,45,40,41,42,43,1,46,11,10,71,78,70,85,62,61,84,79,82,64,63,59,58,81,60,65,66,69,56,87,86,73,74,76,72,75,80,67,68,77,57,83,164,162,163,156,157,166,160,167,168,169,170,52,146,147,152,154,145,153,159,143,144,50,151,158,142,161]},"version":"5.2.2"}# MQTT.js is an OPEN Open Source Project

-----------------------------------------

## What?

Individuals making significant and valuable contributions are given commit-access to the project to contribute as they see fit. This project is more like an open wiki than a standard guarded open source project.

## Rules

There are a few basic ground-rules for contributors:

1. **No `--force` pushes** or modifying the Git history in any way.
1. **Non-main branches** ought to be used for ongoing work.
1. **External API changes and significant modifications** ought to be subject to an **internal pull-request** to solicit feedback from other contributors.
1. Internal pull-requests to solicit feedback are *encouraged* for any other non-trivial contribution but left to the discretion of the contributor.
1. Contributors should attempt to adhere to the prevailing code-style.

## Releases

Declaring formal releases remains the prerogative of the project maintainer.

## Changes to this arrangement

This is an experiment and feedback is welcome! This document may also be subject to pull-requests or changes by contributors where you believe you have something valuable to add or change.

-----------------------------------------
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.mqtt = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypedEventEmitter = void 0;
const events_1 = __importDefault(require("events"));
const shared_1 = require("./shared");
class TypedEventEmitter {
}
exports.TypedEventEmitter = TypedEventEmitter;
(0, shared_1.applyMixin)(TypedEventEmitter, events_1.default);

},{"./shared":17,"events":49}],2:[function(require,module,exports){
(function (process,global){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const topic_alias_recv_1 = __importDefault(require("./topic-alias-recv"));
const mqtt_packet_1 = __importDefault(require("mqtt-packet"));
const default_message_id_provider_1 = __importDefault(require("./default-message-id-provider"));
const readable_stream_1 = require("readable-stream");
const reinterval_1 = __importDefault(require("reinterval"));
const default_1 = __importDefault(require("rfdc/default"));
const validations = __importStar(require("./validations"));
const debug_1 = __importDefault(require("debug"));
const store_1 = __importDefault(require("./store"));
const handlers_1 = __importDefault(require("./handlers"));
const TypedEmitter_1 = require("./TypedEmitter");
const nextTick = process
    ? process.nextTick
    : (callback) => {
        setTimeout(callback, 0);
    };
const setImmediate = global.setImmediate ||
    ((...args) => {
        const callback = args.shift();
        nextTick(() => {
            callback(...args);
        });
    });
const defaultConnectOptions = {
    keepalive: 60,
    reschedulePings: true,
    protocolId: 'MQTT',
    protocolVersion: 4,
    reconnectPeriod: 1000,
    connectTimeout: 30 * 1000,
    clean: true,
    resubscribe: true,
    writeCache: true,
};
const socketErrors = [
    'ECONNREFUSED',
    'EADDRINUSE',
    'ECONNRESET',
    'ENOTFOUND',
    'ETIMEDOUT',
];
class MqttClient extends TypedEmitter_1.TypedEventEmitter {
    static defaultId() {
        return `mqttjs_${Math.random().toString(16).substr(2, 8)}`;
    }
    constructor(streamBuilder, options) {
        super();
        this.options = options || {};
        for (const k in defaultConnectOptions) {
            if (typeof this.options[k] === 'undefined') {
                this.options[k] = defaultConnectOptions[k];
            }
            else {
                this.options[k] = options[k];
            }
        }
        this.log = this.options.log || (0, debug_1.default)('mqttjs:client');
        this.noop = this._noop.bind(this);
        this.log('MqttClient :: options.protocol', options.protocol);
        this.log('MqttClient :: options.protocolVersion', options.protocolVersion);
        this.log('MqttClient :: options.username', options.username);
        this.log('MqttClient :: options.keepalive', options.keepalive);
        this.log('MqttClient :: options.reconnectPeriod', options.reconnectPeriod);
        this.log('MqttClient :: options.rejectUnauthorized', options.rejectUnauthorized);
        this.log('MqttClient :: options.properties.topicAliasMaximum', options.properties
            ? options.properties.topicAliasMaximum
            : undefined);
        this.options.clientId =
            typeof options.clientId === 'string'
                ? options.clientId
                : MqttClient.defaultId();
        this.log('MqttClient :: clientId', this.options.clientId);
        this.options.customHandleAcks =
            options.protocolVersion === 5 && options.customHandleAcks
                ? options.customHandleAcks
                : (...args) => {
                    args[3](null, 0);
                };
        if (!this.options.writeCache) {
            mqtt_packet_1.default.writeToStream.cacheNumbers = false;
        }
        this.streamBuilder = streamBuilder;
        this.messageIdProvider =
            typeof this.options.messageIdProvider === 'undefined'
                ? new default_message_id_provider_1.default()
                : this.options.messageIdProvider;
        this.outgoingStore = options.outgoingStore || new store_1.default();
        this.incomingStore = options.incomingStore || new store_1.default();
        this.queueQoSZero =
            options.queueQoSZero === undefined ? true : options.queueQoSZero;
        this._resubscribeTopics = {};
        this.messageIdToTopic = {};
        this.pingTimer = null;
        this.connected = false;
        this.disconnecting = false;
        this.reconnecting = false;
        this.queue = [];
        this.connackTimer = null;
        this.reconnectTimer = null;
        this._storeProcessing = false;
        this._packetIdsDuringStoreProcessing = {};
        this._storeProcessingQueue = [];
        this.outgoing = {};
        this._firstConnection = true;
        if (options.properties && options.properties.topicAliasMaximum > 0) {
            if (options.properties.topicAliasMaximum > 0xffff) {
                this.log('MqttClient :: options.properties.topicAliasMaximum is out of range');
            }
            else {
                this.topicAliasRecv = new topic_alias_recv_1.default(options.properties.topicAliasMaximum);
            }
        }
        this.on('connect', () => {
            const { queue } = this;
            const deliver = () => {
                const entry = queue.shift();
                this.log('deliver :: entry %o', entry);
                let packet = null;
                if (!entry) {
                    this._resubscribe();
                    return;
                }
                packet = entry.packet;
                this.log('deliver :: call _sendPacket for %o', packet);
                let send = true;
                if (packet.messageId && packet.messageId !== 0) {
                    if (!this.messageIdProvider.register(packet.messageId)) {
                        send = false;
                    }
                }
                if (send) {
                    this._sendPacket(packet, (err) => {
                        if (entry.cb) {
                            entry.cb(err);
                        }
                        deliver();
                    });
                }
                else {
                    this.log('messageId: %d has already used. The message is skipped and removed.', packet.messageId);
                    deliver();
                }
            };
            this.log('connect :: sending queued packets');
            deliver();
        });
        this.on('close', () => {
            this.log('close :: connected set to `false`');
            this.connected = false;
            this.log('close :: clearing connackTimer');
            clearTimeout(this.connackTimer);
            this.log('close :: clearing ping timer');
            if (this.pingTimer !== null) {
                this.pingTimer.clear();
                this.pingTimer = null;
            }
            if (this.topicAliasRecv) {
                this.topicAliasRecv.clear();
            }
            this.log('close :: calling _setupReconnect');
            this._setupReconnect();
        });
        if (!this.options.manualConnect) {
            this.log('MqttClient :: setting up stream');
            this.connect();
        }
    }
    handleAuth(packet, callback) {
        callback();
    }
    handleMessage(packet, callback) {
        callback();
    }
    _nextId() {
        return this.messageIdProvider.allocate();
    }
    getLastMessageId() {
        return this.messageIdProvider.getLastAllocated();
    }
    connect() {
        var _a;
        const writable = new readable_stream_1.Writable();
        const parser = mqtt_packet_1.default.parser(this.options);
        let completeParse = null;
        const packets = [];
        this.log('connect :: calling method to clear reconnect');
        this._clearReconnect();
        this.log('connect :: using streamBuilder provided to client to create stream');
        this.stream = this.streamBuilder(this);
        parser.on('packet', (packet) => {
            this.log('parser :: on packet push to packets array.');
            packets.push(packet);
        });
        const work = () => {
            this.log('work :: getting next packet in queue');
            const packet = packets.shift();
            if (packet) {
                this.log('work :: packet pulled from queue');
                (0, handlers_1.default)(this, packet, nextTickWork);
            }
            else {
                this.log('work :: no packets in queue');
                const done = completeParse;
                completeParse = null;
                this.log('work :: done flag is %s', !!done);
                if (done)
                    done();
            }
        };
        const nextTickWork = () => {
            if (packets.length) {
                nextTick(work);
            }
            else {
                const done = completeParse;
                completeParse = null;
                done();
            }
        };
        writable._write = (buf, enc, done) => {
            completeParse = done;
            this.log('writable stream :: parsing buffer');
            parser.parse(buf);
            work();
        };
        const streamErrorHandler = (error) => {
            this.log('streamErrorHandler :: error', error.message);
            if (socketErrors.includes(error.code)) {
                this.log('streamErrorHandler :: emitting error');
                this.emit('error', error);
            }
            else {
                this.noop(error);
            }
        };
        this.log('connect :: pipe stream to writable stream');
        this.stream.pipe(writable);
        this.stream.on('error', streamErrorHandler);
        this.stream.on('close', () => {
            this.log('(%s)stream :: on close', this.options.clientId);
            this._flushVolatile();
            this.log('stream: emit close to MqttClient');
            this.emit('close');
        });
        this.log('connect: sending packet `connect`');
        const connectPacket = {
            cmd: 'connect',
            protocolId: this.options.protocolId,
            protocolVersion: this.options.protocolVersion,
            clean: this.options.clean,
            clientId: this.options.clientId,
            keepalive: this.options.keepalive,
            username: this.options.username,
            password: this.options.password,
            properties: this.options.properties,
        };
        if (this.options.will) {
            connectPacket.will = Object.assign(Object.assign({}, this.options.will), { payload: (_a = this.options.will) === null || _a === void 0 ? void 0 : _a.payload });
        }
        if (this.topicAliasRecv) {
            if (!connectPacket.properties) {
                connectPacket.properties = {};
            }
            if (this.topicAliasRecv) {
                connectPacket.properties.topicAliasMaximum =
                    this.topicAliasRecv.max;
            }
        }
        this._writePacket(connectPacket);
        parser.on('error', this.emit.bind(this, 'error'));
        if (this.options.properties) {
            if (!this.options.properties.authenticationMethod &&
                this.options.properties.authenticationData) {
                this.end(() => this.emit('error', new Error('Packet has no Authentication Method')));
                return this;
            }
            if (this.options.properties.authenticationMethod &&
                this.options.authPacket &&
                typeof this.options.authPacket === 'object') {
                const authPacket = Object.assign({ cmd: 'auth', reasonCode: 0 }, this.options.authPacket);
                this._writePacket(authPacket);
            }
        }
        this.stream.setMaxListeners(1000);
        clearTimeout(this.connackTimer);
        this.connackTimer = setTimeout(() => {
            this.log('!!connectTimeout hit!! Calling _cleanUp with force `true`');
            this._cleanUp(true);
        }, this.options.connectTimeout);
        return this;
    }
    publish(topic, message, opts, callback) {
        this.log('publish :: message `%s` to topic `%s`', message, topic);
        const { options } = this;
        if (typeof opts === 'function') {
            callback = opts;
            opts = null;
        }
        opts = opts || {};
        const defaultOpts = {
            qos: 0,
            retain: false,
            dup: false,
        };
        opts = Object.assign(Object.assign({}, defaultOpts), opts);
        const { qos, retain, dup, properties, cbStorePut } = opts;
        if (this._checkDisconnecting(callback)) {
            return this;
        }
        const publishProc = () => {
            let messageId = 0;
            if (qos === 1 || qos === 2) {
                messageId = this._nextId();
                if (messageId === null) {
                    this.log('No messageId left');
                    return false;
                }
            }
            const packet = {
                cmd: 'publish',
                topic,
                payload: message,
                qos,
                retain,
                messageId,
                dup,
            };
            if (options.protocolVersion === 5) {
                packet.properties = properties;
            }
            this.log('publish :: qos', qos);
            switch (qos) {
                case 1:
                case 2:
                    this.outgoing[packet.messageId] = {
                        volatile: false,
                        cb: callback || this.noop,
                    };
                    this.log('MqttClient:publish: packet cmd: %s', packet.cmd);
                    this._sendPacket(packet, undefined, cbStorePut);
                    break;
                default:
                    this.log('MqttClient:publish: packet cmd: %s', packet.cmd);
                    this._sendPacket(packet, callback, cbStorePut);
                    break;
            }
            return true;
        };
        if (this._storeProcessing ||
            this._storeProcessingQueue.length > 0 ||
            !publishProc()) {
            this._storeProcessingQueue.push({
                invoke: publishProc,
                cbStorePut: opts.cbStorePut,
                callback,
            });
        }
        return this;
    }
    publishAsync(topic, message, opts) {
        return new Promise((resolve, reject) => {
            this.publish(topic, message, opts, (err, packet) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(packet);
                }
            });
        });
    }
    subscribe(topicObject, opts, callback) {
        const version = this.options.protocolVersion;
        if (typeof opts === 'function') {
            callback = opts;
        }
        callback = callback || this.noop;
        let resubscribe = false;
        let topicsList = [];
        if (typeof topicObject === 'string') {
            topicObject = [topicObject];
            topicsList = topicObject;
        }
        else if (Array.isArray(topicObject)) {
            topicsList = topicObject;
        }
        else if (typeof topicObject === 'object') {
            resubscribe = topicObject.resubscribe;
            delete topicObject.resubscribe;
            topicsList = Object.keys(topicObject);
        }
        const invalidTopic = validations.validateTopics(topicsList);
        if (invalidTopic !== null) {
            setImmediate(callback, new Error(`Invalid topic ${invalidTopic}`));
            return this;
        }
        if (this._checkDisconnecting(callback)) {
            this.log('subscribe: discconecting true');
            return this;
        }
        const defaultOpts = {
            qos: 0,
        };
        if (version === 5) {
            defaultOpts.nl = false;
            defaultOpts.rap = false;
            defaultOpts.rh = 0;
        }
        opts = Object.assign(Object.assign({}, defaultOpts), opts);
        const properties = opts.properties;
        const subs = [];
        const parseSub = (topic, subOptions) => {
            subOptions = (subOptions || opts);
            if (!Object.prototype.hasOwnProperty.call(this._resubscribeTopics, topic) ||
                this._resubscribeTopics[topic].qos < subOptions.qos ||
                resubscribe) {
                const currentOpts = {
                    topic,
                    qos: subOptions.qos,
                };
                if (version === 5) {
                    currentOpts.nl = subOptions.nl;
                    currentOpts.rap = subOptions.rap;
                    currentOpts.rh = subOptions.rh;
                    currentOpts.properties = properties;
                }
                this.log('subscribe: pushing topic `%s` and qos `%s` to subs list', currentOpts.topic, currentOpts.qos);
                subs.push(currentOpts);
            }
        };
        if (Array.isArray(topicObject)) {
            topicObject.forEach((topic) => {
                this.log('subscribe: array topic %s', topic);
                parseSub(topic);
            });
        }
        else {
            Object.keys(topicObject).forEach((topic) => {
                this.log('subscribe: object topic %s, %o', topic, topicObject[topic]);
                parseSub(topic, topicObject[topic]);
            });
        }
        if (!subs.length) {
            callback(null, []);
            return this;
        }
        const subscribeProc = () => {
            const messageId = this._nextId();
            if (messageId === null) {
                this.log('No messageId left');
                return false;
            }
            const packet = {
                cmd: 'subscribe',
                subscriptions: subs,
                messageId,
            };
            if (properties) {
                packet.properties = properties;
            }
            if (this.options.resubscribe) {
                this.log('subscribe :: resubscribe true');
                const topics = [];
                subs.forEach((sub) => {
                    if (this.options.reconnectPeriod > 0) {
                        const topic = { qos: sub.qos };
                        if (version === 5) {
                            topic.nl = sub.nl || false;
                            topic.rap = sub.rap || false;
                            topic.rh = sub.rh || 0;
                            topic.properties = sub.properties;
                        }
                        this._resubscribeTopics[sub.topic] = topic;
                        topics.push(sub.topic);
                    }
                });
                this.messageIdToTopic[packet.messageId] = topics;
            }
            this.outgoing[packet.messageId] = {
                volatile: true,
                cb(err, packet2) {
                    if (!err) {
                        const { granted } = packet2;
                        for (let i = 0; i < granted.length; i += 1) {
                            subs[i].qos = granted[i];
                        }
                    }
                    callback(err, subs);
                },
            };
            this.log('subscribe :: call _sendPacket');
            this._sendPacket(packet);
            return true;
        };
        if (this._storeProcessing ||
            this._storeProcessingQueue.length > 0 ||
            !subscribeProc()) {
            this._storeProcessingQueue.push({
                invoke: subscribeProc,
                callback,
            });
        }
        return this;
    }
    subscribeAsync(topicObject, opts) {
        return new Promise((resolve, reject) => {
            this.subscribe(topicObject, opts, (err, granted) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(granted);
                }
            });
        });
    }
    unsubscribe(topic, opts, callback) {
        if (typeof topic === 'string') {
            topic = [topic];
        }
        if (typeof opts === 'function') {
            callback = opts;
        }
        callback = callback || this.noop;
        const invalidTopic = validations.validateTopics(topic);
        if (invalidTopic !== null) {
            setImmediate(callback, new Error(`Invalid topic ${invalidTopic}`));
            return this;
        }
        if (this._checkDisconnecting(callback)) {
            return this;
        }
        const unsubscribeProc = () => {
            const messageId = this._nextId();
            if (messageId === null) {
                this.log('No messageId left');
                return false;
            }
            const packet = {
                cmd: 'unsubscribe',
                messageId,
                unsubscriptions: [],
            };
            if (typeof topic === 'string') {
                packet.unsubscriptions = [topic];
            }
            else if (Array.isArray(topic)) {
                packet.unsubscriptions = topic;
            }
            if (this.options.resubscribe) {
                packet.unsubscriptions.forEach((topic2) => {
                    delete this._resubscribeTopics[topic2];
                });
            }
            if (typeof opts === 'object' && opts.properties) {
                packet.properties = opts.properties;
            }
            this.outgoing[packet.messageId] = {
                volatile: true,
                cb: callback,
            };
            this.log('unsubscribe: call _sendPacket');
            this._sendPacket(packet);
            return true;
        };
        if (this._storeProcessing ||
            this._storeProcessingQueue.length > 0 ||
            !unsubscribeProc()) {
            this._storeProcessingQueue.push({
                invoke: unsubscribeProc,
                callback,
            });
        }
        return this;
    }
    unsubscribeAsync(topic, opts) {
        return new Promise((resolve, reject) => {
            this.unsubscribe(topic, opts, (err, packet) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(packet);
                }
            });
        });
    }
    end(force, opts, cb) {
        this.log('end :: (%s)', this.options.clientId);
        if (force == null || typeof force !== 'boolean') {
            cb = cb || opts;
            opts = force;
            force = false;
        }
        if (typeof opts !== 'object') {
            cb = cb || opts;
            opts = null;
        }
        this.log('end :: cb? %s', !!cb);
        if (!cb || typeof cb !== 'function') {
            cb = this.noop;
        }
        const closeStores = () => {
            this.log('end :: closeStores: closing incoming and outgoing stores');
            this.disconnected = true;
            this.incomingStore.close((e1) => {
                this.outgoingStore.close((e2) => {
                    this.log('end :: closeStores: emitting end');
                    this.emit('end');
                    if (cb) {
                        const err = e1 || e2;
                        this.log('end :: closeStores: invoking callback with args');
                        cb(err);
                    }
                });
            });
            if (this._deferredReconnect) {
                this._deferredReconnect();
            }
        };
        const finish = () => {
            this.log('end :: (%s) :: finish :: calling _cleanUp with force %s', this.options.clientId, force);
            this._cleanUp(force, () => {
                this.log('end :: finish :: calling process.nextTick on closeStores');
                nextTick(closeStores);
            }, opts);
        };
        if (this.disconnecting) {
            cb();
            return this;
        }
        this._clearReconnect();
        this.disconnecting = true;
        if (!force && Object.keys(this.outgoing).length > 0) {
            this.log('end :: (%s) :: calling finish in 10ms once outgoing is empty', this.options.clientId);
            this.once('outgoingEmpty', setTimeout.bind(null, finish, 10));
        }
        else {
            this.log('end :: (%s) :: immediately calling finish', this.options.clientId);
            finish();
        }
        return this;
    }
    endAsync(force, opts) {
        return new Promise((resolve, reject) => {
            this.end(force, opts, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
    removeOutgoingMessage(messageId) {
        if (this.outgoing[messageId]) {
            const { cb } = this.outgoing[messageId];
            this._removeOutgoingAndStoreMessage(messageId, () => {
                cb(new Error('Message removed'));
            });
        }
        return this;
    }
    reconnect(opts) {
        this.log('client reconnect');
        const f = () => {
            if (opts) {
                this.options.incomingStore = opts.incomingStore;
                this.options.outgoingStore = opts.outgoingStore;
            }
            else {
                this.options.incomingStore = null;
                this.options.outgoingStore = null;
            }
            this.incomingStore = this.options.incomingStore || new store_1.default();
            this.outgoingStore = this.options.outgoingStore || new store_1.default();
            this.disconnecting = false;
            this.disconnected = false;
            this._deferredReconnect = null;
            this._reconnect();
        };
        if (this.disconnecting && !this.disconnected) {
            this._deferredReconnect = f;
        }
        else {
            f();
        }
        return this;
    }
    _flushVolatile() {
        if (this.outgoing) {
            this.log('_flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function');
            Object.keys(this.outgoing).forEach((messageId) => {
                if (this.outgoing[messageId].volatile &&
                    typeof this.outgoing[messageId].cb === 'function') {
                    this.outgoing[messageId].cb(new Error('Connection closed'));
                    delete this.outgoing[messageId];
                }
            });
        }
    }
    _flush() {
        if (this.outgoing) {
            this.log('_flush: queue exists? %b', !!this.outgoing);
            Object.keys(this.outgoing).forEach((messageId) => {
                if (typeof this.outgoing[messageId].cb === 'function') {
                    this.outgoing[messageId].cb(new Error('Connection closed'));
                    delete this.outgoing[messageId];
                }
            });
        }
    }
    _removeTopicAliasAndRecoverTopicName(packet) {
        let alias;
        if (packet.properties) {
            alias = packet.properties.topicAlias;
        }
        let topic = packet.topic.toString();
        this.log('_removeTopicAliasAndRecoverTopicName :: alias %d, topic %o', alias, topic);
        if (topic.length === 0) {
            if (typeof alias === 'undefined') {
                return new Error('Unregistered Topic Alias');
            }
            topic = this.topicAliasSend.getTopicByAlias(alias);
            if (typeof topic === 'undefined') {
                return new Error('Unregistered Topic Alias');
            }
            packet.topic = topic;
        }
        if (alias) {
            delete packet.properties.topicAlias;
        }
    }
    _checkDisconnecting(callback) {
        if (this.disconnecting) {
            if (callback && callback !== this.noop) {
                callback(new Error('client disconnecting'));
            }
            else {
                this.emit('error', new Error('client disconnecting'));
            }
        }
        return this.disconnecting;
    }
    _reconnect() {
        this.log('_reconnect: emitting reconnect to client');
        this.emit('reconnect');
        if (this.connected) {
            this.end(() => {
                this.connect();
            });
            this.log('client already connected. disconnecting first.');
        }
        else {
            this.log('_reconnect: calling connect');
            this.connect();
        }
    }
    _setupReconnect() {
        if (!this.disconnecting &&
            !this.reconnectTimer &&
            this.options.reconnectPeriod > 0) {
            if (!this.reconnecting) {
                this.log('_setupReconnect :: emit `offline` state');
                this.emit('offline');
                this.log('_setupReconnect :: set `reconnecting` to `true`');
                this.reconnecting = true;
            }
            this.log('_setupReconnect :: setting reconnectTimer for %d ms', this.options.reconnectPeriod);
            this.reconnectTimer = setInterval(() => {
                this.log('reconnectTimer :: reconnect triggered!');
                this._reconnect();
            }, this.options.reconnectPeriod);
        }
        else {
            this.log('_setupReconnect :: doing nothing...');
        }
    }
    _clearReconnect() {
        this.log('_clearReconnect : clearing reconnect timer');
        if (this.reconnectTimer) {
            clearInterval(this.reconnectTimer);
            this.reconnectTimer = null;
        }
    }
    _cleanUp(forced, done, opts = {}) {
        if (done) {
            this.log('_cleanUp :: done callback provided for on stream close');
            this.stream.on('close', done);
        }
        this.log('_cleanUp :: forced? %s', forced);
        if (forced) {
            if (this.options.reconnectPeriod === 0 && this.options.clean) {
                this._flush();
            }
            this.log('_cleanUp :: (%s) :: destroying stream', this.options.clientId);
            this.stream.destroy();
        }
        else {
            const packet = Object.assign({ cmd: 'disconnect' }, opts);
            this.log('_cleanUp :: (%s) :: call _sendPacket with disconnect packet', this.options.clientId);
            this._sendPacket(packet, () => {
                this.log('_cleanUp :: (%s) :: destroying stream', this.options.clientId);
                setImmediate(() => {
                    this.stream.end(() => {
                        this.log('_cleanUp :: (%s) :: stream destroyed', this.options.clientId);
                    });
                });
            });
        }
        if (!this.disconnecting) {
            this.log('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.');
            this._clearReconnect();
            this._setupReconnect();
        }
        if (this.pingTimer !== null) {
            this.log('_cleanUp :: clearing pingTimer');
            this.pingTimer.clear();
            this.pingTimer = null;
        }
        if (done && !this.connected) {
            this.log('_cleanUp :: (%s) :: removing stream `done` callback `close` listener', this.options.clientId);
            this.stream.removeListener('close', done);
            done();
        }
    }
    _storeAndSend(packet, cb, cbStorePut) {
        this.log('storeAndSend :: store packet with cmd %s to outgoingStore', packet.cmd);
        let storePacket = packet;
        let err;
        if (storePacket.cmd === 'publish') {
            storePacket = (0, default_1.default)(packet);
            err = this._removeTopicAliasAndRecoverTopicName(storePacket);
            if (err) {
                return cb && cb(err);
            }
        }
        this.outgoingStore.put(storePacket, (err2) => {
            if (err2) {
                return cb && cb(err2);
            }
            cbStorePut();
            this._writePacket(packet, cb);
        });
    }
    _applyTopicAlias(packet) {
        if (this.options.protocolVersion === 5) {
            if (packet.cmd === 'publish') {
                let alias;
                if (packet.properties) {
                    alias = packet.properties.topicAlias;
                }
                const topic = packet.topic.toString();
                if (this.topicAliasSend) {
                    if (alias) {
                        if (topic.length !== 0) {
                            this.log('applyTopicAlias :: register topic: %s - alias: %d', topic, alias);
                            if (!this.topicAliasSend.put(topic, alias)) {
                                this.log('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias);
                                return new Error('Sending Topic Alias out of range');
                            }
                        }
                    }
                    else if (topic.length !== 0) {
                        if (this.options.autoAssignTopicAlias) {
                            alias = this.topicAliasSend.getAliasByTopic(topic);
                            if (alias) {
                                packet.topic = '';
                                packet.properties = Object.assign(Object.assign({}, packet.properties), { topicAlias: alias });
                                this.log('applyTopicAlias :: auto assign(use) topic: %s - alias: %d', topic, alias);
                            }
                            else {
                                alias = this.topicAliasSend.getLruAlias();
                                this.topicAliasSend.put(topic, alias);
                                packet.properties = Object.assign(Object.assign({}, packet.properties), { topicAlias: alias });
                                this.log('applyTopicAlias :: auto assign topic: %s - alias: %d', topic, alias);
                            }
                        }
                        else if (this.options.autoUseTopicAlias) {
                            alias = this.topicAliasSend.getAliasByTopic(topic);
                            if (alias) {
                                packet.topic = '';
                                packet.properties = Object.assign(Object.assign({}, packet.properties), { topicAlias: alias });
                                this.log('applyTopicAlias :: auto use topic: %s - alias: %d', topic, alias);
                            }
                        }
                    }
                }
                else if (alias) {
                    this.log('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias);
                    return new Error('Sending Topic Alias out of range');
                }
            }
        }
    }
    _noop(err) {
        this.log('noop ::', err);
    }
    _writePacket(packet, cb) {
        this.log('_writePacket :: packet: %O', packet);
        this.log('_writePacket :: emitting `packetsend`');
        this.emit('packetsend', packet);
        this._shiftPingInterval();
        this.log('_writePacket :: writing to stream');
        const result = mqtt_packet_1.default.writeToStream(packet, this.stream, this.options);
        this.log('_writePacket :: writeToStream result %s', result);
        if (!result && cb && cb !== this.noop) {
            this.log('_writePacket :: handle events on `drain` once through callback.');
            this.stream.once('drain', cb);
        }
        else if (cb) {
            this.log('_writePacket :: invoking cb');
            cb();
        }
    }
    _sendPacket(packet, cb, cbStorePut, noStore) {
        this.log('_sendPacket :: (%s) ::  start', this.options.clientId);
        cbStorePut = cbStorePut || this.noop;
        cb = cb || this.noop;
        const err = this._applyTopicAlias(packet);
        if (err) {
            cb(err);
            return;
        }
        if (!this.connected) {
            if (packet.cmd === 'auth') {
                this._writePacket(packet, cb);
                return;
            }
            this.log('_sendPacket :: client not connected. Storing packet offline.');
            this._storePacket(packet, cb, cbStorePut);
            return;
        }
        if (noStore) {
            this._writePacket(packet, cb);
            return;
        }
        switch (packet.cmd) {
            case 'publish':
                break;
            case 'pubrel':
                this._storeAndSend(packet, cb, cbStorePut);
                return;
            default:
                this._writePacket(packet, cb);
                return;
        }
        switch (packet.qos) {
            case 2:
            case 1:
                this._storeAndSend(packet, cb, cbStorePut);
                break;
            case 0:
            default:
                this._writePacket(packet, cb);
                break;
        }
        this.log('_sendPacket :: (%s) ::  end', this.options.clientId);
    }
    _storePacket(packet, cb, cbStorePut) {
        this.log('_storePacket :: packet: %o', packet);
        this.log('_storePacket :: cb? %s', !!cb);
        cbStorePut = cbStorePut || this.noop;
        let storePacket = packet;
        if (storePacket.cmd === 'publish') {
            storePacket = (0, default_1.default)(packet);
            const err = this._removeTopicAliasAndRecoverTopicName(storePacket);
            if (err) {
                return cb && cb(err);
            }
        }
        const qos = storePacket.qos || 0;
        if ((qos === 0 && this.queueQoSZero) || storePacket.cmd !== 'publish') {
            this.queue.push({ packet: storePacket, cb });
        }
        else if (qos > 0) {
            cb = this.outgoing[storePacket.messageId]
                ? this.outgoing[storePacket.messageId].cb
                : null;
            this.outgoingStore.put(storePacket, (err) => {
                if (err) {
                    return cb && cb(err);
                }
                cbStorePut();
            });
        }
        else if (cb) {
            cb(new Error('No connection to broker'));
        }
    }
    _setupPingTimer() {
        this.log('_setupPingTimer :: keepalive %d (seconds)', this.options.keepalive);
        if (!this.pingTimer && this.options.keepalive) {
            this.pingResp = true;
            this.pingTimer = (0, reinterval_1.default)(() => {
                this._checkPing();
            }, this.options.keepalive * 1000);
        }
    }
    _shiftPingInterval() {
        if (this.pingTimer &&
            this.options.keepalive &&
            this.options.reschedulePings) {
            this.pingTimer.reschedule(this.options.keepalive * 1000);
        }
    }
    _checkPing() {
        this.log('_checkPing :: checking ping...');
        if (this.pingResp) {
            this.log('_checkPing :: ping response received. Clearing flag and sending `pingreq`');
            this.pingResp = false;
            this._sendPacket({ cmd: 'pingreq' });
        }
        else {
            this.log('_checkPing :: calling _cleanUp with force true');
            this._cleanUp(true);
        }
    }
    _resubscribe() {
        this.log('_resubscribe');
        const _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics);
        if (!this._firstConnection &&
            (this.options.clean ||
                (this.options.protocolVersion >= 4 &&
                    !this.connackPacket.sessionPresent)) &&
            _resubscribeTopicsKeys.length > 0) {
            if (this.options.resubscribe) {
                if (this.options.protocolVersion === 5) {
                    this.log('_resubscribe: protocolVersion 5');
                    for (let topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {
                        const resubscribeTopic = {};
                        resubscribeTopic[_resubscribeTopicsKeys[topicI]] =
                            this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];
                        resubscribeTopic.resubscribe = true;
                        this.subscribe(resubscribeTopic, {
                            properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]]
                                .properties,
                        });
                    }
                }
                else {
                    this._resubscribeTopics.resubscribe = true;
                    this.subscribe(this._resubscribeTopics);
                }
            }
            else {
                this._resubscribeTopics = {};
            }
        }
        this._firstConnection = false;
    }
    _onConnect(packet) {
        if (this.disconnected) {
            this.emit('connect', packet);
            return;
        }
        this.connackPacket = packet;
        this.messageIdProvider.clear();
        this._setupPingTimer();
        this.connected = true;
        const startStreamProcess = () => {
            let outStore = this.outgoingStore.createStream();
            const remove = () => {
                outStore.destroy();
                outStore = null;
                this._flushStoreProcessingQueue();
                clearStoreProcessing();
            };
            const clearStoreProcessing = () => {
                this._storeProcessing = false;
                this._packetIdsDuringStoreProcessing = {};
            };
            this.once('close', remove);
            outStore.on('error', (err) => {
                clearStoreProcessing();
                this._flushStoreProcessingQueue();
                this.removeListener('close', remove);
                this.emit('error', err);
            });
            const storeDeliver = () => {
                if (!outStore) {
                    return;
                }
                const packet2 = outStore.read(1);
                let cb;
                if (!packet2) {
                    outStore.once('readable', storeDeliver);
                    return;
                }
                this._storeProcessing = true;
                if (this._packetIdsDuringStoreProcessing[packet2.messageId]) {
                    storeDeliver();
                    return;
                }
                if (!this.disconnecting && !this.reconnectTimer) {
                    cb = this.outgoing[packet2.messageId]
                        ? this.outgoing[packet2.messageId].cb
                        : null;
                    this.outgoing[packet2.messageId] = {
                        volatile: false,
                        cb(err, status) {
                            if (cb) {
                                cb(err, status);
                            }
                            storeDeliver();
                        },
                    };
                    this._packetIdsDuringStoreProcessing[packet2.messageId] =
                        true;
                    if (this.messageIdProvider.register(packet2.messageId)) {
                        this._sendPacket(packet2, undefined, undefined, true);
                    }
                    else {
                        this.log('messageId: %d has already used.', packet2.messageId);
                    }
                }
                else if (outStore.destroy) {
                    outStore.destroy();
                }
            };
            outStore.on('end', () => {
                let allProcessed = true;
                for (const id in this._packetIdsDuringStoreProcessing) {
                    if (!this._packetIdsDuringStoreProcessing[id]) {
                        allProcessed = false;
                        break;
                    }
                }
                if (allProcessed) {
                    clearStoreProcessing();
                    this.removeListener('close', remove);
                    this._invokeAllStoreProcessingQueue();
                    this.emit('connect', packet);
                }
                else {
                    startStreamProcess();
                }
            });
            storeDeliver();
        };
        startStreamProcess();
    }
    _invokeStoreProcessingQueue() {
        if (!this._storeProcessing && this._storeProcessingQueue.length > 0) {
            const f = this._storeProcessingQueue[0];
            if (f && f.invoke()) {
                this._storeProcessingQueue.shift();
                return true;
            }
        }
        return false;
    }
    _invokeAllStoreProcessingQueue() {
        while (this._invokeStoreProcessingQueue()) {
        }
    }
    _flushStoreProcessingQueue() {
        for (const f of this._storeProcessingQueue) {
            if (f.cbStorePut)
                f.cbStorePut(new Error('Connection closed'));
            if (f.callback)
                f.callback(new Error('Connection closed'));
        }
        this._storeProcessingQueue.splice(0);
    }
    _removeOutgoingAndStoreMessage(messageId, cb) {
        delete this.outgoing[messageId];
        this.outgoingStore.del({ messageId }, (err, packet) => {
            cb(err, packet);
            this.messageIdProvider.deallocate(messageId);
            this._invokeStoreProcessingQueue();
        });
    }
}
exports.default = MqttClient;

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./TypedEmitter":1,"./default-message-id-provider":9,"./handlers":13,"./store":18,"./topic-alias-recv":19,"./validations":22,"_process":102,"debug":30,"mqtt-packet":75,"readable-stream":125,"reinterval":131,"rfdc/default":132}],3:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("buffer");
const readable_stream_1 = require("readable-stream");
const duplexify_1 = __importDefault(require("duplexify"));
let my;
let proxy;
let stream;
let isInitialized = false;
function buildProxy() {
    const _proxy = new readable_stream_1.Transform();
    _proxy._write = (chunk, encoding, next) => {
        my.sendSocketMessage({
            data: chunk.buffer,
            success() {
                next();
            },
            fail() {
                next(new Error());
            },
        });
    };
    _proxy._flush = (done) => {
        my.closeSocket({
            success() {
                done();
            },
        });
    };
    return _proxy;
}
function setDefaultOpts(opts) {
    if (!opts.hostname) {
        opts.hostname = 'localhost';
    }
    if (!opts.path) {
        opts.path = '/';
    }
    if (!opts.wsOptions) {
        opts.wsOptions = {};
    }
}
function buildUrl(opts, client) {
    const protocol = opts.protocol === 'alis' ? 'wss' : 'ws';
    let url = `${protocol}://${opts.hostname}${opts.path}`;
    if (opts.port && opts.port !== 80 && opts.port !== 443) {
        url = `${protocol}://${opts.hostname}:${opts.port}${opts.path}`;
    }
    if (typeof opts.transformWsUrl === 'function') {
        url = opts.transformWsUrl(url, opts, client);
    }
    return url;
}
function bindEventHandler() {
    if (isInitialized)
        return;
    isInitialized = true;
    my.onSocketOpen(() => {
        stream.setReadable(proxy);
        stream.setWritable(proxy);
        stream.emit('connect');
    });
    my.onSocketMessage((res) => {
        if (typeof res.data === 'string') {
            const buffer = buffer_1.Buffer.from(res.data, 'base64');
            proxy.push(buffer);
        }
        else {
            const reader = new FileReader();
            reader.addEventListener('load', () => {
                let data = reader.result;
                if (data instanceof ArrayBuffer)
                    data = buffer_1.Buffer.from(data);
                else
                    data = buffer_1.Buffer.from(data, 'utf8');
                proxy.push(data);
            });
            reader.readAsArrayBuffer(res.data);
        }
    });
    my.onSocketClose(() => {
        stream.end();
        stream.destroy();
    });
    my.onSocketError((res) => {
        stream.destroy(res);
    });
}
const buildStream = (client, opts) => {
    opts.hostname = opts.hostname || opts.host;
    if (!opts.hostname) {
        throw new Error('Could not determine host. Specify host manually.');
    }
    const websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3
        ? 'mqttv3.1'
        : 'mqtt';
    setDefaultOpts(opts);
    const url = buildUrl(opts, client);
    my = opts.my;
    my.connectSocket({
        url,
        protocols: websocketSubProtocol,
    });
    proxy = buildProxy();
    stream = duplexify_1.default.obj();
    bindEventHandler();
    return stream;
};
exports.default = buildStream;

},{"buffer":29,"duplexify":32,"readable-stream":125}],4:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.connectAsync = void 0;
const debug_1 = __importDefault(require("debug"));
const url_1 = __importDefault(require("url"));
const client_1 = __importDefault(require("../client"));
const is_browser_1 = __importDefault(require("../is-browser"));
const debug = (0, debug_1.default)('mqttjs');
const protocols = {};
if (!is_browser_1.default) {
    protocols.mqtt = require('./tcp').default;
    protocols.tcp = require('./tcp').default;
    protocols.ssl = require('./tls').default;
    protocols.tls = protocols.ssl;
    protocols.mqtts = require('./tls').default;
}
else {
    protocols.wx = require('./wx').default;
    protocols.wxs = require('./wx').default;
    protocols.ali = require('./ali').default;
    protocols.alis = require('./ali').default;
}
protocols.ws = require('./ws').default;
protocols.wss = require('./ws').default;
function parseAuthOptions(opts) {
    let matches;
    if (opts.auth) {
        matches = opts.auth.match(/^(.+):(.+)$/);
        if (matches) {
            opts.username = matches[1];
            opts.password = matches[2];
        }
        else {
            opts.username = opts.auth;
        }
    }
}
function connect(brokerUrl, opts) {
    debug('connecting to an MQTT broker...');
    if (typeof brokerUrl === 'object' && !opts) {
        opts = brokerUrl;
        brokerUrl = '';
    }
    opts = opts || {};
    if (brokerUrl && typeof brokerUrl === 'string') {
        const parsed = url_1.default.parse(brokerUrl, true);
        if (parsed.port != null) {
            parsed.port = Number(parsed.port);
        }
        opts = Object.assign(Object.assign({}, parsed), opts);
        if (opts.protocol === null) {
            throw new Error('Missing protocol');
        }
        opts.protocol = opts.protocol.replace(/:$/, '');
    }
    parseAuthOptions(opts);
    if (opts.query && typeof opts.query.clientId === 'string') {
        opts.clientId = opts.query.clientId;
    }
    if (opts.cert && opts.key) {
        if (opts.protocol) {
            if (['mqtts', 'wss', 'wxs', 'alis'].indexOf(opts.protocol) === -1) {
                switch (opts.protocol) {
                    case 'mqtt':
                        opts.protocol = 'mqtts';
                        break;
                    case 'ws':
                        opts.protocol = 'wss';
                        break;
                    case 'wx':
                        opts.protocol = 'wxs';
                        break;
                    case 'ali':
                        opts.protocol = 'alis';
                        break;
                    default:
                        throw new Error(`Unknown protocol for secure connection: "${opts.protocol}"!`);
                }
            }
        }
        else {
            throw new Error('Missing secure protocol key');
        }
    }
    if (!protocols[opts.protocol]) {
        const isSecure = ['mqtts', 'wss'].indexOf(opts.protocol) !== -1;
        opts.protocol = [
            'mqtt',
            'mqtts',
            'ws',
            'wss',
            'wx',
            'wxs',
            'ali',
            'alis',
        ].filter((key, index) => {
            if (isSecure && index % 2 === 0) {
                return false;
            }
            return typeof protocols[key] === 'function';
        })[0];
    }
    if (opts.clean === false && !opts.clientId) {
        throw new Error('Missing clientId for unclean clients');
    }
    if (opts.protocol) {
        opts.defaultProtocol = opts.protocol;
    }
    function wrapper(client) {
        if (opts.servers) {
            if (!client._reconnectCount ||
                client._reconnectCount === opts.servers.length) {
                client._reconnectCount = 0;
            }
            opts.host = opts.servers[client._reconnectCount].host;
            opts.port = opts.servers[client._reconnectCount].port;
            opts.protocol = !opts.servers[client._reconnectCount].protocol
                ? opts.defaultProtocol
                : opts.servers[client._reconnectCount].protocol;
            opts.hostname = opts.host;
            client._reconnectCount++;
        }
        debug('calling streambuilder for', opts.protocol);
        return protocols[opts.protocol](client, opts);
    }
    const client = new client_1.default(wrapper, opts);
    client.on('error', () => {
    });
    return client;
}
function connectAsync(brokerUrl, opts, allowRetries = true) {
    return new Promise((resolve, reject) => {
        const client = connect(brokerUrl, opts);
        const promiseResolutionListeners = {
            connect: (connack) => {
                removePromiseResolutionListeners();
                resolve(client);
            },
            end: () => {
                removePromiseResolutionListeners();
                resolve(client);
            },
            error: (err) => {
                removePromiseResolutionListeners();
                client.end();
                reject(err);
            },
        };
        if (allowRetries === false) {
            promiseResolutionListeners.close = () => {
                promiseResolutionListeners.error(new Error("Couldn't connect to server"));
            };
        }
        function removePromiseResolutionListeners() {
            Object.keys(promiseResolutionListeners).forEach((eventName) => {
                client.off(eventName, promiseResolutionListeners[eventName]);
            });
        }
        Object.keys(promiseResolutionListeners).forEach((eventName) => {
            client.on(eventName, promiseResolutionListeners[eventName]);
        });
    });
}
exports.connectAsync = connectAsync;
exports.default = connect;

},{"../client":2,"../is-browser":16,"./ali":3,"./tcp":5,"./tls":6,"./ws":7,"./wx":8,"debug":30,"url":137}],5:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const net_1 = __importDefault(require("net"));
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('mqttjs:tcp');
const buildStream = (client, opts) => {
    opts.port = opts.port || 1883;
    opts.hostname = opts.hostname || opts.host || 'localhost';
    const { port } = opts;
    const host = opts.hostname;
    debug('port %d and host %s', port, host);
    return net_1.default.createConnection(port, host);
};
exports.default = buildStream;

},{"debug":30,"net":26}],6:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tls_1 = __importDefault(require("tls"));
const net_1 = __importDefault(require("net"));
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('mqttjs:tls');
const buildStream = (client, opts) => {
    opts.port = opts.port || 8883;
    opts.host = opts.hostname || opts.host || 'localhost';
    if (net_1.default.isIP(opts.host) === 0) {
        opts.servername = opts.host;
    }
    opts.rejectUnauthorized = opts.rejectUnauthorized !== false;
    delete opts.path;
    debug('port %d host %s rejectUnauthorized %b', opts.port, opts.host, opts.rejectUnauthorized);
    const connection = tls_1.default.connect(opts);
    connection.on('secureConnect', () => {
        if (opts.rejectUnauthorized && !connection.authorized) {
            connection.emit('error', new Error('TLS not authorized'));
        }
        else {
            connection.removeListener('error', handleTLSerrors);
        }
    });
    function handleTLSerrors(err) {
        if (opts.rejectUnauthorized) {
            client.emit('error', err);
        }
        connection.end();
    }
    connection.on('error', handleTLSerrors);
    return connection;
};
exports.default = buildStream;

},{"debug":30,"net":26,"tls":26}],7:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("buffer");
const ws_1 = __importDefault(require("ws"));
const debug_1 = __importDefault(require("debug"));
const duplexify_1 = __importDefault(require("duplexify"));
const readable_stream_1 = require("readable-stream");
const is_browser_1 = __importDefault(require("../is-browser"));
const debug = (0, debug_1.default)('mqttjs:ws');
const WSS_OPTIONS = [
    'rejectUnauthorized',
    'ca',
    'cert',
    'key',
    'pfx',
    'passphrase',
];
function buildUrl(opts, client) {
    let url = `${opts.protocol}://${opts.hostname}:${opts.port}${opts.path}`;
    if (typeof opts.transformWsUrl === 'function') {
        url = opts.transformWsUrl(url, opts, client);
    }
    return url;
}
function setDefaultOpts(opts) {
    const options = opts;
    if (!opts.hostname) {
        options.hostname = 'localhost';
    }
    if (!opts.port) {
        if (opts.protocol === 'wss') {
            options.port = 443;
        }
        else {
            options.port = 80;
        }
    }
    if (!opts.path) {
        options.path = '/';
    }
    if (!opts.wsOptions) {
        options.wsOptions = {};
    }
    if (!is_browser_1.default && opts.protocol === 'wss') {
        WSS_OPTIONS.forEach((prop) => {
            if (Object.prototype.hasOwnProperty.call(opts, prop) &&
                !Object.prototype.hasOwnProperty.call(opts.wsOptions, prop)) {
                options.wsOptions[prop] = opts[prop];
            }
        });
    }
    return options;
}
function setDefaultBrowserOpts(opts) {
    const options = setDefaultOpts(opts);
    if (!options.hostname) {
        options.hostname = options.host;
    }
    if (!options.hostname) {
        if (typeof document === 'undefined') {
            throw new Error('Could not determine host. Specify host manually.');
        }
        const parsed = new URL(document.URL);
        options.hostname = parsed.hostname;
        if (!options.port) {
            options.port = Number(parsed.port);
        }
    }
    if (options.objectMode === undefined) {
        options.objectMode = !(options.binary === true || options.binary === undefined);
    }
    return options;
}
function createWebSocket(client, url, opts) {
    debug('createWebSocket');
    debug(`protocol: ${opts.protocolId} ${opts.protocolVersion}`);
    const websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3
        ? 'mqttv3.1'
        : 'mqtt';
    debug(`creating new Websocket for url: ${url} and protocol: ${websocketSubProtocol}`);
    let socket;
    if (opts.createWebsocket) {
        socket = opts.createWebsocket(url, [websocketSubProtocol], opts);
    }
    else {
        socket = new ws_1.default(url, [websocketSubProtocol], opts.wsOptions);
    }
    return socket;
}
function createBrowserWebSocket(client, opts) {
    const websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3
        ? 'mqttv3.1'
        : 'mqtt';
    const url = buildUrl(opts, client);
    let socket;
    if (opts.createWebsocket) {
        socket = opts.createWebsocket(url, [websocketSubProtocol], opts);
    }
    else {
        socket = new WebSocket(url, [websocketSubProtocol]);
    }
    socket.binaryType = 'arraybuffer';
    return socket;
}
const streamBuilder = (client, opts) => {
    debug('streamBuilder');
    const options = setDefaultOpts(opts);
    const url = buildUrl(options, client);
    const socket = createWebSocket(client, url, options);
    const webSocketStream = ws_1.default.createWebSocketStream(socket, options.wsOptions);
    webSocketStream['url'] = url;
    socket.on('close', () => {
        webSocketStream.destroy();
    });
    return webSocketStream;
};
const browserStreamBuilder = (client, opts) => {
    debug('browserStreamBuilder');
    let stream;
    const options = setDefaultBrowserOpts(opts);
    const bufferSize = options.browserBufferSize || 1024 * 512;
    const bufferTimeout = opts.browserBufferTimeout || 1000;
    const coerceToBuffer = !opts.objectMode;
    const socket = createBrowserWebSocket(client, opts);
    const proxy = buildProxy(opts, socketWriteBrowser, socketEndBrowser);
    if (!opts.objectMode) {
        proxy._writev = writev;
    }
    proxy.on('close', () => {
        socket.close();
    });
    const eventListenerSupport = typeof socket.addEventListener !== 'undefined';
    if (socket.readyState === socket.OPEN) {
        stream = proxy;
    }
    else {
        stream = (0, duplexify_1.default)(undefined, undefined, opts);
        if (!opts.objectMode) {
            stream._writev = writev;
        }
        if (eventListenerSupport) {
            socket.addEventListener('open', onOpen);
        }
        else {
            socket.onopen = onOpen;
        }
    }
    stream.socket = socket;
    if (eventListenerSupport) {
        socket.addEventListener('close', onClose);
        socket.addEventListener('error', onError);
        socket.addEventListener('message', onMessage);
    }
    else {
        socket.onclose = onClose;
        socket.onerror = onError;
        socket.onmessage = onMessage;
    }
    function buildProxy(pOptions, socketWrite, socketEnd) {
        const _proxy = new readable_stream_1.Transform({
            objectMode: pOptions.objectMode,
        });
        _proxy._write = socketWrite;
        _proxy._flush = socketEnd;
        return _proxy;
    }
    function onOpen() {
        stream.setReadable(proxy);
        stream.setWritable(proxy);
        stream.emit('connect');
    }
    function onClose() {
        stream.end();
        stream.destroy();
    }
    function onError(err) {
        stream.destroy(err);
    }
    function onMessage(event) {
        let { data } = event;
        if (data instanceof ArrayBuffer)
            data = buffer_1.Buffer.from(data);
        else
            data = buffer_1.Buffer.from(data, 'utf8');
        proxy.push(data);
    }
    function writev(chunks, cb) {
        const buffers = new Array(chunks.length);
        for (let i = 0; i < chunks.length; i++) {
            if (typeof chunks[i].chunk === 'string') {
                buffers[i] = buffer_1.Buffer.from(chunks[i], 'utf8');
            }
            else {
                buffers[i] = chunks[i].chunk;
            }
        }
        this._write(buffer_1.Buffer.concat(buffers), 'binary', cb);
    }
    function socketWriteBrowser(chunk, enc, next) {
        if (socket.bufferedAmount > bufferSize) {
            setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next);
        }
        if (coerceToBuffer && typeof chunk === 'string') {
            chunk = buffer_1.Buffer.from(chunk, 'utf8');
        }
        try {
            socket.send(chunk);
        }
        catch (err) {
            return next(err);
        }
        next();
    }
    function socketEndBrowser(done) {
        socket.close();
        done();
    }
    return stream;
};
exports.default = is_browser_1.default ? browserStreamBuilder : streamBuilder;

},{"../is-browser":16,"buffer":29,"debug":30,"duplexify":32,"readable-stream":125,"ws":141}],8:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("buffer");
const readable_stream_1 = require("readable-stream");
const duplexify_1 = __importDefault(require("duplexify"));
let socketTask;
let proxy;
let stream;
function buildProxy() {
    const _proxy = new readable_stream_1.Transform();
    _proxy._write = (chunk, encoding, next) => {
        socketTask.send({
            data: chunk.buffer,
            success() {
                next();
            },
            fail(errMsg) {
                next(new Error(errMsg));
            },
        });
    };
    _proxy._flush = (done) => {
        socketTask.close({
            success() {
                done();
            },
        });
    };
    return _proxy;
}
function setDefaultOpts(opts) {
    if (!opts.hostname) {
        opts.hostname = 'localhost';
    }
    if (!opts.path) {
        opts.path = '/';
    }
    if (!opts.wsOptions) {
        opts.wsOptions = {};
    }
}
function buildUrl(opts, client) {
    const protocol = opts.protocol === 'wxs' ? 'wss' : 'ws';
    let url = `${protocol}://${opts.hostname}${opts.path}`;
    if (opts.port && opts.port !== 80 && opts.port !== 443) {
        url = `${protocol}://${opts.hostname}:${opts.port}${opts.path}`;
    }
    if (typeof opts.transformWsUrl === 'function') {
        url = opts.transformWsUrl(url, opts, client);
    }
    return url;
}
function bindEventHandler() {
    socketTask.onOpen(() => {
        stream.setReadable(proxy);
        stream.setWritable(proxy);
        stream.emit('connect');
    });
    socketTask.onMessage((res) => {
        let { data } = res;
        if (data instanceof ArrayBuffer)
            data = buffer_1.Buffer.from(data);
        else
            data = buffer_1.Buffer.from(data, 'utf8');
        proxy.push(data);
    });
    socketTask.onClose(() => {
        stream.emit('close');
        stream.end();
        stream.destroy();
    });
    socketTask.onError((res) => {
        stream.destroy(new Error(res.errMsg));
    });
}
const buildStream = (client, opts) => {
    opts.hostname = opts.hostname || opts.host;
    if (!opts.hostname) {
        throw new Error('Could not determine host. Specify host manually.');
    }
    const websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3
        ? 'mqttv3.1'
        : 'mqtt';
    setDefaultOpts(opts);
    const url = buildUrl(opts, client);
    socketTask = wx.connectSocket({
        url,
        protocols: [websocketSubProtocol],
    });
    proxy = buildProxy();
    stream = duplexify_1.default.obj();
    stream._destroy = (err, cb) => {
        socketTask.close({
            success() {
                if (cb)
                    cb(err);
            },
        });
    };
    const destroyRef = stream.destroy;
    stream.destroy = () => {
        stream.destroy = destroyRef;
        setTimeout(() => {
            socketTask.close({
                fail() {
                    stream._destroy(new Error());
                },
            });
        }, 0);
    };
    bindEventHandler();
    return stream;
};
exports.default = buildStream;

},{"buffer":29,"duplexify":32,"readable-stream":125}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class DefaultMessageIdProvider {
    constructor() {
        this.nextId = Math.max(1, Math.floor(Math.random() * 65535));
    }
    allocate() {
        const id = this.nextId++;
        if (this.nextId === 65536) {
            this.nextId = 1;
        }
        return id;
    }
    getLastAllocated() {
        return this.nextId === 1 ? 65535 : this.nextId - 1;
    }
    register(messageId) {
        return true;
    }
    deallocate(messageId) { }
    clear() { }
}
exports.default = DefaultMessageIdProvider;

},{}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReasonCodes = void 0;
exports.ReasonCodes = {
    0: '',
    1: 'Unacceptable protocol version',
    2: 'Identifier rejected',
    3: 'Server unavailable',
    4: 'Bad username or password',
    5: 'Not authorized',
    16: 'No matching subscribers',
    17: 'No subscription existed',
    128: 'Unspecified error',
    129: 'Malformed Packet',
    130: 'Protocol Error',
    131: 'Implementation specific error',
    132: 'Unsupported Protocol Version',
    133: 'Client Identifier not valid',
    134: 'Bad User Name or Password',
    135: 'Not authorized',
    136: 'Server unavailable',
    137: 'Server busy',
    138: 'Banned',
    139: 'Server shutting down',
    140: 'Bad authentication method',
    141: 'Keep Alive timeout',
    142: 'Session taken over',
    143: 'Topic Filter invalid',
    144: 'Topic Name invalid',
    145: 'Packet identifier in use',
    146: 'Packet Identifier not found',
    147: 'Receive Maximum exceeded',
    148: 'Topic Alias invalid',
    149: 'Packet too large',
    150: 'Message rate too high',
    151: 'Quota exceeded',
    152: 'Administrative action',
    153: 'Payload format invalid',
    154: 'Retain not supported',
    155: 'QoS not supported',
    156: 'Use another server',
    157: 'Server moved',
    158: 'Shared Subscriptions not supported',
    159: 'Connection rate exceeded',
    160: 'Maximum connect time',
    161: 'Subscription Identifiers not supported',
    162: 'Wildcard Subscriptions not supported',
};
const handleAck = (client, packet) => {
    const { messageId } = packet;
    const type = packet.cmd;
    let response = null;
    const cb = client.outgoing[messageId] ? client.outgoing[messageId].cb : null;
    let err;
    if (!cb) {
        client.log('_handleAck :: Server sent an ack in error. Ignoring.');
        return;
    }
    client.log('_handleAck :: packet type', type);
    switch (type) {
        case 'pubcomp':
        case 'puback': {
            const pubackRC = packet.reasonCode;
            if (pubackRC && pubackRC > 0 && pubackRC !== 16) {
                err = new Error(`Publish error: ${exports.ReasonCodes[pubackRC]}`);
                err.code = pubackRC;
                client['_removeOutgoingAndStoreMessage'](messageId, () => {
                    cb(err, packet);
                });
            }
            else {
                client['_removeOutgoingAndStoreMessage'](messageId, cb);
            }
            break;
        }
        case 'pubrec': {
            response = {
                cmd: 'pubrel',
                qos: 2,
                messageId,
            };
            const pubrecRC = packet.reasonCode;
            if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {
                err = new Error(`Publish error: ${exports.ReasonCodes[pubrecRC]}`);
                err.code = pubrecRC;
                client['_removeOutgoingAndStoreMessage'](messageId, () => {
                    cb(err, packet);
                });
            }
            else {
                client['_sendPacket'](response);
            }
            break;
        }
        case 'suback': {
            delete client.outgoing[messageId];
            client.messageIdProvider.deallocate(messageId);
            const granted = packet.granted;
            for (let grantedI = 0; grantedI < granted.length; grantedI++) {
                if ((granted[grantedI] & 0x80) !== 0) {
                    const topics = client.messageIdToTopic[messageId];
                    if (topics) {
                        topics.forEach((topic) => {
                            delete client['_resubscribeTopics'][topic];
                        });
                    }
                }
            }
            delete client.messageIdToTopic[messageId];
            client['_invokeStoreProcessingQueue']();
            cb(null, packet);
            break;
        }
        case 'unsuback': {
            delete client.outgoing[messageId];
            client.messageIdProvider.deallocate(messageId);
            client['_invokeStoreProcessingQueue']();
            cb(null);
            break;
        }
        default:
            client.emit('error', new Error('unrecognized packet type'));
    }
    if (client.disconnecting && Object.keys(client.outgoing).length === 0) {
        client.emit('outgoingEmpty');
    }
};
exports.default = handleAck;

},{}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const shared_1 = require("../shared");
const ack_1 = require("./ack");
const handleAuth = (client, packet) => {
    const { options } = client;
    const version = options.protocolVersion;
    const rc = version === 5 ? packet.reasonCode : packet.returnCode;
    if (version !== 5) {
        const err = new shared_1.ErrorWithReasonCode(`Protocol error: Auth packets are only supported in MQTT 5. Your version:${version}`, rc);
        client.emit('error', err);
        return;
    }
    client.handleAuth(packet, (err, packet2) => {
        if (err) {
            client.emit('error', err);
            return;
        }
        if (rc === 24) {
            client.reconnecting = false;
            client['_sendPacket'](packet2);
        }
        else {
            const error = new shared_1.ErrorWithReasonCode(`Connection refused: ${ack_1.ReasonCodes[rc]}`, rc);
            client.emit('error', error);
        }
    });
};
exports.default = handleAuth;

},{"../shared":17,"./ack":10}],12:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ack_1 = require("./ack");
const topic_alias_send_1 = __importDefault(require("../topic-alias-send"));
const shared_1 = require("../shared");
const handleConnack = (client, packet) => {
    client.log('_handleConnack');
    const { options } = client;
    const version = options.protocolVersion;
    const rc = version === 5 ? packet.reasonCode : packet.returnCode;
    clearTimeout(client['connackTimer']);
    delete client['topicAliasSend'];
    if (packet.properties) {
        if (packet.properties.topicAliasMaximum) {
            if (packet.properties.topicAliasMaximum > 0xffff) {
                client.emit('error', new Error('topicAliasMaximum from broker is out of range'));
                return;
            }
            if (packet.properties.topicAliasMaximum > 0) {
                client['topicAliasSend'] = new topic_alias_send_1.default(packet.properties.topicAliasMaximum);
            }
        }
        if (packet.properties.serverKeepAlive && options.keepalive) {
            options.keepalive = packet.properties.serverKeepAlive;
            client['_shiftPingInterval']();
        }
        if (packet.properties.maximumPacketSize) {
            if (!options.properties) {
                options.properties = {};
            }
            options.properties.maximumPacketSize =
                packet.properties.maximumPacketSize;
        }
    }
    if (rc === 0) {
        client.reconnecting = false;
        client['_onConnect'](packet);
    }
    else if (rc > 0) {
        const err = new shared_1.ErrorWithReasonCode(`Connection refused: ${ack_1.ReasonCodes[rc]}`, rc);
        client.emit('error', err);
    }
};
exports.default = handleConnack;

},{"../shared":17,"../topic-alias-send":20,"./ack":10}],13:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const publish_1 = __importDefault(require("./publish"));
const auth_1 = __importDefault(require("./auth"));
const connack_1 = __importDefault(require("./connack"));
const ack_1 = __importDefault(require("./ack"));
const pubrel_1 = __importDefault(require("./pubrel"));
const handle = (client, packet, done) => {
    const { options } = client;
    if (options.protocolVersion === 5 &&
        options.properties &&
        options.properties.maximumPacketSize &&
        options.properties.maximumPacketSize < packet.length) {
        client.emit('error', new Error(`exceeding packets size ${packet.cmd}`));
        client.end({
            reasonCode: 149,
            properties: { reasonString: 'Maximum packet size was exceeded' },
        });
        return client;
    }
    client.log('_handlePacket :: emitting packetreceive');
    client.emit('packetreceive', packet);
    switch (packet.cmd) {
        case 'publish':
            (0, publish_1.default)(client, packet, done);
            break;
        case 'puback':
        case 'pubrec':
        case 'pubcomp':
        case 'suback':
        case 'unsuback':
            (0, ack_1.default)(client, packet);
            done();
            break;
        case 'pubrel':
            (0, pubrel_1.default)(client, packet, done);
            break;
        case 'connack':
            (0, connack_1.default)(client, packet);
            done();
            break;
        case 'auth':
            (0, auth_1.default)(client, packet);
            done();
            break;
        case 'pingresp':
            client.pingResp = true;
            done();
            break;
        case 'disconnect':
            client.emit('disconnect', packet);
            done();
            break;
        default:
            client.log('_handlePacket :: unknown command');
            done();
            break;
    }
};
exports.default = handle;

},{"./ack":10,"./auth":11,"./connack":12,"./publish":14,"./pubrel":15}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153];
const handlePublish = (client, packet, done) => {
    client.log('handlePublish: packet %o', packet);
    done = typeof done !== 'undefined' ? done : client.noop;
    let topic = packet.topic.toString();
    const message = packet.payload;
    const { qos } = packet;
    const { messageId } = packet;
    const { options } = client;
    if (client.options.protocolVersion === 5) {
        let alias;
        if (packet.properties) {
            alias = packet.properties.topicAlias;
        }
        if (typeof alias !== 'undefined') {
            if (topic.length === 0) {
                if (alias > 0 && alias <= 0xffff) {
                    const gotTopic = client['topicAliasRecv'].getTopicByAlias(alias);
                    if (gotTopic) {
                        topic = gotTopic;
                        client.log('handlePublish :: topic complemented by alias. topic: %s - alias: %d', topic, alias);
                    }
                    else {
                        client.log('handlePublish :: unregistered topic alias. alias: %d', alias);
                        client.emit('error', new Error('Received unregistered Topic Alias'));
                        return;
                    }
                }
                else {
                    client.log('handlePublish :: topic alias out of range. alias: %d', alias);
                    client.emit('error', new Error('Received Topic Alias is out of range'));
                    return;
                }
            }
            else if (client['topicAliasRecv'].put(topic, alias)) {
                client.log('handlePublish :: registered topic: %s - alias: %d', topic, alias);
            }
            else {
                client.log('handlePublish :: topic alias out of range. alias: %d', alias);
                client.emit('error', new Error('Received Topic Alias is out of range'));
                return;
            }
        }
    }
    client.log('handlePublish: qos %d', qos);
    switch (qos) {
        case 2: {
            options.customHandleAcks(topic, message, packet, (error, code) => {
                if (typeof error === 'number') {
                    code = error;
                    error = null;
                }
                if (error) {
                    return client.emit('error', error);
                }
                if (validReasonCodes.indexOf(code) === -1) {
                    return client.emit('error', new Error('Wrong reason code for pubrec'));
                }
                if (code) {
                    client['_sendPacket']({ cmd: 'pubrec', messageId, reasonCode: code }, done);
                }
                else {
                    client.incomingStore.put(packet, () => {
                        client['_sendPacket']({ cmd: 'pubrec', messageId }, done);
                    });
                }
            });
            break;
        }
        case 1: {
            options.customHandleAcks(topic, message, packet, (error, code) => {
                if (typeof error === 'number') {
                    code = error;
                    error = null;
                }
                if (error) {
                    return client.emit('error', error);
                }
                if (validReasonCodes.indexOf(code) === -1) {
                    return client.emit('error', new Error('Wrong reason code for puback'));
                }
                if (!code) {
                    client.emit('message', topic, message, packet);
                }
                client.handleMessage(packet, (err) => {
                    if (err) {
                        return done && done(err);
                    }
                    client['_sendPacket']({ cmd: 'puback', messageId, reasonCode: code }, done);
                });
            });
            break;
        }
        case 0:
            client.emit('message', topic, message, packet);
            client.handleMessage(packet, done);
            break;
        default:
            client.log('handlePublish: unknown QoS. Doing nothing.');
            break;
    }
};
exports.default = handlePublish;

},{}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const handlePubrel = (client, packet, done) => {
    client.log('handling pubrel packet');
    const callback = typeof done !== 'undefined' ? done : client.noop;
    const { messageId } = packet;
    const comp = { cmd: 'pubcomp', messageId };
    client.incomingStore.get(packet, (err, pub) => {
        if (!err) {
            client.emit('message', pub.topic, pub.payload, pub);
            client.handleMessage(pub, (err2) => {
                if (err2) {
                    return callback(err2);
                }
                client.incomingStore.del(pub, client.noop);
                client['_sendPacket'](comp, callback);
            });
        }
        else {
            client['_sendPacket'](comp, callback);
        }
    });
};
exports.default = handlePubrel;

},{}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const isBrowser = (typeof window !== 'undefined' && typeof window.document !== 'undefined') ||
    (typeof self === 'object' &&
        self.constructor &&
        self.constructor.name === 'DedicatedWorkerGlobalScope') ||
    (typeof navigator !== 'undefined' && navigator.product === 'ReactNative');
exports.default = isBrowser;

},{}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyMixin = exports.ErrorWithReasonCode = void 0;
class ErrorWithReasonCode extends Error {
    constructor(message, code) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ErrorWithReasonCode.prototype);
        Object.getPrototypeOf(this).name = 'ErrorWithReasonCode';
    }
}
exports.ErrorWithReasonCode = ErrorWithReasonCode;
function applyMixin(target, mixin, includeConstructor = false) {
    var _a;
    const inheritanceChain = [mixin];
    while (true) {
        const current = inheritanceChain[0];
        const base = Object.getPrototypeOf(current);
        if (base === null || base === void 0 ? void 0 : base.prototype) {
            inheritanceChain.unshift(base);
        }
        else {
            break;
        }
    }
    for (const ctor of inheritanceChain) {
        for (const prop of Object.getOwnPropertyNames(ctor.prototype)) {
            if (includeConstructor || prop !== 'constructor') {
                Object.defineProperty(target.prototype, prop, (_a = Object.getOwnPropertyDescriptor(ctor.prototype, prop)) !== null && _a !== void 0 ? _a : Object.create(null));
            }
        }
    }
}
exports.applyMixin = applyMixin;

},{}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const readable_stream_1 = require("readable-stream");
const streamsOpts = { objectMode: true };
const defaultStoreOptions = {
    clean: true,
};
class Store {
    constructor(options) {
        this.options = options || {};
        this.options = Object.assign(Object.assign({}, defaultStoreOptions), options);
        this._inflights = new Map();
    }
    put(packet, cb) {
        this._inflights.set(packet.messageId, packet);
        if (cb) {
            cb();
        }
        return this;
    }
    createStream() {
        const stream = new readable_stream_1.Readable(streamsOpts);
        const values = [];
        let destroyed = false;
        let i = 0;
        this._inflights.forEach((value, key) => {
            values.push(value);
        });
        stream._read = () => {
            if (!destroyed && i < values.length) {
                stream.push(values[i++]);
            }
            else {
                stream.push(null);
            }
        };
        stream.destroy = (err) => {
            if (destroyed) {
                return;
            }
            destroyed = true;
            setTimeout(() => {
                stream.emit('close');
            }, 0);
            return stream;
        };
        return stream;
    }
    del(packet, cb) {
        const toDelete = this._inflights.get(packet.messageId);
        if (toDelete) {
            this._inflights.delete(packet.messageId);
            cb(null, toDelete);
        }
        else if (cb) {
            cb(new Error('missing packet'));
        }
        return this;
    }
    get(packet, cb) {
        const storedPacket = this._inflights.get(packet.messageId);
        if (storedPacket) {
            cb(null, storedPacket);
        }
        else if (cb) {
            cb(new Error('missing packet'));
        }
        return this;
    }
    close(cb) {
        if (this.options.clean) {
            this._inflights = null;
        }
        if (cb) {
            cb();
        }
    }
}
exports.default = Store;

},{"readable-stream":125}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class TopicAliasRecv {
    constructor(max) {
        this.aliasToTopic = {};
        this.max = max;
    }
    put(topic, alias) {
        if (alias === 0 || alias > this.max) {
            return false;
        }
        this.aliasToTopic[alias] = topic;
        this.length = Object.keys(this.aliasToTopic).length;
        return true;
    }
    getTopicByAlias(alias) {
        return this.aliasToTopic[alias];
    }
    clear() {
        this.aliasToTopic = {};
    }
}
exports.default = TopicAliasRecv;

},{}],20:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lru_cache_1 = __importDefault(require("lru-cache"));
const number_allocator_1 = require("number-allocator");
class TopicAliasSend {
    constructor(max) {
        if (max > 0) {
            this.aliasToTopic = new lru_cache_1.default({ max });
            this.topicToAlias = {};
            this.numberAllocator = new number_allocator_1.NumberAllocator(1, max);
            this.max = max;
            this.length = 0;
        }
    }
    put(topic, alias) {
        if (alias === 0 || alias > this.max) {
            return false;
        }
        const entry = this.aliasToTopic.get(alias);
        if (entry) {
            delete this.topicToAlias[entry];
        }
        this.aliasToTopic.set(alias, topic);
        this.topicToAlias[topic] = alias;
        this.numberAllocator.use(alias);
        this.length = this.aliasToTopic.size;
        return true;
    }
    getTopicByAlias(alias) {
        return this.aliasToTopic.get(alias);
    }
    getAliasByTopic(topic) {
        const alias = this.topicToAlias[topic];
        if (typeof alias !== 'undefined') {
            this.aliasToTopic.get(alias);
        }
        return alias;
    }
    clear() {
        this.aliasToTopic.clear();
        this.topicToAlias = {};
        this.numberAllocator.clear();
        this.length = 0;
    }
    getLruAlias() {
        const alias = this.numberAllocator.firstVacant();
        if (alias)
            return alias;
        return [...this.aliasToTopic.keys()][this.aliasToTopic.size - 1];
    }
}
exports.default = TopicAliasSend;

},{"lru-cache":72,"number-allocator":98}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const number_allocator_1 = require("number-allocator");
class UniqueMessageIdProvider {
    constructor() {
        this.numberAllocator = new number_allocator_1.NumberAllocator(1, 65535);
    }
    allocate() {
        this.lastId = this.numberAllocator.alloc();
        return this.lastId;
    }
    getLastAllocated() {
        return this.lastId;
    }
    register(messageId) {
        return this.numberAllocator.use(messageId);
    }
    deallocate(messageId) {
        this.numberAllocator.free(messageId);
    }
    clear() {
        this.numberAllocator.clear();
    }
}
exports.default = UniqueMessageIdProvider;

},{"number-allocator":98}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateTopics = exports.validateTopic = void 0;
function validateTopic(topic) {
    const parts = topic.split('/');
    for (let i = 0; i < parts.length; i++) {
        if (parts[i] === '+') {
            continue;
        }
        if (parts[i] === '#') {
            return i === parts.length - 1;
        }
        if (parts[i].indexOf('+') !== -1 || parts[i].indexOf('#') !== -1) {
            return false;
        }
    }
    return true;
}
exports.validateTopic = validateTopic;
function validateTopics(topics) {
    if (topics.length === 0) {
        return 'empty_topic_list';
    }
    for (let i = 0; i < topics.length; i++) {
        if (!validateTopic(topics[i])) {
            return topics[i];
        }
    }
    return null;
}
exports.validateTopics = validateTopics;

},{}],23:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReasonCodes = exports.UniqueMessageIdProvider = exports.DefaultMessageIdProvider = exports.Store = exports.MqttClient = exports.connectAsync = exports.connect = exports.Client = void 0;
const client_1 = __importDefault(require("./lib/client"));
exports.MqttClient = client_1.default;
const default_message_id_provider_1 = __importDefault(require("./lib/default-message-id-provider"));
exports.DefaultMessageIdProvider = default_message_id_provider_1.default;
const unique_message_id_provider_1 = __importDefault(require("./lib/unique-message-id-provider"));
exports.UniqueMessageIdProvider = unique_message_id_provider_1.default;
const store_1 = __importDefault(require("./lib/store"));
exports.Store = store_1.default;
const connect_1 = __importStar(require("./lib/connect"));
exports.connect = connect_1.default;
Object.defineProperty(exports, "connectAsync", { enumerable: true, get: function () { return connect_1.connectAsync; } });
exports.Client = client_1.default;
__exportStar(require("./lib/client"), exports);
__exportStar(require("./lib/shared"), exports);
var ack_1 = require("./lib/handlers/ack");
Object.defineProperty(exports, "ReasonCodes", { enumerable: true, get: function () { return ack_1.ReasonCodes; } });

},{"./lib/client":2,"./lib/connect":4,"./lib/default-message-id-provider":9,"./lib/handlers/ack":10,"./lib/shared":17,"./lib/store":18,"./lib/unique-message-id-provider":21}],24:[function(require,module,exports){
/*globals self, window */
"use strict"

/*eslint-disable @mysticatea/prettier */
const { AbortController, AbortSignal } =
    typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window :
    /* otherwise */ undefined
/*eslint-enable @mysticatea/prettier */

module.exports = AbortController
module.exports.AbortSignal = AbortSignal
module.exports.default = AbortController

},{}],25:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],26:[function(require,module,exports){

},{}],27:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":29}],28:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":27}],29:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":25,"buffer":29,"ieee754":50}],30:[function(require,module,exports){
(function (process){(function (){
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = require('./common')(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

}).call(this)}).call(this,require('_process'))
},{"./common":31,"_process":102}],31:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = require('ms');
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;

},{"ms":97}],32:[function(require,module,exports){
(function (process,Buffer){(function (){
var stream = require('readable-stream')
var eos = require('end-of-stream')
var inherits = require('inherits')
var shift = require('stream-shift')

var SIGNAL_FLUSH = (Buffer.from && Buffer.from !== Uint8Array.from)
  ? Buffer.from([0])
  : new Buffer([0])

var onuncork = function(self, fn) {
  if (self._corked) self.once('uncork', fn)
  else fn()
}

var autoDestroy = function (self, err) {
  if (self._autoDestroy) self.destroy(err)
}

var destroyer = function(self, end) {
  return function(err) {
    if (err) autoDestroy(self, err.message === 'premature close' ? null : err)
    else if (end && !self._ended) self.end()
  }
}

var end = function(ws, fn) {
  if (!ws) return fn()
  if (ws._writableState && ws._writableState.finished) return fn()
  if (ws._writableState) return ws.end(fn)
  ws.end()
  fn()
}

var noop = function() {}

var toStreams2 = function(rs) {
  return new (stream.Readable)({objectMode:true, highWaterMark:16}).wrap(rs)
}

var Duplexify = function(writable, readable, opts) {
  if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts)
  stream.Duplex.call(this, opts)

  this._writable = null
  this._readable = null
  this._readable2 = null

  this._autoDestroy = !opts || opts.autoDestroy !== false
  this._forwardDestroy = !opts || opts.destroy !== false
  this._forwardEnd = !opts || opts.end !== false
  this._corked = 1 // start corked
  this._ondrain = null
  this._drained = false
  this._forwarding = false
  this._unwrite = null
  this._unread = null
  this._ended = false

  this.destroyed = false

  if (writable) this.setWritable(writable)
  if (readable) this.setReadable(readable)
}

inherits(Duplexify, stream.Duplex)

Duplexify.obj = function(writable, readable, opts) {
  if (!opts) opts = {}
  opts.objectMode = true
  opts.highWaterMark = 16
  return new Duplexify(writable, readable, opts)
}

Duplexify.prototype.cork = function() {
  if (++this._corked === 1) this.emit('cork')
}

Duplexify.prototype.uncork = function() {
  if (this._corked && --this._corked === 0) this.emit('uncork')
}

Duplexify.prototype.setWritable = function(writable) {
  if (this._unwrite) this._unwrite()

  if (this.destroyed) {
    if (writable && writable.destroy) writable.destroy()
    return
  }

  if (writable === null || writable === false) {
    this.end()
    return
  }

  var self = this
  var unend = eos(writable, {writable:true, readable:false}, destroyer(this, this._forwardEnd))

  var ondrain = function() {
    var ondrain = self._ondrain
    self._ondrain = null
    if (ondrain) ondrain()
  }

  var clear = function() {
    self._writable.removeListener('drain', ondrain)
    unend()
  }

  if (this._unwrite) process.nextTick(ondrain) // force a drain on stream reset to avoid livelocks

  this._writable = writable
  this._writable.on('drain', ondrain)
  this._unwrite = clear

  this.uncork() // always uncork setWritable
}

Duplexify.prototype.setReadable = function(readable) {
  if (this._unread) this._unread()

  if (this.destroyed) {
    if (readable && readable.destroy) readable.destroy()
    return
  }

  if (readable === null || readable === false) {
    this.push(null)
    this.resume()
    return
  }

  var self = this
  var unend = eos(readable, {writable:false, readable:true}, destroyer(this))

  var onreadable = function() {
    self._forward()
  }

  var onend = function() {
    self.push(null)
  }

  var clear = function() {
    self._readable2.removeListener('readable', onreadable)
    self._readable2.removeListener('end', onend)
    unend()
  }

  this._drained = true
  this._readable = readable
  this._readable2 = readable._readableState ? readable : toStreams2(readable)
  this._readable2.on('readable', onreadable)
  this._readable2.on('end', onend)
  this._unread = clear

  this._forward()
}

Duplexify.prototype._read = function() {
  this._drained = true
  this._forward()
}

Duplexify.prototype._forward = function() {
  if (this._forwarding || !this._readable2 || !this._drained) return
  this._forwarding = true

  var data

  while (this._drained && (data = shift(this._readable2)) !== null) {
    if (this.destroyed) continue
    this._drained = this.push(data)
  }

  this._forwarding = false
}

Duplexify.prototype.destroy = function(err, cb) {
  if (!cb) cb = noop
  if (this.destroyed) return cb(null)
  this.destroyed = true

  var self = this
  process.nextTick(function() {
    self._destroy(err)
    cb(null)
  })
}

Duplexify.prototype._destroy = function(err) {
  if (err) {
    var ondrain = this._ondrain
    this._ondrain = null
    if (ondrain) ondrain(err)
    else this.emit('error', err)
  }

  if (this._forwardDestroy) {
    if (this._readable && this._readable.destroy) this._readable.destroy()
    if (this._writable && this._writable.destroy) this._writable.destroy()
  }

  this.emit('close')
}

Duplexify.prototype._write = function(data, enc, cb) {
  if (this.destroyed) return
  if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb))
  if (data === SIGNAL_FLUSH) return this._finish(cb)
  if (!this._writable) return cb()

  if (this._writable.write(data) === false) this._ondrain = cb
  else if (!this.destroyed) cb()
}

Duplexify.prototype._finish = function(cb) {
  var self = this
  this.emit('preend')
  onuncork(this, function() {
    end(self._forwardEnd && self._writable, function() {
      // haxx to not emit prefinish twice
      if (self._writableState.prefinished === false) self._writableState.prefinished = true
      self.emit('prefinish')
      onuncork(self, cb)
    })
  })
}

Duplexify.prototype.end = function(data, enc, cb) {
  if (typeof data === 'function') return this.end(null, null, data)
  if (typeof enc === 'function') return this.end(data, null, enc)
  this._ended = true
  if (data) this.write(data)
  if (!this._writableState.ending && !this._writableState.destroyed) this.write(SIGNAL_FLUSH)
  return stream.Writable.prototype.end.call(this, cb)
}

module.exports = Duplexify

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":102,"buffer":29,"end-of-stream":48,"inherits":51,"readable-stream":47,"stream-shift":135}],33:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],34:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))
},{"./_stream_readable":36,"./_stream_writable":38,"_process":102,"inherits":51}],35:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":37,"inherits":51}],36:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":33,"./_stream_duplex":34,"./internal/streams/async_iterator":39,"./internal/streams/buffer_list":40,"./internal/streams/destroy":41,"./internal/streams/from":43,"./internal/streams/state":45,"./internal/streams/stream":46,"_process":102,"buffer":29,"events":49,"inherits":51,"string_decoder/":136,"util":26}],37:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":33,"./_stream_duplex":34,"inherits":51}],38:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":33,"./_stream_duplex":34,"./internal/streams/destroy":41,"./internal/streams/state":45,"./internal/streams/stream":46,"_process":102,"buffer":29,"inherits":51,"util-deprecate":139}],39:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))
},{"./end-of-stream":42,"_process":102}],40:[function(require,module,exports){
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
},{"buffer":29,"util":26}],41:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))
},{"_process":102}],42:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
},{"../../../errors":33}],43:[function(require,module,exports){
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

},{}],44:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
},{"../../../errors":33,"./end-of-stream":42}],45:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":33}],46:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":49}],47:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

},{"./lib/_stream_duplex.js":34,"./lib/_stream_passthrough.js":35,"./lib/_stream_readable.js":36,"./lib/_stream_transform.js":37,"./lib/_stream_writable.js":38,"./lib/internal/streams/end-of-stream.js":42,"./lib/internal/streams/pipeline.js":44}],48:[function(require,module,exports){
(function (process){(function (){
var once = require('once');

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);
	var cancelled = false;

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback.call(stream);
	};

	var onend = function() {
		readable = false;
		if (!writable) callback.call(stream);
	};

	var onexit = function(exitCode) {
		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onerror = function(err) {
		callback.call(stream, err);
	};

	var onclose = function() {
		process.nextTick(onclosenexttick);
	};

	var onclosenexttick = function() {
		if (cancelled) return;
		if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));
		if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', onerror);
	stream.on('close', onclose);

	return function() {
		cancelled = true;
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', onerror);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;

}).call(this)}).call(this,require('_process'))
},{"_process":102,"once":100}],49:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],50:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],51:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

exports.ContainerIterator = exports.Container = exports.Base = void 0;

class ContainerIterator {
    constructor(t = 0) {
        this.iteratorType = t;
    }
    equals(t) {
        return this.o === t.o;
    }
}

exports.ContainerIterator = ContainerIterator;

class Base {
    constructor() {
        this.i = 0;
    }
    get length() {
        return this.i;
    }
    size() {
        return this.i;
    }
    empty() {
        return this.i === 0;
    }
}

exports.Base = Base;

class Container extends Base {}

exports.Container = Container;


},{}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

exports.HashContainerIterator = exports.HashContainer = void 0;

var _ContainerBase = require("../../ContainerBase");

var _checkObject = _interopRequireDefault(require("../../../utils/checkObject"));

var _throwError = require("../../../utils/throwError");

function _interopRequireDefault(t) {
    return t && t.t ? t : {
        default: t
    };
}

class HashContainerIterator extends _ContainerBase.ContainerIterator {
    constructor(t, e, i) {
        super(i);
        this.o = t;
        this.h = e;
        if (this.iteratorType === 0) {
            this.pre = function() {
                if (this.o.L === this.h) {
                    (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.L;
                return this;
            };
            this.next = function() {
                if (this.o === this.h) {
                    (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.B;
                return this;
            };
        } else {
            this.pre = function() {
                if (this.o.B === this.h) {
                    (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.B;
                return this;
            };
            this.next = function() {
                if (this.o === this.h) {
                    (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.L;
                return this;
            };
        }
    }
}

exports.HashContainerIterator = HashContainerIterator;

class HashContainer extends _ContainerBase.Container {
    constructor() {
        super();
        this.H = [];
        this.g = {};
        this.HASH_TAG = Symbol("@@HASH_TAG");
        Object.setPrototypeOf(this.g, null);
        this.h = {};
        this.h.L = this.h.B = this.p = this._ = this.h;
    }
    V(t) {
        const {L: e, B: i} = t;
        e.B = i;
        i.L = e;
        if (t === this.p) {
            this.p = i;
        }
        if (t === this._) {
            this._ = e;
        }
        this.i -= 1;
    }
    M(t, e, i) {
        if (i === undefined) i = (0, _checkObject.default)(t);
        let s;
        if (i) {
            const i = t[this.HASH_TAG];
            if (i !== undefined) {
                this.H[i].l = e;
                return this.i;
            }
            Object.defineProperty(t, this.HASH_TAG, {
                value: this.H.length,
                configurable: true
            });
            s = {
                u: t,
                l: e,
                L: this._,
                B: this.h
            };
            this.H.push(s);
        } else {
            const i = this.g[t];
            if (i) {
                i.l = e;
                return this.i;
            }
            s = {
                u: t,
                l: e,
                L: this._,
                B: this.h
            };
            this.g[t] = s;
        }
        if (this.i === 0) {
            this.p = s;
            this.h.B = s;
        } else {
            this._.B = s;
        }
        this._ = s;
        this.h.L = s;
        return ++this.i;
    }
    I(t, e) {
        if (e === undefined) e = (0, _checkObject.default)(t);
        if (e) {
            const e = t[this.HASH_TAG];
            if (e === undefined) return this.h;
            return this.H[e];
        } else {
            return this.g[t] || this.h;
        }
    }
    clear() {
        const t = this.HASH_TAG;
        this.H.forEach((function(e) {
            delete e.u[t];
        }));
        this.H = [];
        this.g = {};
        Object.setPrototypeOf(this.g, null);
        this.i = 0;
        this.p = this._ = this.h.L = this.h.B = this.h;
    }
    eraseElementByKey(t, e) {
        let i;
        if (e === undefined) e = (0, _checkObject.default)(t);
        if (e) {
            const e = t[this.HASH_TAG];
            if (e === undefined) return false;
            delete t[this.HASH_TAG];
            i = this.H[e];
            delete this.H[e];
        } else {
            i = this.g[t];
            if (i === undefined) return false;
            delete this.g[t];
        }
        this.V(i);
        return true;
    }
    eraseElementByIterator(t) {
        const e = t.o;
        if (e === this.h) {
            (0, _throwError.throwIteratorAccessError)();
        }
        this.V(e);
        return t.next();
    }
    eraseElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
            throw new RangeError;
        }
        let e = this.p;
        while (t--) {
            e = e.B;
        }
        this.V(e);
        return this.i;
    }
}

exports.HashContainer = HashContainer;


},{"../../../utils/checkObject":70,"../../../utils/throwError":71,"../../ContainerBase":52}],54:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

exports.default = void 0;

var _Base = require("./Base");

var _checkObject = _interopRequireDefault(require("../../utils/checkObject"));

var _throwError = require("../../utils/throwError");

function _interopRequireDefault(t) {
    return t && t.t ? t : {
        default: t
    };
}

class HashMapIterator extends _Base.HashContainerIterator {
    constructor(t, e, r, s) {
        super(t, e, s);
        this.container = r;
    }
    get pointer() {
        if (this.o === this.h) {
            (0, _throwError.throwIteratorAccessError)();
        }
        const t = this;
        return new Proxy([], {
            get(e, r) {
                if (r === "0") return t.o.u; else if (r === "1") return t.o.l;
            },
            set(e, r, s) {
                if (r !== "1") {
                    throw new TypeError("props must be 1");
                }
                t.o.l = s;
                return true;
            }
        });
    }
    copy() {
        return new HashMapIterator(this.o, this.h, this.container, this.iteratorType);
    }
}

class HashMap extends _Base.HashContainer {
    constructor(t = []) {
        super();
        const e = this;
        t.forEach((function(t) {
            e.setElement(t[0], t[1]);
        }));
    }
    begin() {
        return new HashMapIterator(this.p, this.h, this);
    }
    end() {
        return new HashMapIterator(this.h, this.h, this);
    }
    rBegin() {
        return new HashMapIterator(this._, this.h, this, 1);
    }
    rEnd() {
        return new HashMapIterator(this.h, this.h, this, 1);
    }
    front() {
        if (this.i === 0) return;
        return [ this.p.u, this.p.l ];
    }
    back() {
        if (this.i === 0) return;
        return [ this._.u, this._.l ];
    }
    setElement(t, e, r) {
        return this.M(t, e, r);
    }
    getElementByKey(t, e) {
        if (e === undefined) e = (0, _checkObject.default)(t);
        if (e) {
            const e = t[this.HASH_TAG];
            return e !== undefined ? this.H[e].l : undefined;
        }
        const r = this.g[t];
        return r ? r.l : undefined;
    }
    getElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
            throw new RangeError;
        }
        let e = this.p;
        while (t--) {
            e = e.B;
        }
        return [ e.u, e.l ];
    }
    find(t, e) {
        const r = this.I(t, e);
        return new HashMapIterator(r, this.h, this);
    }
    forEach(t) {
        let e = 0;
        let r = this.p;
        while (r !== this.h) {
            t([ r.u, r.l ], e++, this);
            r = r.B;
        }
    }
    [Symbol.iterator]() {
        return function*() {
            let t = this.p;
            while (t !== this.h) {
                yield [ t.u, t.l ];
                t = t.B;
            }
        }.bind(this)();
    }
}

var _default = HashMap;

exports.default = _default;


},{"../../utils/checkObject":70,"../../utils/throwError":71,"./Base":53}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

exports.default = void 0;

var _Base = require("./Base");

var _throwError = require("../../utils/throwError");

class HashSetIterator extends _Base.HashContainerIterator {
    constructor(t, e, r, s) {
        super(t, e, s);
        this.container = r;
    }
    get pointer() {
        if (this.o === this.h) {
            (0, _throwError.throwIteratorAccessError)();
        }
        return this.o.u;
    }
    copy() {
        return new HashSetIterator(this.o, this.h, this.container, this.iteratorType);
    }
}

class HashSet extends _Base.HashContainer {
    constructor(t = []) {
        super();
        const e = this;
        t.forEach((function(t) {
            e.insert(t);
        }));
    }
    begin() {
        return new HashSetIterator(this.p, this.h, this);
    }
    end() {
        return new HashSetIterator(this.h, this.h, this);
    }
    rBegin() {
        return new HashSetIterator(this._, this.h, this, 1);
    }
    rEnd() {
        return new HashSetIterator(this.h, this.h, this, 1);
    }
    front() {
        return this.p.u;
    }
    back() {
        return this._.u;
    }
    insert(t, e) {
        return this.M(t, undefined, e);
    }
    getElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
            throw new RangeError;
        }
        let e = this.p;
        while (t--) {
            e = e.B;
        }
        return e.u;
    }
    find(t, e) {
        const r = this.I(t, e);
        return new HashSetIterator(r, this.h, this);
    }
    forEach(t) {
        let e = 0;
        let r = this.p;
        while (r !== this.h) {
            t(r.u, e++, this);
            r = r.B;
        }
    }
    [Symbol.iterator]() {
        return function*() {
            let t = this.p;
            while (t !== this.h) {
                yield t.u;
                t = t.B;
            }
        }.bind(this)();
    }
}

var _default = HashSet;

exports.default = _default;


},{"../../utils/throwError":71,"./Base":53}],56:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

exports.default = void 0;

var _ContainerBase = require("../ContainerBase");

class PriorityQueue extends _ContainerBase.Base {
    constructor(t = [], s = function(t, s) {
        if (t > s) return -1;
        if (t < s) return 1;
        return 0;
    }, i = true) {
        super();
        this.v = s;
        if (Array.isArray(t)) {
            this.C = i ? [ ...t ] : t;
        } else {
            this.C = [];
            const s = this;
            t.forEach((function(t) {
                s.C.push(t);
            }));
        }
        this.i = this.C.length;
        const e = this.i >> 1;
        for (let t = this.i - 1 >> 1; t >= 0; --t) {
            this.k(t, e);
        }
    }
    m(t) {
        const s = this.C[t];
        while (t > 0) {
            const i = t - 1 >> 1;
            const e = this.C[i];
            if (this.v(e, s) <= 0) break;
            this.C[t] = e;
            t = i;
        }
        this.C[t] = s;
    }
    k(t, s) {
        const i = this.C[t];
        while (t < s) {
            let s = t << 1 | 1;
            const e = s + 1;
            let h = this.C[s];
            if (e < this.i && this.v(h, this.C[e]) > 0) {
                s = e;
                h = this.C[e];
            }
            if (this.v(h, i) >= 0) break;
            this.C[t] = h;
            t = s;
        }
        this.C[t] = i;
    }
    clear() {
        this.i = 0;
        this.C.length = 0;
    }
    push(t) {
        this.C.push(t);
        this.m(this.i);
        this.i += 1;
    }
    pop() {
        if (this.i === 0) return;
        const t = this.C[0];
        const s = this.C.pop();
        this.i -= 1;
        if (this.i) {
            this.C[0] = s;
            this.k(0, this.i >> 1);
        }
        return t;
    }
    top() {
        return this.C[0];
    }
    find(t) {
        return this.C.indexOf(t) >= 0;
    }
    remove(t) {
        const s = this.C.indexOf(t);
        if (s < 0) return false;
        if (s === 0) {
            this.pop();
        } else if (s === this.i - 1) {
            this.C.pop();
            this.i -= 1;
        } else {
            this.C.splice(s, 1, this.C.pop());
            this.i -= 1;
            this.m(s);
            this.k(s, this.i >> 1);
        }
        return true;
    }
    updateItem(t) {
        const s = this.C.indexOf(t);
        if (s < 0) return false;
        this.m(s);
        this.k(s, this.i >> 1);
        return true;
    }
    toArray() {
        return [ ...this.C ];
    }
}

var _default = PriorityQueue;

exports.default = _default;


},{"../ContainerBase":52}],57:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

exports.default = void 0;

var _ContainerBase = require("../ContainerBase");

class Queue extends _ContainerBase.Base {
    constructor(t = []) {
        super();
        this.j = 0;
        this.q = [];
        const s = this;
        t.forEach((function(t) {
            s.push(t);
        }));
    }
    clear() {
        this.q = [];
        this.i = this.j = 0;
    }
    push(t) {
        const s = this.q.length;
        if (this.j / s > .5 && this.j + this.i >= s && s > 4096) {
            const s = this.i;
            for (let t = 0; t < s; ++t) {
                this.q[t] = this.q[this.j + t];
            }
            this.j = 0;
            this.q[this.i] = t;
        } else this.q[this.j + this.i] = t;
        return ++this.i;
    }
    pop() {
        if (this.i === 0) return;
        const t = this.q[this.j++];
        this.i -= 1;
        return t;
    }
    front() {
        if (this.i === 0) return;
        return this.q[this.j];
    }
}

var _default = Queue;

exports.default = _default;


},{"../ContainerBase":52}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

exports.default = void 0;

var _ContainerBase = require("../ContainerBase");

class Stack extends _ContainerBase.Base {
    constructor(t = []) {
        super();
        this.S = [];
        const s = this;
        t.forEach((function(t) {
            s.push(t);
        }));
    }
    clear() {
        this.i = 0;
        this.S = [];
    }
    push(t) {
        this.S.push(t);
        this.i += 1;
        return this.i;
    }
    pop() {
        if (this.i === 0) return;
        this.i -= 1;
        return this.S.pop();
    }
    top() {
        return this.S[this.i - 1];
    }
}

var _default = Stack;

exports.default = _default;


},{"../ContainerBase":52}],59:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

exports.RandomIterator = void 0;

var _ContainerBase = require("../../ContainerBase");

var _throwError = require("../../../utils/throwError");

class RandomIterator extends _ContainerBase.ContainerIterator {
    constructor(t, r) {
        super(r);
        this.o = t;
        if (this.iteratorType === 0) {
            this.pre = function() {
                if (this.o === 0) {
                    (0, _throwError.throwIteratorAccessError)();
                }
                this.o -= 1;
                return this;
            };
            this.next = function() {
                if (this.o === this.container.size()) {
                    (0, _throwError.throwIteratorAccessError)();
                }
                this.o += 1;
                return this;
            };
        } else {
            this.pre = function() {
                if (this.o === this.container.size() - 1) {
                    (0, _throwError.throwIteratorAccessError)();
                }
                this.o += 1;
                return this;
            };
            this.next = function() {
                if (this.o === -1) {
                    (0, _throwError.throwIteratorAccessError)();
                }
                this.o -= 1;
                return this;
            };
        }
    }
    get pointer() {
        return this.container.getElementByPos(this.o);
    }
    set pointer(t) {
        this.container.setElementByPos(this.o, t);
    }
}

exports.RandomIterator = RandomIterator;


},{"../../../utils/throwError":71,"../../ContainerBase":52}],60:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

exports.default = void 0;

var _ContainerBase = require("../../ContainerBase");

class SequentialContainer extends _ContainerBase.Container {}

var _default = SequentialContainer;

exports.default = _default;


},{"../../ContainerBase":52}],61:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

exports.default = void 0;

var _Base = _interopRequireDefault(require("./Base"));

var _RandomIterator = require("./Base/RandomIterator");

function _interopRequireDefault(t) {
    return t && t.t ? t : {
        default: t
    };
}

class DequeIterator extends _RandomIterator.RandomIterator {
    constructor(t, i, s) {
        super(t, s);
        this.container = i;
    }
    copy() {
        return new DequeIterator(this.o, this.container, this.iteratorType);
    }
}

class Deque extends _Base.default {
    constructor(t = [], i = 1 << 12) {
        super();
        this.j = 0;
        this.D = 0;
        this.R = 0;
        this.N = 0;
        this.P = 0;
        this.A = [];
        const s = (() => {
            if (typeof t.length === "number") return t.length;
            if (typeof t.size === "number") return t.size;
            if (typeof t.size === "function") return t.size();
            throw new TypeError("Cannot get the length or size of the container");
        })();
        this.F = i;
        this.P = Math.max(Math.ceil(s / this.F), 1);
        for (let t = 0; t < this.P; ++t) {
            this.A.push(new Array(this.F));
        }
        const h = Math.ceil(s / this.F);
        this.j = this.R = (this.P >> 1) - (h >> 1);
        this.D = this.N = this.F - s % this.F >> 1;
        const e = this;
        t.forEach((function(t) {
            e.pushBack(t);
        }));
    }
    T() {
        const t = [];
        const i = Math.max(this.P >> 1, 1);
        for (let s = 0; s < i; ++s) {
            t[s] = new Array(this.F);
        }
        for (let i = this.j; i < this.P; ++i) {
            t[t.length] = this.A[i];
        }
        for (let i = 0; i < this.R; ++i) {
            t[t.length] = this.A[i];
        }
        t[t.length] = [ ...this.A[this.R] ];
        this.j = i;
        this.R = t.length - 1;
        for (let s = 0; s < i; ++s) {
            t[t.length] = new Array(this.F);
        }
        this.A = t;
        this.P = t.length;
    }
    O(t) {
        const i = this.D + t + 1;
        const s = i % this.F;
        let h = s - 1;
        let e = this.j + (i - s) / this.F;
        if (s === 0) e -= 1;
        e %= this.P;
        if (h < 0) h += this.F;
        return {
            curNodeBucketIndex: e,
            curNodePointerIndex: h
        };
    }
    clear() {
        this.A = [ new Array(this.F) ];
        this.P = 1;
        this.j = this.R = this.i = 0;
        this.D = this.N = this.F >> 1;
    }
    begin() {
        return new DequeIterator(0, this);
    }
    end() {
        return new DequeIterator(this.i, this);
    }
    rBegin() {
        return new DequeIterator(this.i - 1, this, 1);
    }
    rEnd() {
        return new DequeIterator(-1, this, 1);
    }
    front() {
        if (this.i === 0) return;
        return this.A[this.j][this.D];
    }
    back() {
        if (this.i === 0) return;
        return this.A[this.R][this.N];
    }
    pushBack(t) {
        if (this.i) {
            if (this.N < this.F - 1) {
                this.N += 1;
            } else if (this.R < this.P - 1) {
                this.R += 1;
                this.N = 0;
            } else {
                this.R = 0;
                this.N = 0;
            }
            if (this.R === this.j && this.N === this.D) this.T();
        }
        this.i += 1;
        this.A[this.R][this.N] = t;
        return this.i;
    }
    popBack() {
        if (this.i === 0) return;
        const t = this.A[this.R][this.N];
        if (this.i !== 1) {
            if (this.N > 0) {
                this.N -= 1;
            } else if (this.R > 0) {
                this.R -= 1;
                this.N = this.F - 1;
            } else {
                this.R = this.P - 1;
                this.N = this.F - 1;
            }
        }
        this.i -= 1;
        return t;
    }
    pushFront(t) {
        if (this.i) {
            if (this.D > 0) {
                this.D -= 1;
            } else if (this.j > 0) {
                this.j -= 1;
                this.D = this.F - 1;
            } else {
                this.j = this.P - 1;
                this.D = this.F - 1;
            }
            if (this.j === this.R && this.D === this.N) this.T();
        }
        this.i += 1;
        this.A[this.j][this.D] = t;
        return this.i;
    }
    popFront() {
        if (this.i === 0) return;
        const t = this.A[this.j][this.D];
        if (this.i !== 1) {
            if (this.D < this.F - 1) {
                this.D += 1;
            } else if (this.j < this.P - 1) {
                this.j += 1;
                this.D = 0;
            } else {
                this.j = 0;
                this.D = 0;
            }
        }
        this.i -= 1;
        return t;
    }
    getElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
            throw new RangeError;
        }
        const {curNodeBucketIndex: i, curNodePointerIndex: s} = this.O(t);
        return this.A[i][s];
    }
    setElementByPos(t, i) {
        if (t < 0 || t > this.i - 1) {
            throw new RangeError;
        }
        const {curNodeBucketIndex: s, curNodePointerIndex: h} = this.O(t);
        this.A[s][h] = i;
    }
    insert(t, i, s = 1) {
        if (t < 0 || t > this.i) {
            throw new RangeError;
        }
        if (t === 0) {
            while (s--) this.pushFront(i);
        } else if (t === this.i) {
            while (s--) this.pushBack(i);
        } else {
            const h = [];
            for (let i = t; i < this.i; ++i) {
                h.push(this.getElementByPos(i));
            }
            this.cut(t - 1);
            for (let t = 0; t < s; ++t) this.pushBack(i);
            for (let t = 0; t < h.length; ++t) this.pushBack(h[t]);
        }
        return this.i;
    }
    cut(t) {
        if (t < 0) {
            this.clear();
            return 0;
        }
        const {curNodeBucketIndex: i, curNodePointerIndex: s} = this.O(t);
        this.R = i;
        this.N = s;
        this.i = t + 1;
        return this.i;
    }
    eraseElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
            throw new RangeError;
        }
        if (t === 0) this.popFront(); else if (t === this.i - 1) this.popBack(); else {
            const i = [];
            for (let s = t + 1; s < this.i; ++s) {
                i.push(this.getElementByPos(s));
            }
            this.cut(t);
            this.popBack();
            const s = this;
            i.forEach((function(t) {
                s.pushBack(t);
            }));
        }
        return this.i;
    }
    eraseElementByValue(t) {
        if (this.i === 0) return 0;
        const i = [];
        for (let s = 0; s < this.i; ++s) {
            const h = this.getElementByPos(s);
            if (h !== t) i.push(h);
        }
        const s = i.length;
        for (let t = 0; t < s; ++t) this.setElementByPos(t, i[t]);
        return this.cut(s - 1);
    }
    eraseElementByIterator(t) {
        const i = t.o;
        this.eraseElementByPos(i);
        t = t.next();
        return t;
    }
    find(t) {
        for (let i = 0; i < this.i; ++i) {
            if (this.getElementByPos(i) === t) {
                return new DequeIterator(i, this);
            }
        }
        return this.end();
    }
    reverse() {
        let t = 0;
        let i = this.i - 1;
        while (t < i) {
            const s = this.getElementByPos(t);
            this.setElementByPos(t, this.getElementByPos(i));
            this.setElementByPos(i, s);
            t += 1;
            i -= 1;
        }
    }
    unique() {
        if (this.i <= 1) {
            return this.i;
        }
        let t = 1;
        let i = this.getElementByPos(0);
        for (let s = 1; s < this.i; ++s) {
            const h = this.getElementByPos(s);
            if (h !== i) {
                i = h;
                this.setElementByPos(t++, h);
            }
        }
        while (this.i > t) this.popBack();
        return this.i;
    }
    sort(t) {
        const i = [];
        for (let t = 0; t < this.i; ++t) {
            i.push(this.getElementByPos(t));
        }
        i.sort(t);
        for (let t = 0; t < this.i; ++t) this.setElementByPos(t, i[t]);
    }
    shrinkToFit() {
        if (this.i === 0) return;
        const t = [];
        this.forEach((function(i) {
            t.push(i);
        }));
        this.P = Math.max(Math.ceil(this.i / this.F), 1);
        this.i = this.j = this.R = this.D = this.N = 0;
        this.A = [];
        for (let t = 0; t < this.P; ++t) {
            this.A.push(new Array(this.F));
        }
        for (let i = 0; i < t.length; ++i) this.pushBack(t[i]);
    }
    forEach(t) {
        for (let i = 0; i < this.i; ++i) {
            t(this.getElementByPos(i), i, this);
        }
    }
    [Symbol.iterator]() {
        return function*() {
            for (let t = 0; t < this.i; ++t) {
                yield this.getElementByPos(t);
            }
        }.bind(this)();
    }
}

var _default = Deque;

exports.default = _default;


},{"./Base":60,"./Base/RandomIterator":59}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

exports.default = void 0;

var _Base = _interopRequireDefault(require("./Base"));

var _ContainerBase = require("../ContainerBase");

var _throwError = require("../../utils/throwError");

function _interopRequireDefault(t) {
    return t && t.t ? t : {
        default: t
    };
}

class LinkListIterator extends _ContainerBase.ContainerIterator {
    constructor(t, i, s, r) {
        super(r);
        this.o = t;
        this.h = i;
        this.container = s;
        if (this.iteratorType === 0) {
            this.pre = function() {
                if (this.o.L === this.h) {
                    (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.L;
                return this;
            };
            this.next = function() {
                if (this.o === this.h) {
                    (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.B;
                return this;
            };
        } else {
            this.pre = function() {
                if (this.o.B === this.h) {
                    (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.B;
                return this;
            };
            this.next = function() {
                if (this.o === this.h) {
                    (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.L;
                return this;
            };
        }
    }
    get pointer() {
        if (this.o === this.h) {
            (0, _throwError.throwIteratorAccessError)();
        }
        return this.o.l;
    }
    set pointer(t) {
        if (this.o === this.h) {
            (0, _throwError.throwIteratorAccessError)();
        }
        this.o.l = t;
    }
    copy() {
        return new LinkListIterator(this.o, this.h, this.container, this.iteratorType);
    }
}

class LinkList extends _Base.default {
    constructor(t = []) {
        super();
        this.h = {};
        this.p = this._ = this.h.L = this.h.B = this.h;
        const i = this;
        t.forEach((function(t) {
            i.pushBack(t);
        }));
    }
    V(t) {
        const {L: i, B: s} = t;
        i.B = s;
        s.L = i;
        if (t === this.p) {
            this.p = s;
        }
        if (t === this._) {
            this._ = i;
        }
        this.i -= 1;
    }
    G(t, i) {
        const s = i.B;
        const r = {
            l: t,
            L: i,
            B: s
        };
        i.B = r;
        s.L = r;
        if (i === this.h) {
            this.p = r;
        }
        if (s === this.h) {
            this._ = r;
        }
        this.i += 1;
    }
    clear() {
        this.i = 0;
        this.p = this._ = this.h.L = this.h.B = this.h;
    }
    begin() {
        return new LinkListIterator(this.p, this.h, this);
    }
    end() {
        return new LinkListIterator(this.h, this.h, this);
    }
    rBegin() {
        return new LinkListIterator(this._, this.h, this, 1);
    }
    rEnd() {
        return new LinkListIterator(this.h, this.h, this, 1);
    }
    front() {
        return this.p.l;
    }
    back() {
        return this._.l;
    }
    getElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
            throw new RangeError;
        }
        let i = this.p;
        while (t--) {
            i = i.B;
        }
        return i.l;
    }
    eraseElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
            throw new RangeError;
        }
        let i = this.p;
        while (t--) {
            i = i.B;
        }
        this.V(i);
        return this.i;
    }
    eraseElementByValue(t) {
        let i = this.p;
        while (i !== this.h) {
            if (i.l === t) {
                this.V(i);
            }
            i = i.B;
        }
        return this.i;
    }
    eraseElementByIterator(t) {
        const i = t.o;
        if (i === this.h) {
            (0, _throwError.throwIteratorAccessError)();
        }
        t = t.next();
        this.V(i);
        return t;
    }
    pushBack(t) {
        this.G(t, this._);
        return this.i;
    }
    popBack() {
        if (this.i === 0) return;
        const t = this._.l;
        this.V(this._);
        return t;
    }
    pushFront(t) {
        this.G(t, this.h);
        return this.i;
    }
    popFront() {
        if (this.i === 0) return;
        const t = this.p.l;
        this.V(this.p);
        return t;
    }
    setElementByPos(t, i) {
        if (t < 0 || t > this.i - 1) {
            throw new RangeError;
        }
        let s = this.p;
        while (t--) {
            s = s.B;
        }
        s.l = i;
    }
    insert(t, i, s = 1) {
        if (t < 0 || t > this.i) {
            throw new RangeError;
        }
        if (s <= 0) return this.i;
        if (t === 0) {
            while (s--) this.pushFront(i);
        } else if (t === this.i) {
            while (s--) this.pushBack(i);
        } else {
            let r = this.p;
            for (let i = 1; i < t; ++i) {
                r = r.B;
            }
            const e = r.B;
            this.i += s;
            while (s--) {
                r.B = {
                    l: i,
                    L: r
                };
                r.B.L = r;
                r = r.B;
            }
            r.B = e;
            e.L = r;
        }
        return this.i;
    }
    find(t) {
        let i = this.p;
        while (i !== this.h) {
            if (i.l === t) {
                return new LinkListIterator(i, this.h, this);
            }
            i = i.B;
        }
        return this.end();
    }
    reverse() {
        if (this.i <= 1) return;
        let t = this.p;
        let i = this._;
        let s = 0;
        while (s << 1 < this.i) {
            const r = t.l;
            t.l = i.l;
            i.l = r;
            t = t.B;
            i = i.L;
            s += 1;
        }
    }
    unique() {
        if (this.i <= 1) {
            return this.i;
        }
        let t = this.p;
        while (t !== this.h) {
            let i = t;
            while (i.B !== this.h && i.l === i.B.l) {
                i = i.B;
                this.i -= 1;
            }
            t.B = i.B;
            t.B.L = t;
            t = t.B;
        }
        return this.i;
    }
    sort(t) {
        if (this.i <= 1) return;
        const i = [];
        this.forEach((function(t) {
            i.push(t);
        }));
        i.sort(t);
        let s = this.p;
        i.forEach((function(t) {
            s.l = t;
            s = s.B;
        }));
    }
    merge(t) {
        const i = this;
        if (this.i === 0) {
            t.forEach((function(t) {
                i.pushBack(t);
            }));
        } else {
            let s = this.p;
            t.forEach((function(t) {
                while (s !== i.h && s.l <= t) {
                    s = s.B;
                }
                i.G(t, s.L);
            }));
        }
        return this.i;
    }
    forEach(t) {
        let i = this.p;
        let s = 0;
        while (i !== this.h) {
            t(i.l, s++, this);
            i = i.B;
        }
    }
    [Symbol.iterator]() {
        return function*() {
            if (this.i === 0) return;
            let t = this.p;
            while (t !== this.h) {
                yield t.l;
                t = t.B;
            }
        }.bind(this)();
    }
}

var _default = LinkList;

exports.default = _default;


},{"../../utils/throwError":71,"../ContainerBase":52,"./Base":60}],63:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

exports.default = void 0;

var _Base = _interopRequireDefault(require("./Base"));

var _RandomIterator = require("./Base/RandomIterator");

function _interopRequireDefault(t) {
    return t && t.t ? t : {
        default: t
    };
}

class VectorIterator extends _RandomIterator.RandomIterator {
    constructor(t, r, e) {
        super(t, e);
        this.container = r;
    }
    copy() {
        return new VectorIterator(this.o, this.container, this.iteratorType);
    }
}

class Vector extends _Base.default {
    constructor(t = [], r = true) {
        super();
        if (Array.isArray(t)) {
            this.J = r ? [ ...t ] : t;
            this.i = t.length;
        } else {
            this.J = [];
            const r = this;
            t.forEach((function(t) {
                r.pushBack(t);
            }));
        }
    }
    clear() {
        this.i = 0;
        this.J.length = 0;
    }
    begin() {
        return new VectorIterator(0, this);
    }
    end() {
        return new VectorIterator(this.i, this);
    }
    rBegin() {
        return new VectorIterator(this.i - 1, this, 1);
    }
    rEnd() {
        return new VectorIterator(-1, this, 1);
    }
    front() {
        return this.J[0];
    }
    back() {
        return this.J[this.i - 1];
    }
    getElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
            throw new RangeError;
        }
        return this.J[t];
    }
    eraseElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
            throw new RangeError;
        }
        this.J.splice(t, 1);
        this.i -= 1;
        return this.i;
    }
    eraseElementByValue(t) {
        let r = 0;
        for (let e = 0; e < this.i; ++e) {
            if (this.J[e] !== t) {
                this.J[r++] = this.J[e];
            }
        }
        this.i = this.J.length = r;
        return this.i;
    }
    eraseElementByIterator(t) {
        const r = t.o;
        t = t.next();
        this.eraseElementByPos(r);
        return t;
    }
    pushBack(t) {
        this.J.push(t);
        this.i += 1;
        return this.i;
    }
    popBack() {
        if (this.i === 0) return;
        this.i -= 1;
        return this.J.pop();
    }
    setElementByPos(t, r) {
        if (t < 0 || t > this.i - 1) {
            throw new RangeError;
        }
        this.J[t] = r;
    }
    insert(t, r, e = 1) {
        if (t < 0 || t > this.i) {
            throw new RangeError;
        }
        this.J.splice(t, 0, ...new Array(e).fill(r));
        this.i += e;
        return this.i;
    }
    find(t) {
        for (let r = 0; r < this.i; ++r) {
            if (this.J[r] === t) {
                return new VectorIterator(r, this);
            }
        }
        return this.end();
    }
    reverse() {
        this.J.reverse();
    }
    unique() {
        let t = 1;
        for (let r = 1; r < this.i; ++r) {
            if (this.J[r] !== this.J[r - 1]) {
                this.J[t++] = this.J[r];
            }
        }
        this.i = this.J.length = t;
        return this.i;
    }
    sort(t) {
        this.J.sort(t);
    }
    forEach(t) {
        for (let r = 0; r < this.i; ++r) {
            t(this.J[r], r, this);
        }
    }
    [Symbol.iterator]() {
        return function*() {
            yield* this.J;
        }.bind(this)();
    }
}

var _default = Vector;

exports.default = _default;


},{"./Base":60,"./Base/RandomIterator":59}],64:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

exports.default = void 0;

var _ContainerBase = require("../../ContainerBase");

var _throwError = require("../../../utils/throwError");

class TreeIterator extends _ContainerBase.ContainerIterator {
    constructor(t, r, i) {
        super(i);
        this.o = t;
        this.h = r;
        if (this.iteratorType === 0) {
            this.pre = function() {
                if (this.o === this.h.U) {
                    (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.L();
                return this;
            };
            this.next = function() {
                if (this.o === this.h) {
                    (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.B();
                return this;
            };
        } else {
            this.pre = function() {
                if (this.o === this.h.W) {
                    (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.B();
                return this;
            };
            this.next = function() {
                if (this.o === this.h) {
                    (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.L();
                return this;
            };
        }
    }
    get index() {
        let t = this.o;
        const r = this.h.tt;
        if (t === this.h) {
            if (r) {
                return r.rt - 1;
            }
            return 0;
        }
        let i = 0;
        if (t.U) {
            i += t.U.rt;
        }
        while (t !== r) {
            const r = t.tt;
            if (t === r.W) {
                i += 1;
                if (r.U) {
                    i += r.U.rt;
                }
            }
            t = r;
        }
        return i;
    }
}

var _default = TreeIterator;

exports.default = _default;


},{"../../../utils/throwError":71,"../../ContainerBase":52}],65:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

exports.TreeNodeEnableIndex = exports.TreeNode = void 0;

class TreeNode {
    constructor(e, t) {
        this.ee = 1;
        this.u = undefined;
        this.l = undefined;
        this.U = undefined;
        this.W = undefined;
        this.tt = undefined;
        this.u = e;
        this.l = t;
    }
    L() {
        let e = this;
        if (e.ee === 1 && e.tt.tt === e) {
            e = e.W;
        } else if (e.U) {
            e = e.U;
            while (e.W) {
                e = e.W;
            }
        } else {
            let t = e.tt;
            while (t.U === e) {
                e = t;
                t = e.tt;
            }
            e = t;
        }
        return e;
    }
    B() {
        let e = this;
        if (e.W) {
            e = e.W;
            while (e.U) {
                e = e.U;
            }
            return e;
        } else {
            let t = e.tt;
            while (t.W === e) {
                e = t;
                t = e.tt;
            }
            if (e.W !== t) {
                return t;
            } else return e;
        }
    }
    te() {
        const e = this.tt;
        const t = this.W;
        const s = t.U;
        if (e.tt === this) e.tt = t; else if (e.U === this) e.U = t; else e.W = t;
        t.tt = e;
        t.U = this;
        this.tt = t;
        this.W = s;
        if (s) s.tt = this;
        return t;
    }
    se() {
        const e = this.tt;
        const t = this.U;
        const s = t.W;
        if (e.tt === this) e.tt = t; else if (e.U === this) e.U = t; else e.W = t;
        t.tt = e;
        t.W = this;
        this.tt = t;
        this.U = s;
        if (s) s.tt = this;
        return t;
    }
}

exports.TreeNode = TreeNode;

class TreeNodeEnableIndex extends TreeNode {
    constructor() {
        super(...arguments);
        this.rt = 1;
    }
    te() {
        const e = super.te();
        this.ie();
        e.ie();
        return e;
    }
    se() {
        const e = super.se();
        this.ie();
        e.ie();
        return e;
    }
    ie() {
        this.rt = 1;
        if (this.U) {
            this.rt += this.U.rt;
        }
        if (this.W) {
            this.rt += this.W.rt;
        }
    }
}

exports.TreeNodeEnableIndex = TreeNodeEnableIndex;


},{}],66:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

exports.default = void 0;

var _TreeNode = require("./TreeNode");

var _ContainerBase = require("../../ContainerBase");

var _throwError = require("../../../utils/throwError");

class TreeContainer extends _ContainerBase.Container {
    constructor(e = function(e, t) {
        if (e < t) return -1;
        if (e > t) return 1;
        return 0;
    }, t = false) {
        super();
        this.Y = undefined;
        this.v = e;
        if (t) {
            this.re = _TreeNode.TreeNodeEnableIndex;
            this.M = function(e, t, i) {
                const s = this.ne(e, t, i);
                if (s) {
                    let e = s.tt;
                    while (e !== this.h) {
                        e.rt += 1;
                        e = e.tt;
                    }
                    const t = this.he(s);
                    if (t) {
                        const {parentNode: e, grandParent: i, curNode: s} = t;
                        e.ie();
                        i.ie();
                        s.ie();
                    }
                }
                return this.i;
            };
            this.V = function(e) {
                let t = this.fe(e);
                while (t !== this.h) {
                    t.rt -= 1;
                    t = t.tt;
                }
            };
        } else {
            this.re = _TreeNode.TreeNode;
            this.M = function(e, t, i) {
                const s = this.ne(e, t, i);
                if (s) this.he(s);
                return this.i;
            };
            this.V = this.fe;
        }
        this.h = new this.re;
    }
    X(e, t) {
        let i = this.h;
        while (e) {
            const s = this.v(e.u, t);
            if (s < 0) {
                e = e.W;
            } else if (s > 0) {
                i = e;
                e = e.U;
            } else return e;
        }
        return i;
    }
    Z(e, t) {
        let i = this.h;
        while (e) {
            const s = this.v(e.u, t);
            if (s <= 0) {
                e = e.W;
            } else {
                i = e;
                e = e.U;
            }
        }
        return i;
    }
    $(e, t) {
        let i = this.h;
        while (e) {
            const s = this.v(e.u, t);
            if (s < 0) {
                i = e;
                e = e.W;
            } else if (s > 0) {
                e = e.U;
            } else return e;
        }
        return i;
    }
    rr(e, t) {
        let i = this.h;
        while (e) {
            const s = this.v(e.u, t);
            if (s < 0) {
                i = e;
                e = e.W;
            } else {
                e = e.U;
            }
        }
        return i;
    }
    ue(e) {
        while (true) {
            const t = e.tt;
            if (t === this.h) return;
            if (e.ee === 1) {
                e.ee = 0;
                return;
            }
            if (e === t.U) {
                const i = t.W;
                if (i.ee === 1) {
                    i.ee = 0;
                    t.ee = 1;
                    if (t === this.Y) {
                        this.Y = t.te();
                    } else t.te();
                } else {
                    if (i.W && i.W.ee === 1) {
                        i.ee = t.ee;
                        t.ee = 0;
                        i.W.ee = 0;
                        if (t === this.Y) {
                            this.Y = t.te();
                        } else t.te();
                        return;
                    } else if (i.U && i.U.ee === 1) {
                        i.ee = 1;
                        i.U.ee = 0;
                        i.se();
                    } else {
                        i.ee = 1;
                        e = t;
                    }
                }
            } else {
                const i = t.U;
                if (i.ee === 1) {
                    i.ee = 0;
                    t.ee = 1;
                    if (t === this.Y) {
                        this.Y = t.se();
                    } else t.se();
                } else {
                    if (i.U && i.U.ee === 1) {
                        i.ee = t.ee;
                        t.ee = 0;
                        i.U.ee = 0;
                        if (t === this.Y) {
                            this.Y = t.se();
                        } else t.se();
                        return;
                    } else if (i.W && i.W.ee === 1) {
                        i.ee = 1;
                        i.W.ee = 0;
                        i.te();
                    } else {
                        i.ee = 1;
                        e = t;
                    }
                }
            }
        }
    }
    fe(e) {
        if (this.i === 1) {
            this.clear();
            return this.h;
        }
        let t = e;
        while (t.U || t.W) {
            if (t.W) {
                t = t.W;
                while (t.U) t = t.U;
            } else {
                t = t.U;
            }
            [e.u, t.u] = [ t.u, e.u ];
            [e.l, t.l] = [ t.l, e.l ];
            e = t;
        }
        if (this.h.U === t) {
            this.h.U = t.tt;
        } else if (this.h.W === t) {
            this.h.W = t.tt;
        }
        this.ue(t);
        const i = t.tt;
        if (t === i.U) {
            i.U = undefined;
        } else i.W = undefined;
        this.i -= 1;
        this.Y.ee = 0;
        return i;
    }
    oe(e, t) {
        if (e === undefined) return false;
        const i = this.oe(e.U, t);
        if (i) return true;
        if (t(e)) return true;
        return this.oe(e.W, t);
    }
    he(e) {
        while (true) {
            const t = e.tt;
            if (t.ee === 0) return;
            const i = t.tt;
            if (t === i.U) {
                const s = i.W;
                if (s && s.ee === 1) {
                    s.ee = t.ee = 0;
                    if (i === this.Y) return;
                    i.ee = 1;
                    e = i;
                    continue;
                } else if (e === t.W) {
                    e.ee = 0;
                    if (e.U) e.U.tt = t;
                    if (e.W) e.W.tt = i;
                    t.W = e.U;
                    i.U = e.W;
                    e.U = t;
                    e.W = i;
                    if (i === this.Y) {
                        this.Y = e;
                        this.h.tt = e;
                    } else {
                        const t = i.tt;
                        if (t.U === i) {
                            t.U = e;
                        } else t.W = e;
                    }
                    e.tt = i.tt;
                    t.tt = e;
                    i.tt = e;
                    i.ee = 1;
                    return {
                        parentNode: t,
                        grandParent: i,
                        curNode: e
                    };
                } else {
                    t.ee = 0;
                    if (i === this.Y) {
                        this.Y = i.se();
                    } else i.se();
                    i.ee = 1;
                }
            } else {
                const s = i.U;
                if (s && s.ee === 1) {
                    s.ee = t.ee = 0;
                    if (i === this.Y) return;
                    i.ee = 1;
                    e = i;
                    continue;
                } else if (e === t.U) {
                    e.ee = 0;
                    if (e.U) e.U.tt = i;
                    if (e.W) e.W.tt = t;
                    i.W = e.U;
                    t.U = e.W;
                    e.U = i;
                    e.W = t;
                    if (i === this.Y) {
                        this.Y = e;
                        this.h.tt = e;
                    } else {
                        const t = i.tt;
                        if (t.U === i) {
                            t.U = e;
                        } else t.W = e;
                    }
                    e.tt = i.tt;
                    t.tt = e;
                    i.tt = e;
                    i.ee = 1;
                    return {
                        parentNode: t,
                        grandParent: i,
                        curNode: e
                    };
                } else {
                    t.ee = 0;
                    if (i === this.Y) {
                        this.Y = i.te();
                    } else i.te();
                    i.ee = 1;
                }
            }
            return;
        }
    }
    ne(e, t, i) {
        if (this.Y === undefined) {
            this.i += 1;
            this.Y = new this.re(e, t);
            this.Y.ee = 0;
            this.Y.tt = this.h;
            this.h.tt = this.Y;
            this.h.U = this.Y;
            this.h.W = this.Y;
            return;
        }
        let s;
        const r = this.h.U;
        const n = this.v(r.u, e);
        if (n === 0) {
            r.l = t;
            return;
        } else if (n > 0) {
            r.U = new this.re(e, t);
            r.U.tt = r;
            s = r.U;
            this.h.U = s;
        } else {
            const r = this.h.W;
            const n = this.v(r.u, e);
            if (n === 0) {
                r.l = t;
                return;
            } else if (n < 0) {
                r.W = new this.re(e, t);
                r.W.tt = r;
                s = r.W;
                this.h.W = s;
            } else {
                if (i !== undefined) {
                    const r = i.o;
                    if (r !== this.h) {
                        const i = this.v(r.u, e);
                        if (i === 0) {
                            r.l = t;
                            return;
                        } else if (i > 0) {
                            const i = r.L();
                            const n = this.v(i.u, e);
                            if (n === 0) {
                                i.l = t;
                                return;
                            } else if (n < 0) {
                                s = new this.re(e, t);
                                if (i.W === undefined) {
                                    i.W = s;
                                    s.tt = i;
                                } else {
                                    r.U = s;
                                    s.tt = r;
                                }
                            }
                        }
                    }
                }
                if (s === undefined) {
                    s = this.Y;
                    while (true) {
                        const i = this.v(s.u, e);
                        if (i > 0) {
                            if (s.U === undefined) {
                                s.U = new this.re(e, t);
                                s.U.tt = s;
                                s = s.U;
                                break;
                            }
                            s = s.U;
                        } else if (i < 0) {
                            if (s.W === undefined) {
                                s.W = new this.re(e, t);
                                s.W.tt = s;
                                s = s.W;
                                break;
                            }
                            s = s.W;
                        } else {
                            s.l = t;
                            return;
                        }
                    }
                }
            }
        }
        this.i += 1;
        return s;
    }
    I(e, t) {
        while (e) {
            const i = this.v(e.u, t);
            if (i < 0) {
                e = e.W;
            } else if (i > 0) {
                e = e.U;
            } else return e;
        }
        return e || this.h;
    }
    clear() {
        this.i = 0;
        this.Y = undefined;
        this.h.tt = undefined;
        this.h.U = this.h.W = undefined;
    }
    updateKeyByIterator(e, t) {
        const i = e.o;
        if (i === this.h) {
            (0, _throwError.throwIteratorAccessError)();
        }
        if (this.i === 1) {
            i.u = t;
            return true;
        }
        if (i === this.h.U) {
            if (this.v(i.B().u, t) > 0) {
                i.u = t;
                return true;
            }
            return false;
        }
        if (i === this.h.W) {
            if (this.v(i.L().u, t) < 0) {
                i.u = t;
                return true;
            }
            return false;
        }
        const s = i.L().u;
        if (this.v(s, t) >= 0) return false;
        const r = i.B().u;
        if (this.v(r, t) <= 0) return false;
        i.u = t;
        return true;
    }
    eraseElementByPos(e) {
        if (e < 0 || e > this.i - 1) {
            throw new RangeError;
        }
        let t = 0;
        const i = this;
        this.oe(this.Y, (function(s) {
            if (e === t) {
                i.V(s);
                return true;
            }
            t += 1;
            return false;
        }));
        return this.i;
    }
    eraseElementByKey(e) {
        if (this.i === 0) return false;
        const t = this.I(this.Y, e);
        if (t === this.h) return false;
        this.V(t);
        return true;
    }
    eraseElementByIterator(e) {
        const t = e.o;
        if (t === this.h) {
            (0, _throwError.throwIteratorAccessError)();
        }
        const i = t.W === undefined;
        const s = e.iteratorType === 0;
        if (s) {
            if (i) e.next();
        } else {
            if (!i || t.U === undefined) e.next();
        }
        this.V(t);
        return e;
    }
    forEach(e) {
        let t = 0;
        for (const i of this) e(i, t++, this);
    }
    getElementByPos(e) {
        if (e < 0 || e > this.i - 1) {
            throw new RangeError;
        }
        let t;
        let i = 0;
        for (const s of this) {
            if (i === e) {
                t = s;
                break;
            }
            i += 1;
        }
        return t;
    }
    getHeight() {
        if (this.i === 0) return 0;
        const traversal = function(e) {
            if (!e) return 0;
            return Math.max(traversal(e.U), traversal(e.W)) + 1;
        };
        return traversal(this.Y);
    }
}

var _default = TreeContainer;

exports.default = _default;


},{"../../../utils/throwError":71,"../../ContainerBase":52,"./TreeNode":65}],67:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

exports.default = void 0;

var _Base = _interopRequireDefault(require("./Base"));

var _TreeIterator = _interopRequireDefault(require("./Base/TreeIterator"));

var _throwError = require("../../utils/throwError");

function _interopRequireDefault(r) {
    return r && r.t ? r : {
        default: r
    };
}

class OrderedMapIterator extends _TreeIterator.default {
    constructor(r, t, e, s) {
        super(r, t, s);
        this.container = e;
    }
    get pointer() {
        if (this.o === this.h) {
            (0, _throwError.throwIteratorAccessError)();
        }
        const r = this;
        return new Proxy([], {
            get(t, e) {
                if (e === "0") return r.o.u; else if (e === "1") return r.o.l;
            },
            set(t, e, s) {
                if (e !== "1") {
                    throw new TypeError("props must be 1");
                }
                r.o.l = s;
                return true;
            }
        });
    }
    copy() {
        return new OrderedMapIterator(this.o, this.h, this.container, this.iteratorType);
    }
}

class OrderedMap extends _Base.default {
    constructor(r = [], t, e) {
        super(t, e);
        const s = this;
        r.forEach((function(r) {
            s.setElement(r[0], r[1]);
        }));
    }
    * K(r) {
        if (r === undefined) return;
        yield* this.K(r.U);
        yield [ r.u, r.l ];
        yield* this.K(r.W);
    }
    begin() {
        return new OrderedMapIterator(this.h.U || this.h, this.h, this);
    }
    end() {
        return new OrderedMapIterator(this.h, this.h, this);
    }
    rBegin() {
        return new OrderedMapIterator(this.h.W || this.h, this.h, this, 1);
    }
    rEnd() {
        return new OrderedMapIterator(this.h, this.h, this, 1);
    }
    front() {
        if (this.i === 0) return;
        const r = this.h.U;
        return [ r.u, r.l ];
    }
    back() {
        if (this.i === 0) return;
        const r = this.h.W;
        return [ r.u, r.l ];
    }
    lowerBound(r) {
        const t = this.X(this.Y, r);
        return new OrderedMapIterator(t, this.h, this);
    }
    upperBound(r) {
        const t = this.Z(this.Y, r);
        return new OrderedMapIterator(t, this.h, this);
    }
    reverseLowerBound(r) {
        const t = this.$(this.Y, r);
        return new OrderedMapIterator(t, this.h, this);
    }
    reverseUpperBound(r) {
        const t = this.rr(this.Y, r);
        return new OrderedMapIterator(t, this.h, this);
    }
    setElement(r, t, e) {
        return this.M(r, t, e);
    }
    find(r) {
        const t = this.I(this.Y, r);
        return new OrderedMapIterator(t, this.h, this);
    }
    getElementByKey(r) {
        const t = this.I(this.Y, r);
        return t.l;
    }
    union(r) {
        const t = this;
        r.forEach((function(r) {
            t.setElement(r[0], r[1]);
        }));
        return this.i;
    }
    [Symbol.iterator]() {
        return this.K(this.Y);
    }
}

var _default = OrderedMap;

exports.default = _default;


},{"../../utils/throwError":71,"./Base":66,"./Base/TreeIterator":64}],68:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

exports.default = void 0;

var _Base = _interopRequireDefault(require("./Base"));

var _TreeIterator = _interopRequireDefault(require("./Base/TreeIterator"));

var _throwError = require("../../utils/throwError");

function _interopRequireDefault(e) {
    return e && e.t ? e : {
        default: e
    };
}

class OrderedSetIterator extends _TreeIterator.default {
    constructor(e, t, r, i) {
        super(e, t, i);
        this.container = r;
    }
    get pointer() {
        if (this.o === this.h) {
            (0, _throwError.throwIteratorAccessError)();
        }
        return this.o.u;
    }
    copy() {
        return new OrderedSetIterator(this.o, this.h, this.container, this.iteratorType);
    }
}

class OrderedSet extends _Base.default {
    constructor(e = [], t, r) {
        super(t, r);
        const i = this;
        e.forEach((function(e) {
            i.insert(e);
        }));
    }
    * K(e) {
        if (e === undefined) return;
        yield* this.K(e.U);
        yield e.u;
        yield* this.K(e.W);
    }
    begin() {
        return new OrderedSetIterator(this.h.U || this.h, this.h, this);
    }
    end() {
        return new OrderedSetIterator(this.h, this.h, this);
    }
    rBegin() {
        return new OrderedSetIterator(this.h.W || this.h, this.h, this, 1);
    }
    rEnd() {
        return new OrderedSetIterator(this.h, this.h, this, 1);
    }
    front() {
        return this.h.U ? this.h.U.u : undefined;
    }
    back() {
        return this.h.W ? this.h.W.u : undefined;
    }
    insert(e, t) {
        return this.M(e, undefined, t);
    }
    find(e) {
        const t = this.I(this.Y, e);
        return new OrderedSetIterator(t, this.h, this);
    }
    lowerBound(e) {
        const t = this.X(this.Y, e);
        return new OrderedSetIterator(t, this.h, this);
    }
    upperBound(e) {
        const t = this.Z(this.Y, e);
        return new OrderedSetIterator(t, this.h, this);
    }
    reverseLowerBound(e) {
        const t = this.$(this.Y, e);
        return new OrderedSetIterator(t, this.h, this);
    }
    reverseUpperBound(e) {
        const t = this.rr(this.Y, e);
        return new OrderedSetIterator(t, this.h, this);
    }
    union(e) {
        const t = this;
        e.forEach((function(e) {
            t.insert(e);
        }));
        return this.i;
    }
    [Symbol.iterator]() {
        return this.K(this.Y);
    }
}

var _default = OrderedSet;

exports.default = _default;


},{"../../utils/throwError":71,"./Base":66,"./Base/TreeIterator":64}],69:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

Object.defineProperty(exports, "Deque", {
    enumerable: true,
    get: function() {
        return _Deque.default;
    }
});

Object.defineProperty(exports, "HashMap", {
    enumerable: true,
    get: function() {
        return _HashMap.default;
    }
});

Object.defineProperty(exports, "HashSet", {
    enumerable: true,
    get: function() {
        return _HashSet.default;
    }
});

Object.defineProperty(exports, "LinkList", {
    enumerable: true,
    get: function() {
        return _LinkList.default;
    }
});

Object.defineProperty(exports, "OrderedMap", {
    enumerable: true,
    get: function() {
        return _OrderedMap.default;
    }
});

Object.defineProperty(exports, "OrderedSet", {
    enumerable: true,
    get: function() {
        return _OrderedSet.default;
    }
});

Object.defineProperty(exports, "PriorityQueue", {
    enumerable: true,
    get: function() {
        return _PriorityQueue.default;
    }
});

Object.defineProperty(exports, "Queue", {
    enumerable: true,
    get: function() {
        return _Queue.default;
    }
});

Object.defineProperty(exports, "Stack", {
    enumerable: true,
    get: function() {
        return _Stack.default;
    }
});

Object.defineProperty(exports, "Vector", {
    enumerable: true,
    get: function() {
        return _Vector.default;
    }
});

var _Stack = _interopRequireDefault(require("./container/OtherContainer/Stack"));

var _Queue = _interopRequireDefault(require("./container/OtherContainer/Queue"));

var _PriorityQueue = _interopRequireDefault(require("./container/OtherContainer/PriorityQueue"));

var _Vector = _interopRequireDefault(require("./container/SequentialContainer/Vector"));

var _LinkList = _interopRequireDefault(require("./container/SequentialContainer/LinkList"));

var _Deque = _interopRequireDefault(require("./container/SequentialContainer/Deque"));

var _OrderedSet = _interopRequireDefault(require("./container/TreeContainer/OrderedSet"));

var _OrderedMap = _interopRequireDefault(require("./container/TreeContainer/OrderedMap"));

var _HashSet = _interopRequireDefault(require("./container/HashContainer/HashSet"));

var _HashMap = _interopRequireDefault(require("./container/HashContainer/HashMap"));

function _interopRequireDefault(e) {
    return e && e.t ? e : {
        default: e
    };
}


},{"./container/HashContainer/HashMap":54,"./container/HashContainer/HashSet":55,"./container/OtherContainer/PriorityQueue":56,"./container/OtherContainer/Queue":57,"./container/OtherContainer/Stack":58,"./container/SequentialContainer/Deque":61,"./container/SequentialContainer/LinkList":62,"./container/SequentialContainer/Vector":63,"./container/TreeContainer/OrderedMap":67,"./container/TreeContainer/OrderedSet":68}],70:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

exports.default = checkObject;

function checkObject(e) {
    const t = typeof e;
    return t === "object" && e !== null || t === "function";
}


},{}],71:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

exports.throwIteratorAccessError = throwIteratorAccessError;

function throwIteratorAccessError() {
    throw new RangeError("Iterator access denied!");
}


},{}],72:[function(require,module,exports){
(function (process){(function (){
const perf =
  typeof performance === 'object' &&
  performance &&
  typeof performance.now === 'function'
    ? performance
    : Date

const hasAbortController = typeof AbortController === 'function'

// minimal backwards-compatibility polyfill
// this doesn't have nearly all the checks and whatnot that
// actual AbortController/Signal has, but it's enough for
// our purposes, and if used properly, behaves the same.
const AC = hasAbortController
  ? AbortController
  : class AbortController {
      constructor() {
        this.signal = new AS()
      }
      abort(reason = new Error('This operation was aborted')) {
        this.signal.reason = this.signal.reason || reason
        this.signal.aborted = true
        this.signal.dispatchEvent({
          type: 'abort',
          target: this.signal,
        })
      }
    }

const hasAbortSignal = typeof AbortSignal === 'function'
// Some polyfills put this on the AC class, not global
const hasACAbortSignal = typeof AC.AbortSignal === 'function'
const AS = hasAbortSignal
  ? AbortSignal
  : hasACAbortSignal
  ? AC.AbortController
  : class AbortSignal {
      constructor() {
        this.reason = undefined
        this.aborted = false
        this._listeners = []
      }
      dispatchEvent(e) {
        if (e.type === 'abort') {
          this.aborted = true
          this.onabort(e)
          this._listeners.forEach(f => f(e), this)
        }
      }
      onabort() {}
      addEventListener(ev, fn) {
        if (ev === 'abort') {
          this._listeners.push(fn)
        }
      }
      removeEventListener(ev, fn) {
        if (ev === 'abort') {
          this._listeners = this._listeners.filter(f => f !== fn)
        }
      }
    }

const warned = new Set()
const deprecatedOption = (opt, instead) => {
  const code = `LRU_CACHE_OPTION_${opt}`
  if (shouldWarn(code)) {
    warn(code, `${opt} option`, `options.${instead}`, LRUCache)
  }
}
const deprecatedMethod = (method, instead) => {
  const code = `LRU_CACHE_METHOD_${method}`
  if (shouldWarn(code)) {
    const { prototype } = LRUCache
    const { get } = Object.getOwnPropertyDescriptor(prototype, method)
    warn(code, `${method} method`, `cache.${instead}()`, get)
  }
}
const deprecatedProperty = (field, instead) => {
  const code = `LRU_CACHE_PROPERTY_${field}`
  if (shouldWarn(code)) {
    const { prototype } = LRUCache
    const { get } = Object.getOwnPropertyDescriptor(prototype, field)
    warn(code, `${field} property`, `cache.${instead}`, get)
  }
}

const emitWarning = (...a) => {
  typeof process === 'object' &&
  process &&
  typeof process.emitWarning === 'function'
    ? process.emitWarning(...a)
    : console.error(...a)
}

const shouldWarn = code => !warned.has(code)

const warn = (code, what, instead, fn) => {
  warned.add(code)
  const msg = `The ${what} is deprecated. Please use ${instead} instead.`
  emitWarning(msg, 'DeprecationWarning', code, fn)
}

const isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n)

/* istanbul ignore next - This is a little bit ridiculous, tbh.
 * The maximum array length is 2^32-1 or thereabouts on most JS impls.
 * And well before that point, you're caching the entire world, I mean,
 * that's ~32GB of just integers for the next/prev links, plus whatever
 * else to hold that many keys and values.  Just filling the memory with
 * zeroes at init time is brutal when you get that big.
 * But why not be complete?
 * Maybe in the future, these limits will have expanded. */
const getUintArray = max =>
  !isPosInt(max)
    ? null
    : max <= Math.pow(2, 8)
    ? Uint8Array
    : max <= Math.pow(2, 16)
    ? Uint16Array
    : max <= Math.pow(2, 32)
    ? Uint32Array
    : max <= Number.MAX_SAFE_INTEGER
    ? ZeroArray
    : null

class ZeroArray extends Array {
  constructor(size) {
    super(size)
    this.fill(0)
  }
}

class Stack {
  constructor(max) {
    if (max === 0) {
      return []
    }
    const UintArray = getUintArray(max)
    this.heap = new UintArray(max)
    this.length = 0
  }
  push(n) {
    this.heap[this.length++] = n
  }
  pop() {
    return this.heap[--this.length]
  }
}

class LRUCache {
  constructor(options = {}) {
    const {
      max = 0,
      ttl,
      ttlResolution = 1,
      ttlAutopurge,
      updateAgeOnGet,
      updateAgeOnHas,
      allowStale,
      dispose,
      disposeAfter,
      noDisposeOnSet,
      noUpdateTTL,
      maxSize = 0,
      maxEntrySize = 0,
      sizeCalculation,
      fetchMethod,
      fetchContext,
      noDeleteOnFetchRejection,
      noDeleteOnStaleGet,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
    } = options

    // deprecated options, don't trigger a warning for getting them if
    // the thing being passed in is another LRUCache we're copying.
    const { length, maxAge, stale } =
      options instanceof LRUCache ? {} : options

    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError('max option must be a nonnegative integer')
    }

    const UintArray = max ? getUintArray(max) : Array
    if (!UintArray) {
      throw new Error('invalid max value: ' + max)
    }

    this.max = max
    this.maxSize = maxSize
    this.maxEntrySize = maxEntrySize || this.maxSize
    this.sizeCalculation = sizeCalculation || length
    if (this.sizeCalculation) {
      if (!this.maxSize && !this.maxEntrySize) {
        throw new TypeError(
          'cannot set sizeCalculation without setting maxSize or maxEntrySize'
        )
      }
      if (typeof this.sizeCalculation !== 'function') {
        throw new TypeError('sizeCalculation set to non-function')
      }
    }

    this.fetchMethod = fetchMethod || null
    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {
      throw new TypeError(
        'fetchMethod must be a function if specified'
      )
    }

    this.fetchContext = fetchContext
    if (!this.fetchMethod && fetchContext !== undefined) {
      throw new TypeError(
        'cannot set fetchContext without fetchMethod'
      )
    }

    this.keyMap = new Map()
    this.keyList = new Array(max).fill(null)
    this.valList = new Array(max).fill(null)
    this.next = new UintArray(max)
    this.prev = new UintArray(max)
    this.head = 0
    this.tail = 0
    this.free = new Stack(max)
    this.initialFill = 1
    this.size = 0

    if (typeof dispose === 'function') {
      this.dispose = dispose
    }
    if (typeof disposeAfter === 'function') {
      this.disposeAfter = disposeAfter
      this.disposed = []
    } else {
      this.disposeAfter = null
      this.disposed = null
    }
    this.noDisposeOnSet = !!noDisposeOnSet
    this.noUpdateTTL = !!noUpdateTTL
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort
    this.ignoreFetchAbort = !!ignoreFetchAbort

    // NB: maxEntrySize is set to maxSize if it's set
    if (this.maxEntrySize !== 0) {
      if (this.maxSize !== 0) {
        if (!isPosInt(this.maxSize)) {
          throw new TypeError(
            'maxSize must be a positive integer if specified'
          )
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError(
          'maxEntrySize must be a positive integer if specified'
        )
      }
      this.initializeSizeTracking()
    }

    this.allowStale = !!allowStale || !!stale
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet
    this.updateAgeOnGet = !!updateAgeOnGet
    this.updateAgeOnHas = !!updateAgeOnHas
    this.ttlResolution =
      isPosInt(ttlResolution) || ttlResolution === 0
        ? ttlResolution
        : 1
    this.ttlAutopurge = !!ttlAutopurge
    this.ttl = ttl || maxAge || 0
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError(
          'ttl must be a positive integer if specified'
        )
      }
      this.initializeTTLTracking()
    }

    // do not allow completely unbounded caches
    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
      throw new TypeError(
        'At least one of max, maxSize, or ttl is required'
      )
    }
    if (!this.ttlAutopurge && !this.max && !this.maxSize) {
      const code = 'LRU_CACHE_UNBOUNDED'
      if (shouldWarn(code)) {
        warned.add(code)
        const msg =
          'TTL caching without ttlAutopurge, max, or maxSize can ' +
          'result in unbounded memory consumption.'
        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)
      }
    }

    if (stale) {
      deprecatedOption('stale', 'allowStale')
    }
    if (maxAge) {
      deprecatedOption('maxAge', 'ttl')
    }
    if (length) {
      deprecatedOption('length', 'sizeCalculation')
    }
  }

  getRemainingTTL(key) {
    return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0
  }

  initializeTTLTracking() {
    this.ttls = new ZeroArray(this.max)
    this.starts = new ZeroArray(this.max)

    this.setItemTTL = (index, ttl, start = perf.now()) => {
      this.starts[index] = ttl !== 0 ? start : 0
      this.ttls[index] = ttl
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.isStale(index)) {
            this.delete(this.keyList[index])
          }
        }, ttl + 1)
        /* istanbul ignore else - unref() not supported on all platforms */
        if (t.unref) {
          t.unref()
        }
      }
    }

    this.updateItemAge = index => {
      this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0
    }

    this.statusTTL = (status, index) => {
      if (status) {
        status.ttl = this.ttls[index]
        status.start = this.starts[index]
        status.now = cachedNow || getNow()
        status.remainingTTL = status.now + status.ttl - status.start
      }
    }

    // debounce calls to perf.now() to 1s so we're not hitting
    // that costly call repeatedly.
    let cachedNow = 0
    const getNow = () => {
      const n = perf.now()
      if (this.ttlResolution > 0) {
        cachedNow = n
        const t = setTimeout(
          () => (cachedNow = 0),
          this.ttlResolution
        )
        /* istanbul ignore else - not available on all platforms */
        if (t.unref) {
          t.unref()
        }
      }
      return n
    }

    this.getRemainingTTL = key => {
      const index = this.keyMap.get(key)
      if (index === undefined) {
        return 0
      }
      return this.ttls[index] === 0 || this.starts[index] === 0
        ? Infinity
        : this.starts[index] +
            this.ttls[index] -
            (cachedNow || getNow())
    }

    this.isStale = index => {
      return (
        this.ttls[index] !== 0 &&
        this.starts[index] !== 0 &&
        (cachedNow || getNow()) - this.starts[index] >
          this.ttls[index]
      )
    }
  }
  updateItemAge(_index) {}
  statusTTL(_status, _index) {}
  setItemTTL(_index, _ttl, _start) {}
  isStale(_index) {
    return false
  }

  initializeSizeTracking() {
    this.calculatedSize = 0
    this.sizes = new ZeroArray(this.max)
    this.removeItemSize = index => {
      this.calculatedSize -= this.sizes[index]
      this.sizes[index] = 0
    }
    this.requireSize = (k, v, size, sizeCalculation) => {
      // provisionally accept background fetches.
      // actual value size will be checked when they return.
      if (this.isBackgroundFetch(v)) {
        return 0
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== 'function') {
            throw new TypeError('sizeCalculation must be a function')
          }
          size = sizeCalculation(v, k)
          if (!isPosInt(size)) {
            throw new TypeError(
              'sizeCalculation return invalid (expect positive integer)'
            )
          }
        } else {
          throw new TypeError(
            'invalid size value (must be positive integer). ' +
              'When maxSize or maxEntrySize is used, sizeCalculation or size ' +
              'must be set.'
          )
        }
      }
      return size
    }
    this.addItemSize = (index, size, status) => {
      this.sizes[index] = size
      if (this.maxSize) {
        const maxSize = this.maxSize - this.sizes[index]
        while (this.calculatedSize > maxSize) {
          this.evict(true)
        }
      }
      this.calculatedSize += this.sizes[index]
      if (status) {
        status.entrySize = size
        status.totalCalculatedSize = this.calculatedSize
      }
    }
  }
  removeItemSize(_index) {}
  addItemSize(_index, _size) {}
  requireSize(_k, _v, size, sizeCalculation) {
    if (size || sizeCalculation) {
      throw new TypeError(
        'cannot set size without setting maxSize or maxEntrySize on cache'
      )
    }
  }

  *indexes({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i = this.tail; true; ) {
        if (!this.isValidIndex(i)) {
          break
        }
        if (allowStale || !this.isStale(i)) {
          yield i
        }
        if (i === this.head) {
          break
        } else {
          i = this.prev[i]
        }
      }
    }
  }

  *rindexes({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i = this.head; true; ) {
        if (!this.isValidIndex(i)) {
          break
        }
        if (allowStale || !this.isStale(i)) {
          yield i
        }
        if (i === this.tail) {
          break
        } else {
          i = this.next[i]
        }
      }
    }
  }

  isValidIndex(index) {
    return (
      index !== undefined &&
      this.keyMap.get(this.keyList[index]) === index
    )
  }

  *entries() {
    for (const i of this.indexes()) {
      if (
        this.valList[i] !== undefined &&
        this.keyList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield [this.keyList[i], this.valList[i]]
      }
    }
  }
  *rentries() {
    for (const i of this.rindexes()) {
      if (
        this.valList[i] !== undefined &&
        this.keyList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield [this.keyList[i], this.valList[i]]
      }
    }
  }

  *keys() {
    for (const i of this.indexes()) {
      if (
        this.keyList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield this.keyList[i]
      }
    }
  }
  *rkeys() {
    for (const i of this.rindexes()) {
      if (
        this.keyList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield this.keyList[i]
      }
    }
  }

  *values() {
    for (const i of this.indexes()) {
      if (
        this.valList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield this.valList[i]
      }
    }
  }
  *rvalues() {
    for (const i of this.rindexes()) {
      if (
        this.valList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield this.valList[i]
      }
    }
  }

  [Symbol.iterator]() {
    return this.entries()
  }

  find(fn, getOptions) {
    for (const i of this.indexes()) {
      const v = this.valList[i]
      const value = this.isBackgroundFetch(v)
        ? v.__staleWhileFetching
        : v
      if (value === undefined) continue
      if (fn(value, this.keyList[i], this)) {
        return this.get(this.keyList[i], getOptions)
      }
    }
  }

  forEach(fn, thisp = this) {
    for (const i of this.indexes()) {
      const v = this.valList[i]
      const value = this.isBackgroundFetch(v)
        ? v.__staleWhileFetching
        : v
      if (value === undefined) continue
      fn.call(thisp, value, this.keyList[i], this)
    }
  }

  rforEach(fn, thisp = this) {
    for (const i of this.rindexes()) {
      const v = this.valList[i]
      const value = this.isBackgroundFetch(v)
        ? v.__staleWhileFetching
        : v
      if (value === undefined) continue
      fn.call(thisp, value, this.keyList[i], this)
    }
  }

  get prune() {
    deprecatedMethod('prune', 'purgeStale')
    return this.purgeStale
  }

  purgeStale() {
    let deleted = false
    for (const i of this.rindexes({ allowStale: true })) {
      if (this.isStale(i)) {
        this.delete(this.keyList[i])
        deleted = true
      }
    }
    return deleted
  }

  dump() {
    const arr = []
    for (const i of this.indexes({ allowStale: true })) {
      const key = this.keyList[i]
      const v = this.valList[i]
      const value = this.isBackgroundFetch(v)
        ? v.__staleWhileFetching
        : v
      if (value === undefined) continue
      const entry = { value }
      if (this.ttls) {
        entry.ttl = this.ttls[i]
        // always dump the start relative to a portable timestamp
        // it's ok for this to be a bit slow, it's a rare operation.
        const age = perf.now() - this.starts[i]
        entry.start = Math.floor(Date.now() - age)
      }
      if (this.sizes) {
        entry.size = this.sizes[i]
      }
      arr.unshift([key, entry])
    }
    return arr
  }

  load(arr) {
    this.clear()
    for (const [key, entry] of arr) {
      if (entry.start) {
        // entry.start is a portable timestamp, but we may be using
        // node's performance.now(), so calculate the offset.
        // it's ok for this to be a bit slow, it's a rare operation.
        const age = Date.now() - entry.start
        entry.start = perf.now() - age
      }
      this.set(key, entry.value, entry)
    }
  }

  dispose(_v, _k, _reason) {}

  set(
    k,
    v,
    {
      ttl = this.ttl,
      start,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      status,
    } = {}
  ) {
    size = this.requireSize(k, v, size, sizeCalculation)
    // if the item doesn't fit, don't do anything
    // NB: maxEntrySize set to maxSize by default
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = 'miss'
        status.maxEntrySizeExceeded = true
      }
      // have to delete, in case a background fetch is there already.
      // in non-async cases, this is a no-op
      this.delete(k)
      return this
    }
    let index = this.size === 0 ? undefined : this.keyMap.get(k)
    if (index === undefined) {
      // addition
      index = this.newIndex()
      this.keyList[index] = k
      this.valList[index] = v
      this.keyMap.set(k, index)
      this.next[this.tail] = index
      this.prev[index] = this.tail
      this.tail = index
      this.size++
      this.addItemSize(index, size, status)
      if (status) {
        status.set = 'add'
      }
      noUpdateTTL = false
    } else {
      // update
      this.moveToTail(index)
      const oldVal = this.valList[index]
      if (v !== oldVal) {
        if (this.isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error('replaced'))
        } else {
          if (!noDisposeOnSet) {
            this.dispose(oldVal, k, 'set')
            if (this.disposeAfter) {
              this.disposed.push([oldVal, k, 'set'])
            }
          }
        }
        this.removeItemSize(index)
        this.valList[index] = v
        this.addItemSize(index, size, status)
        if (status) {
          status.set = 'replace'
          const oldValue =
            oldVal && this.isBackgroundFetch(oldVal)
              ? oldVal.__staleWhileFetching
              : oldVal
          if (oldValue !== undefined) status.oldValue = oldValue
        }
      } else if (status) {
        status.set = 'update'
      }
    }
    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
      this.initializeTTLTracking()
    }
    if (!noUpdateTTL) {
      this.setItemTTL(index, ttl, start)
    }
    this.statusTTL(status, index)
    if (this.disposeAfter) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
    return this
  }

  newIndex() {
    if (this.size === 0) {
      return this.tail
    }
    if (this.size === this.max && this.max !== 0) {
      return this.evict(false)
    }
    if (this.free.length !== 0) {
      return this.free.pop()
    }
    // initial fill, just keep writing down the list
    return this.initialFill++
  }

  pop() {
    if (this.size) {
      const val = this.valList[this.head]
      this.evict(true)
      return val
    }
  }

  evict(free) {
    const head = this.head
    const k = this.keyList[head]
    const v = this.valList[head]
    if (this.isBackgroundFetch(v)) {
      v.__abortController.abort(new Error('evicted'))
    } else {
      this.dispose(v, k, 'evict')
      if (this.disposeAfter) {
        this.disposed.push([v, k, 'evict'])
      }
    }
    this.removeItemSize(head)
    // if we aren't about to use the index, then null these out
    if (free) {
      this.keyList[head] = null
      this.valList[head] = null
      this.free.push(head)
    }
    this.head = this.next[head]
    this.keyMap.delete(k)
    this.size--
    return head
  }

  has(k, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined) {
      if (!this.isStale(index)) {
        if (updateAgeOnHas) {
          this.updateItemAge(index)
        }
        if (status) status.has = 'hit'
        this.statusTTL(status, index)
        return true
      } else if (status) {
        status.has = 'stale'
        this.statusTTL(status, index)
      }
    } else if (status) {
      status.has = 'miss'
    }
    return false
  }

  // like get(), but without any LRU updating or TTL expiration
  peek(k, { allowStale = this.allowStale } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined && (allowStale || !this.isStale(index))) {
      const v = this.valList[index]
      // either stale and allowed, or forcing a refresh of non-stale value
      return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v
    }
  }

  backgroundFetch(k, index, options, context) {
    const v = index === undefined ? undefined : this.valList[index]
    if (this.isBackgroundFetch(v)) {
      return v
    }
    const ac = new AC()
    if (options.signal) {
      options.signal.addEventListener('abort', () =>
        ac.abort(options.signal.reason)
      )
    }
    const fetchOpts = {
      signal: ac.signal,
      options,
      context,
    }
    const cb = (v, updateCache = false) => {
      const { aborted } = ac.signal
      const ignoreAbort = options.ignoreFetchAbort && v !== undefined
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true
          options.status.fetchError = ac.signal.reason
          if (ignoreAbort) options.status.fetchAbortIgnored = true
        } else {
          options.status.fetchResolved = true
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason)
      }
      // either we didn't abort, and are still here, or we did, and ignored
      if (this.valList[index] === p) {
        if (v === undefined) {
          if (p.__staleWhileFetching) {
            this.valList[index] = p.__staleWhileFetching
          } else {
            this.delete(k)
          }
        } else {
          if (options.status) options.status.fetchUpdated = true
          this.set(k, v, fetchOpts.options)
        }
      }
      return v
    }
    const eb = er => {
      if (options.status) {
        options.status.fetchRejected = true
        options.status.fetchError = er
      }
      return fetchFail(er)
    }
    const fetchFail = er => {
      const { aborted } = ac.signal
      const allowStaleAborted =
        aborted && options.allowStaleOnFetchAbort
      const allowStale =
        allowStaleAborted || options.allowStaleOnFetchRejection
      const noDelete = allowStale || options.noDeleteOnFetchRejection
      if (this.valList[index] === p) {
        // if we allow stale on fetch rejections, then we need to ensure that
        // the stale value is not removed from the cache when the fetch fails.
        const del = !noDelete || p.__staleWhileFetching === undefined
        if (del) {
          this.delete(k)
        } else if (!allowStaleAborted) {
          // still replace the *promise* with the stale value,
          // since we are done with the promise at this point.
          // leave it untouched if we're still waiting for an
          // aborted background fetch that hasn't yet returned.
          this.valList[index] = p.__staleWhileFetching
        }
      }
      if (allowStale) {
        if (options.status && p.__staleWhileFetching !== undefined) {
          options.status.returnedStale = true
        }
        return p.__staleWhileFetching
      } else if (p.__returned === p) {
        throw er
      }
    }
    const pcall = (res, rej) => {
      this.fetchMethod(k, v, fetchOpts).then(v => res(v), rej)
      // ignored, we go until we finish, regardless.
      // defer check until we are actually aborting,
      // so fetchMethod can override.
      ac.signal.addEventListener('abort', () => {
        if (
          !options.ignoreFetchAbort ||
          options.allowStaleOnFetchAbort
        ) {
          res()
          // when it eventually resolves, update the cache.
          if (options.allowStaleOnFetchAbort) {
            res = v => cb(v, true)
          }
        }
      })
    }
    if (options.status) options.status.fetchDispatched = true
    const p = new Promise(pcall).then(cb, eb)
    p.__abortController = ac
    p.__staleWhileFetching = v
    p.__returned = null
    if (index === undefined) {
      // internal, don't expose status.
      this.set(k, p, { ...fetchOpts.options, status: undefined })
      index = this.keyMap.get(k)
    } else {
      this.valList[index] = p
    }
    return p
  }

  isBackgroundFetch(p) {
    return (
      p &&
      typeof p === 'object' &&
      typeof p.then === 'function' &&
      Object.prototype.hasOwnProperty.call(
        p,
        '__staleWhileFetching'
      ) &&
      Object.prototype.hasOwnProperty.call(p, '__returned') &&
      (p.__returned === p || p.__returned === null)
    )
  }

  // this takes the union of get() and set() opts, because it does both
  async fetch(
    k,
    {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      fetchContext = this.fetchContext,
      forceRefresh = false,
      status,
      signal,
    } = {}
  ) {
    if (!this.fetchMethod) {
      if (status) status.fetch = 'get'
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status,
      })
    }

    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal,
    }

    let index = this.keyMap.get(k)
    if (index === undefined) {
      if (status) status.fetch = 'miss'
      const p = this.backgroundFetch(k, index, options, fetchContext)
      return (p.__returned = p)
    } else {
      // in cache, maybe already fetching
      const v = this.valList[index]
      if (this.isBackgroundFetch(v)) {
        const stale =
          allowStale && v.__staleWhileFetching !== undefined
        if (status) {
          status.fetch = 'inflight'
          if (stale) status.returnedStale = true
        }
        return stale ? v.__staleWhileFetching : (v.__returned = v)
      }

      // if we force a refresh, that means do NOT serve the cached value,
      // unless we are already in the process of refreshing the cache.
      const isStale = this.isStale(index)
      if (!forceRefresh && !isStale) {
        if (status) status.fetch = 'hit'
        this.moveToTail(index)
        if (updateAgeOnGet) {
          this.updateItemAge(index)
        }
        this.statusTTL(status, index)
        return v
      }

      // ok, it is stale or a forced refresh, and not already fetching.
      // refresh the cache.
      const p = this.backgroundFetch(k, index, options, fetchContext)
      const hasStale = p.__staleWhileFetching !== undefined
      const staleVal = hasStale && allowStale
      if (status) {
        status.fetch = hasStale && isStale ? 'stale' : 'refresh'
        if (staleVal && isStale) status.returnedStale = true
      }
      return staleVal ? p.__staleWhileFetching : (p.__returned = p)
    }
  }

  get(
    k,
    {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      status,
    } = {}
  ) {
    const index = this.keyMap.get(k)
    if (index !== undefined) {
      const value = this.valList[index]
      const fetching = this.isBackgroundFetch(value)
      this.statusTTL(status, index)
      if (this.isStale(index)) {
        if (status) status.get = 'stale'
        // delete only if not an in-flight background fetch
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k)
          }
          if (status) status.returnedStale = allowStale
          return allowStale ? value : undefined
        } else {
          if (status) {
            status.returnedStale =
              allowStale && value.__staleWhileFetching !== undefined
          }
          return allowStale ? value.__staleWhileFetching : undefined
        }
      } else {
        if (status) status.get = 'hit'
        // if we're currently fetching it, we don't actually have it yet
        // it's not stale, which means this isn't a staleWhileRefetching.
        // If it's not stale, and fetching, AND has a __staleWhileFetching
        // value, then that means the user fetched with {forceRefresh:true},
        // so it's safe to return that value.
        if (fetching) {
          return value.__staleWhileFetching
        }
        this.moveToTail(index)
        if (updateAgeOnGet) {
          this.updateItemAge(index)
        }
        return value
      }
    } else if (status) {
      status.get = 'miss'
    }
  }

  connect(p, n) {
    this.prev[n] = p
    this.next[p] = n
  }

  moveToTail(index) {
    // if tail already, nothing to do
    // if head, move head to next[index]
    // else
    //   move next[prev[index]] to next[index] (head has no prev)
    //   move prev[next[index]] to prev[index]
    // prev[index] = tail
    // next[tail] = index
    // tail = index
    if (index !== this.tail) {
      if (index === this.head) {
        this.head = this.next[index]
      } else {
        this.connect(this.prev[index], this.next[index])
      }
      this.connect(this.tail, index)
      this.tail = index
    }
  }

  get del() {
    deprecatedMethod('del', 'delete')
    return this.delete
  }

  delete(k) {
    let deleted = false
    if (this.size !== 0) {
      const index = this.keyMap.get(k)
      if (index !== undefined) {
        deleted = true
        if (this.size === 1) {
          this.clear()
        } else {
          this.removeItemSize(index)
          const v = this.valList[index]
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('deleted'))
          } else {
            this.dispose(v, k, 'delete')
            if (this.disposeAfter) {
              this.disposed.push([v, k, 'delete'])
            }
          }
          this.keyMap.delete(k)
          this.keyList[index] = null
          this.valList[index] = null
          if (index === this.tail) {
            this.tail = this.prev[index]
          } else if (index === this.head) {
            this.head = this.next[index]
          } else {
            this.next[this.prev[index]] = this.next[index]
            this.prev[this.next[index]] = this.prev[index]
          }
          this.size--
          this.free.push(index)
        }
      }
    }
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
    return deleted
  }

  clear() {
    for (const index of this.rindexes({ allowStale: true })) {
      const v = this.valList[index]
      if (this.isBackgroundFetch(v)) {
        v.__abortController.abort(new Error('deleted'))
      } else {
        const k = this.keyList[index]
        this.dispose(v, k, 'delete')
        if (this.disposeAfter) {
          this.disposed.push([v, k, 'delete'])
        }
      }
    }

    this.keyMap.clear()
    this.valList.fill(null)
    this.keyList.fill(null)
    if (this.ttls) {
      this.ttls.fill(0)
      this.starts.fill(0)
    }
    if (this.sizes) {
      this.sizes.fill(0)
    }
    this.head = 0
    this.tail = 0
    this.initialFill = 1
    this.free.length = 0
    this.calculatedSize = 0
    this.size = 0
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
  }

  get reset() {
    deprecatedMethod('reset', 'clear')
    return this.clear
  }

  get length() {
    deprecatedProperty('length', 'size')
    return this.size
  }

  static get AbortController() {
    return AC
  }
  static get AbortSignal() {
    return AS
  }
}

module.exports = LRUCache

}).call(this)}).call(this,require('_process'))
},{"_process":102}],73:[function(require,module,exports){
/* Protocol - protocol constants */
const protocol = module.exports
const { Buffer } = require('buffer')

/* Command code => mnemonic */
protocol.types = {
  0: 'reserved',
  1: 'connect',
  2: 'connack',
  3: 'publish',
  4: 'puback',
  5: 'pubrec',
  6: 'pubrel',
  7: 'pubcomp',
  8: 'subscribe',
  9: 'suback',
  10: 'unsubscribe',
  11: 'unsuback',
  12: 'pingreq',
  13: 'pingresp',
  14: 'disconnect',
  15: 'auth'
}

protocol.requiredHeaderFlags = {
  1: 0, // 'connect'
  2: 0, // 'connack'
  4: 0, // 'puback'
  5: 0, // 'pubrec'
  6: 2, // 'pubrel'
  7: 0, // 'pubcomp'
  8: 2, // 'subscribe'
  9: 0, // 'suback'
  10: 2, // 'unsubscribe'
  11: 0, // 'unsuback'
  12: 0, // 'pingreq'
  13: 0, // 'pingresp'
  14: 0, // 'disconnect'
  15: 0 // 'auth'
}

protocol.requiredHeaderFlagsErrors = {}
for (const k in protocol.requiredHeaderFlags) {
  const v = protocol.requiredHeaderFlags[k]
  protocol.requiredHeaderFlagsErrors[k] = 'Invalid header flag bits, must be 0x' + v.toString(16) + ' for ' + protocol.types[k] + ' packet'
}

/* Mnemonic => Command code */
protocol.codes = {}
for (const k in protocol.types) {
  const v = protocol.types[k]
  protocol.codes[v] = k
}

/* Header */
protocol.CMD_SHIFT = 4
protocol.CMD_MASK = 0xF0
protocol.DUP_MASK = 0x08
protocol.QOS_MASK = 0x03
protocol.QOS_SHIFT = 1
protocol.RETAIN_MASK = 0x01

/* Length */
protocol.VARBYTEINT_MASK = 0x7F
protocol.VARBYTEINT_FIN_MASK = 0x80
protocol.VARBYTEINT_MAX = 268435455

/* Connack */
protocol.SESSIONPRESENT_MASK = 0x01
protocol.SESSIONPRESENT_HEADER = Buffer.from([protocol.SESSIONPRESENT_MASK])
protocol.CONNACK_HEADER = Buffer.from([protocol.codes.connack << protocol.CMD_SHIFT])

/* Connect */
protocol.USERNAME_MASK = 0x80
protocol.PASSWORD_MASK = 0x40
protocol.WILL_RETAIN_MASK = 0x20
protocol.WILL_QOS_MASK = 0x18
protocol.WILL_QOS_SHIFT = 3
protocol.WILL_FLAG_MASK = 0x04
protocol.CLEAN_SESSION_MASK = 0x02
protocol.CONNECT_HEADER = Buffer.from([protocol.codes.connect << protocol.CMD_SHIFT])

/* Properties */
protocol.properties = {
  sessionExpiryInterval: 17,
  willDelayInterval: 24,
  receiveMaximum: 33,
  maximumPacketSize: 39,
  topicAliasMaximum: 34,
  requestResponseInformation: 25,
  requestProblemInformation: 23,
  userProperties: 38,
  authenticationMethod: 21,
  authenticationData: 22,
  payloadFormatIndicator: 1,
  messageExpiryInterval: 2,
  contentType: 3,
  responseTopic: 8,
  correlationData: 9,
  maximumQoS: 36,
  retainAvailable: 37,
  assignedClientIdentifier: 18,
  reasonString: 31,
  wildcardSubscriptionAvailable: 40,
  subscriptionIdentifiersAvailable: 41,
  sharedSubscriptionAvailable: 42,
  serverKeepAlive: 19,
  responseInformation: 26,
  serverReference: 28,
  topicAlias: 35,
  subscriptionIdentifier: 11
}
protocol.propertiesCodes = {}
for (const prop in protocol.properties) {
  const id = protocol.properties[prop]
  protocol.propertiesCodes[id] = prop
}
protocol.propertiesTypes = {
  sessionExpiryInterval: 'int32',
  willDelayInterval: 'int32',
  receiveMaximum: 'int16',
  maximumPacketSize: 'int32',
  topicAliasMaximum: 'int16',
  requestResponseInformation: 'byte',
  requestProblemInformation: 'byte',
  userProperties: 'pair',
  authenticationMethod: 'string',
  authenticationData: 'binary',
  payloadFormatIndicator: 'byte',
  messageExpiryInterval: 'int32',
  contentType: 'string',
  responseTopic: 'string',
  correlationData: 'binary',
  maximumQoS: 'int8',
  retainAvailable: 'byte',
  assignedClientIdentifier: 'string',
  reasonString: 'string',
  wildcardSubscriptionAvailable: 'byte',
  subscriptionIdentifiersAvailable: 'byte',
  sharedSubscriptionAvailable: 'byte',
  serverKeepAlive: 'int16',
  responseInformation: 'string',
  serverReference: 'string',
  topicAlias: 'int16',
  subscriptionIdentifier: 'var'
}

function genHeader (type) {
  return [0, 1, 2].map(qos => {
    return [0, 1].map(dup => {
      return [0, 1].map(retain => {
        const buf = Buffer.alloc(1)
        buf.writeUInt8(
          protocol.codes[type] << protocol.CMD_SHIFT |
          (dup ? protocol.DUP_MASK : 0) |
          qos << protocol.QOS_SHIFT | retain, 0, true)
        return buf
      })
    })
  })
}

/* Publish */
protocol.PUBLISH_HEADER = genHeader('publish')

/* Subscribe */
protocol.SUBSCRIBE_HEADER = genHeader('subscribe')
protocol.SUBSCRIBE_OPTIONS_QOS_MASK = 0x03
protocol.SUBSCRIBE_OPTIONS_NL_MASK = 0x01
protocol.SUBSCRIBE_OPTIONS_NL_SHIFT = 2
protocol.SUBSCRIBE_OPTIONS_RAP_MASK = 0x01
protocol.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3
protocol.SUBSCRIBE_OPTIONS_RH_MASK = 0x03
protocol.SUBSCRIBE_OPTIONS_RH_SHIFT = 4
protocol.SUBSCRIBE_OPTIONS_RH = [0x00, 0x10, 0x20]
protocol.SUBSCRIBE_OPTIONS_NL = 0x04
protocol.SUBSCRIBE_OPTIONS_RAP = 0x08
protocol.SUBSCRIBE_OPTIONS_QOS = [0x00, 0x01, 0x02]

/* Unsubscribe */
protocol.UNSUBSCRIBE_HEADER = genHeader('unsubscribe')

/* Confirmations */
protocol.ACKS = {
  unsuback: genHeader('unsuback'),
  puback: genHeader('puback'),
  pubcomp: genHeader('pubcomp'),
  pubrel: genHeader('pubrel'),
  pubrec: genHeader('pubrec')
}

protocol.SUBACK_HEADER = Buffer.from([protocol.codes.suback << protocol.CMD_SHIFT])

/* Protocol versions */
protocol.VERSION3 = Buffer.from([3])
protocol.VERSION4 = Buffer.from([4])
protocol.VERSION5 = Buffer.from([5])
protocol.VERSION131 = Buffer.from([131])
protocol.VERSION132 = Buffer.from([132])

/* QoS */
protocol.QOS = [0, 1, 2].map(qos => {
  return Buffer.from([qos])
})

/* Empty packets */
protocol.EMPTY = {
  pingreq: Buffer.from([protocol.codes.pingreq << 4, 0]),
  pingresp: Buffer.from([protocol.codes.pingresp << 4, 0]),
  disconnect: Buffer.from([protocol.codes.disconnect << 4, 0])
}

protocol.MQTT5_PUBACK_PUBREC_CODES = {
  0x00: 'Success',
  0x10: 'No matching subscribers',
  0x80: 'Unspecified error',
  0x83: 'Implementation specific error',
  0x87: 'Not authorized',
  0x90: 'Topic Name invalid',
  0x91: 'Packet identifier in use',
  0x97: 'Quota exceeded',
  0x99: 'Payload format invalid'
}

protocol.MQTT5_PUBREL_PUBCOMP_CODES = {
  0x00: 'Success',
  0x92: 'Packet Identifier not found'
}

protocol.MQTT5_SUBACK_CODES = {
  0x00: 'Granted QoS 0',
  0x01: 'Granted QoS 1',
  0x02: 'Granted QoS 2',
  0x80: 'Unspecified error',
  0x83: 'Implementation specific error',
  0x87: 'Not authorized',
  0x8F: 'Topic Filter invalid',
  0x91: 'Packet Identifier in use',
  0x97: 'Quota exceeded',
  0x9E: 'Shared Subscriptions not supported',
  0xA1: 'Subscription Identifiers not supported',
  0xA2: 'Wildcard Subscriptions not supported'
}

protocol.MQTT5_UNSUBACK_CODES = {
  0x00: 'Success',
  0x11: 'No subscription existed',
  0x80: 'Unspecified error',
  0x83: 'Implementation specific error',
  0x87: 'Not authorized',
  0x8F: 'Topic Filter invalid',
  0x91: 'Packet Identifier in use'
}

protocol.MQTT5_DISCONNECT_CODES = {
  0x00: 'Normal disconnection',
  0x04: 'Disconnect with Will Message',
  0x80: 'Unspecified error',
  0x81: 'Malformed Packet',
  0x82: 'Protocol Error',
  0x83: 'Implementation specific error',
  0x87: 'Not authorized',
  0x89: 'Server busy',
  0x8B: 'Server shutting down',
  0x8D: 'Keep Alive timeout',
  0x8E: 'Session taken over',
  0x8F: 'Topic Filter invalid',
  0x90: 'Topic Name invalid',
  0x93: 'Receive Maximum exceeded',
  0x94: 'Topic Alias invalid',
  0x95: 'Packet too large',
  0x96: 'Message rate too high',
  0x97: 'Quota exceeded',
  0x98: 'Administrative action',
  0x99: 'Payload format invalid',
  0x9A: 'Retain not supported',
  0x9B: 'QoS not supported',
  0x9C: 'Use another server',
  0x9D: 'Server moved',
  0x9E: 'Shared Subscriptions not supported',
  0x9F: 'Connection rate exceeded',
  0xA0: 'Maximum connect time',
  0xA1: 'Subscription Identifiers not supported',
  0xA2: 'Wildcard Subscriptions not supported'
}

protocol.MQTT5_AUTH_CODES = {
  0x00: 'Success',
  0x18: 'Continue authentication',
  0x19: 'Re-authenticate'
}

},{"buffer":29}],74:[function(require,module,exports){
const writeToStream = require('./writeToStream')
const EventEmitter = require('events')
const { Buffer } = require('buffer')

function generate (packet, opts) {
  const stream = new Accumulator()
  writeToStream(packet, stream, opts)
  return stream.concat()
}

class Accumulator extends EventEmitter {
  constructor () {
    super()
    this._array = new Array(20)
    this._i = 0
  }

  write (chunk) {
    this._array[this._i++] = chunk
    return true
  }

  concat () {
    let length = 0
    const lengths = new Array(this._array.length)
    const list = this._array
    let pos = 0
    let i

    for (i = 0; i < list.length && list[i] !== undefined; i++) {
      if (typeof list[i] !== 'string') lengths[i] = list[i].length
      else lengths[i] = Buffer.byteLength(list[i])

      length += lengths[i]
    }

    const result = Buffer.allocUnsafe(length)

    for (i = 0; i < list.length && list[i] !== undefined; i++) {
      if (typeof list[i] !== 'string') {
        list[i].copy(result, pos)
        pos += lengths[i]
      } else {
        result.write(list[i], pos)
        pos += lengths[i]
      }
    }

    return result
  }

  destroy (err) {
    if (err) this.emit('error', err)
  }
}

module.exports = generate

},{"./writeToStream":96,"buffer":29,"events":49}],75:[function(require,module,exports){
exports.parser = require('./parser').parser
exports.generate = require('./generate')
exports.writeToStream = require('./writeToStream')

},{"./generate":74,"./parser":95,"./writeToStream":96}],76:[function(require,module,exports){
'use strict'

const { Buffer } = require('buffer')
const symbol = Symbol.for('BufferList')

function BufferList (buf) {
  if (!(this instanceof BufferList)) {
    return new BufferList(buf)
  }

  BufferList._init.call(this, buf)
}

BufferList._init = function _init (buf) {
  Object.defineProperty(this, symbol, { value: true })

  this._bufs = []
  this.length = 0

  if (buf) {
    this.append(buf)
  }
}

BufferList.prototype._new = function _new (buf) {
  return new BufferList(buf)
}

BufferList.prototype._offset = function _offset (offset) {
  if (offset === 0) {
    return [0, 0]
  }

  let tot = 0

  for (let i = 0; i < this._bufs.length; i++) {
    const _t = tot + this._bufs[i].length
    if (offset < _t || i === this._bufs.length - 1) {
      return [i, offset - tot]
    }
    tot = _t
  }
}

BufferList.prototype._reverseOffset = function (blOffset) {
  const bufferId = blOffset[0]
  let offset = blOffset[1]

  for (let i = 0; i < bufferId; i++) {
    offset += this._bufs[i].length
  }

  return offset
}

BufferList.prototype.get = function get (index) {
  if (index > this.length || index < 0) {
    return undefined
  }

  const offset = this._offset(index)

  return this._bufs[offset[0]][offset[1]]
}

BufferList.prototype.slice = function slice (start, end) {
  if (typeof start === 'number' && start < 0) {
    start += this.length
  }

  if (typeof end === 'number' && end < 0) {
    end += this.length
  }

  return this.copy(null, 0, start, end)
}

BufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {
  if (typeof srcStart !== 'number' || srcStart < 0) {
    srcStart = 0
  }

  if (typeof srcEnd !== 'number' || srcEnd > this.length) {
    srcEnd = this.length
  }

  if (srcStart >= this.length) {
    return dst || Buffer.alloc(0)
  }

  if (srcEnd <= 0) {
    return dst || Buffer.alloc(0)
  }

  const copy = !!dst
  const off = this._offset(srcStart)
  const len = srcEnd - srcStart
  let bytes = len
  let bufoff = (copy && dstStart) || 0
  let start = off[1]

  // copy/slice everything
  if (srcStart === 0 && srcEnd === this.length) {
    if (!copy) {
      // slice, but full concat if multiple buffers
      return this._bufs.length === 1
        ? this._bufs[0]
        : Buffer.concat(this._bufs, this.length)
    }

    // copy, need to copy individual buffers
    for (let i = 0; i < this._bufs.length; i++) {
      this._bufs[i].copy(dst, bufoff)
      bufoff += this._bufs[i].length
    }

    return dst
  }

  // easy, cheap case where it's a subset of one of the buffers
  if (bytes <= this._bufs[off[0]].length - start) {
    return copy
      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
      : this._bufs[off[0]].slice(start, start + bytes)
  }

  if (!copy) {
    // a slice, we need something to copy in to
    dst = Buffer.allocUnsafe(len)
  }

  for (let i = off[0]; i < this._bufs.length; i++) {
    const l = this._bufs[i].length - start

    if (bytes > l) {
      this._bufs[i].copy(dst, bufoff, start)
      bufoff += l
    } else {
      this._bufs[i].copy(dst, bufoff, start, start + bytes)
      bufoff += l
      break
    }

    bytes -= l

    if (start) {
      start = 0
    }
  }

  // safeguard so that we don't return uninitialized memory
  if (dst.length > bufoff) return dst.slice(0, bufoff)

  return dst
}

BufferList.prototype.shallowSlice = function shallowSlice (start, end) {
  start = start || 0
  end = typeof end !== 'number' ? this.length : end

  if (start < 0) {
    start += this.length
  }

  if (end < 0) {
    end += this.length
  }

  if (start === end) {
    return this._new()
  }

  const startOffset = this._offset(start)
  const endOffset = this._offset(end)
  const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1)

  if (endOffset[1] === 0) {
    buffers.pop()
  } else {
    buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1])
  }

  if (startOffset[1] !== 0) {
    buffers[0] = buffers[0].slice(startOffset[1])
  }

  return this._new(buffers)
}

BufferList.prototype.toString = function toString (encoding, start, end) {
  return this.slice(start, end).toString(encoding)
}

BufferList.prototype.consume = function consume (bytes) {
  // first, normalize the argument, in accordance with how Buffer does it
  bytes = Math.trunc(bytes)
  // do nothing if not a positive number
  if (Number.isNaN(bytes) || bytes <= 0) return this

  while (this._bufs.length) {
    if (bytes >= this._bufs[0].length) {
      bytes -= this._bufs[0].length
      this.length -= this._bufs[0].length
      this._bufs.shift()
    } else {
      this._bufs[0] = this._bufs[0].slice(bytes)
      this.length -= bytes
      break
    }
  }

  return this
}

BufferList.prototype.duplicate = function duplicate () {
  const copy = this._new()

  for (let i = 0; i < this._bufs.length; i++) {
    copy.append(this._bufs[i])
  }

  return copy
}

BufferList.prototype.append = function append (buf) {
  if (buf == null) {
    return this
  }

  if (buf.buffer) {
    // append a view of the underlying ArrayBuffer
    this._appendBuffer(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength))
  } else if (Array.isArray(buf)) {
    for (let i = 0; i < buf.length; i++) {
      this.append(buf[i])
    }
  } else if (this._isBufferList(buf)) {
    // unwrap argument into individual BufferLists
    for (let i = 0; i < buf._bufs.length; i++) {
      this.append(buf._bufs[i])
    }
  } else {
    // coerce number arguments to strings, since Buffer(number) does
    // uninitialized memory allocation
    if (typeof buf === 'number') {
      buf = buf.toString()
    }

    this._appendBuffer(Buffer.from(buf))
  }

  return this
}

BufferList.prototype._appendBuffer = function appendBuffer (buf) {
  this._bufs.push(buf)
  this.length += buf.length
}

BufferList.prototype.indexOf = function (search, offset, encoding) {
  if (encoding === undefined && typeof offset === 'string') {
    encoding = offset
    offset = undefined
  }

  if (typeof search === 'function' || Array.isArray(search)) {
    throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.')
  } else if (typeof search === 'number') {
    search = Buffer.from([search])
  } else if (typeof search === 'string') {
    search = Buffer.from(search, encoding)
  } else if (this._isBufferList(search)) {
    search = search.slice()
  } else if (Array.isArray(search.buffer)) {
    search = Buffer.from(search.buffer, search.byteOffset, search.byteLength)
  } else if (!Buffer.isBuffer(search)) {
    search = Buffer.from(search)
  }

  offset = Number(offset || 0)

  if (isNaN(offset)) {
    offset = 0
  }

  if (offset < 0) {
    offset = this.length + offset
  }

  if (offset < 0) {
    offset = 0
  }

  if (search.length === 0) {
    return offset > this.length ? this.length : offset
  }

  const blOffset = this._offset(offset)
  let blIndex = blOffset[0] // index of which internal buffer we're working on
  let buffOffset = blOffset[1] // offset of the internal buffer we're working on

  // scan over each buffer
  for (; blIndex < this._bufs.length; blIndex++) {
    const buff = this._bufs[blIndex]

    while (buffOffset < buff.length) {
      const availableWindow = buff.length - buffOffset

      if (availableWindow >= search.length) {
        const nativeSearchResult = buff.indexOf(search, buffOffset)

        if (nativeSearchResult !== -1) {
          return this._reverseOffset([blIndex, nativeSearchResult])
        }

        buffOffset = buff.length - search.length + 1 // end of native search window
      } else {
        const revOffset = this._reverseOffset([blIndex, buffOffset])

        if (this._match(revOffset, search)) {
          return revOffset
        }

        buffOffset++
      }
    }

    buffOffset = 0
  }

  return -1
}

BufferList.prototype._match = function (offset, search) {
  if (this.length - offset < search.length) {
    return false
  }

  for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
    if (this.get(offset + searchOffset) !== search[searchOffset]) {
      return false
    }
  }
  return true
}

;(function () {
  const methods = {
    readDoubleBE: 8,
    readDoubleLE: 8,
    readFloatBE: 4,
    readFloatLE: 4,
    readInt32BE: 4,
    readInt32LE: 4,
    readUInt32BE: 4,
    readUInt32LE: 4,
    readInt16BE: 2,
    readInt16LE: 2,
    readUInt16BE: 2,
    readUInt16LE: 2,
    readInt8: 1,
    readUInt8: 1,
    readIntBE: null,
    readIntLE: null,
    readUIntBE: null,
    readUIntLE: null
  }

  for (const m in methods) {
    (function (m) {
      if (methods[m] === null) {
        BufferList.prototype[m] = function (offset, byteLength) {
          return this.slice(offset, offset + byteLength)[m](0, byteLength)
        }
      } else {
        BufferList.prototype[m] = function (offset = 0) {
          return this.slice(offset, offset + methods[m])[m](0)
        }
      }
    }(m))
  }
}())

// Used internally by the class and also as an indicator of this object being
// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser
// environment because there could be multiple different copies of the
// BufferList class and some `BufferList`s might be `BufferList`s.
BufferList.prototype._isBufferList = function _isBufferList (b) {
  return b instanceof BufferList || BufferList.isBufferList(b)
}

BufferList.isBufferList = function isBufferList (b) {
  return b != null && b[symbol]
}

module.exports = BufferList

},{"buffer":29}],77:[function(require,module,exports){
'use strict'

const DuplexStream = require('readable-stream').Duplex
const inherits = require('inherits')
const BufferList = require('./BufferList')

function BufferListStream (callback) {
  if (!(this instanceof BufferListStream)) {
    return new BufferListStream(callback)
  }

  if (typeof callback === 'function') {
    this._callback = callback

    const piper = function piper (err) {
      if (this._callback) {
        this._callback(err)
        this._callback = null
      }
    }.bind(this)

    this.on('pipe', function onPipe (src) {
      src.on('error', piper)
    })
    this.on('unpipe', function onUnpipe (src) {
      src.removeListener('error', piper)
    })

    callback = null
  }

  BufferList._init.call(this, callback)
  DuplexStream.call(this)
}

inherits(BufferListStream, DuplexStream)
Object.assign(BufferListStream.prototype, BufferList.prototype)

BufferListStream.prototype._new = function _new (callback) {
  return new BufferListStream(callback)
}

BufferListStream.prototype._write = function _write (buf, encoding, callback) {
  this._appendBuffer(buf)

  if (typeof callback === 'function') {
    callback()
  }
}

BufferListStream.prototype._read = function _read (size) {
  if (!this.length) {
    return this.push(null)
  }

  size = Math.min(size, this.length)
  this.push(this.slice(0, size))
  this.consume(size)
}

BufferListStream.prototype.end = function end (chunk) {
  DuplexStream.prototype.end.call(this, chunk)

  if (this._callback) {
    this._callback(null, this.slice())
    this._callback = null
  }
}

BufferListStream.prototype._destroy = function _destroy (err, cb) {
  this._bufs.length = 0
  this.length = 0
  cb(err)
}

BufferListStream.prototype._isBufferList = function _isBufferList (b) {
  return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b)
}

BufferListStream.isBufferList = BufferList.isBufferList

module.exports = BufferListStream
module.exports.BufferListStream = BufferListStream
module.exports.BufferList = BufferList

},{"./BufferList":76,"inherits":51,"readable-stream":92}],78:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],79:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"./_stream_readable":81,"./_stream_writable":83,"_process":102,"dup":34,"inherits":51}],80:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"./_stream_transform":82,"dup":35,"inherits":51}],81:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"../errors":78,"./_stream_duplex":79,"./internal/streams/async_iterator":84,"./internal/streams/buffer_list":85,"./internal/streams/destroy":86,"./internal/streams/from":88,"./internal/streams/state":90,"./internal/streams/stream":91,"_process":102,"buffer":29,"dup":36,"events":49,"inherits":51,"string_decoder/":136,"util":26}],82:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"../errors":78,"./_stream_duplex":79,"dup":37,"inherits":51}],83:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"../errors":78,"./_stream_duplex":79,"./internal/streams/destroy":86,"./internal/streams/state":90,"./internal/streams/stream":91,"_process":102,"buffer":29,"dup":38,"inherits":51,"util-deprecate":139}],84:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"./end-of-stream":87,"_process":102,"dup":39}],85:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"buffer":29,"dup":40,"util":26}],86:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"_process":102,"dup":41}],87:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"../../../errors":78,"dup":42}],88:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],89:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"../../../errors":78,"./end-of-stream":87,"dup":44}],90:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"../../../errors":78,"dup":45}],91:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"events":49}],92:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"./lib/_stream_duplex.js":79,"./lib/_stream_passthrough.js":80,"./lib/_stream_readable.js":81,"./lib/_stream_transform.js":82,"./lib/_stream_writable.js":83,"./lib/internal/streams/end-of-stream.js":87,"./lib/internal/streams/pipeline.js":89,"dup":47}],93:[function(require,module,exports){
const { Buffer } = require('buffer')
const max = 65536
const cache = {}

// in node 6 Buffer.subarray returns a Uint8Array instead of a Buffer
// later versions return a Buffer
// alternative is Buffer.slice but that creates a new buffer
// creating new buffers takes time
// SubOk is only false on node < 8
const SubOk = Buffer.isBuffer(Buffer.from([1, 2]).subarray(0, 1))

function generateBuffer (i) {
  const buffer = Buffer.allocUnsafe(2)
  buffer.writeUInt8(i >> 8, 0)
  buffer.writeUInt8(i & 0x00FF, 0 + 1)

  return buffer
}

function generateCache () {
  for (let i = 0; i < max; i++) {
    cache[i] = generateBuffer(i)
  }
}

function genBufVariableByteInt (num) {
  const maxLength = 4 // max 4 bytes
  let digit = 0
  let pos = 0
  const buffer = Buffer.allocUnsafe(maxLength)

  do {
    digit = num % 128 | 0
    num = num / 128 | 0
    if (num > 0) digit = digit | 0x80

    buffer.writeUInt8(digit, pos++)
  } while (num > 0 && pos < maxLength)

  if (num > 0) {
    pos = 0
  }

  return SubOk ? buffer.subarray(0, pos) : buffer.slice(0, pos)
}

function generate4ByteBuffer (num) {
  const buffer = Buffer.allocUnsafe(4)
  buffer.writeUInt32BE(num, 0)
  return buffer
}

module.exports = {
  cache,
  generateCache,
  generateNumber: generateBuffer,
  genBufVariableByteInt,
  generate4ByteBuffer
}

},{"buffer":29}],94:[function(require,module,exports){
class Packet {
  constructor () {
    this.cmd = null
    this.retain = false
    this.qos = 0
    this.dup = false
    this.length = -1
    this.topic = null
    this.payload = null
  }
}

module.exports = Packet

},{}],95:[function(require,module,exports){
const bl = require('bl')
const EventEmitter = require('events')
const Packet = require('./packet')
const constants = require('./constants')
const debug = require('debug')('mqtt-packet:parser')

class Parser extends EventEmitter {
  constructor () {
    super()
    this.parser = this.constructor.parser
  }

  static parser (opt) {
    if (!(this instanceof Parser)) return (new Parser()).parser(opt)

    this.settings = opt || {}

    this._states = [
      '_parseHeader',
      '_parseLength',
      '_parsePayload',
      '_newPacket'
    ]

    this._resetState()
    return this
  }

  _resetState () {
    debug('_resetState: resetting packet, error, _list, and _stateCounter')
    this.packet = new Packet()
    this.error = null
    this._list = bl()
    this._stateCounter = 0
  }

  parse (buf) {
    if (this.error) this._resetState()

    this._list.append(buf)
    debug('parse: current state: %s', this._states[this._stateCounter])
    while ((this.packet.length !== -1 || this._list.length > 0) &&
      this[this._states[this._stateCounter]]() &&
      !this.error) {
      this._stateCounter++
      debug('parse: state complete. _stateCounter is now: %d', this._stateCounter)
      debug('parse: packet.length: %d, buffer list length: %d', this.packet.length, this._list.length)
      if (this._stateCounter >= this._states.length) this._stateCounter = 0
    }
    debug('parse: exited while loop. packet: %d, buffer list length: %d', this.packet.length, this._list.length)
    return this._list.length
  }

  _parseHeader () {
    // There is at least one byte in the buffer
    const zero = this._list.readUInt8(0)
    const cmdIndex = zero >> constants.CMD_SHIFT
    this.packet.cmd = constants.types[cmdIndex]
    const headerFlags = zero & 0xf
    const requiredHeaderFlags = constants.requiredHeaderFlags[cmdIndex]
    if (requiredHeaderFlags != null && headerFlags !== requiredHeaderFlags) {
      // Where a flag bit is marked as Reserved in Table 2.2 - Flag Bits, it is reserved for future use and MUST be set to the value listed in that table [MQTT-2.2.2-1]. If invalid flags are received, the receiver MUST close the Network Connection [MQTT-2.2.2-2]
      return this._emitError(new Error(constants.requiredHeaderFlagsErrors[cmdIndex]))
    }
    this.packet.retain = (zero & constants.RETAIN_MASK) !== 0
    this.packet.qos = (zero >> constants.QOS_SHIFT) & constants.QOS_MASK
    if (this.packet.qos > 2) {
      return this._emitError(new Error('Packet must not have both QoS bits set to 1'))
    }
    this.packet.dup = (zero & constants.DUP_MASK) !== 0
    debug('_parseHeader: packet: %o', this.packet)

    this._list.consume(1)

    return true
  }

  _parseLength () {
    // There is at least one byte in the list
    const result = this._parseVarByteNum(true)

    if (result) {
      this.packet.length = result.value
      this._list.consume(result.bytes)
    }
    debug('_parseLength %d', result.value)
    return !!result
  }

  _parsePayload () {
    debug('_parsePayload: payload %O', this._list)
    let result = false

    // Do we have a payload? Do we have enough data to complete the payload?
    // PINGs have no payload
    if (this.packet.length === 0 || this._list.length >= this.packet.length) {
      this._pos = 0

      switch (this.packet.cmd) {
        case 'connect':
          this._parseConnect()
          break
        case 'connack':
          this._parseConnack()
          break
        case 'publish':
          this._parsePublish()
          break
        case 'puback':
        case 'pubrec':
        case 'pubrel':
        case 'pubcomp':
          this._parseConfirmation()
          break
        case 'subscribe':
          this._parseSubscribe()
          break
        case 'suback':
          this._parseSuback()
          break
        case 'unsubscribe':
          this._parseUnsubscribe()
          break
        case 'unsuback':
          this._parseUnsuback()
          break
        case 'pingreq':
        case 'pingresp':
          // These are empty, nothing to do
          break
        case 'disconnect':
          this._parseDisconnect()
          break
        case 'auth':
          this._parseAuth()
          break
        default:
          this._emitError(new Error('Not supported'))
      }

      result = true
    }
    debug('_parsePayload complete result: %s', result)
    return result
  }

  _parseConnect () {
    debug('_parseConnect')
    let topic // Will topic
    let payload // Will payload
    let password // Password
    let username // Username
    const flags = {}
    const packet = this.packet

    // Parse protocolId
    const protocolId = this._parseString()

    if (protocolId === null) return this._emitError(new Error('Cannot parse protocolId'))
    if (protocolId !== 'MQTT' && protocolId !== 'MQIsdp') {
      return this._emitError(new Error('Invalid protocolId'))
    }

    packet.protocolId = protocolId

    // Parse constants version number
    if (this._pos >= this._list.length) return this._emitError(new Error('Packet too short'))

    packet.protocolVersion = this._list.readUInt8(this._pos)

    if (packet.protocolVersion >= 128) {
      packet.bridgeMode = true
      packet.protocolVersion = packet.protocolVersion - 128
    }

    if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {
      return this._emitError(new Error('Invalid protocol version'))
    }

    this._pos++

    if (this._pos >= this._list.length) {
      return this._emitError(new Error('Packet too short'))
    }

    if (this._list.readUInt8(this._pos) & 0x1) {
      // The Server MUST validate that the reserved flag in the CONNECT Control Packet is set to zero and disconnect the Client if it is not zero [MQTT-3.1.2-3]
      return this._emitError(new Error('Connect flag bit 0 must be 0, but got 1'))
    }
    // Parse connect flags
    flags.username = (this._list.readUInt8(this._pos) & constants.USERNAME_MASK)
    flags.password = (this._list.readUInt8(this._pos) & constants.PASSWORD_MASK)
    flags.will = (this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK)

    const willRetain = !!(this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK)
    const willQos = (this._list.readUInt8(this._pos) &
        constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT

    if (flags.will) {
      packet.will = {}
      packet.will.retain = willRetain
      packet.will.qos = willQos
    } else {
      if (willRetain) {
        return this._emitError(new Error('Will Retain Flag must be set to zero when Will Flag is set to 0'))
      }
      if (willQos) {
        return this._emitError(new Error('Will QoS must be set to zero when Will Flag is set to 0'))
      }
    }

    packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0
    this._pos++

    // Parse keepalive
    packet.keepalive = this._parseNum()
    if (packet.keepalive === -1) return this._emitError(new Error('Packet too short'))

    // parse properties
    if (packet.protocolVersion === 5) {
      const properties = this._parseProperties()
      if (Object.getOwnPropertyNames(properties).length) {
        packet.properties = properties
      }
    }
    // Parse clientId
    const clientId = this._parseString()
    if (clientId === null) return this._emitError(new Error('Packet too short'))
    packet.clientId = clientId
    debug('_parseConnect: packet.clientId: %s', packet.clientId)

    if (flags.will) {
      if (packet.protocolVersion === 5) {
        const willProperties = this._parseProperties()
        if (Object.getOwnPropertyNames(willProperties).length) {
          packet.will.properties = willProperties
        }
      }
      // Parse will topic
      topic = this._parseString()
      if (topic === null) return this._emitError(new Error('Cannot parse will topic'))
      packet.will.topic = topic
      debug('_parseConnect: packet.will.topic: %s', packet.will.topic)

      // Parse will payload
      payload = this._parseBuffer()
      if (payload === null) return this._emitError(new Error('Cannot parse will payload'))
      packet.will.payload = payload
      debug('_parseConnect: packet.will.paylaod: %s', packet.will.payload)
    }

    // Parse username
    if (flags.username) {
      username = this._parseString()
      if (username === null) return this._emitError(new Error('Cannot parse username'))
      packet.username = username
      debug('_parseConnect: packet.username: %s', packet.username)
    }

    // Parse password
    if (flags.password) {
      password = this._parseBuffer()
      if (password === null) return this._emitError(new Error('Cannot parse password'))
      packet.password = password
    }
    // need for right parse auth packet and self set up
    this.settings = packet
    debug('_parseConnect: complete')
    return packet
  }

  _parseConnack () {
    debug('_parseConnack')
    const packet = this.packet

    if (this._list.length < 1) return null
    const flags = this._list.readUInt8(this._pos++)
    if (flags > 1) {
      return this._emitError(new Error('Invalid connack flags, bits 7-1 must be set to 0'))
    }
    packet.sessionPresent = !!(flags & constants.SESSIONPRESENT_MASK)

    if (this.settings.protocolVersion === 5) {
      if (this._list.length >= 2) {
        packet.reasonCode = this._list.readUInt8(this._pos++)
      } else {
        packet.reasonCode = 0
      }
    } else {
      if (this._list.length < 2) return null
      packet.returnCode = this._list.readUInt8(this._pos++)
    }

    if (packet.returnCode === -1 || packet.reasonCode === -1) return this._emitError(new Error('Cannot parse return code'))
    // mqtt 5 properties
    if (this.settings.protocolVersion === 5) {
      const properties = this._parseProperties()
      if (Object.getOwnPropertyNames(properties).length) {
        packet.properties = properties
      }
    }
    debug('_parseConnack: complete')
  }

  _parsePublish () {
    debug('_parsePublish')
    const packet = this.packet
    packet.topic = this._parseString()

    if (packet.topic === null) return this._emitError(new Error('Cannot parse topic'))

    // Parse messageId
    if (packet.qos > 0) if (!this._parseMessageId()) { return }

    // Properties mqtt 5
    if (this.settings.protocolVersion === 5) {
      const properties = this._parseProperties()
      if (Object.getOwnPropertyNames(properties).length) {
        packet.properties = properties
      }
    }

    packet.payload = this._list.slice(this._pos, packet.length)
    debug('_parsePublish: payload from buffer list: %o', packet.payload)
  }

  _parseSubscribe () {
    debug('_parseSubscribe')
    const packet = this.packet
    let topic
    let options
    let qos
    let rh
    let rap
    let nl
    let subscription

    packet.subscriptions = []

    if (!this._parseMessageId()) { return }

    // Properties mqtt 5
    if (this.settings.protocolVersion === 5) {
      const properties = this._parseProperties()
      if (Object.getOwnPropertyNames(properties).length) {
        packet.properties = properties
      }
    }

    if (packet.length <= 0) { return this._emitError(new Error('Malformed subscribe, no payload specified')) }

    while (this._pos < packet.length) {
      // Parse topic
      topic = this._parseString()
      if (topic === null) return this._emitError(new Error('Cannot parse topic'))
      if (this._pos >= packet.length) return this._emitError(new Error('Malformed Subscribe Payload'))

      options = this._parseByte()

      if (this.settings.protocolVersion === 5) {
        if (options & 0xc0) {
          return this._emitError(new Error('Invalid subscribe topic flag bits, bits 7-6 must be 0'))
        }
      } else {
        if (options & 0xfc) {
          return this._emitError(new Error('Invalid subscribe topic flag bits, bits 7-2 must be 0'))
        }
      }

      qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK
      if (qos > 2) {
        return this._emitError(new Error('Invalid subscribe QoS, must be <= 2'))
      }
      nl = ((options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT) & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0
      rap = ((options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT) & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0
      rh = (options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT) & constants.SUBSCRIBE_OPTIONS_RH_MASK

      if (rh > 2) {
        return this._emitError(new Error('Invalid retain handling, must be <= 2'))
      }

      subscription = { topic, qos }

      // mqtt 5 options
      if (this.settings.protocolVersion === 5) {
        subscription.nl = nl
        subscription.rap = rap
        subscription.rh = rh
      } else if (this.settings.bridgeMode) {
        subscription.rh = 0
        subscription.rap = true
        subscription.nl = true
      }

      // Push pair to subscriptions
      debug('_parseSubscribe: push subscription `%s` to subscription', subscription)
      packet.subscriptions.push(subscription)
    }
  }

  _parseSuback () {
    debug('_parseSuback')
    const packet = this.packet
    this.packet.granted = []

    if (!this._parseMessageId()) { return }

    // Properties mqtt 5
    if (this.settings.protocolVersion === 5) {
      const properties = this._parseProperties()
      if (Object.getOwnPropertyNames(properties).length) {
        packet.properties = properties
      }
    }

    if (packet.length <= 0) { return this._emitError(new Error('Malformed suback, no payload specified')) }

    // Parse granted QoSes
    while (this._pos < this.packet.length) {
      const code = this._list.readUInt8(this._pos++)
      if (this.settings.protocolVersion === 5) {
        if (!constants.MQTT5_SUBACK_CODES[code]) {
          return this._emitError(new Error('Invalid suback code'))
        }
      } else {
        if (code > 2 && code !== 0x80) {
          return this._emitError(new Error('Invalid suback QoS, must be 0, 1, 2 or 128'))
        }
      }
      this.packet.granted.push(code)
    }
  }

  _parseUnsubscribe () {
    debug('_parseUnsubscribe')
    const packet = this.packet

    packet.unsubscriptions = []

    // Parse messageId
    if (!this._parseMessageId()) { return }

    // Properties mqtt 5
    if (this.settings.protocolVersion === 5) {
      const properties = this._parseProperties()
      if (Object.getOwnPropertyNames(properties).length) {
        packet.properties = properties
      }
    }

    if (packet.length <= 0) { return this._emitError(new Error('Malformed unsubscribe, no payload specified')) }

    while (this._pos < packet.length) {
      // Parse topic
      const topic = this._parseString()
      if (topic === null) return this._emitError(new Error('Cannot parse topic'))

      // Push topic to unsubscriptions
      debug('_parseUnsubscribe: push topic `%s` to unsubscriptions', topic)
      packet.unsubscriptions.push(topic)
    }
  }

  _parseUnsuback () {
    debug('_parseUnsuback')
    const packet = this.packet
    if (!this._parseMessageId()) return this._emitError(new Error('Cannot parse messageId'))

    if ((this.settings.protocolVersion === 3 ||
      this.settings.protocolVersion === 4) && packet.length !== 2) {
      return this._emitError(new Error('Malformed unsuback, payload length must be 2'))
    }
    if (packet.length <= 0) { return this._emitError(new Error('Malformed unsuback, no payload specified')) }

    // Properties mqtt 5
    if (this.settings.protocolVersion === 5) {
      const properties = this._parseProperties()
      if (Object.getOwnPropertyNames(properties).length) {
        packet.properties = properties
      }
      // Parse granted QoSes
      packet.granted = []

      while (this._pos < this.packet.length) {
        const code = this._list.readUInt8(this._pos++)
        if (!constants.MQTT5_UNSUBACK_CODES[code]) {
          return this._emitError(new Error('Invalid unsuback code'))
        }
        this.packet.granted.push(code)
      }
    }
  }

  // parse packets like puback, pubrec, pubrel, pubcomp
  _parseConfirmation () {
    debug('_parseConfirmation: packet.cmd: `%s`', this.packet.cmd)
    const packet = this.packet

    this._parseMessageId()

    if (this.settings.protocolVersion === 5) {
      if (packet.length > 2) {
        // response code
        packet.reasonCode = this._parseByte()
        switch (this.packet.cmd) {
          case 'puback':
          case 'pubrec':
            if (!constants.MQTT5_PUBACK_PUBREC_CODES[packet.reasonCode]) {
              return this._emitError(new Error('Invalid ' + this.packet.cmd + ' reason code'))
            }
            break
          case 'pubrel':
          case 'pubcomp':
            if (!constants.MQTT5_PUBREL_PUBCOMP_CODES[packet.reasonCode]) {
              return this._emitError(new Error('Invalid ' + this.packet.cmd + ' reason code'))
            }
            break
        }
        debug('_parseConfirmation: packet.reasonCode `%d`', packet.reasonCode)
      } else {
        packet.reasonCode = 0
      }

      if (packet.length > 3) {
        // properies mqtt 5
        const properties = this._parseProperties()
        if (Object.getOwnPropertyNames(properties).length) {
          packet.properties = properties
        }
      }
    }

    return true
  }

  // parse disconnect packet
  _parseDisconnect () {
    const packet = this.packet
    debug('_parseDisconnect')

    if (this.settings.protocolVersion === 5) {
      // response code
      if (this._list.length > 0) {
        packet.reasonCode = this._parseByte()
        if (!constants.MQTT5_DISCONNECT_CODES[packet.reasonCode]) {
          this._emitError(new Error('Invalid disconnect reason code'))
        }
      } else {
        packet.reasonCode = 0
      }
      // properies mqtt 5
      const properties = this._parseProperties()
      if (Object.getOwnPropertyNames(properties).length) {
        packet.properties = properties
      }
    }

    debug('_parseDisconnect result: true')
    return true
  }

  // parse auth packet
  _parseAuth () {
    debug('_parseAuth')
    const packet = this.packet

    if (this.settings.protocolVersion !== 5) {
      return this._emitError(new Error('Not supported auth packet for this version MQTT'))
    }

    // response code
    packet.reasonCode = this._parseByte()
    if (!constants.MQTT5_AUTH_CODES[packet.reasonCode]) {
      return this._emitError(new Error('Invalid auth reason code'))
    }
    // properies mqtt 5
    const properties = this._parseProperties()
    if (Object.getOwnPropertyNames(properties).length) {
      packet.properties = properties
    }

    debug('_parseAuth: result: true')
    return true
  }

  _parseMessageId () {
    const packet = this.packet

    packet.messageId = this._parseNum()

    if (packet.messageId === null) {
      this._emitError(new Error('Cannot parse messageId'))
      return false
    }

    debug('_parseMessageId: packet.messageId %d', packet.messageId)
    return true
  }

  _parseString (maybeBuffer) {
    const length = this._parseNum()
    const end = length + this._pos

    if (length === -1 || end > this._list.length || end > this.packet.length) return null

    const result = this._list.toString('utf8', this._pos, end)
    this._pos += length
    debug('_parseString: result: %s', result)
    return result
  }

  _parseStringPair () {
    debug('_parseStringPair')
    return {
      name: this._parseString(),
      value: this._parseString()
    }
  }

  _parseBuffer () {
    const length = this._parseNum()
    const end = length + this._pos

    if (length === -1 || end > this._list.length || end > this.packet.length) return null

    const result = this._list.slice(this._pos, end)

    this._pos += length
    debug('_parseBuffer: result: %o', result)
    return result
  }

  _parseNum () {
    if (this._list.length - this._pos < 2) return -1

    const result = this._list.readUInt16BE(this._pos)
    this._pos += 2
    debug('_parseNum: result: %s', result)
    return result
  }

  _parse4ByteNum () {
    if (this._list.length - this._pos < 4) return -1

    const result = this._list.readUInt32BE(this._pos)
    this._pos += 4
    debug('_parse4ByteNum: result: %s', result)
    return result
  }

  _parseVarByteNum (fullInfoFlag) {
    debug('_parseVarByteNum')
    const maxBytes = 4
    let bytes = 0
    let mul = 1
    let value = 0
    let result = false
    let current
    const padding = this._pos ? this._pos : 0

    while (bytes < maxBytes && (padding + bytes) < this._list.length) {
      current = this._list.readUInt8(padding + bytes++)
      value += mul * (current & constants.VARBYTEINT_MASK)
      mul *= 0x80

      if ((current & constants.VARBYTEINT_FIN_MASK) === 0) {
        result = true
        break
      }
      if (this._list.length <= bytes) {
        break
      }
    }

    if (!result && bytes === maxBytes && this._list.length >= bytes) {
      this._emitError(new Error('Invalid variable byte integer'))
    }

    if (padding) {
      this._pos += bytes
    }

    if (result) {
      if (fullInfoFlag) {
        result = { bytes, value }
      } else {
        result = value
      }
    } else {
      result = false
    }

    debug('_parseVarByteNum: result: %o', result)
    return result
  }

  _parseByte () {
    let result
    if (this._pos < this._list.length) {
      result = this._list.readUInt8(this._pos)
      this._pos++
    }
    debug('_parseByte: result: %o', result)
    return result
  }

  _parseByType (type) {
    debug('_parseByType: type: %s', type)
    switch (type) {
      case 'byte': {
        return this._parseByte() !== 0
      }
      case 'int8': {
        return this._parseByte()
      }
      case 'int16': {
        return this._parseNum()
      }
      case 'int32': {
        return this._parse4ByteNum()
      }
      case 'var': {
        return this._parseVarByteNum()
      }
      case 'string': {
        return this._parseString()
      }
      case 'pair': {
        return this._parseStringPair()
      }
      case 'binary': {
        return this._parseBuffer()
      }
    }
  }

  _parseProperties () {
    debug('_parseProperties')
    const length = this._parseVarByteNum()
    const start = this._pos
    const end = start + length
    const result = {}
    while (this._pos < end) {
      const type = this._parseByte()
      if (!type) {
        this._emitError(new Error('Cannot parse property code type'))
        return false
      }
      const name = constants.propertiesCodes[type]
      if (!name) {
        this._emitError(new Error('Unknown property'))
        return false
      }
      // user properties process
      if (name === 'userProperties') {
        if (!result[name]) {
          result[name] = Object.create(null)
        }
        const currentUserProperty = this._parseByType(constants.propertiesTypes[name])
        if (result[name][currentUserProperty.name]) {
          if (Array.isArray(result[name][currentUserProperty.name])) {
            result[name][currentUserProperty.name].push(currentUserProperty.value)
          } else {
            const currentValue = result[name][currentUserProperty.name]
            result[name][currentUserProperty.name] = [currentValue]
            result[name][currentUserProperty.name].push(currentUserProperty.value)
          }
        } else {
          result[name][currentUserProperty.name] = currentUserProperty.value
        }
        continue
      }
      if (result[name]) {
        if (Array.isArray(result[name])) {
          result[name].push(this._parseByType(constants.propertiesTypes[name]))
        } else {
          result[name] = [result[name]]
          result[name].push(this._parseByType(constants.propertiesTypes[name]))
        }
      } else {
        result[name] = this._parseByType(constants.propertiesTypes[name])
      }
    }
    return result
  }

  _newPacket () {
    debug('_newPacket')
    if (this.packet) {
      this._list.consume(this.packet.length)
      debug('_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d', this.packet.cmd, this.packet.payload, this.packet.length)
      this.emit('packet', this.packet)
    }
    debug('_newPacket: new packet')
    this.packet = new Packet()

    this._pos = 0

    return true
  }

  _emitError (err) {
    debug('_emitError', err)
    this.error = err
    this.emit('error', err)
  }
}

module.exports = Parser

},{"./constants":73,"./packet":94,"bl":77,"debug":30,"events":49}],96:[function(require,module,exports){
const protocol = require('./constants')
const { Buffer } = require('buffer')
const empty = Buffer.allocUnsafe(0)
const zeroBuf = Buffer.from([0])
const numbers = require('./numbers')
const nextTick = require('process-nextick-args').nextTick
const debug = require('debug')('mqtt-packet:writeToStream')

const numCache = numbers.cache
const generateNumber = numbers.generateNumber
const generateCache = numbers.generateCache
const genBufVariableByteInt = numbers.genBufVariableByteInt
const generate4ByteBuffer = numbers.generate4ByteBuffer
let writeNumber = writeNumberCached
let toGenerate = true

function generate (packet, stream, opts) {
  debug('generate called')
  if (stream.cork) {
    stream.cork()
    nextTick(uncork, stream)
  }

  if (toGenerate) {
    toGenerate = false
    generateCache()
  }
  debug('generate: packet.cmd: %s', packet.cmd)
  switch (packet.cmd) {
    case 'connect':
      return connect(packet, stream, opts)
    case 'connack':
      return connack(packet, stream, opts)
    case 'publish':
      return publish(packet, stream, opts)
    case 'puback':
    case 'pubrec':
    case 'pubrel':
    case 'pubcomp':
      return confirmation(packet, stream, opts)
    case 'subscribe':
      return subscribe(packet, stream, opts)
    case 'suback':
      return suback(packet, stream, opts)
    case 'unsubscribe':
      return unsubscribe(packet, stream, opts)
    case 'unsuback':
      return unsuback(packet, stream, opts)
    case 'pingreq':
    case 'pingresp':
      return emptyPacket(packet, stream, opts)
    case 'disconnect':
      return disconnect(packet, stream, opts)
    case 'auth':
      return auth(packet, stream, opts)
    default:
      stream.destroy(new Error('Unknown command'))
      return false
  }
}
/**
 * Controls numbers cache.
 * Set to "false" to allocate buffers on-the-flight instead of pre-generated cache
 */
Object.defineProperty(generate, 'cacheNumbers', {
  get () {
    return writeNumber === writeNumberCached
  },
  set (value) {
    if (value) {
      if (!numCache || Object.keys(numCache).length === 0) toGenerate = true
      writeNumber = writeNumberCached
    } else {
      toGenerate = false
      writeNumber = writeNumberGenerated
    }
  }
})

function uncork (stream) {
  stream.uncork()
}

function connect (packet, stream, opts) {
  const settings = packet || {}
  const protocolId = settings.protocolId || 'MQTT'
  let protocolVersion = settings.protocolVersion || 4
  const will = settings.will
  let clean = settings.clean
  const keepalive = settings.keepalive || 0
  const clientId = settings.clientId || ''
  const username = settings.username
  const password = settings.password
  /* mqtt5 new oprions */
  const properties = settings.properties

  if (clean === undefined) clean = true

  let length = 0

  // Must be a string and non-falsy
  if (!protocolId ||
     (typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId))) {
    stream.destroy(new Error('Invalid protocolId'))
    return false
  } else length += protocolId.length + 2

  // Must be 3 or 4 or 5
  if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {
    stream.destroy(new Error('Invalid protocol version'))
    return false
  } else length += 1

  // ClientId might be omitted in 3.1.1 and 5, but only if cleanSession is set to 1
  if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) &&
     (clientId || protocolVersion >= 4) && (clientId || clean)) {
    length += Buffer.byteLength(clientId) + 2
  } else {
    if (protocolVersion < 4) {
      stream.destroy(new Error('clientId must be supplied before 3.1.1'))
      return false
    }
    if ((clean * 1) === 0) {
      stream.destroy(new Error('clientId must be given if cleanSession set to 0'))
      return false
    }
  }

  // Must be a two byte number
  if (typeof keepalive !== 'number' ||
      keepalive < 0 ||
      keepalive > 65535 ||
      keepalive % 1 !== 0) {
    stream.destroy(new Error('Invalid keepalive'))
    return false
  } else length += 2

  // Connect flags
  length += 1

  let propertiesData
  let willProperties

  // Properties
  if (protocolVersion === 5) {
    propertiesData = getProperties(stream, properties)
    if (!propertiesData) { return false }
    length += propertiesData.length
  }

  // If will exists...
  if (will) {
    // It must be an object
    if (typeof will !== 'object') {
      stream.destroy(new Error('Invalid will'))
      return false
    }
    // It must have topic typeof string
    if (!will.topic || typeof will.topic !== 'string') {
      stream.destroy(new Error('Invalid will topic'))
      return false
    } else {
      length += Buffer.byteLength(will.topic) + 2
    }

    // Payload
    length += 2 // payload length
    if (will.payload) {
      if (will.payload.length >= 0) {
        if (typeof will.payload === 'string') {
          length += Buffer.byteLength(will.payload)
        } else {
          length += will.payload.length
        }
      } else {
        stream.destroy(new Error('Invalid will payload'))
        return false
      }
    }
    // will properties
    willProperties = {}
    if (protocolVersion === 5) {
      willProperties = getProperties(stream, will.properties)
      if (!willProperties) { return false }
      length += willProperties.length
    }
  }

  // Username
  let providedUsername = false
  if (username != null) {
    if (isStringOrBuffer(username)) {
      providedUsername = true
      length += Buffer.byteLength(username) + 2
    } else {
      stream.destroy(new Error('Invalid username'))
      return false
    }
  }

  // Password
  if (password != null) {
    if (!providedUsername) {
      stream.destroy(new Error('Username is required to use password'))
      return false
    }

    if (isStringOrBuffer(password)) {
      length += byteLength(password) + 2
    } else {
      stream.destroy(new Error('Invalid password'))
      return false
    }
  }

  // Generate header
  stream.write(protocol.CONNECT_HEADER)

  // Generate length
  writeVarByteInt(stream, length)

  // Generate protocol ID
  writeStringOrBuffer(stream, protocolId)

  if (settings.bridgeMode) {
    protocolVersion += 128
  }

  stream.write(
    protocolVersion === 131
      ? protocol.VERSION131
      : protocolVersion === 132
        ? protocol.VERSION132
        : protocolVersion === 4
          ? protocol.VERSION4
          : protocolVersion === 5
            ? protocol.VERSION5
            : protocol.VERSION3
  )

  // Connect flags
  let flags = 0
  flags |= (username != null) ? protocol.USERNAME_MASK : 0
  flags |= (password != null) ? protocol.PASSWORD_MASK : 0
  flags |= (will && will.retain) ? protocol.WILL_RETAIN_MASK : 0
  flags |= (will && will.qos) ? will.qos << protocol.WILL_QOS_SHIFT : 0
  flags |= will ? protocol.WILL_FLAG_MASK : 0
  flags |= clean ? protocol.CLEAN_SESSION_MASK : 0

  stream.write(Buffer.from([flags]))

  // Keepalive
  writeNumber(stream, keepalive)

  // Properties
  if (protocolVersion === 5) {
    propertiesData.write()
  }

  // Client ID
  writeStringOrBuffer(stream, clientId)

  // Will
  if (will) {
    if (protocolVersion === 5) {
      willProperties.write()
    }
    writeString(stream, will.topic)
    writeStringOrBuffer(stream, will.payload)
  }

  // Username and password
  if (username != null) {
    writeStringOrBuffer(stream, username)
  }
  if (password != null) {
    writeStringOrBuffer(stream, password)
  }
  // This is a small packet that happens only once on a stream
  // We assume the stream is always free to receive more data after this
  return true
}

function connack (packet, stream, opts) {
  const version = opts ? opts.protocolVersion : 4
  const settings = packet || {}
  const rc = version === 5 ? settings.reasonCode : settings.returnCode
  const properties = settings.properties
  let length = 2 // length of rc and sessionHeader

  // Check return code
  if (typeof rc !== 'number') {
    stream.destroy(new Error('Invalid return code'))
    return false
  }
  // mqtt5 properties
  let propertiesData = null
  if (version === 5) {
    propertiesData = getProperties(stream, properties)
    if (!propertiesData) { return false }
    length += propertiesData.length
  }

  stream.write(protocol.CONNACK_HEADER)
  // length
  writeVarByteInt(stream, length)
  stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf)

  stream.write(Buffer.from([rc]))
  if (propertiesData != null) {
    propertiesData.write()
  }
  return true
}

function publish (packet, stream, opts) {
  debug('publish: packet: %o', packet)
  const version = opts ? opts.protocolVersion : 4
  const settings = packet || {}
  const qos = settings.qos || 0
  const retain = settings.retain ? protocol.RETAIN_MASK : 0
  const topic = settings.topic
  const payload = settings.payload || empty
  const id = settings.messageId
  const properties = settings.properties

  let length = 0

  // Topic must be a non-empty string or Buffer
  if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2
  else if (Buffer.isBuffer(topic)) length += topic.length + 2
  else {
    stream.destroy(new Error('Invalid topic'))
    return false
  }

  // Get the payload length
  if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload)
  else length += payload.length

  // Message ID must a number if qos > 0
  if (qos && typeof id !== 'number') {
    stream.destroy(new Error('Invalid messageId'))
    return false
  } else if (qos) length += 2

  // mqtt5 properties
  let propertiesData = null
  if (version === 5) {
    propertiesData = getProperties(stream, properties)
    if (!propertiesData) { return false }
    length += propertiesData.length
  }

  // Header
  stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0])

  // Remaining length
  writeVarByteInt(stream, length)

  // Topic
  writeNumber(stream, byteLength(topic))
  stream.write(topic)

  // Message ID
  if (qos > 0) writeNumber(stream, id)

  // Properties
  if (propertiesData != null) {
    propertiesData.write()
  }

  // Payload
  debug('publish: payload: %o', payload)
  return stream.write(payload)
}

/* Puback, pubrec, pubrel and pubcomp */
function confirmation (packet, stream, opts) {
  const version = opts ? opts.protocolVersion : 4
  const settings = packet || {}
  const type = settings.cmd || 'puback'
  const id = settings.messageId
  const dup = (settings.dup && type === 'pubrel') ? protocol.DUP_MASK : 0
  let qos = 0
  const reasonCode = settings.reasonCode
  const properties = settings.properties
  let length = version === 5 ? 3 : 2

  if (type === 'pubrel') qos = 1

  // Check message ID
  if (typeof id !== 'number') {
    stream.destroy(new Error('Invalid messageId'))
    return false
  }

  // properies mqtt 5
  let propertiesData = null
  if (version === 5) {
    // Confirm should not add empty property length with no properties (rfc 3.4.2.2.1)
    if (typeof properties === 'object') {
      propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)
      if (!propertiesData) { return false }
      length += propertiesData.length
    }
  }

  // Header
  stream.write(protocol.ACKS[type][qos][dup][0])

  // Length === 3 is only true of version === 5 and no properties; therefore if reasonCode === 0 we are allowed to skip both bytes - but if we write the reason code we also have to write property length [MQTT-3.4.2-1].
  if (length === 3) length += reasonCode !== 0 ? 1 : -1
  writeVarByteInt(stream, length)

  // Message ID
  writeNumber(stream, id)

  // reason code in header - but only if it couldn't be omitted - indicated by length !== 2.
  if (version === 5 && length !== 2) {
    stream.write(Buffer.from([reasonCode]))
  }

  // properties mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  } else {
    if (length === 4) {
      // we have no properties but have written a reason code - so we need to indicate empty properties by filling in a zero.
      stream.write(Buffer.from([0]))
    }
  }
  return true
}

function subscribe (packet, stream, opts) {
  debug('subscribe: packet: ')
  const version = opts ? opts.protocolVersion : 4
  const settings = packet || {}
  const dup = settings.dup ? protocol.DUP_MASK : 0
  const id = settings.messageId
  const subs = settings.subscriptions
  const properties = settings.properties

  let length = 0

  // Check message ID
  if (typeof id !== 'number') {
    stream.destroy(new Error('Invalid messageId'))
    return false
  } else length += 2

  // properies mqtt 5
  let propertiesData = null
  if (version === 5) {
    propertiesData = getProperties(stream, properties)
    if (!propertiesData) { return false }
    length += propertiesData.length
  }

  // Check subscriptions
  if (typeof subs === 'object' && subs.length) {
    for (let i = 0; i < subs.length; i += 1) {
      const itopic = subs[i].topic
      const iqos = subs[i].qos

      if (typeof itopic !== 'string') {
        stream.destroy(new Error('Invalid subscriptions - invalid topic'))
        return false
      }
      if (typeof iqos !== 'number') {
        stream.destroy(new Error('Invalid subscriptions - invalid qos'))
        return false
      }

      if (version === 5) {
        const nl = subs[i].nl || false
        if (typeof nl !== 'boolean') {
          stream.destroy(new Error('Invalid subscriptions - invalid No Local'))
          return false
        }
        const rap = subs[i].rap || false
        if (typeof rap !== 'boolean') {
          stream.destroy(new Error('Invalid subscriptions - invalid Retain as Published'))
          return false
        }
        const rh = subs[i].rh || 0
        if (typeof rh !== 'number' || rh > 2) {
          stream.destroy(new Error('Invalid subscriptions - invalid Retain Handling'))
          return false
        }
      }

      length += Buffer.byteLength(itopic) + 2 + 1
    }
  } else {
    stream.destroy(new Error('Invalid subscriptions'))
    return false
  }

  // Generate header
  debug('subscribe: writing to stream: %o', protocol.SUBSCRIBE_HEADER)
  stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0])

  // Generate length
  writeVarByteInt(stream, length)

  // Generate message ID
  writeNumber(stream, id)

  // properies mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  }

  let result = true

  // Generate subs
  for (const sub of subs) {
    const jtopic = sub.topic
    const jqos = sub.qos
    const jnl = +sub.nl
    const jrap = +sub.rap
    const jrh = sub.rh
    let joptions

    // Write topic string
    writeString(stream, jtopic)

    // options process
    joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos]
    if (version === 5) {
      joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0
      joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0
      joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0
    }
    // Write options
    result = stream.write(Buffer.from([joptions]))
  }

  return result
}

function suback (packet, stream, opts) {
  const version = opts ? opts.protocolVersion : 4
  const settings = packet || {}
  const id = settings.messageId
  const granted = settings.granted
  const properties = settings.properties
  let length = 0

  // Check message ID
  if (typeof id !== 'number') {
    stream.destroy(new Error('Invalid messageId'))
    return false
  } else length += 2

  // Check granted qos vector
  if (typeof granted === 'object' && granted.length) {
    for (let i = 0; i < granted.length; i += 1) {
      if (typeof granted[i] !== 'number') {
        stream.destroy(new Error('Invalid qos vector'))
        return false
      }
      length += 1
    }
  } else {
    stream.destroy(new Error('Invalid qos vector'))
    return false
  }

  // properies mqtt 5
  let propertiesData = null
  if (version === 5) {
    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)
    if (!propertiesData) { return false }
    length += propertiesData.length
  }

  // header
  stream.write(protocol.SUBACK_HEADER)

  // Length
  writeVarByteInt(stream, length)

  // Message ID
  writeNumber(stream, id)

  // properies mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  }

  return stream.write(Buffer.from(granted))
}

function unsubscribe (packet, stream, opts) {
  const version = opts ? opts.protocolVersion : 4
  const settings = packet || {}
  const id = settings.messageId
  const dup = settings.dup ? protocol.DUP_MASK : 0
  const unsubs = settings.unsubscriptions
  const properties = settings.properties

  let length = 0

  // Check message ID
  if (typeof id !== 'number') {
    stream.destroy(new Error('Invalid messageId'))
    return false
  } else {
    length += 2
  }
  // Check unsubs
  if (typeof unsubs === 'object' && unsubs.length) {
    for (let i = 0; i < unsubs.length; i += 1) {
      if (typeof unsubs[i] !== 'string') {
        stream.destroy(new Error('Invalid unsubscriptions'))
        return false
      }
      length += Buffer.byteLength(unsubs[i]) + 2
    }
  } else {
    stream.destroy(new Error('Invalid unsubscriptions'))
    return false
  }
  // properies mqtt 5
  let propertiesData = null
  if (version === 5) {
    propertiesData = getProperties(stream, properties)
    if (!propertiesData) { return false }
    length += propertiesData.length
  }

  // Header
  stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0])

  // Length
  writeVarByteInt(stream, length)

  // Message ID
  writeNumber(stream, id)

  // properies mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  }

  // Unsubs
  let result = true
  for (let j = 0; j < unsubs.length; j++) {
    result = writeString(stream, unsubs[j])
  }

  return result
}

function unsuback (packet, stream, opts) {
  const version = opts ? opts.protocolVersion : 4
  const settings = packet || {}
  const id = settings.messageId
  const dup = settings.dup ? protocol.DUP_MASK : 0
  const granted = settings.granted
  const properties = settings.properties
  const type = settings.cmd
  const qos = 0

  let length = 2

  // Check message ID
  if (typeof id !== 'number') {
    stream.destroy(new Error('Invalid messageId'))
    return false
  }

  // Check granted
  if (version === 5) {
    if (typeof granted === 'object' && granted.length) {
      for (let i = 0; i < granted.length; i += 1) {
        if (typeof granted[i] !== 'number') {
          stream.destroy(new Error('Invalid qos vector'))
          return false
        }
        length += 1
      }
    } else {
      stream.destroy(new Error('Invalid qos vector'))
      return false
    }
  }

  // properies mqtt 5
  let propertiesData = null
  if (version === 5) {
    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)
    if (!propertiesData) { return false }
    length += propertiesData.length
  }

  // Header
  stream.write(protocol.ACKS[type][qos][dup][0])

  // Length
  writeVarByteInt(stream, length)

  // Message ID
  writeNumber(stream, id)

  // properies mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  }

  // payload
  if (version === 5) {
    stream.write(Buffer.from(granted))
  }
  return true
}

function emptyPacket (packet, stream, opts) {
  return stream.write(protocol.EMPTY[packet.cmd])
}

function disconnect (packet, stream, opts) {
  const version = opts ? opts.protocolVersion : 4
  const settings = packet || {}
  const reasonCode = settings.reasonCode
  const properties = settings.properties
  let length = version === 5 ? 1 : 0

  // properies mqtt 5
  let propertiesData = null
  if (version === 5) {
    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)
    if (!propertiesData) { return false }
    length += propertiesData.length
  }

  // Header
  stream.write(Buffer.from([protocol.codes.disconnect << 4]))

  // Length
  writeVarByteInt(stream, length)

  // reason code in header
  if (version === 5) {
    stream.write(Buffer.from([reasonCode]))
  }

  // properies mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  }

  return true
}

function auth (packet, stream, opts) {
  const version = opts ? opts.protocolVersion : 4
  const settings = packet || {}
  const reasonCode = settings.reasonCode
  const properties = settings.properties
  let length = version === 5 ? 1 : 0

  if (version !== 5) stream.destroy(new Error('Invalid mqtt version for auth packet'))

  // properies mqtt 5
  const propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)
  if (!propertiesData) { return false }
  length += propertiesData.length

  // Header
  stream.write(Buffer.from([protocol.codes.auth << 4]))

  // Length
  writeVarByteInt(stream, length)

  // reason code in header
  stream.write(Buffer.from([reasonCode]))

  // properies mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  }
  return true
}

/**
 * writeVarByteInt - write an MQTT style variable byte integer to the buffer
 *
 * @param <Buffer> buffer - destination
 * @param <Number> pos - offset
 * @param <Number> length - length (>0)
 * @returns <Number> number of bytes written
 *
 * @api private
 */

const varByteIntCache = {}
function writeVarByteInt (stream, num) {
  if (num > protocol.VARBYTEINT_MAX) {
    stream.destroy(new Error(`Invalid variable byte integer: ${num}`))
    return false
  }

  let buffer = varByteIntCache[num]

  if (!buffer) {
    buffer = genBufVariableByteInt(num)
    if (num < 16384) varByteIntCache[num] = buffer
  }
  debug('writeVarByteInt: writing to stream: %o', buffer)
  return stream.write(buffer)
}

/**
 * writeString - write a utf8 string to the buffer
 *
 * @param <Buffer> buffer - destination
 * @param <Number> pos - offset
 * @param <String> string - string to write
 * @return <Number> number of bytes written
 *
 * @api private
 */

function writeString (stream, string) {
  const strlen = Buffer.byteLength(string)
  writeNumber(stream, strlen)

  debug('writeString: %s', string)
  return stream.write(string, 'utf8')
}

/**
 * writeStringPair - write a utf8 string pairs to the buffer
 *
 * @param <Buffer> buffer - destination
 * @param <String> name - string name to write
 * @param <String> value - string value to write
 * @return <Number> number of bytes written
 *
 * @api private
 */
function writeStringPair (stream, name, value) {
  writeString(stream, name)
  writeString(stream, value)
}

/**
 * writeNumber - write a two byte number to the buffer
 *
 * @param <Buffer> buffer - destination
 * @param <Number> pos - offset
 * @param <String> number - number to write
 * @return <Number> number of bytes written
 *
 * @api private
 */
function writeNumberCached (stream, number) {
  debug('writeNumberCached: number: %d', number)
  debug('writeNumberCached: %o', numCache[number])
  return stream.write(numCache[number])
}
function writeNumberGenerated (stream, number) {
  const generatedNumber = generateNumber(number)
  debug('writeNumberGenerated: %o', generatedNumber)
  return stream.write(generatedNumber)
}
function write4ByteNumber (stream, number) {
  const generated4ByteBuffer = generate4ByteBuffer(number)
  debug('write4ByteNumber: %o', generated4ByteBuffer)
  return stream.write(generated4ByteBuffer)
}
/**
 * writeStringOrBuffer - write a String or Buffer with the its length prefix
 *
 * @param <Buffer> buffer - destination
 * @param <Number> pos - offset
 * @param <String> toWrite - String or Buffer
 * @return <Number> number of bytes written
 */
function writeStringOrBuffer (stream, toWrite) {
  if (typeof toWrite === 'string') {
    writeString(stream, toWrite)
  } else if (toWrite) {
    writeNumber(stream, toWrite.length)
    stream.write(toWrite)
  } else writeNumber(stream, 0)
}

function getProperties (stream, properties) {
  /* connect properties */
  if (typeof properties !== 'object' || properties.length != null) {
    return {
      length: 1,
      write () {
        writeProperties(stream, {}, 0)
      }
    }
  }
  let propertiesLength = 0
  function getLengthProperty (name, value) {
    const type = protocol.propertiesTypes[name]
    let length = 0
    switch (type) {
      case 'byte': {
        if (typeof value !== 'boolean') {
          stream.destroy(new Error(`Invalid ${name}: ${value}`))
          return false
        }
        length += 1 + 1
        break
      }
      case 'int8': {
        if (typeof value !== 'number' || value < 0 || value > 0xff) {
          stream.destroy(new Error(`Invalid ${name}: ${value}`))
          return false
        }
        length += 1 + 1
        break
      }
      case 'binary': {
        if (value && value === null) {
          stream.destroy(new Error(`Invalid ${name}: ${value}`))
          return false
        }
        length += 1 + Buffer.byteLength(value) + 2
        break
      }
      case 'int16': {
        if (typeof value !== 'number' || value < 0 || value > 0xffff) {
          stream.destroy(new Error(`Invalid ${name}: ${value}`))
          return false
        }
        length += 1 + 2
        break
      }
      case 'int32': {
        if (typeof value !== 'number' || value < 0 || value > 0xffffffff) {
          stream.destroy(new Error(`Invalid ${name}: ${value}`))
          return false
        }
        length += 1 + 4
        break
      }
      case 'var': {
        // var byte integer is max 24 bits packed in 32 bits
        if (typeof value !== 'number' || value < 0 || value > 0x0fffffff) {
          stream.destroy(new Error(`Invalid ${name}: ${value}`))
          return false
        }
        length += 1 + Buffer.byteLength(genBufVariableByteInt(value))
        break
      }
      case 'string': {
        if (typeof value !== 'string') {
          stream.destroy(new Error(`Invalid ${name}: ${value}`))
          return false
        }
        length += 1 + 2 + Buffer.byteLength(value.toString())
        break
      }
      case 'pair': {
        if (typeof value !== 'object') {
          stream.destroy(new Error(`Invalid ${name}: ${value}`))
          return false
        }
        length += Object.getOwnPropertyNames(value).reduce((result, name) => {
          const currentValue = value[name]
          if (Array.isArray(currentValue)) {
            result += currentValue.reduce((currentLength, value) => {
              currentLength += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value.toString())
              return currentLength
            }, 0)
          } else {
            result += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value[name].toString())
          }
          return result
        }, 0)
        break
      }
      default: {
        stream.destroy(new Error(`Invalid property ${name}: ${value}`))
        return false
      }
    }
    return length
  }
  if (properties) {
    for (const propName in properties) {
      let propLength = 0
      let propValueLength = 0
      const propValue = properties[propName]
      if (Array.isArray(propValue)) {
        for (let valueIndex = 0; valueIndex < propValue.length; valueIndex++) {
          propValueLength = getLengthProperty(propName, propValue[valueIndex])
          if (!propValueLength) { return false }
          propLength += propValueLength
        }
      } else {
        propValueLength = getLengthProperty(propName, propValue)
        if (!propValueLength) { return false }
        propLength = propValueLength
      }
      if (!propLength) return false
      propertiesLength += propLength
    }
  }
  const propertiesLengthLength = Buffer.byteLength(genBufVariableByteInt(propertiesLength))

  return {
    length: propertiesLengthLength + propertiesLength,
    write () {
      writeProperties(stream, properties, propertiesLength)
    }
  }
}

function getPropertiesByMaximumPacketSize (stream, properties, opts, length) {
  const mayEmptyProps = ['reasonString', 'userProperties']
  const maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0

  let propertiesData = getProperties(stream, properties)
  if (maximumPacketSize) {
    while (length + propertiesData.length > maximumPacketSize) {
      const currentMayEmptyProp = mayEmptyProps.shift()
      if (currentMayEmptyProp && properties[currentMayEmptyProp]) {
        delete properties[currentMayEmptyProp]
        propertiesData = getProperties(stream, properties)
      } else {
        return false
      }
    }
  }
  return propertiesData
}

function writeProperty (stream, propName, value) {
  const type = protocol.propertiesTypes[propName]
  switch (type) {
    case 'byte': {
      stream.write(Buffer.from([protocol.properties[propName]]))
      stream.write(Buffer.from([+value]))
      break
    }
    case 'int8': {
      stream.write(Buffer.from([protocol.properties[propName]]))
      stream.write(Buffer.from([value]))
      break
    }
    case 'binary': {
      stream.write(Buffer.from([protocol.properties[propName]]))
      writeStringOrBuffer(stream, value)
      break
    }
    case 'int16': {
      stream.write(Buffer.from([protocol.properties[propName]]))
      writeNumber(stream, value)
      break
    }
    case 'int32': {
      stream.write(Buffer.from([protocol.properties[propName]]))
      write4ByteNumber(stream, value)
      break
    }
    case 'var': {
      stream.write(Buffer.from([protocol.properties[propName]]))
      writeVarByteInt(stream, value)
      break
    }
    case 'string': {
      stream.write(Buffer.from([protocol.properties[propName]]))
      writeString(stream, value)
      break
    }
    case 'pair': {
      Object.getOwnPropertyNames(value).forEach(name => {
        const currentValue = value[name]
        if (Array.isArray(currentValue)) {
          currentValue.forEach(value => {
            stream.write(Buffer.from([protocol.properties[propName]]))
            writeStringPair(stream, name.toString(), value.toString())
          })
        } else {
          stream.write(Buffer.from([protocol.properties[propName]]))
          writeStringPair(stream, name.toString(), currentValue.toString())
        }
      })
      break
    }
    default: {
      stream.destroy(new Error(`Invalid property ${propName} value: ${value}`))
      return false
    }
  }
}

function writeProperties (stream, properties, propertiesLength) {
  /* write properties to stream */
  writeVarByteInt(stream, propertiesLength)
  for (const propName in properties) {
    if (Object.prototype.hasOwnProperty.call(properties, propName) && properties[propName] !== null) {
      const value = properties[propName]
      if (Array.isArray(value)) {
        for (let valueIndex = 0; valueIndex < value.length; valueIndex++) {
          writeProperty(stream, propName, value[valueIndex])
        }
      } else {
        writeProperty(stream, propName, value)
      }
    }
  }
}

function byteLength (bufOrString) {
  if (!bufOrString) return 0
  else if (bufOrString instanceof Buffer) return bufOrString.length
  else return Buffer.byteLength(bufOrString)
}

function isStringOrBuffer (field) {
  return typeof field === 'string' || field instanceof Buffer
}

module.exports = generate

},{"./constants":73,"./numbers":93,"buffer":29,"debug":30,"process-nextick-args":101}],97:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],98:[function(require,module,exports){
// Copyright Takatoshi Kondo 2021
//
// Distributed under the MIT License

const NumberAllocator = require('./lib/number-allocator.js')

module.exports.NumberAllocator = NumberAllocator

},{"./lib/number-allocator.js":99}],99:[function(require,module,exports){
// Copyright Takatoshi Kondo 2021
//
// Distributed under the MIT License

'use strict'

const SortedSet = require('js-sdsl').OrderedSet
const debugTrace = require('debug')('number-allocator:trace')
const debugError = require('debug')('number-allocator:error')
/**
 * Interval constructor
 * @constructor
 * @param {Number} low  - The lowest value of the interval
 * @param {Number} high - The highest value of the interval
 */
function Interval (low, high) {
  this.low = low
  this.high = high
}

Interval.prototype.equals = function (other) {
  return this.low === other.low && this.high === other.high
}

Interval.prototype.compare = function (other) {
  if (this.low < other.low && this.high < other.low) return -1
  if (other.low < this.low && other.high < this.low) return 1
  return 0
}

/**
 * NumberAllocator constructor.
 * The all numbers are set to vacant status.
 * Time Complexity O(1)
 * @constructor
 * @param {Number} min  - The maximum number of allocatable. The number must be integer.
 * @param {Number} maxh - The minimum number of allocatable. The number must be integer.
 */
function NumberAllocator (min, max) {
  if (!(this instanceof NumberAllocator)) {
    return new NumberAllocator(min, max)
  }

  this.min = min
  this.max = max

  this.ss = new SortedSet(
    [],
    (lhs, rhs) => {
      return lhs.compare(rhs)
    }
  )
  debugTrace('Create')
  this.clear()
}

/**
 * Get the first vacant number. The status of the number is not updated.
 * Time Complexity O(1)
 * @return {Number} - The first vacant number. If all numbers are occupied, return null.
 *                    When alloc() is called then the same value will be allocated.
 */
NumberAllocator.prototype.firstVacant = function () {
  if (this.ss.size() === 0) return null
  return this.ss.front().low
}

/**
 * Allocate the first vacant number. The number become occupied status.
 * Time Complexity O(1)
 * @return {Number} - The first vacant number. If all numbers are occupied, return null.
 */
NumberAllocator.prototype.alloc = function () {
  if (this.ss.size() === 0) {
    debugTrace('alloc():empty')
    return null
  }
  const it = this.ss.begin()
  const low = it.pointer.low
  const high = it.pointer.high
  const num = low
  if (num + 1 <= high) {
    // x|----|
    this.ss.updateKeyByIterator(it, new Interval(low + 1, high))
  } else {
    this.ss.eraseElementByPos(0)
  }
  debugTrace('alloc():' + num)
  return num
}

/**
 * Use the number. The number become occupied status.
 * If the number has already been occupied, then return false.
 * Time Complexity O(logN) : N is the number of intervals (not numbers)
 * @param {Number} num - The number to request use.
 * @return {Boolean} - If `num` was not occupied, then return true, otherwise return false.
 */
NumberAllocator.prototype.use = function (num) {
  const key = new Interval(num, num)
  const it = this.ss.lowerBound(key)
  if (!it.equals(this.ss.end())) {
    const low = it.pointer.low
    const high = it.pointer.high
    if (it.pointer.equals(key)) {
      // |x|
      this.ss.eraseElementByIterator(it)
      debugTrace('use():' + num)
      return true
    }

    // x |-----|
    if (low > num) return false

    // |x----|
    if (low === num) {
      // x|----|
      this.ss.updateKeyByIterator(it, new Interval(low + 1, high))
      debugTrace('use():' + num)
      return true
    }

    // |----x|
    if (high === num) {
      // |----|x
      this.ss.updateKeyByIterator(it, new Interval(low, high - 1))
      debugTrace('use():' + num)
      return true
    }

    // |--x--|
    // x|--|
    this.ss.updateKeyByIterator(it, new Interval(num + 1, high))
    // |--|x|--|
    this.ss.insert(new Interval(low, num - 1))
    debugTrace('use():' + num)
    return true
  }

  debugTrace('use():failed')
  return false
}

/**
 * Deallocate the number. The number become vacant status.
 * Time Complexity O(logN) : N is the number of intervals (not numbers)
 * @param {Number} num - The number to deallocate. The number must be occupied status.
 *                       In other words, the number must be allocated by alloc() or occupied be use().
 */
NumberAllocator.prototype.free = function (num) {
  if (num < this.min || num > this.max) {
    debugError('free():' + num + ' is out of range')
    return
  }
  const key = new Interval(num, num)
  const it = this.ss.upperBound(key)
  if (it.equals(this.ss.end())) {
    // ....v
    if (it.equals(this.ss.begin())) {
      // Insert new interval
      this.ss.insert(key)
      return
    }
    it.pre()
    const low = it.pointer.high
    const high = it.pointer.high
    if (high + 1 === num) {
      // Concat to left
      this.ss.updateKeyByIterator(it, new Interval(low, num))
    } else {
      // Insert new interval
      this.ss.insert(key)
    }
  } else {
    if (it.equals(this.ss.begin())) {
      // v....
      if (num + 1 === it.pointer.low) {
        // Concat to right
        const high = it.pointer.high
        this.ss.updateKeyByIterator(it, new Interval(num, high))
      } else {
        // Insert new interval
        this.ss.insert(key)
      }
    } else {
      // ..v..
      const rLow = it.pointer.low
      const rHigh = it.pointer.high
      it.pre()
      const lLow = it.pointer.low
      const lHigh = it.pointer.high
      if (lHigh + 1 === num) {
        if (num + 1 === rLow) {
          // Concat to left and right
          this.ss.eraseElementByIterator(it)
          this.ss.updateKeyByIterator(it, new Interval(lLow, rHigh))
        } else {
          // Concat to left
          this.ss.updateKeyByIterator(it, new Interval(lLow, num))
        }
      } else {
        if (num + 1 === rLow) {
          // Concat to right
          this.ss.eraseElementByIterator(it.next())
          this.ss.insert(new Interval(num, rHigh))
        } else {
          // Insert new interval
          this.ss.insert(key)
        }
      }
    }
  }
  debugTrace('free():' + num)
}

/**
 * Clear all occupied numbers.
 * The all numbers are set to vacant status.
 * Time Complexity O(1)
 */
NumberAllocator.prototype.clear = function () {
  debugTrace('clear()')
  this.ss.clear()
  this.ss.insert(new Interval(this.min, this.max))
}

/**
 * Get the number of intervals. Interval is internal structure of this library.
 * This function is for debugging.
 * Time Complexity O(1)
 * @return {Number} - The number of intervals.
 */
NumberAllocator.prototype.intervalCount = function () {
  return this.ss.size()
}

/**
 * Dump the internal structor of the library.
 * This function is for debugging.
 * Time Complexity O(N) : N is the number of intervals (not numbers)
 */
NumberAllocator.prototype.dump = function () {
  console.log('length:' + this.ss.size())
  for (const element of this.ss) {
    console.log(element)
  }
}

module.exports = NumberAllocator

},{"debug":30,"js-sdsl":69}],100:[function(require,module,exports){
var wrappy = require('wrappy')
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}

},{"wrappy":140}],101:[function(require,module,exports){
(function (process){(function (){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this)}).call(this,require('_process'))
},{"_process":102}],102:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],103:[function(require,module,exports){
(function (global){(function (){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],104:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],105:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],106:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":104,"./encode":105}],107:[function(require,module,exports){
'use strict'

const { AbortError, codes } = require('../../ours/errors')
const { isNodeStream, isWebStream, kControllerErrorFunction } = require('./utils')
const eos = require('./end-of-stream')
const { ERR_INVALID_ARG_TYPE } = codes

// This method is inlined here for readable-stream
// It also does not allow for signal to not exist on the stream
// https://github.com/nodejs/node/pull/36061#discussion_r533718029
const validateAbortSignal = (signal, name) => {
  if (typeof signal !== 'object' || !('aborted' in signal)) {
    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)
  }
}
module.exports.addAbortSignal = function addAbortSignal(signal, stream) {
  validateAbortSignal(signal, 'signal')
  if (!isNodeStream(stream) && !isWebStream(stream)) {
    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)
  }
  return module.exports.addAbortSignalNoValidate(signal, stream)
}
module.exports.addAbortSignalNoValidate = function (signal, stream) {
  if (typeof signal !== 'object' || !('aborted' in signal)) {
    return stream
  }
  const onAbort = isNodeStream(stream)
    ? () => {
        stream.destroy(
          new AbortError(undefined, {
            cause: signal.reason
          })
        )
      }
    : () => {
        stream[kControllerErrorFunction](
          new AbortError(undefined, {
            cause: signal.reason
          })
        )
      }
  if (signal.aborted) {
    onAbort()
  } else {
    signal.addEventListener('abort', onAbort)
    eos(stream, () => signal.removeEventListener('abort', onAbort))
  }
  return stream
}

},{"../../ours/errors":126,"./end-of-stream":113,"./utils":122}],108:[function(require,module,exports){
'use strict'

const { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array } = require('../../ours/primordials')
const { Buffer } = require('buffer')
const { inspect } = require('../../ours/util')
module.exports = class BufferList {
  constructor() {
    this.head = null
    this.tail = null
    this.length = 0
  }
  push(v) {
    const entry = {
      data: v,
      next: null
    }
    if (this.length > 0) this.tail.next = entry
    else this.head = entry
    this.tail = entry
    ++this.length
  }
  unshift(v) {
    const entry = {
      data: v,
      next: this.head
    }
    if (this.length === 0) this.tail = entry
    this.head = entry
    ++this.length
  }
  shift() {
    if (this.length === 0) return
    const ret = this.head.data
    if (this.length === 1) this.head = this.tail = null
    else this.head = this.head.next
    --this.length
    return ret
  }
  clear() {
    this.head = this.tail = null
    this.length = 0
  }
  join(s) {
    if (this.length === 0) return ''
    let p = this.head
    let ret = '' + p.data
    while ((p = p.next) !== null) ret += s + p.data
    return ret
  }
  concat(n) {
    if (this.length === 0) return Buffer.alloc(0)
    const ret = Buffer.allocUnsafe(n >>> 0)
    let p = this.head
    let i = 0
    while (p) {
      TypedArrayPrototypeSet(ret, p.data, i)
      i += p.data.length
      p = p.next
    }
    return ret
  }

  // Consumes a specified amount of bytes or characters from the buffered data.
  consume(n, hasStrings) {
    const data = this.head.data
    if (n < data.length) {
      // `slice` is the same for buffers and strings.
      const slice = data.slice(0, n)
      this.head.data = data.slice(n)
      return slice
    }
    if (n === data.length) {
      // First chunk is a perfect match.
      return this.shift()
    }
    // Result spans more than one buffer.
    return hasStrings ? this._getString(n) : this._getBuffer(n)
  }
  first() {
    return this.head.data
  }
  *[SymbolIterator]() {
    for (let p = this.head; p; p = p.next) {
      yield p.data
    }
  }

  // Consumes a specified amount of characters from the buffered data.
  _getString(n) {
    let ret = ''
    let p = this.head
    let c = 0
    do {
      const str = p.data
      if (n > str.length) {
        ret += str
        n -= str.length
      } else {
        if (n === str.length) {
          ret += str
          ++c
          if (p.next) this.head = p.next
          else this.head = this.tail = null
        } else {
          ret += StringPrototypeSlice(str, 0, n)
          this.head = p
          p.data = StringPrototypeSlice(str, n)
        }
        break
      }
      ++c
    } while ((p = p.next) !== null)
    this.length -= c
    return ret
  }

  // Consumes a specified amount of bytes from the buffered data.
  _getBuffer(n) {
    const ret = Buffer.allocUnsafe(n)
    const retLen = n
    let p = this.head
    let c = 0
    do {
      const buf = p.data
      if (n > buf.length) {
        TypedArrayPrototypeSet(ret, buf, retLen - n)
        n -= buf.length
      } else {
        if (n === buf.length) {
          TypedArrayPrototypeSet(ret, buf, retLen - n)
          ++c
          if (p.next) this.head = p.next
          else this.head = this.tail = null
        } else {
          TypedArrayPrototypeSet(ret, new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n)
          this.head = p
          p.data = buf.slice(n)
        }
        break
      }
      ++c
    } while ((p = p.next) !== null)
    this.length -= c
    return ret
  }

  // Make sure the linked list only shows the minimal necessary information.
  [Symbol.for('nodejs.util.inspect.custom')](_, options) {
    return inspect(this, {
      ...options,
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: false
    })
  }
}

},{"../../ours/primordials":127,"../../ours/util":128,"buffer":29}],109:[function(require,module,exports){
'use strict'

const { pipeline } = require('./pipeline')
const Duplex = require('./duplex')
const { destroyer } = require('./destroy')
const {
  isNodeStream,
  isReadable,
  isWritable,
  isWebStream,
  isTransformStream,
  isWritableStream,
  isReadableStream
} = require('./utils')
const {
  AbortError,
  codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
} = require('../../ours/errors')
const eos = require('./end-of-stream')
module.exports = function compose(...streams) {
  if (streams.length === 0) {
    throw new ERR_MISSING_ARGS('streams')
  }
  if (streams.length === 1) {
    return Duplex.from(streams[0])
  }
  const orgStreams = [...streams]
  if (typeof streams[0] === 'function') {
    streams[0] = Duplex.from(streams[0])
  }
  if (typeof streams[streams.length - 1] === 'function') {
    const idx = streams.length - 1
    streams[idx] = Duplex.from(streams[idx])
  }
  for (let n = 0; n < streams.length; ++n) {
    if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
      // TODO(ronag): Add checks for non streams.
      continue
    }
    if (
      n < streams.length - 1 &&
      !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))
    ) {
      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be readable')
    }
    if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be writable')
    }
  }
  let ondrain
  let onfinish
  let onreadable
  let onclose
  let d
  function onfinished(err) {
    const cb = onclose
    onclose = null
    if (cb) {
      cb(err)
    } else if (err) {
      d.destroy(err)
    } else if (!readable && !writable) {
      d.destroy()
    }
  }
  const head = streams[0]
  const tail = pipeline(streams, onfinished)
  const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head))
  const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail))

  // TODO(ronag): Avoid double buffering.
  // Implement Writable/Readable/Duplex traits.
  // See, https://github.com/nodejs/node/pull/33515.
  d = new Duplex({
    // TODO (ronag): highWaterMark?
    writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode),
    readableObjectMode: !!(tail !== null && tail !== undefined && tail.writableObjectMode),
    writable,
    readable
  })
  if (writable) {
    if (isNodeStream(head)) {
      d._write = function (chunk, encoding, callback) {
        if (head.write(chunk, encoding)) {
          callback()
        } else {
          ondrain = callback
        }
      }
      d._final = function (callback) {
        head.end()
        onfinish = callback
      }
      head.on('drain', function () {
        if (ondrain) {
          const cb = ondrain
          ondrain = null
          cb()
        }
      })
    } else if (isWebStream(head)) {
      const writable = isTransformStream(head) ? head.writable : head
      const writer = writable.getWriter()
      d._write = async function (chunk, encoding, callback) {
        try {
          await writer.ready
          writer.write(chunk).catch(() => {})
          callback()
        } catch (err) {
          callback(err)
        }
      }
      d._final = async function (callback) {
        try {
          await writer.ready
          writer.close().catch(() => {})
          onfinish = callback
        } catch (err) {
          callback(err)
        }
      }
    }
    const toRead = isTransformStream(tail) ? tail.readable : tail
    eos(toRead, () => {
      if (onfinish) {
        const cb = onfinish
        onfinish = null
        cb()
      }
    })
  }
  if (readable) {
    if (isNodeStream(tail)) {
      tail.on('readable', function () {
        if (onreadable) {
          const cb = onreadable
          onreadable = null
          cb()
        }
      })
      tail.on('end', function () {
        d.push(null)
      })
      d._read = function () {
        while (true) {
          const buf = tail.read()
          if (buf === null) {
            onreadable = d._read
            return
          }
          if (!d.push(buf)) {
            return
          }
        }
      }
    } else if (isWebStream(tail)) {
      const readable = isTransformStream(tail) ? tail.readable : tail
      const reader = readable.getReader()
      d._read = async function () {
        while (true) {
          try {
            const { value, done } = await reader.read()
            if (!d.push(value)) {
              return
            }
            if (done) {
              d.push(null)
              return
            }
          } catch {
            return
          }
        }
      }
    }
  }
  d._destroy = function (err, callback) {
    if (!err && onclose !== null) {
      err = new AbortError()
    }
    onreadable = null
    ondrain = null
    onfinish = null
    if (onclose === null) {
      callback(err)
    } else {
      onclose = callback
      if (isNodeStream(tail)) {
        destroyer(tail, err)
      }
    }
  }
  return d
}

},{"../../ours/errors":126,"./destroy":110,"./duplex":111,"./end-of-stream":113,"./pipeline":118,"./utils":122}],110:[function(require,module,exports){
'use strict'

/* replacement start */

const process = require('process/')

/* replacement end */

const {
  aggregateTwoErrors,
  codes: { ERR_MULTIPLE_CALLBACK },
  AbortError
} = require('../../ours/errors')
const { Symbol } = require('../../ours/primordials')
const { kDestroyed, isDestroyed, isFinished, isServerRequest } = require('./utils')
const kDestroy = Symbol('kDestroy')
const kConstruct = Symbol('kConstruct')
function checkError(err, w, r) {
  if (err) {
    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
    err.stack // eslint-disable-line no-unused-expressions

    if (w && !w.errored) {
      w.errored = err
    }
    if (r && !r.errored) {
      r.errored = err
    }
  }
}

// Backwards compat. cb() is undocumented and unused in core but
// unfortunately might be used by modules.
function destroy(err, cb) {
  const r = this._readableState
  const w = this._writableState
  // With duplex streams we use the writable side for state.
  const s = w || r
  if ((w !== null && w !== undefined && w.destroyed) || (r !== null && r !== undefined && r.destroyed)) {
    if (typeof cb === 'function') {
      cb()
    }
    return this
  }

  // We set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks
  checkError(err, w, r)
  if (w) {
    w.destroyed = true
  }
  if (r) {
    r.destroyed = true
  }

  // If still constructing then defer calling _destroy.
  if (!s.constructed) {
    this.once(kDestroy, function (er) {
      _destroy(this, aggregateTwoErrors(er, err), cb)
    })
  } else {
    _destroy(this, err, cb)
  }
  return this
}
function _destroy(self, err, cb) {
  let called = false
  function onDestroy(err) {
    if (called) {
      return
    }
    called = true
    const r = self._readableState
    const w = self._writableState
    checkError(err, w, r)
    if (w) {
      w.closed = true
    }
    if (r) {
      r.closed = true
    }
    if (typeof cb === 'function') {
      cb(err)
    }
    if (err) {
      process.nextTick(emitErrorCloseNT, self, err)
    } else {
      process.nextTick(emitCloseNT, self)
    }
  }
  try {
    self._destroy(err || null, onDestroy)
  } catch (err) {
    onDestroy(err)
  }
}
function emitErrorCloseNT(self, err) {
  emitErrorNT(self, err)
  emitCloseNT(self)
}
function emitCloseNT(self) {
  const r = self._readableState
  const w = self._writableState
  if (w) {
    w.closeEmitted = true
  }
  if (r) {
    r.closeEmitted = true
  }
  if ((w !== null && w !== undefined && w.emitClose) || (r !== null && r !== undefined && r.emitClose)) {
    self.emit('close')
  }
}
function emitErrorNT(self, err) {
  const r = self._readableState
  const w = self._writableState
  if ((w !== null && w !== undefined && w.errorEmitted) || (r !== null && r !== undefined && r.errorEmitted)) {
    return
  }
  if (w) {
    w.errorEmitted = true
  }
  if (r) {
    r.errorEmitted = true
  }
  self.emit('error', err)
}
function undestroy() {
  const r = this._readableState
  const w = this._writableState
  if (r) {
    r.constructed = true
    r.closed = false
    r.closeEmitted = false
    r.destroyed = false
    r.errored = null
    r.errorEmitted = false
    r.reading = false
    r.ended = r.readable === false
    r.endEmitted = r.readable === false
  }
  if (w) {
    w.constructed = true
    w.destroyed = false
    w.closed = false
    w.closeEmitted = false
    w.errored = null
    w.errorEmitted = false
    w.finalCalled = false
    w.prefinished = false
    w.ended = w.writable === false
    w.ending = w.writable === false
    w.finished = w.writable === false
  }
}
function errorOrDestroy(stream, err, sync) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  const r = stream._readableState
  const w = stream._writableState
  if ((w !== null && w !== undefined && w.destroyed) || (r !== null && r !== undefined && r.destroyed)) {
    return this
  }
  if ((r !== null && r !== undefined && r.autoDestroy) || (w !== null && w !== undefined && w.autoDestroy))
    stream.destroy(err)
  else if (err) {
    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
    err.stack // eslint-disable-line no-unused-expressions

    if (w && !w.errored) {
      w.errored = err
    }
    if (r && !r.errored) {
      r.errored = err
    }
    if (sync) {
      process.nextTick(emitErrorNT, stream, err)
    } else {
      emitErrorNT(stream, err)
    }
  }
}
function construct(stream, cb) {
  if (typeof stream._construct !== 'function') {
    return
  }
  const r = stream._readableState
  const w = stream._writableState
  if (r) {
    r.constructed = false
  }
  if (w) {
    w.constructed = false
  }
  stream.once(kConstruct, cb)
  if (stream.listenerCount(kConstruct) > 1) {
    // Duplex
    return
  }
  process.nextTick(constructNT, stream)
}
function constructNT(stream) {
  let called = false
  function onConstruct(err) {
    if (called) {
      errorOrDestroy(stream, err !== null && err !== undefined ? err : new ERR_MULTIPLE_CALLBACK())
      return
    }
    called = true
    const r = stream._readableState
    const w = stream._writableState
    const s = w || r
    if (r) {
      r.constructed = true
    }
    if (w) {
      w.constructed = true
    }
    if (s.destroyed) {
      stream.emit(kDestroy, err)
    } else if (err) {
      errorOrDestroy(stream, err, true)
    } else {
      process.nextTick(emitConstructNT, stream)
    }
  }
  try {
    stream._construct((err) => {
      process.nextTick(onConstruct, err)
    })
  } catch (err) {
    process.nextTick(onConstruct, err)
  }
}
function emitConstructNT(stream) {
  stream.emit(kConstruct)
}
function isRequest(stream) {
  return (stream === null || stream === undefined ? undefined : stream.setHeader) && typeof stream.abort === 'function'
}
function emitCloseLegacy(stream) {
  stream.emit('close')
}
function emitErrorCloseLegacy(stream, err) {
  stream.emit('error', err)
  process.nextTick(emitCloseLegacy, stream)
}

// Normalize destroy for legacy.
function destroyer(stream, err) {
  if (!stream || isDestroyed(stream)) {
    return
  }
  if (!err && !isFinished(stream)) {
    err = new AbortError()
  }

  // TODO: Remove isRequest branches.
  if (isServerRequest(stream)) {
    stream.socket = null
    stream.destroy(err)
  } else if (isRequest(stream)) {
    stream.abort()
  } else if (isRequest(stream.req)) {
    stream.req.abort()
  } else if (typeof stream.destroy === 'function') {
    stream.destroy(err)
  } else if (typeof stream.close === 'function') {
    // TODO: Don't lose err?
    stream.close()
  } else if (err) {
    process.nextTick(emitErrorCloseLegacy, stream, err)
  } else {
    process.nextTick(emitCloseLegacy, stream)
  }
  if (!stream.destroyed) {
    stream[kDestroyed] = true
  }
}
module.exports = {
  construct,
  destroyer,
  destroy,
  undestroy,
  errorOrDestroy
}

},{"../../ours/errors":126,"../../ours/primordials":127,"./utils":122,"process/":102}],111:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototype inheritance, this class
// prototypically inherits from Readable, and then parasitically from
// Writable.

'use strict'

const {
  ObjectDefineProperties,
  ObjectGetOwnPropertyDescriptor,
  ObjectKeys,
  ObjectSetPrototypeOf
} = require('../../ours/primordials')
module.exports = Duplex
const Readable = require('./readable')
const Writable = require('./writable')
ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype)
ObjectSetPrototypeOf(Duplex, Readable)
{
  const keys = ObjectKeys(Writable.prototype)
  // Allow the keys array to be GC'ed.
  for (let i = 0; i < keys.length; i++) {
    const method = keys[i]
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method]
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options)
  Readable.call(this, options)
  Writable.call(this, options)
  if (options) {
    this.allowHalfOpen = options.allowHalfOpen !== false
    if (options.readable === false) {
      this._readableState.readable = false
      this._readableState.ended = true
      this._readableState.endEmitted = true
    }
    if (options.writable === false) {
      this._writableState.writable = false
      this._writableState.ending = true
      this._writableState.ended = true
      this._writableState.finished = true
    }
  } else {
    this.allowHalfOpen = true
  }
}
ObjectDefineProperties(Duplex.prototype, {
  writable: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writable')
  },
  writableHighWaterMark: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableHighWaterMark')
  },
  writableObjectMode: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableObjectMode')
  },
  writableBuffer: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableBuffer')
  },
  writableLength: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableLength')
  },
  writableFinished: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableFinished')
  },
  writableCorked: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableCorked')
  },
  writableEnded: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableEnded')
  },
  writableNeedDrain: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableNeedDrain')
  },
  destroyed: {
    __proto__: null,
    get() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false
      }
      return this._readableState.destroyed && this._writableState.destroyed
    },
    set(value) {
      // Backward compatibility, the user is explicitly
      // managing destroyed.
      if (this._readableState && this._writableState) {
        this._readableState.destroyed = value
        this._writableState.destroyed = value
      }
    }
  }
})
let webStreamsAdapters

// Lazy to avoid circular references
function lazyWebStreams() {
  if (webStreamsAdapters === undefined) webStreamsAdapters = {}
  return webStreamsAdapters
}
Duplex.fromWeb = function (pair, options) {
  return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options)
}
Duplex.toWeb = function (duplex) {
  return lazyWebStreams().newReadableWritablePairFromDuplex(duplex)
}
let duplexify
Duplex.from = function (body) {
  if (!duplexify) {
    duplexify = require('./duplexify')
  }
  return duplexify(body, 'body')
}

},{"../../ours/primordials":127,"./duplexify":112,"./readable":119,"./writable":123}],112:[function(require,module,exports){
/* replacement start */

const process = require('process/')

/* replacement end */

;('use strict')
const bufferModule = require('buffer')
const {
  isReadable,
  isWritable,
  isIterable,
  isNodeStream,
  isReadableNodeStream,
  isWritableNodeStream,
  isDuplexNodeStream
} = require('./utils')
const eos = require('./end-of-stream')
const {
  AbortError,
  codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
} = require('../../ours/errors')
const { destroyer } = require('./destroy')
const Duplex = require('./duplex')
const Readable = require('./readable')
const { createDeferredPromise } = require('../../ours/util')
const from = require('./from')
const Blob = globalThis.Blob || bufferModule.Blob
const isBlob =
  typeof Blob !== 'undefined'
    ? function isBlob(b) {
        return b instanceof Blob
      }
    : function isBlob(b) {
        return false
      }
const AbortController = globalThis.AbortController || require('abort-controller').AbortController
const { FunctionPrototypeCall } = require('../../ours/primordials')

// This is needed for pre node 17.
class Duplexify extends Duplex {
  constructor(options) {
    super(options)

    // https://github.com/nodejs/node/pull/34385

    if ((options === null || options === undefined ? undefined : options.readable) === false) {
      this._readableState.readable = false
      this._readableState.ended = true
      this._readableState.endEmitted = true
    }
    if ((options === null || options === undefined ? undefined : options.writable) === false) {
      this._writableState.writable = false
      this._writableState.ending = true
      this._writableState.ended = true
      this._writableState.finished = true
    }
  }
}
module.exports = function duplexify(body, name) {
  if (isDuplexNodeStream(body)) {
    return body
  }
  if (isReadableNodeStream(body)) {
    return _duplexify({
      readable: body
    })
  }
  if (isWritableNodeStream(body)) {
    return _duplexify({
      writable: body
    })
  }
  if (isNodeStream(body)) {
    return _duplexify({
      writable: false,
      readable: false
    })
  }

  // TODO: Webstreams
  // if (isReadableStream(body)) {
  //   return _duplexify({ readable: Readable.fromWeb(body) });
  // }

  // TODO: Webstreams
  // if (isWritableStream(body)) {
  //   return _duplexify({ writable: Writable.fromWeb(body) });
  // }

  if (typeof body === 'function') {
    const { value, write, final, destroy } = fromAsyncGen(body)
    if (isIterable(value)) {
      return from(Duplexify, value, {
        // TODO (ronag): highWaterMark?
        objectMode: true,
        write,
        final,
        destroy
      })
    }
    const then = value === null || value === undefined ? undefined : value.then
    if (typeof then === 'function') {
      let d
      const promise = FunctionPrototypeCall(
        then,
        value,
        (val) => {
          if (val != null) {
            throw new ERR_INVALID_RETURN_VALUE('nully', 'body', val)
          }
        },
        (err) => {
          destroyer(d, err)
        }
      )
      return (d = new Duplexify({
        // TODO (ronag): highWaterMark?
        objectMode: true,
        readable: false,
        write,
        final(cb) {
          final(async () => {
            try {
              await promise
              process.nextTick(cb, null)
            } catch (err) {
              process.nextTick(cb, err)
            }
          })
        },
        destroy
      }))
    }
    throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or AsyncFunction', name, value)
  }
  if (isBlob(body)) {
    return duplexify(body.arrayBuffer())
  }
  if (isIterable(body)) {
    return from(Duplexify, body, {
      // TODO (ronag): highWaterMark?
      objectMode: true,
      writable: false
    })
  }

  // TODO: Webstreams.
  // if (
  //   isReadableStream(body?.readable) &&
  //   isWritableStream(body?.writable)
  // ) {
  //   return Duplexify.fromWeb(body);
  // }

  if (
    typeof (body === null || body === undefined ? undefined : body.writable) === 'object' ||
    typeof (body === null || body === undefined ? undefined : body.readable) === 'object'
  ) {
    const readable =
      body !== null && body !== undefined && body.readable
        ? isReadableNodeStream(body === null || body === undefined ? undefined : body.readable)
          ? body === null || body === undefined
            ? undefined
            : body.readable
          : duplexify(body.readable)
        : undefined
    const writable =
      body !== null && body !== undefined && body.writable
        ? isWritableNodeStream(body === null || body === undefined ? undefined : body.writable)
          ? body === null || body === undefined
            ? undefined
            : body.writable
          : duplexify(body.writable)
        : undefined
    return _duplexify({
      readable,
      writable
    })
  }
  const then = body === null || body === undefined ? undefined : body.then
  if (typeof then === 'function') {
    let d
    FunctionPrototypeCall(
      then,
      body,
      (val) => {
        if (val != null) {
          d.push(val)
        }
        d.push(null)
      },
      (err) => {
        destroyer(d, err)
      }
    )
    return (d = new Duplexify({
      objectMode: true,
      writable: false,
      read() {}
    }))
  }
  throw new ERR_INVALID_ARG_TYPE(
    name,
    [
      'Blob',
      'ReadableStream',
      'WritableStream',
      'Stream',
      'Iterable',
      'AsyncIterable',
      'Function',
      '{ readable, writable } pair',
      'Promise'
    ],
    body
  )
}
function fromAsyncGen(fn) {
  let { promise, resolve } = createDeferredPromise()
  const ac = new AbortController()
  const signal = ac.signal
  const value = fn(
    (async function* () {
      while (true) {
        const _promise = promise
        promise = null
        const { chunk, done, cb } = await _promise
        process.nextTick(cb)
        if (done) return
        if (signal.aborted)
          throw new AbortError(undefined, {
            cause: signal.reason
          })
        ;({ promise, resolve } = createDeferredPromise())
        yield chunk
      }
    })(),
    {
      signal
    }
  )
  return {
    value,
    write(chunk, encoding, cb) {
      const _resolve = resolve
      resolve = null
      _resolve({
        chunk,
        done: false,
        cb
      })
    },
    final(cb) {
      const _resolve = resolve
      resolve = null
      _resolve({
        done: true,
        cb
      })
    },
    destroy(err, cb) {
      ac.abort()
      cb(err)
    }
  }
}
function _duplexify(pair) {
  const r = pair.readable && typeof pair.readable.read !== 'function' ? Readable.wrap(pair.readable) : pair.readable
  const w = pair.writable
  let readable = !!isReadable(r)
  let writable = !!isWritable(w)
  let ondrain
  let onfinish
  let onreadable
  let onclose
  let d
  function onfinished(err) {
    const cb = onclose
    onclose = null
    if (cb) {
      cb(err)
    } else if (err) {
      d.destroy(err)
    }
  }

  // TODO(ronag): Avoid double buffering.
  // Implement Writable/Readable/Duplex traits.
  // See, https://github.com/nodejs/node/pull/33515.
  d = new Duplexify({
    // TODO (ronag): highWaterMark?
    readableObjectMode: !!(r !== null && r !== undefined && r.readableObjectMode),
    writableObjectMode: !!(w !== null && w !== undefined && w.writableObjectMode),
    readable,
    writable
  })
  if (writable) {
    eos(w, (err) => {
      writable = false
      if (err) {
        destroyer(r, err)
      }
      onfinished(err)
    })
    d._write = function (chunk, encoding, callback) {
      if (w.write(chunk, encoding)) {
        callback()
      } else {
        ondrain = callback
      }
    }
    d._final = function (callback) {
      w.end()
      onfinish = callback
    }
    w.on('drain', function () {
      if (ondrain) {
        const cb = ondrain
        ondrain = null
        cb()
      }
    })
    w.on('finish', function () {
      if (onfinish) {
        const cb = onfinish
        onfinish = null
        cb()
      }
    })
  }
  if (readable) {
    eos(r, (err) => {
      readable = false
      if (err) {
        destroyer(r, err)
      }
      onfinished(err)
    })
    r.on('readable', function () {
      if (onreadable) {
        const cb = onreadable
        onreadable = null
        cb()
      }
    })
    r.on('end', function () {
      d.push(null)
    })
    d._read = function () {
      while (true) {
        const buf = r.read()
        if (buf === null) {
          onreadable = d._read
          return
        }
        if (!d.push(buf)) {
          return
        }
      }
    }
  }
  d._destroy = function (err, callback) {
    if (!err && onclose !== null) {
      err = new AbortError()
    }
    onreadable = null
    ondrain = null
    onfinish = null
    if (onclose === null) {
      callback(err)
    } else {
      onclose = callback
      destroyer(w, err)
      destroyer(r, err)
    }
  }
  return d
}

},{"../../ours/errors":126,"../../ours/primordials":127,"../../ours/util":128,"./destroy":110,"./duplex":111,"./end-of-stream":113,"./from":114,"./readable":119,"./utils":122,"abort-controller":24,"buffer":29,"process/":102}],113:[function(require,module,exports){
/* replacement start */

const process = require('process/')

/* replacement end */
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).

;('use strict')
const { AbortError, codes } = require('../../ours/errors')
const { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes
const { kEmptyObject, once } = require('../../ours/util')
const { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require('../validators')
const { Promise, PromisePrototypeThen } = require('../../ours/primordials')
const {
  isClosed,
  isReadable,
  isReadableNodeStream,
  isReadableStream,
  isReadableFinished,
  isReadableErrored,
  isWritable,
  isWritableNodeStream,
  isWritableStream,
  isWritableFinished,
  isWritableErrored,
  isNodeStream,
  willEmitClose: _willEmitClose,
  kIsClosedPromise
} = require('./utils')
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function'
}
const nop = () => {}
function eos(stream, options, callback) {
  var _options$readable, _options$writable
  if (arguments.length === 2) {
    callback = options
    options = kEmptyObject
  } else if (options == null) {
    options = kEmptyObject
  } else {
    validateObject(options, 'options')
  }
  validateFunction(callback, 'callback')
  validateAbortSignal(options.signal, 'options.signal')
  callback = once(callback)
  if (isReadableStream(stream) || isWritableStream(stream)) {
    return eosWeb(stream, options, callback)
  }
  if (!isNodeStream(stream)) {
    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)
  }
  const readable =
    (_options$readable = options.readable) !== null && _options$readable !== undefined
      ? _options$readable
      : isReadableNodeStream(stream)
  const writable =
    (_options$writable = options.writable) !== null && _options$writable !== undefined
      ? _options$writable
      : isWritableNodeStream(stream)
  const wState = stream._writableState
  const rState = stream._readableState
  const onlegacyfinish = () => {
    if (!stream.writable) {
      onfinish()
    }
  }

  // TODO (ronag): Improve soft detection to include core modules and
  // common ecosystem modules that do properly emit 'close' but fail
  // this generic check.
  let willEmitClose =
    _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable
  let writableFinished = isWritableFinished(stream, false)
  const onfinish = () => {
    writableFinished = true
    // Stream should not be destroyed here. If it is that
    // means that user space is doing something differently and
    // we cannot trust willEmitClose.
    if (stream.destroyed) {
      willEmitClose = false
    }
    if (willEmitClose && (!stream.readable || readable)) {
      return
    }
    if (!readable || readableFinished) {
      callback.call(stream)
    }
  }
  let readableFinished = isReadableFinished(stream, false)
  const onend = () => {
    readableFinished = true
    // Stream should not be destroyed here. If it is that
    // means that user space is doing something differently and
    // we cannot trust willEmitClose.
    if (stream.destroyed) {
      willEmitClose = false
    }
    if (willEmitClose && (!stream.writable || writable)) {
      return
    }
    if (!writable || writableFinished) {
      callback.call(stream)
    }
  }
  const onerror = (err) => {
    callback.call(stream, err)
  }
  let closed = isClosed(stream)
  const onclose = () => {
    closed = true
    const errored = isWritableErrored(stream) || isReadableErrored(stream)
    if (errored && typeof errored !== 'boolean') {
      return callback.call(stream, errored)
    }
    if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
      if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())
    }
    if (writable && !writableFinished) {
      if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())
    }
    callback.call(stream)
  }
  const onclosed = () => {
    closed = true
    const errored = isWritableErrored(stream) || isReadableErrored(stream)
    if (errored && typeof errored !== 'boolean') {
      return callback.call(stream, errored)
    }
    callback.call(stream)
  }
  const onrequest = () => {
    stream.req.on('finish', onfinish)
  }
  if (isRequest(stream)) {
    stream.on('complete', onfinish)
    if (!willEmitClose) {
      stream.on('abort', onclose)
    }
    if (stream.req) {
      onrequest()
    } else {
      stream.on('request', onrequest)
    }
  } else if (writable && !wState) {
    // legacy streams
    stream.on('end', onlegacyfinish)
    stream.on('close', onlegacyfinish)
  }

  // Not all streams will emit 'close' after 'aborted'.
  if (!willEmitClose && typeof stream.aborted === 'boolean') {
    stream.on('aborted', onclose)
  }
  stream.on('end', onend)
  stream.on('finish', onfinish)
  if (options.error !== false) {
    stream.on('error', onerror)
  }
  stream.on('close', onclose)
  if (closed) {
    process.nextTick(onclose)
  } else if (
    (wState !== null && wState !== undefined && wState.errorEmitted) ||
    (rState !== null && rState !== undefined && rState.errorEmitted)
  ) {
    if (!willEmitClose) {
      process.nextTick(onclosed)
    }
  } else if (
    !readable &&
    (!willEmitClose || isReadable(stream)) &&
    (writableFinished || isWritable(stream) === false)
  ) {
    process.nextTick(onclosed)
  } else if (
    !writable &&
    (!willEmitClose || isWritable(stream)) &&
    (readableFinished || isReadable(stream) === false)
  ) {
    process.nextTick(onclosed)
  } else if (rState && stream.req && stream.aborted) {
    process.nextTick(onclosed)
  }
  const cleanup = () => {
    callback = nop
    stream.removeListener('aborted', onclose)
    stream.removeListener('complete', onfinish)
    stream.removeListener('abort', onclose)
    stream.removeListener('request', onrequest)
    if (stream.req) stream.req.removeListener('finish', onfinish)
    stream.removeListener('end', onlegacyfinish)
    stream.removeListener('close', onlegacyfinish)
    stream.removeListener('finish', onfinish)
    stream.removeListener('end', onend)
    stream.removeListener('error', onerror)
    stream.removeListener('close', onclose)
  }
  if (options.signal && !closed) {
    const abort = () => {
      // Keep it because cleanup removes it.
      const endCallback = callback
      cleanup()
      endCallback.call(
        stream,
        new AbortError(undefined, {
          cause: options.signal.reason
        })
      )
    }
    if (options.signal.aborted) {
      process.nextTick(abort)
    } else {
      const originalCallback = callback
      callback = once((...args) => {
        options.signal.removeEventListener('abort', abort)
        originalCallback.apply(stream, args)
      })
      options.signal.addEventListener('abort', abort)
    }
  }
  return cleanup
}
function eosWeb(stream, options, callback) {
  let isAborted = false
  let abort = nop
  if (options.signal) {
    abort = () => {
      isAborted = true
      callback.call(
        stream,
        new AbortError(undefined, {
          cause: options.signal.reason
        })
      )
    }
    if (options.signal.aborted) {
      process.nextTick(abort)
    } else {
      const originalCallback = callback
      callback = once((...args) => {
        options.signal.removeEventListener('abort', abort)
        originalCallback.apply(stream, args)
      })
      options.signal.addEventListener('abort', abort)
    }
  }
  const resolverFn = (...args) => {
    if (!isAborted) {
      process.nextTick(() => callback.apply(stream, args))
    }
  }
  PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn)
  return nop
}
function finished(stream, opts) {
  var _opts
  let autoCleanup = false
  if (opts === null) {
    opts = kEmptyObject
  }
  if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {
    validateBoolean(opts.cleanup, 'cleanup')
    autoCleanup = opts.cleanup
  }
  return new Promise((resolve, reject) => {
    const cleanup = eos(stream, opts, (err) => {
      if (autoCleanup) {
        cleanup()
      }
      if (err) {
        reject(err)
      } else {
        resolve()
      }
    })
  })
}
module.exports = eos
module.exports.finished = finished

},{"../../ours/errors":126,"../../ours/primordials":127,"../../ours/util":128,"../validators":124,"./utils":122,"process/":102}],114:[function(require,module,exports){
'use strict'

/* replacement start */

const process = require('process/')

/* replacement end */

const { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require('../../ours/primordials')
const { Buffer } = require('buffer')
const { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require('../../ours/errors').codes
function from(Readable, iterable, opts) {
  let iterator
  if (typeof iterable === 'string' || iterable instanceof Buffer) {
    return new Readable({
      objectMode: true,
      ...opts,
      read() {
        this.push(iterable)
        this.push(null)
      }
    })
  }
  let isAsync
  if (iterable && iterable[SymbolAsyncIterator]) {
    isAsync = true
    iterator = iterable[SymbolAsyncIterator]()
  } else if (iterable && iterable[SymbolIterator]) {
    isAsync = false
    iterator = iterable[SymbolIterator]()
  } else {
    throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable)
  }
  const readable = new Readable({
    objectMode: true,
    highWaterMark: 1,
    // TODO(ronag): What options should be allowed?
    ...opts
  })

  // Flag to protect against _read
  // being called before last iteration completion.
  let reading = false
  readable._read = function () {
    if (!reading) {
      reading = true
      next()
    }
  }
  readable._destroy = function (error, cb) {
    PromisePrototypeThen(
      close(error),
      () => process.nextTick(cb, error),
      // nextTick is here in case cb throws
      (e) => process.nextTick(cb, e || error)
    )
  }
  async function close(error) {
    const hadError = error !== undefined && error !== null
    const hasThrow = typeof iterator.throw === 'function'
    if (hadError && hasThrow) {
      const { value, done } = await iterator.throw(error)
      await value
      if (done) {
        return
      }
    }
    if (typeof iterator.return === 'function') {
      const { value } = await iterator.return()
      await value
    }
  }
  async function next() {
    for (;;) {
      try {
        const { value, done } = isAsync ? await iterator.next() : iterator.next()
        if (done) {
          readable.push(null)
        } else {
          const res = value && typeof value.then === 'function' ? await value : value
          if (res === null) {
            reading = false
            throw new ERR_STREAM_NULL_VALUES()
          } else if (readable.push(res)) {
            continue
          } else {
            reading = false
          }
        }
      } catch (err) {
        readable.destroy(err)
      }
      break
    }
  }
  return readable
}
module.exports = from

},{"../../ours/errors":126,"../../ours/primordials":127,"buffer":29,"process/":102}],115:[function(require,module,exports){
'use strict'

const { ArrayIsArray, ObjectSetPrototypeOf } = require('../../ours/primordials')
const { EventEmitter: EE } = require('events')
function Stream(opts) {
  EE.call(this, opts)
}
ObjectSetPrototypeOf(Stream.prototype, EE.prototype)
ObjectSetPrototypeOf(Stream, EE)
Stream.prototype.pipe = function (dest, options) {
  const source = this
  function ondata(chunk) {
    if (dest.writable && dest.write(chunk) === false && source.pause) {
      source.pause()
    }
  }
  source.on('data', ondata)
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume()
    }
  }
  dest.on('drain', ondrain)

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend)
    source.on('close', onclose)
  }
  let didOnEnd = false
  function onend() {
    if (didOnEnd) return
    didOnEnd = true
    dest.end()
  }
  function onclose() {
    if (didOnEnd) return
    didOnEnd = true
    if (typeof dest.destroy === 'function') dest.destroy()
  }

  // Don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup()
    if (EE.listenerCount(this, 'error') === 0) {
      this.emit('error', er)
    }
  }
  prependListener(source, 'error', onerror)
  prependListener(dest, 'error', onerror)

  // Remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata)
    dest.removeListener('drain', ondrain)
    source.removeListener('end', onend)
    source.removeListener('close', onclose)
    source.removeListener('error', onerror)
    dest.removeListener('error', onerror)
    source.removeListener('end', cleanup)
    source.removeListener('close', cleanup)
    dest.removeListener('close', cleanup)
  }
  source.on('end', cleanup)
  source.on('close', cleanup)
  dest.on('close', cleanup)
  dest.emit('pipe', source)

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest
}
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn)

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn)
  else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn)
  else emitter._events[event] = [fn, emitter._events[event]]
}
module.exports = {
  Stream,
  prependListener
}

},{"../../ours/primordials":127,"events":49}],116:[function(require,module,exports){
'use strict'

const AbortController = globalThis.AbortController || require('abort-controller').AbortController
const {
  codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
  AbortError
} = require('../../ours/errors')
const { validateAbortSignal, validateInteger, validateObject } = require('../validators')
const kWeakHandler = require('../../ours/primordials').Symbol('kWeak')
const { finished } = require('./end-of-stream')
const staticCompose = require('./compose')
const { addAbortSignalNoValidate } = require('./add-abort-signal')
const { isWritable, isNodeStream } = require('./utils')
const {
  ArrayPrototypePush,
  MathFloor,
  Number,
  NumberIsNaN,
  Promise,
  PromiseReject,
  PromisePrototypeThen,
  Symbol
} = require('../../ours/primordials')
const kEmpty = Symbol('kEmpty')
const kEof = Symbol('kEof')
function compose(stream, options) {
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  if (isNodeStream(stream) && !isWritable(stream)) {
    throw new ERR_INVALID_ARG_VALUE('stream', stream, 'must be writable')
  }
  const composedStream = staticCompose(this, stream)
  if (options !== null && options !== undefined && options.signal) {
    // Not validating as we already validated before
    addAbortSignalNoValidate(options.signal, composedStream)
  }
  return composedStream
}
function map(fn, options) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)
  }
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  let concurrency = 1
  if ((options === null || options === undefined ? undefined : options.concurrency) != null) {
    concurrency = MathFloor(options.concurrency)
  }
  validateInteger(concurrency, 'concurrency', 1)
  return async function* map() {
    var _options$signal, _options$signal2
    const ac = new AbortController()
    const stream = this
    const queue = []
    const signal = ac.signal
    const signalOpt = {
      signal
    }
    const abort = () => ac.abort()
    if (
      options !== null &&
      options !== undefined &&
      (_options$signal = options.signal) !== null &&
      _options$signal !== undefined &&
      _options$signal.aborted
    ) {
      abort()
    }
    options === null || options === undefined
      ? undefined
      : (_options$signal2 = options.signal) === null || _options$signal2 === undefined
      ? undefined
      : _options$signal2.addEventListener('abort', abort)
    let next
    let resume
    let done = false
    function onDone() {
      done = true
    }
    async function pump() {
      try {
        for await (let val of stream) {
          var _val
          if (done) {
            return
          }
          if (signal.aborted) {
            throw new AbortError()
          }
          try {
            val = fn(val, signalOpt)
          } catch (err) {
            val = PromiseReject(err)
          }
          if (val === kEmpty) {
            continue
          }
          if (typeof ((_val = val) === null || _val === undefined ? undefined : _val.catch) === 'function') {
            val.catch(onDone)
          }
          queue.push(val)
          if (next) {
            next()
            next = null
          }
          if (!done && queue.length && queue.length >= concurrency) {
            await new Promise((resolve) => {
              resume = resolve
            })
          }
        }
        queue.push(kEof)
      } catch (err) {
        const val = PromiseReject(err)
        PromisePrototypeThen(val, undefined, onDone)
        queue.push(val)
      } finally {
        var _options$signal3
        done = true
        if (next) {
          next()
          next = null
        }
        options === null || options === undefined
          ? undefined
          : (_options$signal3 = options.signal) === null || _options$signal3 === undefined
          ? undefined
          : _options$signal3.removeEventListener('abort', abort)
      }
    }
    pump()
    try {
      while (true) {
        while (queue.length > 0) {
          const val = await queue[0]
          if (val === kEof) {
            return
          }
          if (signal.aborted) {
            throw new AbortError()
          }
          if (val !== kEmpty) {
            yield val
          }
          queue.shift()
          if (resume) {
            resume()
            resume = null
          }
        }
        await new Promise((resolve) => {
          next = resolve
        })
      }
    } finally {
      ac.abort()
      done = true
      if (resume) {
        resume()
        resume = null
      }
    }
  }.call(this)
}
function asIndexedPairs(options = undefined) {
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  return async function* asIndexedPairs() {
    let index = 0
    for await (const val of this) {
      var _options$signal4
      if (
        options !== null &&
        options !== undefined &&
        (_options$signal4 = options.signal) !== null &&
        _options$signal4 !== undefined &&
        _options$signal4.aborted
      ) {
        throw new AbortError({
          cause: options.signal.reason
        })
      }
      yield [index++, val]
    }
  }.call(this)
}
async function some(fn, options = undefined) {
  for await (const unused of filter.call(this, fn, options)) {
    return true
  }
  return false
}
async function every(fn, options = undefined) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)
  }
  // https://en.wikipedia.org/wiki/De_Morgan%27s_laws
  return !(await some.call(
    this,
    async (...args) => {
      return !(await fn(...args))
    },
    options
  ))
}
async function find(fn, options) {
  for await (const result of filter.call(this, fn, options)) {
    return result
  }
  return undefined
}
async function forEach(fn, options) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)
  }
  async function forEachFn(value, options) {
    await fn(value, options)
    return kEmpty
  }
  // eslint-disable-next-line no-unused-vars
  for await (const unused of map.call(this, forEachFn, options));
}
function filter(fn, options) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)
  }
  async function filterFn(value, options) {
    if (await fn(value, options)) {
      return value
    }
    return kEmpty
  }
  return map.call(this, filterFn, options)
}

// Specific to provide better error to reduce since the argument is only
// missing if the stream has no items in it - but the code is still appropriate
class ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {
  constructor() {
    super('reduce')
    this.message = 'Reduce of an empty stream requires an initial value'
  }
}
async function reduce(reducer, initialValue, options) {
  var _options$signal5
  if (typeof reducer !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('reducer', ['Function', 'AsyncFunction'], reducer)
  }
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  let hasInitialValue = arguments.length > 1
  if (
    options !== null &&
    options !== undefined &&
    (_options$signal5 = options.signal) !== null &&
    _options$signal5 !== undefined &&
    _options$signal5.aborted
  ) {
    const err = new AbortError(undefined, {
      cause: options.signal.reason
    })
    this.once('error', () => {}) // The error is already propagated
    await finished(this.destroy(err))
    throw err
  }
  const ac = new AbortController()
  const signal = ac.signal
  if (options !== null && options !== undefined && options.signal) {
    const opts = {
      once: true,
      [kWeakHandler]: this
    }
    options.signal.addEventListener('abort', () => ac.abort(), opts)
  }
  let gotAnyItemFromStream = false
  try {
    for await (const value of this) {
      var _options$signal6
      gotAnyItemFromStream = true
      if (
        options !== null &&
        options !== undefined &&
        (_options$signal6 = options.signal) !== null &&
        _options$signal6 !== undefined &&
        _options$signal6.aborted
      ) {
        throw new AbortError()
      }
      if (!hasInitialValue) {
        initialValue = value
        hasInitialValue = true
      } else {
        initialValue = await reducer(initialValue, value, {
          signal
        })
      }
    }
    if (!gotAnyItemFromStream && !hasInitialValue) {
      throw new ReduceAwareErrMissingArgs()
    }
  } finally {
    ac.abort()
  }
  return initialValue
}
async function toArray(options) {
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  const result = []
  for await (const val of this) {
    var _options$signal7
    if (
      options !== null &&
      options !== undefined &&
      (_options$signal7 = options.signal) !== null &&
      _options$signal7 !== undefined &&
      _options$signal7.aborted
    ) {
      throw new AbortError(undefined, {
        cause: options.signal.reason
      })
    }
    ArrayPrototypePush(result, val)
  }
  return result
}
function flatMap(fn, options) {
  const values = map.call(this, fn, options)
  return async function* flatMap() {
    for await (const val of values) {
      yield* val
    }
  }.call(this)
}
function toIntegerOrInfinity(number) {
  // We coerce here to align with the spec
  // https://github.com/tc39/proposal-iterator-helpers/issues/169
  number = Number(number)
  if (NumberIsNaN(number)) {
    return 0
  }
  if (number < 0) {
    throw new ERR_OUT_OF_RANGE('number', '>= 0', number)
  }
  return number
}
function drop(number, options = undefined) {
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  number = toIntegerOrInfinity(number)
  return async function* drop() {
    var _options$signal8
    if (
      options !== null &&
      options !== undefined &&
      (_options$signal8 = options.signal) !== null &&
      _options$signal8 !== undefined &&
      _options$signal8.aborted
    ) {
      throw new AbortError()
    }
    for await (const val of this) {
      var _options$signal9
      if (
        options !== null &&
        options !== undefined &&
        (_options$signal9 = options.signal) !== null &&
        _options$signal9 !== undefined &&
        _options$signal9.aborted
      ) {
        throw new AbortError()
      }
      if (number-- <= 0) {
        yield val
      }
    }
  }.call(this)
}
function take(number, options = undefined) {
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  number = toIntegerOrInfinity(number)
  return async function* take() {
    var _options$signal10
    if (
      options !== null &&
      options !== undefined &&
      (_options$signal10 = options.signal) !== null &&
      _options$signal10 !== undefined &&
      _options$signal10.aborted
    ) {
      throw new AbortError()
    }
    for await (const val of this) {
      var _options$signal11
      if (
        options !== null &&
        options !== undefined &&
        (_options$signal11 = options.signal) !== null &&
        _options$signal11 !== undefined &&
        _options$signal11.aborted
      ) {
        throw new AbortError()
      }
      if (number-- > 0) {
        yield val
      } else {
        return
      }
    }
  }.call(this)
}
module.exports.streamReturningOperators = {
  asIndexedPairs,
  drop,
  filter,
  flatMap,
  map,
  take,
  compose
}
module.exports.promiseReturningOperators = {
  every,
  forEach,
  reduce,
  toArray,
  some,
  find
}

},{"../../ours/errors":126,"../../ours/primordials":127,"../validators":124,"./add-abort-signal":107,"./compose":109,"./end-of-stream":113,"./utils":122,"abort-controller":24}],117:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict'

const { ObjectSetPrototypeOf } = require('../../ours/primordials')
module.exports = PassThrough
const Transform = require('./transform')
ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype)
ObjectSetPrototypeOf(PassThrough, Transform)
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options)
  Transform.call(this, options)
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk)
}

},{"../../ours/primordials":127,"./transform":121}],118:[function(require,module,exports){
/* replacement start */

const process = require('process/')

/* replacement end */
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).

;('use strict')
const { ArrayIsArray, Promise, SymbolAsyncIterator } = require('../../ours/primordials')
const eos = require('./end-of-stream')
const { once } = require('../../ours/util')
const destroyImpl = require('./destroy')
const Duplex = require('./duplex')
const {
  aggregateTwoErrors,
  codes: {
    ERR_INVALID_ARG_TYPE,
    ERR_INVALID_RETURN_VALUE,
    ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED,
    ERR_STREAM_PREMATURE_CLOSE
  },
  AbortError
} = require('../../ours/errors')
const { validateFunction, validateAbortSignal } = require('../validators')
const {
  isIterable,
  isReadable,
  isReadableNodeStream,
  isNodeStream,
  isTransformStream,
  isWebStream,
  isReadableStream,
  isReadableEnded
} = require('./utils')
const AbortController = globalThis.AbortController || require('abort-controller').AbortController
let PassThrough
let Readable
function destroyer(stream, reading, writing) {
  let finished = false
  stream.on('close', () => {
    finished = true
  })
  const cleanup = eos(
    stream,
    {
      readable: reading,
      writable: writing
    },
    (err) => {
      finished = !err
    }
  )
  return {
    destroy: (err) => {
      if (finished) return
      finished = true
      destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED('pipe'))
    },
    cleanup
  }
}
function popCallback(streams) {
  // Streams should never be an empty array. It should always contain at least
  // a single stream. Therefore optimize for the average case instead of
  // checking for length === 0 as well.
  validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]')
  return streams.pop()
}
function makeAsyncIterable(val) {
  if (isIterable(val)) {
    return val
  } else if (isReadableNodeStream(val)) {
    // Legacy streams are not Iterable.
    return fromReadable(val)
  }
  throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], val)
}
async function* fromReadable(val) {
  if (!Readable) {
    Readable = require('./readable')
  }
  yield* Readable.prototype[SymbolAsyncIterator].call(val)
}
async function pumpToNode(iterable, writable, finish, { end }) {
  let error
  let onresolve = null
  const resume = (err) => {
    if (err) {
      error = err
    }
    if (onresolve) {
      const callback = onresolve
      onresolve = null
      callback()
    }
  }
  const wait = () =>
    new Promise((resolve, reject) => {
      if (error) {
        reject(error)
      } else {
        onresolve = () => {
          if (error) {
            reject(error)
          } else {
            resolve()
          }
        }
      }
    })
  writable.on('drain', resume)
  const cleanup = eos(
    writable,
    {
      readable: false
    },
    resume
  )
  try {
    if (writable.writableNeedDrain) {
      await wait()
    }
    for await (const chunk of iterable) {
      if (!writable.write(chunk)) {
        await wait()
      }
    }
    if (end) {
      writable.end()
    }
    await wait()
    finish()
  } catch (err) {
    finish(error !== err ? aggregateTwoErrors(error, err) : err)
  } finally {
    cleanup()
    writable.off('drain', resume)
  }
}
async function pumpToWeb(readable, writable, finish, { end }) {
  if (isTransformStream(writable)) {
    writable = writable.writable
  }
  // https://streams.spec.whatwg.org/#example-manual-write-with-backpressure
  const writer = writable.getWriter()
  try {
    for await (const chunk of readable) {
      await writer.ready
      writer.write(chunk).catch(() => {})
    }
    await writer.ready
    if (end) {
      await writer.close()
    }
    finish()
  } catch (err) {
    try {
      await writer.abort(err)
      finish(err)
    } catch (err) {
      finish(err)
    }
  }
}
function pipeline(...streams) {
  return pipelineImpl(streams, once(popCallback(streams)))
}
function pipelineImpl(streams, callback, opts) {
  if (streams.length === 1 && ArrayIsArray(streams[0])) {
    streams = streams[0]
  }
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams')
  }
  const ac = new AbortController()
  const signal = ac.signal
  const outerSignal = opts === null || opts === undefined ? undefined : opts.signal

  // Need to cleanup event listeners if last stream is readable
  // https://github.com/nodejs/node/issues/35452
  const lastStreamCleanup = []
  validateAbortSignal(outerSignal, 'options.signal')
  function abort() {
    finishImpl(new AbortError())
  }
  outerSignal === null || outerSignal === undefined ? undefined : outerSignal.addEventListener('abort', abort)
  let error
  let value
  const destroys = []
  let finishCount = 0
  function finish(err) {
    finishImpl(err, --finishCount === 0)
  }
  function finishImpl(err, final) {
    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {
      error = err
    }
    if (!error && !final) {
      return
    }
    while (destroys.length) {
      destroys.shift()(error)
    }
    outerSignal === null || outerSignal === undefined ? undefined : outerSignal.removeEventListener('abort', abort)
    ac.abort()
    if (final) {
      if (!error) {
        lastStreamCleanup.forEach((fn) => fn())
      }
      process.nextTick(callback, error, value)
    }
  }
  let ret
  for (let i = 0; i < streams.length; i++) {
    const stream = streams[i]
    const reading = i < streams.length - 1
    const writing = i > 0
    const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false
    const isLastStream = i === streams.length - 1
    if (isNodeStream(stream)) {
      if (end) {
        const { destroy, cleanup } = destroyer(stream, reading, writing)
        destroys.push(destroy)
        if (isReadable(stream) && isLastStream) {
          lastStreamCleanup.push(cleanup)
        }
      }

      // Catch stream errors that occur after pipe/pump has completed.
      function onError(err) {
        if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
          finish(err)
        }
      }
      stream.on('error', onError)
      if (isReadable(stream) && isLastStream) {
        lastStreamCleanup.push(() => {
          stream.removeListener('error', onError)
        })
      }
    }
    if (i === 0) {
      if (typeof stream === 'function') {
        ret = stream({
          signal
        })
        if (!isIterable(ret)) {
          throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret)
        }
      } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
        ret = stream
      } else {
        ret = Duplex.from(stream)
      }
    } else if (typeof stream === 'function') {
      if (isTransformStream(ret)) {
        var _ret
        ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable)
      } else {
        ret = makeAsyncIterable(ret)
      }
      ret = stream(ret, {
        signal
      })
      if (reading) {
        if (!isIterable(ret, true)) {
          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable', `transform[${i - 1}]`, ret)
        }
      } else {
        var _ret2
        if (!PassThrough) {
          PassThrough = require('./passthrough')
        }

        // If the last argument to pipeline is not a stream
        // we must create a proxy stream so that pipeline(...)
        // always returns a stream which can be further
        // composed through `.pipe(stream)`.

        const pt = new PassThrough({
          objectMode: true
        })

        // Handle Promises/A+ spec, `then` could be a getter that throws on
        // second use.
        const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then
        if (typeof then === 'function') {
          finishCount++
          then.call(
            ret,
            (val) => {
              value = val
              if (val != null) {
                pt.write(val)
              }
              if (end) {
                pt.end()
              }
              process.nextTick(finish)
            },
            (err) => {
              pt.destroy(err)
              process.nextTick(finish, err)
            }
          )
        } else if (isIterable(ret, true)) {
          finishCount++
          pumpToNode(ret, pt, finish, {
            end
          })
        } else if (isReadableStream(ret) || isTransformStream(ret)) {
          const toRead = ret.readable || ret
          finishCount++
          pumpToNode(toRead, pt, finish, {
            end
          })
        } else {
          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret)
        }
        ret = pt
        const { destroy, cleanup } = destroyer(ret, false, true)
        destroys.push(destroy)
        if (isLastStream) {
          lastStreamCleanup.push(cleanup)
        }
      }
    } else if (isNodeStream(stream)) {
      if (isReadableNodeStream(ret)) {
        finishCount += 2
        const cleanup = pipe(ret, stream, finish, {
          end
        })
        if (isReadable(stream) && isLastStream) {
          lastStreamCleanup.push(cleanup)
        }
      } else if (isTransformStream(ret) || isReadableStream(ret)) {
        const toRead = ret.readable || ret
        finishCount++
        pumpToNode(toRead, stream, finish, {
          end
        })
      } else if (isIterable(ret)) {
        finishCount++
        pumpToNode(ret, stream, finish, {
          end
        })
      } else {
        throw new ERR_INVALID_ARG_TYPE(
          'val',
          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],
          ret
        )
      }
      ret = stream
    } else if (isWebStream(stream)) {
      if (isReadableNodeStream(ret)) {
        finishCount++
        pumpToWeb(makeAsyncIterable(ret), stream, finish, {
          end
        })
      } else if (isReadableStream(ret) || isIterable(ret)) {
        finishCount++
        pumpToWeb(ret, stream, finish, {
          end
        })
      } else if (isTransformStream(ret)) {
        finishCount++
        pumpToWeb(ret.readable, stream, finish, {
          end
        })
      } else {
        throw new ERR_INVALID_ARG_TYPE(
          'val',
          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],
          ret
        )
      }
      ret = stream
    } else {
      ret = Duplex.from(stream)
    }
  }
  if (
    (signal !== null && signal !== undefined && signal.aborted) ||
    (outerSignal !== null && outerSignal !== undefined && outerSignal.aborted)
  ) {
    process.nextTick(abort)
  }
  return ret
}
function pipe(src, dst, finish, { end }) {
  let ended = false
  dst.on('close', () => {
    if (!ended) {
      // Finish if the destination closes before the source has completed.
      finish(new ERR_STREAM_PREMATURE_CLOSE())
    }
  })
  src.pipe(dst, {
    end: false
  }) // If end is true we already will have a listener to end dst.

  if (end) {
    // Compat. Before node v10.12.0 stdio used to throw an error so
    // pipe() did/does not end() stdio destinations.
    // Now they allow it but "secretly" don't close the underlying fd.

    function endFn() {
      ended = true
      dst.end()
    }
    if (isReadableEnded(src)) {
      // End the destination if the source has already ended.
      process.nextTick(endFn)
    } else {
      src.once('end', endFn)
    }
  } else {
    finish()
  }
  eos(
    src,
    {
      readable: true,
      writable: false
    },
    (err) => {
      const rState = src._readableState
      if (
        err &&
        err.code === 'ERR_STREAM_PREMATURE_CLOSE' &&
        rState &&
        rState.ended &&
        !rState.errored &&
        !rState.errorEmitted
      ) {
        // Some readable streams will emit 'close' before 'end'. However, since
        // this is on the readable side 'end' should still be emitted if the
        // stream has been ended and no error emitted. This should be allowed in
        // favor of backwards compatibility. Since the stream is piped to a
        // destination this should not result in any observable difference.
        // We don't need to check if this is a writable premature close since
        // eos will only fail with premature close on the reading side for
        // duplex streams.
        src.once('end', finish).once('error', finish)
      } else {
        finish(err)
      }
    }
  )
  return eos(
    dst,
    {
      readable: false,
      writable: true
    },
    finish
  )
}
module.exports = {
  pipelineImpl,
  pipeline
}

},{"../../ours/errors":126,"../../ours/primordials":127,"../../ours/util":128,"../validators":124,"./destroy":110,"./duplex":111,"./end-of-stream":113,"./passthrough":117,"./readable":119,"./utils":122,"abort-controller":24,"process/":102}],119:[function(require,module,exports){
/* replacement start */

const process = require('process/')

/* replacement end */
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

;('use strict')
const {
  ArrayPrototypeIndexOf,
  NumberIsInteger,
  NumberIsNaN,
  NumberParseInt,
  ObjectDefineProperties,
  ObjectKeys,
  ObjectSetPrototypeOf,
  Promise,
  SafeSet,
  SymbolAsyncIterator,
  Symbol
} = require('../../ours/primordials')
module.exports = Readable
Readable.ReadableState = ReadableState
const { EventEmitter: EE } = require('events')
const { Stream, prependListener } = require('./legacy')
const { Buffer } = require('buffer')
const { addAbortSignal } = require('./add-abort-signal')
const eos = require('./end-of-stream')
let debug = require('../../ours/util').debuglog('stream', (fn) => {
  debug = fn
})
const BufferList = require('./buffer_list')
const destroyImpl = require('./destroy')
const { getHighWaterMark, getDefaultHighWaterMark } = require('./state')
const {
  aggregateTwoErrors,
  codes: {
    ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED,
    ERR_OUT_OF_RANGE,
    ERR_STREAM_PUSH_AFTER_EOF,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT
  }
} = require('../../ours/errors')
const { validateObject } = require('../validators')
const kPaused = Symbol('kPaused')
const { StringDecoder } = require('string_decoder')
const from = require('./from')
ObjectSetPrototypeOf(Readable.prototype, Stream.prototype)
ObjectSetPrototypeOf(Readable, Stream)
const nop = () => {}
const { errorOrDestroy } = destroyImpl
function ReadableState(options, stream, isDuplex) {
  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof require('./duplex')

  // Object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away.
  this.objectMode = !!(options && options.objectMode)
  if (isDuplex) this.objectMode = this.objectMode || !!(options && options.readableObjectMode)

  // The point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = options
    ? getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex)
    : getDefaultHighWaterMark(false)

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift().
  this.buffer = new BufferList()
  this.length = 0
  this.pipes = []
  this.flowing = null
  this.ended = false
  this.endEmitted = false
  this.reading = false

  // Stream is still being constructed and cannot be
  // destroyed until construction finished or failed.
  // Async construction is opt in, therefore we start as
  // constructed.
  this.constructed = true

  // A flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true

  // Whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false
  this.emittedReadable = false
  this.readableListening = false
  this.resumeScheduled = false
  this[kPaused] = null

  // True if the error was already emitted and should not be thrown again.
  this.errorEmitted = false

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = !options || options.emitClose !== false

  // Should .destroy() be called after 'end' (and potentially 'finish').
  this.autoDestroy = !options || options.autoDestroy !== false

  // Has it been destroyed.
  this.destroyed = false

  // Indicates whether the stream has errored. When true no further
  // _read calls, 'data' or 'readable' events should occur. This is needed
  // since when autoDestroy is disabled we need a way to tell whether the
  // stream has failed.
  this.errored = null

  // Indicates whether the stream has finished destroying.
  this.closed = false

  // True if close has been emitted or would have been emitted
  // depending on emitClose.
  this.closeEmitted = false

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8'

  // Ref the piped dest which we need a drain event on it
  // type: null | Writable | Set<Writable>.
  this.awaitDrainWriters = null
  this.multiAwaitDrain = false

  // If true, a maybeReadMore has been scheduled.
  this.readingMore = false
  this.dataEmitted = false
  this.decoder = null
  this.encoding = null
  if (options && options.encoding) {
    this.decoder = new StringDecoder(options.encoding)
    this.encoding = options.encoding
  }
}
function Readable(options) {
  if (!(this instanceof Readable)) return new Readable(options)

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5.
  const isDuplex = this instanceof require('./duplex')
  this._readableState = new ReadableState(options, this, isDuplex)
  if (options) {
    if (typeof options.read === 'function') this._read = options.read
    if (typeof options.destroy === 'function') this._destroy = options.destroy
    if (typeof options.construct === 'function') this._construct = options.construct
    if (options.signal && !isDuplex) addAbortSignal(options.signal, this)
  }
  Stream.call(this, options)
  destroyImpl.construct(this, () => {
    if (this._readableState.needReadable) {
      maybeReadMore(this, this._readableState)
    }
  })
}
Readable.prototype.destroy = destroyImpl.destroy
Readable.prototype._undestroy = destroyImpl.undestroy
Readable.prototype._destroy = function (err, cb) {
  cb(err)
}
Readable.prototype[EE.captureRejectionSymbol] = function (err) {
  this.destroy(err)
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  return readableAddChunk(this, chunk, encoding, false)
}

// Unshift should *always* be something directly out of read().
Readable.prototype.unshift = function (chunk, encoding) {
  return readableAddChunk(this, chunk, encoding, true)
}
function readableAddChunk(stream, chunk, encoding, addToFront) {
  debug('readableAddChunk', chunk)
  const state = stream._readableState
  let err
  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding
      if (state.encoding !== encoding) {
        if (addToFront && state.encoding) {
          // When unshifting, if state.encoding is set, we have to save
          // the string in the BufferList with the state encoding.
          chunk = Buffer.from(chunk, encoding).toString(state.encoding)
        } else {
          chunk = Buffer.from(chunk, encoding)
          encoding = ''
        }
      }
    } else if (chunk instanceof Buffer) {
      encoding = ''
    } else if (Stream._isUint8Array(chunk)) {
      chunk = Stream._uint8ArrayToBuffer(chunk)
      encoding = ''
    } else if (chunk != null) {
      err = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk)
    }
  }
  if (err) {
    errorOrDestroy(stream, err)
  } else if (chunk === null) {
    state.reading = false
    onEofChunk(stream, state)
  } else if (state.objectMode || (chunk && chunk.length > 0)) {
    if (addToFront) {
      if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT())
      else if (state.destroyed || state.errored) return false
      else addChunk(stream, state, chunk, true)
    } else if (state.ended) {
      errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF())
    } else if (state.destroyed || state.errored) {
      return false
    } else {
      state.reading = false
      if (state.decoder && !encoding) {
        chunk = state.decoder.write(chunk)
        if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false)
        else maybeReadMore(stream, state)
      } else {
        addChunk(stream, state, chunk, false)
      }
    }
  } else if (!addToFront) {
    state.reading = false
    maybeReadMore(stream, state)
  }

  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended && (state.length < state.highWaterMark || state.length === 0)
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount('data') > 0) {
    // Use the guard to avoid creating `Set()` repeatedly
    // when we have multiple pipes.
    if (state.multiAwaitDrain) {
      state.awaitDrainWriters.clear()
    } else {
      state.awaitDrainWriters = null
    }
    state.dataEmitted = true
    stream.emit('data', chunk)
  } else {
    // Update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length
    if (addToFront) state.buffer.unshift(chunk)
    else state.buffer.push(chunk)
    if (state.needReadable) emitReadable(stream)
  }
  maybeReadMore(stream, state)
}
Readable.prototype.isPaused = function () {
  const state = this._readableState
  return state[kPaused] === true || state.flowing === false
}

// Backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  const decoder = new StringDecoder(enc)
  this._readableState.decoder = decoder
  // If setEncoding(null), decoder.encoding equals utf8.
  this._readableState.encoding = this._readableState.decoder.encoding
  const buffer = this._readableState.buffer
  // Iterate over current buffer to convert already stored Buffers:
  let content = ''
  for (const data of buffer) {
    content += decoder.write(data)
  }
  buffer.clear()
  if (content !== '') buffer.push(content)
  this._readableState.length = content.length
  return this
}

// Don't raise the hwm > 1GB.
const MAX_HWM = 0x40000000
function computeNewHighWaterMark(n) {
  if (n > MAX_HWM) {
    throw new ERR_OUT_OF_RANGE('size', '<= 1GiB', n)
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts.
    n--
    n |= n >>> 1
    n |= n >>> 2
    n |= n >>> 4
    n |= n >>> 8
    n |= n >>> 16
    n++
  }
  return n
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || (state.length === 0 && state.ended)) return 0
  if (state.objectMode) return 1
  if (NumberIsNaN(n)) {
    // Only flow one buffer at a time.
    if (state.flowing && state.length) return state.buffer.first().length
    return state.length
  }
  if (n <= state.length) return n
  return state.ended ? state.length : 0
}

// You can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n)
  // Same as parseInt(undefined, 10), however V8 7.3 performance regressed
  // in this scenario, so we are doing it manually.
  if (n === undefined) {
    n = NaN
  } else if (!NumberIsInteger(n)) {
    n = NumberParseInt(n, 10)
  }
  const state = this._readableState
  const nOrig = n

  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n)
  if (n !== 0) state.emittedReadable = false

  // If we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (
    n === 0 &&
    state.needReadable &&
    ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)
  ) {
    debug('read: emitReadable', state.length, state.ended)
    if (state.length === 0 && state.ended) endReadable(this)
    else emitReadable(this)
    return null
  }
  n = howMuchToRead(n, state)

  // If we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this)
    return null
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  let doRead = state.needReadable
  debug('need readable', doRead)

  // If we currently have less than the highWaterMark, then also read some.
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true
    debug('length less than watermark', doRead)
  }

  // However, if we've ended, then there's no point, if we're already
  // reading, then it's unnecessary, if we're constructing we have to wait,
  // and if we're destroyed or errored, then it's not allowed,
  if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
    doRead = false
    debug('reading, ended or constructing', doRead)
  } else if (doRead) {
    debug('do read')
    state.reading = true
    state.sync = true
    // If the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true

    // Call internal read method
    try {
      this._read(state.highWaterMark)
    } catch (err) {
      errorOrDestroy(this, err)
    }
    state.sync = false
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state)
  }
  let ret
  if (n > 0) ret = fromList(n, state)
  else ret = null
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark
    n = 0
  } else {
    state.length -= n
    if (state.multiAwaitDrain) {
      state.awaitDrainWriters.clear()
    } else {
      state.awaitDrainWriters = null
    }
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this)
  }
  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
    state.dataEmitted = true
    this.emit('data', ret)
  }
  return ret
}
function onEofChunk(stream, state) {
  debug('onEofChunk')
  if (state.ended) return
  if (state.decoder) {
    const chunk = state.decoder.end()
    if (chunk && chunk.length) {
      state.buffer.push(chunk)
      state.length += state.objectMode ? 1 : chunk.length
    }
  }
  state.ended = true
  if (state.sync) {
    // If we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call.
    emitReadable(stream)
  } else {
    // Emit 'readable' now to make sure it gets picked up.
    state.needReadable = false
    state.emittedReadable = true
    // We have to emit readable now that we are EOF. Modules
    // in the ecosystem (e.g. dicer) rely on this event being sync.
    emitReadable_(stream)
  }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  const state = stream._readableState
  debug('emitReadable', state.needReadable, state.emittedReadable)
  state.needReadable = false
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing)
    state.emittedReadable = true
    process.nextTick(emitReadable_, stream)
  }
}
function emitReadable_(stream) {
  const state = stream._readableState
  debug('emitReadable_', state.destroyed, state.length, state.ended)
  if (!state.destroyed && !state.errored && (state.length || state.ended)) {
    stream.emit('readable')
    state.emittedReadable = false
  }

  // The stream needs another readable event if:
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark
  flow(stream)
}

// At this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore && state.constructed) {
    state.readingMore = true
    process.nextTick(maybeReadMore_, stream, state)
  }
}
function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (
    !state.reading &&
    !state.ended &&
    (state.length < state.highWaterMark || (state.flowing && state.length === 0))
  ) {
    const len = state.length
    debug('maybeReadMore read 0')
    stream.read(0)
    if (len === state.length)
      // Didn't get any data, stop spinning.
      break
  }
  state.readingMore = false
}

// Abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()')
}
Readable.prototype.pipe = function (dest, pipeOpts) {
  const src = this
  const state = this._readableState
  if (state.pipes.length === 1) {
    if (!state.multiAwaitDrain) {
      state.multiAwaitDrain = true
      state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : [])
    }
  }
  state.pipes.push(dest)
  debug('pipe count=%d opts=%j', state.pipes.length, pipeOpts)
  const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr
  const endFn = doEnd ? onend : unpipe
  if (state.endEmitted) process.nextTick(endFn)
  else src.once('end', endFn)
  dest.on('unpipe', onunpipe)
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe')
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true
        cleanup()
      }
    }
  }
  function onend() {
    debug('onend')
    dest.end()
  }
  let ondrain
  let cleanedUp = false
  function cleanup() {
    debug('cleanup')
    // Cleanup event handlers once the pipe is broken.
    dest.removeListener('close', onclose)
    dest.removeListener('finish', onfinish)
    if (ondrain) {
      dest.removeListener('drain', ondrain)
    }
    dest.removeListener('error', onerror)
    dest.removeListener('unpipe', onunpipe)
    src.removeListener('end', onend)
    src.removeListener('end', unpipe)
    src.removeListener('data', ondata)
    cleanedUp = true

    // If the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain()
  }
  function pause() {
    // If the user unpiped during `dest.write()`, it is possible
    // to get stuck in a permanently paused state if that write
    // also returned false.
    // => Check whether `dest` is still a piping destination.
    if (!cleanedUp) {
      if (state.pipes.length === 1 && state.pipes[0] === dest) {
        debug('false write response, pause', 0)
        state.awaitDrainWriters = dest
        state.multiAwaitDrain = false
      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
        debug('false write response, pause', state.awaitDrainWriters.size)
        state.awaitDrainWriters.add(dest)
      }
      src.pause()
    }
    if (!ondrain) {
      // When the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.
      ondrain = pipeOnDrain(src, dest)
      dest.on('drain', ondrain)
    }
  }
  src.on('data', ondata)
  function ondata(chunk) {
    debug('ondata')
    const ret = dest.write(chunk)
    debug('dest.write', ret)
    if (ret === false) {
      pause()
    }
  }

  // If the dest has an error, then stop piping into it.
  // However, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er)
    unpipe()
    dest.removeListener('error', onerror)
    if (dest.listenerCount('error') === 0) {
      const s = dest._writableState || dest._readableState
      if (s && !s.errorEmitted) {
        // User incorrectly emitted 'error' directly on the stream.
        errorOrDestroy(dest, er)
      } else {
        dest.emit('error', er)
      }
    }
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror)

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish)
    unpipe()
  }
  dest.once('close', onclose)
  function onfinish() {
    debug('onfinish')
    dest.removeListener('close', onclose)
    unpipe()
  }
  dest.once('finish', onfinish)
  function unpipe() {
    debug('unpipe')
    src.unpipe(dest)
  }

  // Tell the dest that it's being piped to.
  dest.emit('pipe', src)

  // Start the flow if it hasn't been started already.

  if (dest.writableNeedDrain === true) {
    if (state.flowing) {
      pause()
    }
  } else if (!state.flowing) {
    debug('pipe resume')
    src.resume()
  }
  return dest
}
function pipeOnDrain(src, dest) {
  return function pipeOnDrainFunctionResult() {
    const state = src._readableState

    // `ondrain` will call directly,
    // `this` maybe not a reference to dest,
    // so we use the real dest here.
    if (state.awaitDrainWriters === dest) {
      debug('pipeOnDrain', 1)
      state.awaitDrainWriters = null
    } else if (state.multiAwaitDrain) {
      debug('pipeOnDrain', state.awaitDrainWriters.size)
      state.awaitDrainWriters.delete(dest)
    }
    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount('data')) {
      src.resume()
    }
  }
}
Readable.prototype.unpipe = function (dest) {
  const state = this._readableState
  const unpipeInfo = {
    hasUnpiped: false
  }

  // If we're not piping anywhere, then do nothing.
  if (state.pipes.length === 0) return this
  if (!dest) {
    // remove all.
    const dests = state.pipes
    state.pipes = []
    this.pause()
    for (let i = 0; i < dests.length; i++)
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      })
    return this
  }

  // Try to find the right one.
  const index = ArrayPrototypeIndexOf(state.pipes, dest)
  if (index === -1) return this
  state.pipes.splice(index, 1)
  if (state.pipes.length === 0) this.pause()
  dest.emit('unpipe', this, unpipeInfo)
  return this
}

// Set up data events if they are asked for
// Ensure readable listeners eventually get something.
Readable.prototype.on = function (ev, fn) {
  const res = Stream.prototype.on.call(this, ev, fn)
  const state = this._readableState
  if (ev === 'data') {
    // Update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0

    // Try start flowing on next tick if stream isn't explicitly paused.
    if (state.flowing !== false) this.resume()
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true
      state.flowing = false
      state.emittedReadable = false
      debug('on readable', state.length, state.reading)
      if (state.length) {
        emitReadable(this)
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this)
      }
    }
  }
  return res
}
Readable.prototype.addListener = Readable.prototype.on
Readable.prototype.removeListener = function (ev, fn) {
  const res = Stream.prototype.removeListener.call(this, ev, fn)
  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this)
  }
  return res
}
Readable.prototype.off = Readable.prototype.removeListener
Readable.prototype.removeAllListeners = function (ev) {
  const res = Stream.prototype.removeAllListeners.apply(this, arguments)
  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this)
  }
  return res
}
function updateReadableListening(self) {
  const state = self._readableState
  state.readableListening = self.listenerCount('readable') > 0
  if (state.resumeScheduled && state[kPaused] === false) {
    // Flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true

    // Crude way to check if we should resume.
  } else if (self.listenerCount('data') > 0) {
    self.resume()
  } else if (!state.readableListening) {
    state.flowing = null
  }
}
function nReadingNextTick(self) {
  debug('readable nexttick read 0')
  self.read(0)
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  const state = this._readableState
  if (!state.flowing) {
    debug('resume')
    // We flow only if there is no one listening
    // for readable, but we still have to call
    // resume().
    state.flowing = !state.readableListening
    resume(this, state)
  }
  state[kPaused] = false
  return this
}
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true
    process.nextTick(resume_, stream, state)
  }
}
function resume_(stream, state) {
  debug('resume', state.reading)
  if (!state.reading) {
    stream.read(0)
  }
  state.resumeScheduled = false
  stream.emit('resume')
  flow(stream)
  if (state.flowing && !state.reading) stream.read(0)
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing)
  if (this._readableState.flowing !== false) {
    debug('pause')
    this._readableState.flowing = false
    this.emit('pause')
  }
  this._readableState[kPaused] = true
  return this
}
function flow(stream) {
  const state = stream._readableState
  debug('flow', state.flowing)
  while (state.flowing && stream.read() !== null);
}

// Wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  let paused = false

  // TODO (ronag): Should this.destroy(err) emit
  // 'error' on the wrapped stream? Would require
  // a static factory method, e.g. Readable.wrap(stream).

  stream.on('data', (chunk) => {
    if (!this.push(chunk) && stream.pause) {
      paused = true
      stream.pause()
    }
  })
  stream.on('end', () => {
    this.push(null)
  })
  stream.on('error', (err) => {
    errorOrDestroy(this, err)
  })
  stream.on('close', () => {
    this.destroy()
  })
  stream.on('destroy', () => {
    this.destroy()
  })
  this._read = () => {
    if (paused && stream.resume) {
      paused = false
      stream.resume()
    }
  }

  // Proxy all the other methods. Important when wrapping filters and duplexes.
  const streamKeys = ObjectKeys(stream)
  for (let j = 1; j < streamKeys.length; j++) {
    const i = streamKeys[j]
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = stream[i].bind(stream)
    }
  }
  return this
}
Readable.prototype[SymbolAsyncIterator] = function () {
  return streamToAsyncIterator(this)
}
Readable.prototype.iterator = function (options) {
  if (options !== undefined) {
    validateObject(options, 'options')
  }
  return streamToAsyncIterator(this, options)
}
function streamToAsyncIterator(stream, options) {
  if (typeof stream.read !== 'function') {
    stream = Readable.wrap(stream, {
      objectMode: true
    })
  }
  const iter = createAsyncIterator(stream, options)
  iter.stream = stream
  return iter
}
async function* createAsyncIterator(stream, options) {
  let callback = nop
  function next(resolve) {
    if (this === stream) {
      callback()
      callback = nop
    } else {
      callback = resolve
    }
  }
  stream.on('readable', next)
  let error
  const cleanup = eos(
    stream,
    {
      writable: false
    },
    (err) => {
      error = err ? aggregateTwoErrors(error, err) : null
      callback()
      callback = nop
    }
  )
  try {
    while (true) {
      const chunk = stream.destroyed ? null : stream.read()
      if (chunk !== null) {
        yield chunk
      } else if (error) {
        throw error
      } else if (error === null) {
        return
      } else {
        await new Promise(next)
      }
    }
  } catch (err) {
    error = aggregateTwoErrors(error, err)
    throw error
  } finally {
    if (
      (error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) &&
      (error === undefined || stream._readableState.autoDestroy)
    ) {
      destroyImpl.destroyer(stream, null)
    } else {
      stream.off('readable', next)
      cleanup()
    }
  }
}

// Making it explicit these properties are not enumerable
// because otherwise some prototype manipulation in
// userland will fail.
ObjectDefineProperties(Readable.prototype, {
  readable: {
    __proto__: null,
    get() {
      const r = this._readableState
      // r.readable === false means that this is part of a Duplex stream
      // where the readable side was disabled upon construction.
      // Compat. The user might manually disable readable side through
      // deprecated setter.
      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted
    },
    set(val) {
      // Backwards compat.
      if (this._readableState) {
        this._readableState.readable = !!val
      }
    }
  },
  readableDidRead: {
    __proto__: null,
    enumerable: false,
    get: function () {
      return this._readableState.dataEmitted
    }
  },
  readableAborted: {
    __proto__: null,
    enumerable: false,
    get: function () {
      return !!(
        this._readableState.readable !== false &&
        (this._readableState.destroyed || this._readableState.errored) &&
        !this._readableState.endEmitted
      )
    }
  },
  readableHighWaterMark: {
    __proto__: null,
    enumerable: false,
    get: function () {
      return this._readableState.highWaterMark
    }
  },
  readableBuffer: {
    __proto__: null,
    enumerable: false,
    get: function () {
      return this._readableState && this._readableState.buffer
    }
  },
  readableFlowing: {
    __proto__: null,
    enumerable: false,
    get: function () {
      return this._readableState.flowing
    },
    set: function (state) {
      if (this._readableState) {
        this._readableState.flowing = state
      }
    }
  },
  readableLength: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._readableState.length
    }
  },
  readableObjectMode: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.objectMode : false
    }
  },
  readableEncoding: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.encoding : null
    }
  },
  errored: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.errored : null
    }
  },
  closed: {
    __proto__: null,
    get() {
      return this._readableState ? this._readableState.closed : false
    }
  },
  destroyed: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.destroyed : false
    },
    set(value) {
      // We ignore the value if the stream
      // has not been initialized yet.
      if (!this._readableState) {
        return
      }

      // Backward compatibility, the user is explicitly
      // managing destroyed.
      this._readableState.destroyed = value
    }
  },
  readableEnded: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.endEmitted : false
    }
  }
})
ObjectDefineProperties(ReadableState.prototype, {
  // Legacy getter for `pipesCount`.
  pipesCount: {
    __proto__: null,
    get() {
      return this.pipes.length
    }
  },
  // Legacy property for `paused`.
  paused: {
    __proto__: null,
    get() {
      return this[kPaused] !== false
    },
    set(value) {
      this[kPaused] = !!value
    }
  }
})

// Exposed for testing purposes only.
Readable._fromList = fromList

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered.
  if (state.length === 0) return null
  let ret
  if (state.objectMode) ret = state.buffer.shift()
  else if (!n || n >= state.length) {
    // Read it all, truncate the list.
    if (state.decoder) ret = state.buffer.join('')
    else if (state.buffer.length === 1) ret = state.buffer.first()
    else ret = state.buffer.concat(state.length)
    state.buffer.clear()
  } else {
    // read part of list.
    ret = state.buffer.consume(n, state.decoder)
  }
  return ret
}
function endReadable(stream) {
  const state = stream._readableState
  debug('endReadable', state.endEmitted)
  if (!state.endEmitted) {
    state.ended = true
    process.nextTick(endReadableNT, state, stream)
  }
}
function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length)

  // Check that we didn't get one last unshift.
  if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
    state.endEmitted = true
    stream.emit('end')
    if (stream.writable && stream.allowHalfOpen === false) {
      process.nextTick(endWritableNT, stream)
    } else if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well.
      const wState = stream._writableState
      const autoDestroy =
        !wState ||
        (wState.autoDestroy &&
          // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false))
      if (autoDestroy) {
        stream.destroy()
      }
    }
  }
}
function endWritableNT(stream) {
  const writable = stream.writable && !stream.writableEnded && !stream.destroyed
  if (writable) {
    stream.end()
  }
}
Readable.from = function (iterable, opts) {
  return from(Readable, iterable, opts)
}
let webStreamsAdapters

// Lazy to avoid circular references
function lazyWebStreams() {
  if (webStreamsAdapters === undefined) webStreamsAdapters = {}
  return webStreamsAdapters
}
Readable.fromWeb = function (readableStream, options) {
  return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options)
}
Readable.toWeb = function (streamReadable, options) {
  return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options)
}
Readable.wrap = function (src, options) {
  var _ref, _src$readableObjectMo
  return new Readable({
    objectMode:
      (_ref =
        (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined
          ? _src$readableObjectMo
          : src.objectMode) !== null && _ref !== undefined
        ? _ref
        : true,
    ...options,
    destroy(err, callback) {
      destroyImpl.destroyer(src, err)
      callback(err)
    }
  }).wrap(src)
}

},{"../../ours/errors":126,"../../ours/primordials":127,"../../ours/util":128,"../validators":124,"./add-abort-signal":107,"./buffer_list":108,"./destroy":110,"./duplex":111,"./end-of-stream":113,"./from":114,"./legacy":115,"./state":120,"buffer":29,"events":49,"process/":102,"string_decoder":28}],120:[function(require,module,exports){
'use strict'

const { MathFloor, NumberIsInteger } = require('../../ours/primordials')
const { ERR_INVALID_ARG_VALUE } = require('../../ours/errors').codes
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null
}
function getDefaultHighWaterMark(objectMode) {
  return objectMode ? 16 : 16 * 1024
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  const hwm = highWaterMarkFrom(options, isDuplex, duplexKey)
  if (hwm != null) {
    if (!NumberIsInteger(hwm) || hwm < 0) {
      const name = isDuplex ? `options.${duplexKey}` : 'options.highWaterMark'
      throw new ERR_INVALID_ARG_VALUE(name, hwm)
    }
    return MathFloor(hwm)
  }

  // Default value
  return getDefaultHighWaterMark(state.objectMode)
}
module.exports = {
  getHighWaterMark,
  getDefaultHighWaterMark
}

},{"../../ours/errors":126,"../../ours/primordials":127}],121:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict'

const { ObjectSetPrototypeOf, Symbol } = require('../../ours/primordials')
module.exports = Transform
const { ERR_METHOD_NOT_IMPLEMENTED } = require('../../ours/errors').codes
const Duplex = require('./duplex')
const { getHighWaterMark } = require('./state')
ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype)
ObjectSetPrototypeOf(Transform, Duplex)
const kCallback = Symbol('kCallback')
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options)

  // TODO (ronag): This should preferably always be
  // applied but would be semver-major. Or even better;
  // make Transform a Readable with the Writable interface.
  const readableHighWaterMark = options ? getHighWaterMark(this, options, 'readableHighWaterMark', true) : null
  if (readableHighWaterMark === 0) {
    // A Duplex will buffer both on the writable and readable side while
    // a Transform just wants to buffer hwm number of elements. To avoid
    // buffering twice we disable buffering on the writable side.
    options = {
      ...options,
      highWaterMark: null,
      readableHighWaterMark,
      // TODO (ronag): 0 is not optimal since we have
      // a "bug" where we check needDrain before calling _write and not after.
      // Refs: https://github.com/nodejs/node/pull/32887
      // Refs: https://github.com/nodejs/node/pull/35941
      writableHighWaterMark: options.writableHighWaterMark || 0
    }
  }
  Duplex.call(this, options)

  // We have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false
  this[kCallback] = null
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform
    if (typeof options.flush === 'function') this._flush = options.flush
  }

  // When the writable side finishes, then flush out anything remaining.
  // Backwards compat. Some Transform streams incorrectly implement _final
  // instead of or in addition to _flush. By using 'prefinish' instead of
  // implementing _final we continue supporting this unfortunate use case.
  this.on('prefinish', prefinish)
}
function final(cb) {
  if (typeof this._flush === 'function' && !this.destroyed) {
    this._flush((er, data) => {
      if (er) {
        if (cb) {
          cb(er)
        } else {
          this.destroy(er)
        }
        return
      }
      if (data != null) {
        this.push(data)
      }
      this.push(null)
      if (cb) {
        cb()
      }
    })
  } else {
    this.push(null)
    if (cb) {
      cb()
    }
  }
}
function prefinish() {
  if (this._final !== final) {
    final.call(this)
  }
}
Transform.prototype._final = final
Transform.prototype._transform = function (chunk, encoding, callback) {
  throw new ERR_METHOD_NOT_IMPLEMENTED('_transform()')
}
Transform.prototype._write = function (chunk, encoding, callback) {
  const rState = this._readableState
  const wState = this._writableState
  const length = rState.length
  this._transform(chunk, encoding, (err, val) => {
    if (err) {
      callback(err)
      return
    }
    if (val != null) {
      this.push(val)
    }
    if (
      wState.ended ||
      // Backwards compat.
      length === rState.length ||
      // Backwards compat.
      rState.length < rState.highWaterMark
    ) {
      callback()
    } else {
      this[kCallback] = callback
    }
  })
}
Transform.prototype._read = function () {
  if (this[kCallback]) {
    const callback = this[kCallback]
    this[kCallback] = null
    callback()
  }
}

},{"../../ours/errors":126,"../../ours/primordials":127,"./duplex":111,"./state":120}],122:[function(require,module,exports){
'use strict'

const { Symbol, SymbolAsyncIterator, SymbolIterator, SymbolFor } = require('../../ours/primordials')
const kDestroyed = Symbol('kDestroyed')
const kIsErrored = Symbol('kIsErrored')
const kIsReadable = Symbol('kIsReadable')
const kIsDisturbed = Symbol('kIsDisturbed')
const kIsClosedPromise = SymbolFor('nodejs.webstream.isClosedPromise')
const kControllerErrorFunction = SymbolFor('nodejs.webstream.controllerErrorFunction')
function isReadableNodeStream(obj, strict = false) {
  var _obj$_readableState
  return !!(
    (
      obj &&
      typeof obj.pipe === 'function' &&
      typeof obj.on === 'function' &&
      (!strict || (typeof obj.pause === 'function' && typeof obj.resume === 'function')) &&
      (!obj._writableState ||
        ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined
          ? undefined
          : _obj$_readableState.readable) !== false) &&
      // Duplex
      (!obj._writableState || obj._readableState)
    ) // Writable has .pipe.
  )
}

function isWritableNodeStream(obj) {
  var _obj$_writableState
  return !!(
    (
      obj &&
      typeof obj.write === 'function' &&
      typeof obj.on === 'function' &&
      (!obj._readableState ||
        ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined
          ? undefined
          : _obj$_writableState.writable) !== false)
    ) // Duplex
  )
}

function isDuplexNodeStream(obj) {
  return !!(
    obj &&
    typeof obj.pipe === 'function' &&
    obj._readableState &&
    typeof obj.on === 'function' &&
    typeof obj.write === 'function'
  )
}
function isNodeStream(obj) {
  return (
    obj &&
    (obj._readableState ||
      obj._writableState ||
      (typeof obj.write === 'function' && typeof obj.on === 'function') ||
      (typeof obj.pipe === 'function' && typeof obj.on === 'function'))
  )
}
function isReadableStream(obj) {
  return !!(
    obj &&
    !isNodeStream(obj) &&
    typeof obj.pipeThrough === 'function' &&
    typeof obj.getReader === 'function' &&
    typeof obj.cancel === 'function'
  )
}
function isWritableStream(obj) {
  return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === 'function' && typeof obj.abort === 'function')
}
function isTransformStream(obj) {
  return !!(obj && !isNodeStream(obj) && typeof obj.readable === 'object' && typeof obj.writable === 'object')
}
function isWebStream(obj) {
  return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj)
}
function isIterable(obj, isAsync) {
  if (obj == null) return false
  if (isAsync === true) return typeof obj[SymbolAsyncIterator] === 'function'
  if (isAsync === false) return typeof obj[SymbolIterator] === 'function'
  return typeof obj[SymbolAsyncIterator] === 'function' || typeof obj[SymbolIterator] === 'function'
}
function isDestroyed(stream) {
  if (!isNodeStream(stream)) return null
  const wState = stream._writableState
  const rState = stream._readableState
  const state = wState || rState
  return !!(stream.destroyed || stream[kDestroyed] || (state !== null && state !== undefined && state.destroyed))
}

// Have been end():d.
function isWritableEnded(stream) {
  if (!isWritableNodeStream(stream)) return null
  if (stream.writableEnded === true) return true
  const wState = stream._writableState
  if (wState !== null && wState !== undefined && wState.errored) return false
  if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== 'boolean') return null
  return wState.ended
}

// Have emitted 'finish'.
function isWritableFinished(stream, strict) {
  if (!isWritableNodeStream(stream)) return null
  if (stream.writableFinished === true) return true
  const wState = stream._writableState
  if (wState !== null && wState !== undefined && wState.errored) return false
  if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== 'boolean') return null
  return !!(wState.finished || (strict === false && wState.ended === true && wState.length === 0))
}

// Have been push(null):d.
function isReadableEnded(stream) {
  if (!isReadableNodeStream(stream)) return null
  if (stream.readableEnded === true) return true
  const rState = stream._readableState
  if (!rState || rState.errored) return false
  if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== 'boolean') return null
  return rState.ended
}

// Have emitted 'end'.
function isReadableFinished(stream, strict) {
  if (!isReadableNodeStream(stream)) return null
  const rState = stream._readableState
  if (rState !== null && rState !== undefined && rState.errored) return false
  if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== 'boolean') return null
  return !!(rState.endEmitted || (strict === false && rState.ended === true && rState.length === 0))
}
function isReadable(stream) {
  if (stream && stream[kIsReadable] != null) return stream[kIsReadable]
  if (typeof (stream === null || stream === undefined ? undefined : stream.readable) !== 'boolean') return null
  if (isDestroyed(stream)) return false
  return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream)
}
function isWritable(stream) {
  if (typeof (stream === null || stream === undefined ? undefined : stream.writable) !== 'boolean') return null
  if (isDestroyed(stream)) return false
  return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream)
}
function isFinished(stream, opts) {
  if (!isNodeStream(stream)) {
    return null
  }
  if (isDestroyed(stream)) {
    return true
  }
  if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && isReadable(stream)) {
    return false
  }
  if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && isWritable(stream)) {
    return false
  }
  return true
}
function isWritableErrored(stream) {
  var _stream$_writableStat, _stream$_writableStat2
  if (!isNodeStream(stream)) {
    return null
  }
  if (stream.writableErrored) {
    return stream.writableErrored
  }
  return (_stream$_writableStat =
    (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === undefined
      ? undefined
      : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined
    ? _stream$_writableStat
    : null
}
function isReadableErrored(stream) {
  var _stream$_readableStat, _stream$_readableStat2
  if (!isNodeStream(stream)) {
    return null
  }
  if (stream.readableErrored) {
    return stream.readableErrored
  }
  return (_stream$_readableStat =
    (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === undefined
      ? undefined
      : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined
    ? _stream$_readableStat
    : null
}
function isClosed(stream) {
  if (!isNodeStream(stream)) {
    return null
  }
  if (typeof stream.closed === 'boolean') {
    return stream.closed
  }
  const wState = stream._writableState
  const rState = stream._readableState
  if (
    typeof (wState === null || wState === undefined ? undefined : wState.closed) === 'boolean' ||
    typeof (rState === null || rState === undefined ? undefined : rState.closed) === 'boolean'
  ) {
    return (
      (wState === null || wState === undefined ? undefined : wState.closed) ||
      (rState === null || rState === undefined ? undefined : rState.closed)
    )
  }
  if (typeof stream._closed === 'boolean' && isOutgoingMessage(stream)) {
    return stream._closed
  }
  return null
}
function isOutgoingMessage(stream) {
  return (
    typeof stream._closed === 'boolean' &&
    typeof stream._defaultKeepAlive === 'boolean' &&
    typeof stream._removedConnection === 'boolean' &&
    typeof stream._removedContLen === 'boolean'
  )
}
function isServerResponse(stream) {
  return typeof stream._sent100 === 'boolean' && isOutgoingMessage(stream)
}
function isServerRequest(stream) {
  var _stream$req
  return (
    typeof stream._consuming === 'boolean' &&
    typeof stream._dumped === 'boolean' &&
    ((_stream$req = stream.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) ===
      undefined
  )
}
function willEmitClose(stream) {
  if (!isNodeStream(stream)) return null
  const wState = stream._writableState
  const rState = stream._readableState
  const state = wState || rState
  return (
    (!state && isServerResponse(stream)) || !!(state && state.autoDestroy && state.emitClose && state.closed === false)
  )
}
function isDisturbed(stream) {
  var _stream$kIsDisturbed
  return !!(
    stream &&
    ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined
      ? _stream$kIsDisturbed
      : stream.readableDidRead || stream.readableAborted)
  )
}
function isErrored(stream) {
  var _ref,
    _ref2,
    _ref3,
    _ref4,
    _ref5,
    _stream$kIsErrored,
    _stream$_readableStat3,
    _stream$_writableStat3,
    _stream$_readableStat4,
    _stream$_writableStat4
  return !!(
    stream &&
    ((_ref =
      (_ref2 =
        (_ref3 =
          (_ref4 =
            (_ref5 =
              (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== undefined
                ? _stream$kIsErrored
                : stream.readableErrored) !== null && _ref5 !== undefined
              ? _ref5
              : stream.writableErrored) !== null && _ref4 !== undefined
            ? _ref4
            : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === undefined
            ? undefined
            : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined
          ? _ref3
          : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === undefined
          ? undefined
          : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined
        ? _ref2
        : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === undefined
        ? undefined
        : _stream$_readableStat4.errored) !== null && _ref !== undefined
      ? _ref
      : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === undefined
      ? undefined
      : _stream$_writableStat4.errored)
  )
}
module.exports = {
  kDestroyed,
  isDisturbed,
  kIsDisturbed,
  isErrored,
  kIsErrored,
  isReadable,
  kIsReadable,
  kIsClosedPromise,
  kControllerErrorFunction,
  isClosed,
  isDestroyed,
  isDuplexNodeStream,
  isFinished,
  isIterable,
  isReadableNodeStream,
  isReadableStream,
  isReadableEnded,
  isReadableFinished,
  isReadableErrored,
  isNodeStream,
  isWebStream,
  isWritable,
  isWritableNodeStream,
  isWritableStream,
  isWritableEnded,
  isWritableFinished,
  isWritableErrored,
  isServerRequest,
  isServerResponse,
  willEmitClose,
  isTransformStream
}

},{"../../ours/primordials":127}],123:[function(require,module,exports){
/* replacement start */

const process = require('process/')

/* replacement end */
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

;('use strict')
const {
  ArrayPrototypeSlice,
  Error,
  FunctionPrototypeSymbolHasInstance,
  ObjectDefineProperty,
  ObjectDefineProperties,
  ObjectSetPrototypeOf,
  StringPrototypeToLowerCase,
  Symbol,
  SymbolHasInstance
} = require('../../ours/primordials')
module.exports = Writable
Writable.WritableState = WritableState
const { EventEmitter: EE } = require('events')
const Stream = require('./legacy').Stream
const { Buffer } = require('buffer')
const destroyImpl = require('./destroy')
const { addAbortSignal } = require('./add-abort-signal')
const { getHighWaterMark, getDefaultHighWaterMark } = require('./state')
const {
  ERR_INVALID_ARG_TYPE,
  ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK,
  ERR_STREAM_CANNOT_PIPE,
  ERR_STREAM_DESTROYED,
  ERR_STREAM_ALREADY_FINISHED,
  ERR_STREAM_NULL_VALUES,
  ERR_STREAM_WRITE_AFTER_END,
  ERR_UNKNOWN_ENCODING
} = require('../../ours/errors').codes
const { errorOrDestroy } = destroyImpl
ObjectSetPrototypeOf(Writable.prototype, Stream.prototype)
ObjectSetPrototypeOf(Writable, Stream)
function nop() {}
const kOnFinished = Symbol('kOnFinished')
function WritableState(options, stream, isDuplex) {
  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof require('./duplex')

  // Object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!(options && options.objectMode)
  if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode)

  // The point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write().
  this.highWaterMark = options
    ? getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex)
    : getDefaultHighWaterMark(false)

  // if _final has been called.
  this.finalCalled = false

  // drain event flag.
  this.needDrain = false
  // At the start of calling end()
  this.ending = false
  // When end() has been called, and returned.
  this.ended = false
  // When 'finish' is emitted.
  this.finished = false

  // Has it been destroyed
  this.destroyed = false

  // Should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  const noDecode = !!(options && options.decodeStrings === false)
  this.decodeStrings = !noDecode

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8'

  // Not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0

  // A flag to see when we're in the middle of a write.
  this.writing = false

  // When true all writes will be buffered until .uncork() call.
  this.corked = 0

  // A flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true

  // A flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false

  // The callback that's passed to _write(chunk, cb).
  this.onwrite = onwrite.bind(undefined, stream)

  // The callback that the user supplies to write(chunk, encoding, cb).
  this.writecb = null

  // The amount that is being written when _write is called.
  this.writelen = 0

  // Storage for data passed to the afterWrite() callback in case of
  // synchronous _write() completion.
  this.afterWriteTickInfo = null
  resetBuffer(this)

  // Number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted.
  this.pendingcb = 0

  // Stream is still being constructed and cannot be
  // destroyed until construction finished or failed.
  // Async construction is opt in, therefore we start as
  // constructed.
  this.constructed = true

  // Emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams.
  this.prefinished = false

  // True if the error was already emitted and should not be thrown again.
  this.errorEmitted = false

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = !options || options.emitClose !== false

  // Should .destroy() be called after 'finish' (and potentially 'end').
  this.autoDestroy = !options || options.autoDestroy !== false

  // Indicates whether the stream has errored. When true all write() calls
  // should return false. This is needed since when autoDestroy
  // is disabled we need a way to tell whether the stream has failed.
  this.errored = null

  // Indicates whether the stream has finished destroying.
  this.closed = false

  // True if close has been emitted or would have been emitted
  // depending on emitClose.
  this.closeEmitted = false
  this[kOnFinished] = []
}
function resetBuffer(state) {
  state.buffered = []
  state.bufferedIndex = 0
  state.allBuffers = true
  state.allNoop = true
}
WritableState.prototype.getBuffer = function getBuffer() {
  return ArrayPrototypeSlice(this.buffered, this.bufferedIndex)
}
ObjectDefineProperty(WritableState.prototype, 'bufferedRequestCount', {
  __proto__: null,
  get() {
    return this.buffered.length - this.bufferedIndex
  }
})
function Writable(options) {
  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5.
  const isDuplex = this instanceof require('./duplex')
  if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options)
  this._writableState = new WritableState(options, this, isDuplex)
  if (options) {
    if (typeof options.write === 'function') this._write = options.write
    if (typeof options.writev === 'function') this._writev = options.writev
    if (typeof options.destroy === 'function') this._destroy = options.destroy
    if (typeof options.final === 'function') this._final = options.final
    if (typeof options.construct === 'function') this._construct = options.construct
    if (options.signal) addAbortSignal(options.signal, this)
  }
  Stream.call(this, options)
  destroyImpl.construct(this, () => {
    const state = this._writableState
    if (!state.writing) {
      clearBuffer(this, state)
    }
    finishMaybe(this, state)
  })
}
ObjectDefineProperty(Writable, SymbolHasInstance, {
  __proto__: null,
  value: function (object) {
    if (FunctionPrototypeSymbolHasInstance(this, object)) return true
    if (this !== Writable) return false
    return object && object._writableState instanceof WritableState
  }
})

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE())
}
function _write(stream, chunk, encoding, cb) {
  const state = stream._writableState
  if (typeof encoding === 'function') {
    cb = encoding
    encoding = state.defaultEncoding
  } else {
    if (!encoding) encoding = state.defaultEncoding
    else if (encoding !== 'buffer' && !Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding)
    if (typeof cb !== 'function') cb = nop
  }
  if (chunk === null) {
    throw new ERR_STREAM_NULL_VALUES()
  } else if (!state.objectMode) {
    if (typeof chunk === 'string') {
      if (state.decodeStrings !== false) {
        chunk = Buffer.from(chunk, encoding)
        encoding = 'buffer'
      }
    } else if (chunk instanceof Buffer) {
      encoding = 'buffer'
    } else if (Stream._isUint8Array(chunk)) {
      chunk = Stream._uint8ArrayToBuffer(chunk)
      encoding = 'buffer'
    } else {
      throw new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk)
    }
  }
  let err
  if (state.ending) {
    err = new ERR_STREAM_WRITE_AFTER_END()
  } else if (state.destroyed) {
    err = new ERR_STREAM_DESTROYED('write')
  }
  if (err) {
    process.nextTick(cb, err)
    errorOrDestroy(stream, err, true)
    return err
  }
  state.pendingcb++
  return writeOrBuffer(stream, state, chunk, encoding, cb)
}
Writable.prototype.write = function (chunk, encoding, cb) {
  return _write(this, chunk, encoding, cb) === true
}
Writable.prototype.cork = function () {
  this._writableState.corked++
}
Writable.prototype.uncork = function () {
  const state = this._writableState
  if (state.corked) {
    state.corked--
    if (!state.writing) clearBuffer(this, state)
  }
}
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = StringPrototypeToLowerCase(encoding)
  if (!Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding)
  this._writableState.defaultEncoding = encoding
  return this
}

// If we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, callback) {
  const len = state.objectMode ? 1 : chunk.length
  state.length += len

  // stream._write resets state.length
  const ret = state.length < state.highWaterMark
  // We must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true
  if (state.writing || state.corked || state.errored || !state.constructed) {
    state.buffered.push({
      chunk,
      encoding,
      callback
    })
    if (state.allBuffers && encoding !== 'buffer') {
      state.allBuffers = false
    }
    if (state.allNoop && callback !== nop) {
      state.allNoop = false
    }
  } else {
    state.writelen = len
    state.writecb = callback
    state.writing = true
    state.sync = true
    stream._write(chunk, encoding, state.onwrite)
    state.sync = false
  }

  // Return false if errored or destroyed in order to break
  // any synchronous while(stream.write(data)) loops.
  return ret && !state.errored && !state.destroyed
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len
  state.writecb = cb
  state.writing = true
  state.sync = true
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'))
  else if (writev) stream._writev(chunk, state.onwrite)
  else stream._write(chunk, encoding, state.onwrite)
  state.sync = false
}
function onwriteError(stream, state, er, cb) {
  --state.pendingcb
  cb(er)
  // Ensure callbacks are invoked even when autoDestroy is
  // not enabled. Passing `er` here doesn't make sense since
  // it's related to one specific write, not to the buffered
  // writes.
  errorBuffer(state)
  // This can emit error, but error must always follow cb.
  errorOrDestroy(stream, er)
}
function onwrite(stream, er) {
  const state = stream._writableState
  const sync = state.sync
  const cb = state.writecb
  if (typeof cb !== 'function') {
    errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK())
    return
  }
  state.writing = false
  state.writecb = null
  state.length -= state.writelen
  state.writelen = 0
  if (er) {
    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
    er.stack // eslint-disable-line no-unused-expressions

    if (!state.errored) {
      state.errored = er
    }

    // In case of duplex streams we need to notify the readable side of the
    // error.
    if (stream._readableState && !stream._readableState.errored) {
      stream._readableState.errored = er
    }
    if (sync) {
      process.nextTick(onwriteError, stream, state, er, cb)
    } else {
      onwriteError(stream, state, er, cb)
    }
  } else {
    if (state.buffered.length > state.bufferedIndex) {
      clearBuffer(stream, state)
    }
    if (sync) {
      // It is a common case that the callback passed to .write() is always
      // the same. In that case, we do not schedule a new nextTick(), but
      // rather just increase a counter, to improve performance and avoid
      // memory allocations.
      if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
        state.afterWriteTickInfo.count++
      } else {
        state.afterWriteTickInfo = {
          count: 1,
          cb,
          stream,
          state
        }
        process.nextTick(afterWriteTick, state.afterWriteTickInfo)
      }
    } else {
      afterWrite(stream, state, 1, cb)
    }
  }
}
function afterWriteTick({ stream, state, count, cb }) {
  state.afterWriteTickInfo = null
  return afterWrite(stream, state, count, cb)
}
function afterWrite(stream, state, count, cb) {
  const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain
  if (needDrain) {
    state.needDrain = false
    stream.emit('drain')
  }
  while (count-- > 0) {
    state.pendingcb--
    cb()
  }
  if (state.destroyed) {
    errorBuffer(state)
  }
  finishMaybe(stream, state)
}

// If there's something in the buffer waiting, then invoke callbacks.
function errorBuffer(state) {
  if (state.writing) {
    return
  }
  for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
    var _state$errored
    const { chunk, callback } = state.buffered[n]
    const len = state.objectMode ? 1 : chunk.length
    state.length -= len
    callback(
      (_state$errored = state.errored) !== null && _state$errored !== undefined
        ? _state$errored
        : new ERR_STREAM_DESTROYED('write')
    )
  }
  const onfinishCallbacks = state[kOnFinished].splice(0)
  for (let i = 0; i < onfinishCallbacks.length; i++) {
    var _state$errored2
    onfinishCallbacks[i](
      (_state$errored2 = state.errored) !== null && _state$errored2 !== undefined
        ? _state$errored2
        : new ERR_STREAM_DESTROYED('end')
    )
  }
  resetBuffer(state)
}

// If there's something in the buffer waiting, then process it.
function clearBuffer(stream, state) {
  if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
    return
  }
  const { buffered, bufferedIndex, objectMode } = state
  const bufferedLength = buffered.length - bufferedIndex
  if (!bufferedLength) {
    return
  }
  let i = bufferedIndex
  state.bufferProcessing = true
  if (bufferedLength > 1 && stream._writev) {
    state.pendingcb -= bufferedLength - 1
    const callback = state.allNoop
      ? nop
      : (err) => {
          for (let n = i; n < buffered.length; ++n) {
            buffered[n].callback(err)
          }
        }
    // Make a copy of `buffered` if it's going to be used by `callback` above,
    // since `doWrite` will mutate the array.
    const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i)
    chunks.allBuffers = state.allBuffers
    doWrite(stream, state, true, state.length, chunks, '', callback)
    resetBuffer(state)
  } else {
    do {
      const { chunk, encoding, callback } = buffered[i]
      buffered[i++] = null
      const len = objectMode ? 1 : chunk.length
      doWrite(stream, state, false, len, chunk, encoding, callback)
    } while (i < buffered.length && !state.writing)
    if (i === buffered.length) {
      resetBuffer(state)
    } else if (i > 256) {
      buffered.splice(0, i)
      state.bufferedIndex = 0
    } else {
      state.bufferedIndex = i
    }
  }
  state.bufferProcessing = false
}
Writable.prototype._write = function (chunk, encoding, cb) {
  if (this._writev) {
    this._writev(
      [
        {
          chunk,
          encoding
        }
      ],
      cb
    )
  } else {
    throw new ERR_METHOD_NOT_IMPLEMENTED('_write()')
  }
}
Writable.prototype._writev = null
Writable.prototype.end = function (chunk, encoding, cb) {
  const state = this._writableState
  if (typeof chunk === 'function') {
    cb = chunk
    chunk = null
    encoding = null
  } else if (typeof encoding === 'function') {
    cb = encoding
    encoding = null
  }
  let err
  if (chunk !== null && chunk !== undefined) {
    const ret = _write(this, chunk, encoding)
    if (ret instanceof Error) {
      err = ret
    }
  }

  // .end() fully uncorks.
  if (state.corked) {
    state.corked = 1
    this.uncork()
  }
  if (err) {
    // Do nothing...
  } else if (!state.errored && !state.ending) {
    // This is forgiving in terms of unnecessary calls to end() and can hide
    // logic errors. However, usually such errors are harmless and causing a
    // hard error can be disproportionately destructive. It is not always
    // trivial for the user to determine whether end() needs to be called
    // or not.

    state.ending = true
    finishMaybe(this, state, true)
    state.ended = true
  } else if (state.finished) {
    err = new ERR_STREAM_ALREADY_FINISHED('end')
  } else if (state.destroyed) {
    err = new ERR_STREAM_DESTROYED('end')
  }
  if (typeof cb === 'function') {
    if (err || state.finished) {
      process.nextTick(cb, err)
    } else {
      state[kOnFinished].push(cb)
    }
  }
  return this
}
function needFinish(state) {
  return (
    state.ending &&
    !state.destroyed &&
    state.constructed &&
    state.length === 0 &&
    !state.errored &&
    state.buffered.length === 0 &&
    !state.finished &&
    !state.writing &&
    !state.errorEmitted &&
    !state.closeEmitted
  )
}
function callFinal(stream, state) {
  let called = false
  function onFinish(err) {
    if (called) {
      errorOrDestroy(stream, err !== null && err !== undefined ? err : ERR_MULTIPLE_CALLBACK())
      return
    }
    called = true
    state.pendingcb--
    if (err) {
      const onfinishCallbacks = state[kOnFinished].splice(0)
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i](err)
      }
      errorOrDestroy(stream, err, state.sync)
    } else if (needFinish(state)) {
      state.prefinished = true
      stream.emit('prefinish')
      // Backwards compat. Don't check state.sync here.
      // Some streams assume 'finish' will be emitted
      // asynchronously relative to _final callback.
      state.pendingcb++
      process.nextTick(finish, stream, state)
    }
  }
  state.sync = true
  state.pendingcb++
  try {
    stream._final(onFinish)
  } catch (err) {
    onFinish(err)
  }
  state.sync = false
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.finalCalled = true
      callFinal(stream, state)
    } else {
      state.prefinished = true
      stream.emit('prefinish')
    }
  }
}
function finishMaybe(stream, state, sync) {
  if (needFinish(state)) {
    prefinish(stream, state)
    if (state.pendingcb === 0) {
      if (sync) {
        state.pendingcb++
        process.nextTick(
          (stream, state) => {
            if (needFinish(state)) {
              finish(stream, state)
            } else {
              state.pendingcb--
            }
          },
          stream,
          state
        )
      } else if (needFinish(state)) {
        state.pendingcb++
        finish(stream, state)
      }
    }
  }
}
function finish(stream, state) {
  state.pendingcb--
  state.finished = true
  const onfinishCallbacks = state[kOnFinished].splice(0)
  for (let i = 0; i < onfinishCallbacks.length; i++) {
    onfinishCallbacks[i]()
  }
  stream.emit('finish')
  if (state.autoDestroy) {
    // In case of duplex streams we need a way to detect
    // if the readable side is ready for autoDestroy as well.
    const rState = stream._readableState
    const autoDestroy =
      !rState ||
      (rState.autoDestroy &&
        // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false))
    if (autoDestroy) {
      stream.destroy()
    }
  }
}
ObjectDefineProperties(Writable.prototype, {
  closed: {
    __proto__: null,
    get() {
      return this._writableState ? this._writableState.closed : false
    }
  },
  destroyed: {
    __proto__: null,
    get() {
      return this._writableState ? this._writableState.destroyed : false
    },
    set(value) {
      // Backward compatibility, the user is explicitly managing destroyed.
      if (this._writableState) {
        this._writableState.destroyed = value
      }
    }
  },
  writable: {
    __proto__: null,
    get() {
      const w = this._writableState
      // w.writable === false means that this is part of a Duplex stream
      // where the writable side was disabled upon construction.
      // Compat. The user might manually disable writable side through
      // deprecated setter.
      return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended
    },
    set(val) {
      // Backwards compatible.
      if (this._writableState) {
        this._writableState.writable = !!val
      }
    }
  },
  writableFinished: {
    __proto__: null,
    get() {
      return this._writableState ? this._writableState.finished : false
    }
  },
  writableObjectMode: {
    __proto__: null,
    get() {
      return this._writableState ? this._writableState.objectMode : false
    }
  },
  writableBuffer: {
    __proto__: null,
    get() {
      return this._writableState && this._writableState.getBuffer()
    }
  },
  writableEnded: {
    __proto__: null,
    get() {
      return this._writableState ? this._writableState.ending : false
    }
  },
  writableNeedDrain: {
    __proto__: null,
    get() {
      const wState = this._writableState
      if (!wState) return false
      return !wState.destroyed && !wState.ending && wState.needDrain
    }
  },
  writableHighWaterMark: {
    __proto__: null,
    get() {
      return this._writableState && this._writableState.highWaterMark
    }
  },
  writableCorked: {
    __proto__: null,
    get() {
      return this._writableState ? this._writableState.corked : 0
    }
  },
  writableLength: {
    __proto__: null,
    get() {
      return this._writableState && this._writableState.length
    }
  },
  errored: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._writableState ? this._writableState.errored : null
    }
  },
  writableAborted: {
    __proto__: null,
    enumerable: false,
    get: function () {
      return !!(
        this._writableState.writable !== false &&
        (this._writableState.destroyed || this._writableState.errored) &&
        !this._writableState.finished
      )
    }
  }
})
const destroy = destroyImpl.destroy
Writable.prototype.destroy = function (err, cb) {
  const state = this._writableState

  // Invoke pending callbacks.
  if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
    process.nextTick(errorBuffer, state)
  }
  destroy.call(this, err, cb)
  return this
}
Writable.prototype._undestroy = destroyImpl.undestroy
Writable.prototype._destroy = function (err, cb) {
  cb(err)
}
Writable.prototype[EE.captureRejectionSymbol] = function (err) {
  this.destroy(err)
}
let webStreamsAdapters

// Lazy to avoid circular references
function lazyWebStreams() {
  if (webStreamsAdapters === undefined) webStreamsAdapters = {}
  return webStreamsAdapters
}
Writable.fromWeb = function (writableStream, options) {
  return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options)
}
Writable.toWeb = function (streamWritable) {
  return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable)
}

},{"../../ours/errors":126,"../../ours/primordials":127,"./add-abort-signal":107,"./destroy":110,"./duplex":111,"./legacy":115,"./state":120,"buffer":29,"events":49,"process/":102}],124:[function(require,module,exports){
/* eslint jsdoc/require-jsdoc: "error" */

'use strict'

const {
  ArrayIsArray,
  ArrayPrototypeIncludes,
  ArrayPrototypeJoin,
  ArrayPrototypeMap,
  NumberIsInteger,
  NumberIsNaN,
  NumberMAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER,
  NumberParseInt,
  ObjectPrototypeHasOwnProperty,
  RegExpPrototypeExec,
  String,
  StringPrototypeToUpperCase,
  StringPrototypeTrim
} = require('../ours/primordials')
const {
  hideStackFrames,
  codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
} = require('../ours/errors')
const { normalizeEncoding } = require('../ours/util')
const { isAsyncFunction, isArrayBufferView } = require('../ours/util').types
const signals = {}

/**
 * @param {*} value
 * @returns {boolean}
 */
function isInt32(value) {
  return value === (value | 0)
}

/**
 * @param {*} value
 * @returns {boolean}
 */
function isUint32(value) {
  return value === value >>> 0
}
const octalReg = /^[0-7]+$/
const modeDesc = 'must be a 32-bit unsigned integer or an octal string'

/**
 * Parse and validate values that will be converted into mode_t (the S_*
 * constants). Only valid numbers and octal strings are allowed. They could be
 * converted to 32-bit unsigned integers or non-negative signed integers in the
 * C++ land, but any value higher than 0o777 will result in platform-specific
 * behaviors.
 *
 * @param {*} value Values to be validated
 * @param {string} name Name of the argument
 * @param {number} [def] If specified, will be returned for invalid values
 * @returns {number}
 */
function parseFileMode(value, name, def) {
  if (typeof value === 'undefined') {
    value = def
  }
  if (typeof value === 'string') {
    if (RegExpPrototypeExec(octalReg, value) === null) {
      throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc)
    }
    value = NumberParseInt(value, 8)
  }
  validateUint32(value, name)
  return value
}

/**
 * @callback validateInteger
 * @param {*} value
 * @param {string} name
 * @param {number} [min]
 * @param {number} [max]
 * @returns {asserts value is number}
 */

/** @type {validateInteger} */
const validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)
  if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, 'an integer', value)
  if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)
})

/**
 * @callback validateInt32
 * @param {*} value
 * @param {string} name
 * @param {number} [min]
 * @param {number} [max]
 * @returns {asserts value is number}
 */

/** @type {validateInt32} */
const validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
  // The defaults for min and max correspond to the limits of 32-bit integers.
  if (typeof value !== 'number') {
    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
  if (!NumberIsInteger(value)) {
    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)
  }
  if (value < min || value > max) {
    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)
  }
})

/**
 * @callback validateUint32
 * @param {*} value
 * @param {string} name
 * @param {number|boolean} [positive=false]
 * @returns {asserts value is number}
 */

/** @type {validateUint32} */
const validateUint32 = hideStackFrames((value, name, positive = false) => {
  if (typeof value !== 'number') {
    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
  if (!NumberIsInteger(value)) {
    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)
  }
  const min = positive ? 1 : 0
  // 2 ** 32 === 4294967296
  const max = 4294967295
  if (value < min || value > max) {
    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)
  }
})

/**
 * @callback validateString
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is string}
 */

/** @type {validateString} */
function validateString(value, name) {
  if (typeof value !== 'string') throw new ERR_INVALID_ARG_TYPE(name, 'string', value)
}

/**
 * @callback validateNumber
 * @param {*} value
 * @param {string} name
 * @param {number} [min]
 * @param {number} [max]
 * @returns {asserts value is number}
 */

/** @type {validateNumber} */
function validateNumber(value, name, min = undefined, max) {
  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)
  if (
    (min != null && value < min) ||
    (max != null && value > max) ||
    ((min != null || max != null) && NumberIsNaN(value))
  ) {
    throw new ERR_OUT_OF_RANGE(
      name,
      `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`,
      value
    )
  }
}

/**
 * @callback validateOneOf
 * @template T
 * @param {T} value
 * @param {string} name
 * @param {T[]} oneOf
 */

/** @type {validateOneOf} */
const validateOneOf = hideStackFrames((value, name, oneOf) => {
  if (!ArrayPrototypeIncludes(oneOf, value)) {
    const allowed = ArrayPrototypeJoin(
      ArrayPrototypeMap(oneOf, (v) => (typeof v === 'string' ? `'${v}'` : String(v))),
      ', '
    )
    const reason = 'must be one of: ' + allowed
    throw new ERR_INVALID_ARG_VALUE(name, value, reason)
  }
})

/**
 * @callback validateBoolean
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is boolean}
 */

/** @type {validateBoolean} */
function validateBoolean(value, name) {
  if (typeof value !== 'boolean') throw new ERR_INVALID_ARG_TYPE(name, 'boolean', value)
}

/**
 * @param {any} options
 * @param {string} key
 * @param {boolean} defaultValue
 * @returns {boolean}
 */
function getOwnPropertyValueOrDefault(options, key, defaultValue) {
  return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key]
}

/**
 * @callback validateObject
 * @param {*} value
 * @param {string} name
 * @param {{
 *   allowArray?: boolean,
 *   allowFunction?: boolean,
 *   nullable?: boolean
 * }} [options]
 */

/** @type {validateObject} */
const validateObject = hideStackFrames((value, name, options = null) => {
  const allowArray = getOwnPropertyValueOrDefault(options, 'allowArray', false)
  const allowFunction = getOwnPropertyValueOrDefault(options, 'allowFunction', false)
  const nullable = getOwnPropertyValueOrDefault(options, 'nullable', false)
  if (
    (!nullable && value === null) ||
    (!allowArray && ArrayIsArray(value)) ||
    (typeof value !== 'object' && (!allowFunction || typeof value !== 'function'))
  ) {
    throw new ERR_INVALID_ARG_TYPE(name, 'Object', value)
  }
})

/**
 * @callback validateDictionary - We are using the Web IDL Standard definition
 *                                of "dictionary" here, which means any value
 *                                whose Type is either Undefined, Null, or
 *                                Object (which includes functions).
 * @param {*} value
 * @param {string} name
 * @see https://webidl.spec.whatwg.org/#es-dictionary
 * @see https://tc39.es/ecma262/#table-typeof-operator-results
 */

/** @type {validateDictionary} */
const validateDictionary = hideStackFrames((value, name) => {
  if (value != null && typeof value !== 'object' && typeof value !== 'function') {
    throw new ERR_INVALID_ARG_TYPE(name, 'a dictionary', value)
  }
})

/**
 * @callback validateArray
 * @param {*} value
 * @param {string} name
 * @param {number} [minLength]
 * @returns {asserts value is any[]}
 */

/** @type {validateArray} */
const validateArray = hideStackFrames((value, name, minLength = 0) => {
  if (!ArrayIsArray(value)) {
    throw new ERR_INVALID_ARG_TYPE(name, 'Array', value)
  }
  if (value.length < minLength) {
    const reason = `must be longer than ${minLength}`
    throw new ERR_INVALID_ARG_VALUE(name, value, reason)
  }
})

/**
 * @callback validateStringArray
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is string[]}
 */

/** @type {validateStringArray} */
function validateStringArray(value, name) {
  validateArray(value, name)
  for (let i = 0; i < value.length; i++) {
    validateString(value[i], `${name}[${i}]`)
  }
}

/**
 * @callback validateBooleanArray
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is boolean[]}
 */

/** @type {validateBooleanArray} */
function validateBooleanArray(value, name) {
  validateArray(value, name)
  for (let i = 0; i < value.length; i++) {
    validateBoolean(value[i], `${name}[${i}]`)
  }
}

/**
 * @param {*} signal
 * @param {string} [name='signal']
 * @returns {asserts signal is keyof signals}
 */
function validateSignalName(signal, name = 'signal') {
  validateString(signal, name)
  if (signals[signal] === undefined) {
    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {
      throw new ERR_UNKNOWN_SIGNAL(signal + ' (signals must use all capital letters)')
    }
    throw new ERR_UNKNOWN_SIGNAL(signal)
  }
}

/**
 * @callback validateBuffer
 * @param {*} buffer
 * @param {string} [name='buffer']
 * @returns {asserts buffer is ArrayBufferView}
 */

/** @type {validateBuffer} */
const validateBuffer = hideStackFrames((buffer, name = 'buffer') => {
  if (!isArrayBufferView(buffer)) {
    throw new ERR_INVALID_ARG_TYPE(name, ['Buffer', 'TypedArray', 'DataView'], buffer)
  }
})

/**
 * @param {string} data
 * @param {string} encoding
 */
function validateEncoding(data, encoding) {
  const normalizedEncoding = normalizeEncoding(encoding)
  const length = data.length
  if (normalizedEncoding === 'hex' && length % 2 !== 0) {
    throw new ERR_INVALID_ARG_VALUE('encoding', encoding, `is invalid for data of length ${length}`)
  }
}

/**
 * Check that the port number is not NaN when coerced to a number,
 * is an integer and that it falls within the legal range of port numbers.
 * @param {*} port
 * @param {string} [name='Port']
 * @param {boolean} [allowZero=true]
 * @returns {number}
 */
function validatePort(port, name = 'Port', allowZero = true) {
  if (
    (typeof port !== 'number' && typeof port !== 'string') ||
    (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||
    +port !== +port >>> 0 ||
    port > 0xffff ||
    (port === 0 && !allowZero)
  ) {
    throw new ERR_SOCKET_BAD_PORT(name, port, allowZero)
  }
  return port | 0
}

/**
 * @callback validateAbortSignal
 * @param {*} signal
 * @param {string} name
 */

/** @type {validateAbortSignal} */
const validateAbortSignal = hideStackFrames((signal, name) => {
  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {
    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)
  }
})

/**
 * @callback validateFunction
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is Function}
 */

/** @type {validateFunction} */
const validateFunction = hideStackFrames((value, name) => {
  if (typeof value !== 'function') throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)
})

/**
 * @callback validatePlainFunction
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is Function}
 */

/** @type {validatePlainFunction} */
const validatePlainFunction = hideStackFrames((value, name) => {
  if (typeof value !== 'function' || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)
})

/**
 * @callback validateUndefined
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is undefined}
 */

/** @type {validateUndefined} */
const validateUndefined = hideStackFrames((value, name) => {
  if (value !== undefined) throw new ERR_INVALID_ARG_TYPE(name, 'undefined', value)
})

/**
 * @template T
 * @param {T} value
 * @param {string} name
 * @param {T[]} union
 */
function validateUnion(value, name, union) {
  if (!ArrayPrototypeIncludes(union, value)) {
    throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, '|')}')`, value)
  }
}

/*
  The rules for the Link header field are described here:
  https://www.rfc-editor.org/rfc/rfc8288.html#section-3

  This regex validates any string surrounded by angle brackets
  (not necessarily a valid URI reference) followed by zero or more
  link-params separated by semicolons.
*/
const linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/

/**
 * @param {any} value
 * @param {string} name
 */
function validateLinkHeaderFormat(value, name) {
  if (typeof value === 'undefined' || !RegExpPrototypeExec(linkValueRegExp, value)) {
    throw new ERR_INVALID_ARG_VALUE(
      name,
      value,
      'must be an array or string of format "</styles.css>; rel=preload; as=style"'
    )
  }
}

/**
 * @param {any} hints
 * @return {string}
 */
function validateLinkHeaderValue(hints) {
  if (typeof hints === 'string') {
    validateLinkHeaderFormat(hints, 'hints')
    return hints
  } else if (ArrayIsArray(hints)) {
    const hintsLength = hints.length
    let result = ''
    if (hintsLength === 0) {
      return result
    }
    for (let i = 0; i < hintsLength; i++) {
      const link = hints[i]
      validateLinkHeaderFormat(link, 'hints')
      result += link
      if (i !== hintsLength - 1) {
        result += ', '
      }
    }
    return result
  }
  throw new ERR_INVALID_ARG_VALUE(
    'hints',
    hints,
    'must be an array or string of format "</styles.css>; rel=preload; as=style"'
  )
}
module.exports = {
  isInt32,
  isUint32,
  parseFileMode,
  validateArray,
  validateStringArray,
  validateBooleanArray,
  validateBoolean,
  validateBuffer,
  validateDictionary,
  validateEncoding,
  validateFunction,
  validateInt32,
  validateInteger,
  validateNumber,
  validateObject,
  validateOneOf,
  validatePlainFunction,
  validatePort,
  validateSignalName,
  validateString,
  validateUint32,
  validateUndefined,
  validateUnion,
  validateAbortSignal,
  validateLinkHeaderValue
}

},{"../ours/errors":126,"../ours/primordials":127,"../ours/util":128}],125:[function(require,module,exports){
'use strict'

const CustomStream = require('../stream')
const promises = require('../stream/promises')
const originalDestroy = CustomStream.Readable.destroy
module.exports = CustomStream.Readable

// Explicit export naming is needed for ESM
module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer
module.exports._isUint8Array = CustomStream._isUint8Array
module.exports.isDisturbed = CustomStream.isDisturbed
module.exports.isErrored = CustomStream.isErrored
module.exports.isReadable = CustomStream.isReadable
module.exports.Readable = CustomStream.Readable
module.exports.Writable = CustomStream.Writable
module.exports.Duplex = CustomStream.Duplex
module.exports.Transform = CustomStream.Transform
module.exports.PassThrough = CustomStream.PassThrough
module.exports.addAbortSignal = CustomStream.addAbortSignal
module.exports.finished = CustomStream.finished
module.exports.destroy = CustomStream.destroy
module.exports.destroy = originalDestroy
module.exports.pipeline = CustomStream.pipeline
module.exports.compose = CustomStream.compose
Object.defineProperty(CustomStream, 'promises', {
  configurable: true,
  enumerable: true,
  get() {
    return promises
  }
})
module.exports.Stream = CustomStream.Stream

// Allow default importing
module.exports.default = module.exports

},{"../stream":129,"../stream/promises":130}],126:[function(require,module,exports){
'use strict'

const { format, inspect, AggregateError: CustomAggregateError } = require('./util')

/*
  This file is a reduced and adapted version of the main lib/internal/errors.js file defined at

  https://github.com/nodejs/node/blob/master/lib/internal/errors.js

  Don't try to replace with the original file and keep it up to date (starting from E(...) definitions)
  with the upstream file.
*/

const AggregateError = globalThis.AggregateError || CustomAggregateError
const kIsNodeError = Symbol('kIsNodeError')
const kTypes = [
  'string',
  'function',
  'number',
  'object',
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  'Function',
  'Object',
  'boolean',
  'bigint',
  'symbol'
]
const classRegExp = /^([A-Z][a-z0-9]*)+$/
const nodeInternalPrefix = '__node_internal_'
const codes = {}
function assert(value, message) {
  if (!value) {
    throw new codes.ERR_INTERNAL_ASSERTION(message)
  }
}

// Only use this for integers! Decimal numbers do not work with this function.
function addNumericalSeparator(val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}
function getMessage(key, msg, args) {
  if (typeof msg === 'function') {
    assert(
      msg.length <= args.length,
      // Default options do not count.
      `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
    )
    return msg(...args)
  }
  const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length
  assert(
    expectedLength === args.length,
    `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
  )
  if (args.length === 0) {
    return msg
  }
  return format(msg, ...args)
}
function E(code, message, Base) {
  if (!Base) {
    Base = Error
  }
  class NodeError extends Base {
    constructor(...args) {
      super(getMessage(code, message, args))
    }
    toString() {
      return `${this.name} [${code}]: ${this.message}`
    }
  }
  Object.defineProperties(NodeError.prototype, {
    name: {
      value: Base.name,
      writable: true,
      enumerable: false,
      configurable: true
    },
    toString: {
      value() {
        return `${this.name} [${code}]: ${this.message}`
      },
      writable: true,
      enumerable: false,
      configurable: true
    }
  })
  NodeError.prototype.code = code
  NodeError.prototype[kIsNodeError] = true
  codes[code] = NodeError
}
function hideStackFrames(fn) {
  // We rename the functions that will be hidden to cut off the stacktrace
  // at the outermost one
  const hidden = nodeInternalPrefix + fn.name
  Object.defineProperty(fn, 'name', {
    value: hidden
  })
  return fn
}
function aggregateTwoErrors(innerError, outerError) {
  if (innerError && outerError && innerError !== outerError) {
    if (Array.isArray(outerError.errors)) {
      // If `outerError` is already an `AggregateError`.
      outerError.errors.push(innerError)
      return outerError
    }
    const err = new AggregateError([outerError, innerError], outerError.message)
    err.code = outerError.code
    return err
  }
  return innerError || outerError
}
class AbortError extends Error {
  constructor(message = 'The operation was aborted', options = undefined) {
    if (options !== undefined && typeof options !== 'object') {
      throw new codes.ERR_INVALID_ARG_TYPE('options', 'Object', options)
    }
    super(message, options)
    this.code = 'ABORT_ERR'
    this.name = 'AbortError'
  }
}
E('ERR_ASSERTION', '%s', Error)
E(
  'ERR_INVALID_ARG_TYPE',
  (name, expected, actual) => {
    assert(typeof name === 'string', "'name' must be a string")
    if (!Array.isArray(expected)) {
      expected = [expected]
    }
    let msg = 'The '
    if (name.endsWith(' argument')) {
      // For cases like 'first argument'
      msg += `${name} `
    } else {
      msg += `"${name}" ${name.includes('.') ? 'property' : 'argument'} `
    }
    msg += 'must be '
    const types = []
    const instances = []
    const other = []
    for (const value of expected) {
      assert(typeof value === 'string', 'All expected entries have to be of type string')
      if (kTypes.includes(value)) {
        types.push(value.toLowerCase())
      } else if (classRegExp.test(value)) {
        instances.push(value)
      } else {
        assert(value !== 'object', 'The value "object" should be written as "Object"')
        other.push(value)
      }
    }

    // Special handle `object` in case other instances are allowed to outline
    // the differences between each other.
    if (instances.length > 0) {
      const pos = types.indexOf('object')
      if (pos !== -1) {
        types.splice(types, pos, 1)
        instances.push('Object')
      }
    }
    if (types.length > 0) {
      switch (types.length) {
        case 1:
          msg += `of type ${types[0]}`
          break
        case 2:
          msg += `one of type ${types[0]} or ${types[1]}`
          break
        default: {
          const last = types.pop()
          msg += `one of type ${types.join(', ')}, or ${last}`
        }
      }
      if (instances.length > 0 || other.length > 0) {
        msg += ' or '
      }
    }
    if (instances.length > 0) {
      switch (instances.length) {
        case 1:
          msg += `an instance of ${instances[0]}`
          break
        case 2:
          msg += `an instance of ${instances[0]} or ${instances[1]}`
          break
        default: {
          const last = instances.pop()
          msg += `an instance of ${instances.join(', ')}, or ${last}`
        }
      }
      if (other.length > 0) {
        msg += ' or '
      }
    }
    switch (other.length) {
      case 0:
        break
      case 1:
        if (other[0].toLowerCase() !== other[0]) {
          msg += 'an '
        }
        msg += `${other[0]}`
        break
      case 2:
        msg += `one of ${other[0]} or ${other[1]}`
        break
      default: {
        const last = other.pop()
        msg += `one of ${other.join(', ')}, or ${last}`
      }
    }
    if (actual == null) {
      msg += `. Received ${actual}`
    } else if (typeof actual === 'function' && actual.name) {
      msg += `. Received function ${actual.name}`
    } else if (typeof actual === 'object') {
      var _actual$constructor
      if (
        (_actual$constructor = actual.constructor) !== null &&
        _actual$constructor !== undefined &&
        _actual$constructor.name
      ) {
        msg += `. Received an instance of ${actual.constructor.name}`
      } else {
        const inspected = inspect(actual, {
          depth: -1
        })
        msg += `. Received ${inspected}`
      }
    } else {
      let inspected = inspect(actual, {
        colors: false
      })
      if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`
      }
      msg += `. Received type ${typeof actual} (${inspected})`
    }
    return msg
  },
  TypeError
)
E(
  'ERR_INVALID_ARG_VALUE',
  (name, value, reason = 'is invalid') => {
    let inspected = inspect(value)
    if (inspected.length > 128) {
      inspected = inspected.slice(0, 128) + '...'
    }
    const type = name.includes('.') ? 'property' : 'argument'
    return `The ${type} '${name}' ${reason}. Received ${inspected}`
  },
  TypeError
)
E(
  'ERR_INVALID_RETURN_VALUE',
  (input, name, value) => {
    var _value$constructor
    const type =
      value !== null &&
      value !== undefined &&
      (_value$constructor = value.constructor) !== null &&
      _value$constructor !== undefined &&
      _value$constructor.name
        ? `instance of ${value.constructor.name}`
        : `type ${typeof value}`
    return `Expected ${input} to be returned from the "${name}"` + ` function but got ${type}.`
  },
  TypeError
)
E(
  'ERR_MISSING_ARGS',
  (...args) => {
    assert(args.length > 0, 'At least one arg needs to be specified')
    let msg
    const len = args.length
    args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(' or ')
    switch (len) {
      case 1:
        msg += `The ${args[0]} argument`
        break
      case 2:
        msg += `The ${args[0]} and ${args[1]} arguments`
        break
      default:
        {
          const last = args.pop()
          msg += `The ${args.join(', ')}, and ${last} arguments`
        }
        break
    }
    return `${msg} must be specified`
  },
  TypeError
)
E(
  'ERR_OUT_OF_RANGE',
  (str, range, input) => {
    assert(range, 'Missing "range" argument')
    let received
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > 2n ** 32n || input < -(2n ** 32n)) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    } else {
      received = inspect(input)
    }
    return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`
  },
  RangeError
)
E('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times', Error)
E('ERR_METHOD_NOT_IMPLEMENTED', 'The %s method is not implemented', Error)
E('ERR_STREAM_ALREADY_FINISHED', 'Cannot call %s after a stream was finished', Error)
E('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable', Error)
E('ERR_STREAM_DESTROYED', 'Cannot call %s after a stream was destroyed', Error)
E('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError)
E('ERR_STREAM_PREMATURE_CLOSE', 'Premature close', Error)
E('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF', Error)
E('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event', Error)
E('ERR_STREAM_WRITE_AFTER_END', 'write after end', Error)
E('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s', TypeError)
module.exports = {
  AbortError,
  aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
  hideStackFrames,
  codes
}

},{"./util":128}],127:[function(require,module,exports){
'use strict'

/*
  This file is a reduced and adapted version of the main lib/internal/per_context/primordials.js file defined at

  https://github.com/nodejs/node/blob/master/lib/internal/per_context/primordials.js

  Don't try to replace with the original file and keep it up to date with the upstream file.
*/
module.exports = {
  ArrayIsArray(self) {
    return Array.isArray(self)
  },
  ArrayPrototypeIncludes(self, el) {
    return self.includes(el)
  },
  ArrayPrototypeIndexOf(self, el) {
    return self.indexOf(el)
  },
  ArrayPrototypeJoin(self, sep) {
    return self.join(sep)
  },
  ArrayPrototypeMap(self, fn) {
    return self.map(fn)
  },
  ArrayPrototypePop(self, el) {
    return self.pop(el)
  },
  ArrayPrototypePush(self, el) {
    return self.push(el)
  },
  ArrayPrototypeSlice(self, start, end) {
    return self.slice(start, end)
  },
  Error,
  FunctionPrototypeCall(fn, thisArgs, ...args) {
    return fn.call(thisArgs, ...args)
  },
  FunctionPrototypeSymbolHasInstance(self, instance) {
    return Function.prototype[Symbol.hasInstance].call(self, instance)
  },
  MathFloor: Math.floor,
  Number,
  NumberIsInteger: Number.isInteger,
  NumberIsNaN: Number.isNaN,
  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
  NumberParseInt: Number.parseInt,
  ObjectDefineProperties(self, props) {
    return Object.defineProperties(self, props)
  },
  ObjectDefineProperty(self, name, prop) {
    return Object.defineProperty(self, name, prop)
  },
  ObjectGetOwnPropertyDescriptor(self, name) {
    return Object.getOwnPropertyDescriptor(self, name)
  },
  ObjectKeys(obj) {
    return Object.keys(obj)
  },
  ObjectSetPrototypeOf(target, proto) {
    return Object.setPrototypeOf(target, proto)
  },
  Promise,
  PromisePrototypeCatch(self, fn) {
    return self.catch(fn)
  },
  PromisePrototypeThen(self, thenFn, catchFn) {
    return self.then(thenFn, catchFn)
  },
  PromiseReject(err) {
    return Promise.reject(err)
  },
  ReflectApply: Reflect.apply,
  RegExpPrototypeTest(self, value) {
    return self.test(value)
  },
  SafeSet: Set,
  String,
  StringPrototypeSlice(self, start, end) {
    return self.slice(start, end)
  },
  StringPrototypeToLowerCase(self) {
    return self.toLowerCase()
  },
  StringPrototypeToUpperCase(self) {
    return self.toUpperCase()
  },
  StringPrototypeTrim(self) {
    return self.trim()
  },
  Symbol,
  SymbolFor: Symbol.for,
  SymbolAsyncIterator: Symbol.asyncIterator,
  SymbolHasInstance: Symbol.hasInstance,
  SymbolIterator: Symbol.iterator,
  TypedArrayPrototypeSet(self, buf, len) {
    return self.set(buf, len)
  },
  Uint8Array
}

},{}],128:[function(require,module,exports){
'use strict'

const bufferModule = require('buffer')
const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor
const Blob = globalThis.Blob || bufferModule.Blob
/* eslint-disable indent */
const isBlob =
  typeof Blob !== 'undefined'
    ? function isBlob(b) {
        // eslint-disable-next-line indent
        return b instanceof Blob
      }
    : function isBlob(b) {
        return false
      }
/* eslint-enable indent */

// This is a simplified version of AggregateError
class AggregateError extends Error {
  constructor(errors) {
    if (!Array.isArray(errors)) {
      throw new TypeError(`Expected input to be an Array, got ${typeof errors}`)
    }
    let message = ''
    for (let i = 0; i < errors.length; i++) {
      message += `    ${errors[i].stack}\n`
    }
    super(message)
    this.name = 'AggregateError'
    this.errors = errors
  }
}
module.exports = {
  AggregateError,
  kEmptyObject: Object.freeze({}),
  once(callback) {
    let called = false
    return function (...args) {
      if (called) {
        return
      }
      called = true
      callback.apply(this, args)
    }
  },
  createDeferredPromise: function () {
    let resolve
    let reject

    // eslint-disable-next-line promise/param-names
    const promise = new Promise((res, rej) => {
      resolve = res
      reject = rej
    })
    return {
      promise,
      resolve,
      reject
    }
  },
  promisify(fn) {
    return new Promise((resolve, reject) => {
      fn((err, ...args) => {
        if (err) {
          return reject(err)
        }
        return resolve(...args)
      })
    })
  },
  debuglog() {
    return function () {}
  },
  format(format, ...args) {
    // Simplified version of https://nodejs.org/api/util.html#utilformatformat-args
    return format.replace(/%([sdifj])/g, function (...[_unused, type]) {
      const replacement = args.shift()
      if (type === 'f') {
        return replacement.toFixed(6)
      } else if (type === 'j') {
        return JSON.stringify(replacement)
      } else if (type === 's' && typeof replacement === 'object') {
        const ctor = replacement.constructor !== Object ? replacement.constructor.name : ''
        return `${ctor} {}`.trim()
      } else {
        return replacement.toString()
      }
    })
  },
  inspect(value) {
    // Vastly simplified version of https://nodejs.org/api/util.html#utilinspectobject-options
    switch (typeof value) {
      case 'string':
        if (value.includes("'")) {
          if (!value.includes('"')) {
            return `"${value}"`
          } else if (!value.includes('`') && !value.includes('${')) {
            return `\`${value}\``
          }
        }
        return `'${value}'`
      case 'number':
        if (isNaN(value)) {
          return 'NaN'
        } else if (Object.is(value, -0)) {
          return String(value)
        }
        return value
      case 'bigint':
        return `${String(value)}n`
      case 'boolean':
      case 'undefined':
        return String(value)
      case 'object':
        return '{}'
    }
  },
  types: {
    isAsyncFunction(fn) {
      return fn instanceof AsyncFunction
    },
    isArrayBufferView(arr) {
      return ArrayBuffer.isView(arr)
    }
  },
  isBlob
}
module.exports.promisify.custom = Symbol.for('nodejs.util.promisify.custom')

},{"buffer":29}],129:[function(require,module,exports){
/* replacement start */

const { Buffer } = require('buffer')

/* replacement end */
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

;('use strict')
const { ObjectDefineProperty, ObjectKeys, ReflectApply } = require('./ours/primordials')
const {
  promisify: { custom: customPromisify }
} = require('./ours/util')
const { streamReturningOperators, promiseReturningOperators } = require('./internal/streams/operators')
const {
  codes: { ERR_ILLEGAL_CONSTRUCTOR }
} = require('./ours/errors')
const compose = require('./internal/streams/compose')
const { pipeline } = require('./internal/streams/pipeline')
const { destroyer } = require('./internal/streams/destroy')
const eos = require('./internal/streams/end-of-stream')
const internalBuffer = {}
const promises = require('./stream/promises')
const utils = require('./internal/streams/utils')
const Stream = (module.exports = require('./internal/streams/legacy').Stream)
Stream.isDisturbed = utils.isDisturbed
Stream.isErrored = utils.isErrored
Stream.isReadable = utils.isReadable
Stream.Readable = require('./internal/streams/readable')
for (const key of ObjectKeys(streamReturningOperators)) {
  const op = streamReturningOperators[key]
  function fn(...args) {
    if (new.target) {
      throw ERR_ILLEGAL_CONSTRUCTOR()
    }
    return Stream.Readable.from(ReflectApply(op, this, args))
  }
  ObjectDefineProperty(fn, 'name', {
    __proto__: null,
    value: op.name
  })
  ObjectDefineProperty(fn, 'length', {
    __proto__: null,
    value: op.length
  })
  ObjectDefineProperty(Stream.Readable.prototype, key, {
    __proto__: null,
    value: fn,
    enumerable: false,
    configurable: true,
    writable: true
  })
}
for (const key of ObjectKeys(promiseReturningOperators)) {
  const op = promiseReturningOperators[key]
  function fn(...args) {
    if (new.target) {
      throw ERR_ILLEGAL_CONSTRUCTOR()
    }
    return ReflectApply(op, this, args)
  }
  ObjectDefineProperty(fn, 'name', {
    __proto__: null,
    value: op.name
  })
  ObjectDefineProperty(fn, 'length', {
    __proto__: null,
    value: op.length
  })
  ObjectDefineProperty(Stream.Readable.prototype, key, {
    __proto__: null,
    value: fn,
    enumerable: false,
    configurable: true,
    writable: true
  })
}
Stream.Writable = require('./internal/streams/writable')
Stream.Duplex = require('./internal/streams/duplex')
Stream.Transform = require('./internal/streams/transform')
Stream.PassThrough = require('./internal/streams/passthrough')
Stream.pipeline = pipeline
const { addAbortSignal } = require('./internal/streams/add-abort-signal')
Stream.addAbortSignal = addAbortSignal
Stream.finished = eos
Stream.destroy = destroyer
Stream.compose = compose
ObjectDefineProperty(Stream, 'promises', {
  __proto__: null,
  configurable: true,
  enumerable: true,
  get() {
    return promises
  }
})
ObjectDefineProperty(pipeline, customPromisify, {
  __proto__: null,
  enumerable: true,
  get() {
    return promises.pipeline
  }
})
ObjectDefineProperty(eos, customPromisify, {
  __proto__: null,
  enumerable: true,
  get() {
    return promises.finished
  }
})

// Backwards-compat with node 0.4.x
Stream.Stream = Stream
Stream._isUint8Array = function isUint8Array(value) {
  return value instanceof Uint8Array
}
Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)
}

},{"./internal/streams/add-abort-signal":107,"./internal/streams/compose":109,"./internal/streams/destroy":110,"./internal/streams/duplex":111,"./internal/streams/end-of-stream":113,"./internal/streams/legacy":115,"./internal/streams/operators":116,"./internal/streams/passthrough":117,"./internal/streams/pipeline":118,"./internal/streams/readable":119,"./internal/streams/transform":121,"./internal/streams/utils":122,"./internal/streams/writable":123,"./ours/errors":126,"./ours/primordials":127,"./ours/util":128,"./stream/promises":130,"buffer":29}],130:[function(require,module,exports){
'use strict'

const { ArrayPrototypePop, Promise } = require('../ours/primordials')
const { isIterable, isNodeStream, isWebStream } = require('../internal/streams/utils')
const { pipelineImpl: pl } = require('../internal/streams/pipeline')
const { finished } = require('../internal/streams/end-of-stream')
require('../../lib/stream.js')
function pipeline(...streams) {
  return new Promise((resolve, reject) => {
    let signal
    let end
    const lastArg = streams[streams.length - 1]
    if (
      lastArg &&
      typeof lastArg === 'object' &&
      !isNodeStream(lastArg) &&
      !isIterable(lastArg) &&
      !isWebStream(lastArg)
    ) {
      const options = ArrayPrototypePop(streams)
      signal = options.signal
      end = options.end
    }
    pl(
      streams,
      (err, value) => {
        if (err) {
          reject(err)
        } else {
          resolve(value)
        }
      },
      {
        signal,
        end
      }
    )
  })
}
module.exports = {
  finished,
  pipeline
}

},{"../../lib/stream.js":129,"../internal/streams/end-of-stream":113,"../internal/streams/pipeline":118,"../internal/streams/utils":122,"../ours/primordials":127}],131:[function(require,module,exports){
'use strict'

function ReInterval (callback, interval, args) {
  var self = this;

  this._callback = callback;
  this._args = args;

  this._interval = setInterval(callback, interval, this._args);

  this.reschedule = function (interval) {
    // if no interval entered, use the interval passed in on creation
    if (!interval)
      interval = self._interval;

    if (self._interval)
      clearInterval(self._interval);
    self._interval = setInterval(self._callback, interval, self._args);
  };

  this.clear = function () {
    if (self._interval) {
      clearInterval(self._interval);
      self._interval = undefined;
    }
  };
  
  this.destroy = function () {
    if (self._interval) {
      clearInterval(self._interval);
    }
    self._callback = undefined;
    self._interval = undefined;
    self._args = undefined;
  };
}

function reInterval () {
  if (typeof arguments[0] !== 'function')
    throw new Error('callback needed');
  if (typeof arguments[1] !== 'number')
    throw new Error('interval needed');

  var args;

  if (arguments.length > 0) {
    args = new Array(arguments.length - 2);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 2];
    }
  }

  return new ReInterval(arguments[0], arguments[1], args);
}

module.exports = reInterval;

},{}],132:[function(require,module,exports){
'use strict'

module.exports = require('./index.js')()

},{"./index.js":133}],133:[function(require,module,exports){
(function (Buffer){(function (){
'use strict'
module.exports = rfdc

function copyBuffer (cur) {
  if (cur instanceof Buffer) {
    return Buffer.from(cur)
  }

  return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length)
}

function rfdc (opts) {
  opts = opts || {}

  if (opts.circles) return rfdcCircles(opts)
  return opts.proto ? cloneProto : clone

  function cloneArray (a, fn) {
    var keys = Object.keys(a)
    var a2 = new Array(keys.length)
    for (var i = 0; i < keys.length; i++) {
      var k = keys[i]
      var cur = a[k]
      if (typeof cur !== 'object' || cur === null) {
        a2[k] = cur
      } else if (cur instanceof Date) {
        a2[k] = new Date(cur)
      } else if (ArrayBuffer.isView(cur)) {
        a2[k] = copyBuffer(cur)
      } else {
        a2[k] = fn(cur)
      }
    }
    return a2
  }

  function clone (o) {
    if (typeof o !== 'object' || o === null) return o
    if (o instanceof Date) return new Date(o)
    if (Array.isArray(o)) return cloneArray(o, clone)
    if (o instanceof Map) return new Map(cloneArray(Array.from(o), clone))
    if (o instanceof Set) return new Set(cloneArray(Array.from(o), clone))
    var o2 = {}
    for (var k in o) {
      if (Object.hasOwnProperty.call(o, k) === false) continue
      var cur = o[k]
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur
      } else if (cur instanceof Date) {
        o2[k] = new Date(cur)
      } else if (cur instanceof Map) {
        o2[k] = new Map(cloneArray(Array.from(cur), clone))
      } else if (cur instanceof Set) {
        o2[k] = new Set(cloneArray(Array.from(cur), clone))
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur)
      } else {
        o2[k] = clone(cur)
      }
    }
    return o2
  }

  function cloneProto (o) {
    if (typeof o !== 'object' || o === null) return o
    if (o instanceof Date) return new Date(o)
    if (Array.isArray(o)) return cloneArray(o, cloneProto)
    if (o instanceof Map) return new Map(cloneArray(Array.from(o), cloneProto))
    if (o instanceof Set) return new Set(cloneArray(Array.from(o), cloneProto))
    var o2 = {}
    for (var k in o) {
      var cur = o[k]
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur
      } else if (cur instanceof Date) {
        o2[k] = new Date(cur)
      } else if (cur instanceof Map) {
        o2[k] = new Map(cloneArray(Array.from(cur), cloneProto))
      } else if (cur instanceof Set) {
        o2[k] = new Set(cloneArray(Array.from(cur), cloneProto))
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur)
      } else {
        o2[k] = cloneProto(cur)
      }
    }
    return o2
  }
}

function rfdcCircles (opts) {
  var refs = []
  var refsNew = []

  return opts.proto ? cloneProto : clone

  function cloneArray (a, fn) {
    var keys = Object.keys(a)
    var a2 = new Array(keys.length)
    for (var i = 0; i < keys.length; i++) {
      var k = keys[i]
      var cur = a[k]
      if (typeof cur !== 'object' || cur === null) {
        a2[k] = cur
      } else if (cur instanceof Date) {
        a2[k] = new Date(cur)
      } else if (ArrayBuffer.isView(cur)) {
        a2[k] = copyBuffer(cur)
      } else {
        var index = refs.indexOf(cur)
        if (index !== -1) {
          a2[k] = refsNew[index]
        } else {
          a2[k] = fn(cur)
        }
      }
    }
    return a2
  }

  function clone (o) {
    if (typeof o !== 'object' || o === null) return o
    if (o instanceof Date) return new Date(o)
    if (Array.isArray(o)) return cloneArray(o, clone)
    if (o instanceof Map) return new Map(cloneArray(Array.from(o), clone))
    if (o instanceof Set) return new Set(cloneArray(Array.from(o), clone))
    var o2 = {}
    refs.push(o)
    refsNew.push(o2)
    for (var k in o) {
      if (Object.hasOwnProperty.call(o, k) === false) continue
      var cur = o[k]
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur
      } else if (cur instanceof Date) {
        o2[k] = new Date(cur)
      } else if (cur instanceof Map) {
        o2[k] = new Map(cloneArray(Array.from(cur), clone))
      } else if (cur instanceof Set) {
        o2[k] = new Set(cloneArray(Array.from(cur), clone))
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur)
      } else {
        var i = refs.indexOf(cur)
        if (i !== -1) {
          o2[k] = refsNew[i]
        } else {
          o2[k] = clone(cur)
        }
      }
    }
    refs.pop()
    refsNew.pop()
    return o2
  }

  function cloneProto (o) {
    if (typeof o !== 'object' || o === null) return o
    if (o instanceof Date) return new Date(o)
    if (Array.isArray(o)) return cloneArray(o, cloneProto)
    if (o instanceof Map) return new Map(cloneArray(Array.from(o), cloneProto))
    if (o instanceof Set) return new Set(cloneArray(Array.from(o), cloneProto))
    var o2 = {}
    refs.push(o)
    refsNew.push(o2)
    for (var k in o) {
      var cur = o[k]
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur
      } else if (cur instanceof Date) {
        o2[k] = new Date(cur)
      } else if (cur instanceof Map) {
        o2[k] = new Map(cloneArray(Array.from(cur), cloneProto))
      } else if (cur instanceof Set) {
        o2[k] = new Set(cloneArray(Array.from(cur), cloneProto))
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur)
      } else {
        var i = refs.indexOf(cur)
        if (i !== -1) {
          o2[k] = refsNew[i]
        } else {
          o2[k] = cloneProto(cur)
        }
      }
    }
    refs.pop()
    refsNew.pop()
    return o2
  }
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":29}],134:[function(require,module,exports){
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":29}],135:[function(require,module,exports){
module.exports = shift

function shift (stream) {
  var rs = stream._readableState
  if (!rs) return null
  return (rs.objectMode || typeof stream._duplexState === 'number') ? stream.read() : stream.read(getStateLength(rs))
}

function getStateLength (state) {
  if (state.buffer.length) {
    // Since node 6.3.0 state.buffer is a BufferList not an array
    if (state.buffer.head) {
      return state.buffer.head.data.length
    }

    return state.buffer[0].length
  }

  return state.length
}

},{}],136:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"dup":28,"safe-buffer":134}],137:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":138,"punycode":103,"querystring":106}],138:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],139:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],140:[function(require,module,exports){
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

},{}],141:[function(require,module,exports){
'use strict';

module.exports = function () {
  throw new Error(
    'ws does not work in the browser. Browser clients must use the native ' +
      'WebSocket object'
  );
};

},{}]},{},[23])(23)
});
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).mqtt=e()}}((function(){return function e(t,r,n){function i(o,a){if(!r[o]){if(!t[o]){var l="function"==typeof require&&require;if(!a&&l)return l(o,!0);if(s)return s(o,!0);var u=new Error("Cannot find module '"+o+"'");throw u.code="MODULE_NOT_FOUND",u}var c=r[o]={exports:{}};t[o][0].call(c.exports,(function(e){return i(t[o][1][e]||e)}),c,c.exports,e,t,r,n)}return r[o].exports}for(var s="function"==typeof require&&require,o=0;o<n.length;o++)i(n[o]);return i}({1:[function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(r,"__esModule",{value:!0}),r.TypedEventEmitter=void 0;const i=n(e("events")),s=e("./shared");class o{}r.TypedEventEmitter=o,(0,s.applyMixin)(o,i.default)},{"./shared":17,events:49}],2:[function(e,t,r){(function(t,n){(function(){"use strict";var i=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),s=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&i(t,e,r);return s(t,e),t},a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(r,"__esModule",{value:!0});const l=a(e("./topic-alias-recv")),u=a(e("mqtt-packet")),c=a(e("./default-message-id-provider")),h=e("readable-stream"),f=a(e("reinterval")),d=a(e("rfdc/default")),p=o(e("./validations")),b=a(e("debug")),g=a(e("./store")),m=a(e("./handlers")),y=e("./TypedEmitter"),_=t?t.nextTick:e=>{setTimeout(e,0)},w=n.setImmediate||((...e)=>{const t=e.shift();_((()=>{t(...e)}))}),v={keepalive:60,reschedulePings:!0,protocolId:"MQTT",protocolVersion:4,reconnectPeriod:1e3,connectTimeout:3e4,clean:!0,resubscribe:!0,writeCache:!0},S=["ECONNREFUSED","EADDRINUSE","ECONNRESET","ENOTFOUND","ETIMEDOUT"];class E extends y.TypedEventEmitter{static defaultId(){return`mqttjs_${Math.random().toString(16).substr(2,8)}`}constructor(e,t){super(),this.options=t||{};for(const e in v)void 0===this.options[e]?this.options[e]=v[e]:this.options[e]=t[e];this.log=this.options.log||(0,b.default)("mqttjs:client"),this.noop=this._noop.bind(this),this.log("MqttClient :: options.protocol",t.protocol),this.log("MqttClient :: options.protocolVersion",t.protocolVersion),this.log("MqttClient :: options.username",t.username),this.log("MqttClient :: options.keepalive",t.keepalive),this.log("MqttClient :: options.reconnectPeriod",t.reconnectPeriod),this.log("MqttClient :: options.rejectUnauthorized",t.rejectUnauthorized),this.log("MqttClient :: options.properties.topicAliasMaximum",t.properties?t.properties.topicAliasMaximum:void 0),this.options.clientId="string"==typeof t.clientId?t.clientId:E.defaultId(),this.log("MqttClient :: clientId",this.options.clientId),this.options.customHandleAcks=5===t.protocolVersion&&t.customHandleAcks?t.customHandleAcks:(...e)=>{e[3](null,0)},this.options.writeCache||(u.default.writeToStream.cacheNumbers=!1),this.streamBuilder=e,this.messageIdProvider=void 0===this.options.messageIdProvider?new c.default:this.options.messageIdProvider,this.outgoingStore=t.outgoingStore||new g.default,this.incomingStore=t.incomingStore||new g.default,this.queueQoSZero=void 0===t.queueQoSZero||t.queueQoSZero,this._resubscribeTopics={},this.messageIdToTopic={},this.pingTimer=null,this.connected=!1,this.disconnecting=!1,this.reconnecting=!1,this.queue=[],this.connackTimer=null,this.reconnectTimer=null,this._storeProcessing=!1,this._packetIdsDuringStoreProcessing={},this._storeProcessingQueue=[],this.outgoing={},this._firstConnection=!0,t.properties&&t.properties.topicAliasMaximum>0&&(t.properties.topicAliasMaximum>65535?this.log("MqttClient :: options.properties.topicAliasMaximum is out of range"):this.topicAliasRecv=new l.default(t.properties.topicAliasMaximum)),this.on("connect",(()=>{const{queue:e}=this,t=()=>{const r=e.shift();this.log("deliver :: entry %o",r);let n=null;if(!r)return void this._resubscribe();n=r.packet,this.log("deliver :: call _sendPacket for %o",n);let i=!0;n.messageId&&0!==n.messageId&&(this.messageIdProvider.register(n.messageId)||(i=!1)),i?this._sendPacket(n,(e=>{r.cb&&r.cb(e),t()})):(this.log("messageId: %d has already used. The message is skipped and removed.",n.messageId),t())};this.log("connect :: sending queued packets"),t()})),this.on("close",(()=>{this.log("close :: connected set to `false`"),this.connected=!1,this.log("close :: clearing connackTimer"),clearTimeout(this.connackTimer),this.log("close :: clearing ping timer"),null!==this.pingTimer&&(this.pingTimer.clear(),this.pingTimer=null),this.topicAliasRecv&&this.topicAliasRecv.clear(),this.log("close :: calling _setupReconnect"),this._setupReconnect()})),this.options.manualConnect||(this.log("MqttClient :: setting up stream"),this.connect())}handleAuth(e,t){t()}handleMessage(e,t){t()}_nextId(){return this.messageIdProvider.allocate()}getLastMessageId(){return this.messageIdProvider.getLastAllocated()}connect(){var e;const t=new h.Writable,r=u.default.parser(this.options);let n=null;const i=[];this.log("connect :: calling method to clear reconnect"),this._clearReconnect(),this.log("connect :: using streamBuilder provided to client to create stream"),this.stream=this.streamBuilder(this),r.on("packet",(e=>{this.log("parser :: on packet push to packets array."),i.push(e)}));const s=()=>{this.log("work :: getting next packet in queue");const e=i.shift();if(e)this.log("work :: packet pulled from queue"),(0,m.default)(this,e,o);else{this.log("work :: no packets in queue");const e=n;n=null,this.log("work :: done flag is %s",!!e),e&&e()}},o=()=>{if(i.length)_(s);else{const e=n;n=null,e()}};t._write=(e,t,i)=>{n=i,this.log("writable stream :: parsing buffer"),r.parse(e),s()};this.log("connect :: pipe stream to writable stream"),this.stream.pipe(t),this.stream.on("error",(e=>{this.log("streamErrorHandler :: error",e.message),S.includes(e.code)?(this.log("streamErrorHandler :: emitting error"),this.emit("error",e)):this.noop(e)})),this.stream.on("close",(()=>{this.log("(%s)stream :: on close",this.options.clientId),this._flushVolatile(),this.log("stream: emit close to MqttClient"),this.emit("close")})),this.log("connect: sending packet `connect`");const a={cmd:"connect",protocolId:this.options.protocolId,protocolVersion:this.options.protocolVersion,clean:this.options.clean,clientId:this.options.clientId,keepalive:this.options.keepalive,username:this.options.username,password:this.options.password,properties:this.options.properties};if(this.options.will&&(a.will=Object.assign(Object.assign({},this.options.will),{payload:null===(e=this.options.will)||void 0===e?void 0:e.payload})),this.topicAliasRecv&&(a.properties||(a.properties={}),this.topicAliasRecv&&(a.properties.topicAliasMaximum=this.topicAliasRecv.max)),this._writePacket(a),r.on("error",this.emit.bind(this,"error")),this.options.properties){if(!this.options.properties.authenticationMethod&&this.options.properties.authenticationData)return this.end((()=>this.emit("error",new Error("Packet has no Authentication Method")))),this;if(this.options.properties.authenticationMethod&&this.options.authPacket&&"object"==typeof this.options.authPacket){const e=Object.assign({cmd:"auth",reasonCode:0},this.options.authPacket);this._writePacket(e)}}return this.stream.setMaxListeners(1e3),clearTimeout(this.connackTimer),this.connackTimer=setTimeout((()=>{this.log("!!connectTimeout hit!! Calling _cleanUp with force `true`"),this._cleanUp(!0)}),this.options.connectTimeout),this}publish(e,t,r,n){this.log("publish :: message `%s` to topic `%s`",t,e);const{options:i}=this;"function"==typeof r&&(n=r,r=null),r=r||{};r=Object.assign(Object.assign({},{qos:0,retain:!1,dup:!1}),r);const{qos:s,retain:o,dup:a,properties:l,cbStorePut:u}=r;if(this._checkDisconnecting(n))return this;const c=()=>{let r=0;if((1===s||2===s)&&(r=this._nextId(),null===r))return this.log("No messageId left"),!1;const c={cmd:"publish",topic:e,payload:t,qos:s,retain:o,messageId:r,dup:a};switch(5===i.protocolVersion&&(c.properties=l),this.log("publish :: qos",s),s){case 1:case 2:this.outgoing[c.messageId]={volatile:!1,cb:n||this.noop},this.log("MqttClient:publish: packet cmd: %s",c.cmd),this._sendPacket(c,void 0,u);break;default:this.log("MqttClient:publish: packet cmd: %s",c.cmd),this._sendPacket(c,n,u)}return!0};return(this._storeProcessing||this._storeProcessingQueue.length>0||!c())&&this._storeProcessingQueue.push({invoke:c,cbStorePut:r.cbStorePut,callback:n}),this}publishAsync(e,t,r){return new Promise(((n,i)=>{this.publish(e,t,r,((e,t)=>{e?i(e):n(t)}))}))}subscribe(e,t,r){const n=this.options.protocolVersion;"function"==typeof t&&(r=t),r=r||this.noop;let i=!1,s=[];"string"==typeof e?s=e=[e]:Array.isArray(e)?s=e:"object"==typeof e&&(i=e.resubscribe,delete e.resubscribe,s=Object.keys(e));const o=p.validateTopics(s);if(null!==o)return w(r,new Error(`Invalid topic ${o}`)),this;if(this._checkDisconnecting(r))return this.log("subscribe: discconecting true"),this;const a={qos:0};5===n&&(a.nl=!1,a.rap=!1,a.rh=0);const l=(t=Object.assign(Object.assign({},a),t)).properties,u=[],c=(e,r)=>{if(r=r||t,!Object.prototype.hasOwnProperty.call(this._resubscribeTopics,e)||this._resubscribeTopics[e].qos<r.qos||i){const t={topic:e,qos:r.qos};5===n&&(t.nl=r.nl,t.rap=r.rap,t.rh=r.rh,t.properties=l),this.log("subscribe: pushing topic `%s` and qos `%s` to subs list",t.topic,t.qos),u.push(t)}};if(Array.isArray(e)?e.forEach((e=>{this.log("subscribe: array topic %s",e),c(e)})):Object.keys(e).forEach((t=>{this.log("subscribe: object topic %s, %o",t,e[t]),c(t,e[t])})),!u.length)return r(null,[]),this;const h=()=>{const e=this._nextId();if(null===e)return this.log("No messageId left"),!1;const t={cmd:"subscribe",subscriptions:u,messageId:e};if(l&&(t.properties=l),this.options.resubscribe){this.log("subscribe :: resubscribe true");const e=[];u.forEach((t=>{if(this.options.reconnectPeriod>0){const r={qos:t.qos};5===n&&(r.nl=t.nl||!1,r.rap=t.rap||!1,r.rh=t.rh||0,r.properties=t.properties),this._resubscribeTopics[t.topic]=r,e.push(t.topic)}})),this.messageIdToTopic[t.messageId]=e}return this.outgoing[t.messageId]={volatile:!0,cb(e,t){if(!e){const{granted:e}=t;for(let t=0;t<e.length;t+=1)u[t].qos=e[t]}r(e,u)}},this.log("subscribe :: call _sendPacket"),this._sendPacket(t),!0};return(this._storeProcessing||this._storeProcessingQueue.length>0||!h())&&this._storeProcessingQueue.push({invoke:h,callback:r}),this}subscribeAsync(e,t){return new Promise(((r,n)=>{this.subscribe(e,t,((e,t)=>{e?n(e):r(t)}))}))}unsubscribe(e,t,r){"string"==typeof e&&(e=[e]),"function"==typeof t&&(r=t),r=r||this.noop;const n=p.validateTopics(e);if(null!==n)return w(r,new Error(`Invalid topic ${n}`)),this;if(this._checkDisconnecting(r))return this;const i=()=>{const n=this._nextId();if(null===n)return this.log("No messageId left"),!1;const i={cmd:"unsubscribe",messageId:n,unsubscriptions:[]};return"string"==typeof e?i.unsubscriptions=[e]:Array.isArray(e)&&(i.unsubscriptions=e),this.options.resubscribe&&i.unsubscriptions.forEach((e=>{delete this._resubscribeTopics[e]})),"object"==typeof t&&t.properties&&(i.properties=t.properties),this.outgoing[i.messageId]={volatile:!0,cb:r},this.log("unsubscribe: call _sendPacket"),this._sendPacket(i),!0};return(this._storeProcessing||this._storeProcessingQueue.length>0||!i())&&this._storeProcessingQueue.push({invoke:i,callback:r}),this}unsubscribeAsync(e,t){return new Promise(((r,n)=>{this.unsubscribe(e,t,((e,t)=>{e?n(e):r(t)}))}))}end(e,t,r){this.log("end :: (%s)",this.options.clientId),null!=e&&"boolean"==typeof e||(r=r||t,t=e,e=!1),"object"!=typeof t&&(r=r||t,t=null),this.log("end :: cb? %s",!!r),r&&"function"==typeof r||(r=this.noop);const n=()=>{this.log("end :: closeStores: closing incoming and outgoing stores"),this.disconnected=!0,this.incomingStore.close((e=>{this.outgoingStore.close((t=>{if(this.log("end :: closeStores: emitting end"),this.emit("end"),r){const n=e||t;this.log("end :: closeStores: invoking callback with args"),r(n)}}))})),this._deferredReconnect&&this._deferredReconnect()},i=()=>{this.log("end :: (%s) :: finish :: calling _cleanUp with force %s",this.options.clientId,e),this._cleanUp(e,(()=>{this.log("end :: finish :: calling process.nextTick on closeStores"),_(n)}),t)};return this.disconnecting?(r(),this):(this._clearReconnect(),this.disconnecting=!0,!e&&Object.keys(this.outgoing).length>0?(this.log("end :: (%s) :: calling finish in 10ms once outgoing is empty",this.options.clientId),this.once("outgoingEmpty",setTimeout.bind(null,i,10))):(this.log("end :: (%s) :: immediately calling finish",this.options.clientId),i()),this)}endAsync(e,t){return new Promise(((r,n)=>{this.end(e,t,(e=>{e?n(e):r()}))}))}removeOutgoingMessage(e){if(this.outgoing[e]){const{cb:t}=this.outgoing[e];this._removeOutgoingAndStoreMessage(e,(()=>{t(new Error("Message removed"))}))}return this}reconnect(e){this.log("client reconnect");const t=()=>{e?(this.options.incomingStore=e.incomingStore,this.options.outgoingStore=e.outgoingStore):(this.options.incomingStore=null,this.options.outgoingStore=null),this.incomingStore=this.options.incomingStore||new g.default,this.outgoingStore=this.options.outgoingStore||new g.default,this.disconnecting=!1,this.disconnected=!1,this._deferredReconnect=null,this._reconnect()};return this.disconnecting&&!this.disconnected?this._deferredReconnect=t:t(),this}_flushVolatile(){this.outgoing&&(this.log("_flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function"),Object.keys(this.outgoing).forEach((e=>{this.outgoing[e].volatile&&"function"==typeof this.outgoing[e].cb&&(this.outgoing[e].cb(new Error("Connection closed")),delete this.outgoing[e])})))}_flush(){this.outgoing&&(this.log("_flush: queue exists? %b",!!this.outgoing),Object.keys(this.outgoing).forEach((e=>{"function"==typeof this.outgoing[e].cb&&(this.outgoing[e].cb(new Error("Connection closed")),delete this.outgoing[e])})))}_removeTopicAliasAndRecoverTopicName(e){let t;e.properties&&(t=e.properties.topicAlias);let r=e.topic.toString();if(this.log("_removeTopicAliasAndRecoverTopicName :: alias %d, topic %o",t,r),0===r.length){if(void 0===t)return new Error("Unregistered Topic Alias");if(r=this.topicAliasSend.getTopicByAlias(t),void 0===r)return new Error("Unregistered Topic Alias");e.topic=r}t&&delete e.properties.topicAlias}_checkDisconnecting(e){return this.disconnecting&&(e&&e!==this.noop?e(new Error("client disconnecting")):this.emit("error",new Error("client disconnecting"))),this.disconnecting}_reconnect(){this.log("_reconnect: emitting reconnect to client"),this.emit("reconnect"),this.connected?(this.end((()=>{this.connect()})),this.log("client already connected. disconnecting first.")):(this.log("_reconnect: calling connect"),this.connect())}_setupReconnect(){!this.disconnecting&&!this.reconnectTimer&&this.options.reconnectPeriod>0?(this.reconnecting||(this.log("_setupReconnect :: emit `offline` state"),this.emit("offline"),this.log("_setupReconnect :: set `reconnecting` to `true`"),this.reconnecting=!0),this.log("_setupReconnect :: setting reconnectTimer for %d ms",this.options.reconnectPeriod),this.reconnectTimer=setInterval((()=>{this.log("reconnectTimer :: reconnect triggered!"),this._reconnect()}),this.options.reconnectPeriod)):this.log("_setupReconnect :: doing nothing...")}_clearReconnect(){this.log("_clearReconnect : clearing reconnect timer"),this.reconnectTimer&&(clearInterval(this.reconnectTimer),this.reconnectTimer=null)}_cleanUp(e,t,r={}){if(t&&(this.log("_cleanUp :: done callback provided for on stream close"),this.stream.on("close",t)),this.log("_cleanUp :: forced? %s",e),e)0===this.options.reconnectPeriod&&this.options.clean&&this._flush(),this.log("_cleanUp :: (%s) :: destroying stream",this.options.clientId),this.stream.destroy();else{const e=Object.assign({cmd:"disconnect"},r);this.log("_cleanUp :: (%s) :: call _sendPacket with disconnect packet",this.options.clientId),this._sendPacket(e,(()=>{this.log("_cleanUp :: (%s) :: destroying stream",this.options.clientId),w((()=>{this.stream.end((()=>{this.log("_cleanUp :: (%s) :: stream destroyed",this.options.clientId)}))}))}))}this.disconnecting||(this.log("_cleanUp :: client not disconnecting. Clearing and resetting reconnect."),this._clearReconnect(),this._setupReconnect()),null!==this.pingTimer&&(this.log("_cleanUp :: clearing pingTimer"),this.pingTimer.clear(),this.pingTimer=null),t&&!this.connected&&(this.log("_cleanUp :: (%s) :: removing stream `done` callback `close` listener",this.options.clientId),this.stream.removeListener("close",t),t())}_storeAndSend(e,t,r){this.log("storeAndSend :: store packet with cmd %s to outgoingStore",e.cmd);let n,i=e;if("publish"===i.cmd&&(i=(0,d.default)(e),n=this._removeTopicAliasAndRecoverTopicName(i),n))return t&&t(n);this.outgoingStore.put(i,(n=>{if(n)return t&&t(n);r(),this._writePacket(e,t)}))}_applyTopicAlias(e){if(5===this.options.protocolVersion&&"publish"===e.cmd){let t;e.properties&&(t=e.properties.topicAlias);const r=e.topic.toString();if(this.topicAliasSend)if(t){if(0!==r.length&&(this.log("applyTopicAlias :: register topic: %s - alias: %d",r,t),!this.topicAliasSend.put(r,t)))return this.log("applyTopicAlias :: error out of range. topic: %s - alias: %d",r,t),new Error("Sending Topic Alias out of range")}else 0!==r.length&&(this.options.autoAssignTopicAlias?(t=this.topicAliasSend.getAliasByTopic(r),t?(e.topic="",e.properties=Object.assign(Object.assign({},e.properties),{topicAlias:t}),this.log("applyTopicAlias :: auto assign(use) topic: %s - alias: %d",r,t)):(t=this.topicAliasSend.getLruAlias(),this.topicAliasSend.put(r,t),e.properties=Object.assign(Object.assign({},e.properties),{topicAlias:t}),this.log("applyTopicAlias :: auto assign topic: %s - alias: %d",r,t))):this.options.autoUseTopicAlias&&(t=this.topicAliasSend.getAliasByTopic(r),t&&(e.topic="",e.properties=Object.assign(Object.assign({},e.properties),{topicAlias:t}),this.log("applyTopicAlias :: auto use topic: %s - alias: %d",r,t))));else if(t)return this.log("applyTopicAlias :: error out of range. topic: %s - alias: %d",r,t),new Error("Sending Topic Alias out of range")}}_noop(e){this.log("noop ::",e)}_writePacket(e,t){this.log("_writePacket :: packet: %O",e),this.log("_writePacket :: emitting `packetsend`"),this.emit("packetsend",e),this._shiftPingInterval(),this.log("_writePacket :: writing to stream");const r=u.default.writeToStream(e,this.stream,this.options);this.log("_writePacket :: writeToStream result %s",r),!r&&t&&t!==this.noop?(this.log("_writePacket :: handle events on `drain` once through callback."),this.stream.once("drain",t)):t&&(this.log("_writePacket :: invoking cb"),t())}_sendPacket(e,t,r,n){this.log("_sendPacket :: (%s) ::  start",this.options.clientId),r=r||this.noop,t=t||this.noop;const i=this._applyTopicAlias(e);if(i)t(i);else{if(!this.connected)return"auth"===e.cmd?void this._writePacket(e,t):(this.log("_sendPacket :: client not connected. Storing packet offline."),void this._storePacket(e,t,r));if(n)this._writePacket(e,t);else{switch(e.cmd){case"publish":break;case"pubrel":return void this._storeAndSend(e,t,r);default:return void this._writePacket(e,t)}switch(e.qos){case 2:case 1:this._storeAndSend(e,t,r);break;default:this._writePacket(e,t)}this.log("_sendPacket :: (%s) ::  end",this.options.clientId)}}}_storePacket(e,t,r){this.log("_storePacket :: packet: %o",e),this.log("_storePacket :: cb? %s",!!t),r=r||this.noop;let n=e;if("publish"===n.cmd){n=(0,d.default)(e);const r=this._removeTopicAliasAndRecoverTopicName(n);if(r)return t&&t(r)}const i=n.qos||0;0===i&&this.queueQoSZero||"publish"!==n.cmd?this.queue.push({packet:n,cb:t}):i>0?(t=this.outgoing[n.messageId]?this.outgoing[n.messageId].cb:null,this.outgoingStore.put(n,(e=>{if(e)return t&&t(e);r()}))):t&&t(new Error("No connection to broker"))}_setupPingTimer(){this.log("_setupPingTimer :: keepalive %d (seconds)",this.options.keepalive),!this.pingTimer&&this.options.keepalive&&(this.pingResp=!0,this.pingTimer=(0,f.default)((()=>{this._checkPing()}),1e3*this.options.keepalive))}_shiftPingInterval(){this.pingTimer&&this.options.keepalive&&this.options.reschedulePings&&this.pingTimer.reschedule(1e3*this.options.keepalive)}_checkPing(){this.log("_checkPing :: checking ping..."),this.pingResp?(this.log("_checkPing :: ping response received. Clearing flag and sending `pingreq`"),this.pingResp=!1,this._sendPacket({cmd:"pingreq"})):(this.log("_checkPing :: calling _cleanUp with force true"),this._cleanUp(!0))}_resubscribe(){this.log("_resubscribe");const e=Object.keys(this._resubscribeTopics);if(!this._firstConnection&&(this.options.clean||this.options.protocolVersion>=4&&!this.connackPacket.sessionPresent)&&e.length>0)if(this.options.resubscribe)if(5===this.options.protocolVersion){this.log("_resubscribe: protocolVersion 5");for(let t=0;t<e.length;t++){const r={};r[e[t]]=this._resubscribeTopics[e[t]],r.resubscribe=!0,this.subscribe(r,{properties:r[e[t]].properties})}}else this._resubscribeTopics.resubscribe=!0,this.subscribe(this._resubscribeTopics);else this._resubscribeTopics={};this._firstConnection=!1}_onConnect(e){if(this.disconnected)return void this.emit("connect",e);this.connackPacket=e,this.messageIdProvider.clear(),this._setupPingTimer(),this.connected=!0;const t=()=>{let r=this.outgoingStore.createStream();const n=()=>{r.destroy(),r=null,this._flushStoreProcessingQueue(),i()},i=()=>{this._storeProcessing=!1,this._packetIdsDuringStoreProcessing={}};this.once("close",n),r.on("error",(e=>{i(),this._flushStoreProcessingQueue(),this.removeListener("close",n),this.emit("error",e)}));const s=()=>{if(!r)return;const e=r.read(1);let t;e?(this._storeProcessing=!0,this._packetIdsDuringStoreProcessing[e.messageId]?s():this.disconnecting||this.reconnectTimer?r.destroy&&r.destroy():(t=this.outgoing[e.messageId]?this.outgoing[e.messageId].cb:null,this.outgoing[e.messageId]={volatile:!1,cb(e,r){t&&t(e,r),s()}},this._packetIdsDuringStoreProcessing[e.messageId]=!0,this.messageIdProvider.register(e.messageId)?this._sendPacket(e,void 0,void 0,!0):this.log("messageId: %d has already used.",e.messageId))):r.once("readable",s)};r.on("end",(()=>{let r=!0;for(const e in this._packetIdsDuringStoreProcessing)if(!this._packetIdsDuringStoreProcessing[e]){r=!1;break}r?(i(),this.removeListener("close",n),this._invokeAllStoreProcessingQueue(),this.emit("connect",e)):t()})),s()};t()}_invokeStoreProcessingQueue(){if(!this._storeProcessing&&this._storeProcessingQueue.length>0){const e=this._storeProcessingQueue[0];if(e&&e.invoke())return this._storeProcessingQueue.shift(),!0}return!1}_invokeAllStoreProcessingQueue(){for(;this._invokeStoreProcessingQueue(););}_flushStoreProcessingQueue(){for(const e of this._storeProcessingQueue)e.cbStorePut&&e.cbStorePut(new Error("Connection closed")),e.callback&&e.callback(new Error("Connection closed"));this._storeProcessingQueue.splice(0)}_removeOutgoingAndStoreMessage(e,t){delete this.outgoing[e],this.outgoingStore.del({messageId:e},((r,n)=>{t(r,n),this.messageIdProvider.deallocate(e),this._invokeStoreProcessingQueue()}))}}r.default=E}).call(this)}).call(this,e("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./TypedEmitter":1,"./default-message-id-provider":9,"./handlers":13,"./store":18,"./topic-alias-recv":19,"./validations":22,_process:102,debug:30,"mqtt-packet":75,"readable-stream":125,reinterval:131,"rfdc/default":132}],3:[function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(r,"__esModule",{value:!0});const i=e("buffer"),s=e("readable-stream"),o=n(e("duplexify"));let a,l,u,c=!1;r.default=(e,t)=>{if(t.hostname=t.hostname||t.host,!t.hostname)throw new Error("Could not determine host. Specify host manually.");const r="MQIsdp"===t.protocolId&&3===t.protocolVersion?"mqttv3.1":"mqtt";!function(e){e.hostname||(e.hostname="localhost"),e.path||(e.path="/"),e.wsOptions||(e.wsOptions={})}(t);const n=function(e,t){const r="alis"===e.protocol?"wss":"ws";let n=`${r}://${e.hostname}${e.path}`;return e.port&&80!==e.port&&443!==e.port&&(n=`${r}://${e.hostname}:${e.port}${e.path}`),"function"==typeof e.transformWsUrl&&(n=e.transformWsUrl(n,e,t)),n}(t,e);return a=t.my,a.connectSocket({url:n,protocols:r}),l=function(){const e=new s.Transform;return e._write=(e,t,r)=>{a.sendSocketMessage({data:e.buffer,success(){r()},fail(){r(new Error)}})},e._flush=e=>{a.closeSocket({success(){e()}})},e}(),u=o.default.obj(),c||(c=!0,a.onSocketOpen((()=>{u.setReadable(l),u.setWritable(l),u.emit("connect")})),a.onSocketMessage((e=>{if("string"==typeof e.data){const t=i.Buffer.from(e.data,"base64");l.push(t)}else{const t=new FileReader;t.addEventListener("load",(()=>{let e=t.result;e=e instanceof ArrayBuffer?i.Buffer.from(e):i.Buffer.from(e,"utf8"),l.push(e)})),t.readAsArrayBuffer(e.data)}})),a.onSocketClose((()=>{u.end(),u.destroy()})),a.onSocketError((e=>{u.destroy(e)}))),u}},{buffer:29,duplexify:32,"readable-stream":125}],4:[function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(r,"__esModule",{value:!0}),r.connectAsync=void 0;const i=n(e("debug")),s=n(e("url")),o=n(e("../client")),a=n(e("../is-browser")),l=(0,i.default)("mqttjs"),u={};function c(e,t){if(l("connecting to an MQTT broker..."),"object"!=typeof e||t||(t=e,e=""),t=t||{},e&&"string"==typeof e){const r=s.default.parse(e,!0);if(null!=r.port&&(r.port=Number(r.port)),null===(t=Object.assign(Object.assign({},r),t)).protocol)throw new Error("Missing protocol");t.protocol=t.protocol.replace(/:$/,"")}if(function(e){let t;e.auth&&(t=e.auth.match(/^(.+):(.+)$/),t?(e.username=t[1],e.password=t[2]):e.username=e.auth)}(t),t.query&&"string"==typeof t.query.clientId&&(t.clientId=t.query.clientId),t.cert&&t.key){if(!t.protocol)throw new Error("Missing secure protocol key");if(-1===["mqtts","wss","wxs","alis"].indexOf(t.protocol))switch(t.protocol){case"mqtt":t.protocol="mqtts";break;case"ws":t.protocol="wss";break;case"wx":t.protocol="wxs";break;case"ali":t.protocol="alis";break;default:throw new Error(`Unknown protocol for secure connection: "${t.protocol}"!`)}}if(!u[t.protocol]){const e=-1!==["mqtts","wss"].indexOf(t.protocol);t.protocol=["mqtt","mqtts","ws","wss","wx","wxs","ali","alis"].filter(((t,r)=>(!e||r%2!=0)&&"function"==typeof u[t]))[0]}if(!1===t.clean&&!t.clientId)throw new Error("Missing clientId for unclean clients");t.protocol&&(t.defaultProtocol=t.protocol);const r=new o.default((function(e){return t.servers&&(e._reconnectCount&&e._reconnectCount!==t.servers.length||(e._reconnectCount=0),t.host=t.servers[e._reconnectCount].host,t.port=t.servers[e._reconnectCount].port,t.protocol=t.servers[e._reconnectCount].protocol?t.servers[e._reconnectCount].protocol:t.defaultProtocol,t.hostname=t.host,e._reconnectCount++),l("calling streambuilder for",t.protocol),u[t.protocol](e,t)}),t);return r.on("error",(()=>{})),r}a.default?(u.wx=e("./wx").default,u.wxs=e("./wx").default,u.ali=e("./ali").default,u.alis=e("./ali").default):(u.mqtt=e("./tcp").default,u.tcp=e("./tcp").default,u.ssl=e("./tls").default,u.tls=u.ssl,u.mqtts=e("./tls").default),u.ws=e("./ws").default,u.wss=e("./ws").default,r.connectAsync=function(e,t,r=!0){return new Promise(((n,i)=>{const s=c(e,t),o={connect:e=>{a(),n(s)},end:()=>{a(),n(s)},error:e=>{a(),s.end(),i(e)}};function a(){Object.keys(o).forEach((e=>{s.off(e,o[e])}))}!1===r&&(o.close=()=>{o.error(new Error("Couldn't connect to server"))}),Object.keys(o).forEach((e=>{s.on(e,o[e])}))}))},r.default=c},{"../client":2,"../is-browser":16,"./ali":3,"./tcp":5,"./tls":6,"./ws":7,"./wx":8,debug:30,url:137}],5:[function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(r,"__esModule",{value:!0});const i=n(e("net")),s=(0,n(e("debug")).default)("mqttjs:tcp");r.default=(e,t)=>{t.port=t.port||1883,t.hostname=t.hostname||t.host||"localhost";const{port:r}=t,n=t.hostname;return s("port %d and host %s",r,n),i.default.createConnection(r,n)}},{debug:30,net:26}],6:[function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(r,"__esModule",{value:!0});const i=n(e("tls")),s=n(e("net")),o=(0,n(e("debug")).default)("mqttjs:tls");r.default=(e,t)=>{t.port=t.port||8883,t.host=t.hostname||t.host||"localhost",0===s.default.isIP(t.host)&&(t.servername=t.host),t.rejectUnauthorized=!1!==t.rejectUnauthorized,delete t.path,o("port %d host %s rejectUnauthorized %b",t.port,t.host,t.rejectUnauthorized);const r=i.default.connect(t);function n(n){t.rejectUnauthorized&&e.emit("error",n),r.end()}return r.on("secureConnect",(()=>{t.rejectUnauthorized&&!r.authorized?r.emit("error",new Error("TLS not authorized")):r.removeListener("error",n)})),r.on("error",n),r}},{debug:30,net:26,tls:26}],7:[function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(r,"__esModule",{value:!0});const i=e("buffer"),s=n(e("ws")),o=n(e("debug")),a=n(e("duplexify")),l=e("readable-stream"),u=n(e("../is-browser")),c=(0,o.default)("mqttjs:ws"),h=["rejectUnauthorized","ca","cert","key","pfx","passphrase"];function f(e,t){let r=`${e.protocol}://${e.hostname}:${e.port}${e.path}`;return"function"==typeof e.transformWsUrl&&(r=e.transformWsUrl(r,e,t)),r}function d(e){const t=e;return e.hostname||(t.hostname="localhost"),e.port||("wss"===e.protocol?t.port=443:t.port=80),e.path||(t.path="/"),e.wsOptions||(t.wsOptions={}),u.default||"wss"!==e.protocol||h.forEach((r=>{Object.prototype.hasOwnProperty.call(e,r)&&!Object.prototype.hasOwnProperty.call(e.wsOptions,r)&&(t.wsOptions[r]=e[r])})),t}r.default=u.default?(e,t)=>{let r;c("browserStreamBuilder");const n=function(e){const t=d(e);if(t.hostname||(t.hostname=t.host),!t.hostname){if("undefined"==typeof document)throw new Error("Could not determine host. Specify host manually.");const e=new URL(document.URL);t.hostname=e.hostname,t.port||(t.port=Number(e.port))}return void 0===t.objectMode&&(t.objectMode=!(!0===t.binary||void 0===t.binary)),t}(t),s=n.browserBufferSize||524288,o=t.browserBufferTimeout||1e3,u=!t.objectMode,h=function(e,t){const r="MQIsdp"===t.protocolId&&3===t.protocolVersion?"mqttv3.1":"mqtt",n=f(t,e);let i;return i=t.createWebsocket?t.createWebsocket(n,[r],t):new WebSocket(n,[r]),i.binaryType="arraybuffer",i}(e,t),p=function(e,t,r){const n=new l.Transform({objectMode:e.objectMode});return n._write=t,n._flush=r,n}(t,(function e(t,r,n){h.bufferedAmount>s&&setTimeout(e,o,t,r,n);u&&"string"==typeof t&&(t=i.Buffer.from(t,"utf8"));try{h.send(t)}catch(e){return n(e)}n()}),(function(e){h.close(),e()}));t.objectMode||(p._writev=w),p.on("close",(()=>{h.close()}));const b=void 0!==h.addEventListener;function g(){r.setReadable(p),r.setWritable(p),r.emit("connect")}function m(){r.end(),r.destroy()}function y(e){r.destroy(e)}function _(e){let{data:t}=e;t=t instanceof ArrayBuffer?i.Buffer.from(t):i.Buffer.from(t,"utf8"),p.push(t)}function w(e,t){const r=new Array(e.length);for(let t=0;t<e.length;t++)"string"==typeof e[t].chunk?r[t]=i.Buffer.from(e[t],"utf8"):r[t]=e[t].chunk;this._write(i.Buffer.concat(r),"binary",t)}return h.readyState===h.OPEN?r=p:(r=(0,a.default)(void 0,void 0,t),t.objectMode||(r._writev=w),b?h.addEventListener("open",g):h.onopen=g),r.socket=h,b?(h.addEventListener("close",m),h.addEventListener("error",y),h.addEventListener("message",_)):(h.onclose=m,h.onerror=y,h.onmessage=_),r}:(e,t)=>{c("streamBuilder");const r=d(t),n=f(r,e),i=function(e,t,r){c("createWebSocket"),c(`protocol: ${r.protocolId} ${r.protocolVersion}`);const n="MQIsdp"===r.protocolId&&3===r.protocolVersion?"mqttv3.1":"mqtt";let i;return c(`creating new Websocket for url: ${t} and protocol: ${n}`),i=r.createWebsocket?r.createWebsocket(t,[n],r):new s.default(t,[n],r.wsOptions),i}(0,n,r),o=s.default.createWebSocketStream(i,r.wsOptions);return o.url=n,i.on("close",(()=>{o.destroy()})),o}},{"../is-browser":16,buffer:29,debug:30,duplexify:32,"readable-stream":125,ws:141}],8:[function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(r,"__esModule",{value:!0});const i=e("buffer"),s=e("readable-stream"),o=n(e("duplexify"));let a,l,u;r.default=(e,t)=>{if(t.hostname=t.hostname||t.host,!t.hostname)throw new Error("Could not determine host. Specify host manually.");const r="MQIsdp"===t.protocolId&&3===t.protocolVersion?"mqttv3.1":"mqtt";!function(e){e.hostname||(e.hostname="localhost"),e.path||(e.path="/"),e.wsOptions||(e.wsOptions={})}(t);const n=function(e,t){const r="wxs"===e.protocol?"wss":"ws";let n=`${r}://${e.hostname}${e.path}`;return e.port&&80!==e.port&&443!==e.port&&(n=`${r}://${e.hostname}:${e.port}${e.path}`),"function"==typeof e.transformWsUrl&&(n=e.transformWsUrl(n,e,t)),n}(t,e);a=wx.connectSocket({url:n,protocols:[r]}),l=function(){const e=new s.Transform;return e._write=(e,t,r)=>{a.send({data:e.buffer,success(){r()},fail(e){r(new Error(e))}})},e._flush=e=>{a.close({success(){e()}})},e}(),u=o.default.obj(),u._destroy=(e,t)=>{a.close({success(){t&&t(e)}})};const c=u.destroy;return u.destroy=()=>{u.destroy=c,setTimeout((()=>{a.close({fail(){u._destroy(new Error)}})}),0)},a.onOpen((()=>{u.setReadable(l),u.setWritable(l),u.emit("connect")})),a.onMessage((e=>{let{data:t}=e;t=t instanceof ArrayBuffer?i.Buffer.from(t):i.Buffer.from(t,"utf8"),l.push(t)})),a.onClose((()=>{u.emit("close"),u.end(),u.destroy()})),a.onError((e=>{u.destroy(new Error(e.errMsg))})),u}},{buffer:29,duplexify:32,"readable-stream":125}],9:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});r.default=class{constructor(){this.nextId=Math.max(1,Math.floor(65535*Math.random()))}allocate(){const e=this.nextId++;return 65536===this.nextId&&(this.nextId=1),e}getLastAllocated(){return 1===this.nextId?65535:this.nextId-1}register(e){return!0}deallocate(e){}clear(){}}},{}],10:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.ReasonCodes=void 0,r.ReasonCodes={0:"",1:"Unacceptable protocol version",2:"Identifier rejected",3:"Server unavailable",4:"Bad username or password",5:"Not authorized",16:"No matching subscribers",17:"No subscription existed",128:"Unspecified error",129:"Malformed Packet",130:"Protocol Error",131:"Implementation specific error",132:"Unsupported Protocol Version",133:"Client Identifier not valid",134:"Bad User Name or Password",135:"Not authorized",136:"Server unavailable",137:"Server busy",138:"Banned",139:"Server shutting down",140:"Bad authentication method",141:"Keep Alive timeout",142:"Session taken over",143:"Topic Filter invalid",144:"Topic Name invalid",145:"Packet identifier in use",146:"Packet Identifier not found",147:"Receive Maximum exceeded",148:"Topic Alias invalid",149:"Packet too large",150:"Message rate too high",151:"Quota exceeded",152:"Administrative action",153:"Payload format invalid",154:"Retain not supported",155:"QoS not supported",156:"Use another server",157:"Server moved",158:"Shared Subscriptions not supported",159:"Connection rate exceeded",160:"Maximum connect time",161:"Subscription Identifiers not supported",162:"Wildcard Subscriptions not supported"};r.default=(e,t)=>{const{messageId:n}=t,i=t.cmd;let s=null;const o=e.outgoing[n]?e.outgoing[n].cb:null;let a;if(o){switch(e.log("_handleAck :: packet type",i),i){case"pubcomp":case"puback":{const i=t.reasonCode;i&&i>0&&16!==i?(a=new Error(`Publish error: ${r.ReasonCodes[i]}`),a.code=i,e._removeOutgoingAndStoreMessage(n,(()=>{o(a,t)}))):e._removeOutgoingAndStoreMessage(n,o);break}case"pubrec":{s={cmd:"pubrel",qos:2,messageId:n};const i=t.reasonCode;i&&i>0&&16!==i?(a=new Error(`Publish error: ${r.ReasonCodes[i]}`),a.code=i,e._removeOutgoingAndStoreMessage(n,(()=>{o(a,t)}))):e._sendPacket(s);break}case"suback":{delete e.outgoing[n],e.messageIdProvider.deallocate(n);const r=t.granted;for(let t=0;t<r.length;t++)if(0!=(128&r[t])){const t=e.messageIdToTopic[n];t&&t.forEach((t=>{delete e._resubscribeTopics[t]}))}delete e.messageIdToTopic[n],e._invokeStoreProcessingQueue(),o(null,t);break}case"unsuback":delete e.outgoing[n],e.messageIdProvider.deallocate(n),e._invokeStoreProcessingQueue(),o(null);break;default:e.emit("error",new Error("unrecognized packet type"))}e.disconnecting&&0===Object.keys(e.outgoing).length&&e.emit("outgoingEmpty")}else e.log("_handleAck :: Server sent an ack in error. Ignoring.")}},{}],11:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});const n=e("../shared"),i=e("./ack");r.default=(e,t)=>{const{options:r}=e,s=r.protocolVersion,o=5===s?t.reasonCode:t.returnCode;if(5===s)e.handleAuth(t,((t,r)=>{if(t)e.emit("error",t);else if(24===o)e.reconnecting=!1,e._sendPacket(r);else{const t=new n.ErrorWithReasonCode(`Connection refused: ${i.ReasonCodes[o]}`,o);e.emit("error",t)}}));else{const t=new n.ErrorWithReasonCode(`Protocol error: Auth packets are only supported in MQTT 5. Your version:${s}`,o);e.emit("error",t)}}},{"../shared":17,"./ack":10}],12:[function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(r,"__esModule",{value:!0});const i=e("./ack"),s=n(e("../topic-alias-send")),o=e("../shared");r.default=(e,t)=>{e.log("_handleConnack");const{options:r}=e,n=5===r.protocolVersion?t.reasonCode:t.returnCode;if(clearTimeout(e.connackTimer),delete e.topicAliasSend,t.properties){if(t.properties.topicAliasMaximum){if(t.properties.topicAliasMaximum>65535)return void e.emit("error",new Error("topicAliasMaximum from broker is out of range"));t.properties.topicAliasMaximum>0&&(e.topicAliasSend=new s.default(t.properties.topicAliasMaximum))}t.properties.serverKeepAlive&&r.keepalive&&(r.keepalive=t.properties.serverKeepAlive,e._shiftPingInterval()),t.properties.maximumPacketSize&&(r.properties||(r.properties={}),r.properties.maximumPacketSize=t.properties.maximumPacketSize)}if(0===n)e.reconnecting=!1,e._onConnect(t);else if(n>0){const t=new o.ErrorWithReasonCode(`Connection refused: ${i.ReasonCodes[n]}`,n);e.emit("error",t)}}},{"../shared":17,"../topic-alias-send":20,"./ack":10}],13:[function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(r,"__esModule",{value:!0});const i=n(e("./publish")),s=n(e("./auth")),o=n(e("./connack")),a=n(e("./ack")),l=n(e("./pubrel"));r.default=(e,t,r)=>{const{options:n}=e;if(5===n.protocolVersion&&n.properties&&n.properties.maximumPacketSize&&n.properties.maximumPacketSize<t.length)return e.emit("error",new Error(`exceeding packets size ${t.cmd}`)),e.end({reasonCode:149,properties:{reasonString:"Maximum packet size was exceeded"}}),e;switch(e.log("_handlePacket :: emitting packetreceive"),e.emit("packetreceive",t),t.cmd){case"publish":(0,i.default)(e,t,r);break;case"puback":case"pubrec":case"pubcomp":case"suback":case"unsuback":(0,a.default)(e,t),r();break;case"pubrel":(0,l.default)(e,t,r);break;case"connack":(0,o.default)(e,t),r();break;case"auth":(0,s.default)(e,t),r();break;case"pingresp":e.pingResp=!0,r();break;case"disconnect":e.emit("disconnect",t),r();break;default:e.log("_handlePacket :: unknown command"),r()}}},{"./ack":10,"./auth":11,"./connack":12,"./publish":14,"./pubrel":15}],14:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});const n=[0,16,128,131,135,144,145,151,153];r.default=(e,t,r)=>{e.log("handlePublish: packet %o",t),r=void 0!==r?r:e.noop;let i=t.topic.toString();const s=t.payload,{qos:o}=t,{messageId:a}=t,{options:l}=e;if(5===e.options.protocolVersion){let r;if(t.properties&&(r=t.properties.topicAlias),void 0!==r)if(0===i.length){if(!(r>0&&r<=65535))return e.log("handlePublish :: topic alias out of range. alias: %d",r),void e.emit("error",new Error("Received Topic Alias is out of range"));{const t=e.topicAliasRecv.getTopicByAlias(r);if(!t)return e.log("handlePublish :: unregistered topic alias. alias: %d",r),void e.emit("error",new Error("Received unregistered Topic Alias"));i=t,e.log("handlePublish :: topic complemented by alias. topic: %s - alias: %d",i,r)}}else{if(!e.topicAliasRecv.put(i,r))return e.log("handlePublish :: topic alias out of range. alias: %d",r),void e.emit("error",new Error("Received Topic Alias is out of range"));e.log("handlePublish :: registered topic: %s - alias: %d",i,r)}}switch(e.log("handlePublish: qos %d",o),o){case 2:l.customHandleAcks(i,s,t,((i,s)=>("number"==typeof i&&(s=i,i=null),i?e.emit("error",i):-1===n.indexOf(s)?e.emit("error",new Error("Wrong reason code for pubrec")):void(s?e._sendPacket({cmd:"pubrec",messageId:a,reasonCode:s},r):e.incomingStore.put(t,(()=>{e._sendPacket({cmd:"pubrec",messageId:a},r)}))))));break;case 1:l.customHandleAcks(i,s,t,((o,l)=>("number"==typeof o&&(l=o,o=null),o?e.emit("error",o):-1===n.indexOf(l)?e.emit("error",new Error("Wrong reason code for puback")):(l||e.emit("message",i,s,t),void e.handleMessage(t,(t=>{if(t)return r&&r(t);e._sendPacket({cmd:"puback",messageId:a,reasonCode:l},r)}))))));break;case 0:e.emit("message",i,s,t),e.handleMessage(t,r);break;default:e.log("handlePublish: unknown QoS. Doing nothing.")}}},{}],15:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});r.default=(e,t,r)=>{e.log("handling pubrel packet");const n=void 0!==r?r:e.noop,{messageId:i}=t,s={cmd:"pubcomp",messageId:i};e.incomingStore.get(t,((t,r)=>{t?e._sendPacket(s,n):(e.emit("message",r.topic,r.payload,r),e.handleMessage(r,(t=>{if(t)return n(t);e.incomingStore.del(r,e.noop),e._sendPacket(s,n)})))}))}},{}],16:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});const n="undefined"!=typeof window&&void 0!==window.document||"object"==typeof self&&self.constructor&&"DedicatedWorkerGlobalScope"===self.constructor.name||"undefined"!=typeof navigator&&"ReactNative"===navigator.product;r.default=n},{}],17:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.applyMixin=r.ErrorWithReasonCode=void 0;class n extends Error{constructor(e,t){super(e),this.code=t,Object.setPrototypeOf(this,n.prototype),Object.getPrototypeOf(this).name="ErrorWithReasonCode"}}r.ErrorWithReasonCode=n,r.applyMixin=function(e,t,r=!1){var n;const i=[t];for(;;){const e=i[0],t=Object.getPrototypeOf(e);if(!(null==t?void 0:t.prototype))break;i.unshift(t)}for(const t of i)for(const i of Object.getOwnPropertyNames(t.prototype))(r||"constructor"!==i)&&Object.defineProperty(e.prototype,i,null!==(n=Object.getOwnPropertyDescriptor(t.prototype,i))&&void 0!==n?n:Object.create(null))}},{}],18:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});const n=e("readable-stream"),i={objectMode:!0},s={clean:!0};r.default=class{constructor(e){this.options=e||{},this.options=Object.assign(Object.assign({},s),e),this._inflights=new Map}put(e,t){return this._inflights.set(e.messageId,e),t&&t(),this}createStream(){const e=new n.Readable(i),t=[];let r=!1,s=0;return this._inflights.forEach(((e,r)=>{t.push(e)})),e._read=()=>{!r&&s<t.length?e.push(t[s++]):e.push(null)},e.destroy=t=>{if(!r)return r=!0,setTimeout((()=>{e.emit("close")}),0),e},e}del(e,t){const r=this._inflights.get(e.messageId);return r?(this._inflights.delete(e.messageId),t(null,r)):t&&t(new Error("missing packet")),this}get(e,t){const r=this._inflights.get(e.messageId);return r?t(null,r):t&&t(new Error("missing packet")),this}close(e){this.options.clean&&(this._inflights=null),e&&e()}}},{"readable-stream":125}],19:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});r.default=class{constructor(e){this.aliasToTopic={},this.max=e}put(e,t){return!(0===t||t>this.max)&&(this.aliasToTopic[t]=e,this.length=Object.keys(this.aliasToTopic).length,!0)}getTopicByAlias(e){return this.aliasToTopic[e]}clear(){this.aliasToTopic={}}}},{}],20:[function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(r,"__esModule",{value:!0});const i=n(e("lru-cache")),s=e("number-allocator");r.default=class{constructor(e){e>0&&(this.aliasToTopic=new i.default({max:e}),this.topicToAlias={},this.numberAllocator=new s.NumberAllocator(1,e),this.max=e,this.length=0)}put(e,t){if(0===t||t>this.max)return!1;const r=this.aliasToTopic.get(t);return r&&delete this.topicToAlias[r],this.aliasToTopic.set(t,e),this.topicToAlias[e]=t,this.numberAllocator.use(t),this.length=this.aliasToTopic.size,!0}getTopicByAlias(e){return this.aliasToTopic.get(e)}getAliasByTopic(e){const t=this.topicToAlias[e];return void 0!==t&&this.aliasToTopic.get(t),t}clear(){this.aliasToTopic.clear(),this.topicToAlias={},this.numberAllocator.clear(),this.length=0}getLruAlias(){const e=this.numberAllocator.firstVacant();return e||[...this.aliasToTopic.keys()][this.aliasToTopic.size-1]}}},{"lru-cache":72,"number-allocator":98}],21:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});const n=e("number-allocator");r.default=class{constructor(){this.numberAllocator=new n.NumberAllocator(1,65535)}allocate(){return this.lastId=this.numberAllocator.alloc(),this.lastId}getLastAllocated(){return this.lastId}register(e){return this.numberAllocator.use(e)}deallocate(e){this.numberAllocator.free(e)}clear(){this.numberAllocator.clear()}}},{"number-allocator":98}],22:[function(e,t,r){"use strict";function n(e){const t=e.split("/");for(let e=0;e<t.length;e++)if("+"!==t[e]){if("#"===t[e])return e===t.length-1;if(-1!==t[e].indexOf("+")||-1!==t[e].indexOf("#"))return!1}return!0}Object.defineProperty(r,"__esModule",{value:!0}),r.validateTopics=r.validateTopic=void 0,r.validateTopic=n,r.validateTopics=function(e){if(0===e.length)return"empty_topic_list";for(let t=0;t<e.length;t++)if(!n(e[t]))return e[t];return null}},{}],23:[function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),s=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&n(t,e,r);return i(t,e),t},o=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)},a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(r,"__esModule",{value:!0}),r.ReasonCodes=r.UniqueMessageIdProvider=r.DefaultMessageIdProvider=r.Store=r.MqttClient=r.connectAsync=r.connect=r.Client=void 0;const l=a(e("./lib/client"));r.MqttClient=l.default;const u=a(e("./lib/default-message-id-provider"));r.DefaultMessageIdProvider=u.default;const c=a(e("./lib/unique-message-id-provider"));r.UniqueMessageIdProvider=c.default;const h=a(e("./lib/store"));r.Store=h.default;const f=s(e("./lib/connect"));r.connect=f.default,Object.defineProperty(r,"connectAsync",{enumerable:!0,get:function(){return f.connectAsync}}),r.Client=l.default,o(e("./lib/client"),r),o(e("./lib/shared"),r);var d=e("./lib/handlers/ack");Object.defineProperty(r,"ReasonCodes",{enumerable:!0,get:function(){return d.ReasonCodes}})},{"./lib/client":2,"./lib/connect":4,"./lib/default-message-id-provider":9,"./lib/handlers/ack":10,"./lib/shared":17,"./lib/store":18,"./lib/unique-message-id-provider":21}],24:[function(e,t,r){"use strict";const{AbortController:n,AbortSignal:i}="undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0;t.exports=n,t.exports.AbortSignal=i,t.exports.default=n},{}],25:[function(e,t,r){"use strict";r.byteLength=function(e){var t=l(e),r=t[0],n=t[1];return 3*(r+n)/4-n},r.toByteArray=function(e){var t,r,n=l(e),o=n[0],a=n[1],u=new s(function(e,t,r){return 3*(t+r)/4-r}(0,o,a)),c=0,h=a>0?o-4:o;for(r=0;r<h;r+=4)t=i[e.charCodeAt(r)]<<18|i[e.charCodeAt(r+1)]<<12|i[e.charCodeAt(r+2)]<<6|i[e.charCodeAt(r+3)],u[c++]=t>>16&255,u[c++]=t>>8&255,u[c++]=255&t;2===a&&(t=i[e.charCodeAt(r)]<<2|i[e.charCodeAt(r+1)]>>4,u[c++]=255&t);1===a&&(t=i[e.charCodeAt(r)]<<10|i[e.charCodeAt(r+1)]<<4|i[e.charCodeAt(r+2)]>>2,u[c++]=t>>8&255,u[c++]=255&t);return u},r.fromByteArray=function(e){for(var t,r=e.length,i=r%3,s=[],o=16383,a=0,l=r-i;a<l;a+=o)s.push(u(e,a,a+o>l?l:a+o));1===i?(t=e[r-1],s.push(n[t>>2]+n[t<<4&63]+"==")):2===i&&(t=(e[r-2]<<8)+e[r-1],s.push(n[t>>10]+n[t>>4&63]+n[t<<2&63]+"="));return s.join("")};for(var n=[],i=[],s="undefined"!=typeof Uint8Array?Uint8Array:Array,o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=0;a<64;++a)n[a]=o[a],i[o.charCodeAt(a)]=a;function l(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=e.indexOf("=");return-1===r&&(r=t),[r,r===t?0:4-r%4]}function u(e,t,r){for(var i,s,o=[],a=t;a<r;a+=3)i=(e[a]<<16&16711680)+(e[a+1]<<8&65280)+(255&e[a+2]),o.push(n[(s=i)>>18&63]+n[s>>12&63]+n[s>>6&63]+n[63&s]);return o.join("")}i["-".charCodeAt(0)]=62,i["_".charCodeAt(0)]=63},{}],26:[function(e,t,r){},{}],27:[function(e,t,r){var n=e("buffer"),i=n.Buffer;function s(e,t){for(var r in e)t[r]=e[r]}function o(e,t,r){return i(e,t,r)}i.from&&i.alloc&&i.allocUnsafe&&i.allocUnsafeSlow?t.exports=n:(s(n,r),r.Buffer=o),s(i,o),o.from=function(e,t,r){if("number"==typeof e)throw new TypeError("Argument must not be a number");return i(e,t,r)},o.alloc=function(e,t,r){if("number"!=typeof e)throw new TypeError("Argument must be a number");var n=i(e);return void 0!==t?"string"==typeof r?n.fill(t,r):n.fill(t):n.fill(0),n},o.allocUnsafe=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return i(e)},o.allocUnsafeSlow=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return n.SlowBuffer(e)}},{buffer:29}],28:[function(e,t,r){"use strict";var n=e("safe-buffer").Buffer,i=n.isEncoding||function(e){switch((e=""+e)&&e.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}};function s(e){var t;switch(this.encoding=function(e){var t=function(e){if(!e)return"utf8";for(var t;;)switch(e){case"utf8":case"utf-8":return"utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return"utf16le";case"latin1":case"binary":return"latin1";case"base64":case"ascii":case"hex":return e;default:if(t)return;e=(""+e).toLowerCase(),t=!0}}(e);if("string"!=typeof t&&(n.isEncoding===i||!i(e)))throw new Error("Unknown encoding: "+e);return t||e}(e),this.encoding){case"utf16le":this.text=l,this.end=u,t=4;break;case"utf8":this.fillLast=a,t=4;break;case"base64":this.text=c,this.end=h,t=3;break;default:return this.write=f,void(this.end=d)}this.lastNeed=0,this.lastTotal=0,this.lastChar=n.allocUnsafe(t)}function o(e){return e<=127?0:e>>5==6?2:e>>4==14?3:e>>3==30?4:e>>6==2?-1:-2}function a(e){var t=this.lastTotal-this.lastNeed,r=function(e,t,r){if(128!=(192&t[0]))return e.lastNeed=0,"";if(e.lastNeed>1&&t.length>1){if(128!=(192&t[1]))return e.lastNeed=1,"";if(e.lastNeed>2&&t.length>2&&128!=(192&t[2]))return e.lastNeed=2,""}}(this,e);return void 0!==r?r:this.lastNeed<=e.length?(e.copy(this.lastChar,t,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(e.copy(this.lastChar,t,0,e.length),void(this.lastNeed-=e.length))}function l(e,t){if((e.length-t)%2==0){var r=e.toString("utf16le",t);if(r){var n=r.charCodeAt(r.length-1);if(n>=55296&&n<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1],r.slice(0,-1)}return r}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=e[e.length-1],e.toString("utf16le",t,e.length-1)}function u(e){var t=e&&e.length?this.write(e):"";if(this.lastNeed){var r=this.lastTotal-this.lastNeed;return t+this.lastChar.toString("utf16le",0,r)}return t}function c(e,t){var r=(e.length-t)%3;return 0===r?e.toString("base64",t):(this.lastNeed=3-r,this.lastTotal=3,1===r?this.lastChar[0]=e[e.length-1]:(this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1]),e.toString("base64",t,e.length-r))}function h(e){var t=e&&e.length?this.write(e):"";return this.lastNeed?t+this.lastChar.toString("base64",0,3-this.lastNeed):t}function f(e){return e.toString(this.encoding)}function d(e){return e&&e.length?this.write(e):""}r.StringDecoder=s,s.prototype.write=function(e){if(0===e.length)return"";var t,r;if(this.lastNeed){if(void 0===(t=this.fillLast(e)))return"";r=this.lastNeed,this.lastNeed=0}else r=0;return r<e.length?t?t+this.text(e,r):this.text(e,r):t||""},s.prototype.end=function(e){var t=e&&e.length?this.write(e):"";return this.lastNeed?t+"":t},s.prototype.text=function(e,t){var r=function(e,t,r){var n=t.length-1;if(n<r)return 0;var i=o(t[n]);if(i>=0)return i>0&&(e.lastNeed=i-1),i;if(--n<r||-2===i)return 0;if(i=o(t[n]),i>=0)return i>0&&(e.lastNeed=i-2),i;if(--n<r||-2===i)return 0;if(i=o(t[n]),i>=0)return i>0&&(2===i?i=0:e.lastNeed=i-3),i;return 0}(this,e,t);if(!this.lastNeed)return e.toString("utf8",t);this.lastTotal=r;var n=e.length-(r-this.lastNeed);return e.copy(this.lastChar,0,n),e.toString("utf8",t,n)},s.prototype.fillLast=function(e){if(this.lastNeed<=e.length)return e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,e.length),this.lastNeed-=e.length}},{"safe-buffer":27}],29:[function(e,t,r){(function(t){(function(){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
"use strict";var t=e("base64-js"),n=e("ieee754");r.Buffer=o,r.SlowBuffer=function(e){+e!=e&&(e=0);return o.alloc(+e)},r.INSPECT_MAX_BYTES=50;var i=2147483647;function s(e){if(e>i)throw new RangeError('The value "'+e+'" is invalid for option "size"');var t=new Uint8Array(e);return t.__proto__=o.prototype,t}function o(e,t,r){if("number"==typeof e){if("string"==typeof t)throw new TypeError('The "string" argument must be of type string. Received type number');return u(e)}return a(e,t,r)}function a(e,t,r){if("string"==typeof e)return function(e,t){"string"==typeof t&&""!==t||(t="utf8");if(!o.isEncoding(t))throw new TypeError("Unknown encoding: "+t);var r=0|f(e,t),n=s(r),i=n.write(e,t);i!==r&&(n=n.slice(0,i));return n}(e,t);if(ArrayBuffer.isView(e))return c(e);if(null==e)throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);if(F(e,ArrayBuffer)||e&&F(e.buffer,ArrayBuffer))return function(e,t,r){if(t<0||e.byteLength<t)throw new RangeError('"offset" is outside of buffer bounds');if(e.byteLength<t+(r||0))throw new RangeError('"length" is outside of buffer bounds');var n;n=void 0===t&&void 0===r?new Uint8Array(e):void 0===r?new Uint8Array(e,t):new Uint8Array(e,t,r);return n.__proto__=o.prototype,n}(e,t,r);if("number"==typeof e)throw new TypeError('The "value" argument must not be of type number. Received type number');var n=e.valueOf&&e.valueOf();if(null!=n&&n!==e)return o.from(n,t,r);var i=function(e){if(o.isBuffer(e)){var t=0|h(e.length),r=s(t);return 0===r.length||e.copy(r,0,0,t),r}if(void 0!==e.length)return"number"!=typeof e.length||W(e.length)?s(0):c(e);if("Buffer"===e.type&&Array.isArray(e.data))return c(e.data)}(e);if(i)return i;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof e[Symbol.toPrimitive])return o.from(e[Symbol.toPrimitive]("string"),t,r);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}function l(e){if("number"!=typeof e)throw new TypeError('"size" argument must be of type number');if(e<0)throw new RangeError('The value "'+e+'" is invalid for option "size"')}function u(e){return l(e),s(e<0?0:0|h(e))}function c(e){for(var t=e.length<0?0:0|h(e.length),r=s(t),n=0;n<t;n+=1)r[n]=255&e[n];return r}function h(e){if(e>=i)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+i.toString(16)+" bytes");return 0|e}function f(e,t){if(o.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||F(e,ArrayBuffer))return e.byteLength;if("string"!=typeof e)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);var r=e.length,n=arguments.length>2&&!0===arguments[2];if(!n&&0===r)return 0;for(var i=!1;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":return N(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return U(e).length;default:if(i)return n?-1:N(e).length;t=(""+t).toLowerCase(),i=!0}}function d(e,t,r){var n=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if((r>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return R(this,t,r);case"utf8":case"utf-8":return A(this,t,r);case"ascii":return T(this,t,r);case"latin1":case"binary":return I(this,t,r);case"base64":return E(this,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return O(this,t,r);default:if(n)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),n=!0}}function p(e,t,r){var n=e[t];e[t]=e[r],e[r]=n}function b(e,t,r,n,i){if(0===e.length)return-1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),W(r=+r)&&(r=i?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(i)return-1;r=e.length-1}else if(r<0){if(!i)return-1;r=0}if("string"==typeof t&&(t=o.from(t,n)),o.isBuffer(t))return 0===t.length?-1:g(e,t,r,n,i);if("number"==typeof t)return t&=255,"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):g(e,[t],r,n,i);throw new TypeError("val must be string, number or Buffer")}function g(e,t,r,n,i){var s,o=1,a=e.length,l=t.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(e.length<2||t.length<2)return-1;o=2,a/=2,l/=2,r/=2}function u(e,t){return 1===o?e[t]:e.readUInt16BE(t*o)}if(i){var c=-1;for(s=r;s<a;s++)if(u(e,s)===u(t,-1===c?0:s-c)){if(-1===c&&(c=s),s-c+1===l)return c*o}else-1!==c&&(s-=s-c),c=-1}else for(r+l>a&&(r=a-l),s=r;s>=0;s--){for(var h=!0,f=0;f<l;f++)if(u(e,s+f)!==u(t,f)){h=!1;break}if(h)return s}return-1}function m(e,t,r,n){r=Number(r)||0;var i=e.length-r;n?(n=Number(n))>i&&(n=i):n=i;var s=t.length;n>s/2&&(n=s/2);for(var o=0;o<n;++o){var a=parseInt(t.substr(2*o,2),16);if(W(a))return o;e[r+o]=a}return o}function y(e,t,r,n){return D(N(t,e.length-r),e,r,n)}function _(e,t,r,n){return D(function(e){for(var t=[],r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}(t),e,r,n)}function w(e,t,r,n){return _(e,t,r,n)}function v(e,t,r,n){return D(U(t),e,r,n)}function S(e,t,r,n){return D(function(e,t){for(var r,n,i,s=[],o=0;o<e.length&&!((t-=2)<0);++o)n=(r=e.charCodeAt(o))>>8,i=r%256,s.push(i),s.push(n);return s}(t,e.length-r),e,r,n)}function E(e,r,n){return 0===r&&n===e.length?t.fromByteArray(e):t.fromByteArray(e.slice(r,n))}function A(e,t,r){r=Math.min(e.length,r);for(var n=[],i=t;i<r;){var s,o,a,l,u=e[i],c=null,h=u>239?4:u>223?3:u>191?2:1;if(i+h<=r)switch(h){case 1:u<128&&(c=u);break;case 2:128==(192&(s=e[i+1]))&&(l=(31&u)<<6|63&s)>127&&(c=l);break;case 3:s=e[i+1],o=e[i+2],128==(192&s)&&128==(192&o)&&(l=(15&u)<<12|(63&s)<<6|63&o)>2047&&(l<55296||l>57343)&&(c=l);break;case 4:s=e[i+1],o=e[i+2],a=e[i+3],128==(192&s)&&128==(192&o)&&128==(192&a)&&(l=(15&u)<<18|(63&s)<<12|(63&o)<<6|63&a)>65535&&l<1114112&&(c=l)}null===c?(c=65533,h=1):c>65535&&(c-=65536,n.push(c>>>10&1023|55296),c=56320|1023&c),n.push(c),i+=h}return function(e){var t=e.length;if(t<=k)return String.fromCharCode.apply(String,e);var r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=k));return r}(n)}r.kMaxLength=i,o.TYPED_ARRAY_SUPPORT=function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()}catch(e){return!1}}(),o.TYPED_ARRAY_SUPPORT||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(o.prototype,"parent",{enumerable:!0,get:function(){if(o.isBuffer(this))return this.buffer}}),Object.defineProperty(o.prototype,"offset",{enumerable:!0,get:function(){if(o.isBuffer(this))return this.byteOffset}}),"undefined"!=typeof Symbol&&null!=Symbol.species&&o[Symbol.species]===o&&Object.defineProperty(o,Symbol.species,{value:null,configurable:!0,enumerable:!1,writable:!1}),o.poolSize=8192,o.from=function(e,t,r){return a(e,t,r)},o.prototype.__proto__=Uint8Array.prototype,o.__proto__=Uint8Array,o.alloc=function(e,t,r){return function(e,t,r){return l(e),e<=0?s(e):void 0!==t?"string"==typeof r?s(e).fill(t,r):s(e).fill(t):s(e)}(e,t,r)},o.allocUnsafe=function(e){return u(e)},o.allocUnsafeSlow=function(e){return u(e)},o.isBuffer=function(e){return null!=e&&!0===e._isBuffer&&e!==o.prototype},o.compare=function(e,t){if(F(e,Uint8Array)&&(e=o.from(e,e.offset,e.byteLength)),F(t,Uint8Array)&&(t=o.from(t,t.offset,t.byteLength)),!o.isBuffer(e)||!o.isBuffer(t))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===t)return 0;for(var r=e.length,n=t.length,i=0,s=Math.min(r,n);i<s;++i)if(e[i]!==t[i]){r=e[i],n=t[i];break}return r<n?-1:n<r?1:0},o.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},o.concat=function(e,t){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return o.alloc(0);var r;if(void 0===t)for(t=0,r=0;r<e.length;++r)t+=e[r].length;var n=o.allocUnsafe(t),i=0;for(r=0;r<e.length;++r){var s=e[r];if(F(s,Uint8Array)&&(s=o.from(s)),!o.isBuffer(s))throw new TypeError('"list" argument must be an Array of Buffers');s.copy(n,i),i+=s.length}return n},o.byteLength=f,o.prototype._isBuffer=!0,o.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)p(this,t,t+1);return this},o.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)p(this,t,t+3),p(this,t+1,t+2);return this},o.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)p(this,t,t+7),p(this,t+1,t+6),p(this,t+2,t+5),p(this,t+3,t+4);return this},o.prototype.toString=function(){var e=this.length;return 0===e?"":0===arguments.length?A(this,0,e):d.apply(this,arguments)},o.prototype.toLocaleString=o.prototype.toString,o.prototype.equals=function(e){if(!o.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===o.compare(this,e)},o.prototype.inspect=function(){var e="",t=r.INSPECT_MAX_BYTES;return e=this.toString("hex",0,t).replace(/(.{2})/g,"$1 ").trim(),this.length>t&&(e+=" ... "),"<Buffer "+e+">"},o.prototype.compare=function(e,t,r,n,i){if(F(e,Uint8Array)&&(e=o.from(e,e.offset,e.byteLength)),!o.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===n&&(n=0),void 0===i&&(i=this.length),t<0||r>e.length||n<0||i>this.length)throw new RangeError("out of range index");if(n>=i&&t>=r)return 0;if(n>=i)return-1;if(t>=r)return 1;if(this===e)return 0;for(var s=(i>>>=0)-(n>>>=0),a=(r>>>=0)-(t>>>=0),l=Math.min(s,a),u=this.slice(n,i),c=e.slice(t,r),h=0;h<l;++h)if(u[h]!==c[h]){s=u[h],a=c[h];break}return s<a?-1:a<s?1:0},o.prototype.includes=function(e,t,r){return-1!==this.indexOf(e,t,r)},o.prototype.indexOf=function(e,t,r){return b(this,e,t,r,!0)},o.prototype.lastIndexOf=function(e,t,r){return b(this,e,t,r,!1)},o.prototype.write=function(e,t,r,n){if(void 0===t)n="utf8",r=this.length,t=0;else if(void 0===r&&"string"==typeof t)n=t,r=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t>>>=0,isFinite(r)?(r>>>=0,void 0===n&&(n="utf8")):(n=r,r=void 0)}var i=this.length-t;if((void 0===r||r>i)&&(r=i),e.length>0&&(r<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");for(var s=!1;;)switch(n){case"hex":return m(this,e,t,r);case"utf8":case"utf-8":return y(this,e,t,r);case"ascii":return _(this,e,t,r);case"latin1":case"binary":return w(this,e,t,r);case"base64":return v(this,e,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return S(this,e,t,r);default:if(s)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),s=!0}},o.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var k=4096;function T(e,t,r){var n="";r=Math.min(e.length,r);for(var i=t;i<r;++i)n+=String.fromCharCode(127&e[i]);return n}function I(e,t,r){var n="";r=Math.min(e.length,r);for(var i=t;i<r;++i)n+=String.fromCharCode(e[i]);return n}function R(e,t,r){var n=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>n)&&(r=n);for(var i="",s=t;s<r;++s)i+=j(e[s]);return i}function O(e,t,r){for(var n=e.slice(t,r),i="",s=0;s<n.length;s+=2)i+=String.fromCharCode(n[s]+256*n[s+1]);return i}function C(e,t,r){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>r)throw new RangeError("Trying to access beyond buffer length")}function P(e,t,r,n,i,s){if(!o.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>i||t<s)throw new RangeError('"value" argument is out of bounds');if(r+n>e.length)throw new RangeError("Index out of range")}function x(e,t,r,n,i,s){if(r+n>e.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function M(e,t,r,i,s){return t=+t,r>>>=0,s||x(e,0,r,4),n.write(e,t,r,i,23,4),r+4}function B(e,t,r,i,s){return t=+t,r>>>=0,s||x(e,0,r,8),n.write(e,t,r,i,52,8),r+8}o.prototype.slice=function(e,t){var r=this.length;(e=~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),(t=void 0===t?r:~~t)<0?(t+=r)<0&&(t=0):t>r&&(t=r),t<e&&(t=e);var n=this.subarray(e,t);return n.__proto__=o.prototype,n},o.prototype.readUIntLE=function(e,t,r){e>>>=0,t>>>=0,r||C(e,t,this.length);for(var n=this[e],i=1,s=0;++s<t&&(i*=256);)n+=this[e+s]*i;return n},o.prototype.readUIntBE=function(e,t,r){e>>>=0,t>>>=0,r||C(e,t,this.length);for(var n=this[e+--t],i=1;t>0&&(i*=256);)n+=this[e+--t]*i;return n},o.prototype.readUInt8=function(e,t){return e>>>=0,t||C(e,1,this.length),this[e]},o.prototype.readUInt16LE=function(e,t){return e>>>=0,t||C(e,2,this.length),this[e]|this[e+1]<<8},o.prototype.readUInt16BE=function(e,t){return e>>>=0,t||C(e,2,this.length),this[e]<<8|this[e+1]},o.prototype.readUInt32LE=function(e,t){return e>>>=0,t||C(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},o.prototype.readUInt32BE=function(e,t){return e>>>=0,t||C(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},o.prototype.readIntLE=function(e,t,r){e>>>=0,t>>>=0,r||C(e,t,this.length);for(var n=this[e],i=1,s=0;++s<t&&(i*=256);)n+=this[e+s]*i;return n>=(i*=128)&&(n-=Math.pow(2,8*t)),n},o.prototype.readIntBE=function(e,t,r){e>>>=0,t>>>=0,r||C(e,t,this.length);for(var n=t,i=1,s=this[e+--n];n>0&&(i*=256);)s+=this[e+--n]*i;return s>=(i*=128)&&(s-=Math.pow(2,8*t)),s},o.prototype.readInt8=function(e,t){return e>>>=0,t||C(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},o.prototype.readInt16LE=function(e,t){e>>>=0,t||C(e,2,this.length);var r=this[e]|this[e+1]<<8;return 32768&r?4294901760|r:r},o.prototype.readInt16BE=function(e,t){e>>>=0,t||C(e,2,this.length);var r=this[e+1]|this[e]<<8;return 32768&r?4294901760|r:r},o.prototype.readInt32LE=function(e,t){return e>>>=0,t||C(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},o.prototype.readInt32BE=function(e,t){return e>>>=0,t||C(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},o.prototype.readFloatLE=function(e,t){return e>>>=0,t||C(e,4,this.length),n.read(this,e,!0,23,4)},o.prototype.readFloatBE=function(e,t){return e>>>=0,t||C(e,4,this.length),n.read(this,e,!1,23,4)},o.prototype.readDoubleLE=function(e,t){return e>>>=0,t||C(e,8,this.length),n.read(this,e,!0,52,8)},o.prototype.readDoubleBE=function(e,t){return e>>>=0,t||C(e,8,this.length),n.read(this,e,!1,52,8)},o.prototype.writeUIntLE=function(e,t,r,n){(e=+e,t>>>=0,r>>>=0,n)||P(this,e,t,r,Math.pow(2,8*r)-1,0);var i=1,s=0;for(this[t]=255&e;++s<r&&(i*=256);)this[t+s]=e/i&255;return t+r},o.prototype.writeUIntBE=function(e,t,r,n){(e=+e,t>>>=0,r>>>=0,n)||P(this,e,t,r,Math.pow(2,8*r)-1,0);var i=r-1,s=1;for(this[t+i]=255&e;--i>=0&&(s*=256);)this[t+i]=e/s&255;return t+r},o.prototype.writeUInt8=function(e,t,r){return e=+e,t>>>=0,r||P(this,e,t,1,255,0),this[t]=255&e,t+1},o.prototype.writeUInt16LE=function(e,t,r){return e=+e,t>>>=0,r||P(this,e,t,2,65535,0),this[t]=255&e,this[t+1]=e>>>8,t+2},o.prototype.writeUInt16BE=function(e,t,r){return e=+e,t>>>=0,r||P(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=255&e,t+2},o.prototype.writeUInt32LE=function(e,t,r){return e=+e,t>>>=0,r||P(this,e,t,4,4294967295,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e,t+4},o.prototype.writeUInt32BE=function(e,t,r){return e=+e,t>>>=0,r||P(this,e,t,4,4294967295,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},o.prototype.writeIntLE=function(e,t,r,n){if(e=+e,t>>>=0,!n){var i=Math.pow(2,8*r-1);P(this,e,t,r,i-1,-i)}var s=0,o=1,a=0;for(this[t]=255&e;++s<r&&(o*=256);)e<0&&0===a&&0!==this[t+s-1]&&(a=1),this[t+s]=(e/o>>0)-a&255;return t+r},o.prototype.writeIntBE=function(e,t,r,n){if(e=+e,t>>>=0,!n){var i=Math.pow(2,8*r-1);P(this,e,t,r,i-1,-i)}var s=r-1,o=1,a=0;for(this[t+s]=255&e;--s>=0&&(o*=256);)e<0&&0===a&&0!==this[t+s+1]&&(a=1),this[t+s]=(e/o>>0)-a&255;return t+r},o.prototype.writeInt8=function(e,t,r){return e=+e,t>>>=0,r||P(this,e,t,1,127,-128),e<0&&(e=255+e+1),this[t]=255&e,t+1},o.prototype.writeInt16LE=function(e,t,r){return e=+e,t>>>=0,r||P(this,e,t,2,32767,-32768),this[t]=255&e,this[t+1]=e>>>8,t+2},o.prototype.writeInt16BE=function(e,t,r){return e=+e,t>>>=0,r||P(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=255&e,t+2},o.prototype.writeInt32LE=function(e,t,r){return e=+e,t>>>=0,r||P(this,e,t,4,2147483647,-2147483648),this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4},o.prototype.writeInt32BE=function(e,t,r){return e=+e,t>>>=0,r||P(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},o.prototype.writeFloatLE=function(e,t,r){return M(this,e,t,!0,r)},o.prototype.writeFloatBE=function(e,t,r){return M(this,e,t,!1,r)},o.prototype.writeDoubleLE=function(e,t,r){return B(this,e,t,!0,r)},o.prototype.writeDoubleBE=function(e,t,r){return B(this,e,t,!1,r)},o.prototype.copy=function(e,t,r,n){if(!o.isBuffer(e))throw new TypeError("argument should be a Buffer");if(r||(r=0),n||0===n||(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);var i=n-r;if(this===e&&"function"==typeof Uint8Array.prototype.copyWithin)this.copyWithin(t,r,n);else if(this===e&&r<t&&t<n)for(var s=i-1;s>=0;--s)e[s+t]=this[s+r];else Uint8Array.prototype.set.call(e,this.subarray(r,n),t);return i},o.prototype.fill=function(e,t,r,n){if("string"==typeof e){if("string"==typeof t?(n=t,t=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!o.isEncoding(n))throw new TypeError("Unknown encoding: "+n);if(1===e.length){var i=e.charCodeAt(0);("utf8"===n&&i<128||"latin1"===n)&&(e=i)}}else"number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<r)throw new RangeError("Out of range index");if(r<=t)return this;var s;if(t>>>=0,r=void 0===r?this.length:r>>>0,e||(e=0),"number"==typeof e)for(s=t;s<r;++s)this[s]=e;else{var a=o.isBuffer(e)?e:o.from(e,n),l=a.length;if(0===l)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(s=0;s<r-t;++s)this[s+t]=a[s%l]}return this};var L=/[^+/0-9A-Za-z-_]/g;function j(e){return e<16?"0"+e.toString(16):e.toString(16)}function N(e,t){var r;t=t||1/0;for(var n=e.length,i=null,s=[],o=0;o<n;++o){if((r=e.charCodeAt(o))>55295&&r<57344){if(!i){if(r>56319){(t-=3)>-1&&s.push(239,191,189);continue}if(o+1===n){(t-=3)>-1&&s.push(239,191,189);continue}i=r;continue}if(r<56320){(t-=3)>-1&&s.push(239,191,189),i=r;continue}r=65536+(i-55296<<10|r-56320)}else i&&(t-=3)>-1&&s.push(239,191,189);if(i=null,r<128){if((t-=1)<0)break;s.push(r)}else if(r<2048){if((t-=2)<0)break;s.push(r>>6|192,63&r|128)}else if(r<65536){if((t-=3)<0)break;s.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;s.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return s}function U(e){return t.toByteArray(function(e){if((e=(e=e.split("=")[0]).trim().replace(L,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function D(e,t,r,n){for(var i=0;i<n&&!(i+r>=t.length||i>=e.length);++i)t[i+r]=e[i];return i}function F(e,t){return e instanceof t||null!=e&&null!=e.constructor&&null!=e.constructor.name&&e.constructor.name===t.name}function W(e){return e!=e}}).call(this)}).call(this,e("buffer").Buffer)},{"base64-js":25,buffer:29,ieee754:50}],30:[function(e,t,r){(function(n){(function(){r.formatArgs=function(e){if(e[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+e[0]+(this.useColors?"%c ":" ")+"+"+t.exports.humanize(this.diff),!this.useColors)return;const r="color: "+this.color;e.splice(1,0,r,"color: inherit");let n=0,i=0;e[0].replace(/%[a-zA-Z%]/g,(e=>{"%%"!==e&&(n++,"%c"===e&&(i=n))})),e.splice(i,0,r)},r.save=function(e){try{e?r.storage.setItem("debug",e):r.storage.removeItem("debug")}catch(e){}},r.load=function(){let e;try{e=r.storage.getItem("debug")}catch(e){}!e&&void 0!==n&&"env"in n&&(e=n.env.DEBUG);return e},r.useColors=function(){if("undefined"!=typeof window&&window.process&&("renderer"===window.process.type||window.process.__nwjs))return!0;if("undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;return"undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},r.storage=function(){try{return localStorage}catch(e){}}(),r.destroy=(()=>{let e=!1;return()=>{e||(e=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),r.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],r.log=console.debug||console.log||(()=>{}),t.exports=e("./common")(r);const{formatters:i}=t.exports;i.j=function(e){try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}}).call(this)}).call(this,e("_process"))},{"./common":31,_process:102}],31:[function(e,t,r){t.exports=function(t){function r(e){let t,i,s,o=null;function a(...e){if(!a.enabled)return;const n=a,i=Number(new Date),s=i-(t||i);n.diff=s,n.prev=t,n.curr=i,t=i,e[0]=r.coerce(e[0]),"string"!=typeof e[0]&&e.unshift("%O");let o=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,((t,i)=>{if("%%"===t)return"%";o++;const s=r.formatters[i];if("function"==typeof s){const r=e[o];t=s.call(n,r),e.splice(o,1),o--}return t})),r.formatArgs.call(n,e);(n.log||r.log).apply(n,e)}return a.namespace=e,a.useColors=r.useColors(),a.color=r.selectColor(e),a.extend=n,a.destroy=r.destroy,Object.defineProperty(a,"enabled",{enumerable:!0,configurable:!1,get:()=>null!==o?o:(i!==r.namespaces&&(i=r.namespaces,s=r.enabled(e)),s),set:e=>{o=e}}),"function"==typeof r.init&&r.init(a),a}function n(e,t){const n=r(this.namespace+(void 0===t?":":t)+e);return n.log=this.log,n}function i(e){return e.toString().substring(2,e.toString().length-2).replace(/\.\*\?$/,"*")}return r.debug=r,r.default=r,r.coerce=function(e){if(e instanceof Error)return e.stack||e.message;return e},r.disable=function(){const e=[...r.names.map(i),...r.skips.map(i).map((e=>"-"+e))].join(",");return r.enable(""),e},r.enable=function(e){let t;r.save(e),r.namespaces=e,r.names=[],r.skips=[];const n=("string"==typeof e?e:"").split(/[\s,]+/),i=n.length;for(t=0;t<i;t++)n[t]&&("-"===(e=n[t].replace(/\*/g,".*?"))[0]?r.skips.push(new RegExp("^"+e.slice(1)+"$")):r.names.push(new RegExp("^"+e+"$")))},r.enabled=function(e){if("*"===e[e.length-1])return!0;let t,n;for(t=0,n=r.skips.length;t<n;t++)if(r.skips[t].test(e))return!1;for(t=0,n=r.names.length;t<n;t++)if(r.names[t].test(e))return!0;return!1},r.humanize=e("ms"),r.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(t).forEach((e=>{r[e]=t[e]})),r.names=[],r.skips=[],r.formatters={},r.selectColor=function(e){let t=0;for(let r=0;r<e.length;r++)t=(t<<5)-t+e.charCodeAt(r),t|=0;return r.colors[Math.abs(t)%r.colors.length]},r.enable(r.load()),r}},{ms:97}],32:[function(e,t,r){(function(r,n){(function(){var i=e("readable-stream"),s=e("end-of-stream"),o=e("inherits"),a=e("stream-shift"),l=n.from&&n.from!==Uint8Array.from?n.from([0]):new n([0]),u=function(e,t){e._corked?e.once("uncork",t):t()},c=function(e,t){return function(r){r?function(e,t){e._autoDestroy&&e.destroy(t)}(e,"premature close"===r.message?null:r):t&&!e._ended&&e.end()}},h=function(){},f=function(e,t,r){if(!(this instanceof f))return new f(e,t,r);i.Duplex.call(this,r),this._writable=null,this._readable=null,this._readable2=null,this._autoDestroy=!r||!1!==r.autoDestroy,this._forwardDestroy=!r||!1!==r.destroy,this._forwardEnd=!r||!1!==r.end,this._corked=1,this._ondrain=null,this._drained=!1,this._forwarding=!1,this._unwrite=null,this._unread=null,this._ended=!1,this.destroyed=!1,e&&this.setWritable(e),t&&this.setReadable(t)};o(f,i.Duplex),f.obj=function(e,t,r){return r||(r={}),r.objectMode=!0,r.highWaterMark=16,new f(e,t,r)},f.prototype.cork=function(){1==++this._corked&&this.emit("cork")},f.prototype.uncork=function(){this._corked&&0==--this._corked&&this.emit("uncork")},f.prototype.setWritable=function(e){if(this._unwrite&&this._unwrite(),this.destroyed)e&&e.destroy&&e.destroy();else if(null!==e&&!1!==e){var t=this,n=s(e,{writable:!0,readable:!1},c(this,this._forwardEnd)),i=function(){var e=t._ondrain;t._ondrain=null,e&&e()};this._unwrite&&r.nextTick(i),this._writable=e,this._writable.on("drain",i),this._unwrite=function(){t._writable.removeListener("drain",i),n()},this.uncork()}else this.end()},f.prototype.setReadable=function(e){if(this._unread&&this._unread(),this.destroyed)e&&e.destroy&&e.destroy();else{if(null===e||!1===e)return this.push(null),void this.resume();var t,r=this,n=s(e,{writable:!1,readable:!0},c(this)),o=function(){r._forward()},a=function(){r.push(null)};this._drained=!0,this._readable=e,this._readable2=e._readableState?e:(t=e,new i.Readable({objectMode:!0,highWaterMark:16}).wrap(t)),this._readable2.on("readable",o),this._readable2.on("end",a),this._unread=function(){r._readable2.removeListener("readable",o),r._readable2.removeListener("end",a),n()},this._forward()}},f.prototype._read=function(){this._drained=!0,this._forward()},f.prototype._forward=function(){if(!this._forwarding&&this._readable2&&this._drained){var e;for(this._forwarding=!0;this._drained&&null!==(e=a(this._readable2));)this.destroyed||(this._drained=this.push(e));this._forwarding=!1}},f.prototype.destroy=function(e,t){if(t||(t=h),this.destroyed)return t(null);this.destroyed=!0;var n=this;r.nextTick((function(){n._destroy(e),t(null)}))},f.prototype._destroy=function(e){if(e){var t=this._ondrain;this._ondrain=null,t?t(e):this.emit("error",e)}this._forwardDestroy&&(this._readable&&this._readable.destroy&&this._readable.destroy(),this._writable&&this._writable.destroy&&this._writable.destroy()),this.emit("close")},f.prototype._write=function(e,t,r){if(!this.destroyed)return this._corked?u(this,this._write.bind(this,e,t,r)):e===l?this._finish(r):this._writable?void(!1===this._writable.write(e)?this._ondrain=r:this.destroyed||r()):r()},f.prototype._finish=function(e){var t=this;this.emit("preend"),u(this,(function(){var r,n;r=t._forwardEnd&&t._writable,n=function(){!1===t._writableState.prefinished&&(t._writableState.prefinished=!0),t.emit("prefinish"),u(t,e)},r?r._writableState&&r._writableState.finished?n():r._writableState?r.end(n):(r.end(),n()):n()}))},f.prototype.end=function(e,t,r){return"function"==typeof e?this.end(null,null,e):"function"==typeof t?this.end(e,null,t):(this._ended=!0,e&&this.write(e),this._writableState.ending||this._writableState.destroyed||this.write(l),i.Writable.prototype.end.call(this,r))},t.exports=f}).call(this)}).call(this,e("_process"),e("buffer").Buffer)},{_process:102,buffer:29,"end-of-stream":48,inherits:51,"readable-stream":47,"stream-shift":135}],33:[function(e,t,r){"use strict";var n={};function i(e,t,r){r||(r=Error);var i=function(e){var r,n;function i(r,n,i){return e.call(this,function(e,r,n){return"string"==typeof t?t:t(e,r,n)}(r,n,i))||this}return n=e,(r=i).prototype=Object.create(n.prototype),r.prototype.constructor=r,r.__proto__=n,i}(r);i.prototype.name=r.name,i.prototype.code=e,n[e]=i}function s(e,t){if(Array.isArray(e)){var r=e.length;return e=e.map((function(e){return String(e)})),r>2?"one of ".concat(t," ").concat(e.slice(0,r-1).join(", "),", or ")+e[r-1]:2===r?"one of ".concat(t," ").concat(e[0]," or ").concat(e[1]):"of ".concat(t," ").concat(e[0])}return"of ".concat(t," ").concat(String(e))}i("ERR_INVALID_OPT_VALUE",(function(e,t){return'The value "'+t+'" is invalid for option "'+e+'"'}),TypeError),i("ERR_INVALID_ARG_TYPE",(function(e,t,r){var n,i,o,a;if("string"==typeof t&&(i="not ",t.substr(!o||o<0?0:+o,i.length)===i)?(n="must not be",t=t.replace(/^not /,"")):n="must be",function(e,t,r){return(void 0===r||r>e.length)&&(r=e.length),e.substring(r-t.length,r)===t}(e," argument"))a="The ".concat(e," ").concat(n," ").concat(s(t,"type"));else{var l=function(e,t,r){return"number"!=typeof r&&(r=0),!(r+t.length>e.length)&&-1!==e.indexOf(t,r)}(e,".")?"property":"argument";a='The "'.concat(e,'" ').concat(l," ").concat(n," ").concat(s(t,"type"))}return a+=". Received type ".concat(typeof r)}),TypeError),i("ERR_STREAM_PUSH_AFTER_EOF","stream.push() after EOF"),i("ERR_METHOD_NOT_IMPLEMENTED",(function(e){return"The "+e+" method is not implemented"})),i("ERR_STREAM_PREMATURE_CLOSE","Premature close"),i("ERR_STREAM_DESTROYED",(function(e){return"Cannot call "+e+" after a stream was destroyed"})),i("ERR_MULTIPLE_CALLBACK","Callback called multiple times"),i("ERR_STREAM_CANNOT_PIPE","Cannot pipe, not readable"),i("ERR_STREAM_WRITE_AFTER_END","write after end"),i("ERR_STREAM_NULL_VALUES","May not write null values to stream",TypeError),i("ERR_UNKNOWN_ENCODING",(function(e){return"Unknown encoding: "+e}),TypeError),i("ERR_STREAM_UNSHIFT_AFTER_END_EVENT","stream.unshift() after end event"),t.exports.codes=n},{}],34:[function(e,t,r){(function(r){(function(){"use strict";var n=Object.keys||function(e){var t=[];for(var r in e)t.push(r);return t};t.exports=u;var i=e("./_stream_readable"),s=e("./_stream_writable");e("inherits")(u,i);for(var o=n(s.prototype),a=0;a<o.length;a++){var l=o[a];u.prototype[l]||(u.prototype[l]=s.prototype[l])}function u(e){if(!(this instanceof u))return new u(e);i.call(this,e),s.call(this,e),this.allowHalfOpen=!0,e&&(!1===e.readable&&(this.readable=!1),!1===e.writable&&(this.writable=!1),!1===e.allowHalfOpen&&(this.allowHalfOpen=!1,this.once("end",c)))}function c(){this._writableState.ended||r.nextTick(h,this)}function h(e){e.end()}Object.defineProperty(u.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),Object.defineProperty(u.prototype,"writableBuffer",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(u.prototype,"writableLength",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(u.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed&&this._writableState.destroyed)},set:function(e){void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed=e,this._writableState.destroyed=e)}})}).call(this)}).call(this,e("_process"))},{"./_stream_readable":36,"./_stream_writable":38,_process:102,inherits:51}],35:[function(e,t,r){"use strict";t.exports=i;var n=e("./_stream_transform");function i(e){if(!(this instanceof i))return new i(e);n.call(this,e)}e("inherits")(i,n),i.prototype._transform=function(e,t,r){r(null,e)}},{"./_stream_transform":37,inherits:51}],36:[function(e,t,r){(function(r,n){(function(){"use strict";var i;t.exports=k,k.ReadableState=A;e("events").EventEmitter;var s=function(e,t){return e.listeners(t).length},o=e("./internal/streams/stream"),a=e("buffer").Buffer,l=n.Uint8Array||function(){};var u,c=e("util");u=c&&c.debuglog?c.debuglog("stream"):function(){};var h,f,d,p=e("./internal/streams/buffer_list"),b=e("./internal/streams/destroy"),g=e("./internal/streams/state").getHighWaterMark,m=e("../errors").codes,y=m.ERR_INVALID_ARG_TYPE,_=m.ERR_STREAM_PUSH_AFTER_EOF,w=m.ERR_METHOD_NOT_IMPLEMENTED,v=m.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;e("inherits")(k,o);var S=b.errorOrDestroy,E=["error","close","destroy","pause","resume"];function A(t,r,n){i=i||e("./_stream_duplex"),t=t||{},"boolean"!=typeof n&&(n=r instanceof i),this.objectMode=!!t.objectMode,n&&(this.objectMode=this.objectMode||!!t.readableObjectMode),this.highWaterMark=g(this,t,"readableHighWaterMark",n),this.buffer=new p,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.paused=!0,this.emitClose=!1!==t.emitClose,this.autoDestroy=!!t.autoDestroy,this.destroyed=!1,this.defaultEncoding=t.defaultEncoding||"utf8",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,t.encoding&&(h||(h=e("string_decoder/").StringDecoder),this.decoder=new h(t.encoding),this.encoding=t.encoding)}function k(t){if(i=i||e("./_stream_duplex"),!(this instanceof k))return new k(t);var r=this instanceof i;this._readableState=new A(t,this,r),this.readable=!0,t&&("function"==typeof t.read&&(this._read=t.read),"function"==typeof t.destroy&&(this._destroy=t.destroy)),o.call(this)}function T(e,t,r,n,i){u("readableAddChunk",t);var s,o=e._readableState;if(null===t)o.reading=!1,function(e,t){if(u("onEofChunk"),t.ended)return;if(t.decoder){var r=t.decoder.end();r&&r.length&&(t.buffer.push(r),t.length+=t.objectMode?1:r.length)}t.ended=!0,t.sync?C(e):(t.needReadable=!1,t.emittedReadable||(t.emittedReadable=!0,P(e)))}(e,o);else if(i||(s=function(e,t){var r;n=t,a.isBuffer(n)||n instanceof l||"string"==typeof t||void 0===t||e.objectMode||(r=new y("chunk",["string","Buffer","Uint8Array"],t));var n;return r}(o,t)),s)S(e,s);else if(o.objectMode||t&&t.length>0)if("string"==typeof t||o.objectMode||Object.getPrototypeOf(t)===a.prototype||(t=function(e){return a.from(e)}(t)),n)o.endEmitted?S(e,new v):I(e,o,t,!0);else if(o.ended)S(e,new _);else{if(o.destroyed)return!1;o.reading=!1,o.decoder&&!r?(t=o.decoder.write(t),o.objectMode||0!==t.length?I(e,o,t,!1):x(e,o)):I(e,o,t,!1)}else n||(o.reading=!1,x(e,o));return!o.ended&&(o.length<o.highWaterMark||0===o.length)}function I(e,t,r,n){t.flowing&&0===t.length&&!t.sync?(t.awaitDrain=0,e.emit("data",r)):(t.length+=t.objectMode?1:r.length,n?t.buffer.unshift(r):t.buffer.push(r),t.needReadable&&C(e)),x(e,t)}Object.defineProperty(k.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._readableState&&this._readableState.destroyed},set:function(e){this._readableState&&(this._readableState.destroyed=e)}}),k.prototype.destroy=b.destroy,k.prototype._undestroy=b.undestroy,k.prototype._destroy=function(e,t){t(e)},k.prototype.push=function(e,t){var r,n=this._readableState;return n.objectMode?r=!0:"string"==typeof e&&((t=t||n.defaultEncoding)!==n.encoding&&(e=a.from(e,t),t=""),r=!0),T(this,e,t,!1,r)},k.prototype.unshift=function(e){return T(this,e,null,!0,!1)},k.prototype.isPaused=function(){return!1===this._readableState.flowing},k.prototype.setEncoding=function(t){h||(h=e("string_decoder/").StringDecoder);var r=new h(t);this._readableState.decoder=r,this._readableState.encoding=this._readableState.decoder.encoding;for(var n=this._readableState.buffer.head,i="";null!==n;)i+=r.write(n.data),n=n.next;return this._readableState.buffer.clear(),""!==i&&this._readableState.buffer.push(i),this._readableState.length=i.length,this};var R=1073741824;function O(e,t){return e<=0||0===t.length&&t.ended?0:t.objectMode?1:e!=e?t.flowing&&t.length?t.buffer.head.data.length:t.length:(e>t.highWaterMark&&(t.highWaterMark=function(e){return e>=R?e=R:(e--,e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,e|=e>>>16,e++),e}(e)),e<=t.length?e:t.ended?t.length:(t.needReadable=!0,0))}function C(e){var t=e._readableState;u("emitReadable",t.needReadable,t.emittedReadable),t.needReadable=!1,t.emittedReadable||(u("emitReadable",t.flowing),t.emittedReadable=!0,r.nextTick(P,e))}function P(e){var t=e._readableState;u("emitReadable_",t.destroyed,t.length,t.ended),t.destroyed||!t.length&&!t.ended||(e.emit("readable"),t.emittedReadable=!1),t.needReadable=!t.flowing&&!t.ended&&t.length<=t.highWaterMark,N(e)}function x(e,t){t.readingMore||(t.readingMore=!0,r.nextTick(M,e,t))}function M(e,t){for(;!t.reading&&!t.ended&&(t.length<t.highWaterMark||t.flowing&&0===t.length);){var r=t.length;if(u("maybeReadMore read 0"),e.read(0),r===t.length)break}t.readingMore=!1}function B(e){var t=e._readableState;t.readableListening=e.listenerCount("readable")>0,t.resumeScheduled&&!t.paused?t.flowing=!0:e.listenerCount("data")>0&&e.resume()}function L(e){u("readable nexttick read 0"),e.read(0)}function j(e,t){u("resume",t.reading),t.reading||e.read(0),t.resumeScheduled=!1,e.emit("resume"),N(e),t.flowing&&!t.reading&&e.read(0)}function N(e){var t=e._readableState;for(u("flow",t.flowing);t.flowing&&null!==e.read(););}function U(e,t){return 0===t.length?null:(t.objectMode?r=t.buffer.shift():!e||e>=t.length?(r=t.decoder?t.buffer.join(""):1===t.buffer.length?t.buffer.first():t.buffer.concat(t.length),t.buffer.clear()):r=t.buffer.consume(e,t.decoder),r);var r}function D(e){var t=e._readableState;u("endReadable",t.endEmitted),t.endEmitted||(t.ended=!0,r.nextTick(F,t,e))}function F(e,t){if(u("endReadableNT",e.endEmitted,e.length),!e.endEmitted&&0===e.length&&(e.endEmitted=!0,t.readable=!1,t.emit("end"),e.autoDestroy)){var r=t._writableState;(!r||r.autoDestroy&&r.finished)&&t.destroy()}}function W(e,t){for(var r=0,n=e.length;r<n;r++)if(e[r]===t)return r;return-1}k.prototype.read=function(e){u("read",e),e=parseInt(e,10);var t=this._readableState,r=e;if(0!==e&&(t.emittedReadable=!1),0===e&&t.needReadable&&((0!==t.highWaterMark?t.length>=t.highWaterMark:t.length>0)||t.ended))return u("read: emitReadable",t.length,t.ended),0===t.length&&t.ended?D(this):C(this),null;if(0===(e=O(e,t))&&t.ended)return 0===t.length&&D(this),null;var n,i=t.needReadable;return u("need readable",i),(0===t.length||t.length-e<t.highWaterMark)&&u("length less than watermark",i=!0),t.ended||t.reading?u("reading or ended",i=!1):i&&(u("do read"),t.reading=!0,t.sync=!0,0===t.length&&(t.needReadable=!0),this._read(t.highWaterMark),t.sync=!1,t.reading||(e=O(r,t))),null===(n=e>0?U(e,t):null)?(t.needReadable=t.length<=t.highWaterMark,e=0):(t.length-=e,t.awaitDrain=0),0===t.length&&(t.ended||(t.needReadable=!0),r!==e&&t.ended&&D(this)),null!==n&&this.emit("data",n),n},k.prototype._read=function(e){S(this,new w("_read()"))},k.prototype.pipe=function(e,t){var n=this,i=this._readableState;switch(i.pipesCount){case 0:i.pipes=e;break;case 1:i.pipes=[i.pipes,e];break;default:i.pipes.push(e)}i.pipesCount+=1,u("pipe count=%d opts=%j",i.pipesCount,t);var o=(!t||!1!==t.end)&&e!==r.stdout&&e!==r.stderr?l:g;function a(t,r){u("onunpipe"),t===n&&r&&!1===r.hasUnpiped&&(r.hasUnpiped=!0,u("cleanup"),e.removeListener("close",p),e.removeListener("finish",b),e.removeListener("drain",c),e.removeListener("error",d),e.removeListener("unpipe",a),n.removeListener("end",l),n.removeListener("end",g),n.removeListener("data",f),h=!0,!i.awaitDrain||e._writableState&&!e._writableState.needDrain||c())}function l(){u("onend"),e.end()}i.endEmitted?r.nextTick(o):n.once("end",o),e.on("unpipe",a);var c=function(e){return function(){var t=e._readableState;u("pipeOnDrain",t.awaitDrain),t.awaitDrain&&t.awaitDrain--,0===t.awaitDrain&&s(e,"data")&&(t.flowing=!0,N(e))}}(n);e.on("drain",c);var h=!1;function f(t){u("ondata");var r=e.write(t);u("dest.write",r),!1===r&&((1===i.pipesCount&&i.pipes===e||i.pipesCount>1&&-1!==W(i.pipes,e))&&!h&&(u("false write response, pause",i.awaitDrain),i.awaitDrain++),n.pause())}function d(t){u("onerror",t),g(),e.removeListener("error",d),0===s(e,"error")&&S(e,t)}function p(){e.removeListener("finish",b),g()}function b(){u("onfinish"),e.removeListener("close",p),g()}function g(){u("unpipe"),n.unpipe(e)}return n.on("data",f),function(e,t,r){if("function"==typeof e.prependListener)return e.prependListener(t,r);e._events&&e._events[t]?Array.isArray(e._events[t])?e._events[t].unshift(r):e._events[t]=[r,e._events[t]]:e.on(t,r)}(e,"error",d),e.once("close",p),e.once("finish",b),e.emit("pipe",n),i.flowing||(u("pipe resume"),n.resume()),e},k.prototype.unpipe=function(e){var t=this._readableState,r={hasUnpiped:!1};if(0===t.pipesCount)return this;if(1===t.pipesCount)return e&&e!==t.pipes||(e||(e=t.pipes),t.pipes=null,t.pipesCount=0,t.flowing=!1,e&&e.emit("unpipe",this,r)),this;if(!e){var n=t.pipes,i=t.pipesCount;t.pipes=null,t.pipesCount=0,t.flowing=!1;for(var s=0;s<i;s++)n[s].emit("unpipe",this,{hasUnpiped:!1});return this}var o=W(t.pipes,e);return-1===o||(t.pipes.splice(o,1),t.pipesCount-=1,1===t.pipesCount&&(t.pipes=t.pipes[0]),e.emit("unpipe",this,r)),this},k.prototype.on=function(e,t){var n=o.prototype.on.call(this,e,t),i=this._readableState;return"data"===e?(i.readableListening=this.listenerCount("readable")>0,!1!==i.flowing&&this.resume()):"readable"===e&&(i.endEmitted||i.readableListening||(i.readableListening=i.needReadable=!0,i.flowing=!1,i.emittedReadable=!1,u("on readable",i.length,i.reading),i.length?C(this):i.reading||r.nextTick(L,this))),n},k.prototype.addListener=k.prototype.on,k.prototype.removeListener=function(e,t){var n=o.prototype.removeListener.call(this,e,t);return"readable"===e&&r.nextTick(B,this),n},k.prototype.removeAllListeners=function(e){var t=o.prototype.removeAllListeners.apply(this,arguments);return"readable"!==e&&void 0!==e||r.nextTick(B,this),t},k.prototype.resume=function(){var e=this._readableState;return e.flowing||(u("resume"),e.flowing=!e.readableListening,function(e,t){t.resumeScheduled||(t.resumeScheduled=!0,r.nextTick(j,e,t))}(this,e)),e.paused=!1,this},k.prototype.pause=function(){return u("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(u("pause"),this._readableState.flowing=!1,this.emit("pause")),this._readableState.paused=!0,this},k.prototype.wrap=function(e){var t=this,r=this._readableState,n=!1;for(var i in e.on("end",(function(){if(u("wrapped end"),r.decoder&&!r.ended){var e=r.decoder.end();e&&e.length&&t.push(e)}t.push(null)})),e.on("data",(function(i){(u("wrapped data"),r.decoder&&(i=r.decoder.write(i)),r.objectMode&&null==i)||(r.objectMode||i&&i.length)&&(t.push(i)||(n=!0,e.pause()))})),e)void 0===this[i]&&"function"==typeof e[i]&&(this[i]=function(t){return function(){return e[t].apply(e,arguments)}}(i));for(var s=0;s<E.length;s++)e.on(E[s],this.emit.bind(this,E[s]));return this._read=function(t){u("wrapped _read",t),n&&(n=!1,e.resume())},this},"function"==typeof Symbol&&(k.prototype[Symbol.asyncIterator]=function(){return void 0===f&&(f=e("./internal/streams/async_iterator")),f(this)}),Object.defineProperty(k.prototype,"readableHighWaterMark",{enumerable:!1,get:function(){return this._readableState.highWaterMark}}),Object.defineProperty(k.prototype,"readableBuffer",{enumerable:!1,get:function(){return this._readableState&&this._readableState.buffer}}),Object.defineProperty(k.prototype,"readableFlowing",{enumerable:!1,get:function(){return this._readableState.flowing},set:function(e){this._readableState&&(this._readableState.flowing=e)}}),k._fromList=U,Object.defineProperty(k.prototype,"readableLength",{enumerable:!1,get:function(){return this._readableState.length}}),"function"==typeof Symbol&&(k.from=function(t,r){return void 0===d&&(d=e("./internal/streams/from")),d(k,t,r)})}).call(this)}).call(this,e("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"../errors":33,"./_stream_duplex":34,"./internal/streams/async_iterator":39,"./internal/streams/buffer_list":40,"./internal/streams/destroy":41,"./internal/streams/from":43,"./internal/streams/state":45,"./internal/streams/stream":46,_process:102,buffer:29,events:49,inherits:51,"string_decoder/":136,util:26}],37:[function(e,t,r){"use strict";t.exports=c;var n=e("../errors").codes,i=n.ERR_METHOD_NOT_IMPLEMENTED,s=n.ERR_MULTIPLE_CALLBACK,o=n.ERR_TRANSFORM_ALREADY_TRANSFORMING,a=n.ERR_TRANSFORM_WITH_LENGTH_0,l=e("./_stream_duplex");function u(e,t){var r=this._transformState;r.transforming=!1;var n=r.writecb;if(null===n)return this.emit("error",new s);r.writechunk=null,r.writecb=null,null!=t&&this.push(t),n(e);var i=this._readableState;i.reading=!1,(i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}function c(e){if(!(this instanceof c))return new c(e);l.call(this,e),this._transformState={afterTransform:u.bind(this),needTransform:!1,transforming:!1,writecb:null,writechunk:null,writeencoding:null},this._readableState.needReadable=!0,this._readableState.sync=!1,e&&("function"==typeof e.transform&&(this._transform=e.transform),"function"==typeof e.flush&&(this._flush=e.flush)),this.on("prefinish",h)}function h(){var e=this;"function"!=typeof this._flush||this._readableState.destroyed?f(this,null,null):this._flush((function(t,r){f(e,t,r)}))}function f(e,t,r){if(t)return e.emit("error",t);if(null!=r&&e.push(r),e._writableState.length)throw new a;if(e._transformState.transforming)throw new o;return e.push(null)}e("inherits")(c,l),c.prototype.push=function(e,t){return this._transformState.needTransform=!1,l.prototype.push.call(this,e,t)},c.prototype._transform=function(e,t,r){r(new i("_transform()"))},c.prototype._write=function(e,t,r){var n=this._transformState;if(n.writecb=r,n.writechunk=e,n.writeencoding=t,!n.transforming){var i=this._readableState;(n.needTransform||i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}},c.prototype._read=function(e){var t=this._transformState;null===t.writechunk||t.transforming?t.needTransform=!0:(t.transforming=!0,this._transform(t.writechunk,t.writeencoding,t.afterTransform))},c.prototype._destroy=function(e,t){l.prototype._destroy.call(this,e,(function(e){t(e)}))}},{"../errors":33,"./_stream_duplex":34,inherits:51}],38:[function(e,t,r){(function(r,n){(function(){"use strict";function i(e){var t=this;this.next=null,this.entry=null,this.finish=function(){!function(e,t,r){var n=e.entry;e.entry=null;for(;n;){var i=n.callback;t.pendingcb--,i(r),n=n.next}t.corkedRequestsFree.next=e}(t,e)}}var s;t.exports=k,k.WritableState=A;var o={deprecate:e("util-deprecate")},a=e("./internal/streams/stream"),l=e("buffer").Buffer,u=n.Uint8Array||function(){};var c,h=e("./internal/streams/destroy"),f=e("./internal/streams/state").getHighWaterMark,d=e("../errors").codes,p=d.ERR_INVALID_ARG_TYPE,b=d.ERR_METHOD_NOT_IMPLEMENTED,g=d.ERR_MULTIPLE_CALLBACK,m=d.ERR_STREAM_CANNOT_PIPE,y=d.ERR_STREAM_DESTROYED,_=d.ERR_STREAM_NULL_VALUES,w=d.ERR_STREAM_WRITE_AFTER_END,v=d.ERR_UNKNOWN_ENCODING,S=h.errorOrDestroy;function E(){}function A(t,n,o){s=s||e("./_stream_duplex"),t=t||{},"boolean"!=typeof o&&(o=n instanceof s),this.objectMode=!!t.objectMode,o&&(this.objectMode=this.objectMode||!!t.writableObjectMode),this.highWaterMark=f(this,t,"writableHighWaterMark",o),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;var a=!1===t.decodeStrings;this.decodeStrings=!a,this.defaultEncoding=t.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(e){!function(e,t){var n=e._writableState,i=n.sync,s=n.writecb;if("function"!=typeof s)throw new g;if(function(e){e.writing=!1,e.writecb=null,e.length-=e.writelen,e.writelen=0}(n),t)!function(e,t,n,i,s){--t.pendingcb,n?(r.nextTick(s,i),r.nextTick(P,e,t),e._writableState.errorEmitted=!0,S(e,i)):(s(i),e._writableState.errorEmitted=!0,S(e,i),P(e,t))}(e,n,i,t,s);else{var o=O(n)||e.destroyed;o||n.corked||n.bufferProcessing||!n.bufferedRequest||R(e,n),i?r.nextTick(I,e,n,o,s):I(e,n,o,s)}}(n,e)},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.emitClose=!1!==t.emitClose,this.autoDestroy=!!t.autoDestroy,this.bufferedRequestCount=0,this.corkedRequestsFree=new i(this)}function k(t){var r=this instanceof(s=s||e("./_stream_duplex"));if(!r&&!c.call(k,this))return new k(t);this._writableState=new A(t,this,r),this.writable=!0,t&&("function"==typeof t.write&&(this._write=t.write),"function"==typeof t.writev&&(this._writev=t.writev),"function"==typeof t.destroy&&(this._destroy=t.destroy),"function"==typeof t.final&&(this._final=t.final)),a.call(this)}function T(e,t,r,n,i,s,o){t.writelen=n,t.writecb=o,t.writing=!0,t.sync=!0,t.destroyed?t.onwrite(new y("write")):r?e._writev(i,t.onwrite):e._write(i,s,t.onwrite),t.sync=!1}function I(e,t,r,n){r||function(e,t){0===t.length&&t.needDrain&&(t.needDrain=!1,e.emit("drain"))}(e,t),t.pendingcb--,n(),P(e,t)}function R(e,t){t.bufferProcessing=!0;var r=t.bufferedRequest;if(e._writev&&r&&r.next){var n=t.bufferedRequestCount,s=new Array(n),o=t.corkedRequestsFree;o.entry=r;for(var a=0,l=!0;r;)s[a]=r,r.isBuf||(l=!1),r=r.next,a+=1;s.allBuffers=l,T(e,t,!0,t.length,s,"",o.finish),t.pendingcb++,t.lastBufferedRequest=null,o.next?(t.corkedRequestsFree=o.next,o.next=null):t.corkedRequestsFree=new i(t),t.bufferedRequestCount=0}else{for(;r;){var u=r.chunk,c=r.encoding,h=r.callback;if(T(e,t,!1,t.objectMode?1:u.length,u,c,h),r=r.next,t.bufferedRequestCount--,t.writing)break}null===r&&(t.lastBufferedRequest=null)}t.bufferedRequest=r,t.bufferProcessing=!1}function O(e){return e.ending&&0===e.length&&null===e.bufferedRequest&&!e.finished&&!e.writing}function C(e,t){e._final((function(r){t.pendingcb--,r&&S(e,r),t.prefinished=!0,e.emit("prefinish"),P(e,t)}))}function P(e,t){var n=O(t);if(n&&(function(e,t){t.prefinished||t.finalCalled||("function"!=typeof e._final||t.destroyed?(t.prefinished=!0,e.emit("prefinish")):(t.pendingcb++,t.finalCalled=!0,r.nextTick(C,e,t)))}(e,t),0===t.pendingcb&&(t.finished=!0,e.emit("finish"),t.autoDestroy))){var i=e._readableState;(!i||i.autoDestroy&&i.endEmitted)&&e.destroy()}return n}e("inherits")(k,a),A.prototype.getBuffer=function(){for(var e=this.bufferedRequest,t=[];e;)t.push(e),e=e.next;return t},function(){try{Object.defineProperty(A.prototype,"buffer",{get:o.deprecate((function(){return this.getBuffer()}),"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.","DEP0003")})}catch(e){}}(),"function"==typeof Symbol&&Symbol.hasInstance&&"function"==typeof Function.prototype[Symbol.hasInstance]?(c=Function.prototype[Symbol.hasInstance],Object.defineProperty(k,Symbol.hasInstance,{value:function(e){return!!c.call(this,e)||this===k&&(e&&e._writableState instanceof A)}})):c=function(e){return e instanceof this},k.prototype.pipe=function(){S(this,new m)},k.prototype.write=function(e,t,n){var i,s=this._writableState,o=!1,a=!s.objectMode&&(i=e,l.isBuffer(i)||i instanceof u);return a&&!l.isBuffer(e)&&(e=function(e){return l.from(e)}(e)),"function"==typeof t&&(n=t,t=null),a?t="buffer":t||(t=s.defaultEncoding),"function"!=typeof n&&(n=E),s.ending?function(e,t){var n=new w;S(e,n),r.nextTick(t,n)}(this,n):(a||function(e,t,n,i){var s;return null===n?s=new _:"string"==typeof n||t.objectMode||(s=new p("chunk",["string","Buffer"],n)),!s||(S(e,s),r.nextTick(i,s),!1)}(this,s,e,n))&&(s.pendingcb++,o=function(e,t,r,n,i,s){if(!r){var o=function(e,t,r){e.objectMode||!1===e.decodeStrings||"string"!=typeof t||(t=l.from(t,r));return t}(t,n,i);n!==o&&(r=!0,i="buffer",n=o)}var a=t.objectMode?1:n.length;t.length+=a;var u=t.length<t.highWaterMark;u||(t.needDrain=!0);if(t.writing||t.corked){var c=t.lastBufferedRequest;t.lastBufferedRequest={chunk:n,encoding:i,isBuf:r,callback:s,next:null},c?c.next=t.lastBufferedRequest:t.bufferedRequest=t.lastBufferedRequest,t.bufferedRequestCount+=1}else T(e,t,!1,a,n,i,s);return u}(this,s,a,e,t,n)),o},k.prototype.cork=function(){this._writableState.corked++},k.prototype.uncork=function(){var e=this._writableState;e.corked&&(e.corked--,e.writing||e.corked||e.bufferProcessing||!e.bufferedRequest||R(this,e))},k.prototype.setDefaultEncoding=function(e){if("string"==typeof e&&(e=e.toLowerCase()),!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((e+"").toLowerCase())>-1))throw new v(e);return this._writableState.defaultEncoding=e,this},Object.defineProperty(k.prototype,"writableBuffer",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(k.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),k.prototype._write=function(e,t,r){r(new b("_write()"))},k.prototype._writev=null,k.prototype.end=function(e,t,n){var i=this._writableState;return"function"==typeof e?(n=e,e=null,t=null):"function"==typeof t&&(n=t,t=null),null!=e&&this.write(e,t),i.corked&&(i.corked=1,this.uncork()),i.ending||function(e,t,n){t.ending=!0,P(e,t),n&&(t.finished?r.nextTick(n):e.once("finish",n));t.ended=!0,e.writable=!1}(this,i,n),this},Object.defineProperty(k.prototype,"writableLength",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(k.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._writableState&&this._writableState.destroyed},set:function(e){this._writableState&&(this._writableState.destroyed=e)}}),k.prototype.destroy=h.destroy,k.prototype._undestroy=h.undestroy,k.prototype._destroy=function(e,t){t(e)}}).call(this)}).call(this,e("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"../errors":33,"./_stream_duplex":34,"./internal/streams/destroy":41,"./internal/streams/state":45,"./internal/streams/stream":46,_process:102,buffer:29,inherits:51,"util-deprecate":139}],39:[function(e,t,r){(function(r){(function(){"use strict";var n;function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}var s=e("./end-of-stream"),o=Symbol("lastResolve"),a=Symbol("lastReject"),l=Symbol("error"),u=Symbol("ended"),c=Symbol("lastPromise"),h=Symbol("handlePromise"),f=Symbol("stream");function d(e,t){return{value:e,done:t}}function p(e){var t=e[o];if(null!==t){var r=e[f].read();null!==r&&(e[c]=null,e[o]=null,e[a]=null,t(d(r,!1)))}}function b(e){r.nextTick(p,e)}var g=Object.getPrototypeOf((function(){})),m=Object.setPrototypeOf((i(n={get stream(){return this[f]},next:function(){var e=this,t=this[l];if(null!==t)return Promise.reject(t);if(this[u])return Promise.resolve(d(void 0,!0));if(this[f].destroyed)return new Promise((function(t,n){r.nextTick((function(){e[l]?n(e[l]):t(d(void 0,!0))}))}));var n,i=this[c];if(i)n=new Promise(function(e,t){return function(r,n){e.then((function(){t[u]?r(d(void 0,!0)):t[h](r,n)}),n)}}(i,this));else{var s=this[f].read();if(null!==s)return Promise.resolve(d(s,!1));n=new Promise(this[h])}return this[c]=n,n}},Symbol.asyncIterator,(function(){return this})),i(n,"return",(function(){var e=this;return new Promise((function(t,r){e[f].destroy(null,(function(e){e?r(e):t(d(void 0,!0))}))}))})),n),g);t.exports=function(e){var t,r=Object.create(m,(i(t={},f,{value:e,writable:!0}),i(t,o,{value:null,writable:!0}),i(t,a,{value:null,writable:!0}),i(t,l,{value:null,writable:!0}),i(t,u,{value:e._readableState.endEmitted,writable:!0}),i(t,h,{value:function(e,t){var n=r[f].read();n?(r[c]=null,r[o]=null,r[a]=null,e(d(n,!1))):(r[o]=e,r[a]=t)},writable:!0}),t));return r[c]=null,s(e,(function(e){if(e&&"ERR_STREAM_PREMATURE_CLOSE"!==e.code){var t=r[a];return null!==t&&(r[c]=null,r[o]=null,r[a]=null,t(e)),void(r[l]=e)}var n=r[o];null!==n&&(r[c]=null,r[o]=null,r[a]=null,n(d(void 0,!0))),r[u]=!0})),e.on("readable",b.bind(null,r)),r}}).call(this)}).call(this,e("_process"))},{"./end-of-stream":42,_process:102}],40:[function(e,t,r){"use strict";function n(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var o=e("buffer").Buffer,a=e("util").inspect,l=a&&a.custom||"inspect";t.exports=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.head=null,this.tail=null,this.length=0}var t,r,u;return t=e,r=[{key:"push",value:function(e){var t={data:e,next:null};this.length>0?this.tail.next=t:this.head=t,this.tail=t,++this.length}},{key:"unshift",value:function(e){var t={data:e,next:this.head};0===this.length&&(this.tail=t),this.head=t,++this.length}},{key:"shift",value:function(){if(0!==this.length){var e=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,e}}},{key:"clear",value:function(){this.head=this.tail=null,this.length=0}},{key:"join",value:function(e){if(0===this.length)return"";for(var t=this.head,r=""+t.data;t=t.next;)r+=e+t.data;return r}},{key:"concat",value:function(e){if(0===this.length)return o.alloc(0);for(var t,r,n,i=o.allocUnsafe(e>>>0),s=this.head,a=0;s;)t=s.data,r=i,n=a,o.prototype.copy.call(t,r,n),a+=s.data.length,s=s.next;return i}},{key:"consume",value:function(e,t){var r;return e<this.head.data.length?(r=this.head.data.slice(0,e),this.head.data=this.head.data.slice(e)):r=e===this.head.data.length?this.shift():t?this._getString(e):this._getBuffer(e),r}},{key:"first",value:function(){return this.head.data}},{key:"_getString",value:function(e){var t=this.head,r=1,n=t.data;for(e-=n.length;t=t.next;){var i=t.data,s=e>i.length?i.length:e;if(s===i.length?n+=i:n+=i.slice(0,e),0==(e-=s)){s===i.length?(++r,t.next?this.head=t.next:this.head=this.tail=null):(this.head=t,t.data=i.slice(s));break}++r}return this.length-=r,n}},{key:"_getBuffer",value:function(e){var t=o.allocUnsafe(e),r=this.head,n=1;for(r.data.copy(t),e-=r.data.length;r=r.next;){var i=r.data,s=e>i.length?i.length:e;if(i.copy(t,t.length-e,0,s),0==(e-=s)){s===i.length?(++n,r.next?this.head=r.next:this.head=this.tail=null):(this.head=r,r.data=i.slice(s));break}++n}return this.length-=n,t}},{key:l,value:function(e,t){return a(this,function(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?n(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}({},t,{depth:0,customInspect:!1}))}}],r&&s(t.prototype,r),u&&s(t,u),e}()},{buffer:29,util:26}],41:[function(e,t,r){(function(e){(function(){"use strict";function r(e,t){i(e,t),n(e)}function n(e){e._writableState&&!e._writableState.emitClose||e._readableState&&!e._readableState.emitClose||e.emit("close")}function i(e,t){e.emit("error",t)}t.exports={destroy:function(t,s){var o=this,a=this._readableState&&this._readableState.destroyed,l=this._writableState&&this._writableState.destroyed;return a||l?(s?s(t):t&&(this._writableState?this._writableState.errorEmitted||(this._writableState.errorEmitted=!0,e.nextTick(i,this,t)):e.nextTick(i,this,t)),this):(this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(t||null,(function(t){!s&&t?o._writableState?o._writableState.errorEmitted?e.nextTick(n,o):(o._writableState.errorEmitted=!0,e.nextTick(r,o,t)):e.nextTick(r,o,t):s?(e.nextTick(n,o),s(t)):e.nextTick(n,o)})),this)},undestroy:function(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finalCalled=!1,this._writableState.prefinished=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1)},errorOrDestroy:function(e,t){var r=e._readableState,n=e._writableState;r&&r.autoDestroy||n&&n.autoDestroy?e.destroy(t):e.emit("error",t)}}}).call(this)}).call(this,e("_process"))},{_process:102}],42:[function(e,t,r){"use strict";var n=e("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;function i(){}t.exports=function e(t,r,s){if("function"==typeof r)return e(t,null,r);r||(r={}),s=function(e){var t=!1;return function(){if(!t){t=!0;for(var r=arguments.length,n=new Array(r),i=0;i<r;i++)n[i]=arguments[i];e.apply(this,n)}}}(s||i);var o=r.readable||!1!==r.readable&&t.readable,a=r.writable||!1!==r.writable&&t.writable,l=function(){t.writable||c()},u=t._writableState&&t._writableState.finished,c=function(){a=!1,u=!0,o||s.call(t)},h=t._readableState&&t._readableState.endEmitted,f=function(){o=!1,h=!0,a||s.call(t)},d=function(e){s.call(t,e)},p=function(){var e;return o&&!h?(t._readableState&&t._readableState.ended||(e=new n),s.call(t,e)):a&&!u?(t._writableState&&t._writableState.ended||(e=new n),s.call(t,e)):void 0},b=function(){t.req.on("finish",c)};return!function(e){return e.setHeader&&"function"==typeof e.abort}(t)?a&&!t._writableState&&(t.on("end",l),t.on("close",l)):(t.on("complete",c),t.on("abort",p),t.req?b():t.on("request",b)),t.on("end",f),t.on("finish",c),!1!==r.error&&t.on("error",d),t.on("close",p),function(){t.removeListener("complete",c),t.removeListener("abort",p),t.removeListener("request",b),t.req&&t.req.removeListener("finish",c),t.removeListener("end",l),t.removeListener("close",l),t.removeListener("finish",c),t.removeListener("end",f),t.removeListener("error",d),t.removeListener("close",p)}}},{"../../../errors":33}],43:[function(e,t,r){t.exports=function(){throw new Error("Readable.from is not available in the browser")}},{}],44:[function(e,t,r){"use strict";var n;var i=e("../../../errors").codes,s=i.ERR_MISSING_ARGS,o=i.ERR_STREAM_DESTROYED;function a(e){if(e)throw e}function l(e){e()}function u(e,t){return e.pipe(t)}t.exports=function(){for(var t=arguments.length,r=new Array(t),i=0;i<t;i++)r[i]=arguments[i];var c,h=function(e){return e.length?"function"!=typeof e[e.length-1]?a:e.pop():a}(r);if(Array.isArray(r[0])&&(r=r[0]),r.length<2)throw new s("streams");var f=r.map((function(t,i){var s=i<r.length-1;return function(t,r,i,s){s=function(e){var t=!1;return function(){t||(t=!0,e.apply(void 0,arguments))}}(s);var a=!1;t.on("close",(function(){a=!0})),void 0===n&&(n=e("./end-of-stream")),n(t,{readable:r,writable:i},(function(e){if(e)return s(e);a=!0,s()}));var l=!1;return function(e){if(!a&&!l)return l=!0,function(e){return e.setHeader&&"function"==typeof e.abort}(t)?t.abort():"function"==typeof t.destroy?t.destroy():void s(e||new o("pipe"))}}(t,s,i>0,(function(e){c||(c=e),e&&f.forEach(l),s||(f.forEach(l),h(c))}))}));return r.reduce(u)}},{"../../../errors":33,"./end-of-stream":42}],45:[function(e,t,r){"use strict";var n=e("../../../errors").codes.ERR_INVALID_OPT_VALUE;t.exports={getHighWaterMark:function(e,t,r,i){var s=function(e,t,r){return null!=e.highWaterMark?e.highWaterMark:t?e[r]:null}(t,i,r);if(null!=s){if(!isFinite(s)||Math.floor(s)!==s||s<0)throw new n(i?r:"highWaterMark",s);return Math.floor(s)}return e.objectMode?16:16384}}},{"../../../errors":33}],46:[function(e,t,r){t.exports=e("events").EventEmitter},{events:49}],47:[function(e,t,r){(r=t.exports=e("./lib/_stream_readable.js")).Stream=r,r.Readable=r,r.Writable=e("./lib/_stream_writable.js"),r.Duplex=e("./lib/_stream_duplex.js"),r.Transform=e("./lib/_stream_transform.js"),r.PassThrough=e("./lib/_stream_passthrough.js"),r.finished=e("./lib/internal/streams/end-of-stream.js"),r.pipeline=e("./lib/internal/streams/pipeline.js")},{"./lib/_stream_duplex.js":34,"./lib/_stream_passthrough.js":35,"./lib/_stream_readable.js":36,"./lib/_stream_transform.js":37,"./lib/_stream_writable.js":38,"./lib/internal/streams/end-of-stream.js":42,"./lib/internal/streams/pipeline.js":44}],48:[function(e,t,r){(function(r){(function(){var n=e("once"),i=function(){},s=function(e,t,o){if("function"==typeof t)return s(e,null,t);t||(t={}),o=n(o||i);var a=e._writableState,l=e._readableState,u=t.readable||!1!==t.readable&&e.readable,c=t.writable||!1!==t.writable&&e.writable,h=!1,f=function(){e.writable||d()},d=function(){c=!1,u||o.call(e)},p=function(){u=!1,c||o.call(e)},b=function(t){o.call(e,t?new Error("exited with error code: "+t):null)},g=function(t){o.call(e,t)},m=function(){r.nextTick(y)},y=function(){if(!h)return(!u||l&&l.ended&&!l.destroyed)&&(!c||a&&a.ended&&!a.destroyed)?void 0:o.call(e,new Error("premature close"))},_=function(){e.req.on("finish",d)};return!function(e){return e.setHeader&&"function"==typeof e.abort}(e)?c&&!a&&(e.on("end",f),e.on("close",f)):(e.on("complete",d),e.on("abort",m),e.req?_():e.on("request",_)),function(e){return e.stdio&&Array.isArray(e.stdio)&&3===e.stdio.length}(e)&&e.on("exit",b),e.on("end",p),e.on("finish",d),!1!==t.error&&e.on("error",g),e.on("close",m),function(){h=!0,e.removeListener("complete",d),e.removeListener("abort",m),e.removeListener("request",_),e.req&&e.req.removeListener("finish",d),e.removeListener("end",f),e.removeListener("close",f),e.removeListener("finish",d),e.removeListener("exit",b),e.removeListener("end",p),e.removeListener("error",g),e.removeListener("close",m)}};t.exports=s}).call(this)}).call(this,e("_process"))},{_process:102,once:100}],49:[function(e,t,r){"use strict";var n,i="object"==typeof Reflect?Reflect:null,s=i&&"function"==typeof i.apply?i.apply:function(e,t,r){return Function.prototype.apply.call(e,t,r)};n=i&&"function"==typeof i.ownKeys?i.ownKeys:Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:function(e){return Object.getOwnPropertyNames(e)};var o=Number.isNaN||function(e){return e!=e};function a(){a.init.call(this)}t.exports=a,t.exports.once=function(e,t){return new Promise((function(r,n){function i(r){e.removeListener(t,s),n(r)}function s(){"function"==typeof e.removeListener&&e.removeListener("error",i),r([].slice.call(arguments))}m(e,t,s,{once:!0}),"error"!==t&&function(e,t,r){"function"==typeof e.on&&m(e,"error",t,r)}(e,i,{once:!0})}))},a.EventEmitter=a,a.prototype._events=void 0,a.prototype._eventsCount=0,a.prototype._maxListeners=void 0;var l=10;function u(e){if("function"!=typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e)}function c(e){return void 0===e._maxListeners?a.defaultMaxListeners:e._maxListeners}function h(e,t,r,n){var i,s,o,a;if(u(r),void 0===(s=e._events)?(s=e._events=Object.create(null),e._eventsCount=0):(void 0!==s.newListener&&(e.emit("newListener",t,r.listener?r.listener:r),s=e._events),o=s[t]),void 0===o)o=s[t]=r,++e._eventsCount;else if("function"==typeof o?o=s[t]=n?[r,o]:[o,r]:n?o.unshift(r):o.push(r),(i=c(e))>0&&o.length>i&&!o.warned){o.warned=!0;var l=new Error("Possible EventEmitter memory leak detected. "+o.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");l.name="MaxListenersExceededWarning",l.emitter=e,l.type=t,l.count=o.length,a=l,console&&console.warn&&console.warn(a)}return e}function f(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function d(e,t,r){var n={fired:!1,wrapFn:void 0,target:e,type:t,listener:r},i=f.bind(n);return i.listener=r,n.wrapFn=i,i}function p(e,t,r){var n=e._events;if(void 0===n)return[];var i=n[t];return void 0===i?[]:"function"==typeof i?r?[i.listener||i]:[i]:r?function(e){for(var t=new Array(e.length),r=0;r<t.length;++r)t[r]=e[r].listener||e[r];return t}(i):g(i,i.length)}function b(e){var t=this._events;if(void 0!==t){var r=t[e];if("function"==typeof r)return 1;if(void 0!==r)return r.length}return 0}function g(e,t){for(var r=new Array(t),n=0;n<t;++n)r[n]=e[n];return r}function m(e,t,r,n){if("function"==typeof e.on)n.once?e.once(t,r):e.on(t,r);else{if("function"!=typeof e.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof e);e.addEventListener(t,(function i(s){n.once&&e.removeEventListener(t,i),r(s)}))}}Object.defineProperty(a,"defaultMaxListeners",{enumerable:!0,get:function(){return l},set:function(e){if("number"!=typeof e||e<0||o(e))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");l=e}}),a.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},a.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||o(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this},a.prototype.getMaxListeners=function(){return c(this)},a.prototype.emit=function(e){for(var t=[],r=1;r<arguments.length;r++)t.push(arguments[r]);var n="error"===e,i=this._events;if(void 0!==i)n=n&&void 0===i.error;else if(!n)return!1;if(n){var o;if(t.length>0&&(o=t[0]),o instanceof Error)throw o;var a=new Error("Unhandled error."+(o?" ("+o.message+")":""));throw a.context=o,a}var l=i[e];if(void 0===l)return!1;if("function"==typeof l)s(l,this,t);else{var u=l.length,c=g(l,u);for(r=0;r<u;++r)s(c[r],this,t)}return!0},a.prototype.addListener=function(e,t){return h(this,e,t,!1)},a.prototype.on=a.prototype.addListener,a.prototype.prependListener=function(e,t){return h(this,e,t,!0)},a.prototype.once=function(e,t){return u(t),this.on(e,d(this,e,t)),this},a.prototype.prependOnceListener=function(e,t){return u(t),this.prependListener(e,d(this,e,t)),this},a.prototype.removeListener=function(e,t){var r,n,i,s,o;if(u(t),void 0===(n=this._events))return this;if(void 0===(r=n[e]))return this;if(r===t||r.listener===t)0==--this._eventsCount?this._events=Object.create(null):(delete n[e],n.removeListener&&this.emit("removeListener",e,r.listener||t));else if("function"!=typeof r){for(i=-1,s=r.length-1;s>=0;s--)if(r[s]===t||r[s].listener===t){o=r[s].listener,i=s;break}if(i<0)return this;0===i?r.shift():function(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}(r,i),1===r.length&&(n[e]=r[0]),void 0!==n.removeListener&&this.emit("removeListener",e,o||t)}return this},a.prototype.off=a.prototype.removeListener,a.prototype.removeAllListeners=function(e){var t,r,n;if(void 0===(r=this._events))return this;if(void 0===r.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==r[e]&&(0==--this._eventsCount?this._events=Object.create(null):delete r[e]),this;if(0===arguments.length){var i,s=Object.keys(r);for(n=0;n<s.length;++n)"removeListener"!==(i=s[n])&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(t=r[e]))this.removeListener(e,t);else if(void 0!==t)for(n=t.length-1;n>=0;n--)this.removeListener(e,t[n]);return this},a.prototype.listeners=function(e){return p(this,e,!0)},a.prototype.rawListeners=function(e){return p(this,e,!1)},a.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):b.call(e,t)},a.prototype.listenerCount=b,a.prototype.eventNames=function(){return this._eventsCount>0?n(this._events):[]}},{}],50:[function(e,t,r){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
r.read=function(e,t,r,n,i){var s,o,a=8*i-n-1,l=(1<<a)-1,u=l>>1,c=-7,h=r?i-1:0,f=r?-1:1,d=e[t+h];for(h+=f,s=d&(1<<-c)-1,d>>=-c,c+=a;c>0;s=256*s+e[t+h],h+=f,c-=8);for(o=s&(1<<-c)-1,s>>=-c,c+=n;c>0;o=256*o+e[t+h],h+=f,c-=8);if(0===s)s=1-u;else{if(s===l)return o?NaN:1/0*(d?-1:1);o+=Math.pow(2,n),s-=u}return(d?-1:1)*o*Math.pow(2,s-n)},r.write=function(e,t,r,n,i,s){var o,a,l,u=8*s-i-1,c=(1<<u)-1,h=c>>1,f=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,d=n?0:s-1,p=n?1:-1,b=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(a=isNaN(t)?1:0,o=c):(o=Math.floor(Math.log(t)/Math.LN2),t*(l=Math.pow(2,-o))<1&&(o--,l*=2),(t+=o+h>=1?f/l:f*Math.pow(2,1-h))*l>=2&&(o++,l/=2),o+h>=c?(a=0,o=c):o+h>=1?(a=(t*l-1)*Math.pow(2,i),o+=h):(a=t*Math.pow(2,h-1)*Math.pow(2,i),o=0));i>=8;e[r+d]=255&a,d+=p,a/=256,i-=8);for(o=o<<i|a,u+=i;u>0;e[r+d]=255&o,d+=p,o/=256,u-=8);e[r+d-p]|=128*b}},{}],51:[function(e,t,r){"function"==typeof Object.create?t.exports=function(e,t){t&&(e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}))}:t.exports=function(e,t){if(t){e.super_=t;var r=function(){};r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e}}},{}],52:[function(e,t,r){"use strict";Object.defineProperty(r,"t",{value:!0}),r.ContainerIterator=r.Container=r.Base=void 0;r.ContainerIterator=class{constructor(e=0){this.iteratorType=e}equals(e){return this.o===e.o}};class n{constructor(){this.i=0}get length(){return this.i}size(){return this.i}empty(){return 0===this.i}}r.Base=n;r.Container=class extends n{}},{}],53:[function(e,t,r){"use strict";Object.defineProperty(r,"t",{value:!0}),r.HashContainerIterator=r.HashContainer=void 0;var n,i=e("../../ContainerBase"),s=(n=e("../../../utils/checkObject"))&&n.t?n:{default:n},o=e("../../../utils/throwError");class a extends i.ContainerIterator{constructor(e,t,r){super(r),this.o=e,this.h=t,0===this.iteratorType?(this.pre=function(){return this.o.L===this.h&&(0,o.throwIteratorAccessError)(),this.o=this.o.L,this},this.next=function(){return this.o===this.h&&(0,o.throwIteratorAccessError)(),this.o=this.o.B,this}):(this.pre=function(){return this.o.B===this.h&&(0,o.throwIteratorAccessError)(),this.o=this.o.B,this},this.next=function(){return this.o===this.h&&(0,o.throwIteratorAccessError)(),this.o=this.o.L,this})}}r.HashContainerIterator=a;class l extends i.Container{constructor(){super(),this.H=[],this.g={},this.HASH_TAG=Symbol("@@HASH_TAG"),Object.setPrototypeOf(this.g,null),this.h={},this.h.L=this.h.B=this.p=this._=this.h}V(e){const{L:t,B:r}=e;t.B=r,r.L=t,e===this.p&&(this.p=r),e===this._&&(this._=t),this.i-=1}M(e,t,r){let n;if(void 0===r&&(r=(0,s.default)(e)),r){const r=e[this.HASH_TAG];if(void 0!==r)return this.H[r].l=t,this.i;Object.defineProperty(e,this.HASH_TAG,{value:this.H.length,configurable:!0}),n={u:e,l:t,L:this._,B:this.h},this.H.push(n)}else{const r=this.g[e];if(r)return r.l=t,this.i;n={u:e,l:t,L:this._,B:this.h},this.g[e]=n}return 0===this.i?(this.p=n,this.h.B=n):this._.B=n,this._=n,this.h.L=n,++this.i}I(e,t){if(void 0===t&&(t=(0,s.default)(e)),t){const t=e[this.HASH_TAG];return void 0===t?this.h:this.H[t]}return this.g[e]||this.h}clear(){const e=this.HASH_TAG;this.H.forEach((function(t){delete t.u[e]})),this.H=[],this.g={},Object.setPrototypeOf(this.g,null),this.i=0,this.p=this._=this.h.L=this.h.B=this.h}eraseElementByKey(e,t){let r;if(void 0===t&&(t=(0,s.default)(e)),t){const t=e[this.HASH_TAG];if(void 0===t)return!1;delete e[this.HASH_TAG],r=this.H[t],delete this.H[t]}else{if(r=this.g[e],void 0===r)return!1;delete this.g[e]}return this.V(r),!0}eraseElementByIterator(e){const t=e.o;return t===this.h&&(0,o.throwIteratorAccessError)(),this.V(t),e.next()}eraseElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let t=this.p;for(;e--;)t=t.B;return this.V(t),this.i}}r.HashContainer=l},{"../../../utils/checkObject":70,"../../../utils/throwError":71,"../../ContainerBase":52}],54:[function(e,t,r){"use strict";Object.defineProperty(r,"t",{value:!0}),r.default=void 0;var n,i=e("./Base"),s=(n=e("../../utils/checkObject"))&&n.t?n:{default:n},o=e("../../utils/throwError");class a extends i.HashContainerIterator{constructor(e,t,r,n){super(e,t,n),this.container=r}get pointer(){this.o===this.h&&(0,o.throwIteratorAccessError)();const e=this;return new Proxy([],{get:(t,r)=>"0"===r?e.o.u:"1"===r?e.o.l:void 0,set(t,r,n){if("1"!==r)throw new TypeError("props must be 1");return e.o.l=n,!0}})}copy(){return new a(this.o,this.h,this.container,this.iteratorType)}}class l extends i.HashContainer{constructor(e=[]){super();const t=this;e.forEach((function(e){t.setElement(e[0],e[1])}))}begin(){return new a(this.p,this.h,this)}end(){return new a(this.h,this.h,this)}rBegin(){return new a(this._,this.h,this,1)}rEnd(){return new a(this.h,this.h,this,1)}front(){if(0!==this.i)return[this.p.u,this.p.l]}back(){if(0!==this.i)return[this._.u,this._.l]}setElement(e,t,r){return this.M(e,t,r)}getElementByKey(e,t){if(void 0===t&&(t=(0,s.default)(e)),t){const t=e[this.HASH_TAG];return void 0!==t?this.H[t].l:void 0}const r=this.g[e];return r?r.l:void 0}getElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let t=this.p;for(;e--;)t=t.B;return[t.u,t.l]}find(e,t){const r=this.I(e,t);return new a(r,this.h,this)}forEach(e){let t=0,r=this.p;for(;r!==this.h;)e([r.u,r.l],t++,this),r=r.B}[Symbol.iterator](){return function*(){let e=this.p;for(;e!==this.h;)yield[e.u,e.l],e=e.B}.bind(this)()}}var u=l;r.default=u},{"../../utils/checkObject":70,"../../utils/throwError":71,"./Base":53}],55:[function(e,t,r){"use strict";Object.defineProperty(r,"t",{value:!0}),r.default=void 0;var n=e("./Base"),i=e("../../utils/throwError");class s extends n.HashContainerIterator{constructor(e,t,r,n){super(e,t,n),this.container=r}get pointer(){return this.o===this.h&&(0,i.throwIteratorAccessError)(),this.o.u}copy(){return new s(this.o,this.h,this.container,this.iteratorType)}}class o extends n.HashContainer{constructor(e=[]){super();const t=this;e.forEach((function(e){t.insert(e)}))}begin(){return new s(this.p,this.h,this)}end(){return new s(this.h,this.h,this)}rBegin(){return new s(this._,this.h,this,1)}rEnd(){return new s(this.h,this.h,this,1)}front(){return this.p.u}back(){return this._.u}insert(e,t){return this.M(e,void 0,t)}getElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let t=this.p;for(;e--;)t=t.B;return t.u}find(e,t){const r=this.I(e,t);return new s(r,this.h,this)}forEach(e){let t=0,r=this.p;for(;r!==this.h;)e(r.u,t++,this),r=r.B}[Symbol.iterator](){return function*(){let e=this.p;for(;e!==this.h;)yield e.u,e=e.B}.bind(this)()}}var a=o;r.default=a},{"../../utils/throwError":71,"./Base":53}],56:[function(e,t,r){"use strict";Object.defineProperty(r,"t",{value:!0}),r.default=void 0;var n=e("../ContainerBase");class i extends n.Base{constructor(e=[],t=function(e,t){return e>t?-1:e<t?1:0},r=!0){if(super(),this.v=t,Array.isArray(e))this.C=r?[...e]:e;else{this.C=[];const t=this;e.forEach((function(e){t.C.push(e)}))}this.i=this.C.length;const n=this.i>>1;for(let e=this.i-1>>1;e>=0;--e)this.k(e,n)}m(e){const t=this.C[e];for(;e>0;){const r=e-1>>1,n=this.C[r];if(this.v(n,t)<=0)break;this.C[e]=n,e=r}this.C[e]=t}k(e,t){const r=this.C[e];for(;e<t;){let t=e<<1|1;const n=t+1;let i=this.C[t];if(n<this.i&&this.v(i,this.C[n])>0&&(t=n,i=this.C[n]),this.v(i,r)>=0)break;this.C[e]=i,e=t}this.C[e]=r}clear(){this.i=0,this.C.length=0}push(e){this.C.push(e),this.m(this.i),this.i+=1}pop(){if(0===this.i)return;const e=this.C[0],t=this.C.pop();return this.i-=1,this.i&&(this.C[0]=t,this.k(0,this.i>>1)),e}top(){return this.C[0]}find(e){return this.C.indexOf(e)>=0}remove(e){const t=this.C.indexOf(e);return!(t<0)&&(0===t?this.pop():t===this.i-1?(this.C.pop(),this.i-=1):(this.C.splice(t,1,this.C.pop()),this.i-=1,this.m(t),this.k(t,this.i>>1)),!0)}updateItem(e){const t=this.C.indexOf(e);return!(t<0)&&(this.m(t),this.k(t,this.i>>1),!0)}toArray(){return[...this.C]}}var s=i;r.default=s},{"../ContainerBase":52}],57:[function(e,t,r){"use strict";Object.defineProperty(r,"t",{value:!0}),r.default=void 0;var n=e("../ContainerBase");class i extends n.Base{constructor(e=[]){super(),this.j=0,this.q=[];const t=this;e.forEach((function(e){t.push(e)}))}clear(){this.q=[],this.i=this.j=0}push(e){const t=this.q.length;if(this.j/t>.5&&this.j+this.i>=t&&t>4096){const t=this.i;for(let e=0;e<t;++e)this.q[e]=this.q[this.j+e];this.j=0,this.q[this.i]=e}else this.q[this.j+this.i]=e;return++this.i}pop(){if(0===this.i)return;const e=this.q[this.j++];return this.i-=1,e}front(){if(0!==this.i)return this.q[this.j]}}var s=i;r.default=s},{"../ContainerBase":52}],58:[function(e,t,r){"use strict";Object.defineProperty(r,"t",{value:!0}),r.default=void 0;var n=e("../ContainerBase");class i extends n.Base{constructor(e=[]){super(),this.S=[];const t=this;e.forEach((function(e){t.push(e)}))}clear(){this.i=0,this.S=[]}push(e){return this.S.push(e),this.i+=1,this.i}pop(){if(0!==this.i)return this.i-=1,this.S.pop()}top(){return this.S[this.i-1]}}var s=i;r.default=s},{"../ContainerBase":52}],59:[function(e,t,r){"use strict";Object.defineProperty(r,"t",{value:!0}),r.RandomIterator=void 0;var n=e("../../ContainerBase"),i=e("../../../utils/throwError");class s extends n.ContainerIterator{constructor(e,t){super(t),this.o=e,0===this.iteratorType?(this.pre=function(){return 0===this.o&&(0,i.throwIteratorAccessError)(),this.o-=1,this},this.next=function(){return this.o===this.container.size()&&(0,i.throwIteratorAccessError)(),this.o+=1,this}):(this.pre=function(){return this.o===this.container.size()-1&&(0,i.throwIteratorAccessError)(),this.o+=1,this},this.next=function(){return-1===this.o&&(0,i.throwIteratorAccessError)(),this.o-=1,this})}get pointer(){return this.container.getElementByPos(this.o)}set pointer(e){this.container.setElementByPos(this.o,e)}}r.RandomIterator=s},{"../../../utils/throwError":71,"../../ContainerBase":52}],60:[function(e,t,r){"use strict";Object.defineProperty(r,"t",{value:!0}),r.default=void 0;var n=e("../../ContainerBase");class i extends n.Container{}var s=i;r.default=s},{"../../ContainerBase":52}],61:[function(e,t,r){"use strict";Object.defineProperty(r,"t",{value:!0}),r.default=void 0;var n,i=(n=e("./Base"))&&n.t?n:{default:n},s=e("./Base/RandomIterator");class o extends s.RandomIterator{constructor(e,t,r){super(e,r),this.container=t}copy(){return new o(this.o,this.container,this.iteratorType)}}class a extends i.default{constructor(e=[],t=4096){super(),this.j=0,this.D=0,this.R=0,this.N=0,this.P=0,this.A=[];const r=(()=>{if("number"==typeof e.length)return e.length;if("number"==typeof e.size)return e.size;if("function"==typeof e.size)return e.size();throw new TypeError("Cannot get the length or size of the container")})();this.F=t,this.P=Math.max(Math.ceil(r/this.F),1);for(let e=0;e<this.P;++e)this.A.push(new Array(this.F));const n=Math.ceil(r/this.F);this.j=this.R=(this.P>>1)-(n>>1),this.D=this.N=this.F-r%this.F>>1;const i=this;e.forEach((function(e){i.pushBack(e)}))}T(){const e=[],t=Math.max(this.P>>1,1);for(let r=0;r<t;++r)e[r]=new Array(this.F);for(let t=this.j;t<this.P;++t)e[e.length]=this.A[t];for(let t=0;t<this.R;++t)e[e.length]=this.A[t];e[e.length]=[...this.A[this.R]],this.j=t,this.R=e.length-1;for(let r=0;r<t;++r)e[e.length]=new Array(this.F);this.A=e,this.P=e.length}O(e){const t=this.D+e+1,r=t%this.F;let n=r-1,i=this.j+(t-r)/this.F;return 0===r&&(i-=1),i%=this.P,n<0&&(n+=this.F),{curNodeBucketIndex:i,curNodePointerIndex:n}}clear(){this.A=[new Array(this.F)],this.P=1,this.j=this.R=this.i=0,this.D=this.N=this.F>>1}begin(){return new o(0,this)}end(){return new o(this.i,this)}rBegin(){return new o(this.i-1,this,1)}rEnd(){return new o(-1,this,1)}front(){if(0!==this.i)return this.A[this.j][this.D]}back(){if(0!==this.i)return this.A[this.R][this.N]}pushBack(e){return this.i&&(this.N<this.F-1?this.N+=1:this.R<this.P-1?(this.R+=1,this.N=0):(this.R=0,this.N=0),this.R===this.j&&this.N===this.D&&this.T()),this.i+=1,this.A[this.R][this.N]=e,this.i}popBack(){if(0===this.i)return;const e=this.A[this.R][this.N];return 1!==this.i&&(this.N>0?this.N-=1:this.R>0?(this.R-=1,this.N=this.F-1):(this.R=this.P-1,this.N=this.F-1)),this.i-=1,e}pushFront(e){return this.i&&(this.D>0?this.D-=1:this.j>0?(this.j-=1,this.D=this.F-1):(this.j=this.P-1,this.D=this.F-1),this.j===this.R&&this.D===this.N&&this.T()),this.i+=1,this.A[this.j][this.D]=e,this.i}popFront(){if(0===this.i)return;const e=this.A[this.j][this.D];return 1!==this.i&&(this.D<this.F-1?this.D+=1:this.j<this.P-1?(this.j+=1,this.D=0):(this.j=0,this.D=0)),this.i-=1,e}getElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;const{curNodeBucketIndex:t,curNodePointerIndex:r}=this.O(e);return this.A[t][r]}setElementByPos(e,t){if(e<0||e>this.i-1)throw new RangeError;const{curNodeBucketIndex:r,curNodePointerIndex:n}=this.O(e);this.A[r][n]=t}insert(e,t,r=1){if(e<0||e>this.i)throw new RangeError;if(0===e)for(;r--;)this.pushFront(t);else if(e===this.i)for(;r--;)this.pushBack(t);else{const n=[];for(let t=e;t<this.i;++t)n.push(this.getElementByPos(t));this.cut(e-1);for(let e=0;e<r;++e)this.pushBack(t);for(let e=0;e<n.length;++e)this.pushBack(n[e])}return this.i}cut(e){if(e<0)return this.clear(),0;const{curNodeBucketIndex:t,curNodePointerIndex:r}=this.O(e);return this.R=t,this.N=r,this.i=e+1,this.i}eraseElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;if(0===e)this.popFront();else if(e===this.i-1)this.popBack();else{const t=[];for(let r=e+1;r<this.i;++r)t.push(this.getElementByPos(r));this.cut(e),this.popBack();const r=this;t.forEach((function(e){r.pushBack(e)}))}return this.i}eraseElementByValue(e){if(0===this.i)return 0;const t=[];for(let r=0;r<this.i;++r){const n=this.getElementByPos(r);n!==e&&t.push(n)}const r=t.length;for(let e=0;e<r;++e)this.setElementByPos(e,t[e]);return this.cut(r-1)}eraseElementByIterator(e){const t=e.o;return this.eraseElementByPos(t),e=e.next()}find(e){for(let t=0;t<this.i;++t)if(this.getElementByPos(t)===e)return new o(t,this);return this.end()}reverse(){let e=0,t=this.i-1;for(;e<t;){const r=this.getElementByPos(e);this.setElementByPos(e,this.getElementByPos(t)),this.setElementByPos(t,r),e+=1,t-=1}}unique(){if(this.i<=1)return this.i;let e=1,t=this.getElementByPos(0);for(let r=1;r<this.i;++r){const n=this.getElementByPos(r);n!==t&&(t=n,this.setElementByPos(e++,n))}for(;this.i>e;)this.popBack();return this.i}sort(e){const t=[];for(let e=0;e<this.i;++e)t.push(this.getElementByPos(e));t.sort(e);for(let e=0;e<this.i;++e)this.setElementByPos(e,t[e])}shrinkToFit(){if(0===this.i)return;const e=[];this.forEach((function(t){e.push(t)})),this.P=Math.max(Math.ceil(this.i/this.F),1),this.i=this.j=this.R=this.D=this.N=0,this.A=[];for(let e=0;e<this.P;++e)this.A.push(new Array(this.F));for(let t=0;t<e.length;++t)this.pushBack(e[t])}forEach(e){for(let t=0;t<this.i;++t)e(this.getElementByPos(t),t,this)}[Symbol.iterator](){return function*(){for(let e=0;e<this.i;++e)yield this.getElementByPos(e)}.bind(this)()}}var l=a;r.default=l},{"./Base":60,"./Base/RandomIterator":59}],62:[function(e,t,r){"use strict";Object.defineProperty(r,"t",{value:!0}),r.default=void 0;var n,i=(n=e("./Base"))&&n.t?n:{default:n},s=e("../ContainerBase"),o=e("../../utils/throwError");class a extends s.ContainerIterator{constructor(e,t,r,n){super(n),this.o=e,this.h=t,this.container=r,0===this.iteratorType?(this.pre=function(){return this.o.L===this.h&&(0,o.throwIteratorAccessError)(),this.o=this.o.L,this},this.next=function(){return this.o===this.h&&(0,o.throwIteratorAccessError)(),this.o=this.o.B,this}):(this.pre=function(){return this.o.B===this.h&&(0,o.throwIteratorAccessError)(),this.o=this.o.B,this},this.next=function(){return this.o===this.h&&(0,o.throwIteratorAccessError)(),this.o=this.o.L,this})}get pointer(){return this.o===this.h&&(0,o.throwIteratorAccessError)(),this.o.l}set pointer(e){this.o===this.h&&(0,o.throwIteratorAccessError)(),this.o.l=e}copy(){return new a(this.o,this.h,this.container,this.iteratorType)}}class l extends i.default{constructor(e=[]){super(),this.h={},this.p=this._=this.h.L=this.h.B=this.h;const t=this;e.forEach((function(e){t.pushBack(e)}))}V(e){const{L:t,B:r}=e;t.B=r,r.L=t,e===this.p&&(this.p=r),e===this._&&(this._=t),this.i-=1}G(e,t){const r=t.B,n={l:e,L:t,B:r};t.B=n,r.L=n,t===this.h&&(this.p=n),r===this.h&&(this._=n),this.i+=1}clear(){this.i=0,this.p=this._=this.h.L=this.h.B=this.h}begin(){return new a(this.p,this.h,this)}end(){return new a(this.h,this.h,this)}rBegin(){return new a(this._,this.h,this,1)}rEnd(){return new a(this.h,this.h,this,1)}front(){return this.p.l}back(){return this._.l}getElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let t=this.p;for(;e--;)t=t.B;return t.l}eraseElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let t=this.p;for(;e--;)t=t.B;return this.V(t),this.i}eraseElementByValue(e){let t=this.p;for(;t!==this.h;)t.l===e&&this.V(t),t=t.B;return this.i}eraseElementByIterator(e){const t=e.o;return t===this.h&&(0,o.throwIteratorAccessError)(),e=e.next(),this.V(t),e}pushBack(e){return this.G(e,this._),this.i}popBack(){if(0===this.i)return;const e=this._.l;return this.V(this._),e}pushFront(e){return this.G(e,this.h),this.i}popFront(){if(0===this.i)return;const e=this.p.l;return this.V(this.p),e}setElementByPos(e,t){if(e<0||e>this.i-1)throw new RangeError;let r=this.p;for(;e--;)r=r.B;r.l=t}insert(e,t,r=1){if(e<0||e>this.i)throw new RangeError;if(r<=0)return this.i;if(0===e)for(;r--;)this.pushFront(t);else if(e===this.i)for(;r--;)this.pushBack(t);else{let n=this.p;for(let t=1;t<e;++t)n=n.B;const i=n.B;for(this.i+=r;r--;)n.B={l:t,L:n},n.B.L=n,n=n.B;n.B=i,i.L=n}return this.i}find(e){let t=this.p;for(;t!==this.h;){if(t.l===e)return new a(t,this.h,this);t=t.B}return this.end()}reverse(){if(this.i<=1)return;let e=this.p,t=this._,r=0;for(;r<<1<this.i;){const n=e.l;e.l=t.l,t.l=n,e=e.B,t=t.L,r+=1}}unique(){if(this.i<=1)return this.i;let e=this.p;for(;e!==this.h;){let t=e;for(;t.B!==this.h&&t.l===t.B.l;)t=t.B,this.i-=1;e.B=t.B,e.B.L=e,e=e.B}return this.i}sort(e){if(this.i<=1)return;const t=[];this.forEach((function(e){t.push(e)})),t.sort(e);let r=this.p;t.forEach((function(e){r.l=e,r=r.B}))}merge(e){const t=this;if(0===this.i)e.forEach((function(e){t.pushBack(e)}));else{let r=this.p;e.forEach((function(e){for(;r!==t.h&&r.l<=e;)r=r.B;t.G(e,r.L)}))}return this.i}forEach(e){let t=this.p,r=0;for(;t!==this.h;)e(t.l,r++,this),t=t.B}[Symbol.iterator](){return function*(){if(0===this.i)return;let e=this.p;for(;e!==this.h;)yield e.l,e=e.B}.bind(this)()}}var u=l;r.default=u},{"../../utils/throwError":71,"../ContainerBase":52,"./Base":60}],63:[function(e,t,r){"use strict";Object.defineProperty(r,"t",{value:!0}),r.default=void 0;var n,i=(n=e("./Base"))&&n.t?n:{default:n},s=e("./Base/RandomIterator");class o extends s.RandomIterator{constructor(e,t,r){super(e,r),this.container=t}copy(){return new o(this.o,this.container,this.iteratorType)}}class a extends i.default{constructor(e=[],t=!0){if(super(),Array.isArray(e))this.J=t?[...e]:e,this.i=e.length;else{this.J=[];const t=this;e.forEach((function(e){t.pushBack(e)}))}}clear(){this.i=0,this.J.length=0}begin(){return new o(0,this)}end(){return new o(this.i,this)}rBegin(){return new o(this.i-1,this,1)}rEnd(){return new o(-1,this,1)}front(){return this.J[0]}back(){return this.J[this.i-1]}getElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;return this.J[e]}eraseElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;return this.J.splice(e,1),this.i-=1,this.i}eraseElementByValue(e){let t=0;for(let r=0;r<this.i;++r)this.J[r]!==e&&(this.J[t++]=this.J[r]);return this.i=this.J.length=t,this.i}eraseElementByIterator(e){const t=e.o;return e=e.next(),this.eraseElementByPos(t),e}pushBack(e){return this.J.push(e),this.i+=1,this.i}popBack(){if(0!==this.i)return this.i-=1,this.J.pop()}setElementByPos(e,t){if(e<0||e>this.i-1)throw new RangeError;this.J[e]=t}insert(e,t,r=1){if(e<0||e>this.i)throw new RangeError;return this.J.splice(e,0,...new Array(r).fill(t)),this.i+=r,this.i}find(e){for(let t=0;t<this.i;++t)if(this.J[t]===e)return new o(t,this);return this.end()}reverse(){this.J.reverse()}unique(){let e=1;for(let t=1;t<this.i;++t)this.J[t]!==this.J[t-1]&&(this.J[e++]=this.J[t]);return this.i=this.J.length=e,this.i}sort(e){this.J.sort(e)}forEach(e){for(let t=0;t<this.i;++t)e(this.J[t],t,this)}[Symbol.iterator](){return function*(){yield*this.J}.bind(this)()}}var l=a;r.default=l},{"./Base":60,"./Base/RandomIterator":59}],64:[function(e,t,r){"use strict";Object.defineProperty(r,"t",{value:!0}),r.default=void 0;var n=e("../../ContainerBase"),i=e("../../../utils/throwError");class s extends n.ContainerIterator{constructor(e,t,r){super(r),this.o=e,this.h=t,0===this.iteratorType?(this.pre=function(){return this.o===this.h.U&&(0,i.throwIteratorAccessError)(),this.o=this.o.L(),this},this.next=function(){return this.o===this.h&&(0,i.throwIteratorAccessError)(),this.o=this.o.B(),this}):(this.pre=function(){return this.o===this.h.W&&(0,i.throwIteratorAccessError)(),this.o=this.o.B(),this},this.next=function(){return this.o===this.h&&(0,i.throwIteratorAccessError)(),this.o=this.o.L(),this})}get index(){let e=this.o;const t=this.h.tt;if(e===this.h)return t?t.rt-1:0;let r=0;for(e.U&&(r+=e.U.rt);e!==t;){const t=e.tt;e===t.W&&(r+=1,t.U&&(r+=t.U.rt)),e=t}return r}}var o=s;r.default=o},{"../../../utils/throwError":71,"../../ContainerBase":52}],65:[function(e,t,r){"use strict";Object.defineProperty(r,"t",{value:!0}),r.TreeNodeEnableIndex=r.TreeNode=void 0;class n{constructor(e,t){this.ee=1,this.u=void 0,this.l=void 0,this.U=void 0,this.W=void 0,this.tt=void 0,this.u=e,this.l=t}L(){let e=this;if(1===e.ee&&e.tt.tt===e)e=e.W;else if(e.U)for(e=e.U;e.W;)e=e.W;else{let t=e.tt;for(;t.U===e;)e=t,t=e.tt;e=t}return e}B(){let e=this;if(e.W){for(e=e.W;e.U;)e=e.U;return e}{let t=e.tt;for(;t.W===e;)e=t,t=e.tt;return e.W!==t?t:e}}te(){const e=this.tt,t=this.W,r=t.U;return e.tt===this?e.tt=t:e.U===this?e.U=t:e.W=t,t.tt=e,t.U=this,this.tt=t,this.W=r,r&&(r.tt=this),t}se(){const e=this.tt,t=this.U,r=t.W;return e.tt===this?e.tt=t:e.U===this?e.U=t:e.W=t,t.tt=e,t.W=this,this.tt=t,this.U=r,r&&(r.tt=this),t}}r.TreeNode=n;r.TreeNodeEnableIndex=class extends n{constructor(){super(...arguments),this.rt=1}te(){const e=super.te();return this.ie(),e.ie(),e}se(){const e=super.se();return this.ie(),e.ie(),e}ie(){this.rt=1,this.U&&(this.rt+=this.U.rt),this.W&&(this.rt+=this.W.rt)}}},{}],66:[function(e,t,r){"use strict";Object.defineProperty(r,"t",{value:!0}),r.default=void 0;var n=e("./TreeNode"),i=e("../../ContainerBase"),s=e("../../../utils/throwError");class o extends i.Container{constructor(e=function(e,t){return e<t?-1:e>t?1:0},t=!1){super(),this.Y=void 0,this.v=e,t?(this.re=n.TreeNodeEnableIndex,this.M=function(e,t,r){const n=this.ne(e,t,r);if(n){let e=n.tt;for(;e!==this.h;)e.rt+=1,e=e.tt;const t=this.he(n);if(t){const{parentNode:e,grandParent:r,curNode:n}=t;e.ie(),r.ie(),n.ie()}}return this.i},this.V=function(e){let t=this.fe(e);for(;t!==this.h;)t.rt-=1,t=t.tt}):(this.re=n.TreeNode,this.M=function(e,t,r){const n=this.ne(e,t,r);return n&&this.he(n),this.i},this.V=this.fe),this.h=new this.re}X(e,t){let r=this.h;for(;e;){const n=this.v(e.u,t);if(n<0)e=e.W;else{if(!(n>0))return e;r=e,e=e.U}}return r}Z(e,t){let r=this.h;for(;e;){this.v(e.u,t)<=0?e=e.W:(r=e,e=e.U)}return r}$(e,t){let r=this.h;for(;e;){const n=this.v(e.u,t);if(n<0)r=e,e=e.W;else{if(!(n>0))return e;e=e.U}}return r}rr(e,t){let r=this.h;for(;e;){this.v(e.u,t)<0?(r=e,e=e.W):e=e.U}return r}ue(e){for(;;){const t=e.tt;if(t===this.h)return;if(1===e.ee)return void(e.ee=0);if(e===t.U){const r=t.W;if(1===r.ee)r.ee=0,t.ee=1,t===this.Y?this.Y=t.te():t.te();else{if(r.W&&1===r.W.ee)return r.ee=t.ee,t.ee=0,r.W.ee=0,void(t===this.Y?this.Y=t.te():t.te());r.U&&1===r.U.ee?(r.ee=1,r.U.ee=0,r.se()):(r.ee=1,e=t)}}else{const r=t.U;if(1===r.ee)r.ee=0,t.ee=1,t===this.Y?this.Y=t.se():t.se();else{if(r.U&&1===r.U.ee)return r.ee=t.ee,t.ee=0,r.U.ee=0,void(t===this.Y?this.Y=t.se():t.se());r.W&&1===r.W.ee?(r.ee=1,r.W.ee=0,r.te()):(r.ee=1,e=t)}}}}fe(e){if(1===this.i)return this.clear(),this.h;let t=e;for(;t.U||t.W;){if(t.W)for(t=t.W;t.U;)t=t.U;else t=t.U;[e.u,t.u]=[t.u,e.u],[e.l,t.l]=[t.l,e.l],e=t}this.h.U===t?this.h.U=t.tt:this.h.W===t&&(this.h.W=t.tt),this.ue(t);const r=t.tt;return t===r.U?r.U=void 0:r.W=void 0,this.i-=1,this.Y.ee=0,r}oe(e,t){if(void 0===e)return!1;return!!this.oe(e.U,t)||(!!t(e)||this.oe(e.W,t))}he(e){for(;;){const t=e.tt;if(0===t.ee)return;const r=t.tt;if(t===r.U){const n=r.W;if(n&&1===n.ee){if(n.ee=t.ee=0,r===this.Y)return;r.ee=1,e=r;continue}if(e===t.W){if(e.ee=0,e.U&&(e.U.tt=t),e.W&&(e.W.tt=r),t.W=e.U,r.U=e.W,e.U=t,e.W=r,r===this.Y)this.Y=e,this.h.tt=e;else{const t=r.tt;t.U===r?t.U=e:t.W=e}return e.tt=r.tt,t.tt=e,r.tt=e,r.ee=1,{parentNode:t,grandParent:r,curNode:e}}t.ee=0,r===this.Y?this.Y=r.se():r.se(),r.ee=1}else{const n=r.U;if(n&&1===n.ee){if(n.ee=t.ee=0,r===this.Y)return;r.ee=1,e=r;continue}if(e===t.U){if(e.ee=0,e.U&&(e.U.tt=r),e.W&&(e.W.tt=t),r.W=e.U,t.U=e.W,e.U=r,e.W=t,r===this.Y)this.Y=e,this.h.tt=e;else{const t=r.tt;t.U===r?t.U=e:t.W=e}return e.tt=r.tt,t.tt=e,r.tt=e,r.ee=1,{parentNode:t,grandParent:r,curNode:e}}t.ee=0,r===this.Y?this.Y=r.te():r.te(),r.ee=1}return}}ne(e,t,r){if(void 0===this.Y)return this.i+=1,this.Y=new this.re(e,t),this.Y.ee=0,this.Y.tt=this.h,this.h.tt=this.Y,this.h.U=this.Y,void(this.h.W=this.Y);let n;const i=this.h.U,s=this.v(i.u,e);if(0!==s){if(s>0)i.U=new this.re(e,t),i.U.tt=i,n=i.U,this.h.U=n;else{const i=this.h.W,s=this.v(i.u,e);if(0===s)return void(i.l=t);if(s<0)i.W=new this.re(e,t),i.W.tt=i,n=i.W,this.h.W=n;else{if(void 0!==r){const i=r.o;if(i!==this.h){const r=this.v(i.u,e);if(0===r)return void(i.l=t);if(r>0){const r=i.L(),s=this.v(r.u,e);if(0===s)return void(r.l=t);s<0&&(n=new this.re(e,t),void 0===r.W?(r.W=n,n.tt=r):(i.U=n,n.tt=i))}}}if(void 0===n)for(n=this.Y;;){const r=this.v(n.u,e);if(r>0){if(void 0===n.U){n.U=new this.re(e,t),n.U.tt=n,n=n.U;break}n=n.U}else{if(!(r<0))return void(n.l=t);if(void 0===n.W){n.W=new this.re(e,t),n.W.tt=n,n=n.W;break}n=n.W}}}}return this.i+=1,n}i.l=t}I(e,t){for(;e;){const r=this.v(e.u,t);if(r<0)e=e.W;else{if(!(r>0))return e;e=e.U}}return e||this.h}clear(){this.i=0,this.Y=void 0,this.h.tt=void 0,this.h.U=this.h.W=void 0}updateKeyByIterator(e,t){const r=e.o;if(r===this.h&&(0,s.throwIteratorAccessError)(),1===this.i)return r.u=t,!0;if(r===this.h.U)return this.v(r.B().u,t)>0&&(r.u=t,!0);if(r===this.h.W)return this.v(r.L().u,t)<0&&(r.u=t,!0);const n=r.L().u;if(this.v(n,t)>=0)return!1;const i=r.B().u;return!(this.v(i,t)<=0)&&(r.u=t,!0)}eraseElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let t=0;const r=this;return this.oe(this.Y,(function(n){return e===t?(r.V(n),!0):(t+=1,!1)})),this.i}eraseElementByKey(e){if(0===this.i)return!1;const t=this.I(this.Y,e);return t!==this.h&&(this.V(t),!0)}eraseElementByIterator(e){const t=e.o;t===this.h&&(0,s.throwIteratorAccessError)();const r=void 0===t.W;return 0===e.iteratorType?r&&e.next():r&&void 0!==t.U||e.next(),this.V(t),e}forEach(e){let t=0;for(const r of this)e(r,t++,this)}getElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let t,r=0;for(const n of this){if(r===e){t=n;break}r+=1}return t}getHeight(){if(0===this.i)return 0;const e=function(t){return t?Math.max(e(t.U),e(t.W))+1:0};return e(this.Y)}}var a=o;r.default=a},{"../../../utils/throwError":71,"../../ContainerBase":52,"./TreeNode":65}],67:[function(e,t,r){"use strict";Object.defineProperty(r,"t",{value:!0}),r.default=void 0;var n=o(e("./Base")),i=o(e("./Base/TreeIterator")),s=e("../../utils/throwError");function o(e){return e&&e.t?e:{default:e}}class a extends i.default{constructor(e,t,r,n){super(e,t,n),this.container=r}get pointer(){this.o===this.h&&(0,s.throwIteratorAccessError)();const e=this;return new Proxy([],{get:(t,r)=>"0"===r?e.o.u:"1"===r?e.o.l:void 0,set(t,r,n){if("1"!==r)throw new TypeError("props must be 1");return e.o.l=n,!0}})}copy(){return new a(this.o,this.h,this.container,this.iteratorType)}}class l extends n.default{constructor(e=[],t,r){super(t,r);const n=this;e.forEach((function(e){n.setElement(e[0],e[1])}))}*K(e){void 0!==e&&(yield*this.K(e.U),yield[e.u,e.l],yield*this.K(e.W))}begin(){return new a(this.h.U||this.h,this.h,this)}end(){return new a(this.h,this.h,this)}rBegin(){return new a(this.h.W||this.h,this.h,this,1)}rEnd(){return new a(this.h,this.h,this,1)}front(){if(0===this.i)return;const e=this.h.U;return[e.u,e.l]}back(){if(0===this.i)return;const e=this.h.W;return[e.u,e.l]}lowerBound(e){const t=this.X(this.Y,e);return new a(t,this.h,this)}upperBound(e){const t=this.Z(this.Y,e);return new a(t,this.h,this)}reverseLowerBound(e){const t=this.$(this.Y,e);return new a(t,this.h,this)}reverseUpperBound(e){const t=this.rr(this.Y,e);return new a(t,this.h,this)}setElement(e,t,r){return this.M(e,t,r)}find(e){const t=this.I(this.Y,e);return new a(t,this.h,this)}getElementByKey(e){return this.I(this.Y,e).l}union(e){const t=this;return e.forEach((function(e){t.setElement(e[0],e[1])})),this.i}[Symbol.iterator](){return this.K(this.Y)}}var u=l;r.default=u},{"../../utils/throwError":71,"./Base":66,"./Base/TreeIterator":64}],68:[function(e,t,r){"use strict";Object.defineProperty(r,"t",{value:!0}),r.default=void 0;var n=o(e("./Base")),i=o(e("./Base/TreeIterator")),s=e("../../utils/throwError");function o(e){return e&&e.t?e:{default:e}}class a extends i.default{constructor(e,t,r,n){super(e,t,n),this.container=r}get pointer(){return this.o===this.h&&(0,s.throwIteratorAccessError)(),this.o.u}copy(){return new a(this.o,this.h,this.container,this.iteratorType)}}class l extends n.default{constructor(e=[],t,r){super(t,r);const n=this;e.forEach((function(e){n.insert(e)}))}*K(e){void 0!==e&&(yield*this.K(e.U),yield e.u,yield*this.K(e.W))}begin(){return new a(this.h.U||this.h,this.h,this)}end(){return new a(this.h,this.h,this)}rBegin(){return new a(this.h.W||this.h,this.h,this,1)}rEnd(){return new a(this.h,this.h,this,1)}front(){return this.h.U?this.h.U.u:void 0}back(){return this.h.W?this.h.W.u:void 0}insert(e,t){return this.M(e,void 0,t)}find(e){const t=this.I(this.Y,e);return new a(t,this.h,this)}lowerBound(e){const t=this.X(this.Y,e);return new a(t,this.h,this)}upperBound(e){const t=this.Z(this.Y,e);return new a(t,this.h,this)}reverseLowerBound(e){const t=this.$(this.Y,e);return new a(t,this.h,this)}reverseUpperBound(e){const t=this.rr(this.Y,e);return new a(t,this.h,this)}union(e){const t=this;return e.forEach((function(e){t.insert(e)})),this.i}[Symbol.iterator](){return this.K(this.Y)}}var u=l;r.default=u},{"../../utils/throwError":71,"./Base":66,"./Base/TreeIterator":64}],69:[function(e,t,r){"use strict";Object.defineProperty(r,"t",{value:!0}),Object.defineProperty(r,"Deque",{enumerable:!0,get:function(){return l.default}}),Object.defineProperty(r,"HashMap",{enumerable:!0,get:function(){return f.default}}),Object.defineProperty(r,"HashSet",{enumerable:!0,get:function(){return h.default}}),Object.defineProperty(r,"LinkList",{enumerable:!0,get:function(){return a.default}}),Object.defineProperty(r,"OrderedMap",{enumerable:!0,get:function(){return c.default}}),Object.defineProperty(r,"OrderedSet",{enumerable:!0,get:function(){return u.default}}),Object.defineProperty(r,"PriorityQueue",{enumerable:!0,get:function(){return s.default}}),Object.defineProperty(r,"Queue",{enumerable:!0,get:function(){return i.default}}),Object.defineProperty(r,"Stack",{enumerable:!0,get:function(){return n.default}}),Object.defineProperty(r,"Vector",{enumerable:!0,get:function(){return o.default}});var n=d(e("./container/OtherContainer/Stack")),i=d(e("./container/OtherContainer/Queue")),s=d(e("./container/OtherContainer/PriorityQueue")),o=d(e("./container/SequentialContainer/Vector")),a=d(e("./container/SequentialContainer/LinkList")),l=d(e("./container/SequentialContainer/Deque")),u=d(e("./container/TreeContainer/OrderedSet")),c=d(e("./container/TreeContainer/OrderedMap")),h=d(e("./container/HashContainer/HashSet")),f=d(e("./container/HashContainer/HashMap"));function d(e){return e&&e.t?e:{default:e}}},{"./container/HashContainer/HashMap":54,"./container/HashContainer/HashSet":55,"./container/OtherContainer/PriorityQueue":56,"./container/OtherContainer/Queue":57,"./container/OtherContainer/Stack":58,"./container/SequentialContainer/Deque":61,"./container/SequentialContainer/LinkList":62,"./container/SequentialContainer/Vector":63,"./container/TreeContainer/OrderedMap":67,"./container/TreeContainer/OrderedSet":68}],70:[function(e,t,r){"use strict";Object.defineProperty(r,"t",{value:!0}),r.default=function(e){const t=typeof e;return"object"===t&&null!==e||"function"===t}},{}],71:[function(e,t,r){"use strict";Object.defineProperty(r,"t",{value:!0}),r.throwIteratorAccessError=function(){throw new RangeError("Iterator access denied!")}},{}],72:[function(e,t,r){(function(e){(function(){const r="object"==typeof performance&&performance&&"function"==typeof performance.now?performance:Date,n="function"==typeof AbortController?AbortController:class{constructor(){this.signal=new o}abort(e=new Error("This operation was aborted")){this.signal.reason=this.signal.reason||e,this.signal.aborted=!0,this.signal.dispatchEvent({type:"abort",target:this.signal})}},i="function"==typeof AbortSignal,s="function"==typeof n.AbortSignal,o=i?AbortSignal:s?n.AbortController:class{constructor(){this.reason=void 0,this.aborted=!1,this._listeners=[]}dispatchEvent(e){"abort"===e.type&&(this.aborted=!0,this.onabort(e),this._listeners.forEach((t=>t(e)),this))}onabort(){}addEventListener(e,t){"abort"===e&&this._listeners.push(t)}removeEventListener(e,t){"abort"===e&&(this._listeners=this._listeners.filter((e=>e!==t)))}},a=new Set,l=(e,t)=>{const r=`LRU_CACHE_OPTION_${e}`;h(r)&&f(r,`${e} option`,`options.${t}`,m)},u=(e,t)=>{const r=`LRU_CACHE_METHOD_${e}`;if(h(r)){const{prototype:n}=m,{get:i}=Object.getOwnPropertyDescriptor(n,e);f(r,`${e} method`,`cache.${t}()`,i)}},c=(...t)=>{"object"==typeof e&&e&&"function"==typeof e.emitWarning?e.emitWarning(...t):console.error(...t)},h=e=>!a.has(e),f=(e,t,r,n)=>{a.add(e);c(`The ${t} is deprecated. Please use ${r} instead.`,"DeprecationWarning",e,n)},d=e=>e&&e===Math.floor(e)&&e>0&&isFinite(e),p=e=>d(e)?e<=Math.pow(2,8)?Uint8Array:e<=Math.pow(2,16)?Uint16Array:e<=Math.pow(2,32)?Uint32Array:e<=Number.MAX_SAFE_INTEGER?b:null:null;class b extends Array{constructor(e){super(e),this.fill(0)}}class g{constructor(e){if(0===e)return[];const t=p(e);this.heap=new t(e),this.length=0}push(e){this.heap[this.length++]=e}pop(){return this.heap[--this.length]}}class m{constructor(e={}){const{max:t=0,ttl:r,ttlResolution:n=1,ttlAutopurge:i,updateAgeOnGet:s,updateAgeOnHas:o,allowStale:u,dispose:f,disposeAfter:b,noDisposeOnSet:y,noUpdateTTL:_,maxSize:w=0,maxEntrySize:v=0,sizeCalculation:S,fetchMethod:E,fetchContext:A,noDeleteOnFetchRejection:k,noDeleteOnStaleGet:T,allowStaleOnFetchRejection:I,allowStaleOnFetchAbort:R,ignoreFetchAbort:O}=e,{length:C,maxAge:P,stale:x}=e instanceof m?{}:e;if(0!==t&&!d(t))throw new TypeError("max option must be a nonnegative integer");const M=t?p(t):Array;if(!M)throw new Error("invalid max value: "+t);if(this.max=t,this.maxSize=w,this.maxEntrySize=v||this.maxSize,this.sizeCalculation=S||C,this.sizeCalculation){if(!this.maxSize&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if("function"!=typeof this.sizeCalculation)throw new TypeError("sizeCalculation set to non-function")}if(this.fetchMethod=E||null,this.fetchMethod&&"function"!=typeof this.fetchMethod)throw new TypeError("fetchMethod must be a function if specified");if(this.fetchContext=A,!this.fetchMethod&&void 0!==A)throw new TypeError("cannot set fetchContext without fetchMethod");if(this.keyMap=new Map,this.keyList=new Array(t).fill(null),this.valList=new Array(t).fill(null),this.next=new M(t),this.prev=new M(t),this.head=0,this.tail=0,this.free=new g(t),this.initialFill=1,this.size=0,"function"==typeof f&&(this.dispose=f),"function"==typeof b?(this.disposeAfter=b,this.disposed=[]):(this.disposeAfter=null,this.disposed=null),this.noDisposeOnSet=!!y,this.noUpdateTTL=!!_,this.noDeleteOnFetchRejection=!!k,this.allowStaleOnFetchRejection=!!I,this.allowStaleOnFetchAbort=!!R,this.ignoreFetchAbort=!!O,0!==this.maxEntrySize){if(0!==this.maxSize&&!d(this.maxSize))throw new TypeError("maxSize must be a positive integer if specified");if(!d(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");this.initializeSizeTracking()}if(this.allowStale=!!u||!!x,this.noDeleteOnStaleGet=!!T,this.updateAgeOnGet=!!s,this.updateAgeOnHas=!!o,this.ttlResolution=d(n)||0===n?n:1,this.ttlAutopurge=!!i,this.ttl=r||P||0,this.ttl){if(!d(this.ttl))throw new TypeError("ttl must be a positive integer if specified");this.initializeTTLTracking()}if(0===this.max&&0===this.ttl&&0===this.maxSize)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.max&&!this.maxSize){const e="LRU_CACHE_UNBOUNDED";if(h(e)){a.add(e);c("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",e,m)}}x&&l("stale","allowStale"),P&&l("maxAge","ttl"),C&&l("length","sizeCalculation")}getRemainingTTL(e){return this.has(e,{updateAgeOnHas:!1})?1/0:0}initializeTTLTracking(){this.ttls=new b(this.max),this.starts=new b(this.max),this.setItemTTL=(e,t,n=r.now())=>{if(this.starts[e]=0!==t?n:0,this.ttls[e]=t,0!==t&&this.ttlAutopurge){const r=setTimeout((()=>{this.isStale(e)&&this.delete(this.keyList[e])}),t+1);r.unref&&r.unref()}},this.updateItemAge=e=>{this.starts[e]=0!==this.ttls[e]?r.now():0},this.statusTTL=(r,n)=>{r&&(r.ttl=this.ttls[n],r.start=this.starts[n],r.now=e||t(),r.remainingTTL=r.now+r.ttl-r.start)};let e=0;const t=()=>{const t=r.now();if(this.ttlResolution>0){e=t;const r=setTimeout((()=>e=0),this.ttlResolution);r.unref&&r.unref()}return t};this.getRemainingTTL=r=>{const n=this.keyMap.get(r);return void 0===n?0:0===this.ttls[n]||0===this.starts[n]?1/0:this.starts[n]+this.ttls[n]-(e||t())},this.isStale=r=>0!==this.ttls[r]&&0!==this.starts[r]&&(e||t())-this.starts[r]>this.ttls[r]}updateItemAge(e){}statusTTL(e,t){}setItemTTL(e,t,r){}isStale(e){return!1}initializeSizeTracking(){this.calculatedSize=0,this.sizes=new b(this.max),this.removeItemSize=e=>{this.calculatedSize-=this.sizes[e],this.sizes[e]=0},this.requireSize=(e,t,r,n)=>{if(this.isBackgroundFetch(t))return 0;if(!d(r)){if(!n)throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");if("function"!=typeof n)throw new TypeError("sizeCalculation must be a function");if(r=n(t,e),!d(r))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}return r},this.addItemSize=(e,t,r)=>{if(this.sizes[e]=t,this.maxSize){const t=this.maxSize-this.sizes[e];for(;this.calculatedSize>t;)this.evict(!0)}this.calculatedSize+=this.sizes[e],r&&(r.entrySize=t,r.totalCalculatedSize=this.calculatedSize)}}removeItemSize(e){}addItemSize(e,t){}requireSize(e,t,r,n){if(r||n)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache")}*indexes({allowStale:e=this.allowStale}={}){if(this.size)for(let t=this.tail;this.isValidIndex(t)&&(!e&&this.isStale(t)||(yield t),t!==this.head);)t=this.prev[t]}*rindexes({allowStale:e=this.allowStale}={}){if(this.size)for(let t=this.head;this.isValidIndex(t)&&(!e&&this.isStale(t)||(yield t),t!==this.tail);)t=this.next[t]}isValidIndex(e){return void 0!==e&&this.keyMap.get(this.keyList[e])===e}*entries(){for(const e of this.indexes())void 0===this.valList[e]||void 0===this.keyList[e]||this.isBackgroundFetch(this.valList[e])||(yield[this.keyList[e],this.valList[e]])}*rentries(){for(const e of this.rindexes())void 0===this.valList[e]||void 0===this.keyList[e]||this.isBackgroundFetch(this.valList[e])||(yield[this.keyList[e],this.valList[e]])}*keys(){for(const e of this.indexes())void 0===this.keyList[e]||this.isBackgroundFetch(this.valList[e])||(yield this.keyList[e])}*rkeys(){for(const e of this.rindexes())void 0===this.keyList[e]||this.isBackgroundFetch(this.valList[e])||(yield this.keyList[e])}*values(){for(const e of this.indexes())void 0===this.valList[e]||this.isBackgroundFetch(this.valList[e])||(yield this.valList[e])}*rvalues(){for(const e of this.rindexes())void 0===this.valList[e]||this.isBackgroundFetch(this.valList[e])||(yield this.valList[e])}[Symbol.iterator](){return this.entries()}find(e,t){for(const r of this.indexes()){const n=this.valList[r],i=this.isBackgroundFetch(n)?n.__staleWhileFetching:n;if(void 0!==i&&e(i,this.keyList[r],this))return this.get(this.keyList[r],t)}}forEach(e,t=this){for(const r of this.indexes()){const n=this.valList[r],i=this.isBackgroundFetch(n)?n.__staleWhileFetching:n;void 0!==i&&e.call(t,i,this.keyList[r],this)}}rforEach(e,t=this){for(const r of this.rindexes()){const n=this.valList[r],i=this.isBackgroundFetch(n)?n.__staleWhileFetching:n;void 0!==i&&e.call(t,i,this.keyList[r],this)}}get prune(){return u("prune","purgeStale"),this.purgeStale}purgeStale(){let e=!1;for(const t of this.rindexes({allowStale:!0}))this.isStale(t)&&(this.delete(this.keyList[t]),e=!0);return e}dump(){const e=[];for(const t of this.indexes({allowStale:!0})){const n=this.keyList[t],i=this.valList[t],s=this.isBackgroundFetch(i)?i.__staleWhileFetching:i;if(void 0===s)continue;const o={value:s};if(this.ttls){o.ttl=this.ttls[t];const e=r.now()-this.starts[t];o.start=Math.floor(Date.now()-e)}this.sizes&&(o.size=this.sizes[t]),e.unshift([n,o])}return e}load(e){this.clear();for(const[t,n]of e){if(n.start){const e=Date.now()-n.start;n.start=r.now()-e}this.set(t,n.value,n)}}dispose(e,t,r){}set(e,t,{ttl:r=this.ttl,start:n,noDisposeOnSet:i=this.noDisposeOnSet,size:s=0,sizeCalculation:o=this.sizeCalculation,noUpdateTTL:a=this.noUpdateTTL,status:l}={}){if(s=this.requireSize(e,t,s,o),this.maxEntrySize&&s>this.maxEntrySize)return l&&(l.set="miss",l.maxEntrySizeExceeded=!0),this.delete(e),this;let u=0===this.size?void 0:this.keyMap.get(e);if(void 0===u)u=this.newIndex(),this.keyList[u]=e,this.valList[u]=t,this.keyMap.set(e,u),this.next[this.tail]=u,this.prev[u]=this.tail,this.tail=u,this.size++,this.addItemSize(u,s,l),l&&(l.set="add"),a=!1;else{this.moveToTail(u);const r=this.valList[u];if(t!==r){if(this.isBackgroundFetch(r)?r.__abortController.abort(new Error("replaced")):i||(this.dispose(r,e,"set"),this.disposeAfter&&this.disposed.push([r,e,"set"])),this.removeItemSize(u),this.valList[u]=t,this.addItemSize(u,s,l),l){l.set="replace";const e=r&&this.isBackgroundFetch(r)?r.__staleWhileFetching:r;void 0!==e&&(l.oldValue=e)}}else l&&(l.set="update")}if(0===r||0!==this.ttl||this.ttls||this.initializeTTLTracking(),a||this.setItemTTL(u,r,n),this.statusTTL(l,u),this.disposeAfter)for(;this.disposed.length;)this.disposeAfter(...this.disposed.shift());return this}newIndex(){return 0===this.size?this.tail:this.size===this.max&&0!==this.max?this.evict(!1):0!==this.free.length?this.free.pop():this.initialFill++}pop(){if(this.size){const e=this.valList[this.head];return this.evict(!0),e}}evict(e){const t=this.head,r=this.keyList[t],n=this.valList[t];return this.isBackgroundFetch(n)?n.__abortController.abort(new Error("evicted")):(this.dispose(n,r,"evict"),this.disposeAfter&&this.disposed.push([n,r,"evict"])),this.removeItemSize(t),e&&(this.keyList[t]=null,this.valList[t]=null,this.free.push(t)),this.head=this.next[t],this.keyMap.delete(r),this.size--,t}has(e,{updateAgeOnHas:t=this.updateAgeOnHas,status:r}={}){const n=this.keyMap.get(e);if(void 0!==n){if(!this.isStale(n))return t&&this.updateItemAge(n),r&&(r.has="hit"),this.statusTTL(r,n),!0;r&&(r.has="stale",this.statusTTL(r,n))}else r&&(r.has="miss");return!1}peek(e,{allowStale:t=this.allowStale}={}){const r=this.keyMap.get(e);if(void 0!==r&&(t||!this.isStale(r))){const e=this.valList[r];return this.isBackgroundFetch(e)?e.__staleWhileFetching:e}}backgroundFetch(e,t,r,i){const s=void 0===t?void 0:this.valList[t];if(this.isBackgroundFetch(s))return s;const o=new n;r.signal&&r.signal.addEventListener("abort",(()=>o.abort(r.signal.reason)));const a={signal:o.signal,options:r,context:i},l=(n,i=!1)=>{const{aborted:s}=o.signal,l=r.ignoreFetchAbort&&void 0!==n;return r.status&&(s&&!i?(r.status.fetchAborted=!0,r.status.fetchError=o.signal.reason,l&&(r.status.fetchAbortIgnored=!0)):r.status.fetchResolved=!0),!s||l||i?(this.valList[t]===c&&(void 0===n?c.__staleWhileFetching?this.valList[t]=c.__staleWhileFetching:this.delete(e):(r.status&&(r.status.fetchUpdated=!0),this.set(e,n,a.options))),n):u(o.signal.reason)},u=n=>{const{aborted:i}=o.signal,s=i&&r.allowStaleOnFetchAbort,a=s||r.allowStaleOnFetchRejection,l=a||r.noDeleteOnFetchRejection;if(this.valList[t]===c){!l||void 0===c.__staleWhileFetching?this.delete(e):s||(this.valList[t]=c.__staleWhileFetching)}if(a)return r.status&&void 0!==c.__staleWhileFetching&&(r.status.returnedStale=!0),c.__staleWhileFetching;if(c.__returned===c)throw n};r.status&&(r.status.fetchDispatched=!0);const c=new Promise(((t,n)=>{this.fetchMethod(e,s,a).then((e=>t(e)),n),o.signal.addEventListener("abort",(()=>{r.ignoreFetchAbort&&!r.allowStaleOnFetchAbort||(t(),r.allowStaleOnFetchAbort&&(t=e=>l(e,!0)))}))})).then(l,(e=>(r.status&&(r.status.fetchRejected=!0,r.status.fetchError=e),u(e))));return c.__abortController=o,c.__staleWhileFetching=s,c.__returned=null,void 0===t?(this.set(e,c,{...a.options,status:void 0}),t=this.keyMap.get(e)):this.valList[t]=c,c}isBackgroundFetch(e){return e&&"object"==typeof e&&"function"==typeof e.then&&Object.prototype.hasOwnProperty.call(e,"__staleWhileFetching")&&Object.prototype.hasOwnProperty.call(e,"__returned")&&(e.__returned===e||null===e.__returned)}async fetch(e,{allowStale:t=this.allowStale,updateAgeOnGet:r=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,ttl:i=this.ttl,noDisposeOnSet:s=this.noDisposeOnSet,size:o=0,sizeCalculation:a=this.sizeCalculation,noUpdateTTL:l=this.noUpdateTTL,noDeleteOnFetchRejection:u=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:c=this.allowStaleOnFetchRejection,ignoreFetchAbort:h=this.ignoreFetchAbort,allowStaleOnFetchAbort:f=this.allowStaleOnFetchAbort,fetchContext:d=this.fetchContext,forceRefresh:p=!1,status:b,signal:g}={}){if(!this.fetchMethod)return b&&(b.fetch="get"),this.get(e,{allowStale:t,updateAgeOnGet:r,noDeleteOnStaleGet:n,status:b});const m={allowStale:t,updateAgeOnGet:r,noDeleteOnStaleGet:n,ttl:i,noDisposeOnSet:s,size:o,sizeCalculation:a,noUpdateTTL:l,noDeleteOnFetchRejection:u,allowStaleOnFetchRejection:c,allowStaleOnFetchAbort:f,ignoreFetchAbort:h,status:b,signal:g};let y=this.keyMap.get(e);if(void 0===y){b&&(b.fetch="miss");const t=this.backgroundFetch(e,y,m,d);return t.__returned=t}{const n=this.valList[y];if(this.isBackgroundFetch(n)){const e=t&&void 0!==n.__staleWhileFetching;return b&&(b.fetch="inflight",e&&(b.returnedStale=!0)),e?n.__staleWhileFetching:n.__returned=n}const i=this.isStale(y);if(!p&&!i)return b&&(b.fetch="hit"),this.moveToTail(y),r&&this.updateItemAge(y),this.statusTTL(b,y),n;const s=this.backgroundFetch(e,y,m,d),o=void 0!==s.__staleWhileFetching,a=o&&t;return b&&(b.fetch=o&&i?"stale":"refresh",a&&i&&(b.returnedStale=!0)),a?s.__staleWhileFetching:s.__returned=s}}get(e,{allowStale:t=this.allowStale,updateAgeOnGet:r=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,status:i}={}){const s=this.keyMap.get(e);if(void 0!==s){const o=this.valList[s],a=this.isBackgroundFetch(o);return this.statusTTL(i,s),this.isStale(s)?(i&&(i.get="stale"),a?(i&&(i.returnedStale=t&&void 0!==o.__staleWhileFetching),t?o.__staleWhileFetching:void 0):(n||this.delete(e),i&&(i.returnedStale=t),t?o:void 0)):(i&&(i.get="hit"),a?o.__staleWhileFetching:(this.moveToTail(s),r&&this.updateItemAge(s),o))}i&&(i.get="miss")}connect(e,t){this.prev[t]=e,this.next[e]=t}moveToTail(e){e!==this.tail&&(e===this.head?this.head=this.next[e]:this.connect(this.prev[e],this.next[e]),this.connect(this.tail,e),this.tail=e)}get del(){return u("del","delete"),this.delete}delete(e){let t=!1;if(0!==this.size){const r=this.keyMap.get(e);if(void 0!==r)if(t=!0,1===this.size)this.clear();else{this.removeItemSize(r);const t=this.valList[r];this.isBackgroundFetch(t)?t.__abortController.abort(new Error("deleted")):(this.dispose(t,e,"delete"),this.disposeAfter&&this.disposed.push([t,e,"delete"])),this.keyMap.delete(e),this.keyList[r]=null,this.valList[r]=null,r===this.tail?this.tail=this.prev[r]:r===this.head?this.head=this.next[r]:(this.next[this.prev[r]]=this.next[r],this.prev[this.next[r]]=this.prev[r]),this.size--,this.free.push(r)}}if(this.disposed)for(;this.disposed.length;)this.disposeAfter(...this.disposed.shift());return t}clear(){for(const e of this.rindexes({allowStale:!0})){const t=this.valList[e];if(this.isBackgroundFetch(t))t.__abortController.abort(new Error("deleted"));else{const r=this.keyList[e];this.dispose(t,r,"delete"),this.disposeAfter&&this.disposed.push([t,r,"delete"])}}if(this.keyMap.clear(),this.valList.fill(null),this.keyList.fill(null),this.ttls&&(this.ttls.fill(0),this.starts.fill(0)),this.sizes&&this.sizes.fill(0),this.head=0,this.tail=0,this.initialFill=1,this.free.length=0,this.calculatedSize=0,this.size=0,this.disposed)for(;this.disposed.length;)this.disposeAfter(...this.disposed.shift())}get reset(){return u("reset","clear"),this.clear}get length(){return((e,t)=>{const r=`LRU_CACHE_PROPERTY_${e}`;if(h(r)){const{prototype:n}=m,{get:i}=Object.getOwnPropertyDescriptor(n,e);f(r,`${e} property`,`cache.${t}`,i)}})("length","size"),this.size}static get AbortController(){return n}static get AbortSignal(){return o}}t.exports=m}).call(this)}).call(this,e("_process"))},{_process:102}],73:[function(e,t,r){const n=t.exports,{Buffer:i}=e("buffer");n.types={0:"reserved",1:"connect",2:"connack",3:"publish",4:"puback",5:"pubrec",6:"pubrel",7:"pubcomp",8:"subscribe",9:"suback",10:"unsubscribe",11:"unsuback",12:"pingreq",13:"pingresp",14:"disconnect",15:"auth"},n.requiredHeaderFlags={1:0,2:0,4:0,5:0,6:2,7:0,8:2,9:0,10:2,11:0,12:0,13:0,14:0,15:0},n.requiredHeaderFlagsErrors={};for(const e in n.requiredHeaderFlags){const t=n.requiredHeaderFlags[e];n.requiredHeaderFlagsErrors[e]="Invalid header flag bits, must be 0x"+t.toString(16)+" for "+n.types[e]+" packet"}n.codes={};for(const e in n.types){const t=n.types[e];n.codes[t]=e}n.CMD_SHIFT=4,n.CMD_MASK=240,n.DUP_MASK=8,n.QOS_MASK=3,n.QOS_SHIFT=1,n.RETAIN_MASK=1,n.VARBYTEINT_MASK=127,n.VARBYTEINT_FIN_MASK=128,n.VARBYTEINT_MAX=268435455,n.SESSIONPRESENT_MASK=1,n.SESSIONPRESENT_HEADER=i.from([n.SESSIONPRESENT_MASK]),n.CONNACK_HEADER=i.from([n.codes.connack<<n.CMD_SHIFT]),n.USERNAME_MASK=128,n.PASSWORD_MASK=64,n.WILL_RETAIN_MASK=32,n.WILL_QOS_MASK=24,n.WILL_QOS_SHIFT=3,n.WILL_FLAG_MASK=4,n.CLEAN_SESSION_MASK=2,n.CONNECT_HEADER=i.from([n.codes.connect<<n.CMD_SHIFT]),n.properties={sessionExpiryInterval:17,willDelayInterval:24,receiveMaximum:33,maximumPacketSize:39,topicAliasMaximum:34,requestResponseInformation:25,requestProblemInformation:23,userProperties:38,authenticationMethod:21,authenticationData:22,payloadFormatIndicator:1,messageExpiryInterval:2,contentType:3,responseTopic:8,correlationData:9,maximumQoS:36,retainAvailable:37,assignedClientIdentifier:18,reasonString:31,wildcardSubscriptionAvailable:40,subscriptionIdentifiersAvailable:41,sharedSubscriptionAvailable:42,serverKeepAlive:19,responseInformation:26,serverReference:28,topicAlias:35,subscriptionIdentifier:11},n.propertiesCodes={};for(const e in n.properties){const t=n.properties[e];n.propertiesCodes[t]=e}function s(e){return[0,1,2].map((t=>[0,1].map((r=>[0,1].map((s=>{const o=i.alloc(1);return o.writeUInt8(n.codes[e]<<n.CMD_SHIFT|(r?n.DUP_MASK:0)|t<<n.QOS_SHIFT|s,0,!0),o}))))))}n.propertiesTypes={sessionExpiryInterval:"int32",willDelayInterval:"int32",receiveMaximum:"int16",maximumPacketSize:"int32",topicAliasMaximum:"int16",requestResponseInformation:"byte",requestProblemInformation:"byte",userProperties:"pair",authenticationMethod:"string",authenticationData:"binary",payloadFormatIndicator:"byte",messageExpiryInterval:"int32",contentType:"string",responseTopic:"string",correlationData:"binary",maximumQoS:"int8",retainAvailable:"byte",assignedClientIdentifier:"string",reasonString:"string",wildcardSubscriptionAvailable:"byte",subscriptionIdentifiersAvailable:"byte",sharedSubscriptionAvailable:"byte",serverKeepAlive:"int16",responseInformation:"string",serverReference:"string",topicAlias:"int16",subscriptionIdentifier:"var"},n.PUBLISH_HEADER=s("publish"),n.SUBSCRIBE_HEADER=s("subscribe"),n.SUBSCRIBE_OPTIONS_QOS_MASK=3,n.SUBSCRIBE_OPTIONS_NL_MASK=1,n.SUBSCRIBE_OPTIONS_NL_SHIFT=2,n.SUBSCRIBE_OPTIONS_RAP_MASK=1,n.SUBSCRIBE_OPTIONS_RAP_SHIFT=3,n.SUBSCRIBE_OPTIONS_RH_MASK=3,n.SUBSCRIBE_OPTIONS_RH_SHIFT=4,n.SUBSCRIBE_OPTIONS_RH=[0,16,32],n.SUBSCRIBE_OPTIONS_NL=4,n.SUBSCRIBE_OPTIONS_RAP=8,n.SUBSCRIBE_OPTIONS_QOS=[0,1,2],n.UNSUBSCRIBE_HEADER=s("unsubscribe"),n.ACKS={unsuback:s("unsuback"),puback:s("puback"),pubcomp:s("pubcomp"),pubrel:s("pubrel"),pubrec:s("pubrec")},n.SUBACK_HEADER=i.from([n.codes.suback<<n.CMD_SHIFT]),n.VERSION3=i.from([3]),n.VERSION4=i.from([4]),n.VERSION5=i.from([5]),n.VERSION131=i.from([131]),n.VERSION132=i.from([132]),n.QOS=[0,1,2].map((e=>i.from([e]))),n.EMPTY={pingreq:i.from([n.codes.pingreq<<4,0]),pingresp:i.from([n.codes.pingresp<<4,0]),disconnect:i.from([n.codes.disconnect<<4,0])},n.MQTT5_PUBACK_PUBREC_CODES={0:"Success",16:"No matching subscribers",128:"Unspecified error",131:"Implementation specific error",135:"Not authorized",144:"Topic Name invalid",145:"Packet identifier in use",151:"Quota exceeded",153:"Payload format invalid"},n.MQTT5_PUBREL_PUBCOMP_CODES={0:"Success",146:"Packet Identifier not found"},n.MQTT5_SUBACK_CODES={0:"Granted QoS 0",1:"Granted QoS 1",2:"Granted QoS 2",128:"Unspecified error",131:"Implementation specific error",135:"Not authorized",143:"Topic Filter invalid",145:"Packet Identifier in use",151:"Quota exceeded",158:"Shared Subscriptions not supported",161:"Subscription Identifiers not supported",162:"Wildcard Subscriptions not supported"},n.MQTT5_UNSUBACK_CODES={0:"Success",17:"No subscription existed",128:"Unspecified error",131:"Implementation specific error",135:"Not authorized",143:"Topic Filter invalid",145:"Packet Identifier in use"},n.MQTT5_DISCONNECT_CODES={0:"Normal disconnection",4:"Disconnect with Will Message",128:"Unspecified error",129:"Malformed Packet",130:"Protocol Error",131:"Implementation specific error",135:"Not authorized",137:"Server busy",139:"Server shutting down",141:"Keep Alive timeout",142:"Session taken over",143:"Topic Filter invalid",144:"Topic Name invalid",147:"Receive Maximum exceeded",148:"Topic Alias invalid",149:"Packet too large",150:"Message rate too high",151:"Quota exceeded",152:"Administrative action",153:"Payload format invalid",154:"Retain not supported",155:"QoS not supported",156:"Use another server",157:"Server moved",158:"Shared Subscriptions not supported",159:"Connection rate exceeded",160:"Maximum connect time",161:"Subscription Identifiers not supported",162:"Wildcard Subscriptions not supported"},n.MQTT5_AUTH_CODES={0:"Success",24:"Continue authentication",25:"Re-authenticate"}},{buffer:29}],74:[function(e,t,r){const n=e("./writeToStream"),i=e("events"),{Buffer:s}=e("buffer");class o extends i{constructor(){super(),this._array=new Array(20),this._i=0}write(e){return this._array[this._i++]=e,!0}concat(){let e=0;const t=new Array(this._array.length),r=this._array;let n,i=0;for(n=0;n<r.length&&void 0!==r[n];n++)"string"!=typeof r[n]?t[n]=r[n].length:t[n]=s.byteLength(r[n]),e+=t[n];const o=s.allocUnsafe(e);for(n=0;n<r.length&&void 0!==r[n];n++)"string"!=typeof r[n]?(r[n].copy(o,i),i+=t[n]):(o.write(r[n],i),i+=t[n]);return o}destroy(e){e&&this.emit("error",e)}}t.exports=function(e,t){const r=new o;return n(e,r,t),r.concat()}},{"./writeToStream":96,buffer:29,events:49}],75:[function(e,t,r){r.parser=e("./parser").parser,r.generate=e("./generate"),r.writeToStream=e("./writeToStream")},{"./generate":74,"./parser":95,"./writeToStream":96}],76:[function(e,t,r){"use strict";const{Buffer:n}=e("buffer"),i=Symbol.for("BufferList");function s(e){if(!(this instanceof s))return new s(e);s._init.call(this,e)}s._init=function(e){Object.defineProperty(this,i,{value:!0}),this._bufs=[],this.length=0,e&&this.append(e)},s.prototype._new=function(e){return new s(e)},s.prototype._offset=function(e){if(0===e)return[0,0];let t=0;for(let r=0;r<this._bufs.length;r++){const n=t+this._bufs[r].length;if(e<n||r===this._bufs.length-1)return[r,e-t];t=n}},s.prototype._reverseOffset=function(e){const t=e[0];let r=e[1];for(let e=0;e<t;e++)r+=this._bufs[e].length;return r},s.prototype.get=function(e){if(e>this.length||e<0)return;const t=this._offset(e);return this._bufs[t[0]][t[1]]},s.prototype.slice=function(e,t){return"number"==typeof e&&e<0&&(e+=this.length),"number"==typeof t&&t<0&&(t+=this.length),this.copy(null,0,e,t)},s.prototype.copy=function(e,t,r,i){if(("number"!=typeof r||r<0)&&(r=0),("number"!=typeof i||i>this.length)&&(i=this.length),r>=this.length)return e||n.alloc(0);if(i<=0)return e||n.alloc(0);const s=!!e,o=this._offset(r),a=i-r;let l=a,u=s&&t||0,c=o[1];if(0===r&&i===this.length){if(!s)return 1===this._bufs.length?this._bufs[0]:n.concat(this._bufs,this.length);for(let t=0;t<this._bufs.length;t++)this._bufs[t].copy(e,u),u+=this._bufs[t].length;return e}if(l<=this._bufs[o[0]].length-c)return s?this._bufs[o[0]].copy(e,t,c,c+l):this._bufs[o[0]].slice(c,c+l);s||(e=n.allocUnsafe(a));for(let t=o[0];t<this._bufs.length;t++){const r=this._bufs[t].length-c;if(!(l>r)){this._bufs[t].copy(e,u,c,c+l),u+=r;break}this._bufs[t].copy(e,u,c),u+=r,l-=r,c&&(c=0)}return e.length>u?e.slice(0,u):e},s.prototype.shallowSlice=function(e,t){if(e=e||0,t="number"!=typeof t?this.length:t,e<0&&(e+=this.length),t<0&&(t+=this.length),e===t)return this._new();const r=this._offset(e),n=this._offset(t),i=this._bufs.slice(r[0],n[0]+1);return 0===n[1]?i.pop():i[i.length-1]=i[i.length-1].slice(0,n[1]),0!==r[1]&&(i[0]=i[0].slice(r[1])),this._new(i)},s.prototype.toString=function(e,t,r){return this.slice(t,r).toString(e)},s.prototype.consume=function(e){if(e=Math.trunc(e),Number.isNaN(e)||e<=0)return this;for(;this._bufs.length;){if(!(e>=this._bufs[0].length)){this._bufs[0]=this._bufs[0].slice(e),this.length-=e;break}e-=this._bufs[0].length,this.length-=this._bufs[0].length,this._bufs.shift()}return this},s.prototype.duplicate=function(){const e=this._new();for(let t=0;t<this._bufs.length;t++)e.append(this._bufs[t]);return e},s.prototype.append=function(e){if(null==e)return this;if(e.buffer)this._appendBuffer(n.from(e.buffer,e.byteOffset,e.byteLength));else if(Array.isArray(e))for(let t=0;t<e.length;t++)this.append(e[t]);else if(this._isBufferList(e))for(let t=0;t<e._bufs.length;t++)this.append(e._bufs[t]);else"number"==typeof e&&(e=e.toString()),this._appendBuffer(n.from(e));return this},s.prototype._appendBuffer=function(e){this._bufs.push(e),this.length+=e.length},s.prototype.indexOf=function(e,t,r){if(void 0===r&&"string"==typeof t&&(r=t,t=void 0),"function"==typeof e||Array.isArray(e))throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');if("number"==typeof e?e=n.from([e]):"string"==typeof e?e=n.from(e,r):this._isBufferList(e)?e=e.slice():Array.isArray(e.buffer)?e=n.from(e.buffer,e.byteOffset,e.byteLength):n.isBuffer(e)||(e=n.from(e)),t=Number(t||0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),0===e.length)return t>this.length?this.length:t;const i=this._offset(t);let s=i[0],o=i[1];for(;s<this._bufs.length;s++){const t=this._bufs[s];for(;o<t.length;){if(t.length-o>=e.length){const r=t.indexOf(e,o);if(-1!==r)return this._reverseOffset([s,r]);o=t.length-e.length+1}else{const t=this._reverseOffset([s,o]);if(this._match(t,e))return t;o++}}o=0}return-1},s.prototype._match=function(e,t){if(this.length-e<t.length)return!1;for(let r=0;r<t.length;r++)if(this.get(e+r)!==t[r])return!1;return!0},function(){const e={readDoubleBE:8,readDoubleLE:8,readFloatBE:4,readFloatLE:4,readInt32BE:4,readInt32LE:4,readUInt32BE:4,readUInt32LE:4,readInt16BE:2,readInt16LE:2,readUInt16BE:2,readUInt16LE:2,readInt8:1,readUInt8:1,readIntBE:null,readIntLE:null,readUIntBE:null,readUIntLE:null};for(const t in e)!function(t){s.prototype[t]=null===e[t]?function(e,r){return this.slice(e,e+r)[t](0,r)}:function(r=0){return this.slice(r,r+e[t])[t](0)}}(t)}(),s.prototype._isBufferList=function(e){return e instanceof s||s.isBufferList(e)},s.isBufferList=function(e){return null!=e&&e[i]},t.exports=s},{buffer:29}],77:[function(e,t,r){"use strict";const n=e("readable-stream").Duplex,i=e("inherits"),s=e("./BufferList");function o(e){if(!(this instanceof o))return new o(e);if("function"==typeof e){this._callback=e;const t=function(e){this._callback&&(this._callback(e),this._callback=null)}.bind(this);this.on("pipe",(function(e){e.on("error",t)})),this.on("unpipe",(function(e){e.removeListener("error",t)})),e=null}s._init.call(this,e),n.call(this)}i(o,n),Object.assign(o.prototype,s.prototype),o.prototype._new=function(e){return new o(e)},o.prototype._write=function(e,t,r){this._appendBuffer(e),"function"==typeof r&&r()},o.prototype._read=function(e){if(!this.length)return this.push(null);e=Math.min(e,this.length),this.push(this.slice(0,e)),this.consume(e)},o.prototype.end=function(e){n.prototype.end.call(this,e),this._callback&&(this._callback(null,this.slice()),this._callback=null)},o.prototype._destroy=function(e,t){this._bufs.length=0,this.length=0,t(e)},o.prototype._isBufferList=function(e){return e instanceof o||e instanceof s||o.isBufferList(e)},o.isBufferList=s.isBufferList,t.exports=o,t.exports.BufferListStream=o,t.exports.BufferList=s},{"./BufferList":76,inherits:51,"readable-stream":92}],78:[function(e,t,r){arguments[4][33][0].apply(r,arguments)},{dup:33}],79:[function(e,t,r){arguments[4][34][0].apply(r,arguments)},{"./_stream_readable":81,"./_stream_writable":83,_process:102,dup:34,inherits:51}],80:[function(e,t,r){arguments[4][35][0].apply(r,arguments)},{"./_stream_transform":82,dup:35,inherits:51}],81:[function(e,t,r){arguments[4][36][0].apply(r,arguments)},{"../errors":78,"./_stream_duplex":79,"./internal/streams/async_iterator":84,"./internal/streams/buffer_list":85,"./internal/streams/destroy":86,"./internal/streams/from":88,"./internal/streams/state":90,"./internal/streams/stream":91,_process:102,buffer:29,dup:36,events:49,inherits:51,"string_decoder/":136,util:26}],82:[function(e,t,r){arguments[4][37][0].apply(r,arguments)},{"../errors":78,"./_stream_duplex":79,dup:37,inherits:51}],83:[function(e,t,r){arguments[4][38][0].apply(r,arguments)},{"../errors":78,"./_stream_duplex":79,"./internal/streams/destroy":86,"./internal/streams/state":90,"./internal/streams/stream":91,_process:102,buffer:29,dup:38,inherits:51,"util-deprecate":139}],84:[function(e,t,r){arguments[4][39][0].apply(r,arguments)},{"./end-of-stream":87,_process:102,dup:39}],85:[function(e,t,r){arguments[4][40][0].apply(r,arguments)},{buffer:29,dup:40,util:26}],86:[function(e,t,r){arguments[4][41][0].apply(r,arguments)},{_process:102,dup:41}],87:[function(e,t,r){arguments[4][42][0].apply(r,arguments)},{"../../../errors":78,dup:42}],88:[function(e,t,r){arguments[4][43][0].apply(r,arguments)},{dup:43}],89:[function(e,t,r){arguments[4][44][0].apply(r,arguments)},{"../../../errors":78,"./end-of-stream":87,dup:44}],90:[function(e,t,r){arguments[4][45][0].apply(r,arguments)},{"../../../errors":78,dup:45}],91:[function(e,t,r){arguments[4][46][0].apply(r,arguments)},{dup:46,events:49}],92:[function(e,t,r){arguments[4][47][0].apply(r,arguments)},{"./lib/_stream_duplex.js":79,"./lib/_stream_passthrough.js":80,"./lib/_stream_readable.js":81,"./lib/_stream_transform.js":82,"./lib/_stream_writable.js":83,"./lib/internal/streams/end-of-stream.js":87,"./lib/internal/streams/pipeline.js":89,dup:47}],93:[function(e,t,r){const{Buffer:n}=e("buffer"),i={},s=n.isBuffer(n.from([1,2]).subarray(0,1));function o(e){const t=n.allocUnsafe(2);return t.writeUInt8(e>>8,0),t.writeUInt8(255&e,1),t}t.exports={cache:i,generateCache:function(){for(let e=0;e<65536;e++)i[e]=o(e)},generateNumber:o,genBufVariableByteInt:function(e){let t=0,r=0;const i=n.allocUnsafe(4);do{t=e%128|0,(e=e/128|0)>0&&(t|=128),i.writeUInt8(t,r++)}while(e>0&&r<4);return e>0&&(r=0),s?i.subarray(0,r):i.slice(0,r)},generate4ByteBuffer:function(e){const t=n.allocUnsafe(4);return t.writeUInt32BE(e,0),t}}},{buffer:29}],94:[function(e,t,r){t.exports=class{constructor(){this.cmd=null,this.retain=!1,this.qos=0,this.dup=!1,this.length=-1,this.topic=null,this.payload=null}}},{}],95:[function(e,t,r){const n=e("bl"),i=e("events"),s=e("./packet"),o=e("./constants"),a=e("debug")("mqtt-packet:parser");class l extends i{constructor(){super(),this.parser=this.constructor.parser}static parser(e){return this instanceof l?(this.settings=e||{},this._states=["_parseHeader","_parseLength","_parsePayload","_newPacket"],this._resetState(),this):(new l).parser(e)}_resetState(){a("_resetState: resetting packet, error, _list, and _stateCounter"),this.packet=new s,this.error=null,this._list=n(),this._stateCounter=0}parse(e){for(this.error&&this._resetState(),this._list.append(e),a("parse: current state: %s",this._states[this._stateCounter]);(-1!==this.packet.length||this._list.length>0)&&this[this._states[this._stateCounter]]()&&!this.error;)this._stateCounter++,a("parse: state complete. _stateCounter is now: %d",this._stateCounter),a("parse: packet.length: %d, buffer list length: %d",this.packet.length,this._list.length),this._stateCounter>=this._states.length&&(this._stateCounter=0);return a("parse: exited while loop. packet: %d, buffer list length: %d",this.packet.length,this._list.length),this._list.length}_parseHeader(){const e=this._list.readUInt8(0),t=e>>o.CMD_SHIFT;this.packet.cmd=o.types[t];const r=15&e,n=o.requiredHeaderFlags[t];return null!=n&&r!==n?this._emitError(new Error(o.requiredHeaderFlagsErrors[t])):(this.packet.retain=0!=(e&o.RETAIN_MASK),this.packet.qos=e>>o.QOS_SHIFT&o.QOS_MASK,this.packet.qos>2?this._emitError(new Error("Packet must not have both QoS bits set to 1")):(this.packet.dup=0!=(e&o.DUP_MASK),a("_parseHeader: packet: %o",this.packet),this._list.consume(1),!0))}_parseLength(){const e=this._parseVarByteNum(!0);return e&&(this.packet.length=e.value,this._list.consume(e.bytes)),a("_parseLength %d",e.value),!!e}_parsePayload(){a("_parsePayload: payload %O",this._list);let e=!1;if(0===this.packet.length||this._list.length>=this.packet.length){switch(this._pos=0,this.packet.cmd){case"connect":this._parseConnect();break;case"connack":this._parseConnack();break;case"publish":this._parsePublish();break;case"puback":case"pubrec":case"pubrel":case"pubcomp":this._parseConfirmation();break;case"subscribe":this._parseSubscribe();break;case"suback":this._parseSuback();break;case"unsubscribe":this._parseUnsubscribe();break;case"unsuback":this._parseUnsuback();break;case"pingreq":case"pingresp":break;case"disconnect":this._parseDisconnect();break;case"auth":this._parseAuth();break;default:this._emitError(new Error("Not supported"))}e=!0}return a("_parsePayload complete result: %s",e),e}_parseConnect(){let e,t,r,n;a("_parseConnect");const i={},s=this.packet,l=this._parseString();if(null===l)return this._emitError(new Error("Cannot parse protocolId"));if("MQTT"!==l&&"MQIsdp"!==l)return this._emitError(new Error("Invalid protocolId"));if(s.protocolId=l,this._pos>=this._list.length)return this._emitError(new Error("Packet too short"));if(s.protocolVersion=this._list.readUInt8(this._pos),s.protocolVersion>=128&&(s.bridgeMode=!0,s.protocolVersion=s.protocolVersion-128),3!==s.protocolVersion&&4!==s.protocolVersion&&5!==s.protocolVersion)return this._emitError(new Error("Invalid protocol version"));if(this._pos++,this._pos>=this._list.length)return this._emitError(new Error("Packet too short"));if(1&this._list.readUInt8(this._pos))return this._emitError(new Error("Connect flag bit 0 must be 0, but got 1"));i.username=this._list.readUInt8(this._pos)&o.USERNAME_MASK,i.password=this._list.readUInt8(this._pos)&o.PASSWORD_MASK,i.will=this._list.readUInt8(this._pos)&o.WILL_FLAG_MASK;const u=!!(this._list.readUInt8(this._pos)&o.WILL_RETAIN_MASK),c=(this._list.readUInt8(this._pos)&o.WILL_QOS_MASK)>>o.WILL_QOS_SHIFT;if(i.will)s.will={},s.will.retain=u,s.will.qos=c;else{if(u)return this._emitError(new Error("Will Retain Flag must be set to zero when Will Flag is set to 0"));if(c)return this._emitError(new Error("Will QoS must be set to zero when Will Flag is set to 0"))}if(s.clean=0!=(this._list.readUInt8(this._pos)&o.CLEAN_SESSION_MASK),this._pos++,s.keepalive=this._parseNum(),-1===s.keepalive)return this._emitError(new Error("Packet too short"));if(5===s.protocolVersion){const e=this._parseProperties();Object.getOwnPropertyNames(e).length&&(s.properties=e)}const h=this._parseString();if(null===h)return this._emitError(new Error("Packet too short"));if(s.clientId=h,a("_parseConnect: packet.clientId: %s",s.clientId),i.will){if(5===s.protocolVersion){const e=this._parseProperties();Object.getOwnPropertyNames(e).length&&(s.will.properties=e)}if(e=this._parseString(),null===e)return this._emitError(new Error("Cannot parse will topic"));if(s.will.topic=e,a("_parseConnect: packet.will.topic: %s",s.will.topic),t=this._parseBuffer(),null===t)return this._emitError(new Error("Cannot parse will payload"));s.will.payload=t,a("_parseConnect: packet.will.paylaod: %s",s.will.payload)}if(i.username){if(n=this._parseString(),null===n)return this._emitError(new Error("Cannot parse username"));s.username=n,a("_parseConnect: packet.username: %s",s.username)}if(i.password){if(r=this._parseBuffer(),null===r)return this._emitError(new Error("Cannot parse password"));s.password=r}return this.settings=s,a("_parseConnect: complete"),s}_parseConnack(){a("_parseConnack");const e=this.packet;if(this._list.length<1)return null;const t=this._list.readUInt8(this._pos++);if(t>1)return this._emitError(new Error("Invalid connack flags, bits 7-1 must be set to 0"));if(e.sessionPresent=!!(t&o.SESSIONPRESENT_MASK),5===this.settings.protocolVersion)this._list.length>=2?e.reasonCode=this._list.readUInt8(this._pos++):e.reasonCode=0;else{if(this._list.length<2)return null;e.returnCode=this._list.readUInt8(this._pos++)}if(-1===e.returnCode||-1===e.reasonCode)return this._emitError(new Error("Cannot parse return code"));if(5===this.settings.protocolVersion){const t=this._parseProperties();Object.getOwnPropertyNames(t).length&&(e.properties=t)}a("_parseConnack: complete")}_parsePublish(){a("_parsePublish");const e=this.packet;if(e.topic=this._parseString(),null===e.topic)return this._emitError(new Error("Cannot parse topic"));if(!(e.qos>0)||this._parseMessageId()){if(5===this.settings.protocolVersion){const t=this._parseProperties();Object.getOwnPropertyNames(t).length&&(e.properties=t)}e.payload=this._list.slice(this._pos,e.length),a("_parsePublish: payload from buffer list: %o",e.payload)}}_parseSubscribe(){a("_parseSubscribe");const e=this.packet;let t,r,n,i,s,l,u;if(e.subscriptions=[],this._parseMessageId()){if(5===this.settings.protocolVersion){const t=this._parseProperties();Object.getOwnPropertyNames(t).length&&(e.properties=t)}if(e.length<=0)return this._emitError(new Error("Malformed subscribe, no payload specified"));for(;this._pos<e.length;){if(t=this._parseString(),null===t)return this._emitError(new Error("Cannot parse topic"));if(this._pos>=e.length)return this._emitError(new Error("Malformed Subscribe Payload"));if(r=this._parseByte(),5===this.settings.protocolVersion){if(192&r)return this._emitError(new Error("Invalid subscribe topic flag bits, bits 7-6 must be 0"))}else if(252&r)return this._emitError(new Error("Invalid subscribe topic flag bits, bits 7-2 must be 0"));if(n=r&o.SUBSCRIBE_OPTIONS_QOS_MASK,n>2)return this._emitError(new Error("Invalid subscribe QoS, must be <= 2"));if(l=0!=(r>>o.SUBSCRIBE_OPTIONS_NL_SHIFT&o.SUBSCRIBE_OPTIONS_NL_MASK),s=0!=(r>>o.SUBSCRIBE_OPTIONS_RAP_SHIFT&o.SUBSCRIBE_OPTIONS_RAP_MASK),i=r>>o.SUBSCRIBE_OPTIONS_RH_SHIFT&o.SUBSCRIBE_OPTIONS_RH_MASK,i>2)return this._emitError(new Error("Invalid retain handling, must be <= 2"));u={topic:t,qos:n},5===this.settings.protocolVersion?(u.nl=l,u.rap=s,u.rh=i):this.settings.bridgeMode&&(u.rh=0,u.rap=!0,u.nl=!0),a("_parseSubscribe: push subscription `%s` to subscription",u),e.subscriptions.push(u)}}}_parseSuback(){a("_parseSuback");const e=this.packet;if(this.packet.granted=[],this._parseMessageId()){if(5===this.settings.protocolVersion){const t=this._parseProperties();Object.getOwnPropertyNames(t).length&&(e.properties=t)}if(e.length<=0)return this._emitError(new Error("Malformed suback, no payload specified"));for(;this._pos<this.packet.length;){const e=this._list.readUInt8(this._pos++);if(5===this.settings.protocolVersion){if(!o.MQTT5_SUBACK_CODES[e])return this._emitError(new Error("Invalid suback code"))}else if(e>2&&128!==e)return this._emitError(new Error("Invalid suback QoS, must be 0, 1, 2 or 128"));this.packet.granted.push(e)}}}_parseUnsubscribe(){a("_parseUnsubscribe");const e=this.packet;if(e.unsubscriptions=[],this._parseMessageId()){if(5===this.settings.protocolVersion){const t=this._parseProperties();Object.getOwnPropertyNames(t).length&&(e.properties=t)}if(e.length<=0)return this._emitError(new Error("Malformed unsubscribe, no payload specified"));for(;this._pos<e.length;){const t=this._parseString();if(null===t)return this._emitError(new Error("Cannot parse topic"));a("_parseUnsubscribe: push topic `%s` to unsubscriptions",t),e.unsubscriptions.push(t)}}}_parseUnsuback(){a("_parseUnsuback");const e=this.packet;if(!this._parseMessageId())return this._emitError(new Error("Cannot parse messageId"));if((3===this.settings.protocolVersion||4===this.settings.protocolVersion)&&2!==e.length)return this._emitError(new Error("Malformed unsuback, payload length must be 2"));if(e.length<=0)return this._emitError(new Error("Malformed unsuback, no payload specified"));if(5===this.settings.protocolVersion){const t=this._parseProperties();for(Object.getOwnPropertyNames(t).length&&(e.properties=t),e.granted=[];this._pos<this.packet.length;){const e=this._list.readUInt8(this._pos++);if(!o.MQTT5_UNSUBACK_CODES[e])return this._emitError(new Error("Invalid unsuback code"));this.packet.granted.push(e)}}}_parseConfirmation(){a("_parseConfirmation: packet.cmd: `%s`",this.packet.cmd);const e=this.packet;if(this._parseMessageId(),5===this.settings.protocolVersion){if(e.length>2){switch(e.reasonCode=this._parseByte(),this.packet.cmd){case"puback":case"pubrec":if(!o.MQTT5_PUBACK_PUBREC_CODES[e.reasonCode])return this._emitError(new Error("Invalid "+this.packet.cmd+" reason code"));break;case"pubrel":case"pubcomp":if(!o.MQTT5_PUBREL_PUBCOMP_CODES[e.reasonCode])return this._emitError(new Error("Invalid "+this.packet.cmd+" reason code"))}a("_parseConfirmation: packet.reasonCode `%d`",e.reasonCode)}else e.reasonCode=0;if(e.length>3){const t=this._parseProperties();Object.getOwnPropertyNames(t).length&&(e.properties=t)}}return!0}_parseDisconnect(){const e=this.packet;if(a("_parseDisconnect"),5===this.settings.protocolVersion){this._list.length>0?(e.reasonCode=this._parseByte(),o.MQTT5_DISCONNECT_CODES[e.reasonCode]||this._emitError(new Error("Invalid disconnect reason code"))):e.reasonCode=0;const t=this._parseProperties();Object.getOwnPropertyNames(t).length&&(e.properties=t)}return a("_parseDisconnect result: true"),!0}_parseAuth(){a("_parseAuth");const e=this.packet;if(5!==this.settings.protocolVersion)return this._emitError(new Error("Not supported auth packet for this version MQTT"));if(e.reasonCode=this._parseByte(),!o.MQTT5_AUTH_CODES[e.reasonCode])return this._emitError(new Error("Invalid auth reason code"));const t=this._parseProperties();return Object.getOwnPropertyNames(t).length&&(e.properties=t),a("_parseAuth: result: true"),!0}_parseMessageId(){const e=this.packet;return e.messageId=this._parseNum(),null===e.messageId?(this._emitError(new Error("Cannot parse messageId")),!1):(a("_parseMessageId: packet.messageId %d",e.messageId),!0)}_parseString(e){const t=this._parseNum(),r=t+this._pos;if(-1===t||r>this._list.length||r>this.packet.length)return null;const n=this._list.toString("utf8",this._pos,r);return this._pos+=t,a("_parseString: result: %s",n),n}_parseStringPair(){return a("_parseStringPair"),{name:this._parseString(),value:this._parseString()}}_parseBuffer(){const e=this._parseNum(),t=e+this._pos;if(-1===e||t>this._list.length||t>this.packet.length)return null;const r=this._list.slice(this._pos,t);return this._pos+=e,a("_parseBuffer: result: %o",r),r}_parseNum(){if(this._list.length-this._pos<2)return-1;const e=this._list.readUInt16BE(this._pos);return this._pos+=2,a("_parseNum: result: %s",e),e}_parse4ByteNum(){if(this._list.length-this._pos<4)return-1;const e=this._list.readUInt32BE(this._pos);return this._pos+=4,a("_parse4ByteNum: result: %s",e),e}_parseVarByteNum(e){a("_parseVarByteNum");let t,r=0,n=1,i=0,s=!1;const l=this._pos?this._pos:0;for(;r<4&&l+r<this._list.length;){if(t=this._list.readUInt8(l+r++),i+=n*(t&o.VARBYTEINT_MASK),n*=128,0==(t&o.VARBYTEINT_FIN_MASK)){s=!0;break}if(this._list.length<=r)break}return!s&&4===r&&this._list.length>=r&&this._emitError(new Error("Invalid variable byte integer")),l&&(this._pos+=r),s=!!s&&(e?{bytes:r,value:i}:i),a("_parseVarByteNum: result: %o",s),s}_parseByte(){let e;return this._pos<this._list.length&&(e=this._list.readUInt8(this._pos),this._pos++),a("_parseByte: result: %o",e),e}_parseByType(e){switch(a("_parseByType: type: %s",e),e){case"byte":return 0!==this._parseByte();case"int8":return this._parseByte();case"int16":return this._parseNum();case"int32":return this._parse4ByteNum();case"var":return this._parseVarByteNum();case"string":return this._parseString();case"pair":return this._parseStringPair();case"binary":return this._parseBuffer()}}_parseProperties(){a("_parseProperties");const e=this._parseVarByteNum(),t=this._pos+e,r={};for(;this._pos<t;){const e=this._parseByte();if(!e)return this._emitError(new Error("Cannot parse property code type")),!1;const t=o.propertiesCodes[e];if(!t)return this._emitError(new Error("Unknown property")),!1;if("userProperties"!==t)r[t]?(Array.isArray(r[t])||(r[t]=[r[t]]),r[t].push(this._parseByType(o.propertiesTypes[t]))):r[t]=this._parseByType(o.propertiesTypes[t]);else{r[t]||(r[t]=Object.create(null));const e=this._parseByType(o.propertiesTypes[t]);if(r[t][e.name])if(Array.isArray(r[t][e.name]))r[t][e.name].push(e.value);else{const n=r[t][e.name];r[t][e.name]=[n],r[t][e.name].push(e.value)}else r[t][e.name]=e.value}}return r}_newPacket(){return a("_newPacket"),this.packet&&(this._list.consume(this.packet.length),a("_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d",this.packet.cmd,this.packet.payload,this.packet.length),this.emit("packet",this.packet)),a("_newPacket: new packet"),this.packet=new s,this._pos=0,!0}_emitError(e){a("_emitError",e),this.error=e,this.emit("error",e)}}t.exports=l},{"./constants":73,"./packet":94,bl:77,debug:30,events:49}],96:[function(e,t,r){const n=e("./constants"),{Buffer:i}=e("buffer"),s=i.allocUnsafe(0),o=i.from([0]),a=e("./numbers"),l=e("process-nextick-args").nextTick,u=e("debug")("mqtt-packet:writeToStream"),c=a.cache,h=a.generateNumber,f=a.generateCache,d=a.genBufVariableByteInt,p=a.generate4ByteBuffer;let b=E,g=!0;function m(e,t,r){switch(u("generate called"),t.cork&&(t.cork(),l(y,t)),g&&(g=!1,f()),u("generate: packet.cmd: %s",e.cmd),e.cmd){case"connect":return function(e,t,r){const s=e||{},o=s.protocolId||"MQTT";let a=s.protocolVersion||4;const l=s.will;let u=s.clean;const c=s.keepalive||0,h=s.clientId||"",f=s.username,d=s.password,p=s.properties;void 0===u&&(u=!0);let g,m,y=0;if(!o||"string"!=typeof o&&!i.isBuffer(o))return t.destroy(new Error("Invalid protocolId")),!1;y+=o.length+2;if(3!==a&&4!==a&&5!==a)return t.destroy(new Error("Invalid protocol version")),!1;y+=1;if(("string"==typeof h||i.isBuffer(h))&&(h||a>=4)&&(h||u))y+=i.byteLength(h)+2;else{if(a<4)return t.destroy(new Error("clientId must be supplied before 3.1.1")),!1;if(1*u==0)return t.destroy(new Error("clientId must be given if cleanSession set to 0")),!1}if("number"!=typeof c||c<0||c>65535||c%1!=0)return t.destroy(new Error("Invalid keepalive")),!1;y+=2;if(y+=1,5===a){if(g=T(t,p),!g)return!1;y+=g.length}if(l){if("object"!=typeof l)return t.destroy(new Error("Invalid will")),!1;if(!l.topic||"string"!=typeof l.topic)return t.destroy(new Error("Invalid will topic")),!1;if(y+=i.byteLength(l.topic)+2,y+=2,l.payload){if(!(l.payload.length>=0))return t.destroy(new Error("Invalid will payload")),!1;"string"==typeof l.payload?y+=i.byteLength(l.payload):y+=l.payload.length}if(m={},5===a){if(m=T(t,l.properties),!m)return!1;y+=m.length}}let _=!1;if(null!=f){if(!P(f))return t.destroy(new Error("Invalid username")),!1;_=!0,y+=i.byteLength(f)+2}if(null!=d){if(!_)return t.destroy(new Error("Username is required to use password")),!1;if(!P(d))return t.destroy(new Error("Invalid password")),!1;y+=C(d)+2}t.write(n.CONNECT_HEADER),w(t,y),k(t,o),s.bridgeMode&&(a+=128);t.write(131===a?n.VERSION131:132===a?n.VERSION132:4===a?n.VERSION4:5===a?n.VERSION5:n.VERSION3);let S=0;S|=null!=f?n.USERNAME_MASK:0,S|=null!=d?n.PASSWORD_MASK:0,S|=l&&l.retain?n.WILL_RETAIN_MASK:0,S|=l&&l.qos?l.qos<<n.WILL_QOS_SHIFT:0,S|=l?n.WILL_FLAG_MASK:0,S|=u?n.CLEAN_SESSION_MASK:0,t.write(i.from([S])),b(t,c),5===a&&g.write();k(t,h),l&&(5===a&&m.write(),v(t,l.topic),k(t,l.payload));null!=f&&k(t,f);null!=d&&k(t,d);return!0}(e,t);case"connack":return function(e,t,r){const s=r?r.protocolVersion:4,a=e||{},l=5===s?a.reasonCode:a.returnCode,u=a.properties;let c=2;if("number"!=typeof l)return t.destroy(new Error("Invalid return code")),!1;let h=null;if(5===s){if(h=T(t,u),!h)return!1;c+=h.length}t.write(n.CONNACK_HEADER),w(t,c),t.write(a.sessionPresent?n.SESSIONPRESENT_HEADER:o),t.write(i.from([l])),null!=h&&h.write();return!0}(e,t,r);case"publish":return function(e,t,r){u("publish: packet: %o",e);const o=r?r.protocolVersion:4,a=e||{},l=a.qos||0,c=a.retain?n.RETAIN_MASK:0,h=a.topic,f=a.payload||s,d=a.messageId,p=a.properties;let g=0;if("string"==typeof h)g+=i.byteLength(h)+2;else{if(!i.isBuffer(h))return t.destroy(new Error("Invalid topic")),!1;g+=h.length+2}i.isBuffer(f)?g+=f.length:g+=i.byteLength(f);if(l&&"number"!=typeof d)return t.destroy(new Error("Invalid messageId")),!1;l&&(g+=2);let m=null;if(5===o){if(m=T(t,p),!m)return!1;g+=m.length}t.write(n.PUBLISH_HEADER[l][a.dup?1:0][c?1:0]),w(t,g),b(t,C(h)),t.write(h),l>0&&b(t,d);null!=m&&m.write();return u("publish: payload: %o",f),t.write(f)}(e,t,r);case"puback":case"pubrec":case"pubrel":case"pubcomp":return function(e,t,r){const s=r?r.protocolVersion:4,o=e||{},a=o.cmd||"puback",l=o.messageId,u=o.dup&&"pubrel"===a?n.DUP_MASK:0;let c=0;const h=o.reasonCode,f=o.properties;let d=5===s?3:2;"pubrel"===a&&(c=1);if("number"!=typeof l)return t.destroy(new Error("Invalid messageId")),!1;let p=null;if(5===s&&"object"==typeof f){if(p=I(t,f,r,d),!p)return!1;d+=p.length}t.write(n.ACKS[a][c][u][0]),3===d&&(d+=0!==h?1:-1);w(t,d),b(t,l),5===s&&2!==d&&t.write(i.from([h]));null!==p?p.write():4===d&&t.write(i.from([0]));return!0}(e,t,r);case"subscribe":return function(e,t,r){u("subscribe: packet: ");const s=r?r.protocolVersion:4,o=e||{},a=o.dup?n.DUP_MASK:0,l=o.messageId,c=o.subscriptions,h=o.properties;let f=0;if("number"!=typeof l)return t.destroy(new Error("Invalid messageId")),!1;f+=2;let d=null;if(5===s){if(d=T(t,h),!d)return!1;f+=d.length}if("object"!=typeof c||!c.length)return t.destroy(new Error("Invalid subscriptions")),!1;for(let e=0;e<c.length;e+=1){const r=c[e].topic,n=c[e].qos;if("string"!=typeof r)return t.destroy(new Error("Invalid subscriptions - invalid topic")),!1;if("number"!=typeof n)return t.destroy(new Error("Invalid subscriptions - invalid qos")),!1;if(5===s){if("boolean"!=typeof(c[e].nl||!1))return t.destroy(new Error("Invalid subscriptions - invalid No Local")),!1;if("boolean"!=typeof(c[e].rap||!1))return t.destroy(new Error("Invalid subscriptions - invalid Retain as Published")),!1;const r=c[e].rh||0;if("number"!=typeof r||r>2)return t.destroy(new Error("Invalid subscriptions - invalid Retain Handling")),!1}f+=i.byteLength(r)+2+1}u("subscribe: writing to stream: %o",n.SUBSCRIBE_HEADER),t.write(n.SUBSCRIBE_HEADER[1][a?1:0][0]),w(t,f),b(t,l),null!==d&&d.write();let p=!0;for(const e of c){const r=e.topic,o=e.qos,a=+e.nl,l=+e.rap,u=e.rh;let c;v(t,r),c=n.SUBSCRIBE_OPTIONS_QOS[o],5===s&&(c|=a?n.SUBSCRIBE_OPTIONS_NL:0,c|=l?n.SUBSCRIBE_OPTIONS_RAP:0,c|=u?n.SUBSCRIBE_OPTIONS_RH[u]:0),p=t.write(i.from([c]))}return p}(e,t,r);case"suback":return function(e,t,r){const s=r?r.protocolVersion:4,o=e||{},a=o.messageId,l=o.granted,u=o.properties;let c=0;if("number"!=typeof a)return t.destroy(new Error("Invalid messageId")),!1;c+=2;if("object"!=typeof l||!l.length)return t.destroy(new Error("Invalid qos vector")),!1;for(let e=0;e<l.length;e+=1){if("number"!=typeof l[e])return t.destroy(new Error("Invalid qos vector")),!1;c+=1}let h=null;if(5===s){if(h=I(t,u,r,c),!h)return!1;c+=h.length}t.write(n.SUBACK_HEADER),w(t,c),b(t,a),null!==h&&h.write();return t.write(i.from(l))}(e,t,r);case"unsubscribe":return function(e,t,r){const s=r?r.protocolVersion:4,o=e||{},a=o.messageId,l=o.dup?n.DUP_MASK:0,u=o.unsubscriptions,c=o.properties;let h=0;if("number"!=typeof a)return t.destroy(new Error("Invalid messageId")),!1;h+=2;if("object"!=typeof u||!u.length)return t.destroy(new Error("Invalid unsubscriptions")),!1;for(let e=0;e<u.length;e+=1){if("string"!=typeof u[e])return t.destroy(new Error("Invalid unsubscriptions")),!1;h+=i.byteLength(u[e])+2}let f=null;if(5===s){if(f=T(t,c),!f)return!1;h+=f.length}t.write(n.UNSUBSCRIBE_HEADER[1][l?1:0][0]),w(t,h),b(t,a),null!==f&&f.write();let d=!0;for(let e=0;e<u.length;e++)d=v(t,u[e]);return d}(e,t,r);case"unsuback":return function(e,t,r){const s=r?r.protocolVersion:4,o=e||{},a=o.messageId,l=o.dup?n.DUP_MASK:0,u=o.granted,c=o.properties,h=o.cmd,f=0;let d=2;if("number"!=typeof a)return t.destroy(new Error("Invalid messageId")),!1;if(5===s){if("object"!=typeof u||!u.length)return t.destroy(new Error("Invalid qos vector")),!1;for(let e=0;e<u.length;e+=1){if("number"!=typeof u[e])return t.destroy(new Error("Invalid qos vector")),!1;d+=1}}let p=null;if(5===s){if(p=I(t,c,r,d),!p)return!1;d+=p.length}t.write(n.ACKS[h][f][l][0]),w(t,d),b(t,a),null!==p&&p.write();5===s&&t.write(i.from(u));return!0}(e,t,r);case"pingreq":case"pingresp":return function(e,t,r){return t.write(n.EMPTY[e.cmd])}(e,t);case"disconnect":return function(e,t,r){const s=r?r.protocolVersion:4,o=e||{},a=o.reasonCode,l=o.properties;let u=5===s?1:0,c=null;if(5===s){if(c=I(t,l,r,u),!c)return!1;u+=c.length}t.write(i.from([n.codes.disconnect<<4])),w(t,u),5===s&&t.write(i.from([a]));null!==c&&c.write();return!0}(e,t,r);case"auth":return function(e,t,r){const s=r?r.protocolVersion:4,o=e||{},a=o.reasonCode,l=o.properties;let u=5===s?1:0;5!==s&&t.destroy(new Error("Invalid mqtt version for auth packet"));const c=I(t,l,r,u);if(!c)return!1;u+=c.length,t.write(i.from([n.codes.auth<<4])),w(t,u),t.write(i.from([a])),null!==c&&c.write();return!0}(e,t,r);default:return t.destroy(new Error("Unknown command")),!1}}function y(e){e.uncork()}Object.defineProperty(m,"cacheNumbers",{get:()=>b===E,set(e){e?(c&&0!==Object.keys(c).length||(g=!0),b=E):(g=!1,b=A)}});const _={};function w(e,t){if(t>n.VARBYTEINT_MAX)return e.destroy(new Error(`Invalid variable byte integer: ${t}`)),!1;let r=_[t];return r||(r=d(t),t<16384&&(_[t]=r)),u("writeVarByteInt: writing to stream: %o",r),e.write(r)}function v(e,t){const r=i.byteLength(t);return b(e,r),u("writeString: %s",t),e.write(t,"utf8")}function S(e,t,r){v(e,t),v(e,r)}function E(e,t){return u("writeNumberCached: number: %d",t),u("writeNumberCached: %o",c[t]),e.write(c[t])}function A(e,t){const r=h(t);return u("writeNumberGenerated: %o",r),e.write(r)}function k(e,t){"string"==typeof t?v(e,t):t?(b(e,t.length),e.write(t)):b(e,0)}function T(e,t){if("object"!=typeof t||null!=t.length)return{length:1,write(){O(e,{},0)}};let r=0;function s(t,r){let s=0;switch(n.propertiesTypes[t]){case"byte":if("boolean"!=typeof r)return e.destroy(new Error(`Invalid ${t}: ${r}`)),!1;s+=2;break;case"int8":if("number"!=typeof r||r<0||r>255)return e.destroy(new Error(`Invalid ${t}: ${r}`)),!1;s+=2;break;case"binary":if(r&&null===r)return e.destroy(new Error(`Invalid ${t}: ${r}`)),!1;s+=1+i.byteLength(r)+2;break;case"int16":if("number"!=typeof r||r<0||r>65535)return e.destroy(new Error(`Invalid ${t}: ${r}`)),!1;s+=3;break;case"int32":if("number"!=typeof r||r<0||r>4294967295)return e.destroy(new Error(`Invalid ${t}: ${r}`)),!1;s+=5;break;case"var":if("number"!=typeof r||r<0||r>268435455)return e.destroy(new Error(`Invalid ${t}: ${r}`)),!1;s+=1+i.byteLength(d(r));break;case"string":if("string"!=typeof r)return e.destroy(new Error(`Invalid ${t}: ${r}`)),!1;s+=3+i.byteLength(r.toString());break;case"pair":if("object"!=typeof r)return e.destroy(new Error(`Invalid ${t}: ${r}`)),!1;s+=Object.getOwnPropertyNames(r).reduce(((e,t)=>{const n=r[t];return Array.isArray(n)?e+=n.reduce(((e,r)=>e+=3+i.byteLength(t.toString())+2+i.byteLength(r.toString())),0):e+=3+i.byteLength(t.toString())+2+i.byteLength(r[t].toString()),e}),0);break;default:return e.destroy(new Error(`Invalid property ${t}: ${r}`)),!1}return s}if(t)for(const e in t){let n=0,i=0;const o=t[e];if(Array.isArray(o))for(let t=0;t<o.length;t++){if(i=s(e,o[t]),!i)return!1;n+=i}else{if(i=s(e,o),!i)return!1;n=i}if(!n)return!1;r+=n}return{length:i.byteLength(d(r))+r,write(){O(e,t,r)}}}function I(e,t,r,n){const i=["reasonString","userProperties"],s=r&&r.properties&&r.properties.maximumPacketSize?r.properties.maximumPacketSize:0;let o=T(e,t);if(s)for(;n+o.length>s;){const r=i.shift();if(!r||!t[r])return!1;delete t[r],o=T(e,t)}return o}function R(e,t,r){switch(n.propertiesTypes[t]){case"byte":e.write(i.from([n.properties[t]])),e.write(i.from([+r]));break;case"int8":e.write(i.from([n.properties[t]])),e.write(i.from([r]));break;case"binary":e.write(i.from([n.properties[t]])),k(e,r);break;case"int16":e.write(i.from([n.properties[t]])),b(e,r);break;case"int32":e.write(i.from([n.properties[t]])),function(e,t){const r=p(t);u("write4ByteNumber: %o",r),e.write(r)}(e,r);break;case"var":e.write(i.from([n.properties[t]])),w(e,r);break;case"string":e.write(i.from([n.properties[t]])),v(e,r);break;case"pair":Object.getOwnPropertyNames(r).forEach((s=>{const o=r[s];Array.isArray(o)?o.forEach((r=>{e.write(i.from([n.properties[t]])),S(e,s.toString(),r.toString())})):(e.write(i.from([n.properties[t]])),S(e,s.toString(),o.toString()))}));break;default:return e.destroy(new Error(`Invalid property ${t} value: ${r}`)),!1}}function O(e,t,r){w(e,r);for(const r in t)if(Object.prototype.hasOwnProperty.call(t,r)&&null!==t[r]){const n=t[r];if(Array.isArray(n))for(let t=0;t<n.length;t++)R(e,r,n[t]);else R(e,r,n)}}function C(e){return e?e instanceof i?e.length:i.byteLength(e):0}function P(e){return"string"==typeof e||e instanceof i}t.exports=m},{"./constants":73,"./numbers":93,buffer:29,debug:30,"process-nextick-args":101}],97:[function(e,t,r){var n=1e3,i=60*n,s=60*i,o=24*s,a=7*o,l=365.25*o;function u(e,t,r,n){var i=t>=1.5*r;return Math.round(e/r)+" "+n+(i?"s":"")}t.exports=function(e,t){t=t||{};var r=typeof e;if("string"===r&&e.length>0)return function(e){if((e=String(e)).length>100)return;var t=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);if(!t)return;var r=parseFloat(t[1]);switch((t[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return r*l;case"weeks":case"week":case"w":return r*a;case"days":case"day":case"d":return r*o;case"hours":case"hour":case"hrs":case"hr":case"h":return r*s;case"minutes":case"minute":case"mins":case"min":case"m":return r*i;case"seconds":case"second":case"secs":case"sec":case"s":return r*n;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return r;default:return}}(e);if("number"===r&&isFinite(e))return t.long?function(e){var t=Math.abs(e);if(t>=o)return u(e,t,o,"day");if(t>=s)return u(e,t,s,"hour");if(t>=i)return u(e,t,i,"minute");if(t>=n)return u(e,t,n,"second");return e+" ms"}(e):function(e){var t=Math.abs(e);if(t>=o)return Math.round(e/o)+"d";if(t>=s)return Math.round(e/s)+"h";if(t>=i)return Math.round(e/i)+"m";if(t>=n)return Math.round(e/n)+"s";return e+"ms"}(e);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(e))}},{}],98:[function(e,t,r){const n=e("./lib/number-allocator.js");t.exports.NumberAllocator=n},{"./lib/number-allocator.js":99}],99:[function(e,t,r){"use strict";const n=e("js-sdsl").OrderedSet,i=e("debug")("number-allocator:trace"),s=e("debug")("number-allocator:error");function o(e,t){this.low=e,this.high=t}function a(e,t){if(!(this instanceof a))return new a(e,t);this.min=e,this.max=t,this.ss=new n([],((e,t)=>e.compare(t))),i("Create"),this.clear()}o.prototype.equals=function(e){return this.low===e.low&&this.high===e.high},o.prototype.compare=function(e){return this.low<e.low&&this.high<e.low?-1:e.low<this.low&&e.high<this.low?1:0},a.prototype.firstVacant=function(){return 0===this.ss.size()?null:this.ss.front().low},a.prototype.alloc=function(){if(0===this.ss.size())return i("alloc():empty"),null;const e=this.ss.begin(),t=e.pointer.low,r=e.pointer.high,n=t;return n+1<=r?this.ss.updateKeyByIterator(e,new o(t+1,r)):this.ss.eraseElementByPos(0),i("alloc():"+n),n},a.prototype.use=function(e){const t=new o(e,e),r=this.ss.lowerBound(t);if(!r.equals(this.ss.end())){const n=r.pointer.low,s=r.pointer.high;return r.pointer.equals(t)?(this.ss.eraseElementByIterator(r),i("use():"+e),!0):!(n>e)&&(n===e?(this.ss.updateKeyByIterator(r,new o(n+1,s)),i("use():"+e),!0):s===e?(this.ss.updateKeyByIterator(r,new o(n,s-1)),i("use():"+e),!0):(this.ss.updateKeyByIterator(r,new o(e+1,s)),this.ss.insert(new o(n,e-1)),i("use():"+e),!0))}return i("use():failed"),!1},a.prototype.free=function(e){if(e<this.min||e>this.max)return void s("free():"+e+" is out of range");const t=new o(e,e),r=this.ss.upperBound(t);if(r.equals(this.ss.end())){if(r.equals(this.ss.begin()))return void this.ss.insert(t);r.pre();const n=r.pointer.high;r.pointer.high+1===e?this.ss.updateKeyByIterator(r,new o(n,e)):this.ss.insert(t)}else if(r.equals(this.ss.begin()))if(e+1===r.pointer.low){const t=r.pointer.high;this.ss.updateKeyByIterator(r,new o(e,t))}else this.ss.insert(t);else{const n=r.pointer.low,i=r.pointer.high;r.pre();const s=r.pointer.low;r.pointer.high+1===e?e+1===n?(this.ss.eraseElementByIterator(r),this.ss.updateKeyByIterator(r,new o(s,i))):this.ss.updateKeyByIterator(r,new o(s,e)):e+1===n?(this.ss.eraseElementByIterator(r.next()),this.ss.insert(new o(e,i))):this.ss.insert(t)}i("free():"+e)},a.prototype.clear=function(){i("clear()"),this.ss.clear(),this.ss.insert(new o(this.min,this.max))},a.prototype.intervalCount=function(){return this.ss.size()},a.prototype.dump=function(){console.log("length:"+this.ss.size());for(const e of this.ss)console.log(e)},t.exports=a},{debug:30,"js-sdsl":69}],100:[function(e,t,r){var n=e("wrappy");function i(e){var t=function(){return t.called?t.value:(t.called=!0,t.value=e.apply(this,arguments))};return t.called=!1,t}function s(e){var t=function(){if(t.called)throw new Error(t.onceError);return t.called=!0,t.value=e.apply(this,arguments)},r=e.name||"Function wrapped with `once`";return t.onceError=r+" shouldn't be called more than once",t.called=!1,t}t.exports=n(i),t.exports.strict=n(s),i.proto=i((function(){Object.defineProperty(Function.prototype,"once",{value:function(){return i(this)},configurable:!0}),Object.defineProperty(Function.prototype,"onceStrict",{value:function(){return s(this)},configurable:!0})}))},{wrappy:140}],101:[function(e,t,r){(function(e){(function(){"use strict";void 0===e||!e.version||0===e.version.indexOf("v0.")||0===e.version.indexOf("v1.")&&0!==e.version.indexOf("v1.8.")?t.exports={nextTick:function(t,r,n,i){if("function"!=typeof t)throw new TypeError('"callback" argument must be a function');var s,o,a=arguments.length;switch(a){case 0:case 1:return e.nextTick(t);case 2:return e.nextTick((function(){t.call(null,r)}));case 3:return e.nextTick((function(){t.call(null,r,n)}));case 4:return e.nextTick((function(){t.call(null,r,n,i)}));default:for(s=new Array(a-1),o=0;o<s.length;)s[o++]=arguments[o];return e.nextTick((function(){t.apply(null,s)}))}}}:t.exports=e}).call(this)}).call(this,e("_process"))},{_process:102}],102:[function(e,t,r){var n,i,s=t.exports={};function o(){throw new Error("setTimeout has not been defined")}function a(){throw new Error("clearTimeout has not been defined")}function l(e){if(n===setTimeout)return setTimeout(e,0);if((n===o||!n)&&setTimeout)return n=setTimeout,setTimeout(e,0);try{return n(e,0)}catch(t){try{return n.call(null,e,0)}catch(t){return n.call(this,e,0)}}}!function(){try{n="function"==typeof setTimeout?setTimeout:o}catch(e){n=o}try{i="function"==typeof clearTimeout?clearTimeout:a}catch(e){i=a}}();var u,c=[],h=!1,f=-1;function d(){h&&u&&(h=!1,u.length?c=u.concat(c):f=-1,c.length&&p())}function p(){if(!h){var e=l(d);h=!0;for(var t=c.length;t;){for(u=c,c=[];++f<t;)u&&u[f].run();f=-1,t=c.length}u=null,h=!1,function(e){if(i===clearTimeout)return clearTimeout(e);if((i===a||!i)&&clearTimeout)return i=clearTimeout,clearTimeout(e);try{return i(e)}catch(t){try{return i.call(null,e)}catch(t){return i.call(this,e)}}}(e)}}function b(e,t){this.fun=e,this.array=t}function g(){}s.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];c.push(new b(e,t)),1!==c.length||h||l(p)},b.prototype.run=function(){this.fun.apply(null,this.array)},s.title="browser",s.browser=!0,s.env={},s.argv=[],s.version="",s.versions={},s.on=g,s.addListener=g,s.once=g,s.off=g,s.removeListener=g,s.removeAllListeners=g,s.emit=g,s.prependListener=g,s.prependOnceListener=g,s.listeners=function(e){return[]},s.binding=function(e){throw new Error("process.binding is not supported")},s.cwd=function(){return"/"},s.chdir=function(e){throw new Error("process.chdir is not supported")},s.umask=function(){return 0}},{}],103:[function(e,t,r){(function(e){(function(){!function(n){var i="object"==typeof r&&r&&!r.nodeType&&r,s="object"==typeof t&&t&&!t.nodeType&&t,o="object"==typeof e&&e;o.global!==o&&o.window!==o&&o.self!==o||(n=o);var a,l,u=2147483647,c=36,h=1,f=26,d=38,p=700,b=72,g=128,m="-",y=/^xn--/,_=/[^\x20-\x7E]/,w=/[\x2E\u3002\uFF0E\uFF61]/g,v={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},S=c-h,E=Math.floor,A=String.fromCharCode;function k(e){throw new RangeError(v[e])}function T(e,t){for(var r=e.length,n=[];r--;)n[r]=t(e[r]);return n}function I(e,t){var r=e.split("@"),n="";return r.length>1&&(n=r[0]+"@",e=r[1]),n+T((e=e.replace(w,".")).split("."),t).join(".")}function R(e){for(var t,r,n=[],i=0,s=e.length;i<s;)(t=e.charCodeAt(i++))>=55296&&t<=56319&&i<s?56320==(64512&(r=e.charCodeAt(i++)))?n.push(((1023&t)<<10)+(1023&r)+65536):(n.push(t),i--):n.push(t);return n}function O(e){return T(e,(function(e){var t="";return e>65535&&(t+=A((e-=65536)>>>10&1023|55296),e=56320|1023&e),t+=A(e)})).join("")}function C(e,t){return e+22+75*(e<26)-((0!=t)<<5)}function P(e,t,r){var n=0;for(e=r?E(e/p):e>>1,e+=E(e/t);e>S*f>>1;n+=c)e=E(e/S);return E(n+(S+1)*e/(e+d))}function x(e){var t,r,n,i,s,o,a,l,d,p,y,_=[],w=e.length,v=0,S=g,A=b;for((r=e.lastIndexOf(m))<0&&(r=0),n=0;n<r;++n)e.charCodeAt(n)>=128&&k("not-basic"),_.push(e.charCodeAt(n));for(i=r>0?r+1:0;i<w;){for(s=v,o=1,a=c;i>=w&&k("invalid-input"),((l=(y=e.charCodeAt(i++))-48<10?y-22:y-65<26?y-65:y-97<26?y-97:c)>=c||l>E((u-v)/o))&&k("overflow"),v+=l*o,!(l<(d=a<=A?h:a>=A+f?f:a-A));a+=c)o>E(u/(p=c-d))&&k("overflow"),o*=p;A=P(v-s,t=_.length+1,0==s),E(v/t)>u-S&&k("overflow"),S+=E(v/t),v%=t,_.splice(v++,0,S)}return O(_)}function M(e){var t,r,n,i,s,o,a,l,d,p,y,_,w,v,S,T=[];for(_=(e=R(e)).length,t=g,r=0,s=b,o=0;o<_;++o)(y=e[o])<128&&T.push(A(y));for(n=i=T.length,i&&T.push(m);n<_;){for(a=u,o=0;o<_;++o)(y=e[o])>=t&&y<a&&(a=y);for(a-t>E((u-r)/(w=n+1))&&k("overflow"),r+=(a-t)*w,t=a,o=0;o<_;++o)if((y=e[o])<t&&++r>u&&k("overflow"),y==t){for(l=r,d=c;!(l<(p=d<=s?h:d>=s+f?f:d-s));d+=c)S=l-p,v=c-p,T.push(A(C(p+S%v,0))),l=E(S/v);T.push(A(C(l,0))),s=P(r,w,n==i),r=0,++n}++r,++t}return T.join("")}if(a={version:"1.4.1",ucs2:{decode:R,encode:O},decode:x,encode:M,toASCII:function(e){return I(e,(function(e){return _.test(e)?"xn--"+M(e):e}))},toUnicode:function(e){return I(e,(function(e){return y.test(e)?x(e.slice(4).toLowerCase()):e}))}},i&&s)if(t.exports==i)s.exports=a;else for(l in a)a.hasOwnProperty(l)&&(i[l]=a[l]);else n.punycode=a}(this)}).call(this)}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],104:[function(e,t,r){"use strict";function n(e,t){return Object.prototype.hasOwnProperty.call(e,t)}t.exports=function(e,t,r,s){t=t||"&",r=r||"=";var o={};if("string"!=typeof e||0===e.length)return o;var a=/\+/g;e=e.split(t);var l=1e3;s&&"number"==typeof s.maxKeys&&(l=s.maxKeys);var u=e.length;l>0&&u>l&&(u=l);for(var c=0;c<u;++c){var h,f,d,p,b=e[c].replace(a,"%20"),g=b.indexOf(r);g>=0?(h=b.substr(0,g),f=b.substr(g+1)):(h=b,f=""),d=decodeURIComponent(h),p=decodeURIComponent(f),n(o,d)?i(o[d])?o[d].push(p):o[d]=[o[d],p]:o[d]=p}return o};var i=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)}},{}],105:[function(e,t,r){"use strict";var n=function(e){switch(typeof e){case"string":return e;case"boolean":return e?"true":"false";case"number":return isFinite(e)?e:"";default:return""}};t.exports=function(e,t,r,a){return t=t||"&",r=r||"=",null===e&&(e=void 0),"object"==typeof e?s(o(e),(function(o){var a=encodeURIComponent(n(o))+r;return i(e[o])?s(e[o],(function(e){return a+encodeURIComponent(n(e))})).join(t):a+encodeURIComponent(n(e[o]))})).join(t):a?encodeURIComponent(n(a))+r+encodeURIComponent(n(e)):""};var i=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)};function s(e,t){if(e.map)return e.map(t);for(var r=[],n=0;n<e.length;n++)r.push(t(e[n],n));return r}var o=Object.keys||function(e){var t=[];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.push(r);return t}},{}],106:[function(e,t,r){"use strict";r.decode=r.parse=e("./decode"),r.encode=r.stringify=e("./encode")},{"./decode":104,"./encode":105}],107:[function(e,t,r){"use strict";const{AbortError:n,codes:i}=e("../../ours/errors"),{isNodeStream:s,isWebStream:o,kControllerErrorFunction:a}=e("./utils"),l=e("./end-of-stream"),{ERR_INVALID_ARG_TYPE:u}=i;t.exports.addAbortSignal=function(e,r){if(((e,t)=>{if("object"!=typeof e||!("aborted"in e))throw new u(t,"AbortSignal",e)})(e,"signal"),!s(r)&&!o(r))throw new u("stream",["ReadableStream","WritableStream","Stream"],r);return t.exports.addAbortSignalNoValidate(e,r)},t.exports.addAbortSignalNoValidate=function(e,t){if("object"!=typeof e||!("aborted"in e))return t;const r=s(t)?()=>{t.destroy(new n(void 0,{cause:e.reason}))}:()=>{t[a](new n(void 0,{cause:e.reason}))};return e.aborted?r():(e.addEventListener("abort",r),l(t,(()=>e.removeEventListener("abort",r)))),t}},{"../../ours/errors":126,"./end-of-stream":113,"./utils":122}],108:[function(e,t,r){"use strict";const{StringPrototypeSlice:n,SymbolIterator:i,TypedArrayPrototypeSet:s,Uint8Array:o}=e("../../ours/primordials"),{Buffer:a}=e("buffer"),{inspect:l}=e("../../ours/util");t.exports=class{constructor(){this.head=null,this.tail=null,this.length=0}push(e){const t={data:e,next:null};this.length>0?this.tail.next=t:this.head=t,this.tail=t,++this.length}unshift(e){const t={data:e,next:this.head};0===this.length&&(this.tail=t),this.head=t,++this.length}shift(){if(0===this.length)return;const e=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,e}clear(){this.head=this.tail=null,this.length=0}join(e){if(0===this.length)return"";let t=this.head,r=""+t.data;for(;null!==(t=t.next);)r+=e+t.data;return r}concat(e){if(0===this.length)return a.alloc(0);const t=a.allocUnsafe(e>>>0);let r=this.head,n=0;for(;r;)s(t,r.data,n),n+=r.data.length,r=r.next;return t}consume(e,t){const r=this.head.data;if(e<r.length){const t=r.slice(0,e);return this.head.data=r.slice(e),t}return e===r.length?this.shift():t?this._getString(e):this._getBuffer(e)}first(){return this.head.data}*[i](){for(let e=this.head;e;e=e.next)yield e.data}_getString(e){let t="",r=this.head,i=0;do{const s=r.data;if(!(e>s.length)){e===s.length?(t+=s,++i,r.next?this.head=r.next:this.head=this.tail=null):(t+=n(s,0,e),this.head=r,r.data=n(s,e));break}t+=s,e-=s.length,++i}while(null!==(r=r.next));return this.length-=i,t}_getBuffer(e){const t=a.allocUnsafe(e),r=e;let n=this.head,i=0;do{const a=n.data;if(!(e>a.length)){e===a.length?(s(t,a,r-e),++i,n.next?this.head=n.next:this.head=this.tail=null):(s(t,new o(a.buffer,a.byteOffset,e),r-e),this.head=n,n.data=a.slice(e));break}s(t,a,r-e),e-=a.length,++i}while(null!==(n=n.next));return this.length-=i,t}[Symbol.for("nodejs.util.inspect.custom")](e,t){return l(this,{...t,depth:0,customInspect:!1})}}},{"../../ours/primordials":127,"../../ours/util":128,buffer:29}],109:[function(e,t,r){"use strict";const{pipeline:n}=e("./pipeline"),i=e("./duplex"),{destroyer:s}=e("./destroy"),{isNodeStream:o,isReadable:a,isWritable:l,isWebStream:u,isTransformStream:c,isWritableStream:h,isReadableStream:f}=e("./utils"),{AbortError:d,codes:{ERR_INVALID_ARG_VALUE:p,ERR_MISSING_ARGS:b}}=e("../../ours/errors"),g=e("./end-of-stream");t.exports=function(...e){if(0===e.length)throw new b("streams");if(1===e.length)return i.from(e[0]);const t=[...e];if("function"==typeof e[0]&&(e[0]=i.from(e[0])),"function"==typeof e[e.length-1]){const t=e.length-1;e[t]=i.from(e[t])}for(let r=0;r<e.length;++r)if(o(e[r])||u(e[r])){if(r<e.length-1&&!(a(e[r])||f(e[r])||c(e[r])))throw new p(`streams[${r}]`,t[r],"must be readable");if(r>0&&!(l(e[r])||h(e[r])||c(e[r])))throw new p(`streams[${r}]`,t[r],"must be writable")}let r,m,y,_,w;const v=e[0],S=n(e,(function(e){const t=_;_=null,t?t(e):e?w.destroy(e):A||E||w.destroy()})),E=!!(l(v)||h(v)||c(v)),A=!!(a(S)||f(S)||c(S));if(w=new i({writableObjectMode:!(null==v||!v.writableObjectMode),readableObjectMode:!(null==S||!S.writableObjectMode),writable:E,readable:A}),E){if(o(v))w._write=function(e,t,n){v.write(e,t)?n():r=n},w._final=function(e){v.end(),m=e},v.on("drain",(function(){if(r){const e=r;r=null,e()}}));else if(u(v)){const e=(c(v)?v.writable:v).getWriter();w._write=async function(t,r,n){try{await e.ready,e.write(t).catch((()=>{})),n()}catch(e){n(e)}},w._final=async function(t){try{await e.ready,e.close().catch((()=>{})),m=t}catch(e){t(e)}}}const e=c(S)?S.readable:S;g(e,(()=>{if(m){const e=m;m=null,e()}}))}if(A)if(o(S))S.on("readable",(function(){if(y){const e=y;y=null,e()}})),S.on("end",(function(){w.push(null)})),w._read=function(){for(;;){const e=S.read();if(null===e)return void(y=w._read);if(!w.push(e))return}};else if(u(S)){const e=(c(S)?S.readable:S).getReader();w._read=async function(){for(;;)try{const{value:t,done:r}=await e.read();if(!w.push(t))return;if(r)return void w.push(null)}catch{return}}}return w._destroy=function(e,t){e||null===_||(e=new d),y=null,r=null,m=null,null===_?t(e):(_=t,o(S)&&s(S,e))},w}},{"../../ours/errors":126,"./destroy":110,"./duplex":111,"./end-of-stream":113,"./pipeline":118,"./utils":122}],110:[function(e,t,r){"use strict";const n=e("process/"),{aggregateTwoErrors:i,codes:{ERR_MULTIPLE_CALLBACK:s},AbortError:o}=e("../../ours/errors"),{Symbol:a}=e("../../ours/primordials"),{kDestroyed:l,isDestroyed:u,isFinished:c,isServerRequest:h}=e("./utils"),f=a("kDestroy"),d=a("kConstruct");function p(e,t,r){e&&(e.stack,t&&!t.errored&&(t.errored=e),r&&!r.errored&&(r.errored=e))}function b(e,t,r){let i=!1;function s(t){if(i)return;i=!0;const s=e._readableState,o=e._writableState;p(t,o,s),o&&(o.closed=!0),s&&(s.closed=!0),"function"==typeof r&&r(t),t?n.nextTick(g,e,t):n.nextTick(m,e)}try{e._destroy(t||null,s)}catch(t){s(t)}}function g(e,t){y(e,t),m(e)}function m(e){const t=e._readableState,r=e._writableState;r&&(r.closeEmitted=!0),t&&(t.closeEmitted=!0),(null!=r&&r.emitClose||null!=t&&t.emitClose)&&e.emit("close")}function y(e,t){const r=e._readableState,n=e._writableState;null!=n&&n.errorEmitted||null!=r&&r.errorEmitted||(n&&(n.errorEmitted=!0),r&&(r.errorEmitted=!0),e.emit("error",t))}function _(e,t,r){const i=e._readableState,s=e._writableState;if(null!=s&&s.destroyed||null!=i&&i.destroyed)return this;null!=i&&i.autoDestroy||null!=s&&s.autoDestroy?e.destroy(t):t&&(t.stack,s&&!s.errored&&(s.errored=t),i&&!i.errored&&(i.errored=t),r?n.nextTick(y,e,t):y(e,t))}function w(e){let t=!1;function r(r){if(t)return void _(e,null!=r?r:new s);t=!0;const i=e._readableState,o=e._writableState,a=o||i;i&&(i.constructed=!0),o&&(o.constructed=!0),a.destroyed?e.emit(f,r):r?_(e,r,!0):n.nextTick(v,e)}try{e._construct((e=>{n.nextTick(r,e)}))}catch(e){n.nextTick(r,e)}}function v(e){e.emit(d)}function S(e){return(null==e?void 0:e.setHeader)&&"function"==typeof e.abort}function E(e){e.emit("close")}function A(e,t){e.emit("error",t),n.nextTick(E,e)}t.exports={construct:function(e,t){if("function"!=typeof e._construct)return;const r=e._readableState,i=e._writableState;r&&(r.constructed=!1),i&&(i.constructed=!1),e.once(d,t),e.listenerCount(d)>1||n.nextTick(w,e)},destroyer:function(e,t){e&&!u(e)&&(t||c(e)||(t=new o),h(e)?(e.socket=null,e.destroy(t)):S(e)?e.abort():S(e.req)?e.req.abort():"function"==typeof e.destroy?e.destroy(t):"function"==typeof e.close?e.close():t?n.nextTick(A,e,t):n.nextTick(E,e),e.destroyed||(e[l]=!0))},destroy:function(e,t){const r=this._readableState,n=this._writableState,s=n||r;return null!=n&&n.destroyed||null!=r&&r.destroyed?("function"==typeof t&&t(),this):(p(e,n,r),n&&(n.destroyed=!0),r&&(r.destroyed=!0),s.constructed?b(this,e,t):this.once(f,(function(r){b(this,i(r,e),t)})),this)},undestroy:function(){const e=this._readableState,t=this._writableState;e&&(e.constructed=!0,e.closed=!1,e.closeEmitted=!1,e.destroyed=!1,e.errored=null,e.errorEmitted=!1,e.reading=!1,e.ended=!1===e.readable,e.endEmitted=!1===e.readable),t&&(t.constructed=!0,t.destroyed=!1,t.closed=!1,t.closeEmitted=!1,t.errored=null,t.errorEmitted=!1,t.finalCalled=!1,t.prefinished=!1,t.ended=!1===t.writable,t.ending=!1===t.writable,t.finished=!1===t.writable)},errorOrDestroy:_}},{"../../ours/errors":126,"../../ours/primordials":127,"./utils":122,"process/":102}],111:[function(e,t,r){"use strict";const{ObjectDefineProperties:n,ObjectGetOwnPropertyDescriptor:i,ObjectKeys:s,ObjectSetPrototypeOf:o}=e("../../ours/primordials");t.exports=u;const a=e("./readable"),l=e("./writable");o(u.prototype,a.prototype),o(u,a);{const e=s(l.prototype);for(let t=0;t<e.length;t++){const r=e[t];u.prototype[r]||(u.prototype[r]=l.prototype[r])}}function u(e){if(!(this instanceof u))return new u(e);a.call(this,e),l.call(this,e),e?(this.allowHalfOpen=!1!==e.allowHalfOpen,!1===e.readable&&(this._readableState.readable=!1,this._readableState.ended=!0,this._readableState.endEmitted=!0),!1===e.writable&&(this._writableState.writable=!1,this._writableState.ending=!0,this._writableState.ended=!0,this._writableState.finished=!0)):this.allowHalfOpen=!0}let c,h;function f(){return void 0===c&&(c={}),c}n(u.prototype,{writable:{__proto__:null,...i(l.prototype,"writable")},writableHighWaterMark:{__proto__:null,...i(l.prototype,"writableHighWaterMark")},writableObjectMode:{__proto__:null,...i(l.prototype,"writableObjectMode")},writableBuffer:{__proto__:null,...i(l.prototype,"writableBuffer")},writableLength:{__proto__:null,...i(l.prototype,"writableLength")},writableFinished:{__proto__:null,...i(l.prototype,"writableFinished")},writableCorked:{__proto__:null,...i(l.prototype,"writableCorked")},writableEnded:{__proto__:null,...i(l.prototype,"writableEnded")},writableNeedDrain:{__proto__:null,...i(l.prototype,"writableNeedDrain")},destroyed:{__proto__:null,get(){return void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed&&this._writableState.destroyed)},set(e){this._readableState&&this._writableState&&(this._readableState.destroyed=e,this._writableState.destroyed=e)}}}),u.fromWeb=function(e,t){return f().newStreamDuplexFromReadableWritablePair(e,t)},u.toWeb=function(e){return f().newReadableWritablePairFromDuplex(e)},u.from=function(t){return h||(h=e("./duplexify")),h(t,"body")}},{"../../ours/primordials":127,"./duplexify":112,"./readable":119,"./writable":123}],112:[function(e,t,r){const n=e("process/"),i=e("buffer"),{isReadable:s,isWritable:o,isIterable:a,isNodeStream:l,isReadableNodeStream:u,isWritableNodeStream:c,isDuplexNodeStream:h}=e("./utils"),f=e("./end-of-stream"),{AbortError:d,codes:{ERR_INVALID_ARG_TYPE:p,ERR_INVALID_RETURN_VALUE:b}}=e("../../ours/errors"),{destroyer:g}=e("./destroy"),m=e("./duplex"),y=e("./readable"),{createDeferredPromise:_}=e("../../ours/util"),w=e("./from"),v=globalThis.Blob||i.Blob,S=void 0!==v?function(e){return e instanceof v}:function(e){return!1},E=globalThis.AbortController||e("abort-controller").AbortController,{FunctionPrototypeCall:A}=e("../../ours/primordials");class k extends m{constructor(e){super(e),!1===(null==e?void 0:e.readable)&&(this._readableState.readable=!1,this._readableState.ended=!0,this._readableState.endEmitted=!0),!1===(null==e?void 0:e.writable)&&(this._writableState.writable=!1,this._writableState.ending=!0,this._writableState.ended=!0,this._writableState.finished=!0)}}function T(e){const t=e.readable&&"function"!=typeof e.readable.read?y.wrap(e.readable):e.readable,r=e.writable;let n,i,a,l,u,c=!!s(t),h=!!o(r);function p(e){const t=l;l=null,t?t(e):e&&u.destroy(e)}return u=new k({readableObjectMode:!(null==t||!t.readableObjectMode),writableObjectMode:!(null==r||!r.writableObjectMode),readable:c,writable:h}),h&&(f(r,(e=>{h=!1,e&&g(t,e),p(e)})),u._write=function(e,t,i){r.write(e,t)?i():n=i},u._final=function(e){r.end(),i=e},r.on("drain",(function(){if(n){const e=n;n=null,e()}})),r.on("finish",(function(){if(i){const e=i;i=null,e()}}))),c&&(f(t,(e=>{c=!1,e&&g(t,e),p(e)})),t.on("readable",(function(){if(a){const e=a;a=null,e()}})),t.on("end",(function(){u.push(null)})),u._read=function(){for(;;){const e=t.read();if(null===e)return void(a=u._read);if(!u.push(e))return}}),u._destroy=function(e,s){e||null===l||(e=new d),a=null,n=null,i=null,null===l?s(e):(l=s,g(r,e),g(t,e))},u}t.exports=function e(t,r){if(h(t))return t;if(u(t))return T({readable:t});if(c(t))return T({writable:t});if(l(t))return T({writable:!1,readable:!1});if("function"==typeof t){const{value:e,write:i,final:s,destroy:o}=function(e){let{promise:t,resolve:r}=_();const i=new E,s=i.signal,o=e(async function*(){for(;;){const e=t;t=null;const{chunk:i,done:o,cb:a}=await e;if(n.nextTick(a),o)return;if(s.aborted)throw new d(void 0,{cause:s.reason});({promise:t,resolve:r}=_()),yield i}}(),{signal:s});return{value:o,write(e,t,n){const i=r;r=null,i({chunk:e,done:!1,cb:n})},final(e){const t=r;r=null,t({done:!0,cb:e})},destroy(e,t){i.abort(),t(e)}}}(t);if(a(e))return w(k,e,{objectMode:!0,write:i,final:s,destroy:o});const l=null==e?void 0:e.then;if("function"==typeof l){let t;const r=A(l,e,(e=>{if(null!=e)throw new b("nully","body",e)}),(e=>{g(t,e)}));return t=new k({objectMode:!0,readable:!1,write:i,final(e){s((async()=>{try{await r,n.nextTick(e,null)}catch(t){n.nextTick(e,t)}}))},destroy:o})}throw new b("Iterable, AsyncIterable or AsyncFunction",r,e)}if(S(t))return e(t.arrayBuffer());if(a(t))return w(k,t,{objectMode:!0,writable:!1});if("object"==typeof(null==t?void 0:t.writable)||"object"==typeof(null==t?void 0:t.readable)){return T({readable:null!=t&&t.readable?u(null==t?void 0:t.readable)?null==t?void 0:t.readable:e(t.readable):void 0,writable:null!=t&&t.writable?c(null==t?void 0:t.writable)?null==t?void 0:t.writable:e(t.writable):void 0})}const i=null==t?void 0:t.then;if("function"==typeof i){let e;return A(i,t,(t=>{null!=t&&e.push(t),e.push(null)}),(t=>{g(e,t)})),e=new k({objectMode:!0,writable:!1,read(){}})}throw new p(r,["Blob","ReadableStream","WritableStream","Stream","Iterable","AsyncIterable","Function","{ readable, writable } pair","Promise"],t)}},{"../../ours/errors":126,"../../ours/primordials":127,"../../ours/util":128,"./destroy":110,"./duplex":111,"./end-of-stream":113,"./from":114,"./readable":119,"./utils":122,"abort-controller":24,buffer:29,"process/":102}],113:[function(e,t,r){const n=e("process/"),{AbortError:i,codes:s}=e("../../ours/errors"),{ERR_INVALID_ARG_TYPE:o,ERR_STREAM_PREMATURE_CLOSE:a}=s,{kEmptyObject:l,once:u}=e("../../ours/util"),{validateAbortSignal:c,validateFunction:h,validateObject:f,validateBoolean:d}=e("../validators"),{Promise:p,PromisePrototypeThen:b}=e("../../ours/primordials"),{isClosed:g,isReadable:m,isReadableNodeStream:y,isReadableStream:_,isReadableFinished:w,isReadableErrored:v,isWritable:S,isWritableNodeStream:E,isWritableStream:A,isWritableFinished:k,isWritableErrored:T,isNodeStream:I,willEmitClose:R,kIsClosedPromise:O}=e("./utils");const C=()=>{};function P(e,t,r){var s,d;if(2===arguments.length?(r=t,t=l):null==t?t=l:f(t,"options"),h(r,"callback"),c(t.signal,"options.signal"),r=u(r),_(e)||A(e))return function(e,t,r){let s=!1,o=C;if(t.signal)if(o=()=>{s=!0,r.call(e,new i(void 0,{cause:t.signal.reason}))},t.signal.aborted)n.nextTick(o);else{const n=r;r=u(((...r)=>{t.signal.removeEventListener("abort",o),n.apply(e,r)})),t.signal.addEventListener("abort",o)}const a=(...t)=>{s||n.nextTick((()=>r.apply(e,t)))};return b(e[O].promise,a,a),C}(e,t,r);if(!I(e))throw new o("stream",["ReadableStream","WritableStream","Stream"],e);const p=null!==(s=t.readable)&&void 0!==s?s:y(e),P=null!==(d=t.writable)&&void 0!==d?d:E(e),x=e._writableState,M=e._readableState,B=()=>{e.writable||N()};let L=R(e)&&y(e)===p&&E(e)===P,j=k(e,!1);const N=()=>{j=!0,e.destroyed&&(L=!1),(!L||e.readable&&!p)&&(p&&!U||r.call(e))};let U=w(e,!1);const D=()=>{U=!0,e.destroyed&&(L=!1),(!L||e.writable&&!P)&&(P&&!j||r.call(e))},F=t=>{r.call(e,t)};let W=g(e);const q=()=>{W=!0;const t=T(e)||v(e);return t&&"boolean"!=typeof t?r.call(e,t):p&&!U&&y(e,!0)&&!w(e,!1)?r.call(e,new a):!P||j||k(e,!1)?void r.call(e):r.call(e,new a)},H=()=>{W=!0;const t=T(e)||v(e);if(t&&"boolean"!=typeof t)return r.call(e,t);r.call(e)},z=()=>{e.req.on("finish",N)};!function(e){return e.setHeader&&"function"==typeof e.abort}(e)?P&&!x&&(e.on("end",B),e.on("close",B)):(e.on("complete",N),L||e.on("abort",q),e.req?z():e.on("request",z)),L||"boolean"!=typeof e.aborted||e.on("aborted",q),e.on("end",D),e.on("finish",N),!1!==t.error&&e.on("error",F),e.on("close",q),W?n.nextTick(q):null!=x&&x.errorEmitted||null!=M&&M.errorEmitted?L||n.nextTick(H):(p||L&&!m(e)||!j&&!1!==S(e))&&(P||L&&!S(e)||!U&&!1!==m(e))?M&&e.req&&e.aborted&&n.nextTick(H):n.nextTick(H);const V=()=>{r=C,e.removeListener("aborted",q),e.removeListener("complete",N),e.removeListener("abort",q),e.removeListener("request",z),e.req&&e.req.removeListener("finish",N),e.removeListener("end",B),e.removeListener("close",B),e.removeListener("finish",N),e.removeListener("end",D),e.removeListener("error",F),e.removeListener("close",q)};if(t.signal&&!W){const s=()=>{const n=r;V(),n.call(e,new i(void 0,{cause:t.signal.reason}))};if(t.signal.aborted)n.nextTick(s);else{const n=r;r=u(((...r)=>{t.signal.removeEventListener("abort",s),n.apply(e,r)})),t.signal.addEventListener("abort",s)}}return V}t.exports=P,t.exports.finished=function(e,t){var r;let n=!1;return null===t&&(t=l),null!==(r=t)&&void 0!==r&&r.cleanup&&(d(t.cleanup,"cleanup"),n=t.cleanup),new p(((r,i)=>{const s=P(e,t,(e=>{n&&s(),e?i(e):r()}))}))}},{"../../ours/errors":126,"../../ours/primordials":127,"../../ours/util":128,"../validators":124,"./utils":122,"process/":102}],114:[function(e,t,r){"use strict";const n=e("process/"),{PromisePrototypeThen:i,SymbolAsyncIterator:s,SymbolIterator:o}=e("../../ours/primordials"),{Buffer:a}=e("buffer"),{ERR_INVALID_ARG_TYPE:l,ERR_STREAM_NULL_VALUES:u}=e("../../ours/errors").codes;t.exports=function(e,t,r){let c,h;if("string"==typeof t||t instanceof a)return new e({objectMode:!0,...r,read(){this.push(t),this.push(null)}});if(t&&t[s])h=!0,c=t[s]();else{if(!t||!t[o])throw new l("iterable",["Iterable"],t);h=!1,c=t[o]()}const f=new e({objectMode:!0,highWaterMark:1,...r});let d=!1;return f._read=function(){d||(d=!0,async function(){for(;;){try{const{value:e,done:t}=h?await c.next():c.next();if(t)f.push(null);else{const t=e&&"function"==typeof e.then?await e:e;if(null===t)throw d=!1,new u;if(f.push(t))continue;d=!1}}catch(e){f.destroy(e)}break}}())},f._destroy=function(e,t){i(async function(e){const t=null!=e,r="function"==typeof c.throw;if(t&&r){const{value:t,done:r}=await c.throw(e);if(await t,r)return}if("function"==typeof c.return){const{value:e}=await c.return();await e}}(e),(()=>n.nextTick(t,e)),(r=>n.nextTick(t,r||e)))},f}},{"../../ours/errors":126,"../../ours/primordials":127,buffer:29,"process/":102}],115:[function(e,t,r){"use strict";const{ArrayIsArray:n,ObjectSetPrototypeOf:i}=e("../../ours/primordials"),{EventEmitter:s}=e("events");function o(e){s.call(this,e)}function a(e,t,r){if("function"==typeof e.prependListener)return e.prependListener(t,r);e._events&&e._events[t]?n(e._events[t])?e._events[t].unshift(r):e._events[t]=[r,e._events[t]]:e.on(t,r)}i(o.prototype,s.prototype),i(o,s),o.prototype.pipe=function(e,t){const r=this;function n(t){e.writable&&!1===e.write(t)&&r.pause&&r.pause()}function i(){r.readable&&r.resume&&r.resume()}r.on("data",n),e.on("drain",i),e._isStdio||t&&!1===t.end||(r.on("end",l),r.on("close",u));let o=!1;function l(){o||(o=!0,e.end())}function u(){o||(o=!0,"function"==typeof e.destroy&&e.destroy())}function c(e){h(),0===s.listenerCount(this,"error")&&this.emit("error",e)}function h(){r.removeListener("data",n),e.removeListener("drain",i),r.removeListener("end",l),r.removeListener("close",u),r.removeListener("error",c),e.removeListener("error",c),r.removeListener("end",h),r.removeListener("close",h),e.removeListener("close",h)}return a(r,"error",c),a(e,"error",c),r.on("end",h),r.on("close",h),e.on("close",h),e.emit("pipe",r),e},t.exports={Stream:o,prependListener:a}},{"../../ours/primordials":127,events:49}],116:[function(e,t,r){"use strict";const n=globalThis.AbortController||e("abort-controller").AbortController,{codes:{ERR_INVALID_ARG_VALUE:i,ERR_INVALID_ARG_TYPE:s,ERR_MISSING_ARGS:o,ERR_OUT_OF_RANGE:a},AbortError:l}=e("../../ours/errors"),{validateAbortSignal:u,validateInteger:c,validateObject:h}=e("../validators"),f=e("../../ours/primordials").Symbol("kWeak"),{finished:d}=e("./end-of-stream"),p=e("./compose"),{addAbortSignalNoValidate:b}=e("./add-abort-signal"),{isWritable:g,isNodeStream:m}=e("./utils"),{ArrayPrototypePush:y,MathFloor:_,Number:w,NumberIsNaN:v,Promise:S,PromiseReject:E,PromisePrototypeThen:A,Symbol:k}=e("../../ours/primordials"),T=k("kEmpty"),I=k("kEof");function R(e,t){if("function"!=typeof e)throw new s("fn",["Function","AsyncFunction"],e);null!=t&&h(t,"options"),null!=(null==t?void 0:t.signal)&&u(t.signal,"options.signal");let r=1;return null!=(null==t?void 0:t.concurrency)&&(r=_(t.concurrency)),c(r,"concurrency",1),async function*(){var i,s;const o=new n,a=this,u=[],c=o.signal,h={signal:c},f=()=>o.abort();let d,p;null!=t&&null!==(i=t.signal)&&void 0!==i&&i.aborted&&f(),null==t||null===(s=t.signal)||void 0===s||s.addEventListener("abort",f);let b=!1;function g(){b=!0}!async function(){try{for await(let t of a){var n;if(b)return;if(c.aborted)throw new l;try{t=e(t,h)}catch(e){t=E(e)}t!==T&&("function"==typeof(null===(n=t)||void 0===n?void 0:n.catch)&&t.catch(g),u.push(t),d&&(d(),d=null),!b&&u.length&&u.length>=r&&await new S((e=>{p=e})))}u.push(I)}catch(e){const t=E(e);A(t,void 0,g),u.push(t)}finally{var i;b=!0,d&&(d(),d=null),null==t||null===(i=t.signal)||void 0===i||i.removeEventListener("abort",f)}}();try{for(;;){for(;u.length>0;){const e=await u[0];if(e===I)return;if(c.aborted)throw new l;e!==T&&(yield e),u.shift(),p&&(p(),p=null)}await new S((e=>{d=e}))}}finally{o.abort(),b=!0,p&&(p(),p=null)}}.call(this)}async function O(e,t=void 0){for await(const r of C.call(this,e,t))return!0;return!1}function C(e,t){if("function"!=typeof e)throw new s("fn",["Function","AsyncFunction"],e);return R.call(this,(async function(t,r){return await e(t,r)?t:T}),t)}class P extends o{constructor(){super("reduce"),this.message="Reduce of an empty stream requires an initial value"}}function x(e){if(e=w(e),v(e))return 0;if(e<0)throw new a("number",">= 0",e);return e}t.exports.streamReturningOperators={asIndexedPairs:function(e=void 0){return null!=e&&h(e,"options"),null!=(null==e?void 0:e.signal)&&u(e.signal,"options.signal"),async function*(){let t=0;for await(const n of this){var r;if(null!=e&&null!==(r=e.signal)&&void 0!==r&&r.aborted)throw new l({cause:e.signal.reason});yield[t++,n]}}.call(this)},drop:function(e,t=void 0){return null!=t&&h(t,"options"),null!=(null==t?void 0:t.signal)&&u(t.signal,"options.signal"),e=x(e),async function*(){var r;if(null!=t&&null!==(r=t.signal)&&void 0!==r&&r.aborted)throw new l;for await(const r of this){var n;if(null!=t&&null!==(n=t.signal)&&void 0!==n&&n.aborted)throw new l;e--<=0&&(yield r)}}.call(this)},filter:C,flatMap:function(e,t){const r=R.call(this,e,t);return async function*(){for await(const e of r)yield*e}.call(this)},map:R,take:function(e,t=void 0){return null!=t&&h(t,"options"),null!=(null==t?void 0:t.signal)&&u(t.signal,"options.signal"),e=x(e),async function*(){var r;if(null!=t&&null!==(r=t.signal)&&void 0!==r&&r.aborted)throw new l;for await(const r of this){var n;if(null!=t&&null!==(n=t.signal)&&void 0!==n&&n.aborted)throw new l;if(!(e-- >0))return;yield r}}.call(this)},compose:function(e,t){if(null!=t&&h(t,"options"),null!=(null==t?void 0:t.signal)&&u(t.signal,"options.signal"),m(e)&&!g(e))throw new i("stream",e,"must be writable");const r=p(this,e);return null!=t&&t.signal&&b(t.signal,r),r}},t.exports.promiseReturningOperators={every:async function(e,t=void 0){if("function"!=typeof e)throw new s("fn",["Function","AsyncFunction"],e);return!await O.call(this,(async(...t)=>!await e(...t)),t)},forEach:async function(e,t){if("function"!=typeof e)throw new s("fn",["Function","AsyncFunction"],e);for await(const r of R.call(this,(async function(t,r){return await e(t,r),T}),t));},reduce:async function(e,t,r){var i;if("function"!=typeof e)throw new s("reducer",["Function","AsyncFunction"],e);null!=r&&h(r,"options"),null!=(null==r?void 0:r.signal)&&u(r.signal,"options.signal");let o=arguments.length>1;if(null!=r&&null!==(i=r.signal)&&void 0!==i&&i.aborted){const e=new l(void 0,{cause:r.signal.reason});throw this.once("error",(()=>{})),await d(this.destroy(e)),e}const a=new n,c=a.signal;if(null!=r&&r.signal){const e={once:!0,[f]:this};r.signal.addEventListener("abort",(()=>a.abort()),e)}let p=!1;try{for await(const n of this){var b;if(p=!0,null!=r&&null!==(b=r.signal)&&void 0!==b&&b.aborted)throw new l;o?t=await e(t,n,{signal:c}):(t=n,o=!0)}if(!p&&!o)throw new P}finally{a.abort()}return t},toArray:async function(e){null!=e&&h(e,"options"),null!=(null==e?void 0:e.signal)&&u(e.signal,"options.signal");const t=[];for await(const n of this){var r;if(null!=e&&null!==(r=e.signal)&&void 0!==r&&r.aborted)throw new l(void 0,{cause:e.signal.reason});y(t,n)}return t},some:O,find:async function(e,t){for await(const r of C.call(this,e,t))return r}}},{"../../ours/errors":126,"../../ours/primordials":127,"../validators":124,"./add-abort-signal":107,"./compose":109,"./end-of-stream":113,"./utils":122,"abort-controller":24}],117:[function(e,t,r){"use strict";const{ObjectSetPrototypeOf:n}=e("../../ours/primordials");t.exports=s;const i=e("./transform");function s(e){if(!(this instanceof s))return new s(e);i.call(this,e)}n(s.prototype,i.prototype),n(s,i),s.prototype._transform=function(e,t,r){r(null,e)}},{"../../ours/primordials":127,"./transform":121}],118:[function(e,t,r){const n=e("process/"),{ArrayIsArray:i,Promise:s,SymbolAsyncIterator:o}=e("../../ours/primordials"),a=e("./end-of-stream"),{once:l}=e("../../ours/util"),u=e("./destroy"),c=e("./duplex"),{aggregateTwoErrors:h,codes:{ERR_INVALID_ARG_TYPE:f,ERR_INVALID_RETURN_VALUE:d,ERR_MISSING_ARGS:p,ERR_STREAM_DESTROYED:b,ERR_STREAM_PREMATURE_CLOSE:g},AbortError:m}=e("../../ours/errors"),{validateFunction:y,validateAbortSignal:_}=e("../validators"),{isIterable:w,isReadable:v,isReadableNodeStream:S,isNodeStream:E,isTransformStream:A,isWebStream:k,isReadableStream:T,isReadableEnded:I}=e("./utils"),R=globalThis.AbortController||e("abort-controller").AbortController;let O,C;function P(e,t,r){let n=!1;e.on("close",(()=>{n=!0}));return{destroy:t=>{n||(n=!0,u.destroyer(e,t||new b("pipe")))},cleanup:a(e,{readable:t,writable:r},(e=>{n=!e}))}}function x(t){if(w(t))return t;if(S(t))return async function*(t){C||(C=e("./readable"));yield*C.prototype[o].call(t)}(t);throw new f("val",["Readable","Iterable","AsyncIterable"],t)}async function M(e,t,r,{end:n}){let i,o=null;const l=e=>{if(e&&(i=e),o){const e=o;o=null,e()}},u=()=>new s(((e,t)=>{i?t(i):o=()=>{i?t(i):e()}}));t.on("drain",l);const c=a(t,{readable:!1},l);try{t.writableNeedDrain&&await u();for await(const r of e)t.write(r)||await u();n&&t.end(),await u(),r()}catch(e){r(i!==e?h(i,e):e)}finally{c(),t.off("drain",l)}}async function B(e,t,r,{end:n}){A(t)&&(t=t.writable);const i=t.getWriter();try{for await(const t of e)await i.ready,i.write(t).catch((()=>{}));await i.ready,n&&await i.close(),r()}catch(e){try{await i.abort(e),r(e)}catch(e){r(e)}}}function L(t,r,s){if(1===t.length&&i(t[0])&&(t=t[0]),t.length<2)throw new p("streams");const o=new R,a=o.signal,l=null==s?void 0:s.signal,u=[];function h(){N(new m)}let b,g;_(l,"options.signal"),null==l||l.addEventListener("abort",h);const y=[];let I,C=0;function L(e){N(e,0==--C)}function N(e,t){if(!e||b&&"ERR_STREAM_PREMATURE_CLOSE"!==b.code||(b=e),b||t){for(;y.length;)y.shift()(b);null==l||l.removeEventListener("abort",h),o.abort(),t&&(b||u.forEach((e=>e())),n.nextTick(r,b,g))}}for(let W=0;W<t.length;W++){const q=t[W],H=W<t.length-1,z=W>0,V=H||!1!==(null==s?void 0:s.end),$=W===t.length-1;if(E(q)){if(V){const{destroy:K,cleanup:G}=P(q,H,z);y.push(K),v(q)&&$&&u.push(G)}function U(e){e&&"AbortError"!==e.name&&"ERR_STREAM_PREMATURE_CLOSE"!==e.code&&L(e)}q.on("error",U),v(q)&&$&&u.push((()=>{q.removeListener("error",U)}))}if(0===W)if("function"==typeof q){if(I=q({signal:a}),!w(I))throw new d("Iterable, AsyncIterable or Stream","source",I)}else I=w(q)||S(q)||A(q)?q:c.from(q);else if("function"==typeof q){var D;if(A(I))I=x(null===(D=I)||void 0===D?void 0:D.readable);else I=x(I);if(I=q(I,{signal:a}),H){if(!w(I,!0))throw new d("AsyncIterable",`transform[${W-1}]`,I)}else{var F;O||(O=e("./passthrough"));const Q=new O({objectMode:!0}),Y=null===(F=I)||void 0===F?void 0:F.then;if("function"==typeof Y)C++,Y.call(I,(e=>{g=e,null!=e&&Q.write(e),V&&Q.end(),n.nextTick(L)}),(e=>{Q.destroy(e),n.nextTick(L,e)}));else if(w(I,!0))C++,M(I,Q,L,{end:V});else{if(!T(I)&&!A(I))throw new d("AsyncIterable or Promise","destination",I);{const X=I.readable||I;C++,M(X,Q,L,{end:V})}}I=Q;const{destroy:J,cleanup:Z}=P(I,!1,!0);y.push(J),$&&u.push(Z)}}else if(E(q)){if(S(I)){C+=2;const ee=j(I,q,L,{end:V});v(q)&&$&&u.push(ee)}else if(A(I)||T(I)){const te=I.readable||I;C++,M(te,q,L,{end:V})}else{if(!w(I))throw new f("val",["Readable","Iterable","AsyncIterable","ReadableStream","TransformStream"],I);C++,M(I,q,L,{end:V})}I=q}else if(k(q)){if(S(I))C++,B(x(I),q,L,{end:V});else if(T(I)||w(I))C++,B(I,q,L,{end:V});else{if(!A(I))throw new f("val",["Readable","Iterable","AsyncIterable","ReadableStream","TransformStream"],I);C++,B(I.readable,q,L,{end:V})}I=q}else I=c.from(q)}return(null!=a&&a.aborted||null!=l&&l.aborted)&&n.nextTick(h),I}function j(e,t,r,{end:i}){let s=!1;if(t.on("close",(()=>{s||r(new g)})),e.pipe(t,{end:!1}),i){function o(){s=!0,t.end()}I(e)?n.nextTick(o):e.once("end",o)}else r();return a(e,{readable:!0,writable:!1},(t=>{const n=e._readableState;t&&"ERR_STREAM_PREMATURE_CLOSE"===t.code&&n&&n.ended&&!n.errored&&!n.errorEmitted?e.once("end",r).once("error",r):r(t)})),a(t,{readable:!1,writable:!0},r)}t.exports={pipelineImpl:L,pipeline:function(...e){return L(e,l(function(e){return y(e[e.length-1],"streams[stream.length - 1]"),e.pop()}(e)))}}},{"../../ours/errors":126,"../../ours/primordials":127,"../../ours/util":128,"../validators":124,"./destroy":110,"./duplex":111,"./end-of-stream":113,"./passthrough":117,"./readable":119,"./utils":122,"abort-controller":24,"process/":102}],119:[function(e,t,r){const n=e("process/"),{ArrayPrototypeIndexOf:i,NumberIsInteger:s,NumberIsNaN:o,NumberParseInt:a,ObjectDefineProperties:l,ObjectKeys:u,ObjectSetPrototypeOf:c,Promise:h,SafeSet:f,SymbolAsyncIterator:d,Symbol:p}=e("../../ours/primordials");t.exports=D,D.ReadableState=U;const{EventEmitter:b}=e("events"),{Stream:g,prependListener:m}=e("./legacy"),{Buffer:y}=e("buffer"),{addAbortSignal:_}=e("./add-abort-signal"),w=e("./end-of-stream");let v=e("../../ours/util").debuglog("stream",(e=>{v=e}));const S=e("./buffer_list"),E=e("./destroy"),{getHighWaterMark:A,getDefaultHighWaterMark:k}=e("./state"),{aggregateTwoErrors:T,codes:{ERR_INVALID_ARG_TYPE:I,ERR_METHOD_NOT_IMPLEMENTED:R,ERR_OUT_OF_RANGE:O,ERR_STREAM_PUSH_AFTER_EOF:C,ERR_STREAM_UNSHIFT_AFTER_END_EVENT:P}}=e("../../ours/errors"),{validateObject:x}=e("../validators"),M=p("kPaused"),{StringDecoder:B}=e("string_decoder"),L=e("./from");c(D.prototype,g.prototype),c(D,g);const j=()=>{},{errorOrDestroy:N}=E;function U(t,r,n){"boolean"!=typeof n&&(n=r instanceof e("./duplex")),this.objectMode=!(!t||!t.objectMode),n&&(this.objectMode=this.objectMode||!(!t||!t.readableObjectMode)),this.highWaterMark=t?A(this,t,"readableHighWaterMark",n):k(!1),this.buffer=new S,this.length=0,this.pipes=[],this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.constructed=!0,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this[M]=null,this.errorEmitted=!1,this.emitClose=!t||!1!==t.emitClose,this.autoDestroy=!t||!1!==t.autoDestroy,this.destroyed=!1,this.errored=null,this.closed=!1,this.closeEmitted=!1,this.defaultEncoding=t&&t.defaultEncoding||"utf8",this.awaitDrainWriters=null,this.multiAwaitDrain=!1,this.readingMore=!1,this.dataEmitted=!1,this.decoder=null,this.encoding=null,t&&t.encoding&&(this.decoder=new B(t.encoding),this.encoding=t.encoding)}function D(t){if(!(this instanceof D))return new D(t);const r=this instanceof e("./duplex");this._readableState=new U(t,this,r),t&&("function"==typeof t.read&&(this._read=t.read),"function"==typeof t.destroy&&(this._destroy=t.destroy),"function"==typeof t.construct&&(this._construct=t.construct),t.signal&&!r&&_(t.signal,this)),g.call(this,t),E.construct(this,(()=>{this._readableState.needReadable&&V(this,this._readableState)}))}function F(e,t,r,n){v("readableAddChunk",t);const i=e._readableState;let s;if(i.objectMode||("string"==typeof t?(r=r||i.defaultEncoding,i.encoding!==r&&(n&&i.encoding?t=y.from(t,r).toString(i.encoding):(t=y.from(t,r),r=""))):t instanceof y?r="":g._isUint8Array(t)?(t=g._uint8ArrayToBuffer(t),r=""):null!=t&&(s=new I("chunk",["string","Buffer","Uint8Array"],t))),s)N(e,s);else if(null===t)i.reading=!1,function(e,t){if(v("onEofChunk"),t.ended)return;if(t.decoder){const e=t.decoder.end();e&&e.length&&(t.buffer.push(e),t.length+=t.objectMode?1:e.length)}t.ended=!0,t.sync?H(e):(t.needReadable=!1,t.emittedReadable=!0,z(e))}(e,i);else if(i.objectMode||t&&t.length>0)if(n)if(i.endEmitted)N(e,new P);else{if(i.destroyed||i.errored)return!1;W(e,i,t,!0)}else if(i.ended)N(e,new C);else{if(i.destroyed||i.errored)return!1;i.reading=!1,i.decoder&&!r?(t=i.decoder.write(t),i.objectMode||0!==t.length?W(e,i,t,!1):V(e,i)):W(e,i,t,!1)}else n||(i.reading=!1,V(e,i));return!i.ended&&(i.length<i.highWaterMark||0===i.length)}function W(e,t,r,n){t.flowing&&0===t.length&&!t.sync&&e.listenerCount("data")>0?(t.multiAwaitDrain?t.awaitDrainWriters.clear():t.awaitDrainWriters=null,t.dataEmitted=!0,e.emit("data",r)):(t.length+=t.objectMode?1:r.length,n?t.buffer.unshift(r):t.buffer.push(r),t.needReadable&&H(e)),V(e,t)}D.prototype.destroy=E.destroy,D.prototype._undestroy=E.undestroy,D.prototype._destroy=function(e,t){t(e)},D.prototype[b.captureRejectionSymbol]=function(e){this.destroy(e)},D.prototype.push=function(e,t){return F(this,e,t,!1)},D.prototype.unshift=function(e,t){return F(this,e,t,!0)},D.prototype.isPaused=function(){const e=this._readableState;return!0===e[M]||!1===e.flowing},D.prototype.setEncoding=function(e){const t=new B(e);this._readableState.decoder=t,this._readableState.encoding=this._readableState.decoder.encoding;const r=this._readableState.buffer;let n="";for(const e of r)n+=t.write(e);return r.clear(),""!==n&&r.push(n),this._readableState.length=n.length,this};function q(e,t){return e<=0||0===t.length&&t.ended?0:t.objectMode?1:o(e)?t.flowing&&t.length?t.buffer.first().length:t.length:e<=t.length?e:t.ended?t.length:0}function H(e){const t=e._readableState;v("emitReadable",t.needReadable,t.emittedReadable),t.needReadable=!1,t.emittedReadable||(v("emitReadable",t.flowing),t.emittedReadable=!0,n.nextTick(z,e))}function z(e){const t=e._readableState;v("emitReadable_",t.destroyed,t.length,t.ended),t.destroyed||t.errored||!t.length&&!t.ended||(e.emit("readable"),t.emittedReadable=!1),t.needReadable=!t.flowing&&!t.ended&&t.length<=t.highWaterMark,Y(e)}function V(e,t){!t.readingMore&&t.constructed&&(t.readingMore=!0,n.nextTick($,e,t))}function $(e,t){for(;!t.reading&&!t.ended&&(t.length<t.highWaterMark||t.flowing&&0===t.length);){const r=t.length;if(v("maybeReadMore read 0"),e.read(0),r===t.length)break}t.readingMore=!1}function K(e){const t=e._readableState;t.readableListening=e.listenerCount("readable")>0,t.resumeScheduled&&!1===t[M]?t.flowing=!0:e.listenerCount("data")>0?e.resume():t.readableListening||(t.flowing=null)}function G(e){v("readable nexttick read 0"),e.read(0)}function Q(e,t){v("resume",t.reading),t.reading||e.read(0),t.resumeScheduled=!1,e.emit("resume"),Y(e),t.flowing&&!t.reading&&e.read(0)}function Y(e){const t=e._readableState;for(v("flow",t.flowing);t.flowing&&null!==e.read(););}function J(e,t){"function"!=typeof e.read&&(e=D.wrap(e,{objectMode:!0}));const r=async function*(e,t){let r,n=j;function i(t){this===e?(n(),n=j):n=t}e.on("readable",i);const s=w(e,{writable:!1},(e=>{r=e?T(r,e):null,n(),n=j}));try{for(;;){const t=e.destroyed?null:e.read();if(null!==t)yield t;else{if(r)throw r;if(null===r)return;await new h(i)}}}catch(e){throw r=T(r,e),r}finally{!r&&!1===(null==t?void 0:t.destroyOnReturn)||void 0!==r&&!e._readableState.autoDestroy?(e.off("readable",i),s()):E.destroyer(e,null)}}(e,t);return r.stream=e,r}function Z(e,t){if(0===t.length)return null;let r;return t.objectMode?r=t.buffer.shift():!e||e>=t.length?(r=t.decoder?t.buffer.join(""):1===t.buffer.length?t.buffer.first():t.buffer.concat(t.length),t.buffer.clear()):r=t.buffer.consume(e,t.decoder),r}function X(e){const t=e._readableState;v("endReadable",t.endEmitted),t.endEmitted||(t.ended=!0,n.nextTick(ee,t,e))}function ee(e,t){if(v("endReadableNT",e.endEmitted,e.length),!e.errored&&!e.closeEmitted&&!e.endEmitted&&0===e.length)if(e.endEmitted=!0,t.emit("end"),t.writable&&!1===t.allowHalfOpen)n.nextTick(te,t);else if(e.autoDestroy){const e=t._writableState;(!e||e.autoDestroy&&(e.finished||!1===e.writable))&&t.destroy()}}function te(e){e.writable&&!e.writableEnded&&!e.destroyed&&e.end()}let re;function ne(){return void 0===re&&(re={}),re}D.prototype.read=function(e){v("read",e),void 0===e?e=NaN:s(e)||(e=a(e,10));const t=this._readableState,r=e;if(e>t.highWaterMark&&(t.highWaterMark=function(e){if(e>1073741824)throw new O("size","<= 1GiB",e);return e--,e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,e|=e>>>16,++e}(e)),0!==e&&(t.emittedReadable=!1),0===e&&t.needReadable&&((0!==t.highWaterMark?t.length>=t.highWaterMark:t.length>0)||t.ended))return v("read: emitReadable",t.length,t.ended),0===t.length&&t.ended?X(this):H(this),null;if(0===(e=q(e,t))&&t.ended)return 0===t.length&&X(this),null;let n,i=t.needReadable;if(v("need readable",i),(0===t.length||t.length-e<t.highWaterMark)&&(i=!0,v("length less than watermark",i)),t.ended||t.reading||t.destroyed||t.errored||!t.constructed)i=!1,v("reading, ended or constructing",i);else if(i){v("do read"),t.reading=!0,t.sync=!0,0===t.length&&(t.needReadable=!0);try{this._read(t.highWaterMark)}catch(e){N(this,e)}t.sync=!1,t.reading||(e=q(r,t))}return n=e>0?Z(e,t):null,null===n?(t.needReadable=t.length<=t.highWaterMark,e=0):(t.length-=e,t.multiAwaitDrain?t.awaitDrainWriters.clear():t.awaitDrainWriters=null),0===t.length&&(t.ended||(t.needReadable=!0),r!==e&&t.ended&&X(this)),null===n||t.errorEmitted||t.closeEmitted||(t.dataEmitted=!0,this.emit("data",n)),n},D.prototype._read=function(e){throw new R("_read()")},D.prototype.pipe=function(e,t){const r=this,i=this._readableState;1===i.pipes.length&&(i.multiAwaitDrain||(i.multiAwaitDrain=!0,i.awaitDrainWriters=new f(i.awaitDrainWriters?[i.awaitDrainWriters]:[]))),i.pipes.push(e),v("pipe count=%d opts=%j",i.pipes.length,t);const s=(!t||!1!==t.end)&&e!==n.stdout&&e!==n.stderr?a:g;function o(t,n){v("onunpipe"),t===r&&n&&!1===n.hasUnpiped&&(n.hasUnpiped=!0,function(){v("cleanup"),e.removeListener("close",p),e.removeListener("finish",b),l&&e.removeListener("drain",l);e.removeListener("error",d),e.removeListener("unpipe",o),r.removeListener("end",a),r.removeListener("end",g),r.removeListener("data",h),u=!0,l&&i.awaitDrainWriters&&(!e._writableState||e._writableState.needDrain)&&l()}())}function a(){v("onend"),e.end()}let l;i.endEmitted?n.nextTick(s):r.once("end",s),e.on("unpipe",o);let u=!1;function c(){u||(1===i.pipes.length&&i.pipes[0]===e?(v("false write response, pause",0),i.awaitDrainWriters=e,i.multiAwaitDrain=!1):i.pipes.length>1&&i.pipes.includes(e)&&(v("false write response, pause",i.awaitDrainWriters.size),i.awaitDrainWriters.add(e)),r.pause()),l||(l=function(e,t){return function(){const r=e._readableState;r.awaitDrainWriters===t?(v("pipeOnDrain",1),r.awaitDrainWriters=null):r.multiAwaitDrain&&(v("pipeOnDrain",r.awaitDrainWriters.size),r.awaitDrainWriters.delete(t)),r.awaitDrainWriters&&0!==r.awaitDrainWriters.size||!e.listenerCount("data")||e.resume()}}(r,e),e.on("drain",l))}function h(t){v("ondata");const r=e.write(t);v("dest.write",r),!1===r&&c()}function d(t){if(v("onerror",t),g(),e.removeListener("error",d),0===e.listenerCount("error")){const r=e._writableState||e._readableState;r&&!r.errorEmitted?N(e,t):e.emit("error",t)}}function p(){e.removeListener("finish",b),g()}function b(){v("onfinish"),e.removeListener("close",p),g()}function g(){v("unpipe"),r.unpipe(e)}return r.on("data",h),m(e,"error",d),e.once("close",p),e.once("finish",b),e.emit("pipe",r),!0===e.writableNeedDrain?i.flowing&&c():i.flowing||(v("pipe resume"),r.resume()),e},D.prototype.unpipe=function(e){const t=this._readableState;if(0===t.pipes.length)return this;if(!e){const e=t.pipes;t.pipes=[],this.pause();for(let t=0;t<e.length;t++)e[t].emit("unpipe",this,{hasUnpiped:!1});return this}const r=i(t.pipes,e);return-1===r||(t.pipes.splice(r,1),0===t.pipes.length&&this.pause(),e.emit("unpipe",this,{hasUnpiped:!1})),this},D.prototype.on=function(e,t){const r=g.prototype.on.call(this,e,t),i=this._readableState;return"data"===e?(i.readableListening=this.listenerCount("readable")>0,!1!==i.flowing&&this.resume()):"readable"===e&&(i.endEmitted||i.readableListening||(i.readableListening=i.needReadable=!0,i.flowing=!1,i.emittedReadable=!1,v("on readable",i.length,i.reading),i.length?H(this):i.reading||n.nextTick(G,this))),r},D.prototype.addListener=D.prototype.on,D.prototype.removeListener=function(e,t){const r=g.prototype.removeListener.call(this,e,t);return"readable"===e&&n.nextTick(K,this),r},D.prototype.off=D.prototype.removeListener,D.prototype.removeAllListeners=function(e){const t=g.prototype.removeAllListeners.apply(this,arguments);return"readable"!==e&&void 0!==e||n.nextTick(K,this),t},D.prototype.resume=function(){const e=this._readableState;return e.flowing||(v("resume"),e.flowing=!e.readableListening,function(e,t){t.resumeScheduled||(t.resumeScheduled=!0,n.nextTick(Q,e,t))}(this,e)),e[M]=!1,this},D.prototype.pause=function(){return v("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(v("pause"),this._readableState.flowing=!1,this.emit("pause")),this._readableState[M]=!0,this},D.prototype.wrap=function(e){let t=!1;e.on("data",(r=>{!this.push(r)&&e.pause&&(t=!0,e.pause())})),e.on("end",(()=>{this.push(null)})),e.on("error",(e=>{N(this,e)})),e.on("close",(()=>{this.destroy()})),e.on("destroy",(()=>{this.destroy()})),this._read=()=>{t&&e.resume&&(t=!1,e.resume())};const r=u(e);for(let t=1;t<r.length;t++){const n=r[t];void 0===this[n]&&"function"==typeof e[n]&&(this[n]=e[n].bind(e))}return this},D.prototype[d]=function(){return J(this)},D.prototype.iterator=function(e){return void 0!==e&&x(e,"options"),J(this,e)},l(D.prototype,{readable:{__proto__:null,get(){const e=this._readableState;return!(!e||!1===e.readable||e.destroyed||e.errorEmitted||e.endEmitted)},set(e){this._readableState&&(this._readableState.readable=!!e)}},readableDidRead:{__proto__:null,enumerable:!1,get:function(){return this._readableState.dataEmitted}},readableAborted:{__proto__:null,enumerable:!1,get:function(){return!(!1===this._readableState.readable||!this._readableState.destroyed&&!this._readableState.errored||this._readableState.endEmitted)}},readableHighWaterMark:{__proto__:null,enumerable:!1,get:function(){return this._readableState.highWaterMark}},readableBuffer:{__proto__:null,enumerable:!1,get:function(){return this._readableState&&this._readableState.buffer}},readableFlowing:{__proto__:null,enumerable:!1,get:function(){return this._readableState.flowing},set:function(e){this._readableState&&(this._readableState.flowing=e)}},readableLength:{__proto__:null,enumerable:!1,get(){return this._readableState.length}},readableObjectMode:{__proto__:null,enumerable:!1,get(){return!!this._readableState&&this._readableState.objectMode}},readableEncoding:{__proto__:null,enumerable:!1,get(){return this._readableState?this._readableState.encoding:null}},errored:{__proto__:null,enumerable:!1,get(){return this._readableState?this._readableState.errored:null}},closed:{__proto__:null,get(){return!!this._readableState&&this._readableState.closed}},destroyed:{__proto__:null,enumerable:!1,get(){return!!this._readableState&&this._readableState.destroyed},set(e){this._readableState&&(this._readableState.destroyed=e)}},readableEnded:{__proto__:null,enumerable:!1,get(){return!!this._readableState&&this._readableState.endEmitted}}}),l(U.prototype,{pipesCount:{__proto__:null,get(){return this.pipes.length}},paused:{__proto__:null,get(){return!1!==this[M]},set(e){this[M]=!!e}}}),D._fromList=Z,D.from=function(e,t){return L(D,e,t)},D.fromWeb=function(e,t){return ne().newStreamReadableFromReadableStream(e,t)},D.toWeb=function(e,t){return ne().newReadableStreamFromStreamReadable(e,t)},D.wrap=function(e,t){var r,n;return new D({objectMode:null===(r=null!==(n=e.readableObjectMode)&&void 0!==n?n:e.objectMode)||void 0===r||r,...t,destroy(t,r){E.destroyer(e,t),r(t)}}).wrap(e)}},{"../../ours/errors":126,"../../ours/primordials":127,"../../ours/util":128,"../validators":124,"./add-abort-signal":107,"./buffer_list":108,"./destroy":110,"./duplex":111,"./end-of-stream":113,"./from":114,"./legacy":115,"./state":120,buffer:29,events:49,"process/":102,string_decoder:28}],120:[function(e,t,r){"use strict";const{MathFloor:n,NumberIsInteger:i}=e("../../ours/primordials"),{ERR_INVALID_ARG_VALUE:s}=e("../../ours/errors").codes;function o(e){return e?16:16384}t.exports={getHighWaterMark:function(e,t,r,a){const l=function(e,t,r){return null!=e.highWaterMark?e.highWaterMark:t?e[r]:null}(t,a,r);if(null!=l){if(!i(l)||l<0){throw new s(a?`options.${r}`:"options.highWaterMark",l)}return n(l)}return o(e.objectMode)},getDefaultHighWaterMark:o}},{"../../ours/errors":126,"../../ours/primordials":127}],121:[function(e,t,r){"use strict";const{ObjectSetPrototypeOf:n,Symbol:i}=e("../../ours/primordials");t.exports=u;const{ERR_METHOD_NOT_IMPLEMENTED:s}=e("../../ours/errors").codes,o=e("./duplex"),{getHighWaterMark:a}=e("./state");n(u.prototype,o.prototype),n(u,o);const l=i("kCallback");function u(e){if(!(this instanceof u))return new u(e);const t=e?a(this,e,"readableHighWaterMark",!0):null;0===t&&(e={...e,highWaterMark:null,readableHighWaterMark:t,writableHighWaterMark:e.writableHighWaterMark||0}),o.call(this,e),this._readableState.sync=!1,this[l]=null,e&&("function"==typeof e.transform&&(this._transform=e.transform),"function"==typeof e.flush&&(this._flush=e.flush)),this.on("prefinish",h)}function c(e){"function"!=typeof this._flush||this.destroyed?(this.push(null),e&&e()):this._flush(((t,r)=>{t?e?e(t):this.destroy(t):(null!=r&&this.push(r),this.push(null),e&&e())}))}function h(){this._final!==c&&c.call(this)}u.prototype._final=c,u.prototype._transform=function(e,t,r){throw new s("_transform()")},u.prototype._write=function(e,t,r){const n=this._readableState,i=this._writableState,s=n.length;this._transform(e,t,((e,t)=>{e?r(e):(null!=t&&this.push(t),i.ended||s===n.length||n.length<n.highWaterMark?r():this[l]=r)}))},u.prototype._read=function(){if(this[l]){const e=this[l];this[l]=null,e()}}},{"../../ours/errors":126,"../../ours/primordials":127,"./duplex":111,"./state":120}],122:[function(e,t,r){"use strict";const{Symbol:n,SymbolAsyncIterator:i,SymbolIterator:s,SymbolFor:o}=e("../../ours/primordials"),a=n("kDestroyed"),l=n("kIsErrored"),u=n("kIsReadable"),c=n("kIsDisturbed"),h=o("nodejs.webstream.isClosedPromise"),f=o("nodejs.webstream.controllerErrorFunction");function d(e,t=!1){var r;return!(!e||"function"!=typeof e.pipe||"function"!=typeof e.on||t&&("function"!=typeof e.pause||"function"!=typeof e.resume)||e._writableState&&!1===(null===(r=e._readableState)||void 0===r?void 0:r.readable)||e._writableState&&!e._readableState)}function p(e){var t;return!(!e||"function"!=typeof e.write||"function"!=typeof e.on||e._readableState&&!1===(null===(t=e._writableState)||void 0===t?void 0:t.writable))}function b(e){return e&&(e._readableState||e._writableState||"function"==typeof e.write&&"function"==typeof e.on||"function"==typeof e.pipe&&"function"==typeof e.on)}function g(e){return!(!e||b(e)||"function"!=typeof e.pipeThrough||"function"!=typeof e.getReader||"function"!=typeof e.cancel)}function m(e){return!(!e||b(e)||"function"!=typeof e.getWriter||"function"!=typeof e.abort)}function y(e){return!(!e||b(e)||"object"!=typeof e.readable||"object"!=typeof e.writable)}function _(e){if(!b(e))return null;const t=e._writableState,r=e._readableState,n=t||r;return!!(e.destroyed||e[a]||null!=n&&n.destroyed)}function w(e){if(!p(e))return null;if(!0===e.writableEnded)return!0;const t=e._writableState;return(null==t||!t.errored)&&("boolean"!=typeof(null==t?void 0:t.ended)?null:t.ended)}function v(e,t){if(!d(e))return null;const r=e._readableState;return(null==r||!r.errored)&&("boolean"!=typeof(null==r?void 0:r.endEmitted)?null:!!(r.endEmitted||!1===t&&!0===r.ended&&0===r.length))}function S(e){return e&&null!=e[u]?e[u]:"boolean"!=typeof(null==e?void 0:e.readable)?null:!_(e)&&(d(e)&&e.readable&&!v(e))}function E(e){return"boolean"!=typeof(null==e?void 0:e.writable)?null:!_(e)&&(p(e)&&e.writable&&!w(e))}function A(e){return"boolean"==typeof e._closed&&"boolean"==typeof e._defaultKeepAlive&&"boolean"==typeof e._removedConnection&&"boolean"==typeof e._removedContLen}function k(e){return"boolean"==typeof e._sent100&&A(e)}t.exports={kDestroyed:a,isDisturbed:function(e){var t;return!(!e||!(null!==(t=e[c])&&void 0!==t?t:e.readableDidRead||e.readableAborted))},kIsDisturbed:c,isErrored:function(e){var t,r,n,i,s,o,a,u,c,h;return!(!e||!(null!==(t=null!==(r=null!==(n=null!==(i=null!==(s=null!==(o=e[l])&&void 0!==o?o:e.readableErrored)&&void 0!==s?s:e.writableErrored)&&void 0!==i?i:null===(a=e._readableState)||void 0===a?void 0:a.errorEmitted)&&void 0!==n?n:null===(u=e._writableState)||void 0===u?void 0:u.errorEmitted)&&void 0!==r?r:null===(c=e._readableState)||void 0===c?void 0:c.errored)&&void 0!==t?t:null===(h=e._writableState)||void 0===h?void 0:h.errored))},kIsErrored:l,isReadable:S,kIsReadable:u,kIsClosedPromise:h,kControllerErrorFunction:f,isClosed:function(e){if(!b(e))return null;if("boolean"==typeof e.closed)return e.closed;const t=e._writableState,r=e._readableState;return"boolean"==typeof(null==t?void 0:t.closed)||"boolean"==typeof(null==r?void 0:r.closed)?(null==t?void 0:t.closed)||(null==r?void 0:r.closed):"boolean"==typeof e._closed&&A(e)?e._closed:null},isDestroyed:_,isDuplexNodeStream:function(e){return!(!e||"function"!=typeof e.pipe||!e._readableState||"function"!=typeof e.on||"function"!=typeof e.write)},isFinished:function(e,t){return b(e)?!!_(e)||(!1===(null==t?void 0:t.readable)||!S(e))&&(!1===(null==t?void 0:t.writable)||!E(e)):null},isIterable:function(e,t){return null!=e&&(!0===t?"function"==typeof e[i]:!1===t?"function"==typeof e[s]:"function"==typeof e[i]||"function"==typeof e[s])},isReadableNodeStream:d,isReadableStream:g,isReadableEnded:function(e){if(!d(e))return null;if(!0===e.readableEnded)return!0;const t=e._readableState;return!(!t||t.errored)&&("boolean"!=typeof(null==t?void 0:t.ended)?null:t.ended)},isReadableFinished:v,isReadableErrored:function(e){var t,r;return b(e)?e.readableErrored?e.readableErrored:null!==(t=null===(r=e._readableState)||void 0===r?void 0:r.errored)&&void 0!==t?t:null:null},isNodeStream:b,isWebStream:function(e){return g(e)||m(e)||y(e)},isWritable:E,isWritableNodeStream:p,isWritableStream:m,isWritableEnded:w,isWritableFinished:function(e,t){if(!p(e))return null;if(!0===e.writableFinished)return!0;const r=e._writableState;return(null==r||!r.errored)&&("boolean"!=typeof(null==r?void 0:r.finished)?null:!!(r.finished||!1===t&&!0===r.ended&&0===r.length))},isWritableErrored:function(e){var t,r;return b(e)?e.writableErrored?e.writableErrored:null!==(t=null===(r=e._writableState)||void 0===r?void 0:r.errored)&&void 0!==t?t:null:null},isServerRequest:function(e){var t;return"boolean"==typeof e._consuming&&"boolean"==typeof e._dumped&&void 0===(null===(t=e.req)||void 0===t?void 0:t.upgradeOrConnect)},isServerResponse:k,willEmitClose:function(e){if(!b(e))return null;const t=e._writableState,r=e._readableState,n=t||r;return!n&&k(e)||!!(n&&n.autoDestroy&&n.emitClose&&!1===n.closed)},isTransformStream:y}},{"../../ours/primordials":127}],123:[function(e,t,r){const n=e("process/"),{ArrayPrototypeSlice:i,Error:s,FunctionPrototypeSymbolHasInstance:o,ObjectDefineProperty:a,ObjectDefineProperties:l,ObjectSetPrototypeOf:u,StringPrototypeToLowerCase:c,Symbol:h,SymbolHasInstance:f}=e("../../ours/primordials");t.exports=B,B.WritableState=x;const{EventEmitter:d}=e("events"),p=e("./legacy").Stream,{Buffer:b}=e("buffer"),g=e("./destroy"),{addAbortSignal:m}=e("./add-abort-signal"),{getHighWaterMark:y,getDefaultHighWaterMark:_}=e("./state"),{ERR_INVALID_ARG_TYPE:w,ERR_METHOD_NOT_IMPLEMENTED:v,ERR_MULTIPLE_CALLBACK:S,ERR_STREAM_CANNOT_PIPE:E,ERR_STREAM_DESTROYED:A,ERR_STREAM_ALREADY_FINISHED:k,ERR_STREAM_NULL_VALUES:T,ERR_STREAM_WRITE_AFTER_END:I,ERR_UNKNOWN_ENCODING:R}=e("../../ours/errors").codes,{errorOrDestroy:O}=g;function C(){}u(B.prototype,p.prototype),u(B,p);const P=h("kOnFinished");function x(t,r,n){"boolean"!=typeof n&&(n=r instanceof e("./duplex")),this.objectMode=!(!t||!t.objectMode),n&&(this.objectMode=this.objectMode||!(!t||!t.writableObjectMode)),this.highWaterMark=t?y(this,t,"writableHighWaterMark",n):_(!1),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;const i=!(!t||!1!==t.decodeStrings);this.decodeStrings=!i,this.defaultEncoding=t&&t.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=U.bind(void 0,r),this.writecb=null,this.writelen=0,this.afterWriteTickInfo=null,M(this),this.pendingcb=0,this.constructed=!0,this.prefinished=!1,this.errorEmitted=!1,this.emitClose=!t||!1!==t.emitClose,this.autoDestroy=!t||!1!==t.autoDestroy,this.errored=null,this.closed=!1,this.closeEmitted=!1,this[P]=[]}function M(e){e.buffered=[],e.bufferedIndex=0,e.allBuffers=!0,e.allNoop=!0}function B(t){const r=this instanceof e("./duplex");if(!r&&!o(B,this))return new B(t);this._writableState=new x(t,this,r),t&&("function"==typeof t.write&&(this._write=t.write),"function"==typeof t.writev&&(this._writev=t.writev),"function"==typeof t.destroy&&(this._destroy=t.destroy),"function"==typeof t.final&&(this._final=t.final),"function"==typeof t.construct&&(this._construct=t.construct),t.signal&&m(t.signal,this)),p.call(this,t),g.construct(this,(()=>{const e=this._writableState;e.writing||q(this,e),V(this,e)}))}function L(e,t,r,i){const s=e._writableState;if("function"==typeof r)i=r,r=s.defaultEncoding;else{if(r){if("buffer"!==r&&!b.isEncoding(r))throw new R(r)}else r=s.defaultEncoding;"function"!=typeof i&&(i=C)}if(null===t)throw new T;if(!s.objectMode)if("string"==typeof t)!1!==s.decodeStrings&&(t=b.from(t,r),r="buffer");else if(t instanceof b)r="buffer";else{if(!p._isUint8Array(t))throw new w("chunk",["string","Buffer","Uint8Array"],t);t=p._uint8ArrayToBuffer(t),r="buffer"}let o;return s.ending?o=new I:s.destroyed&&(o=new A("write")),o?(n.nextTick(i,o),O(e,o,!0),o):(s.pendingcb++,function(e,t,r,n,i){const s=t.objectMode?1:r.length;t.length+=s;const o=t.length<t.highWaterMark;o||(t.needDrain=!0);t.writing||t.corked||t.errored||!t.constructed?(t.buffered.push({chunk:r,encoding:n,callback:i}),t.allBuffers&&"buffer"!==n&&(t.allBuffers=!1),t.allNoop&&i!==C&&(t.allNoop=!1)):(t.writelen=s,t.writecb=i,t.writing=!0,t.sync=!0,e._write(r,n,t.onwrite),t.sync=!1);return o&&!t.errored&&!t.destroyed}(e,s,t,r,i))}function j(e,t,r,n,i,s,o){t.writelen=n,t.writecb=o,t.writing=!0,t.sync=!0,t.destroyed?t.onwrite(new A("write")):r?e._writev(i,t.onwrite):e._write(i,s,t.onwrite),t.sync=!1}function N(e,t,r,n){--t.pendingcb,n(r),W(t),O(e,r)}function U(e,t){const r=e._writableState,i=r.sync,s=r.writecb;"function"==typeof s?(r.writing=!1,r.writecb=null,r.length-=r.writelen,r.writelen=0,t?(t.stack,r.errored||(r.errored=t),e._readableState&&!e._readableState.errored&&(e._readableState.errored=t),i?n.nextTick(N,e,r,t,s):N(e,r,t,s)):(r.buffered.length>r.bufferedIndex&&q(e,r),i?null!==r.afterWriteTickInfo&&r.afterWriteTickInfo.cb===s?r.afterWriteTickInfo.count++:(r.afterWriteTickInfo={count:1,cb:s,stream:e,state:r},n.nextTick(D,r.afterWriteTickInfo)):F(e,r,1,s))):O(e,new S)}function D({stream:e,state:t,count:r,cb:n}){return t.afterWriteTickInfo=null,F(e,t,r,n)}function F(e,t,r,n){for(!t.ending&&!e.destroyed&&0===t.length&&t.needDrain&&(t.needDrain=!1,e.emit("drain"));r-- >0;)t.pendingcb--,n();t.destroyed&&W(t),V(e,t)}function W(e){if(e.writing)return;for(let r=e.bufferedIndex;r<e.buffered.length;++r){var t;const{chunk:n,callback:i}=e.buffered[r],s=e.objectMode?1:n.length;e.length-=s,i(null!==(t=e.errored)&&void 0!==t?t:new A("write"))}const r=e[P].splice(0);for(let t=0;t<r.length;t++){var n;r[t](null!==(n=e.errored)&&void 0!==n?n:new A("end"))}M(e)}function q(e,t){if(t.corked||t.bufferProcessing||t.destroyed||!t.constructed)return;const{buffered:r,bufferedIndex:n,objectMode:s}=t,o=r.length-n;if(!o)return;let a=n;if(t.bufferProcessing=!0,o>1&&e._writev){t.pendingcb-=o-1;const n=t.allNoop?C:e=>{for(let t=a;t<r.length;++t)r[t].callback(e)},s=t.allNoop&&0===a?r:i(r,a);s.allBuffers=t.allBuffers,j(e,t,!0,t.length,s,"",n),M(t)}else{do{const{chunk:n,encoding:i,callback:o}=r[a];r[a++]=null;j(e,t,!1,s?1:n.length,n,i,o)}while(a<r.length&&!t.writing);a===r.length?M(t):a>256?(r.splice(0,a),t.bufferedIndex=0):t.bufferedIndex=a}t.bufferProcessing=!1}function H(e){return e.ending&&!e.destroyed&&e.constructed&&0===e.length&&!e.errored&&0===e.buffered.length&&!e.finished&&!e.writing&&!e.errorEmitted&&!e.closeEmitted}function z(e,t){t.prefinished||t.finalCalled||("function"!=typeof e._final||t.destroyed?(t.prefinished=!0,e.emit("prefinish")):(t.finalCalled=!0,function(e,t){let r=!1;function i(i){if(r)O(e,null!=i?i:S());else if(r=!0,t.pendingcb--,i){const r=t[P].splice(0);for(let e=0;e<r.length;e++)r[e](i);O(e,i,t.sync)}else H(t)&&(t.prefinished=!0,e.emit("prefinish"),t.pendingcb++,n.nextTick($,e,t))}t.sync=!0,t.pendingcb++;try{e._final(i)}catch(e){i(e)}t.sync=!1}(e,t)))}function V(e,t,r){H(t)&&(z(e,t),0===t.pendingcb&&(r?(t.pendingcb++,n.nextTick(((e,t)=>{H(t)?$(e,t):t.pendingcb--}),e,t)):H(t)&&(t.pendingcb++,$(e,t))))}function $(e,t){t.pendingcb--,t.finished=!0;const r=t[P].splice(0);for(let e=0;e<r.length;e++)r[e]();if(e.emit("finish"),t.autoDestroy){const t=e._readableState;(!t||t.autoDestroy&&(t.endEmitted||!1===t.readable))&&e.destroy()}}x.prototype.getBuffer=function(){return i(this.buffered,this.bufferedIndex)},a(x.prototype,"bufferedRequestCount",{__proto__:null,get(){return this.buffered.length-this.bufferedIndex}}),a(B,f,{__proto__:null,value:function(e){return!!o(this,e)||this===B&&(e&&e._writableState instanceof x)}}),B.prototype.pipe=function(){O(this,new E)},B.prototype.write=function(e,t,r){return!0===L(this,e,t,r)},B.prototype.cork=function(){this._writableState.corked++},B.prototype.uncork=function(){const e=this._writableState;e.corked&&(e.corked--,e.writing||q(this,e))},B.prototype.setDefaultEncoding=function(e){if("string"==typeof e&&(e=c(e)),!b.isEncoding(e))throw new R(e);return this._writableState.defaultEncoding=e,this},B.prototype._write=function(e,t,r){if(!this._writev)throw new v("_write()");this._writev([{chunk:e,encoding:t}],r)},B.prototype._writev=null,B.prototype.end=function(e,t,r){const i=this._writableState;let o;if("function"==typeof e?(r=e,e=null,t=null):"function"==typeof t&&(r=t,t=null),null!=e){const r=L(this,e,t);r instanceof s&&(o=r)}return i.corked&&(i.corked=1,this.uncork()),o||(i.errored||i.ending?i.finished?o=new k("end"):i.destroyed&&(o=new A("end")):(i.ending=!0,V(this,i,!0),i.ended=!0)),"function"==typeof r&&(o||i.finished?n.nextTick(r,o):i[P].push(r)),this},l(B.prototype,{closed:{__proto__:null,get(){return!!this._writableState&&this._writableState.closed}},destroyed:{__proto__:null,get(){return!!this._writableState&&this._writableState.destroyed},set(e){this._writableState&&(this._writableState.destroyed=e)}},writable:{__proto__:null,get(){const e=this._writableState;return!(!e||!1===e.writable||e.destroyed||e.errored||e.ending||e.ended)},set(e){this._writableState&&(this._writableState.writable=!!e)}},writableFinished:{__proto__:null,get(){return!!this._writableState&&this._writableState.finished}},writableObjectMode:{__proto__:null,get(){return!!this._writableState&&this._writableState.objectMode}},writableBuffer:{__proto__:null,get(){return this._writableState&&this._writableState.getBuffer()}},writableEnded:{__proto__:null,get(){return!!this._writableState&&this._writableState.ending}},writableNeedDrain:{__proto__:null,get(){const e=this._writableState;return!!e&&(!e.destroyed&&!e.ending&&e.needDrain)}},writableHighWaterMark:{__proto__:null,get(){return this._writableState&&this._writableState.highWaterMark}},writableCorked:{__proto__:null,get(){return this._writableState?this._writableState.corked:0}},writableLength:{__proto__:null,get(){return this._writableState&&this._writableState.length}},errored:{__proto__:null,enumerable:!1,get(){return this._writableState?this._writableState.errored:null}},writableAborted:{__proto__:null,enumerable:!1,get:function(){return!(!1===this._writableState.writable||!this._writableState.destroyed&&!this._writableState.errored||this._writableState.finished)}}});const K=g.destroy;let G;function Q(){return void 0===G&&(G={}),G}B.prototype.destroy=function(e,t){const r=this._writableState;return!r.destroyed&&(r.bufferedIndex<r.buffered.length||r[P].length)&&n.nextTick(W,r),K.call(this,e,t),this},B.prototype._undestroy=g.undestroy,B.prototype._destroy=function(e,t){t(e)},B.prototype[d.captureRejectionSymbol]=function(e){this.destroy(e)},B.fromWeb=function(e,t){return Q().newStreamWritableFromWritableStream(e,t)},B.toWeb=function(e){return Q().newWritableStreamFromStreamWritable(e)}},{"../../ours/errors":126,"../../ours/primordials":127,"./add-abort-signal":107,"./destroy":110,"./duplex":111,"./legacy":115,"./state":120,buffer:29,events:49,"process/":102}],124:[function(e,t,r){"use strict";const{ArrayIsArray:n,ArrayPrototypeIncludes:i,ArrayPrototypeJoin:s,ArrayPrototypeMap:o,NumberIsInteger:a,NumberIsNaN:l,NumberMAX_SAFE_INTEGER:u,NumberMIN_SAFE_INTEGER:c,NumberParseInt:h,ObjectPrototypeHasOwnProperty:f,RegExpPrototypeExec:d,String:p,StringPrototypeToUpperCase:b,StringPrototypeTrim:g}=e("../ours/primordials"),{hideStackFrames:m,codes:{ERR_SOCKET_BAD_PORT:y,ERR_INVALID_ARG_TYPE:_,ERR_INVALID_ARG_VALUE:w,ERR_OUT_OF_RANGE:v,ERR_UNKNOWN_SIGNAL:S}}=e("../ours/errors"),{normalizeEncoding:E}=e("../ours/util"),{isAsyncFunction:A,isArrayBufferView:k}=e("../ours/util").types,T={};const I=/^[0-7]+$/;const R=m(((e,t,r=c,n=u)=>{if("number"!=typeof e)throw new _(t,"number",e);if(!a(e))throw new v(t,"an integer",e);if(e<r||e>n)throw new v(t,`>= ${r} && <= ${n}`,e)})),O=m(((e,t,r=-2147483648,n=2147483647)=>{if("number"!=typeof e)throw new _(t,"number",e);if(!a(e))throw new v(t,"an integer",e);if(e<r||e>n)throw new v(t,`>= ${r} && <= ${n}`,e)})),C=m(((e,t,r=!1)=>{if("number"!=typeof e)throw new _(t,"number",e);if(!a(e))throw new v(t,"an integer",e);const n=r?1:0,i=4294967295;if(e<n||e>i)throw new v(t,`>= ${n} && <= ${i}`,e)}));function P(e,t){if("string"!=typeof e)throw new _(t,"string",e)}const x=m(((e,t,r)=>{if(!i(r,e)){const n=s(o(r,(e=>"string"==typeof e?`'${e}'`:p(e))),", ");throw new w(t,e,"must be one of: "+n)}}));function M(e,t){if("boolean"!=typeof e)throw new _(t,"boolean",e)}function B(e,t,r){return null!=e&&f(e,t)?e[t]:r}const L=m(((e,t,r=null)=>{const i=B(r,"allowArray",!1),s=B(r,"allowFunction",!1);if(!B(r,"nullable",!1)&&null===e||!i&&n(e)||"object"!=typeof e&&(!s||"function"!=typeof e))throw new _(t,"Object",e)})),j=m(((e,t)=>{if(null!=e&&"object"!=typeof e&&"function"!=typeof e)throw new _(t,"a dictionary",e)})),N=m(((e,t,r=0)=>{if(!n(e))throw new _(t,"Array",e);if(e.length<r){throw new w(t,e,`must be longer than ${r}`)}}));const U=m(((e,t="buffer")=>{if(!k(e))throw new _(t,["Buffer","TypedArray","DataView"],e)}));const D=m(((e,t)=>{if(void 0!==e&&(null===e||"object"!=typeof e||!("aborted"in e)))throw new _(t,"AbortSignal",e)})),F=m(((e,t)=>{if("function"!=typeof e)throw new _(t,"Function",e)})),W=m(((e,t)=>{if("function"!=typeof e||A(e))throw new _(t,"Function",e)})),q=m(((e,t)=>{if(void 0!==e)throw new _(t,"undefined",e)}));const H=/^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;function z(e,t){if(void 0===e||!d(H,e))throw new w(t,e,'must be an array or string of format "</styles.css>; rel=preload; as=style"')}t.exports={isInt32:function(e){return e===(0|e)},isUint32:function(e){return e===e>>>0},parseFileMode:function(e,t,r){if(void 0===e&&(e=r),"string"==typeof e){if(null===d(I,e))throw new w(t,e,"must be a 32-bit unsigned integer or an octal string");e=h(e,8)}return C(e,t),e},validateArray:N,validateStringArray:function(e,t){N(e,t);for(let r=0;r<e.length;r++)P(e[r],`${t}[${r}]`)},validateBooleanArray:function(e,t){N(e,t);for(let r=0;r<e.length;r++)M(e[r],`${t}[${r}]`)},validateBoolean:M,validateBuffer:U,validateDictionary:j,validateEncoding:function(e,t){const r=E(t),n=e.length;if("hex"===r&&n%2!=0)throw new w("encoding",t,`is invalid for data of length ${n}`)},validateFunction:F,validateInt32:O,validateInteger:R,validateNumber:function(e,t,r=void 0,n){if("number"!=typeof e)throw new _(t,"number",e);if(null!=r&&e<r||null!=n&&e>n||(null!=r||null!=n)&&l(e))throw new v(t,`${null!=r?`>= ${r}`:""}${null!=r&&null!=n?" && ":""}${null!=n?`<= ${n}`:""}`,e)},validateObject:L,validateOneOf:x,validatePlainFunction:W,validatePort:function(e,t="Port",r=!0){if("number"!=typeof e&&"string"!=typeof e||"string"==typeof e&&0===g(e).length||+e!=+e>>>0||e>65535||0===e&&!r)throw new y(t,e,r);return 0|e},validateSignalName:function(e,t="signal"){if(P(e,t),void 0===T[e]){if(void 0!==T[b(e)])throw new S(e+" (signals must use all capital letters)");throw new S(e)}},validateString:P,validateUint32:C,validateUndefined:q,validateUnion:function(e,t,r){if(!i(r,e))throw new _(t,`('${s(r,"|")}')`,e)},validateAbortSignal:D,validateLinkHeaderValue:function(e){if("string"==typeof e)return z(e,"hints"),e;if(n(e)){const t=e.length;let r="";if(0===t)return r;for(let n=0;n<t;n++){const i=e[n];z(i,"hints"),r+=i,n!==t-1&&(r+=", ")}return r}throw new w("hints",e,'must be an array or string of format "</styles.css>; rel=preload; as=style"')}}},{"../ours/errors":126,"../ours/primordials":127,"../ours/util":128}],125:[function(e,t,r){"use strict";const n=e("../stream"),i=e("../stream/promises"),s=n.Readable.destroy;t.exports=n.Readable,t.exports._uint8ArrayToBuffer=n._uint8ArrayToBuffer,t.exports._isUint8Array=n._isUint8Array,t.exports.isDisturbed=n.isDisturbed,t.exports.isErrored=n.isErrored,t.exports.isReadable=n.isReadable,t.exports.Readable=n.Readable,t.exports.Writable=n.Writable,t.exports.Duplex=n.Duplex,t.exports.Transform=n.Transform,t.exports.PassThrough=n.PassThrough,t.exports.addAbortSignal=n.addAbortSignal,t.exports.finished=n.finished,t.exports.destroy=n.destroy,t.exports.destroy=s,t.exports.pipeline=n.pipeline,t.exports.compose=n.compose,Object.defineProperty(n,"promises",{configurable:!0,enumerable:!0,get:()=>i}),t.exports.Stream=n.Stream,t.exports.default=t.exports},{"../stream":129,"../stream/promises":130}],126:[function(e,t,r){"use strict";const{format:n,inspect:i,AggregateError:s}=e("./util"),o=globalThis.AggregateError||s,a=Symbol("kIsNodeError"),l=["string","function","number","object","Function","Object","boolean","bigint","symbol"],u=/^([A-Z][a-z0-9]*)+$/,c={};function h(e,t){if(!e)throw new c.ERR_INTERNAL_ASSERTION(t)}function f(e){let t="",r=e.length;const n="-"===e[0]?1:0;for(;r>=n+4;r-=3)t=`_${e.slice(r-3,r)}${t}`;return`${e.slice(0,r)}${t}`}function d(e,t,r){r||(r=Error);class i extends r{constructor(...r){super(function(e,t,r){if("function"==typeof t)return h(t.length<=r.length,`Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${t.length}).`),t(...r);const i=(t.match(/%[dfijoOs]/g)||[]).length;return h(i===r.length,`Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${i}).`),0===r.length?t:n(t,...r)}(e,t,r))}toString(){return`${this.name} [${e}]: ${this.message}`}}Object.defineProperties(i.prototype,{name:{value:r.name,writable:!0,enumerable:!1,configurable:!0},toString:{value(){return`${this.name} [${e}]: ${this.message}`},writable:!0,enumerable:!1,configurable:!0}}),i.prototype.code=e,i.prototype[a]=!0,c[e]=i}function p(e){const t="__node_internal_"+e.name;return Object.defineProperty(e,"name",{value:t}),e}class b extends Error{constructor(e="The operation was aborted",t=void 0){if(void 0!==t&&"object"!=typeof t)throw new c.ERR_INVALID_ARG_TYPE("options","Object",t);super(e,t),this.code="ABORT_ERR",this.name="AbortError"}}d("ERR_ASSERTION","%s",Error),d("ERR_INVALID_ARG_TYPE",((e,t,r)=>{h("string"==typeof e,"'name' must be a string"),Array.isArray(t)||(t=[t]);let n="The ";e.endsWith(" argument")?n+=`${e} `:n+=`"${e}" ${e.includes(".")?"property":"argument"} `,n+="must be ";const s=[],o=[],a=[];for(const e of t)h("string"==typeof e,"All expected entries have to be of type string"),l.includes(e)?s.push(e.toLowerCase()):u.test(e)?o.push(e):(h("object"!==e,'The value "object" should be written as "Object"'),a.push(e));if(o.length>0){const e=s.indexOf("object");-1!==e&&(s.splice(s,e,1),o.push("Object"))}if(s.length>0){switch(s.length){case 1:n+=`of type ${s[0]}`;break;case 2:n+=`one of type ${s[0]} or ${s[1]}`;break;default:{const e=s.pop();n+=`one of type ${s.join(", ")}, or ${e}`}}(o.length>0||a.length>0)&&(n+=" or ")}if(o.length>0){switch(o.length){case 1:n+=`an instance of ${o[0]}`;break;case 2:n+=`an instance of ${o[0]} or ${o[1]}`;break;default:{const e=o.pop();n+=`an instance of ${o.join(", ")}, or ${e}`}}a.length>0&&(n+=" or ")}switch(a.length){case 0:break;case 1:a[0].toLowerCase()!==a[0]&&(n+="an "),n+=`${a[0]}`;break;case 2:n+=`one of ${a[0]} or ${a[1]}`;break;default:{const e=a.pop();n+=`one of ${a.join(", ")}, or ${e}`}}if(null==r)n+=`. Received ${r}`;else if("function"==typeof r&&r.name)n+=`. Received function ${r.name}`;else if("object"==typeof r){var c;if(null!==(c=r.constructor)&&void 0!==c&&c.name)n+=`. Received an instance of ${r.constructor.name}`;else{n+=`. Received ${i(r,{depth:-1})}`}}else{let e=i(r,{colors:!1});e.length>25&&(e=`${e.slice(0,25)}...`),n+=`. Received type ${typeof r} (${e})`}return n}),TypeError),d("ERR_INVALID_ARG_VALUE",((e,t,r="is invalid")=>{let n=i(t);n.length>128&&(n=n.slice(0,128)+"...");return`The ${e.includes(".")?"property":"argument"} '${e}' ${r}. Received ${n}`}),TypeError),d("ERR_INVALID_RETURN_VALUE",((e,t,r)=>{var n;return`Expected ${e} to be returned from the "${t}" function but got ${null!=r&&null!==(n=r.constructor)&&void 0!==n&&n.name?`instance of ${r.constructor.name}`:"type "+typeof r}.`}),TypeError),d("ERR_MISSING_ARGS",((...e)=>{let t;h(e.length>0,"At least one arg needs to be specified");const r=e.length;switch(e=(Array.isArray(e)?e:[e]).map((e=>`"${e}"`)).join(" or "),r){case 1:t+=`The ${e[0]} argument`;break;case 2:t+=`The ${e[0]} and ${e[1]} arguments`;break;default:{const r=e.pop();t+=`The ${e.join(", ")}, and ${r} arguments`}}return`${t} must be specified`}),TypeError),d("ERR_OUT_OF_RANGE",((e,t,r)=>{let n;return h(t,'Missing "range" argument'),Number.isInteger(r)&&Math.abs(r)>2**32?n=f(String(r)):"bigint"==typeof r?(n=String(r),(r>2n**32n||r<-(2n**32n))&&(n=f(n)),n+="n"):n=i(r),`The value of "${e}" is out of range. It must be ${t}. Received ${n}`}),RangeError),d("ERR_MULTIPLE_CALLBACK","Callback called multiple times",Error),d("ERR_METHOD_NOT_IMPLEMENTED","The %s method is not implemented",Error),d("ERR_STREAM_ALREADY_FINISHED","Cannot call %s after a stream was finished",Error),d("ERR_STREAM_CANNOT_PIPE","Cannot pipe, not readable",Error),d("ERR_STREAM_DESTROYED","Cannot call %s after a stream was destroyed",Error),d("ERR_STREAM_NULL_VALUES","May not write null values to stream",TypeError),d("ERR_STREAM_PREMATURE_CLOSE","Premature close",Error),d("ERR_STREAM_PUSH_AFTER_EOF","stream.push() after EOF",Error),d("ERR_STREAM_UNSHIFT_AFTER_END_EVENT","stream.unshift() after end event",Error),d("ERR_STREAM_WRITE_AFTER_END","write after end",Error),d("ERR_UNKNOWN_ENCODING","Unknown encoding: %s",TypeError),t.exports={AbortError:b,aggregateTwoErrors:p((function(e,t){if(e&&t&&e!==t){if(Array.isArray(t.errors))return t.errors.push(e),t;const r=new o([t,e],t.message);return r.code=t.code,r}return e||t})),hideStackFrames:p,codes:c}},{"./util":128}],127:[function(e,t,r){"use strict";t.exports={ArrayIsArray:e=>Array.isArray(e),ArrayPrototypeIncludes:(e,t)=>e.includes(t),ArrayPrototypeIndexOf:(e,t)=>e.indexOf(t),ArrayPrototypeJoin:(e,t)=>e.join(t),ArrayPrototypeMap:(e,t)=>e.map(t),ArrayPrototypePop:(e,t)=>e.pop(t),ArrayPrototypePush:(e,t)=>e.push(t),ArrayPrototypeSlice:(e,t,r)=>e.slice(t,r),Error:Error,FunctionPrototypeCall:(e,t,...r)=>e.call(t,...r),FunctionPrototypeSymbolHasInstance:(e,t)=>Function.prototype[Symbol.hasInstance].call(e,t),MathFloor:Math.floor,Number:Number,NumberIsInteger:Number.isInteger,NumberIsNaN:Number.isNaN,NumberMAX_SAFE_INTEGER:Number.MAX_SAFE_INTEGER,NumberMIN_SAFE_INTEGER:Number.MIN_SAFE_INTEGER,NumberParseInt:Number.parseInt,ObjectDefineProperties:(e,t)=>Object.defineProperties(e,t),ObjectDefineProperty:(e,t,r)=>Object.defineProperty(e,t,r),ObjectGetOwnPropertyDescriptor:(e,t)=>Object.getOwnPropertyDescriptor(e,t),ObjectKeys:e=>Object.keys(e),ObjectSetPrototypeOf:(e,t)=>Object.setPrototypeOf(e,t),Promise:Promise,PromisePrototypeCatch:(e,t)=>e.catch(t),PromisePrototypeThen:(e,t,r)=>e.then(t,r),PromiseReject:e=>Promise.reject(e),ReflectApply:Reflect.apply,RegExpPrototypeTest:(e,t)=>e.test(t),SafeSet:Set,String:String,StringPrototypeSlice:(e,t,r)=>e.slice(t,r),StringPrototypeToLowerCase:e=>e.toLowerCase(),StringPrototypeToUpperCase:e=>e.toUpperCase(),StringPrototypeTrim:e=>e.trim(),Symbol:Symbol,SymbolFor:Symbol.for,SymbolAsyncIterator:Symbol.asyncIterator,SymbolHasInstance:Symbol.hasInstance,SymbolIterator:Symbol.iterator,TypedArrayPrototypeSet:(e,t,r)=>e.set(t,r),Uint8Array:Uint8Array}},{}],128:[function(e,t,r){"use strict";const n=e("buffer"),i=Object.getPrototypeOf((async function(){})).constructor,s=globalThis.Blob||n.Blob,o=void 0!==s?function(e){return e instanceof s}:function(e){return!1};class a extends Error{constructor(e){if(!Array.isArray(e))throw new TypeError("Expected input to be an Array, got "+typeof e);let t="";for(let r=0;r<e.length;r++)t+=`    ${e[r].stack}\n`;super(t),this.name="AggregateError",this.errors=e}}t.exports={AggregateError:a,kEmptyObject:Object.freeze({}),once(e){let t=!1;return function(...r){t||(t=!0,e.apply(this,r))}},createDeferredPromise:function(){let e,t;return{promise:new Promise(((r,n)=>{e=r,t=n})),resolve:e,reject:t}},promisify:e=>new Promise(((t,r)=>{e(((e,...n)=>e?r(e):t(...n)))})),debuglog:()=>function(){},format:(e,...t)=>e.replace(/%([sdifj])/g,(function(...[e,r]){const n=t.shift();if("f"===r)return n.toFixed(6);if("j"===r)return JSON.stringify(n);if("s"===r&&"object"==typeof n){return`${n.constructor!==Object?n.constructor.name:""} {}`.trim()}return n.toString()})),inspect(e){switch(typeof e){case"string":if(e.includes("'")){if(!e.includes('"'))return`"${e}"`;if(!e.includes("`")&&!e.includes("${"))return`\`${e}\``}return`'${e}'`;case"number":return isNaN(e)?"NaN":Object.is(e,-0)?String(e):e;case"bigint":return`${String(e)}n`;case"boolean":case"undefined":return String(e);case"object":return"{}"}},types:{isAsyncFunction:e=>e instanceof i,isArrayBufferView:e=>ArrayBuffer.isView(e)},isBlob:o},t.exports.promisify.custom=Symbol.for("nodejs.util.promisify.custom")},{buffer:29}],129:[function(e,t,r){const{Buffer:n}=e("buffer"),{ObjectDefineProperty:i,ObjectKeys:s,ReflectApply:o}=e("./ours/primordials"),{promisify:{custom:a}}=e("./ours/util"),{streamReturningOperators:l,promiseReturningOperators:u}=e("./internal/streams/operators"),{codes:{ERR_ILLEGAL_CONSTRUCTOR:c}}=e("./ours/errors"),h=e("./internal/streams/compose"),{pipeline:f}=e("./internal/streams/pipeline"),{destroyer:d}=e("./internal/streams/destroy"),p=e("./internal/streams/end-of-stream"),b=e("./stream/promises"),g=e("./internal/streams/utils"),m=t.exports=e("./internal/streams/legacy").Stream;m.isDisturbed=g.isDisturbed,m.isErrored=g.isErrored,m.isReadable=g.isReadable,m.Readable=e("./internal/streams/readable");for(const w of s(l)){const v=l[w];function y(...e){if(new.target)throw c();return m.Readable.from(o(v,this,e))}i(y,"name",{__proto__:null,value:v.name}),i(y,"length",{__proto__:null,value:v.length}),i(m.Readable.prototype,w,{__proto__:null,value:y,enumerable:!1,configurable:!0,writable:!0})}for(const S of s(u)){const E=u[S];function y(...e){if(new.target)throw c();return o(E,this,e)}i(y,"name",{__proto__:null,value:E.name}),i(y,"length",{__proto__:null,value:E.length}),i(m.Readable.prototype,S,{__proto__:null,value:y,enumerable:!1,configurable:!0,writable:!0})}m.Writable=e("./internal/streams/writable"),m.Duplex=e("./internal/streams/duplex"),m.Transform=e("./internal/streams/transform"),m.PassThrough=e("./internal/streams/passthrough"),m.pipeline=f;const{addAbortSignal:_}=e("./internal/streams/add-abort-signal");m.addAbortSignal=_,m.finished=p,m.destroy=d,m.compose=h,i(m,"promises",{__proto__:null,configurable:!0,enumerable:!0,get:()=>b}),i(f,a,{__proto__:null,enumerable:!0,get:()=>b.pipeline}),i(p,a,{__proto__:null,enumerable:!0,get:()=>b.finished}),m.Stream=m,m._isUint8Array=function(e){return e instanceof Uint8Array},m._uint8ArrayToBuffer=function(e){return n.from(e.buffer,e.byteOffset,e.byteLength)}},{"./internal/streams/add-abort-signal":107,"./internal/streams/compose":109,"./internal/streams/destroy":110,"./internal/streams/duplex":111,"./internal/streams/end-of-stream":113,"./internal/streams/legacy":115,"./internal/streams/operators":116,"./internal/streams/passthrough":117,"./internal/streams/pipeline":118,"./internal/streams/readable":119,"./internal/streams/transform":121,"./internal/streams/utils":122,"./internal/streams/writable":123,"./ours/errors":126,"./ours/primordials":127,"./ours/util":128,"./stream/promises":130,buffer:29}],130:[function(e,t,r){"use strict";const{ArrayPrototypePop:n,Promise:i}=e("../ours/primordials"),{isIterable:s,isNodeStream:o,isWebStream:a}=e("../internal/streams/utils"),{pipelineImpl:l}=e("../internal/streams/pipeline"),{finished:u}=e("../internal/streams/end-of-stream");e("../../lib/stream.js"),t.exports={finished:u,pipeline:function(...e){return new i(((t,r)=>{let i,u;const c=e[e.length-1];if(c&&"object"==typeof c&&!o(c)&&!s(c)&&!a(c)){const t=n(e);i=t.signal,u=t.end}l(e,((e,n)=>{e?r(e):t(n)}),{signal:i,end:u})}))}}},{"../../lib/stream.js":129,"../internal/streams/end-of-stream":113,"../internal/streams/pipeline":118,"../internal/streams/utils":122,"../ours/primordials":127}],131:[function(e,t,r){"use strict";function n(e,t,r){var n=this;this._callback=e,this._args=r,this._interval=setInterval(e,t,this._args),this.reschedule=function(e){e||(e=n._interval),n._interval&&clearInterval(n._interval),n._interval=setInterval(n._callback,e,n._args)},this.clear=function(){n._interval&&(clearInterval(n._interval),n._interval=void 0)},this.destroy=function(){n._interval&&clearInterval(n._interval),n._callback=void 0,n._interval=void 0,n._args=void 0}}t.exports=function(){if("function"!=typeof arguments[0])throw new Error("callback needed");if("number"!=typeof arguments[1])throw new Error("interval needed");var e;if(arguments.length>0){e=new Array(arguments.length-2);for(var t=0;t<e.length;t++)e[t]=arguments[t+2]}return new n(arguments[0],arguments[1],e)}},{}],132:[function(e,t,r){"use strict";t.exports=e("./index.js")()},{"./index.js":133}],133:[function(e,t,r){(function(e){(function(){"use strict";function r(t){return t instanceof e?e.from(t):new t.constructor(t.buffer.slice(),t.byteOffset,t.length)}t.exports=function(e){return(e=e||{}).circles?function(e){var t=[],n=[];return e.proto?function e(s){if("object"!=typeof s||null===s)return s;if(s instanceof Date)return new Date(s);if(Array.isArray(s))return i(s,e);if(s instanceof Map)return new Map(i(Array.from(s),e));if(s instanceof Set)return new Set(i(Array.from(s),e));var o={};for(var a in t.push(s),n.push(o),s){var l=s[a];if("object"!=typeof l||null===l)o[a]=l;else if(l instanceof Date)o[a]=new Date(l);else if(l instanceof Map)o[a]=new Map(i(Array.from(l),e));else if(l instanceof Set)o[a]=new Set(i(Array.from(l),e));else if(ArrayBuffer.isView(l))o[a]=r(l);else{var u=t.indexOf(l);o[a]=-1!==u?n[u]:e(l)}}return t.pop(),n.pop(),o}:function e(s){if("object"!=typeof s||null===s)return s;if(s instanceof Date)return new Date(s);if(Array.isArray(s))return i(s,e);if(s instanceof Map)return new Map(i(Array.from(s),e));if(s instanceof Set)return new Set(i(Array.from(s),e));var o={};for(var a in t.push(s),n.push(o),s)if(!1!==Object.hasOwnProperty.call(s,a)){var l=s[a];if("object"!=typeof l||null===l)o[a]=l;else if(l instanceof Date)o[a]=new Date(l);else if(l instanceof Map)o[a]=new Map(i(Array.from(l),e));else if(l instanceof Set)o[a]=new Set(i(Array.from(l),e));else if(ArrayBuffer.isView(l))o[a]=r(l);else{var u=t.indexOf(l);o[a]=-1!==u?n[u]:e(l)}}return t.pop(),n.pop(),o};function i(e,i){for(var s=Object.keys(e),o=new Array(s.length),a=0;a<s.length;a++){var l=s[a],u=e[l];if("object"!=typeof u||null===u)o[l]=u;else if(u instanceof Date)o[l]=new Date(u);else if(ArrayBuffer.isView(u))o[l]=r(u);else{var c=t.indexOf(u);o[l]=-1!==c?n[c]:i(u)}}return o}}(e):e.proto?function e(n){if("object"!=typeof n||null===n)return n;if(n instanceof Date)return new Date(n);if(Array.isArray(n))return t(n,e);if(n instanceof Map)return new Map(t(Array.from(n),e));if(n instanceof Set)return new Set(t(Array.from(n),e));var i={};for(var s in n){var o=n[s];"object"!=typeof o||null===o?i[s]=o:o instanceof Date?i[s]=new Date(o):o instanceof Map?i[s]=new Map(t(Array.from(o),e)):o instanceof Set?i[s]=new Set(t(Array.from(o),e)):ArrayBuffer.isView(o)?i[s]=r(o):i[s]=e(o)}return i}:function e(n){if("object"!=typeof n||null===n)return n;if(n instanceof Date)return new Date(n);if(Array.isArray(n))return t(n,e);if(n instanceof Map)return new Map(t(Array.from(n),e));if(n instanceof Set)return new Set(t(Array.from(n),e));var i={};for(var s in n)if(!1!==Object.hasOwnProperty.call(n,s)){var o=n[s];"object"!=typeof o||null===o?i[s]=o:o instanceof Date?i[s]=new Date(o):o instanceof Map?i[s]=new Map(t(Array.from(o),e)):o instanceof Set?i[s]=new Set(t(Array.from(o),e)):ArrayBuffer.isView(o)?i[s]=r(o):i[s]=e(o)}return i};function t(e,t){for(var n=Object.keys(e),i=new Array(n.length),s=0;s<n.length;s++){var o=n[s],a=e[o];"object"!=typeof a||null===a?i[o]=a:a instanceof Date?i[o]=new Date(a):ArrayBuffer.isView(a)?i[o]=r(a):i[o]=t(a)}return i}}}).call(this)}).call(this,e("buffer").Buffer)},{buffer:29}],134:[function(e,t,r){
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var n=e("buffer"),i=n.Buffer;function s(e,t){for(var r in e)t[r]=e[r]}function o(e,t,r){return i(e,t,r)}i.from&&i.alloc&&i.allocUnsafe&&i.allocUnsafeSlow?t.exports=n:(s(n,r),r.Buffer=o),o.prototype=Object.create(i.prototype),s(i,o),o.from=function(e,t,r){if("number"==typeof e)throw new TypeError("Argument must not be a number");return i(e,t,r)},o.alloc=function(e,t,r){if("number"!=typeof e)throw new TypeError("Argument must be a number");var n=i(e);return void 0!==t?"string"==typeof r?n.fill(t,r):n.fill(t):n.fill(0),n},o.allocUnsafe=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return i(e)},o.allocUnsafeSlow=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return n.SlowBuffer(e)}},{buffer:29}],135:[function(e,t,r){t.exports=function(e){var t=e._readableState;return t?t.objectMode||"number"==typeof e._duplexState?e.read():e.read(function(e){if(e.buffer.length)return e.buffer.head?e.buffer.head.data.length:e.buffer[0].length;return e.length}(t)):null}},{}],136:[function(e,t,r){arguments[4][28][0].apply(r,arguments)},{dup:28,"safe-buffer":134}],137:[function(e,t,r){"use strict";var n=e("punycode"),i=e("./util");function s(){this.protocol=null,this.slashes=null,this.auth=null,this.host=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.query=null,this.pathname=null,this.path=null,this.href=null}r.parse=_,r.resolve=function(e,t){return _(e,!1,!0).resolve(t)},r.resolveObject=function(e,t){return e?_(e,!1,!0).resolveObject(t):t},r.format=function(e){i.isString(e)&&(e=_(e));return e instanceof s?e.format():s.prototype.format.call(e)},r.Url=s;var o=/^([a-z0-9.+-]+:)/i,a=/:[0-9]*$/,l=/^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,u=["{","}","|","\\","^","`"].concat(["<",">",'"',"`"," ","\r","\n","\t"]),c=["'"].concat(u),h=["%","/","?",";","#"].concat(c),f=["/","?","#"],d=/^[+a-z0-9A-Z_-]{0,63}$/,p=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,b={javascript:!0,"javascript:":!0},g={javascript:!0,"javascript:":!0},m={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,"http:":!0,"https:":!0,"ftp:":!0,"gopher:":!0,"file:":!0},y=e("querystring");function _(e,t,r){if(e&&i.isObject(e)&&e instanceof s)return e;var n=new s;return n.parse(e,t,r),n}s.prototype.parse=function(e,t,r){if(!i.isString(e))throw new TypeError("Parameter 'url' must be a string, not "+typeof e);var s=e.indexOf("?"),a=-1!==s&&s<e.indexOf("#")?"?":"#",u=e.split(a);u[0]=u[0].replace(/\\/g,"/");var _=e=u.join(a);if(_=_.trim(),!r&&1===e.split("#").length){var w=l.exec(_);if(w)return this.path=_,this.href=_,this.pathname=w[1],w[2]?(this.search=w[2],this.query=t?y.parse(this.search.substr(1)):this.search.substr(1)):t&&(this.search="",this.query={}),this}var v=o.exec(_);if(v){var S=(v=v[0]).toLowerCase();this.protocol=S,_=_.substr(v.length)}if(r||v||_.match(/^\/\/[^@\/]+@[^@\/]+/)){var E="//"===_.substr(0,2);!E||v&&g[v]||(_=_.substr(2),this.slashes=!0)}if(!g[v]&&(E||v&&!m[v])){for(var A,k,T=-1,I=0;I<f.length;I++){-1!==(R=_.indexOf(f[I]))&&(-1===T||R<T)&&(T=R)}-1!==(k=-1===T?_.lastIndexOf("@"):_.lastIndexOf("@",T))&&(A=_.slice(0,k),_=_.slice(k+1),this.auth=decodeURIComponent(A)),T=-1;for(I=0;I<h.length;I++){var R;-1!==(R=_.indexOf(h[I]))&&(-1===T||R<T)&&(T=R)}-1===T&&(T=_.length),this.host=_.slice(0,T),_=_.slice(T),this.parseHost(),this.hostname=this.hostname||"";var O="["===this.hostname[0]&&"]"===this.hostname[this.hostname.length-1];if(!O)for(var C=this.hostname.split(/\./),P=(I=0,C.length);I<P;I++){var x=C[I];if(x&&!x.match(d)){for(var M="",B=0,L=x.length;B<L;B++)x.charCodeAt(B)>127?M+="x":M+=x[B];if(!M.match(d)){var j=C.slice(0,I),N=C.slice(I+1),U=x.match(p);U&&(j.push(U[1]),N.unshift(U[2])),N.length&&(_="/"+N.join(".")+_),this.hostname=j.join(".");break}}}this.hostname.length>255?this.hostname="":this.hostname=this.hostname.toLowerCase(),O||(this.hostname=n.toASCII(this.hostname));var D=this.port?":"+this.port:"",F=this.hostname||"";this.host=F+D,this.href+=this.host,O&&(this.hostname=this.hostname.substr(1,this.hostname.length-2),"/"!==_[0]&&(_="/"+_))}if(!b[S])for(I=0,P=c.length;I<P;I++){var W=c[I];if(-1!==_.indexOf(W)){var q=encodeURIComponent(W);q===W&&(q=escape(W)),_=_.split(W).join(q)}}var H=_.indexOf("#");-1!==H&&(this.hash=_.substr(H),_=_.slice(0,H));var z=_.indexOf("?");if(-1!==z?(this.search=_.substr(z),this.query=_.substr(z+1),t&&(this.query=y.parse(this.query)),_=_.slice(0,z)):t&&(this.search="",this.query={}),_&&(this.pathname=_),m[S]&&this.hostname&&!this.pathname&&(this.pathname="/"),this.pathname||this.search){D=this.pathname||"";var V=this.search||"";this.path=D+V}return this.href=this.format(),this},s.prototype.format=function(){var e=this.auth||"";e&&(e=(e=encodeURIComponent(e)).replace(/%3A/i,":"),e+="@");var t=this.protocol||"",r=this.pathname||"",n=this.hash||"",s=!1,o="";this.host?s=e+this.host:this.hostname&&(s=e+(-1===this.hostname.indexOf(":")?this.hostname:"["+this.hostname+"]"),this.port&&(s+=":"+this.port)),this.query&&i.isObject(this.query)&&Object.keys(this.query).length&&(o=y.stringify(this.query));var a=this.search||o&&"?"+o||"";return t&&":"!==t.substr(-1)&&(t+=":"),this.slashes||(!t||m[t])&&!1!==s?(s="//"+(s||""),r&&"/"!==r.charAt(0)&&(r="/"+r)):s||(s=""),n&&"#"!==n.charAt(0)&&(n="#"+n),a&&"?"!==a.charAt(0)&&(a="?"+a),t+s+(r=r.replace(/[?#]/g,(function(e){return encodeURIComponent(e)})))+(a=a.replace("#","%23"))+n},s.prototype.resolve=function(e){return this.resolveObject(_(e,!1,!0)).format()},s.prototype.resolveObject=function(e){if(i.isString(e)){var t=new s;t.parse(e,!1,!0),e=t}for(var r=new s,n=Object.keys(this),o=0;o<n.length;o++){var a=n[o];r[a]=this[a]}if(r.hash=e.hash,""===e.href)return r.href=r.format(),r;if(e.slashes&&!e.protocol){for(var l=Object.keys(e),u=0;u<l.length;u++){var c=l[u];"protocol"!==c&&(r[c]=e[c])}return m[r.protocol]&&r.hostname&&!r.pathname&&(r.path=r.pathname="/"),r.href=r.format(),r}if(e.protocol&&e.protocol!==r.protocol){if(!m[e.protocol]){for(var h=Object.keys(e),f=0;f<h.length;f++){var d=h[f];r[d]=e[d]}return r.href=r.format(),r}if(r.protocol=e.protocol,e.host||g[e.protocol])r.pathname=e.pathname;else{for(var p=(e.pathname||"").split("/");p.length&&!(e.host=p.shift()););e.host||(e.host=""),e.hostname||(e.hostname=""),""!==p[0]&&p.unshift(""),p.length<2&&p.unshift(""),r.pathname=p.join("/")}if(r.search=e.search,r.query=e.query,r.host=e.host||"",r.auth=e.auth,r.hostname=e.hostname||e.host,r.port=e.port,r.pathname||r.search){var b=r.pathname||"",y=r.search||"";r.path=b+y}return r.slashes=r.slashes||e.slashes,r.href=r.format(),r}var _=r.pathname&&"/"===r.pathname.charAt(0),w=e.host||e.pathname&&"/"===e.pathname.charAt(0),v=w||_||r.host&&e.pathname,S=v,E=r.pathname&&r.pathname.split("/")||[],A=(p=e.pathname&&e.pathname.split("/")||[],r.protocol&&!m[r.protocol]);if(A&&(r.hostname="",r.port=null,r.host&&(""===E[0]?E[0]=r.host:E.unshift(r.host)),r.host="",e.protocol&&(e.hostname=null,e.port=null,e.host&&(""===p[0]?p[0]=e.host:p.unshift(e.host)),e.host=null),v=v&&(""===p[0]||""===E[0])),w)r.host=e.host||""===e.host?e.host:r.host,r.hostname=e.hostname||""===e.hostname?e.hostname:r.hostname,r.search=e.search,r.query=e.query,E=p;else if(p.length)E||(E=[]),E.pop(),E=E.concat(p),r.search=e.search,r.query=e.query;else if(!i.isNullOrUndefined(e.search)){if(A)r.hostname=r.host=E.shift(),(O=!!(r.host&&r.host.indexOf("@")>0)&&r.host.split("@"))&&(r.auth=O.shift(),r.host=r.hostname=O.shift());return r.search=e.search,r.query=e.query,i.isNull(r.pathname)&&i.isNull(r.search)||(r.path=(r.pathname?r.pathname:"")+(r.search?r.search:"")),r.href=r.format(),r}if(!E.length)return r.pathname=null,r.search?r.path="/"+r.search:r.path=null,r.href=r.format(),r;for(var k=E.slice(-1)[0],T=(r.host||e.host||E.length>1)&&("."===k||".."===k)||""===k,I=0,R=E.length;R>=0;R--)"."===(k=E[R])?E.splice(R,1):".."===k?(E.splice(R,1),I++):I&&(E.splice(R,1),I--);if(!v&&!S)for(;I--;I)E.unshift("..");!v||""===E[0]||E[0]&&"/"===E[0].charAt(0)||E.unshift(""),T&&"/"!==E.join("/").substr(-1)&&E.push("");var O,C=""===E[0]||E[0]&&"/"===E[0].charAt(0);A&&(r.hostname=r.host=C?"":E.length?E.shift():"",(O=!!(r.host&&r.host.indexOf("@")>0)&&r.host.split("@"))&&(r.auth=O.shift(),r.host=r.hostname=O.shift()));return(v=v||r.host&&E.length)&&!C&&E.unshift(""),E.length?r.pathname=E.join("/"):(r.pathname=null,r.path=null),i.isNull(r.pathname)&&i.isNull(r.search)||(r.path=(r.pathname?r.pathname:"")+(r.search?r.search:"")),r.auth=e.auth||r.auth,r.slashes=r.slashes||e.slashes,r.href=r.format(),r},s.prototype.parseHost=function(){var e=this.host,t=a.exec(e);t&&(":"!==(t=t[0])&&(this.port=t.substr(1)),e=e.substr(0,e.length-t.length)),e&&(this.hostname=e)}},{"./util":138,punycode:103,querystring:106}],138:[function(e,t,r){"use strict";t.exports={isString:function(e){return"string"==typeof e},isObject:function(e){return"object"==typeof e&&null!==e},isNull:function(e){return null===e},isNullOrUndefined:function(e){return null==e}}},{}],139:[function(e,t,r){(function(e){(function(){function r(t){try{if(!e.localStorage)return!1}catch(e){return!1}var r=e.localStorage[t];return null!=r&&"true"===String(r).toLowerCase()}t.exports=function(e,t){if(r("noDeprecation"))return e;var n=!1;return function(){if(!n){if(r("throwDeprecation"))throw new Error(t);r("traceDeprecation")?console.trace(t):console.warn(t),n=!0}return e.apply(this,arguments)}}}).call(this)}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],140:[function(e,t,r){t.exports=function e(t,r){if(t&&r)return e(t)(r);if("function"!=typeof t)throw new TypeError("need wrapper function");return Object.keys(t).forEach((function(e){n[e]=t[e]})),n;function n(){for(var e=new Array(arguments.length),r=0;r<e.length;r++)e[r]=arguments[r];var n=t.apply(this,e),i=e[e.length-1];return"function"==typeof n&&n!==i&&Object.keys(i).forEach((function(e){n[e]=i[e]})),n}}},{}],141:[function(e,t,r){"use strict";t.exports=function(){throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object")}},{}]},{},[23])(23)}));MQTT.js command line interface, available commands are:

  * publish     publish a message to the broker
  * subscribe   subscribe for updates from the broker
  * version     the current MQTT.js version
  * help        help about commands

Launch 'mqtt help [command]' to know more about the commands.
Usage: mqtt publish [opts] topic [message]

Available options:

  -h/--hostname HOST    the broker host
  -p/--port PORT        the broker port
  -i/--client-id ID     the client id
  -q/--qos 0/1/2        the QoS of the message
  -t/--topic TOPIC      the message topic
  -m/--message MSG      the message body
  -r/--retain           send a retained message
  -s/--stdin            read the message body from stdin
  -M/--multiline        read lines from stdin as multiple messages 
  -u/--username USER    the username
  -P/--password PASS    the password
  -C/--protocol PROTO   the protocol to use, 'mqtt',
                        'mqtts', 'ws' or 'wss'
  --key PATH            path to the key file
  --cert PATH           path to the cert file
  --ca PATH             path to the ca certificate
  --insecure            do not verify the server certificate
  --will-topic TOPIC    the will topic
  --will-payload BODY   the will message
  --will-qos 0/1/2      the will qos
  --will-retain         send a will retained message 
  -H/--help             show this
Usage: mqtt subscribe [opts] [topic]

Available options:

  -h/--hostname HOST    the broker host
  -p/--port PORT        the broker port
  -i/--clientId ID      the client id
  -q/--qos 0/1/2        the QoS of the message
  --no-clean            do not discard any pending message for
                        the given id
  -t/--topic TOPIC      the message topic
  -k/--keepalive SEC    send a ping every SEC seconds
  -u/--username USER    the username
  -P/--password PASS    the password
  -l/--protocol PROTO   the protocol to use, 'mqtt',
                        'mqtts', 'ws' or 'wss'
  --key PATH            path to the key file
  --cert PATH           path to the cert file
  --ca PATH             path to the ca certificate
  --insecure            do not verify the server certificate
  --will-topic TOPIC    the will topic
  --will-message BODY   the will message
  --will-qos 0/1/2      the will qos
  --will-retain         send a will retained message
  -v/--verbose          print the topic before the message
  -H/--help             show this
The MIT License (MIT)
=====================

Copyright (c) 2015-2016 MQTT.js contributors
---------------------------------------

*MQTT.js contributors listed at <https://github.com/mqttjs/MQTT.js#contributors>*

Copyright 2011-2014 by Adam Rudd

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
{
  "name": "mqtt",
  "description": "A library for the MQTT protocol",
  "version": "5.1.4",
  "contributors": [
    "Adam Rudd <adamvrr@gmail.com>",
    "Matteo Collina <matteo.collina@gmail.com> (https://github.com/mcollina)",
    "Siarhei Buntsevich <scarry0506@gmail.com> (https://github.com/scarry1992)",
    "Yoseph Maguire <yomaguir@microsoft.com> (https://github.com/YoDaMa)",
    "Daniel Lando <daniel.sorridi@gmail.com> (https://github.com/robertsLando)"
  ],
  "keywords": [
    "mqtt",
    "publish/subscribe",
    "publish",
    "subscribe"
  ],
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git://github.com/mqttjs/MQTT.js.git"
  },
  "main": "./build/mqtt.js",
  "bin": {
    "mqtt_pub": "./build/bin/pub.js",
    "mqtt_sub": "./build/bin/sub.js",
    "mqtt": "./build/bin/mqtt.js"
  },
  "files": [
    "dist/",
    "CONTRIBUTING.md",
    "LICENSE.md",
    "help/",
    "build/",
    "src/"
  ],
  "exports": {
    ".": "./build/mqtt.js",
    "./package.json": "./package.json",
    "./*.map": "./build/*.js.map",
    "./dist/*": "./dist/*.js",
    "./*": "./build/*.js"
  },
  "types": "build/mqtt.d.ts",
  "typesVersions": {
    "*": {
      "*": [
        "./build/mqtt.d.ts"
      ]
    }
  },
  "scripts": {
    "lint": "eslint --ext .ts .",
    "lint-fix": "eslint --fix --ext .ts .",
    "build:ts": "rimraf build/ && tsc -p tsconfig.build.json",
    "build:browser": "rimraf dist/ && mkdirp dist/ && browserify build/mqtt.js --standalone mqtt > dist/mqtt.js && terser dist/mqtt.js --compress --mangle --output dist/mqtt.min.js",
    "build": "npm run build:ts && npm run build:browser",
    "prepare": "npm run build",
    "unit-test:node": "node_modules/.bin/nyc --reporter=lcov --reporter=text node -r esbuild-register test/runTests.ts",
    "unit-test:browser": "airtap --server test/browser/server.js test/browser/test.js",
    "test:node": "npm run unit-test:node && codecov",
    "test:browser": "npm run build && npm run unit-test:browser",
    "test": "npm run test:node",
    "changelog": "conventional-changelog -p angular -i CHANGELOG.md -s && git add CHANGELOG.md",
    "changelog-init": "conventional-changelog -p angular -i CHANGELOG.md -s -r 0",
    "release": "read -p 'GITHUB_TOKEN: ' GITHUB_TOKEN && export GITHUB_TOKEN=$GITHUB_TOKEN && release-it"
  },
  "release-it": {
    "github": {
      "release": true
    },
    "git": {
      "tagName": "v${version}",
      "commitMessage": "chore(release): ${version}"
    },
    "hooks": {
      "before:init": [
        "npm run test"
      ]
    },
    "npm": {
      "publish": true
    },
    "plugins": {
      "@release-it/conventional-changelog": {
        "preset": "angular",
        "infile": "CHANGELOG.md"
      }
    }
  },
  "pre-commit": [
    "lint"
  ],
  "engines": {
    "node": ">=16.0.0"
  },
  "browser": {
    "./mqtt.js": "./build/mqtt.js",
    "fs": false,
    "tls": false,
    "net": false
  },
  "dependencies": {
    "@types/readable-stream": "^4.0.4",
    "@types/ws": "^8.5.8",
    "commist": "^3.2.0",
    "concat-stream": "^2.0.0",
    "debug": "^4.3.4",
    "duplexify": "^4.1.2",
    "help-me": "^4.2.0",
    "lru-cache": "^7.18.3",
    "minimist": "^1.2.8",
    "mqtt-packet": "^8.2.1",
    "number-allocator": "^1.0.14",
    "readable-stream": "^4.4.2",
    "reinterval": "^1.1.0",
    "rfdc": "^1.3.0",
    "split2": "^4.2.0",
    "ws": "^8.14.2"
  },
  "devDependencies": {
    "@release-it/conventional-changelog": "^7.0.2",
    "@types/chai": "^4.3.9",
    "@types/duplexify": "^3.6.3",
    "@types/node": "^20.8.8",
    "@types/sinon": "^10.0.20",
    "@types/tape": "^5.6.3",
    "@typescript-eslint/eslint-plugin": "^6.9.0",
    "@typescript-eslint/parser": "^6.9.0",
    "airtap": "^4.0.4",
    "airtap-playwright": "^1.0.1",
    "browserify": "^17.0.0",
    "chai": "^4.3.10",
    "chokidar": "^3.5.3",
    "codecov": "^3.8.2",
    "conventional-changelog-cli": "^4.1.0",
    "end-of-stream": "^1.4.4",
    "esbuild-register": "^3.5.0",
    "eslint": "^8.52.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "eslint-config-airbnb-typescript": "^17.1.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-import": "^2.29.0",
    "eslint-plugin-prettier": "^5.0.1",
    "global": "^4.4.0",
    "leaked-handles": "^5.2.0",
    "mkdirp": "^3.0.1",
    "mqtt-connection": "^4.1.0",
    "mqtt-level-store": "^3.1.0",
    "nyc": "^15.1.0",
    "pre-commit": "^1.2.2",
    "prettier": "^3.0.3",
    "release-it": "^16.2.1",
    "rimraf": "^5.0.5",
    "should": "^13.2.3",
    "sinon": "^17.0.0",
    "snazzy": "^9.0.0",
    "tape": "^5.7.2",
    "terser": "^5.22.0",
    "ts-node": "^10.9.1",
    "typescript": "^5.2.2"
  }
}
# ![mqtt.js](https://raw.githubusercontent.com/mqttjs/MQTT.js/137ee0e3940c1f01049a30248c70f24dc6e6f829/MQTT.js.png)

![Github Test Status](https://github.com/mqttjs/MQTT.js/workflows/MQTT.js%20CI/badge.svg) [![codecov](https://codecov.io/gh/mqttjs/MQTT.js/branch/master/graph/badge.svg)](https://codecov.io/gh/mqttjs/MQTT.js)

[![Maintenance](https://img.shields.io/badge/Maintained%3F-yes-green.svg)](https://github.com/mqttjs/MQTT.js/graphs/commit-activity)
[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://github.com/mqttjs/MQTT.js/pulls)

[![node](https://img.shields.io/node/v/mqtt.svg) ![npm](https://img.shields.io/npm/v/mqtt.svg?logo=npm) ![NPM Downloads](https://img.shields.io/npm/dm/mqtt.svg)](https://www.npmjs.com/package/mqtt)

MQTT.js is a client library for the [MQTT](http://mqtt.org/) protocol, written
in JavaScript for node.js and the browser.

## Table of Contents

- [Upgrade notes](#notes)
- [Installation](#install)
- [Example](#example)
- [Import Styles](#example)
- [Command Line Tools](#cli)
- [API](#api)
- [Browser](#browser)
- [About QoS](#qos)
- [TypeScript](#typescript)
- [Weapp and Ali support](#weapp-alipay)
- [Contributing](#contributing)
- [Sponsor](#sponsor)
- [License](#license)

MQTT.js is an OPEN Open Source Project, see the [Contributing](#contributing) section to find out what this means.

[![JavaScript Style
Guide](https://cdn.rawgit.com/feross/standard/master/badge.svg)](https://github.com/feross/standard)

<a name="notes"></a>

## Important notes for existing users

**v5.0.0** (07/2023)

- Removes support for all end of life node versions (v12 and v14), and now supports node v18 and v20.
- Completely rewritten in Typescript .
- When creating `MqttClient` instance `new` is now required.

**v4.0.0** (Released 04/2020) removes support for all end of life node versions, and now supports node v12 and v14. It also adds improvements to
debug logging, along with some feature additions.

As a **breaking change**, by default a error handler is built into the MQTT.js client, so if any
errors are emitted and the user has not created an event handler on the client for errors, the client will
not break as a result of unhandled errors. Additionally, typical TLS errors like `ECONNREFUSED`, `ECONNRESET` have been
added to a list of TLS errors that will be emitted from the MQTT.js client, and so can be handled as connection errors.

**v3.0.0** adds support for MQTT 5, support for node v10.x, and many fixes to improve reliability.

**Note:** MQTT v5 support is experimental as it has not been implemented by brokers yet.

**v2.0.0** removes support for node v0.8, v0.10 and v0.12, and it is 3x faster in sending
packets. It also removes all the deprecated functionality in v1.0.0,
mainly `mqtt.createConnection` and `mqtt.Server`. From v2.0.0,
subscriptions are restored upon reconnection if `clean: true`.
v1.x.x is now in _LTS_, and it will keep being supported as long as
there are v0.8, v0.10 and v0.12 users.

As a **breaking change**, the `encoding` option in the old client is
removed, and now everything is UTF-8 with the exception of the
`password` in the CONNECT message and `payload` in the PUBLISH message,
which are `Buffer`.

Another **breaking change** is that MQTT.js now defaults to MQTT v3.1.1,
so to support old brokers, please read the [client options doc](#client).

**v1.0.0** improves the overall architecture of the project, which is now
split into three components: MQTT.js keeps the Client,
[mqtt-connection](http://npm.im/mqtt-connection) includes the barebone
Connection code for server-side usage, and [mqtt-packet](http://npm.im/mqtt-packet)
includes the protocol parser and generator. The new Client improves
performance by a 30% factor, embeds Websocket support
([MOWS](http://npm.im/mows) is now deprecated), and it has a better
support for QoS 1 and 2. The previous API is still supported but
deprecated, as such, it is not documented in this README.

<a name="install"></a>

## Installation

```sh
npm install mqtt --save
```

<a name="example"></a>

## Example

For the sake of simplicity, let's put the subscriber and the publisher in the same file:

```js
const mqtt = require("mqtt");
const client = mqtt.connect("mqtt://test.mosquitto.org");

client.on("connect", () => {
  client.subscribe("presence", (err) => {
    if (!err) {
      client.publish("presence", "Hello mqtt");
    }
  });
});

client.on("message", (topic, message) => {
  // message is Buffer
  console.log(message.toString());
  client.end();
});
```

output:

```sh
Hello mqtt
```

If you want to run your own MQTT broker, you can use
[Mosquitto](http://mosquitto.org) or
[Aedes-cli](https://github.com/moscajs/aedes-cli), and launch it.

You can also use a test instance: test.mosquitto.org.

If you do not want to install a separate broker, you can try using the
[Aedes](https://github.com/moscajs/aedes).

<a name="import_styles"></a>

## Import styles

### CommonJS (Require)

```js
const mqtt = require("mqtt")  // require mqtt
const client = mqtt.connect("test.mosquitto.org")  // create a client
```

### ES6 Modules (Import)

#### Aliased wildcard import

```js
import * as mqtt from "mqtt"; // import everything inside the mqtt module and give it the namespace "mqtt"
let client = mqtt.connect("mqtt://test.mosquitto.org"); // create a client
```

#### Importing individual components

```js
import { connect } from "mqtt"; // import connect from mqtt
let client = connect("mqtt://test.mosquitto.org"); // create a client
```

<a name="cli"></a>

## Command Line Tools

MQTT.js bundles a command to interact with a broker.
In order to have it available on your path, you should install MQTT.js
globally:

```sh
npm install mqtt -g
```

Then, on one terminal

```sh
mqtt sub -t 'hello' -h 'test.mosquitto.org' -v
```

On another

```sh
mqtt pub -t 'hello' -h 'test.mosquitto.org' -m 'from MQTT.js'
```

See `mqtt help <command>` for the command help.

<a name="debug"></a>

## Debug Logs

MQTT.js uses the [debug](https://www.npmjs.com/package/debug#cmd) package for debugging purposes. To enable debug logs, add the following environment variable on runtime :

```ps
# (example using PowerShell, the VS Code default)
$env:DEBUG='mqttjs*'
```

<a name="reconnecting"></a>

## About Reconnection

An important part of any websocket connection is what to do when a connection
drops off and the client needs to reconnect. MQTT has built-in reconnection
support that can be configured to behave in ways that suit the application.

#### Refresh Authentication Options / Signed Urls with `transformWsUrl` (Websocket Only)

When an mqtt connection drops and needs to reconnect, it's common to require
that any authentication associated with the connection is kept current with
the underlying auth mechanism. For instance some applications may pass an auth
token with connection options on the initial connection, while other cloud
services may require a url be signed with each connection.

By the time the reconnect happens in the application lifecycle, the original
auth data may have expired.

To address this we can use a hook called `transformWsUrl` to manipulate
either of the connection url or the client options at the time of a reconnect.

Example (update clientId & username on each reconnect):

```js
    const transformWsUrl = (url, options, client) => {
      client.options.username = `token=${this.get_current_auth_token()}`;
      client.options.clientId = `${this.get_updated_clientId()}`;

      return `${this.get_signed_cloud_url(url)}`;
    }

    const connection = await mqtt.connectAsync(<wss url>, {
      ...,
      transformWsUrl: transformUrl,
    });

```

Now every time a new WebSocket connection is opened (hopefully not too often),
we will get a fresh signed url or fresh auth token data.

Note: Currently this hook does _not_ support promises, meaning that in order to
use the latest auth token, you must have some outside mechanism running that
handles application-level authentication refreshing so that the websocket
connection can simply grab the latest valid token or signed url.

#### Customize Websockets with `createWebsocket` (Websocket Only)

When you need to add a custom websocket subprotocol or header to open a connection
through a proxy with custom authentication this callback allows you to create your own
instance of a websocket which will be used in the mqtt client.

```js
  const createWebsocket = createWebsocket(url, websocketSubProtocols, options) => {
    const subProtocols = [
      websocketSubProtocols[0],
      'myCustomSubprotocolOrOAuthToken',
    ]
    return new WebSocket(url, subProtocols)
  }

    const connection = await mqtt.connectAsync(<wss url>, {
      ...,
      createWebsocket: createWebsocket,
    });
```

#### Enabling Reconnection with `reconnectPeriod` option

To ensure that the mqtt client automatically tries to reconnect when the
connection is dropped, you must set the client option `reconnectPeriod` to a
value greater than 0. A value of 0 will disable reconnection and then terminate
the final connection when it drops.

The default value is 1000 ms which means it will try to reconnect 1 second
after losing the connection.

<a name="topicalias"></a>

## About Topic Alias Management

### Enabling automatic Topic Alias using

If the client sets the option `autoUseTopicAlias:true` then MQTT.js uses existing topic alias automatically.

example scenario:

```bash
1. PUBLISH topic:'t1', ta:1                   (register)
2. PUBLISH topic:'t1'       -> topic:'', ta:1 (auto use existing map entry)
3. PUBLISH topic:'t2', ta:1                   (register overwrite)
4. PUBLISH topic:'t2'       -> topic:'', ta:1 (auto use existing map entry based on the receent map)
5. PUBLISH topic:'t1'                         (t1 is no longer mapped to ta:1)
```

User doesn't need to manage which topic is mapped to which topic alias.
If the user want to register topic alias, then publish topic with topic alias.
If the user want to use topic alias, then publish topic without topic alias. If there is a mapped topic alias then added it as a property and update the topic to empty string.

### Enabling automatic Topic Alias assign

If the client sets the option `autoAssignTopicAlias:true` then MQTT.js uses existing topic alias automatically.
If no topic alias exists, then assign a new vacant topic alias automatically. If topic alias is fully used, then LRU(Least Recently Used) topic-alias entry is overwritten.

example scenario:

```bash
The broker returns CONNACK (TopicAliasMaximum:3)
1. PUBLISH topic:'t1' -> 't1', ta:1 (auto assign t1:1 and register)
2. PUBLISH topic:'t1' -> ''  , ta:1 (auto use existing map entry)
3. PUBLISH topic:'t2' -> 't2', ta:2 (auto assign t1:2 and register. 2 was vacant)
4. PUBLISH topic:'t3' -> 't3', ta:3 (auto assign t1:3 and register. 3 was vacant)
5. PUBLISH topic:'t4' -> 't4', ta:1 (LRU entry is overwritten)
```

Also user can manually register topic-alias pair using PUBLISH topic:'some', ta:X. It works well with automatic topic alias assign.

<a name="api"></a>

## API

- [`mqtt.connect()`](#connect)
- [`mqtt.connectAsync()`](#connect-async)
- [`mqtt.Client()`](#client)
- [`mqtt.Client#connect()`](#client-connect)
- [`mqtt.Client#publish()`](#publish)
- [`mqtt.Client#publishAsync()`](#publish-async)
- [`mqtt.Client#subscribe()`](#subscribe)
- [`mqtt.Client#subscribeAsync()`](#subscribe-async)
- [`mqtt.Client#unsubscribe()`](#unsubscribe)
- [`mqtt.Client#unsubscribeAsync()`](#unsubscribe-async)
- [`mqtt.Client#end()`](#end)
- [`mqtt.Client#endAsync()`](#end-async)
- [`mqtt.Client#removeOutgoingMessage()`](#removeOutgoingMessage)
- [`mqtt.Client#reconnect()`](#reconnect)
- [`mqtt.Client#handleMessage()`](#handleMessage)
- [`mqtt.Client#connected`](#connected)
- [`mqtt.Client#reconnecting`](#reconnecting)
- [`mqtt.Client#getLastMessageId()`](#getLastMessageId)
- [`mqtt.Store()`](#store)
- [`mqtt.Store#put()`](#put)
- [`mqtt.Store#del()`](#del)
- [`mqtt.Store#createStream()`](#createStream)
- [`mqtt.Store#close()`](#close)

---

<a name="connect"></a>

### mqtt.connect([url], options)

Connects to the broker specified by the given url and options and
returns a [Client](#client).

The URL can be on the following protocols: 'mqtt', 'mqtts', 'tcp',
'tls', 'ws', 'wss', 'wxs', 'alis'. The URL can also be an object as returned by
[`URL.parse()`](http://nodejs.org/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost),
in that case the two objects are merged, i.e. you can pass a single
object with both the URL and the connect options.

You can also specify a `servers` options with content: `[{ host:
'localhost', port: 1883 }, ... ]`, in that case that array is iterated
at every connect.

For all MQTT-related options, see the [Client](#client)
constructor.

<a name="connect-async"></a>

### connectAsync([url], options)

Asynchronous wrapper around the [`connect`](#connect) function.

Returns a `Promise` that resolves to a `mqtt.Client` instance when the client
fires a `'connect'` or `'end'` event, or rejects with an error if the `'error'`
is fired.

Note that the `manualConnect` option will cause the promise returned by this
function to never resolve or reject as the underlying client never fires any
events.

---

<a name="client"></a>

### mqtt.Client(streamBuilder, options)

The `Client` class wraps a client connection to an
MQTT broker over an arbitrary transport method (TCP, TLS,
WebSocket, ecc).
`Client` is an [EventEmitter](https://nodejs.dev/en/learn/the-nodejs-event-emitter/) that has it's own [events](#events)

`Client` automatically handles the following:

- Regular server pings
- QoS flow
- Automatic reconnections
- Start publishing before being connected

The arguments are:

- `streamBuilder` is a function that returns a subclass of the `Stream` class that supports
  the `connect` event. Typically a `net.Socket`.
- `options` is the client connection options (see: the [connect packet](https://github.com/mcollina/mqtt-packet#connect)). Defaults:
  - `wsOptions`: is the WebSocket connection options. Default is `{}`.
    It's specific for WebSockets. For possible options have a look at: <https://github.com/websockets/ws/blob/master/doc/ws.md>.
  - `keepalive`: `60` seconds, set to `0` to disable
  - `reschedulePings`: reschedule ping messages after sending packets (default `true`)
  - `clientId`: `'mqttjs_' + Math.random().toString(16).substr(2, 8)`
  - `protocolId`: `'MQTT'`
  - `protocolVersion`: `4`
  - `clean`: `true`, set to false to receive QoS 1 and 2 messages while
    offline
  - `reconnectPeriod`: `1000` milliseconds, interval between two
    reconnections. Disable auto reconnect by setting to `0`.
  - `connectTimeout`: `30 * 1000` milliseconds, time to wait before a
    CONNACK is received
  - `username`: the username required by your broker, if any
  - `password`: the password required by your broker, if any
  - `incomingStore`: a [Store](#store) for the incoming packets
  - `outgoingStore`: a [Store](#store) for the outgoing packets
  - `queueQoSZero`: if connection is broken, queue outgoing QoS zero messages (default `true`)
  - `customHandleAcks`: MQTT 5 feature of custom handling puback and pubrec packets. Its callback:

    ```js
      customHandleAcks: function(topic, message, packet, done) {/*some logic with calling done(error, reasonCode)*/}
    ```

  - `autoUseTopicAlias`: enabling automatic Topic Alias using functionality
  - `autoAssignTopicAlias`: enabling automatic Topic Alias assign functionality
  - `properties`: properties MQTT 5.0.
    `object` that supports the following properties:
    - `sessionExpiryInterval`: representing the Session Expiry Interval in seconds `number`,
    - `receiveMaximum`: representing the Receive Maximum value `number`,
    - `maximumPacketSize`: representing the Maximum Packet Size the Client is willing to accept `number`,
    - `topicAliasMaximum`: representing the Topic Alias Maximum value indicates the highest value that the Client will accept as a Topic Alias sent by the Server `number`,
    - `requestResponseInformation`: The Client uses this value to request the Server to return Response Information in the CONNACK `boolean`,
    - `requestProblemInformation`: The Client uses this value to indicate whether the Reason String or User Properties are sent in the case of failures `boolean`,
    - `userProperties`: The User Property is allowed to appear multiple times to represent multiple name, value pairs `object`,
    - `authenticationMethod`: the name of the authentication method used for extended authentication `string`,
    - `authenticationData`: Binary Data containing authentication data `binary`
  - `authPacket`: settings for auth packet `object`
  - `will`: a message that will sent by the broker automatically when
    the client disconnect badly. The format is:
    - `topic`: the topic to publish
    - `payload`: the message to publish
    - `qos`: the QoS
    - `retain`: the retain flag
    - `properties`: properties of will by MQTT 5.0:
      - `willDelayInterval`: representing the Will Delay Interval in seconds `number`,
      - `payloadFormatIndicator`: Will Message is UTF-8 Encoded Character Data or not `boolean`,
      - `messageExpiryInterval`: value is the lifetime of the Will Message in seconds and is sent as the Publication Expiry Interval when the Server publishes the Will Message `number`,
      - `contentType`: describing the content of the Will Message `string`,
      - `responseTopic`: String which is used as the Topic Name for a response message `string`,
      - `correlationData`: The Correlation Data is used by the sender of the Request Message to identify which request the Response Message is for when it is received `binary`,
      - `userProperties`: The User Property is allowed to appear multiple times to represent multiple name, value pairs `object`
  - `transformWsUrl` : optional `(url, options, client) => url` function
    For ws/wss protocols only. Can be used to implement signing
    urls which upon reconnect can have become expired.
  - `createWebsocket` : optional `url, websocketSubProtocols, options) => Websocket` function
      For ws/wss protocols only. Can be used to implement a custom websocket subprotocol or implementation.
  - `resubscribe` : if connection is broken and reconnects,
    subscribed topics are automatically subscribed again (default `true`)
  - `messageIdProvider`: custom messageId provider. when `new UniqueMessageIdProvider()` is set, then non conflict messageId is provided.
  - `log`: custom log function. Default uses [debug](https://www.npmjs.com/package/debug) package.
  - `manualConnect`: prevents the constructor to call `connect`. In this case after the `mqtt.connect` is called you should call `client.connect` manually.

In case mqtts (mqtt over tls) is required, the `options` object is passed through to [`tls.connect()`](http://nodejs.org/api/tls.html#tls_tls_connect_options_callback). If using a **self-signed certificate**, set `rejectUnauthorized: false`. However, be cautious as this exposes you to potential man in the middle attacks and isn't recommended for production.

For those supporting multiple TLS protocols on a single port, like MQTTS and MQTT over WSS, utilize the `ALPNProtocols` option. This lets you define the Application Layer Protocol Negotiation (ALPN) protocol. You can set `ALPNProtocols` as a string array, Buffer, or Uint8Array based on your setup.

If you are connecting to a broker that supports only MQTT 3.1 (not
3.1.1 compliant), you should pass these additional options:

```js
{
  protocolId: 'MQIsdp',
  protocolVersion: 3
}
```

This is confirmed on RabbitMQ 3.2.4, and on Mosquitto < 1.3. Mosquitto
version 1.3 and 1.4 works fine without those.

<a name="events"></a>

#### Event `'connect'`

`function (connack) {}`

Emitted on successful (re)connection (i.e. connack rc=0).

- `connack` received connack packet. When `clean` connection option is `false` and server has a previous session
  for `clientId` connection option, then `connack.sessionPresent` flag is `true`. When that is the case,
  you may rely on stored session and prefer not to send subscribe commands for the client.

#### Event `'reconnect'`

`function () {}`

Emitted when a reconnect starts.

#### Event `'close'`

`function () {}`

Emitted after a disconnection.

#### Event `'disconnect'`

`function (packet) {}`

Emitted after receiving disconnect packet from broker. MQTT 5.0 feature.

#### Event `'offline'`

`function () {}`

Emitted when the client goes offline.

#### Event `'error'`

`function (error) {}`

Emitted when the client cannot connect (i.e. connack rc != 0) or when a
parsing error occurs.

The following TLS errors will be emitted as an `error` event:

- `ECONNREFUSED`
- `ECONNRESET`
- `EADDRINUSE`
- `ENOTFOUND`

#### Event `'end'`

`function () {}`

Emitted when [`mqtt.Client#end()`](#end) is called.
If a callback was passed to `mqtt.Client#end()`, this event is emitted once the
callback returns.

#### Event `'message'`

`function (topic, message, packet) {}`

Emitted when the client receives a publish packet

- `topic` topic of the received packet
- `message` payload of the received packet
- `packet` received packet, as defined in
  [mqtt-packet](https://github.com/mcollina/mqtt-packet#publish)

#### Event `'packetsend'`

`function (packet) {}`

Emitted when the client sends any packet. This includes .published() packets
as well as packets used by MQTT for managing subscriptions and connections

- `packet` received packet, as defined in
  [mqtt-packet](https://github.com/mcollina/mqtt-packet)

#### Event `'packetreceive'`

`function (packet) {}`

Emitted when the client receives any packet. This includes packets from
subscribed topics as well as packets used by MQTT for managing subscriptions
and connections

- `packet` received packet, as defined in
  [mqtt-packet](https://github.com/mcollina/mqtt-packet)

---

<a name="client-connect"></a>

### mqtt.Client#connect()

By default client connects when constructor is called. To prevent this you can set `manualConnect` option to `true` and call `client.connect()` manually.

<a name="publish"></a>

### mqtt.Client#publish(topic, message, [options], [callback])

Publish a message to a topic

- `topic` is the topic to publish to, `String`
- `message` is the message to publish, `Buffer` or `String`
- `options` is the options to publish with, including:
  - `qos` QoS level, `Number`, default `0`
  - `retain` retain flag, `Boolean`, default `false`
  - `dup` mark as duplicate flag, `Boolean`, default `false`
  - `properties`: MQTT 5.0 properties `object`
    - `payloadFormatIndicator`: Payload is UTF-8 Encoded Character Data or not `boolean`,
    - `messageExpiryInterval`: the lifetime of the Application Message in seconds `number`,
    - `topicAlias`: value that is used to identify the Topic instead of using the Topic Name `number`,
    - `responseTopic`: String which is used as the Topic Name for a response message `string`,
    - `correlationData`: used by the sender of the Request Message to identify which request the Response Message is for when it is received `binary`,
    - `userProperties`: The User Property is allowed to appear multiple times to represent multiple name, value pairs `object`,
    - `subscriptionIdentifier`: representing the identifier of the subscription `number`,
    - `contentType`: String describing the content of the Application Message `string`
  - `cbStorePut` - `function ()`, fired when message is put into `outgoingStore` if QoS is `1` or `2`.
- `callback` - `function (err)`, fired when the QoS handling completes,
  or at the next tick if QoS 0. An error occurs if client is disconnecting.

<a name="publish-async"></a>

### mqtt.Client#publishAsync(topic, message, [options])

Async [`publish`](#publish). Returns a `Promise<void>`.

---

<a name="subscribe"></a>

### mqtt.Client#subscribe(topic/topic array/topic object, [options], [callback])

Subscribe to a topic or topics

- `topic` is a `String` topic to subscribe to or an `Array` of
  topics to subscribe to. It can also be an object, it has as object
  keys the topic name and as value the QoS, like `{'test1': {qos: 0}, 'test2': {qos: 1}}`.
  MQTT `topic` wildcard characters are supported (`+` - for single level and `#` - for multi level)
- `options` is the options to subscribe with, including:
  - `qos` QoS subscription level, default 0
  - `nl` No Local MQTT 5.0 flag (If the value is true, Application Messages MUST NOT be forwarded to a connection with a ClientID equal to the ClientID of the publishing connection)
  - `rap` Retain as Published MQTT 5.0 flag (If true, Application Messages forwarded using this subscription keep the RETAIN flag they were published with. If false, Application Messages forwarded using this subscription have the RETAIN flag set to 0.)
  - `rh` Retain Handling MQTT 5.0 (This option specifies whether retained messages are sent when the subscription is established.)
  - `properties`: `object`
    - `subscriptionIdentifier`: representing the identifier of the subscription `number`,
    - `userProperties`: The User Property is allowed to appear multiple times to represent multiple name, value pairs `object`
- `callback` - `function (err, granted)`
  callback fired on suback where:
  - `err` a subscription error or an error that occurs when client is disconnecting
  - `granted` is an array of `{topic, qos}` where:
    - `topic` is a subscribed to topic
    - `qos` is the granted QoS level on it

<a name="subscribe-async"></a>

### mqtt.Client#subscribeAsync(topic/topic array/topic object, [options])

Async [`subscribe`](#subscribe). Returns a `Promise<granted[]>`.

---

<a name="unsubscribe"></a>

### mqtt.Client#unsubscribe(topic/topic array, [options], [callback])

Unsubscribe from a topic or topics

- `topic` is a `String` topic or an array of topics to unsubscribe from
- `options`: options of unsubscribe.
  - `properties`: `object`
    - `userProperties`: The User Property is allowed to appear multiple times to represent multiple name, value pairs `object`
- `callback` - `function (err)`, fired on unsuback. An error occurs if client is disconnecting.

<a name="unsubscribe-async"></a>

### mqtt.Client#unsubscribeAsync(topic/topic array, [options])

Async [`unsubscribe`](#unsubscribe). Returns a `Promise<void>`.

---

<a name="end"></a>

### mqtt.Client#end([force], [options], [callback])

Close the client, accepts the following options:

- `force`: passing it to true will close the client right away, without
  waiting for the in-flight messages to be acked. This parameter is
  optional.
- `options`: options of disconnect.
  - `reasonCode`: Disconnect Reason Code `number`
  - `properties`: `object`
    - `sessionExpiryInterval`: representing the Session Expiry Interval in seconds `number`,
    - `reasonString`: representing the reason for the disconnect `string`,
    - `userProperties`: The User Property is allowed to appear multiple times to represent multiple name, value pairs `object`,
    - `serverReference`: String which can be used by the Client to identify another Server to use `string`
- `callback`: will be called when the client is closed. This parameter is
  optional.

<a name="end-async"></a>

### mqtt.Client#endAsync([force], [options])

Async [`end`](#end). Returns a `Promise<void>`.

---

<a name="removeOutgoingMessage"></a>

### mqtt.Client#removeOutgoingMessage(mId)

Remove a message from the outgoingStore.
The outgoing callback will be called with Error('Message removed') if the message is removed.

After this function is called, the messageId is released and becomes reusable.

- `mId`: The messageId of the message in the outgoingStore.

---

<a name="reconnect"></a>

### mqtt.Client#reconnect()

Connect again using the same options as connect()

---

<a name="handleMessage"></a>

### mqtt.Client#handleMessage(packet, callback)

Handle messages with backpressure support, one at a time.
Override at will, but **always call `callback`**, or the client
will hang.

---

<a name="connected"></a>

### mqtt.Client#connected

Boolean : set to `true` if the client is connected. `false` otherwise.

---

<a name="getLastMessageId"></a>

### mqtt.Client#getLastMessageId()

Number : get last message id. This is for sent messages only.

---

<a name="reconnecting"></a>

### mqtt.Client#reconnecting

Boolean : set to `true` if the client is trying to reconnect to the server. `false` otherwise.

---

<a name="store"></a>

### mqtt.Store(options)

In-memory implementation of the message store.

- `options` is the store options:
  - `clean`: `true`, clean inflight messages when close is called (default `true`)

Other implementations of `mqtt.Store`:

- [mqtt-jsonl-store](https://github.com/robertsLando/mqtt-jsonl-store) which uses
  [jsonl-db](https://github.com/AlCalzone/jsonl-db) to store inflight data, it works only on Node.
- [mqtt-level-store](http://npm.im/mqtt-level-store) which uses
  [Level-browserify](http://npm.im/level-browserify) to store the inflight
  data, making it usable both in Node and the Browser.
- [mqtt-nedb-store](https://github.com/behrad/mqtt-nedb-store) which
  uses [nedb](https://www.npmjs.com/package/nedb) to store the inflight
  data.
- [mqtt-localforage-store](http://npm.im/mqtt-localforage-store) which uses
  [localForage](http://npm.im/localforage) to store the inflight
  data, making it usable in the Browser without browserify.

---

<a name="put"></a>

### mqtt.Store#put(packet, callback)

Adds a packet to the store, a packet is
anything that has a `messageId` property.
The callback is called when the packet has been stored.

---

<a name="createStream"></a>

### mqtt.Store#createStream()

Creates a stream with all the packets in the store.

---

<a name="del"></a>

### mqtt.Store#del(packet, cb)

Removes a packet from the store, a packet is
anything that has a `messageId` property.
The callback is called when the packet has been removed.

---

<a name="close"></a>

### mqtt.Store#close(cb)

Closes the Store.

<a name="browser"></a>

## Browser

MQTT.js is bundled using [browserify](http://browserify.org/). You can find the browser build in the `dist` folder.

```js
import * as mqtt from 'mqtt/dist/mqtt.min'
```

<a name="cdn"></a>

### Via CDN

The MQTT.js bundle is available through <http://unpkg.com>, specifically
at <https://unpkg.com/mqtt/dist/mqtt.min.js>.
See <http://unpkg.com> for the full documentation on version ranges.

**Be sure to only use this bundle with `ws` or `wss` URLs in the browser. Others URL types will likey fail**

<a name="webpack"></a>

### Webpack

If you are using webpack simply import MQTT.js like this:

```js
import * as mqtt from 'mqtt/dist/mqtt.min'
```

<a name="vite"></a>

### Vite

If you are using vite simply import MQTT.js like this:

```js
import * as mqtt from 'mqtt/dist/mqtt.min'
```

<a name="qos"></a>

## About QoS

Here is how QoS works:

- QoS 0 : received **at most once** : The packet is sent, and that's it. There is no validation about whether it has been received.
- QoS 1 : received **at least once** : The packet is sent and stored as long as the client has not received a confirmation from the server. MQTT ensures that it _will_ be received, but there can be duplicates.
- QoS 2 : received **exactly once** : Same as QoS 1 but there is no duplicates.

About data consumption, obviously, QoS 2 > QoS 1 > QoS 0, if that's a concern to you.

<a name="typescript"></a>

## Usage with TypeScript

Starting from v5 this project is written in TypeScript and the type definitions are included in the package.

Example:

```ts
import { connect } from "mqtt"
const client = connect('mqtt://test.mosquitto.org')
```

<a name="weapp-alipay"></a>

## WeChat and Ali Mini Program support

### WeChat Mini Program

Supports [WeChat Mini Program](https://mp.weixin.qq.com/). Use the `wxs` protocol. See [the WeChat docs](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-socket.html).

```js
const mqtt = require("mqtt");
const client = mqtt.connect("wxs://test.mosquitto.org");
```

### Ali Mini Program

Supports [Ali Mini Program](https://open.alipay.com/channel/miniIndex.htm). Use the `alis` protocol. See [the Alipay docs](https://docs.alipay.com/mini/developer/getting-started).
<a name="example"></a>

```js
const mqtt = require("mqtt");
const client = mqtt.connect("alis://test.mosquitto.org");
```

<a name="contributing"></a>

## Contributing

MQTT.js is an **OPEN Open Source Project**. This means that:

> Individuals making significant and valuable contributions are given commit-access to the project to contribute as they see fit. This project is more like an open wiki than a standard guarded open source project.

See the [CONTRIBUTING.md](https://github.com/mqttjs/MQTT.js/blob/master/CONTRIBUTING.md) file for more details.

### Contributors

MQTT.js is only possible due to the excellent work of the following contributors:

| Name               | GitHub                                             | Twitter                                                    |
| ------------------ | -------------------------------------------------- | ---------------------------------------------------------- |
| Adam Rudd          | [GitHub/adamvr](https://github.com/adamvr)         | [Twitter/@adam_vr](http://twitter.com/adam_vr)             |
| Matteo Collina     | [GitHub/mcollina](https://github.com/mcollina)     | [Twitter/@matteocollina](http://twitter.com/matteocollina) |
| Maxime Agor        | [GitHub/4rzael](https://github.com/4rzael)         | [Twitter/@4rzael](http://twitter.com/4rzael)               |
| Siarhei Buntsevich | [GitHub/scarry1992](https://github.com/scarry1992) |                                                            |
| Daniel Lando    | [GitHub/robertsLando](https://github.com/robertsLando) |                                                           |

<a name="sponsor"></a>

## Sponsor

If you would like to support MQTT.js, please consider sponsoring the author and active maintainers:

- [Matteo Collina](https://github.com/sponsors/mcollina): author of MQTT.js
- [Daniel Lando](https://github.com/sponsors/robertsLando): active maintainer

<a name="license"></a>

## License

MIT
#!/usr/bin/env node

/*
 * Copyright (c) 2015-2015 MQTT.js contributors.
 * Copyright (c) 2011-2014 Adam Rudd.
 *
 * See LICENSE for more information
 */
import path from 'path'
import Commist from 'commist'
import help from 'help-me'
import publish from './pub'
import subscribe from './sub'

// eslint-disable-next-line @typescript-eslint/no-var-requires
const version = require('../../package.json').version

const helpMe = help({
	dir: path.join(__dirname, '../../', 'help'),
	ext: '.txt',
})

const commist = Commist()

commist.register('publish', publish)
commist.register('pub', publish)

commist.register('subscribe', subscribe)
commist.register('sub', subscribe)

commist.register('version', () => {
	console.log('MQTT.js version:', version)
})
commist.register('help', helpMe.toStdout)

if (commist.parse(process.argv.slice(2)) !== null) {
	console.log('No such command:', process.argv[2], '\n')
	helpMe.toStdout()
}
#!/usr/bin/env node

import { Writable } from 'readable-stream'
import path from 'path'
import fs from 'fs'
import concat from 'concat-stream'
import help from 'help-me'

import minimist, { ParsedArgs } from 'minimist'
import split2 from 'split2'
import { connect } from '../mqtt'
import { IClientOptions, IClientPublishOptions } from 'src/lib/client'
import { pipeline } from 'stream'

const helpMe = help({
	dir: path.join(__dirname, '../../', 'help'),
})

function send(args: ParsedArgs) {
	const client = connect(args as IClientOptions)
	client.on('connect', () => {
		client.publish(
			args.topic,
			args.message,
			args as IClientPublishOptions,
			(err) => {
				if (err) {
					console.warn(err)
				}
				client.end()
			},
		)
	})
	client.on('error', (err) => {
		console.warn(err)
		client.end()
	})
}

function multisend(args: ParsedArgs) {
	const client = connect(args as IClientOptions)
	const sender = new Writable({
		objectMode: true,
	})
	sender._write = (line, enc, cb) => {
		client.publish(
			args.topic,
			line.trim(),
			args as IClientPublishOptions,
			cb,
		)
	}

	client.on('connect', () => {
		pipeline(process.stdin, split2(), sender, (err) => {
			client.end()
			if (err) {
				throw err
			}
		})
	})
}

export default function start(args: string[]) {
	const parsedArgs = minimist(args, {
		string: [
			'hostname',
			'username',
			'password',
			'key',
			'cert',
			'ca',
			'message',
			'clientId',
			'i',
			'id',
		],
		boolean: ['stdin', 'retain', 'help', 'insecure', 'multiline'],
		alias: {
			port: 'p',
			hostname: ['h', 'host'],
			topic: 't',
			message: 'm',
			qos: 'q',
			clientId: ['i', 'id'],
			retain: 'r',
			username: 'u',
			password: 'P',
			stdin: 's',
			multiline: 'M',
			protocol: ['C', 'l'],
			help: 'H',
			ca: 'cafile',
		},
		default: {
			host: 'localhost',
			qos: 0,
			retain: false,
			topic: '',
			message: '',
		},
	})

	if (parsedArgs.help) {
		return helpMe.toStdout('publish')
	}

	if (parsedArgs.key) {
		parsedArgs.key = fs.readFileSync(parsedArgs.key)
	}

	if (parsedArgs.cert) {
		parsedArgs.cert = fs.readFileSync(parsedArgs.cert)
	}

	if (parsedArgs.ca) {
		parsedArgs.ca = fs.readFileSync(parsedArgs.ca)
	}

	if (parsedArgs.key && parsedArgs.cert && !parsedArgs.protocol) {
		parsedArgs.protocol = 'mqtts'
	}

	if (parsedArgs.port) {
		if (typeof parsedArgs.port !== 'number') {
			console.warn(
				"# Port: number expected, '%s' was given.",
				typeof parsedArgs.port,
			)
			return
		}
	}

	if (parsedArgs['will-topic']) {
		parsedArgs.will = {}
		parsedArgs.will.topic = parsedArgs['will-topic']
		parsedArgs.will.payload = parsedArgs['will-message']
		parsedArgs.will.qos = parsedArgs['will-qos']
		parsedArgs.will.retain = parsedArgs['will-retain']
	}

	if (parsedArgs.insecure) {
		parsedArgs.rejectUnauthorized = false
	}

	parsedArgs.topic = (parsedArgs.topic || parsedArgs._.shift())?.toString()
	parsedArgs.message = (
		parsedArgs.message || parsedArgs._.shift()
	)?.toString()

	if (!parsedArgs.topic) {
		console.error('missing topic\n')
		return helpMe.toStdout('publish')
	}

	if (parsedArgs.stdin) {
		if (parsedArgs.multiline) {
			multisend(parsedArgs)
		} else {
			process.stdin.pipe(
				concat((data) => {
					parsedArgs.message = data
					send(parsedArgs)
				}),
			)
		}
	} else {
		send(parsedArgs)
	}
}

if (require.main === module) {
	start(process.argv.slice(2))
}
#!/usr/bin/env node

import path from 'path'
import fs from 'fs'
import minimist from 'minimist'
import help from 'help-me'
import { connect } from '../mqtt'
import { IClientOptions } from 'src/lib/client'

const helpMe = help({
	dir: path.join(__dirname, '../../', 'help'),
})

export default function start(args: string[]) {
	const parsedArgs = minimist(args, {
		string: [
			'hostname',
			'username',
			'password',
			'key',
			'cert',
			'ca',
			'clientId',
			'i',
			'id',
		],
		boolean: ['stdin', 'help', 'clean', 'insecure'],
		alias: {
			port: 'p',
			hostname: ['h', 'host'],
			topic: 't',
			qos: 'q',
			clean: 'c',
			keepalive: 'k',
			clientId: ['i', 'id'],
			username: 'u',
			password: 'P',
			protocol: ['C', 'l'],
			verbose: 'v',
			help: '-H',
			ca: 'cafile',
		},
		default: {
			host: 'localhost',
			qos: 0,
			retain: false,
			clean: true,
			keepAlive: 30, // 30 sec
		},
	})

	if (parsedArgs.help) {
		return helpMe.toStdout('subscribe')
	}

	parsedArgs.topic = parsedArgs.topic || parsedArgs._.shift()

	if (!parsedArgs.topic) {
		console.error('missing topic\n')
		return helpMe.toStdout('subscribe')
	}

	if (parsedArgs.key) {
		parsedArgs.key = fs.readFileSync(parsedArgs.key)
	}

	if (parsedArgs.cert) {
		parsedArgs.cert = fs.readFileSync(parsedArgs.cert)
	}

	if (parsedArgs.ca) {
		parsedArgs.ca = fs.readFileSync(parsedArgs.ca)
	}

	if (parsedArgs.key && parsedArgs.cert && !parsedArgs.protocol) {
		parsedArgs.protocol = 'mqtts'
	}

	if (parsedArgs.insecure) {
		parsedArgs.rejectUnauthorized = false
	}

	if (parsedArgs.port) {
		if (typeof parsedArgs.port !== 'number') {
			console.warn(
				"# Port: number expected, '%s' was given.",
				typeof parsedArgs.port,
			)
			return
		}
	}

	if (parsedArgs['will-topic']) {
		parsedArgs.will = {}
		parsedArgs.will.topic = parsedArgs['will-topic']
		parsedArgs.will.payload = parsedArgs['will-message']
		parsedArgs.will.qos = parsedArgs['will-qos']
		parsedArgs.will.retain = parsedArgs['will-retain']
	}

	parsedArgs.keepAlive = parsedArgs['keep-alive']

	const client = connect(parsedArgs as IClientOptions)

	client.on('connect', () => {
		client.subscribe(
			parsedArgs.topic,
			{ qos: parsedArgs.qos },
			(err, result) => {
				if (err) {
					console.error(err)
					process.exit(1)
				}

				result.forEach((sub) => {
					if (sub.qos > 2) {
						console.error(
							'subscription negated to',
							sub.topic,
							'with code',
							sub.qos,
						)
						process.exit(1)
					}
				})
			},
		)
	})

	client.on('message', (topic, payload) => {
		if (parsedArgs.verbose) {
			console.log(topic, payload.toString())
		} else {
			console.log(payload.toString())
		}
	})

	client.on('error', (err) => {
		console.warn(err)
		client.end()
	})
}

if (require.main === module) {
	start(process.argv.slice(2))
}
/**
 * Module dependencies
 */
import TopicAliasRecv from './topic-alias-recv'
import mqttPacket, {
	IAuthPacket,
	IConnackPacket,
	IDisconnectPacket,
	IPublishPacket,
	ISubscribePacket,
	ISubscription,
	IUnsubscribePacket,
	Packet,
	QoS,
	ISubackPacket,
	IConnectPacket,
} from 'mqtt-packet'
import DefaultMessageIdProvider, {
	IMessageIdProvider,
} from './default-message-id-provider'
import { DuplexOptions, Writable } from 'readable-stream'
import reInterval from 'reinterval'
import clone from 'rfdc/default'
import * as validations from './validations'
import _debug from 'debug'
import Store, { IStore } from './store'
import handlePacket from './handlers'
import { ClientOptions } from 'ws'
import { ClientRequestArgs } from 'http'
import {
	DoneCallback,
	ErrorWithReasonCode,
	GenericCallback,
	IStream,
	StreamBuilder,
	VoidCallback,
} from './shared'
import TopicAliasSend from './topic-alias-send'
import { TypedEventEmitter } from './TypedEmitter'

const nextTick = process
	? process.nextTick
	: (callback: () => void) => {
			setTimeout(callback, 0)
	  }

const setImmediate =
	global.setImmediate ||
	((...args: any[]) => {
		const callback = args.shift()
		nextTick(() => {
			callback(...args)
		})
	})

const defaultConnectOptions = {
	keepalive: 60,
	reschedulePings: true,
	protocolId: 'MQTT',
	protocolVersion: 4,
	reconnectPeriod: 1000,
	connectTimeout: 30 * 1000,
	clean: true,
	resubscribe: true,
	writeCache: true,
}

const socketErrors = [
	'ECONNREFUSED',
	'EADDRINUSE',
	'ECONNRESET',
	'ENOTFOUND',
	'ETIMEDOUT',
]

export type MqttProtocol =
	| 'wss'
	| 'ws'
	| 'mqtt'
	| 'mqtts'
	| 'tcp'
	| 'ssl'
	| 'wx'
	| 'wxs'
	| 'ali'
	| 'alis'

export type StorePutCallback = () => void

export interface ISecureClientOptions {
	/**
	 * optional private keys in PEM format
	 */
	key?: string | string[] | Buffer | Buffer[] | any[]
	keyPath?: string
	/**
	 * optional cert chains in PEM format
	 */
	cert?: string | string[] | Buffer | Buffer[]
	certPath?: string
	/**
	 * Optionally override the trusted CA certificates in PEM format
	 */
	ca?: string | string[] | Buffer | Buffer[]
	caPaths?: string | string[]

	rejectUnauthorized?: boolean
	/**
	 * optional alpn's
	 */
	ALPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array
}

export type AckHandler = (
	topic: string,
	message: Buffer,
	packet: any,
	cb: (error: Error | number, code?: number) => void,
) => void

export interface IClientOptions extends ISecureClientOptions {
	/** CLIENT PROPERTIES */

	/** Encoding to use. Example 'binary' */
	encoding?: BufferEncoding
	/** Set browser buffer size. Default to 512KB */
	browserBufferSize?: number
	/** used in ws protocol to set `objectMode` */
	binary?: boolean
	/** Used on ali protocol */
	my?: any
	/** Manually call `connect` after creating client instance */
	manualConnect?: boolean
	/** Custom auth packet properties */
	authPacket?: Partial<IAuthPacket>
	/** Disable/Enable writeToStream.cacheNumbers */
	writeCache?: boolean
	/** Should be set to `host` */
	servername?: string
	/** The default protocol to use when using `servers` and no protocol is specified */
	defaultProtocol?: MqttProtocol
	/** Support clientId passed in the query string of the url */
	query?: Record<string, string>
	/** Auth string in the format <username>:<password> */
	auth?: string
	/** Custom ack handler */
	customHandleAcks?: AckHandler
	/** Broker port */
	port?: number
	/** Broker host. Does NOT include port */
	host?: string
	/** @deprecated use `host instead */
	hostname?: string
	/** Websocket `path` added as suffix */
	path?: string
	/** The `MqttProtocol` to use */
	protocol?: MqttProtocol

	/** Websocket options */
	wsOptions?: ClientOptions | ClientRequestArgs | DuplexOptions

	/**
	 * 1000 milliseconds, interval between two reconnections
	 */
	reconnectPeriod?: number
	/**
	 * 30 * 1000 milliseconds, time to wait before a CONNACK is received
	 */
	connectTimeout?: number

	/**
	 * a Store for the incoming packets
	 */
	incomingStore?: IStore
	/**
	 * a Store for the outgoing packets
	 */
	outgoingStore?: IStore

	/** Enable/Disable queue for QoS 0 packets */
	queueQoSZero?: boolean

	/** Custom log function, default uses `debug` */
	log?: (...args: any[]) => void

	/** automatically use topic alias */
	autoUseTopicAlias?: boolean

	/** automatically assign topic alias */
	autoAssignTopicAlias?: boolean

	/** Set to false to disable ping reschedule. When enabled ping messages are rescheduled on each message sent */
	reschedulePings?: boolean

	/** List of broker servers. On each reconnect try the next server will be used */
	servers?: Array<{
		host: string
		port: number
		protocol?:
			| 'wss'
			| 'ws'
			| 'mqtt'
			| 'mqtts'
			| 'tcp'
			| 'ssl'
			| 'wx'
			| 'wxs'
	}>
	/**
	 * true, set to false to disable re-subscribe functionality
	 */
	resubscribe?: boolean

	/** when defined this function will be called to transform the url string generated by MqttClient from provided options */
	transformWsUrl?: (
		url: string,
		options: IClientOptions,
		client: MqttClient,
	) => string

	/** when defined this function will be called to create the Websocket instance, used to add custom protocols or websocket implementations */
	createWebsocket?: (
		url: string,
		websocketSubProtocols: string[],
		options: IClientOptions,
	) => any

	/** Custom message id provider */
	messageIdProvider?: IMessageIdProvider

	/** When using websockets, this is the timeout used when writing to socket. Default 1000 (1s) */
	browserBufferTimeout?: number

	/**
	 * When using websockets, this sets the `objectMode` option.
	 * When in objectMode, streams can push Strings and Buffers
	 * as well as any other JavaScript object.
	 * Another major difference is that when in objectMode,
	 * the internal buffering algorithm counts objects rather than bytes.
	 * This means if we have a Transform stream with the highWaterMark option set to 5,
	 * the stream will only buffer a maximum of 5 objects internally
	 */
	objectMode?: boolean

	/** CONNECT PACKET PROPERTIES */

	/**
	 * 'mqttjs_' + Math.random().toString(16).substr(2, 8)
	 */
	clientId?: string
	/**
	 * 3=MQTT 3.1 4=MQTT 3.1.1 5=MQTT 5.0. Defaults to 4
	 */
	protocolVersion?: IConnectPacket['protocolVersion']
	/**
	 * 'MQTT'
	 */
	protocolId?: IConnectPacket['protocolId']
	/**
	 * true, set to false to receive QoS 1 and 2 messages while offline
	 */
	clean?: boolean
	/**
	 *  10 seconds, set to 0 to disable
	 */
	keepalive?: number
	/**
	 * the username required by your broker, if any
	 */
	username?: string
	/**
	 * the password required by your broker, if any
	 */
	password?: Buffer | string
	/**
	 * a message that will sent by the broker automatically when the client disconnect badly.
	 */
	will?: IConnectPacket['will']
	/** see `connect` packet: https://github.com/mqttjs/mqtt-packet/blob/master/types/index.d.ts#L65 */
	properties?: IConnectPacket['properties']
}

export interface IClientPublishOptions {
	/**
	 * the QoS
	 */
	qos?: QoS
	/**
	 * the retain flag
	 */
	retain?: boolean
	/**
	 * whether or not mark a message as duplicate
	 */
	dup?: boolean
	/*
	 *  MQTT 5.0 properties object
	 */
	properties?: IPublishPacket['properties']
	/**
	 * callback called when message is put into `outgoingStore`
	 */
	cbStorePut?: StorePutCallback
}

export interface IClientReconnectOptions {
	/**
	 * a Store for the incoming packets
	 */
	incomingStore?: Store
	/**
	 * a Store for the outgoing packets
	 */
	outgoingStore?: Store
}
export interface IClientSubscribeProperties {
	/*
	 *  MQTT 5.0 properies object of subscribe
	 * */
	properties?: ISubscribePacket['properties']
}

export interface IClientSubscribeOptions extends IClientSubscribeProperties {
	/**
	 * the QoS
	 */
	qos: QoS
	/*
	 * no local flag
	 * */
	nl?: boolean
	/*
	 * Retain As Published flag
	 * */
	rap?: boolean
	/*
	 * Retain Handling option
	 * */
	rh?: number
}
export interface ISubscriptionRequest extends IClientSubscribeOptions {
	/**
	 *  is a subscribed to topic
	 */
	topic: string
}

export interface ISubscriptionGrant
	extends Omit<ISubscriptionRequest, 'qos' | 'properties'> {
	/**
	 *  is the granted qos level on it, may return 128 on error
	 */
	qos: QoS | 128
}

export type ISubscriptionMap = {
	/**
	 * object which has topic names as object keys and as value the options, like {'test1': {qos: 0}, 'test2': {qos: 2}}.
	 */
	[topic: string]: IClientSubscribeOptions
} & {
	resubscribe?: boolean
}

export { IConnackPacket, IDisconnectPacket, IPublishPacket, Packet }
export type OnConnectCallback = (packet: IConnackPacket) => void
export type OnDisconnectCallback = (packet: IDisconnectPacket) => void
export type ClientSubscribeCallback = (
	err: Error | null,
	granted: ISubscriptionGrant[],
) => void
export type OnMessageCallback = (
	topic: string,
	payload: Buffer,
	packet: IPublishPacket,
) => void
export type OnPacketCallback = (packet: Packet) => void
export type OnCloseCallback = () => void
export type OnErrorCallback = (error: Error | ErrorWithReasonCode) => void
export type PacketCallback = (error?: Error, packet?: Packet) => any
export type CloseCallback = (error?: Error) => void

export interface MqttClientEventCallbacks {
	connect: OnConnectCallback
	message: OnMessageCallback
	packetsend: OnPacketCallback
	packetreceive: OnPacketCallback
	disconnect: OnDisconnectCallback
	error: OnErrorCallback
	close: OnCloseCallback
	end: VoidCallback
	reconnect: VoidCallback
	offline: VoidCallback
	outgoingEmpty: VoidCallback
}

/**
 * MqttClient constructor
 *
 * @param {Stream} stream - stream
 * @param {Object} [options] - connection options
 * (see Connection#connect)
 */
export default class MqttClient extends TypedEventEmitter<MqttClientEventCallbacks> {
	/** Public fields */

	/** It's true when client is connected to broker */
	public connected: boolean

	public disconnecting: boolean

	public disconnected: boolean

	public reconnecting: boolean

	public incomingStore: IStore

	public outgoingStore: IStore

	public options: IClientOptions

	public queueQoSZero: boolean

	public _reconnectCount: number

	public log: (...args: any[]) => void

	public messageIdProvider: IMessageIdProvider

	public pingResp: boolean

	public outgoing: Record<
		number,
		{ volatile: boolean; cb: (err: Error, packet?: Packet) => void }
	>

	public messageIdToTopic: Record<number, string[]>

	public noop: (error?: any) => void

	public pingTimer: any

	public stream: IStream

	public queue: { packet: Packet; cb: PacketCallback }[]

	/* Private fields */

	/** Function used to build the stream */
	private streamBuilder: StreamBuilder

	private _resubscribeTopics: ISubscriptionMap

	private connackTimer: NodeJS.Timeout

	private reconnectTimer: NodeJS.Timeout

	private _storeProcessing: boolean

	/** keep a reference of packets that have been successfully processed from outgoing store  */
	private _packetIdsDuringStoreProcessing: Record<number, boolean>

	private _storeProcessingQueue: {
		invoke: () => any
		cbStorePut?: DoneCallback
		callback: GenericCallback<any>
	}[]

	private _firstConnection: boolean

	private topicAliasRecv: TopicAliasRecv

	private topicAliasSend: TopicAliasSend

	private _deferredReconnect: () => void

	private connackPacket: IConnackPacket

	public static defaultId() {
		return `mqttjs_${Math.random().toString(16).substr(2, 8)}`
	}

	constructor(streamBuilder: StreamBuilder, options: IClientOptions) {
		super()

		this.options = options || {}

		// Defaults
		for (const k in defaultConnectOptions) {
			if (typeof this.options[k] === 'undefined') {
				this.options[k] = defaultConnectOptions[k]
			} else {
				this.options[k] = options[k]
			}
		}

		this.log = this.options.log || _debug('mqttjs:client')
		this.noop = this._noop.bind(this)

		this.log('MqttClient :: options.protocol', options.protocol)
		this.log(
			'MqttClient :: options.protocolVersion',
			options.protocolVersion,
		)
		this.log('MqttClient :: options.username', options.username)
		this.log('MqttClient :: options.keepalive', options.keepalive)
		this.log(
			'MqttClient :: options.reconnectPeriod',
			options.reconnectPeriod,
		)
		this.log(
			'MqttClient :: options.rejectUnauthorized',
			options.rejectUnauthorized,
		)
		this.log(
			'MqttClient :: options.properties.topicAliasMaximum',
			options.properties
				? options.properties.topicAliasMaximum
				: undefined,
		)

		this.options.clientId =
			typeof options.clientId === 'string'
				? options.clientId
				: MqttClient.defaultId()

		this.log('MqttClient :: clientId', this.options.clientId)

		this.options.customHandleAcks =
			options.protocolVersion === 5 && options.customHandleAcks
				? options.customHandleAcks
				: (...args) => {
						args[3](null, 0)
				  }

		// Disable pre-generated write cache if requested. Will allocate buffers on-the-fly instead. WARNING: This can affect write performance
		if (!this.options.writeCache) {
			mqttPacket.writeToStream.cacheNumbers = false
		}

		this.streamBuilder = streamBuilder

		this.messageIdProvider =
			typeof this.options.messageIdProvider === 'undefined'
				? new DefaultMessageIdProvider()
				: this.options.messageIdProvider

		// Inflight message storages
		this.outgoingStore = options.outgoingStore || new Store()
		this.incomingStore = options.incomingStore || new Store()

		// Should QoS zero messages be queued when the connection is broken?
		this.queueQoSZero =
			options.queueQoSZero === undefined ? true : options.queueQoSZero

		// map of subscribed topics to support reconnection
		this._resubscribeTopics = {}

		// map of a subscribe messageId and a topic
		this.messageIdToTopic = {}

		// Ping timer, setup in _setupPingTimer
		this.pingTimer = null
		// Is the client connected?
		this.connected = false
		// Are we disconnecting?
		this.disconnecting = false
		// Are we reconnecting?
		this.reconnecting = false
		// Packet queue
		this.queue = []
		// connack timer
		this.connackTimer = null
		// Reconnect timer
		this.reconnectTimer = null
		// Is processing store?
		this._storeProcessing = false
		// Packet Ids are put into the store during store processing
		this._packetIdsDuringStoreProcessing = {}
		// Store processing queue
		this._storeProcessingQueue = []

		// Inflight callbacks
		this.outgoing = {}

		// True if connection is first time.
		this._firstConnection = true

		if (options.properties && options.properties.topicAliasMaximum > 0) {
			if (options.properties.topicAliasMaximum > 0xffff) {
				this.log(
					'MqttClient :: options.properties.topicAliasMaximum is out of range',
				)
			} else {
				this.topicAliasRecv = new TopicAliasRecv(
					options.properties.topicAliasMaximum,
				)
			}
		}

		// Send queued packets
		this.on('connect', () => {
			const { queue } = this

			const deliver = () => {
				const entry = queue.shift()
				this.log('deliver :: entry %o', entry)
				let packet = null

				if (!entry) {
					this._resubscribe()
					return
				}

				packet = entry.packet
				this.log('deliver :: call _sendPacket for %o', packet)
				let send = true
				if (packet.messageId && packet.messageId !== 0) {
					if (!this.messageIdProvider.register(packet.messageId)) {
						send = false
					}
				}
				if (send) {
					this._sendPacket(packet, (err) => {
						if (entry.cb) {
							entry.cb(err)
						}
						deliver()
					})
				} else {
					this.log(
						'messageId: %d has already used. The message is skipped and removed.',
						packet.messageId,
					)
					deliver()
				}
			}

			this.log('connect :: sending queued packets')
			deliver()
		})

		this.on('close', () => {
			this.log('close :: connected set to `false`')
			this.connected = false

			this.log('close :: clearing connackTimer')
			clearTimeout(this.connackTimer)

			this.log('close :: clearing ping timer')
			if (this.pingTimer !== null) {
				this.pingTimer.clear()
				this.pingTimer = null
			}

			if (this.topicAliasRecv) {
				this.topicAliasRecv.clear()
			}

			this.log('close :: calling _setupReconnect')
			this._setupReconnect()
		})

		if (!this.options.manualConnect) {
			this.log('MqttClient :: setting up stream')
			this.connect()
		}
	}

	/**
	 * @param packet the packet received by the broker
	 * @return the auth packet to be returned to the broker
	 * @api public
	 */
	public handleAuth(packet: IAuthPacket, callback: PacketCallback) {
		callback()
	}

	/**
	 * Handle messages with backpressure support, one at a time.
	 * Override at will.
	 *
	 * @param Packet packet the packet
	 * @param Function callback call when finished
	 * @api public
	 */
	public handleMessage(packet: IPublishPacket, callback: DoneCallback) {
		callback()
	}

	/**
	 * _nextId
	 * @return unsigned int
	 */
	private _nextId() {
		return this.messageIdProvider.allocate()
	}

	/**
	 * getLastMessageId
	 * @return unsigned int
	 */
	public getLastMessageId() {
		return this.messageIdProvider.getLastAllocated()
	}

	/**
	 * Setup the event handlers in the inner stream, sends `connect` and `auth` packets
	 */
	public connect() {
		const writable = new Writable()
		const parser = mqttPacket.parser(this.options)
		let completeParse = null
		const packets = []

		this.log('connect :: calling method to clear reconnect')
		this._clearReconnect()

		this.log(
			'connect :: using streamBuilder provided to client to create stream',
		)
		this.stream = this.streamBuilder(this)

		parser.on('packet', (packet) => {
			this.log('parser :: on packet push to packets array.')
			packets.push(packet)
		})

		const work = () => {
			this.log('work :: getting next packet in queue')
			const packet = packets.shift()

			if (packet) {
				this.log('work :: packet pulled from queue')
				handlePacket(this, packet, nextTickWork)
			} else {
				this.log('work :: no packets in queue')
				const done = completeParse
				completeParse = null
				this.log('work :: done flag is %s', !!done)
				if (done) done()
			}
		}

		const nextTickWork = () => {
			if (packets.length) {
				nextTick(work)
			} else {
				const done = completeParse
				completeParse = null
				done()
			}
		}

		writable._write = (buf, enc, done) => {
			completeParse = done
			this.log('writable stream :: parsing buffer')
			parser.parse(buf)
			work()
		}

		const streamErrorHandler = (error) => {
			this.log('streamErrorHandler :: error', error.message)
			if (socketErrors.includes(error.code)) {
				// handle error
				this.log('streamErrorHandler :: emitting error')
				this.emit('error', error)
			} else {
				this.noop(error)
			}
		}

		this.log('connect :: pipe stream to writable stream')
		this.stream.pipe(writable)

		// Suppress connection errors
		this.stream.on('error', streamErrorHandler)

		// Echo stream close
		this.stream.on('close', () => {
			this.log('(%s)stream :: on close', this.options.clientId)
			this._flushVolatile()
			this.log('stream: emit close to MqttClient')
			this.emit('close')
		})

		// Send a connect packet
		this.log('connect: sending packet `connect`')

		const connectPacket: IConnectPacket = {
			cmd: 'connect',
			protocolId: this.options.protocolId,
			protocolVersion: this.options.protocolVersion,
			clean: this.options.clean,
			clientId: this.options.clientId,
			keepalive: this.options.keepalive,
			username: this.options.username,
			password: this.options.password as Buffer,
			properties: this.options.properties,
		}

		if (this.options.will) {
			connectPacket.will = {
				...this.options.will,
				payload: this.options.will?.payload as Buffer,
			}
		}

		if (this.topicAliasRecv) {
			if (!connectPacket.properties) {
				connectPacket.properties = {}
			}
			if (this.topicAliasRecv) {
				connectPacket.properties.topicAliasMaximum =
					this.topicAliasRecv.max
			}
		}
		// avoid message queue
		this._writePacket(connectPacket)

		// Echo connection errors
		parser.on('error', this.emit.bind(this, 'error'))

		// auth
		if (this.options.properties) {
			if (
				!this.options.properties.authenticationMethod &&
				this.options.properties.authenticationData
			) {
				this.end(() =>
					this.emit(
						'error',
						new Error('Packet has no Authentication Method'),
					),
				)
				return this
			}
			if (
				this.options.properties.authenticationMethod &&
				this.options.authPacket &&
				typeof this.options.authPacket === 'object'
			) {
				const authPacket: IAuthPacket = {
					cmd: 'auth',
					reasonCode: 0,
					...this.options.authPacket,
				}
				this._writePacket(authPacket)
			}
		}

		// many drain listeners are needed for qos 1 callbacks if the connection is intermittent
		this.stream.setMaxListeners(1000)

		clearTimeout(this.connackTimer)
		this.connackTimer = setTimeout(() => {
			this.log(
				'!!connectTimeout hit!! Calling _cleanUp with force `true`',
			)
			this._cleanUp(true)
		}, this.options.connectTimeout)

		return this
	}

	/**
	 * publish - publish <message> to <topic>
	 *
	 * @param {String} topic - topic to publish to
	 * @param {String, Buffer} message - message to publish
	 * @param {Object} [opts] - publish options, includes:
	 *    {Number} qos - qos level to publish on
	 *    {Boolean} retain - whether or not to retain the message
	 *    {Boolean} dup - whether or not mark a message as duplicate
	 *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`
	 * @param {Function} [callback] - function(err){}
	 *    called when publish succeeds or fails
	 * @returns {MqttClient} this - for chaining
	 * @api public
	 *
	 * @example client.publish('topic', 'message');
	 * @example
	 *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});
	 * @example client.publish('topic', 'message', console.log);
	 */
	public publish(topic: string, message: string | Buffer): MqttClient
	public publish(
		topic: string,
		message: string | Buffer,
		callback?: PacketCallback,
	): MqttClient
	public publish(
		topic: string,
		message: string | Buffer,
		opts?: IClientPublishOptions,
		callback?: PacketCallback,
	): MqttClient
	public publish(
		topic: string,
		message: string | Buffer,
		opts?: IClientPublishOptions | DoneCallback,
		callback?: PacketCallback,
	): MqttClient {
		this.log('publish :: message `%s` to topic `%s`', message, topic)
		const { options } = this

		// .publish(topic, payload, cb);
		if (typeof opts === 'function') {
			callback = opts as DoneCallback
			opts = null
		}

		opts = opts || {}

		// default opts
		const defaultOpts: IClientPublishOptions = {
			qos: 0,
			retain: false,
			dup: false,
		}
		opts = { ...defaultOpts, ...opts }

		const { qos, retain, dup, properties, cbStorePut } = opts

		if (this._checkDisconnecting(callback)) {
			return this
		}

		const publishProc = () => {
			let messageId = 0
			if (qos === 1 || qos === 2) {
				messageId = this._nextId()
				if (messageId === null) {
					this.log('No messageId left')
					return false
				}
			}
			const packet: IPublishPacket = {
				cmd: 'publish',
				topic,
				payload: message,
				qos,
				retain,
				messageId,
				dup,
			}

			if (options.protocolVersion === 5) {
				packet.properties = properties
			}

			this.log('publish :: qos', qos)
			switch (qos) {
				case 1:
				case 2:
					// Add to callbacks
					this.outgoing[packet.messageId] = {
						volatile: false,
						cb: callback || this.noop,
					}
					this.log('MqttClient:publish: packet cmd: %s', packet.cmd)
					this._sendPacket(packet, undefined, cbStorePut)
					break
				default:
					this.log('MqttClient:publish: packet cmd: %s', packet.cmd)
					this._sendPacket(packet, callback, cbStorePut)
					break
			}
			return true
		}

		if (
			this._storeProcessing ||
			this._storeProcessingQueue.length > 0 ||
			!publishProc()
		) {
			this._storeProcessingQueue.push({
				invoke: publishProc,
				cbStorePut: opts.cbStorePut,
				callback,
			})
		}

		return this
	}

	public publishAsync(
		topic: string,
		message: string | Buffer,
	): Promise<Packet | undefined>
	public publishAsync(
		topic: string,
		message: string | Buffer,
		opts?: IClientPublishOptions,
	): Promise<Packet | undefined>
	public publishAsync(
		topic: string,
		message: string | Buffer,
		opts?: IClientPublishOptions,
	): Promise<Packet | undefined> {
		return new Promise((resolve, reject) => {
			this.publish(topic, message, opts, (err, packet) => {
				if (err) {
					reject(err)
				} else {
					resolve(packet)
				}
			})
		})
	}

	/**
	 * subscribe - subscribe to <topic>
	 *
	 * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}
	 * @param {Object} [opts] - optional subscription options, includes:
	 *    {Number} qos - subscribe qos level
	 * @param {Function} [callback] - function(err, granted){} where:
	 *    {Error} err - subscription error (none at the moment!)
	 *    {Array} granted - array of {topic: 't', qos: 0}
	 * @returns {MqttClient} this - for chaining
	 * @api public
	 * @example client.subscribe('topic');
	 * @example client.subscribe('topic', {qos: 1});
	 * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);
	 * @example client.subscribe('topic', console.log);
	 */
	public subscribe(
		topicObject: string | string[] | ISubscriptionMap,
	): MqttClient
	public subscribe(
		topicObject: string | string[] | ISubscriptionMap,
		callback?: ClientSubscribeCallback,
	): MqttClient
	public subscribe(
		topicObject: string | string[] | ISubscriptionMap,
		opts?: IClientSubscribeOptions | IClientSubscribeProperties,
	): MqttClient
	public subscribe(
		topicObject: string | string[] | ISubscriptionMap,
		opts?: IClientSubscribeOptions | IClientSubscribeProperties,
		callback?: ClientSubscribeCallback,
	): MqttClient
	public subscribe(
		topicObject: string | string[] | ISubscriptionMap,
		opts?:
			| IClientSubscribeOptions
			| IClientSubscribeProperties
			| ClientSubscribeCallback,
		callback?: ClientSubscribeCallback,
	): MqttClient {
		const version = this.options.protocolVersion

		if (typeof opts === 'function') {
			callback = opts
		}

		callback = callback || this.noop

		// force re-subscribe on reconnect. This is only true
		// when provided `topicObject` is `this._resubscribeTopics`
		let resubscribe = false
		let topicsList = []

		if (typeof topicObject === 'string') {
			topicObject = [topicObject]
			topicsList = topicObject
		} else if (Array.isArray(topicObject)) {
			topicsList = topicObject
		} else if (typeof topicObject === 'object') {
			resubscribe = topicObject.resubscribe
			delete topicObject.resubscribe
			topicsList = Object.keys(topicObject)
		}

		// validate topics
		const invalidTopic = validations.validateTopics(topicsList)
		if (invalidTopic !== null) {
			setImmediate(callback, new Error(`Invalid topic ${invalidTopic}`))
			return this
		}

		if (this._checkDisconnecting(callback)) {
			this.log('subscribe: discconecting true')
			return this
		}

		const defaultOpts: Partial<IClientSubscribeOptions> = {
			qos: 0,
		}

		if (version === 5) {
			defaultOpts.nl = false
			defaultOpts.rap = false
			defaultOpts.rh = 0
		}
		opts = { ...defaultOpts, ...opts } as IClientSubscribeOptions

		const properties = opts.properties

		const subs: ISubscriptionRequest[] = []

		const parseSub = (
			topic: string,
			subOptions?: IClientSubscribeOptions,
		) => {
			// subOptions is defined only when providing a subs map, use opts otherwise
			subOptions = (subOptions || opts) as IClientSubscribeOptions
			if (
				!Object.prototype.hasOwnProperty.call(
					this._resubscribeTopics,
					topic,
				) ||
				this._resubscribeTopics[topic].qos < subOptions.qos ||
				resubscribe
			) {
				const currentOpts: ISubscription & IClientSubscribeProperties =
					{
						topic,
						qos: subOptions.qos,
					}
				if (version === 5) {
					currentOpts.nl = subOptions.nl
					currentOpts.rap = subOptions.rap
					currentOpts.rh = subOptions.rh
					// use opts.properties
					currentOpts.properties = properties
				}
				this.log(
					'subscribe: pushing topic `%s` and qos `%s` to subs list',
					currentOpts.topic,
					currentOpts.qos,
				)
				subs.push(currentOpts)
			}
		}

		if (Array.isArray(topicObject)) {
			// array of topics
			topicObject.forEach((topic) => {
				this.log('subscribe: array topic %s', topic)
				parseSub(topic)
			})
		} else {
			// object topic --> subOptions (no properties)
			Object.keys(topicObject).forEach((topic) => {
				this.log(
					'subscribe: object topic %s, %o',
					topic,
					topicObject[topic],
				)
				parseSub(topic, topicObject[topic])
			})
		}

		if (!subs.length) {
			callback(null, [])
			return this
		}

		const subscribeProc = () => {
			const messageId = this._nextId()
			if (messageId === null) {
				this.log('No messageId left')
				return false
			}

			const packet: ISubscribePacket = {
				cmd: 'subscribe',
				subscriptions: subs,
				// qos: 1,
				// retain: false,
				// dup: false,
				messageId,
			}

			if (properties) {
				packet.properties = properties
			}

			// subscriptions to resubscribe to in case of disconnect
			if (this.options.resubscribe) {
				this.log('subscribe :: resubscribe true')
				const topics = []
				subs.forEach((sub) => {
					if (this.options.reconnectPeriod > 0) {
						const topic: IClientSubscribeOptions = { qos: sub.qos }
						if (version === 5) {
							topic.nl = sub.nl || false
							topic.rap = sub.rap || false
							topic.rh = sub.rh || 0
							topic.properties = sub.properties
						}
						this._resubscribeTopics[sub.topic] = topic
						topics.push(sub.topic)
					}
				})
				this.messageIdToTopic[packet.messageId] = topics
			}

			this.outgoing[packet.messageId] = {
				volatile: true,
				cb(err, packet2: ISubackPacket) {
					if (!err) {
						const { granted } = packet2
						for (let i = 0; i < granted.length; i += 1) {
							subs[i].qos = granted[i] as QoS
						}
					}

					callback(err, subs)
				},
			}
			this.log('subscribe :: call _sendPacket')
			this._sendPacket(packet)
			return true
		}

		if (
			this._storeProcessing ||
			this._storeProcessingQueue.length > 0 ||
			!subscribeProc()
		) {
			this._storeProcessingQueue.push({
				invoke: subscribeProc,
				callback,
			})
		}

		return this
	}

	public subscribeAsync(
		topicObject: string | string[] | ISubscriptionMap,
	): Promise<ISubscriptionGrant[]>
	public subscribeAsync(
		topicObject: string | string[] | ISubscriptionMap,
		opts?: IClientSubscribeOptions | IClientSubscribeProperties,
	): Promise<ISubscriptionGrant[]>
	public subscribeAsync(
		topicObject: string | string[] | ISubscriptionMap,
		opts?: IClientSubscribeOptions | IClientSubscribeProperties,
	): Promise<ISubscriptionGrant[]> {
		return new Promise((resolve, reject) => {
			this.subscribe(topicObject, opts, (err, granted) => {
				if (err) {
					reject(err)
				} else {
					resolve(granted)
				}
			})
		})
	}

	/**
	 * unsubscribe - unsubscribe from topic(s)
	 *
	 * @param {String, Array} topic - topics to unsubscribe from
	 * @param {Object} [opts] - optional subscription options, includes:
	 *    {Object} properties - properties of unsubscribe packet
	 *