{
    if (!supports_1.supportsNativeFetch()) {
        return;
    }
    object_1.fill(global, 'fetch', function (originalFetch) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var handlerData = {
                args: args,
                fetchData: {
                    method: getFetchMethod(args),
                    url: getFetchUrl(args),
                },
                startTimestamp: Date.now(),
            };
            triggerHandlers('fetch', tslib_1.__assign({}, handlerData));
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            return originalFetch.apply(global, args).then(function (response) {
                triggerHandlers('fetch', tslib_1.__assign(tslib_1.__assign({}, handlerData), { endTimestamp: Date.now(), response: response }));
                return response;
            }, function (error) {
                triggerHandlers('fetch', tslib_1.__assign(tslib_1.__assign({}, handlerData), { endTimestamp: Date.now(), error: error }));
                // NOTE: If you are a Sentry user, and you are seeing this stack frame,
                //       it means the sentry.javascript SDK caught an error invoking your application code.
                //       This is expected behavior and NOT indicative of a bug with sentry.javascript.
                throw error;
            });
        };
    });
}
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/** Extract `method` from fetch call arguments */
function getFetchMethod(fetchArgs) {
    if (fetchArgs === void 0) { fetchArgs = []; }
    if ('Request' in global && is_1.isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {
        return String(fetchArgs[0].method).toUpperCase();
    }
    if (fetchArgs[1] && fetchArgs[1].method) {
        return String(fetchArgs[1].method).toUpperCase();
    }
    return 'GET';
}
/** Extract `url` from fetch call arguments */
function getFetchUrl(fetchArgs) {
    if (fetchArgs === void 0) { fetchArgs = []; }
    if (typeof fetchArgs[0] === 'string') {
        return fetchArgs[0];
    }
    if ('Request' in global && is_1.isInstanceOf(fetchArgs[0], Request)) {
        return fetchArgs[0].url;
    }
    return String(fetchArgs[0]);
}
/* eslint-enable @typescript-eslint/no-unsafe-member-access */
/** JSDoc */
function instrumentXHR() {
    if (!('XMLHttpRequest' in global)) {
        return;
    }
    var xhrproto = XMLHttpRequest.prototype;
    object_1.fill(xhrproto, 'open', function (originalOpen) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            var xhr = this;
            var url = args[1];
            var xhrInfo = (xhr.__sentry_xhr__ = {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                method: is_1.isString(args[0]) ? args[0].toUpperCase() : args[0],
                url: args[1],
            });
            // if Sentry key appears in URL, don't capture it as a request
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            if (is_1.isString(url) && xhrInfo.method === 'POST' && url.match(/sentry_key/)) {
                xhr.__sentry_own_request__ = true;
            }
            var onreadystatechangeHandler = function () {
                if (xhr.readyState === 4) {
                    try {
                        // touching statusCode in some platforms throws
                        // an exception
                        xhrInfo.status_code = xhr.status;
                    }
                    catch (e) {
                        /* do nothing */
                    }
                    triggerHandlers('xhr', {
                        args: args,
                        endTimestamp: Date.now(),
                        startTimestamp: Date.now(),
                        xhr: xhr,
                    });
                }
            };
            if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {
                object_1.fill(xhr, 'onreadystatechange', function (original) {
                    return function () {
                        var readyStateArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            readyStateArgs[_i] = arguments[_i];
                        }
                        onreadystatechangeHandler();
                        return original.apply(xhr, readyStateArgs);
                    };
                });
            }
            else {
                xhr.addEventListener('readystatechange', onreadystatechangeHandler);
            }
            return originalOpen.apply(xhr, args);
        };
    });
    object_1.fill(xhrproto, 'send', function (originalSend) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (this.__sentry_xhr__ && args[0] !== undefined) {
                this.__sentry_xhr__.body = args[0];
            }
            triggerHandlers('xhr', {
                args: args,
                startTimestamp: Date.now(),
                xhr: this,
            });
            return originalSend.apply(this, args);
        };
    });
}
var lastHref;
/** JSDoc */
function instrumentHistory() {
    if (!supports_1.supportsHistory()) {
        return;
    }
    var oldOnPopState = global.onpopstate;
    global.onpopstate = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var to = global.location.href;
        // keep track of the current URL state, as we always receive only the updated state
        var from = lastHref;
        lastHref = to;
        triggerHandlers('history', {
            from: from,
            to: to,
        });
        if (oldOnPopState) {
            // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.
            // https://github.com/getsentry/sentry-javascript/issues/3344
            // https://github.com/bugsnag/bugsnag-js/issues/469
            try {
                return oldOnPopState.apply(this, args);
            }
            catch (_oO) {
                // no-empty
            }
        }
    };
    /** @hidden */
    function historyReplacementFunction(originalHistoryFunction) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var url = args.length > 2 ? args[2] : undefined;
            if (url) {
                // coerce to string (this is what pushState does)
                var from = lastHref;
                var to = String(url);
                // keep track of the current URL state, as we always receive only the updated state
                lastHref = to;
                triggerHandlers('history', {
                    from: from,
                    to: to,
                });
            }
            return originalHistoryFunction.apply(this, args);
        };
    }
    object_1.fill(global.history, 'pushState', historyReplacementFunction);
    object_1.fill(global.history, 'replaceState', historyReplacementFunction);
}
var debounceDuration = 1000;
var debounceTimerID;
var lastCapturedEvent;
/**
 * Decide whether the current event should finish the debounce of previously captured one.
 * @param previous previously captured event
 * @param current event to be captured
 */
function shouldShortcircuitPreviousDebounce(previous, current) {
    // If there was no previous event, it should always be swapped for the new one.
    if (!previous) {
        return true;
    }
    // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.
    if (previous.type !== current.type) {
        return true;
    }
    try {
        // If both events have the same type, it's still possible that actions were performed on different targets.
        // e.g. 2 clicks on different buttons.
        if (previous.target !== current.target) {
            return true;
        }
    }
    catch (e) {
        // just accessing `target` property can throw an exception in some rare circumstances
        // see: https://github.com/getsentry/sentry-javascript/issues/838
    }
    // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_
    // to which an event listener was attached), we treat them as the same action, as we want to capture
    // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.
    return false;
}
/**
 * Decide whether an event should be captured.
 * @param event event to be captured
 */
function shouldSkipDOMEvent(event) {
    // We are only interested in filtering `keypress` events for now.
    if (event.type !== 'keypress') {
        return false;
    }
    try {
        var target = event.target;
        if (!target || !target.tagName) {
            return true;
        }
        // Only consider keypress events on actual input elements. This will disregard keypresses targeting body
        // e.g.tabbing through elements, hotkeys, etc.
        if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
            return false;
        }
    }
    catch (e) {
        // just accessing `target` property can throw an exception in some rare circumstances
        // see: https://github.com/getsentry/sentry-javascript/issues/838
    }
    return true;
}
/**
 * Wraps addEventListener to capture UI breadcrumbs
 * @param handler function that will be triggered
 * @param globalListener indicates whether event was captured by the global event listener
 * @returns wrapped breadcrumb events handler
 * @hidden
 */
function makeDOMEventHandler(handler, globalListener) {
    if (globalListener === void 0) { globalListener = false; }
    return function (event) {
        // It's possible this handler might trigger multiple times for the same
        // event (e.g. event propagation through node ancestors).
        // Ignore if we've already captured that event.
        if (!event || lastCapturedEvent === event) {
            return;
        }
        // We always want to skip _some_ events.
        if (shouldSkipDOMEvent(event)) {
            return;
        }
        var name = event.type === 'keypress' ? 'input' : event.type;
        // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.
        if (debounceTimerID === undefined) {
            handler({
                event: event,
                name: name,
                global: globalListener,
            });
            lastCapturedEvent = event;
        }
        // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.
        // If that's the case, emit the previous event and store locally the newly-captured DOM event.
        else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {
            handler({
                event: event,
                name: name,
                global: globalListener,
            });
            lastCapturedEvent = event;
        }
        // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.
        clearTimeout(debounceTimerID);
        debounceTimerID = global.setTimeout(function () {
            debounceTimerID = undefined;
        }, debounceDuration);
    };
}
/** JSDoc */
function instrumentDOM() {
    if (!('document' in global)) {
        return;
    }
    // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom
    // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before
    // we instrument `addEventListener` so that we don't end up attaching this handler twice.
    var triggerDOMHandler = triggerHandlers.bind(null, 'dom');
    var globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
    global.document.addEventListener('click', globalDOMEventHandler, false);
    global.document.addEventListener('keypress', globalDOMEventHandler, false);
    // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled
    // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That
    // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler
    // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still
    // guaranteed to fire at least once.)
    ['EventTarget', 'Node'].forEach(function (target) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        var proto = global[target] && global[target].prototype;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins
        if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {
            return;
        }
        object_1.fill(proto, 'addEventListener', function (originalAddEventListener) {
            return function (type, listener, options) {
                if (type === 'click' || type == 'keypress') {
                    try {
                        var el = this;
                        var handlers_1 = (el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {});
                        var handlerForType = (handlers_1[type] = handlers_1[type] || { refCount: 0 });
                        if (!handlerForType.handler) {
                            var handler = makeDOMEventHandler(triggerDOMHandler);
                            handlerForType.handler = handler;
                            originalAddEventListener.call(this, type, handler, options);
                        }
                        handlerForType.refCount += 1;
                    }
                    catch (e) {
                        // Accessing dom properties is always fragile.
                        // Also allows us to skip `addEventListenrs` calls with no proper `this` context.
                    }
                }
                return originalAddEventListener.call(this, type, listener, options);
            };
        });
        object_1.fill(proto, 'removeEventListener', function (originalRemoveEventListener) {
            return function (type, listener, options) {
                if (type === 'click' || type == 'keypress') {
                    try {
                        var el = this;
                        var handlers_2 = el.__sentry_instrumentation_handlers__ || {};
                        var handlerForType = handlers_2[type];
                        if (handlerForType) {
                            handlerForType.refCount -= 1;
                            // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.
                            if (handlerForType.refCount <= 0) {
                                originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                                handlerForType.handler = undefined;
                                delete handlers_2[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete
                            }
                            // If there are no longer any custom handlers of any type on this element, cleanup everything.
                            if (Object.keys(handlers_2).length === 0) {
                                delete el.__sentry_instrumentation_handlers__;
                            }
                        }
                    }
                    catch (e) {
                        // Accessing dom properties is always fragile.
                        // Also allows us to skip `addEventListenrs` calls with no proper `this` context.
                    }
                }
                return originalRemoveEventListener.call(this, type, listener, options);
            };
        });
    });
}
var _oldOnErrorHandler = null;
/** JSDoc */
function instrumentError() {
    _oldOnErrorHandler = global.onerror;
    global.onerror = function (msg, url, line, column, error) {
        triggerHandlers('error', {
            column: column,
            error: error,
            line: line,
            msg: msg,
            url: url,
        });
        if (_oldOnErrorHandler) {
            // eslint-disable-next-line prefer-rest-params
            return _oldOnErrorHandler.apply(this, arguments);
        }
        return false;
    };
}
var _oldOnUnhandledRejectionHandler = null;
/** JSDoc */
function instrumentUnhandledRejection() {
    _oldOnUnhandledRejectionHandler = global.onunhandledrejection;
    global.onunhandledrejection = function (e) {
        triggerHandlers('unhandledrejection', e);
        if (_oldOnUnhandledRejectionHandler) {
            // eslint-disable-next-line prefer-rest-params
            return _oldOnUnhandledRejectionHandler.apply(this, arguments);
        }
        return true;
    };
}
//# sourceMappingURL=instrument.js.map{"version":3,"file":"instrument.js","sourceRoot":"","sources":["../../src/instrument.ts"],"names":[],"mappings":";;AAKA,iCAAyC;AACzC,mCAA2C;AAC3C,2BAA8C;AAC9C,mCAAkD;AAClD,mCAAgC;AAChC,2CAA+C;AAC/C,uCAAkE;AAElE,IAAM,MAAM,GAAG,wBAAe,EAAU,CAAC;AAazC;;;;;;;;;GASG;AAEH,IAAM,QAAQ,GAAqE,EAAE,CAAC;AACtF,IAAM,YAAY,GAAiD,EAAE,CAAC;AAEtE,4BAA4B;AAC5B,SAAS,UAAU,CAAC,IAA2B;IAC7C,IAAI,YAAY,CAAC,IAAI,CAAC,EAAE;QACtB,OAAO;KACR;IAED,YAAY,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;IAE1B,QAAQ,IAAI,EAAE;QACZ,KAAK,SAAS;YACZ,iBAAiB,EAAE,CAAC;YACpB,MAAM;QACR,KAAK,KAAK;YACR,aAAa,EAAE,CAAC;YAChB,MAAM;QACR,KAAK,KAAK;YACR,aAAa,EAAE,CAAC;YAChB,MAAM;QACR,KAAK,OAAO;YACV,eAAe,EAAE,CAAC;YAClB,MAAM;QACR,KAAK,SAAS;YACZ,iBAAiB,EAAE,CAAC;YACpB,MAAM;QACR,KAAK,OAAO;YACV,eAAe,EAAE,CAAC;YAClB,MAAM;QACR,KAAK,oBAAoB;YACvB,4BAA4B,EAAE,CAAC;YAC/B,MAAM;QACR;YACE,sBAAc,IAAI,eAAM,CAAC,IAAI,CAAC,+BAA+B,EAAE,IAAI,CAAC,CAAC;YACrE,OAAO;KACV;AACH,CAAC;AAED;;;;GAIG;AACH,SAAgB,yBAAyB,CAAC,IAA2B,EAAE,QAAmC;IACxG,QAAQ,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;IACrC,QAAQ,CAAC,IAAI,CAAiC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC/D,UAAU,CAAC,IAAI,CAAC,CAAC;AACnB,CAAC;AAJD,8DAIC;AAED,YAAY;AACZ,SAAS,eAAe,CAAC,IAA2B,EAAE,IAAS;;IAC7D,IAAI,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;QAC5B,OAAO;KACR;;QAED,KAAsB,IAAA,KAAA,iBAAA,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,CAAA,gBAAA,4BAAE;YAAvC,IAAM,OAAO,WAAA;YAChB,IAAI;gBACF,OAAO,CAAC,IAAI,CAAC,CAAC;aACf;YAAC,OAAO,CAAC,EAAE;gBACV,sBAAc;oBACZ,eAAM,CAAC,KAAK,CACV,4DAA0D,IAAI,gBAAW,4BAAe,CAAC,OAAO,CAAC,aAAU,EAC3G,CAAC,CACF,CAAC;aACL;SACF;;;;;;;;;AACH,CAAC;AAED,YAAY;AACZ,SAAS,iBAAiB;IACxB,IAAI,CAAC,CAAC,SAAS,IAAI,MAAM,CAAC,EAAE;QAC1B,OAAO;KACR;IAED,uBAAc,CAAC,OAAO,CAAC,UAAU,KAAa;QAC5C,IAAI,CAAC,CAAC,KAAK,IAAI,MAAM,CAAC,OAAO,CAAC,EAAE;YAC9B,OAAO;SACR;QAED,aAAI,CAAC,MAAM,CAAC,OAAO,EAAE,KAAK,EAAE,UAAU,qBAAgC;YACpE,OAAO;gBAAU,cAAc;qBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;oBAAd,yBAAc;;gBAC7B,eAAe,CAAC,SAAS,EAAE,EAAE,IAAI,MAAA,EAAE,KAAK,OAAA,EAAE,CAAC,CAAC;gBAE5C,mCAAmC;gBACnC,IAAI,qBAAqB,EAAE;oBACzB,qBAAqB,CAAC,KAAK,CAAC,MAAM,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;iBACnD;YACH,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC;AAED,YAAY;AACZ,SAAS,eAAe;IACtB,IAAI,CAAC,8BAAmB,EAAE,EAAE;QAC1B,OAAO;KACR;IAED,aAAI,CAAC,MAAM,EAAE,OAAO,EAAE,UAAU,aAAyB;QACvD,OAAO;YAAU,cAAc;iBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;gBAAd,yBAAc;;YAC7B,IAAM,WAAW,GAAG;gBAClB,IAAI,MAAA;gBACJ,SAAS,EAAE;oBACT,MAAM,EAAE,cAAc,CAAC,IAAI,CAAC;oBAC5B,GAAG,EAAE,WAAW,CAAC,IAAI,CAAC;iBACvB;gBACD,cAAc,EAAE,IAAI,CAAC,GAAG,EAAE;aAC3B,CAAC;YAEF,eAAe,CAAC,OAAO,uBAClB,WAAW,EACd,CAAC;YAEH,sEAAsE;YACtE,OAAO,aAAa,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,IAAI,CAC3C,UAAC,QAAkB;gBACjB,eAAe,CAAC,OAAO,wCAClB,WAAW,KACd,YAAY,EAAE,IAAI,CAAC,GAAG,EAAE,EACxB,QAAQ,UAAA,IACR,CAAC;gBACH,OAAO,QAAQ,CAAC;YAClB,CAAC,EACD,UAAC,KAAY;gBACX,eAAe,CAAC,OAAO,wCAClB,WAAW,KACd,YAAY,EAAE,IAAI,CAAC,GAAG,EAAE,EACxB,KAAK,OAAA,IACL,CAAC;gBACH,uEAAuE;gBACvE,2FAA2F;gBAC3F,sFAAsF;gBACtF,MAAM,KAAK,CAAC;YACd,CAAC,CACF,CAAC;QACJ,CAAC,CAAC;IACJ,CAAC,CAAC,CAAC;AACL,CAAC;AAeD,+DAA+D;AAC/D,iDAAiD;AACjD,SAAS,cAAc,CAAC,SAAqB;IAArB,0BAAA,EAAA,cAAqB;IAC3C,IAAI,SAAS,IAAI,MAAM,IAAI,iBAAY,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE;QACrF,OAAO,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,WAAW,EAAE,CAAC;KAClD;IACD,IAAI,SAAS,CAAC,CAAC,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE;QACvC,OAAO,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,WAAW,EAAE,CAAC;KAClD;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAED,8CAA8C;AAC9C,SAAS,WAAW,CAAC,SAAqB;IAArB,0BAAA,EAAA,cAAqB;IACxC,IAAI,OAAO,SAAS,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;QACpC,OAAO,SAAS,CAAC,CAAC,CAAC,CAAC;KACrB;IACD,IAAI,SAAS,IAAI,MAAM,IAAI,iBAAY,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,EAAE;QAC9D,OAAO,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;KACzB;IACD,OAAO,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC;AACD,8DAA8D;AAE9D,YAAY;AACZ,SAAS,aAAa;IACpB,IAAI,CAAC,CAAC,gBAAgB,IAAI,MAAM,CAAC,EAAE;QACjC,OAAO;KACR;IAED,IAAM,QAAQ,GAAG,cAAc,CAAC,SAAS,CAAC;IAE1C,aAAI,CAAC,QAAQ,EAAE,MAAM,EAAE,UAAU,YAAwB;QACvD,OAAO;YAA6C,cAAc;iBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;gBAAd,yBAAc;;YAChE,4DAA4D;YAC5D,IAAM,GAAG,GAAG,IAAI,CAAC;YACjB,IAAM,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;YACpB,IAAM,OAAO,GAAkD,CAAC,GAAG,CAAC,cAAc,GAAG;gBACnF,sEAAsE;gBACtE,MAAM,EAAE,aAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;gBAC3D,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC;aACb,CAAC,CAAC;YAEH,8DAA8D;YAC9D,sEAAsE;YACtE,IAAI,aAAQ,CAAC,GAAG,CAAC,IAAI,OAAO,CAAC,MAAM,KAAK,MAAM,IAAI,GAAG,CAAC,KAAK,CAAC,YAAY,CAAC,EAAE;gBACzE,GAAG,CAAC,sBAAsB,GAAG,IAAI,CAAC;aACnC;YAED,IAAM,yBAAyB,GAAG;gBAChC,IAAI,GAAG,CAAC,UAAU,KAAK,CAAC,EAAE;oBACxB,IAAI;wBACF,+CAA+C;wBAC/C,eAAe;wBACf,OAAO,CAAC,WAAW,GAAG,GAAG,CAAC,MAAM,CAAC;qBAClC;oBAAC,OAAO,CAAC,EAAE;wBACV,gBAAgB;qBACjB;oBAED,eAAe,CAAC,KAAK,EAAE;wBACrB,IAAI,MAAA;wBACJ,YAAY,EAAE,IAAI,CAAC,GAAG,EAAE;wBACxB,cAAc,EAAE,IAAI,CAAC,GAAG,EAAE;wBAC1B,GAAG,KAAA;qBACJ,CAAC,CAAC;iBACJ;YACH,CAAC,CAAC;YAEF,IAAI,oBAAoB,IAAI,GAAG,IAAI,OAAO,GAAG,CAAC,kBAAkB,KAAK,UAAU,EAAE;gBAC/E,aAAI,CAAC,GAAG,EAAE,oBAAoB,EAAE,UAAU,QAAyB;oBACjE,OAAO;wBAAU,wBAAwB;6BAAxB,UAAwB,EAAxB,qBAAwB,EAAxB,IAAwB;4BAAxB,mCAAwB;;wBACvC,yBAAyB,EAAE,CAAC;wBAC5B,OAAO,QAAQ,CAAC,KAAK,CAAC,GAAG,EAAE,cAAc,CAAC,CAAC;oBAC7C,CAAC,CAAC;gBACJ,CAAC,CAAC,CAAC;aACJ;iBAAM;gBACL,GAAG,CAAC,gBAAgB,CAAC,kBAAkB,EAAE,yBAAyB,CAAC,CAAC;aACrE;YAED,OAAO,YAAY,CAAC,KAAK,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QACvC,CAAC,CAAC;IACJ,CAAC,CAAC,CAAC;IAEH,aAAI,CAAC,QAAQ,EAAE,MAAM,EAAE,UAAU,YAAwB;QACvD,OAAO;YAA6C,cAAc;iBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;gBAAd,yBAAc;;YAChE,IAAI,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,SAAS,EAAE;gBAChD,IAAI,CAAC,cAAc,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;aACpC;YAED,eAAe,CAAC,KAAK,EAAE;gBACrB,IAAI,MAAA;gBACJ,cAAc,EAAE,IAAI,CAAC,GAAG,EAAE;gBAC1B,GAAG,EAAE,IAAI;aACV,CAAC,CAAC;YAEH,OAAO,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QACxC,CAAC,CAAC;IACJ,CAAC,CAAC,CAAC;AACL,CAAC;AAED,IAAI,QAAgB,CAAC;AAErB,YAAY;AACZ,SAAS,iBAAiB;IACxB,IAAI,CAAC,0BAAe,EAAE,EAAE;QACtB,OAAO;KACR;IAED,IAAM,aAAa,GAAG,MAAM,CAAC,UAAU,CAAC;IACxC,MAAM,CAAC,UAAU,GAAG;QAAqC,cAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;YAAd,yBAAc;;QACrE,IAAM,EAAE,GAAG,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC;QAChC,mFAAmF;QACnF,IAAM,IAAI,GAAG,QAAQ,CAAC;QACtB,QAAQ,GAAG,EAAE,CAAC;QACd,eAAe,CAAC,SAAS,EAAE;YACzB,IAAI,MAAA;YACJ,EAAE,IAAA;SACH,CAAC,CAAC;QACH,IAAI,aAAa,EAAE;YACjB,yFAAyF;YACzF,6DAA6D;YAC7D,mDAAmD;YACnD,IAAI;gBACF,OAAO,aAAa,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;aACxC;YAAC,OAAO,GAAG,EAAE;gBACZ,WAAW;aACZ;SACF;IACH,CAAC,CAAC;IAEF,cAAc;IACd,SAAS,0BAA0B,CAAC,uBAAmC;QACrE,OAAO;YAAyB,cAAc;iBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;gBAAd,yBAAc;;YAC5C,IAAM,GAAG,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;YAClD,IAAI,GAAG,EAAE;gBACP,iDAAiD;gBACjD,IAAM,IAAI,GAAG,QAAQ,CAAC;gBACtB,IAAM,EAAE,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;gBACvB,mFAAmF;gBACnF,QAAQ,GAAG,EAAE,CAAC;gBACd,eAAe,CAAC,SAAS,EAAE;oBACzB,IAAI,MAAA;oBACJ,EAAE,IAAA;iBACH,CAAC,CAAC;aACJ;YACD,OAAO,uBAAuB,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QACnD,CAAC,CAAC;IACJ,CAAC;IAED,aAAI,CAAC,MAAM,CAAC,OAAO,EAAE,WAAW,EAAE,0BAA0B,CAAC,CAAC;IAC9D,aAAI,CAAC,MAAM,CAAC,OAAO,EAAE,cAAc,EAAE,0BAA0B,CAAC,CAAC;AACnE,CAAC;AAED,IAAM,gBAAgB,GAAG,IAAI,CAAC;AAC9B,IAAI,eAAmC,CAAC;AACxC,IAAI,iBAAoC,CAAC;AAEzC;;;;GAIG;AACH,SAAS,kCAAkC,CAAC,QAA2B,EAAE,OAAc;IACrF,+EAA+E;IAC/E,IAAI,CAAC,QAAQ,EAAE;QACb,OAAO,IAAI,CAAC;KACb;IAED,kHAAkH;IAClH,IAAI,QAAQ,CAAC,IAAI,KAAK,OAAO,CAAC,IAAI,EAAE;QAClC,OAAO,IAAI,CAAC;KACb;IAED,IAAI;QACF,2GAA2G;QAC3G,sCAAsC;QACtC,IAAI,QAAQ,CAAC,MAAM,KAAK,OAAO,CAAC,MAAM,EAAE;YACtC,OAAO,IAAI,CAAC;SACb;KACF;IAAC,OAAO,CAAC,EAAE;QACV,qFAAqF;QACrF,iEAAiE;KAClE;IAED,gHAAgH;IAChH,oGAAoG;IACpG,mGAAmG;IACnG,OAAO,KAAK,CAAC;AACf,CAAC;AAED;;;GAGG;AACH,SAAS,kBAAkB,CAAC,KAAY;IACtC,iEAAiE;IACjE,IAAI,KAAK,CAAC,IAAI,KAAK,UAAU,EAAE;QAC7B,OAAO,KAAK,CAAC;KACd;IAED,IAAI;QACF,IAAM,MAAM,GAAG,KAAK,CAAC,MAAqB,CAAC;QAE3C,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE;YAC9B,OAAO,IAAI,CAAC;SACb;QAED,wGAAwG;QACxG,8CAA8C;QAC9C,IAAI,MAAM,CAAC,OAAO,KAAK,OAAO,IAAI,MAAM,CAAC,OAAO,KAAK,UAAU,IAAI,MAAM,CAAC,iBAAiB,EAAE;YAC3F,OAAO,KAAK,CAAC;SACd;KACF;IAAC,OAAO,CAAC,EAAE;QACV,qFAAqF;QACrF,iEAAiE;KAClE;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;;;;;GAMG;AACH,SAAS,mBAAmB,CAAC,OAAiB,EAAE,cAA+B;IAA/B,+BAAA,EAAA,sBAA+B;IAC7E,OAAO,UAAC,KAAY;QAClB,uEAAuE;QACvE,yDAAyD;QACzD,+CAA+C;QAC/C,IAAI,CAAC,KAAK,IAAI,iBAAiB,KAAK,KAAK,EAAE;YACzC,OAAO;SACR;QAED,wCAAwC;QACxC,IAAI,kBAAkB,CAAC,KAAK,CAAC,EAAE;YAC7B,OAAO;SACR;QAED,IAAM,IAAI,GAAG,KAAK,CAAC,IAAI,KAAK,UAAU,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC;QAE9D,wHAAwH;QACxH,IAAI,eAAe,KAAK,SAAS,EAAE;YACjC,OAAO,CAAC;gBACN,KAAK,EAAE,KAAK;gBACZ,IAAI,MAAA;gBACJ,MAAM,EAAE,cAAc;aACvB,CAAC,CAAC;YACH,iBAAiB,GAAG,KAAK,CAAC;SAC3B;QACD,yGAAyG;QACzG,8FAA8F;aACzF,IAAI,kCAAkC,CAAC,iBAAiB,EAAE,KAAK,CAAC,EAAE;YACrE,OAAO,CAAC;gBACN,KAAK,EAAE,KAAK;gBACZ,IAAI,MAAA;gBACJ,MAAM,EAAE,cAAc;aACvB,CAAC,CAAC;YACH,iBAAiB,GAAG,KAAK,CAAC;SAC3B;QAED,kHAAkH;QAClH,YAAY,CAAC,eAAe,CAAC,CAAC;QAC9B,eAAe,GAAG,MAAM,CAAC,UAAU,CAAC;YAClC,eAAe,GAAG,SAAS,CAAC;QAC9B,CAAC,EAAE,gBAAgB,CAAC,CAAC;IACvB,CAAC,CAAC;AACJ,CAAC;AAuBD,YAAY;AACZ,SAAS,aAAa;IACpB,IAAI,CAAC,CAAC,UAAU,IAAI,MAAM,CAAC,EAAE;QAC3B,OAAO;KACR;IAED,oHAAoH;IACpH,gHAAgH;IAChH,yFAAyF;IACzF,IAAM,iBAAiB,GAAG,eAAe,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAC5D,IAAM,qBAAqB,GAAG,mBAAmB,CAAC,iBAAiB,EAAE,IAAI,CAAC,CAAC;IAC3E,MAAM,CAAC,QAAQ,CAAC,gBAAgB,CAAC,OAAO,EAAE,qBAAqB,EAAE,KAAK,CAAC,CAAC;IACxE,MAAM,CAAC,QAAQ,CAAC,gBAAgB,CAAC,UAAU,EAAE,qBAAqB,EAAE,KAAK,CAAC,CAAC;IAE3E,wGAAwG;IACxG,gHAAgH;IAChH,6GAA6G;IAC7G,gHAAgH;IAChH,qCAAqC;IACrC,CAAC,aAAa,EAAE,MAAM,CAAC,CAAC,OAAO,CAAC,UAAC,MAAc;QAC7C,sEAAsE;QACtE,IAAM,KAAK,GAAI,MAAc,CAAC,MAAM,CAAC,IAAK,MAAc,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC;QAC3E,6FAA6F;QAC7F,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,cAAc,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,kBAAkB,CAAC,EAAE;YAChF,OAAO;SACR;QAED,aAAI,CAAC,KAAK,EAAE,kBAAkB,EAAE,UAAU,wBAA0C;YAClF,OAAO,UAEL,IAAY,EACZ,QAA4C,EAC5C,OAA2C;gBAE3C,IAAI,IAAI,KAAK,OAAO,IAAI,IAAI,IAAI,UAAU,EAAE;oBAC1C,IAAI;wBACF,IAAM,EAAE,GAAG,IAA2B,CAAC;wBACvC,IAAM,UAAQ,GAAG,CAAC,EAAE,CAAC,mCAAmC,GAAG,EAAE,CAAC,mCAAmC,IAAI,EAAE,CAAC,CAAC;wBACzG,IAAM,cAAc,GAAG,CAAC,UAAQ,CAAC,IAAI,CAAC,GAAG,UAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;wBAE5E,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE;4BAC3B,IAAM,OAAO,GAAG,mBAAmB,CAAC,iBAAiB,CAAC,CAAC;4BACvD,cAAc,CAAC,OAAO,GAAG,OAAO,CAAC;4BACjC,wBAAwB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;yBAC7D;wBAED,cAAc,CAAC,QAAQ,IAAI,CAAC,CAAC;qBAC9B;oBAAC,OAAO,CAAC,EAAE;wBACV,8CAA8C;wBAC9C,iFAAiF;qBAClF;iBACF;gBAED,OAAO,wBAAwB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;YACtE,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;QAEH,aAAI,CACF,KAAK,EACL,qBAAqB,EACrB,UAAU,2BAAgD;YACxD,OAAO,UAEL,IAAY,EACZ,QAA4C,EAC5C,OAAwC;gBAExC,IAAI,IAAI,KAAK,OAAO,IAAI,IAAI,IAAI,UAAU,EAAE;oBAC1C,IAAI;wBACF,IAAM,EAAE,GAAG,IAA2B,CAAC;wBACvC,IAAM,UAAQ,GAAG,EAAE,CAAC,mCAAmC,IAAI,EAAE,CAAC;wBAC9D,IAAM,cAAc,GAAG,UAAQ,CAAC,IAAI,CAAC,CAAC;wBAEtC,IAAI,cAAc,EAAE;4BAClB,cAAc,CAAC,QAAQ,IAAI,CAAC,CAAC;4BAC7B,2GAA2G;4BAC3G,IAAI,cAAc,CAAC,QAAQ,IAAI,CAAC,EAAE;gCAChC,2BAA2B,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,cAAc,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;gCAC9E,cAAc,CAAC,OAAO,GAAG,SAAS,CAAC;gCACnC,OAAO,UAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,2DAA2D;6BACnF;4BAED,8FAA8F;4BAC9F,IAAI,MAAM,CAAC,IAAI,CAAC,UAAQ,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE;gCACtC,OAAO,EAAE,CAAC,mCAAmC,CAAC;6BAC/C;yBACF;qBACF;oBAAC,OAAO,CAAC,EAAE;wBACV,8CAA8C;wBAC9C,iFAAiF;qBAClF;iBACF;gBAED,OAAO,2BAA2B,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;YACzE,CAAC,CAAC;QACJ,CAAC,CACF,CAAC;IACJ,CAAC,CAAC,CAAC;AACL,CAAC;AAED,IAAI,kBAAkB,GAAwB,IAAI,CAAC;AACnD,YAAY;AACZ,SAAS,eAAe;IACtB,kBAAkB,GAAG,MAAM,CAAC,OAAO,CAAC;IAEpC,MAAM,CAAC,OAAO,GAAG,UAAU,GAAQ,EAAE,GAAQ,EAAE,IAAS,EAAE,MAAW,EAAE,KAAU;QAC/E,eAAe,CAAC,OAAO,EAAE;YACvB,MAAM,QAAA;YACN,KAAK,OAAA;YACL,IAAI,MAAA;YACJ,GAAG,KAAA;YACH,GAAG,KAAA;SACJ,CAAC,CAAC;QAEH,IAAI,kBAAkB,EAAE;YACtB,8CAA8C;YAC9C,OAAO,kBAAkB,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;SAClD;QAED,OAAO,KAAK,CAAC;IACf,CAAC,CAAC;AACJ,CAAC;AAED,IAAI,+BAA+B,GAA8B,IAAI,CAAC;AACtE,YAAY;AACZ,SAAS,4BAA4B;IACnC,+BAA+B,GAAG,MAAM,CAAC,oBAAoB,CAAC;IAE9D,MAAM,CAAC,oBAAoB,GAAG,UAAU,CAAM;QAC5C,eAAe,CAAC,oBAAoB,EAAE,CAAC,CAAC,CAAC;QAEzC,IAAI,+BAA+B,EAAE;YACnC,8CAA8C;YAC9C,OAAO,+BAA+B,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;SAC/D;QAED,OAAO,IAAI,CAAC;IACd,CAAC,CAAC;AACJ,CAAC","sourcesContent":["/* eslint-disable max-lines */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\nimport { WrappedFunction } from '@sentry/types';\n\nimport { IS_DEBUG_BUILD } from './flags';\nimport { getGlobalObject } from './global';\nimport { isInstanceOf, isString } from './is';\nimport { CONSOLE_LEVELS, logger } from './logger';\nimport { fill } from './object';\nimport { getFunctionName } from './stacktrace';\nimport { supportsHistory, supportsNativeFetch } from './supports';\n\nconst global = getGlobalObject<Window>();\n\ntype InstrumentHandlerType =\n  | 'console'\n  | 'dom'\n  | 'fetch'\n  | 'history'\n  | 'sentry'\n  | 'xhr'\n  | 'error'\n  | 'unhandledrejection';\ntype InstrumentHandlerCallback = (data: any) => void;\n\n/**\n * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.\n *  - Console API\n *  - Fetch API\n *  - XHR API\n *  - History API\n *  - DOM API (click/typing)\n *  - Error API\n *  - UnhandledRejection API\n */\n\nconst handlers: { [key in InstrumentHandlerType]?: InstrumentHandlerCallback[] } = {};\nconst instrumented: { [key in InstrumentHandlerType]?: boolean } = {};\n\n/** Instruments given API */\nfunction instrument(type: InstrumentHandlerType): void {\n  if (instrumented[type]) {\n    return;\n  }\n\n  instrumented[type] = true;\n\n  switch (type) {\n    case 'console':\n      instrumentConsole();\n      break;\n    case 'dom':\n      instrumentDOM();\n      break;\n    case 'xhr':\n      instrumentXHR();\n      break;\n    case 'fetch':\n      instrumentFetch();\n      break;\n    case 'history':\n      instrumentHistory();\n      break;\n    case 'error':\n      instrumentError();\n      break;\n    case 'unhandledrejection':\n      instrumentUnhandledRejection();\n      break;\n    default:\n      IS_DEBUG_BUILD && logger.warn('unknown instrumentation type:', type);\n      return;\n  }\n}\n\n/**\n * Add handler that will be called when given type of instrumentation triggers.\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addInstrumentationHandler(type: InstrumentHandlerType, callback: InstrumentHandlerCallback): void {\n  handlers[type] = handlers[type] || [];\n  (handlers[type] as InstrumentHandlerCallback[]).push(callback);\n  instrument(type);\n}\n\n/** JSDoc */\nfunction triggerHandlers(type: InstrumentHandlerType, data: any): void {\n  if (!type || !handlers[type]) {\n    return;\n  }\n\n  for (const handler of handlers[type] || []) {\n    try {\n      handler(data);\n    } catch (e) {\n      IS_DEBUG_BUILD &&\n        logger.error(\n          `Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`,\n          e,\n        );\n    }\n  }\n}\n\n/** JSDoc */\nfunction instrumentConsole(): void {\n  if (!('console' in global)) {\n    return;\n  }\n\n  CONSOLE_LEVELS.forEach(function (level: string): void {\n    if (!(level in global.console)) {\n      return;\n    }\n\n    fill(global.console, level, function (originalConsoleMethod: () => any): Function {\n      return function (...args: any[]): void {\n        triggerHandlers('console', { args, level });\n\n        // this fails for some browsers. :(\n        if (originalConsoleMethod) {\n          originalConsoleMethod.apply(global.console, args);\n        }\n      };\n    });\n  });\n}\n\n/** JSDoc */\nfunction instrumentFetch(): void {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n\n  fill(global, 'fetch', function (originalFetch: () => void): () => void {\n    return function (...args: any[]): void {\n      const handlerData = {\n        args,\n        fetchData: {\n          method: getFetchMethod(args),\n          url: getFetchUrl(args),\n        },\n        startTimestamp: Date.now(),\n      };\n\n      triggerHandlers('fetch', {\n        ...handlerData,\n      });\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalFetch.apply(global, args).then(\n        (response: Response) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            response,\n          });\n          return response;\n        },\n        (error: Error) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            error,\n          });\n          // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n          //       it means the sentry.javascript SDK caught an error invoking your application code.\n          //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n          throw error;\n        },\n      );\n    };\n  });\n}\n\ntype XHRSendInput = null | Blob | BufferSource | FormData | URLSearchParams | string;\n\n/** JSDoc */\ninterface SentryWrappedXMLHttpRequest extends XMLHttpRequest {\n  [key: string]: any;\n  __sentry_xhr__?: {\n    method?: string;\n    url?: string;\n    status_code?: number;\n    body?: XHRSendInput;\n  };\n}\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/** Extract `method` from fetch call arguments */\nfunction getFetchMethod(fetchArgs: any[] = []): string {\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {\n    return String(fetchArgs[0].method).toUpperCase();\n  }\n  if (fetchArgs[1] && fetchArgs[1].method) {\n    return String(fetchArgs[1].method).toUpperCase();\n  }\n  return 'GET';\n}\n\n/** Extract `url` from fetch call arguments */\nfunction getFetchUrl(fetchArgs: any[] = []): string {\n  if (typeof fetchArgs[0] === 'string') {\n    return fetchArgs[0];\n  }\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request)) {\n    return fetchArgs[0].url;\n  }\n  return String(fetchArgs[0]);\n}\n/* eslint-enable @typescript-eslint/no-unsafe-member-access */\n\n/** JSDoc */\nfunction instrumentXHR(): void {\n  if (!('XMLHttpRequest' in global)) {\n    return;\n  }\n\n  const xhrproto = XMLHttpRequest.prototype;\n\n  fill(xhrproto, 'open', function (originalOpen: () => void): () => void {\n    return function (this: SentryWrappedXMLHttpRequest, ...args: any[]): void {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const xhr = this;\n      const url = args[1];\n      const xhrInfo: SentryWrappedXMLHttpRequest['__sentry_xhr__'] = (xhr.__sentry_xhr__ = {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        method: isString(args[0]) ? args[0].toUpperCase() : args[0],\n        url: args[1],\n      });\n\n      // if Sentry key appears in URL, don't capture it as a request\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (isString(url) && xhrInfo.method === 'POST' && url.match(/sentry_key/)) {\n        xhr.__sentry_own_request__ = true;\n      }\n\n      const onreadystatechangeHandler = function (): void {\n        if (xhr.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = xhr.status;\n          } catch (e) {\n            /* do nothing */\n          }\n\n          triggerHandlers('xhr', {\n            args,\n            endTimestamp: Date.now(),\n            startTimestamp: Date.now(),\n            xhr,\n          });\n        }\n      };\n\n      if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {\n        fill(xhr, 'onreadystatechange', function (original: WrappedFunction): Function {\n          return function (...readyStateArgs: any[]): void {\n            onreadystatechangeHandler();\n            return original.apply(xhr, readyStateArgs);\n          };\n        });\n      } else {\n        xhr.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      return originalOpen.apply(xhr, args);\n    };\n  });\n\n  fill(xhrproto, 'send', function (originalSend: () => void): () => void {\n    return function (this: SentryWrappedXMLHttpRequest, ...args: any[]): void {\n      if (this.__sentry_xhr__ && args[0] !== undefined) {\n        this.__sentry_xhr__.body = args[0];\n      }\n\n      triggerHandlers('xhr', {\n        args,\n        startTimestamp: Date.now(),\n        xhr: this,\n      });\n\n      return originalSend.apply(this, args);\n    };\n  });\n}\n\nlet lastHref: string;\n\n/** JSDoc */\nfunction instrumentHistory(): void {\n  if (!supportsHistory()) {\n    return;\n  }\n\n  const oldOnPopState = global.onpopstate;\n  global.onpopstate = function (this: WindowEventHandlers, ...args: any[]): any {\n    const to = global.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n    triggerHandlers('history', {\n      from,\n      to,\n    });\n    if (oldOnPopState) {\n      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.\n      // https://github.com/getsentry/sentry-javascript/issues/3344\n      // https://github.com/bugsnag/bugsnag-js/issues/469\n      try {\n        return oldOnPopState.apply(this, args);\n      } catch (_oO) {\n        // no-empty\n      }\n    }\n  };\n\n  /** @hidden */\n  function historyReplacementFunction(originalHistoryFunction: () => void): () => void {\n    return function (this: History, ...args: any[]): void {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        const from = lastHref;\n        const to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        triggerHandlers('history', {\n          from,\n          to,\n        });\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(global.history, 'pushState', historyReplacementFunction);\n  fill(global.history, 'replaceState', historyReplacementFunction);\n}\n\nconst debounceDuration = 1000;\nlet debounceTimerID: number | undefined;\nlet lastCapturedEvent: Event | undefined;\n\n/**\n * Decide whether the current event should finish the debounce of previously captured one.\n * @param previous previously captured event\n * @param current event to be captured\n */\nfunction shouldShortcircuitPreviousDebounce(previous: Event | undefined, current: Event): boolean {\n  // If there was no previous event, it should always be swapped for the new one.\n  if (!previous) {\n    return true;\n  }\n\n  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n  if (previous.type !== current.type) {\n    return true;\n  }\n\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (previous.target !== current.target) {\n      return true;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n  return false;\n}\n\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\nfunction shouldSkipDOMEvent(event: Event): boolean {\n  // We are only interested in filtering `keypress` events for now.\n  if (event.type !== 'keypress') {\n    return false;\n  }\n\n  try {\n    const target = event.target as HTMLElement;\n\n    if (!target || !target.tagName) {\n      return true;\n    }\n\n    // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n    // e.g.tabbing through elements, hotkeys, etc.\n    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n      return false;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  return true;\n}\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n * @param handler function that will be triggered\n * @param globalListener indicates whether event was captured by the global event listener\n * @returns wrapped breadcrumb events handler\n * @hidden\n */\nfunction makeDOMEventHandler(handler: Function, globalListener: boolean = false): (event: Event) => void {\n  return (event: Event): void => {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || lastCapturedEvent === event) {\n      return;\n    }\n\n    // We always want to skip _some_ events.\n    if (shouldSkipDOMEvent(event)) {\n      return;\n    }\n\n    const name = event.type === 'keypress' ? 'input' : event.type;\n\n    // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.\n    if (debounceTimerID === undefined) {\n      handler({\n        event: event,\n        name,\n        global: globalListener,\n      });\n      lastCapturedEvent = event;\n    }\n    // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {\n      handler({\n        event: event,\n        name,\n        global: globalListener,\n      });\n      lastCapturedEvent = event;\n    }\n\n    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n    clearTimeout(debounceTimerID);\n    debounceTimerID = global.setTimeout(() => {\n      debounceTimerID = undefined;\n    }, debounceDuration);\n  };\n}\n\ntype AddEventListener = (\n  type: string,\n  listener: EventListenerOrEventListenerObject,\n  options?: boolean | AddEventListenerOptions,\n) => void;\ntype RemoveEventListener = (\n  type: string,\n  listener: EventListenerOrEventListenerObject,\n  options?: boolean | EventListenerOptions,\n) => void;\n\ntype InstrumentedElement = Element & {\n  __sentry_instrumentation_handlers__?: {\n    [key in 'click' | 'keypress']?: {\n      handler?: Function;\n      /** The number of custom listeners attached to this element */\n      refCount: number;\n    };\n  };\n};\n\n/** JSDoc */\nfunction instrumentDOM(): void {\n  if (!('document' in global)) {\n    return;\n  }\n\n  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n  const triggerDOMHandler = triggerHandlers.bind(null, 'dom');\n  const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  global.document.addEventListener('click', globalDOMEventHandler, false);\n  global.document.addEventListener('keypress', globalDOMEventHandler, false);\n\n  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n  ['EventTarget', 'Node'].forEach((target: string) => {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const proto = (global as any)[target] && (global as any)[target].prototype;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n\n    fill(proto, 'addEventListener', function (originalAddEventListener: AddEventListener): AddEventListener {\n      return function (\n        this: Element,\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: boolean | AddEventListenerOptions,\n      ): AddEventListener {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            const el = this as InstrumentedElement;\n            const handlers = (el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {});\n            const handlerForType = (handlers[type] = handlers[type] || { refCount: 0 });\n\n            if (!handlerForType.handler) {\n              const handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n\n            handlerForType.refCount += 1;\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n          }\n        }\n\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n\n    fill(\n      proto,\n      'removeEventListener',\n      function (originalRemoveEventListener: RemoveEventListener): RemoveEventListener {\n        return function (\n          this: Element,\n          type: string,\n          listener: EventListenerOrEventListenerObject,\n          options?: boolean | EventListenerOptions,\n        ): () => void {\n          if (type === 'click' || type == 'keypress') {\n            try {\n              const el = this as InstrumentedElement;\n              const handlers = el.__sentry_instrumentation_handlers__ || {};\n              const handlerForType = handlers[type];\n\n              if (handlerForType) {\n                handlerForType.refCount -= 1;\n                // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n                if (handlerForType.refCount <= 0) {\n                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                  handlerForType.handler = undefined;\n                  delete handlers[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n                }\n\n                // If there are no longer any custom handlers of any type on this element, cleanup everything.\n                if (Object.keys(handlers).length === 0) {\n                  delete el.__sentry_instrumentation_handlers__;\n                }\n              }\n            } catch (e) {\n              // Accessing dom properties is always fragile.\n              // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n            }\n          }\n\n          return originalRemoveEventListener.call(this, type, listener, options);\n        };\n      },\n    );\n  });\n}\n\nlet _oldOnErrorHandler: OnErrorEventHandler = null;\n/** JSDoc */\nfunction instrumentError(): void {\n  _oldOnErrorHandler = global.onerror;\n\n  global.onerror = function (msg: any, url: any, line: any, column: any, error: any): boolean {\n    triggerHandlers('error', {\n      column,\n      error,\n      line,\n      msg,\n      url,\n    });\n\n    if (_oldOnErrorHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnErrorHandler.apply(this, arguments);\n    }\n\n    return false;\n  };\n}\n\nlet _oldOnUnhandledRejectionHandler: ((e: any) => void) | null = null;\n/** JSDoc */\nfunction instrumentUnhandledRejection(): void {\n  _oldOnUnhandledRejectionHandler = global.onunhandledrejection;\n\n  global.onunhandledrejection = function (e: any): boolean {\n    triggerHandlers('unhandledrejection', e);\n\n    if (_oldOnUnhandledRejectionHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnUnhandledRejectionHandler.apply(this, arguments);\n    }\n\n    return true;\n  };\n}\n"]}import { Primitive } from '@sentry/types';
/**
 * Checks whether given value's type is one of a few Error or Error-like
 * {@link isError}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isError(wat: unknown): wat is Error;
/**
 * Checks whether given value's type is ErrorEvent
 * {@link isErrorEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isErrorEvent(wat: unknown): boolean;
/**
 * Checks whether given value's type is DOMError
 * {@link isDOMError}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isDOMError(wat: unknown): boolean;
/**
 * Checks whether given value's type is DOMException
 * {@link isDOMException}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isDOMException(wat: unknown): boolean;
/**
 * Checks whether given value's type is a string
 * {@link isString}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isString(wat: unknown): wat is string;
/**
 * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)
 * {@link isPrimitive}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isPrimitive(wat: unknown): wat is Primitive;
/**
 * Checks whether given value's type is an object literal
 * {@link isPlainObject}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isPlainObject(wat: unknown): wat is Record<string, unknown>;
/**
 * Checks whether given value's type is an Event instance
 * {@link isEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isEvent(wat: unknown): boolean;
/**
 * Checks whether given value's type is an Element instance
 * {@link isElement}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isElement(wat: unknown): boolean;
/**
 * Checks whether given value's type is an regexp
 * {@link isRegExp}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isRegExp(wat: unknown): wat is RegExp;
/**
 * Checks whether given value has a then function.
 * @param wat A value to be checked.
 */
export declare function isThenable(wat: any): wat is PromiseLike<any>;
/**
 * Checks whether given value's type is a SyntheticEvent
 * {@link isSyntheticEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isSyntheticEvent(wat: unknown): boolean;
/**
 * Checks whether given value is NaN
 * {@link isNaN}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isNaN(wat: unknown): boolean;
/**
 * Checks whether given value's type is an instance of provided constructor.
 * {@link isInstanceOf}.
 *
 * @param wat A value to be checked.
 * @param base A constructor to be used in a check.
 * @returns A boolean representing the result.
 */
export declare function isInstanceOf(wat: any, base: any): boolean;
//# sourceMappingURL=is.d.ts.map{"version":3,"file":"is.d.ts","sourceRoot":"","sources":["../../src/is.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAK1C;;;;;;GAMG;AACH,wBAAgB,OAAO,CAAC,GAAG,EAAE,OAAO,GAAG,GAAG,IAAI,KAAK,CASlD;AAMD;;;;;;GAMG;AACH,wBAAgB,YAAY,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAElD;AAED;;;;;;GAMG;AACH,wBAAgB,UAAU,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAEhD;AAED;;;;;;GAMG;AACH,wBAAgB,cAAc,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAEpD;AAED;;;;;;GAMG;AACH,wBAAgB,QAAQ,CAAC,GAAG,EAAE,OAAO,GAAG,GAAG,IAAI,MAAM,CAEpD;AAED;;;;;;GAMG;AACH,wBAAgB,WAAW,CAAC,GAAG,EAAE,OAAO,GAAG,GAAG,IAAI,SAAS,CAE1D;AAED;;;;;;GAMG;AACH,wBAAgB,aAAa,CAAC,GAAG,EAAE,OAAO,GAAG,GAAG,IAAI,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAE1E;AAED;;;;;;GAMG;AACH,wBAAgB,OAAO,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAE7C;AAED;;;;;;GAMG;AACH,wBAAgB,SAAS,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAE/C;AAED;;;;;;GAMG;AACH,wBAAgB,QAAQ,CAAC,GAAG,EAAE,OAAO,GAAG,GAAG,IAAI,MAAM,CAEpD;AAED;;;GAGG;AACH,wBAAgB,UAAU,CAAC,GAAG,EAAE,GAAG,GAAG,GAAG,IAAI,WAAW,CAAC,GAAG,CAAC,CAG5D;AAED;;;;;;GAMG;AACH,wBAAgB,gBAAgB,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAEtD;AAED;;;;;;GAMG;AACH,wBAAgB,KAAK,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAE3C;AAED;;;;;;;GAOG;AACH,wBAAgB,YAAY,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,OAAO,CAMzD"}/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
Object.defineProperty(exports, "__esModule", { value: true });
// eslint-disable-next-line @typescript-eslint/unbound-method
var objectToString = Object.prototype.toString;
/**
 * Checks whether given value's type is one of a few Error or Error-like
 * {@link isError}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isError(wat) {
    switch (objectToString.call(wat)) {
        case '[object Error]':
        case '[object Exception]':
        case '[object DOMException]':
            return true;
        default:
            return isInstanceOf(wat, Error);
    }
}
exports.isError = isError;
function isBuiltin(wat, ty) {
    return objectToString.call(wat) === "[object " + ty + "]";
}
/**
 * Checks whether given value's type is ErrorEvent
 * {@link isErrorEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isErrorEvent(wat) {
    return isBuiltin(wat, 'ErrorEvent');
}
exports.isErrorEvent = isErrorEvent;
/**
 * Checks whether given value's type is DOMError
 * {@link isDOMError}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isDOMError(wat) {
    return isBuiltin(wat, 'DOMError');
}
exports.isDOMError = isDOMError;
/**
 * Checks whether given value's type is DOMException
 * {@link isDOMException}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isDOMException(wat) {
    return isBuiltin(wat, 'DOMException');
}
exports.isDOMException = isDOMException;
/**
 * Checks whether given value's type is a string
 * {@link isString}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isString(wat) {
    return isBuiltin(wat, 'String');
}
exports.isString = isString;
/**
 * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)
 * {@link isPrimitive}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isPrimitive(wat) {
    return wat === null || (typeof wat !== 'object' && typeof wat !== 'function');
}
exports.isPrimitive = isPrimitive;
/**
 * Checks whether given value's type is an object literal
 * {@link isPlainObject}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isPlainObject(wat) {
    return isBuiltin(wat, 'Object');
}
exports.isPlainObject = isPlainObject;
/**
 * Checks whether given value's type is an Event instance
 * {@link isEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isEvent(wat) {
    return typeof Event !== 'undefined' && isInstanceOf(wat, Event);
}
exports.isEvent = isEvent;
/**
 * Checks whether given value's type is an Element instance
 * {@link isElement}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isElement(wat) {
    return typeof Element !== 'undefined' && isInstanceOf(wat, Element);
}
exports.isElement = isElement;
/**
 * Checks whether given value's type is an regexp
 * {@link isRegExp}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isRegExp(wat) {
    return isBuiltin(wat, 'RegExp');
}
exports.isRegExp = isRegExp;
/**
 * Checks whether given value has a then function.
 * @param wat A value to be checked.
 */
function isThenable(wat) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    return Boolean(wat && wat.then && typeof wat.then === 'function');
}
exports.isThenable = isThenable;
/**
 * Checks whether given value's type is a SyntheticEvent
 * {@link isSyntheticEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isSyntheticEvent(wat) {
    return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;
}
exports.isSyntheticEvent = isSyntheticEvent;
/**
 * Checks whether given value is NaN
 * {@link isNaN}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isNaN(wat) {
    return typeof wat === 'number' && wat !== wat;
}
exports.isNaN = isNaN;
/**
 * Checks whether given value's type is an instance of provided constructor.
 * {@link isInstanceOf}.
 *
 * @param wat A value to be checked.
 * @param base A constructor to be used in a check.
 * @returns A boolean representing the result.
 */
function isInstanceOf(wat, base) {
    try {
        return wat instanceof base;
    }
    catch (_e) {
        return false;
    }
}
exports.isInstanceOf = isInstanceOf;
//# sourceMappingURL=is.js.map{"version":3,"file":"is.js","sourceRoot":"","sources":["../../src/is.ts"],"names":[],"mappings":"AAAA,uDAAuD;AACvD,sEAAsE;;AAItE,6DAA6D;AAC7D,IAAM,cAAc,GAAG,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC;AAEjD;;;;;;GAMG;AACH,SAAgB,OAAO,CAAC,GAAY;IAClC,QAAQ,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;QAChC,KAAK,gBAAgB,CAAC;QACtB,KAAK,oBAAoB,CAAC;QAC1B,KAAK,uBAAuB;YAC1B,OAAO,IAAI,CAAC;QACd;YACE,OAAO,YAAY,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;KACnC;AACH,CAAC;AATD,0BASC;AAED,SAAS,SAAS,CAAC,GAAY,EAAE,EAAU;IACzC,OAAO,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,aAAW,EAAE,MAAG,CAAC;AACvD,CAAC;AAED;;;;;;GAMG;AACH,SAAgB,YAAY,CAAC,GAAY;IACvC,OAAO,SAAS,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;AACtC,CAAC;AAFD,oCAEC;AAED;;;;;;GAMG;AACH,SAAgB,UAAU,CAAC,GAAY;IACrC,OAAO,SAAS,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC;AACpC,CAAC;AAFD,gCAEC;AAED;;;;;;GAMG;AACH,SAAgB,cAAc,CAAC,GAAY;IACzC,OAAO,SAAS,CAAC,GAAG,EAAE,cAAc,CAAC,CAAC;AACxC,CAAC;AAFD,wCAEC;AAED;;;;;;GAMG;AACH,SAAgB,QAAQ,CAAC,GAAY;IACnC,OAAO,SAAS,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;AAClC,CAAC;AAFD,4BAEC;AAED;;;;;;GAMG;AACH,SAAgB,WAAW,CAAC,GAAY;IACtC,OAAO,GAAG,KAAK,IAAI,IAAI,CAAC,OAAO,GAAG,KAAK,QAAQ,IAAI,OAAO,GAAG,KAAK,UAAU,CAAC,CAAC;AAChF,CAAC;AAFD,kCAEC;AAED;;;;;;GAMG;AACH,SAAgB,aAAa,CAAC,GAAY;IACxC,OAAO,SAAS,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;AAClC,CAAC;AAFD,sCAEC;AAED;;;;;;GAMG;AACH,SAAgB,OAAO,CAAC,GAAY;IAClC,OAAO,OAAO,KAAK,KAAK,WAAW,IAAI,YAAY,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;AAClE,CAAC;AAFD,0BAEC;AAED;;;;;;GAMG;AACH,SAAgB,SAAS,CAAC,GAAY;IACpC,OAAO,OAAO,OAAO,KAAK,WAAW,IAAI,YAAY,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;AACtE,CAAC;AAFD,8BAEC;AAED;;;;;;GAMG;AACH,SAAgB,QAAQ,CAAC,GAAY;IACnC,OAAO,SAAS,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;AAClC,CAAC;AAFD,4BAEC;AAED;;;GAGG;AACH,SAAgB,UAAU,CAAC,GAAQ;IACjC,sEAAsE;IACtE,OAAO,OAAO,CAAC,GAAG,IAAI,GAAG,CAAC,IAAI,IAAI,OAAO,GAAG,CAAC,IAAI,KAAK,UAAU,CAAC,CAAC;AACpE,CAAC;AAHD,gCAGC;AAED;;;;;;GAMG;AACH,SAAgB,gBAAgB,CAAC,GAAY;IAC3C,OAAO,aAAa,CAAC,GAAG,CAAC,IAAI,aAAa,IAAI,GAAG,IAAI,gBAAgB,IAAI,GAAG,IAAI,iBAAiB,IAAI,GAAG,CAAC;AAC3G,CAAC;AAFD,4CAEC;AAED;;;;;;GAMG;AACH,SAAgB,KAAK,CAAC,GAAY;IAChC,OAAO,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,KAAK,GAAG,CAAC;AAChD,CAAC;AAFD,sBAEC;AAED;;;;;;;GAOG;AACH,SAAgB,YAAY,CAAC,GAAQ,EAAE,IAAS;IAC9C,IAAI;QACF,OAAO,GAAG,YAAY,IAAI,CAAC;KAC5B;IAAC,OAAO,EAAE,EAAE;QACX,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAND,oCAMC","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n\nimport { Primitive } from '@sentry/types';\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst objectToString = Object.prototype.toString;\n\n/**\n * Checks whether given value's type is one of a few Error or Error-like\n * {@link isError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isError(wat: unknown): wat is Error {\n  switch (objectToString.call(wat)) {\n    case '[object Error]':\n    case '[object Exception]':\n    case '[object DOMException]':\n      return true;\n    default:\n      return isInstanceOf(wat, Error);\n  }\n}\n\nfunction isBuiltin(wat: unknown, ty: string): boolean {\n  return objectToString.call(wat) === `[object ${ty}]`;\n}\n\n/**\n * Checks whether given value's type is ErrorEvent\n * {@link isErrorEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isErrorEvent(wat: unknown): boolean {\n  return isBuiltin(wat, 'ErrorEvent');\n}\n\n/**\n * Checks whether given value's type is DOMError\n * {@link isDOMError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isDOMError(wat: unknown): boolean {\n  return isBuiltin(wat, 'DOMError');\n}\n\n/**\n * Checks whether given value's type is DOMException\n * {@link isDOMException}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isDOMException(wat: unknown): boolean {\n  return isBuiltin(wat, 'DOMException');\n}\n\n/**\n * Checks whether given value's type is a string\n * {@link isString}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isString(wat: unknown): wat is string {\n  return isBuiltin(wat, 'String');\n}\n\n/**\n * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)\n * {@link isPrimitive}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isPrimitive(wat: unknown): wat is Primitive {\n  return wat === null || (typeof wat !== 'object' && typeof wat !== 'function');\n}\n\n/**\n * Checks whether given value's type is an object literal\n * {@link isPlainObject}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isPlainObject(wat: unknown): wat is Record<string, unknown> {\n  return isBuiltin(wat, 'Object');\n}\n\n/**\n * Checks whether given value's type is an Event instance\n * {@link isEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isEvent(wat: unknown): boolean {\n  return typeof Event !== 'undefined' && isInstanceOf(wat, Event);\n}\n\n/**\n * Checks whether given value's type is an Element instance\n * {@link isElement}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isElement(wat: unknown): boolean {\n  return typeof Element !== 'undefined' && isInstanceOf(wat, Element);\n}\n\n/**\n * Checks whether given value's type is an regexp\n * {@link isRegExp}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isRegExp(wat: unknown): wat is RegExp {\n  return isBuiltin(wat, 'RegExp');\n}\n\n/**\n * Checks whether given value has a then function.\n * @param wat A value to be checked.\n */\nexport function isThenable(wat: any): wat is PromiseLike<any> {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return Boolean(wat && wat.then && typeof wat.then === 'function');\n}\n\n/**\n * Checks whether given value's type is a SyntheticEvent\n * {@link isSyntheticEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isSyntheticEvent(wat: unknown): boolean {\n  return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;\n}\n\n/**\n * Checks whether given value is NaN\n * {@link isNaN}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isNaN(wat: unknown): boolean {\n  return typeof wat === 'number' && wat !== wat;\n}\n\n/**\n * Checks whether given value's type is an instance of provided constructor.\n * {@link isInstanceOf}.\n *\n * @param wat A value to be checked.\n * @param base A constructor to be used in a check.\n * @returns A boolean representing the result.\n */\nexport function isInstanceOf(wat: any, base: any): boolean {\n  try {\n    return wat instanceof base;\n  } catch (_e) {\n    return false;\n  }\n}\n"]}export declare const CONSOLE_LEVELS: readonly ["debug", "info", "warn", "error", "log", "assert"];
declare type LoggerMethod = (...args: unknown[]) => void;
declare type LoggerConsoleMethods = Record<typeof CONSOLE_LEVELS[number], LoggerMethod>;
/** JSDoc */
interface Logger extends LoggerConsoleMethods {
    disable(): void;
    enable(): void;
}
/**
 * Temporarily disable sentry console instrumentations.
 *
 * @param callback The function to run against the original `console` messages
 * @returns The results of the callback
 */
export declare function consoleSandbox<T>(callback: () => T): T;
declare let logger: Logger;
export { logger };
//# sourceMappingURL=logger.d.ts.map{"version":3,"file":"logger.d.ts","sourceRoot":"","sources":["../../src/logger.ts"],"names":[],"mappings":"AAWA,eAAO,MAAM,cAAc,8DAA+D,CAAC;AAE3F,aAAK,YAAY,GAAG,CAAC,GAAG,IAAI,EAAE,OAAO,EAAE,KAAK,IAAI,CAAC;AACjD,aAAK,oBAAoB,GAAG,MAAM,CAAC,OAAO,cAAc,CAAC,MAAM,CAAC,EAAE,YAAY,CAAC,CAAC;AAEhF,YAAY;AACZ,UAAU,MAAO,SAAQ,oBAAoB;IAC3C,OAAO,IAAI,IAAI,CAAC;IAChB,MAAM,IAAI,IAAI,CAAC;CAChB;AAED;;;;;GAKG;AACH,wBAAgB,cAAc,CAAC,CAAC,EAAE,QAAQ,EAAE,MAAM,CAAC,GAAG,CAAC,CA6BtD;AAkCD,QAAA,IAAI,MAAM,EAAE,MAAM,CAAC;AAOnB,OAAO,EAAE,MAAM,EAAE,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var flags_1 = require("./flags");
var global_1 = require("./global");
// TODO: Implement different loggers for different environments
var global = global_1.getGlobalObject();
/** Prefix for logging strings */
var PREFIX = 'Sentry Logger ';
exports.CONSOLE_LEVELS = ['debug', 'info', 'warn', 'error', 'log', 'assert'];
/**
 * Temporarily disable sentry console instrumentations.
 *
 * @param callback The function to run against the original `console` messages
 * @returns The results of the callback
 */
function consoleSandbox(callback) {
    var global = global_1.getGlobalObject();
    if (!('console' in global)) {
        return callback();
    }
    var originalConsole = global.console;
    var wrappedLevels = {};
    // Restore all wrapped console methods
    exports.CONSOLE_LEVELS.forEach(function (level) {
        // TODO(v7): Remove this check as it's only needed for Node 6
        var originalWrappedFunc = originalConsole[level] && originalConsole[level].__sentry_original__;
        if (level in global.console && originalWrappedFunc) {
            wrappedLevels[level] = originalConsole[level];
            originalConsole[level] = originalWrappedFunc;
        }
    });
    try {
        return callback();
    }
    finally {
        // Revert restoration to wrapped state
        Object.keys(wrappedLevels).forEach(function (level) {
            originalConsole[level] = wrappedLevels[level];
        });
    }
}
exports.consoleSandbox = consoleSandbox;
function makeLogger() {
    var enabled = false;
    var logger = {
        enable: function () {
            enabled = true;
        },
        disable: function () {
            enabled = false;
        },
    };
    if (flags_1.IS_DEBUG_BUILD) {
        exports.CONSOLE_LEVELS.forEach(function (name) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            logger[name] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (enabled) {
                    consoleSandbox(function () {
                        var _a;
                        (_a = global.console)[name].apply(_a, tslib_1.__spread([PREFIX + "[" + name + "]:"], args));
                    });
                }
            };
        });
    }
    else {
        exports.CONSOLE_LEVELS.forEach(function (name) {
            logger[name] = function () { return undefined; };
        });
    }
    return logger;
}
// Ensure we only have a single logger instance, even if multiple versions of @sentry/utils are being used
var logger;
exports.logger = logger;
if (flags_1.IS_DEBUG_BUILD) {
    exports.logger = logger = global_1.getGlobalSingleton('logger', makeLogger);
}
else {
    exports.logger = logger = makeLogger();
}
//# sourceMappingURL=logger.js.map{"version":3,"file":"logger.js","sourceRoot":"","sources":["../../src/logger.ts"],"names":[],"mappings":";;AAEA,iCAAyC;AACzC,mCAA+D;AAE/D,+DAA+D;AAC/D,IAAM,MAAM,GAAG,wBAAe,EAA0B,CAAC;AAEzD,iCAAiC;AACjC,IAAM,MAAM,GAAG,gBAAgB,CAAC;AAEnB,QAAA,cAAc,GAAG,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,QAAQ,CAAU,CAAC;AAW3F;;;;;GAKG;AACH,SAAgB,cAAc,CAAI,QAAiB;IACjD,IAAM,MAAM,GAAG,wBAAe,EAAU,CAAC;IAEzC,IAAI,CAAC,CAAC,SAAS,IAAI,MAAM,CAAC,EAAE;QAC1B,OAAO,QAAQ,EAAE,CAAC;KACnB;IAED,IAAM,eAAe,GAAG,MAAM,CAAC,OAA4C,CAAC;IAC5E,IAAM,aAAa,GAAkC,EAAE,CAAC;IAExD,sCAAsC;IACtC,sBAAc,CAAC,OAAO,CAAC,UAAA,KAAK;QAC1B,6DAA6D;QAC7D,IAAM,mBAAmB,GACvB,eAAe,CAAC,KAAK,CAAC,IAAK,eAAe,CAAC,KAAK,CAAqB,CAAC,mBAAmB,CAAC;QAC5F,IAAI,KAAK,IAAI,MAAM,CAAC,OAAO,IAAI,mBAAmB,EAAE;YAClD,aAAa,CAAC,KAAK,CAAC,GAAG,eAAe,CAAC,KAAK,CAAuC,CAAC;YACpF,eAAe,CAAC,KAAK,CAAC,GAAG,mBAA4C,CAAC;SACvE;IACH,CAAC,CAAC,CAAC;IAEH,IAAI;QACF,OAAO,QAAQ,EAAE,CAAC;KACnB;YAAS;QACR,sCAAsC;QACtC,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,OAAO,CAAC,UAAA,KAAK;YACtC,eAAe,CAAC,KAAK,CAAC,GAAG,aAAa,CAAC,KAAsC,CAAC,CAAC;QACjF,CAAC,CAAC,CAAC;KACJ;AACH,CAAC;AA7BD,wCA6BC;AAED,SAAS,UAAU;IACjB,IAAI,OAAO,GAAG,KAAK,CAAC;IACpB,IAAM,MAAM,GAAoB;QAC9B,MAAM,EAAE;YACN,OAAO,GAAG,IAAI,CAAC;QACjB,CAAC;QACD,OAAO,EAAE;YACP,OAAO,GAAG,KAAK,CAAC;QAClB,CAAC;KACF,CAAC;IAEF,IAAI,sBAAc,EAAE;QAClB,sBAAc,CAAC,OAAO,CAAC,UAAA,IAAI;YACzB,8DAA8D;YAC9D,MAAM,CAAC,IAAI,CAAC,GAAG;gBAAC,cAAc;qBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;oBAAd,yBAAc;;gBAC5B,IAAI,OAAO,EAAE;oBACX,cAAc,CAAC;;wBACb,CAAA,KAAA,MAAM,CAAC,OAAO,CAAA,CAAC,IAAI,CAAC,6BAAI,MAAM,SAAI,IAAI,OAAI,GAAK,IAAI,GAAE;oBACvD,CAAC,CAAC,CAAC;iBACJ;YACH,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;KACJ;SAAM;QACL,sBAAc,CAAC,OAAO,CAAC,UAAA,IAAI;YACzB,MAAM,CAAC,IAAI,CAAC,GAAG,cAAM,OAAA,SAAS,EAAT,CAAS,CAAC;QACjC,CAAC,CAAC,CAAC;KACJ;IAED,OAAO,MAAgB,CAAC;AAC1B,CAAC;AAED,0GAA0G;AAC1G,IAAI,MAAc,CAAC;AAOV,wBAAM;AANf,IAAI,sBAAc,EAAE;IAClB,iBAAA,MAAM,GAAG,2BAAkB,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;CACnD;KAAM;IACL,iBAAA,MAAM,GAAG,UAAU,EAAE,CAAC;CACvB","sourcesContent":["import { WrappedFunction } from '@sentry/types';\n\nimport { IS_DEBUG_BUILD } from './flags';\nimport { getGlobalObject, getGlobalSingleton } from './global';\n\n// TODO: Implement different loggers for different environments\nconst global = getGlobalObject<Window | NodeJS.Global>();\n\n/** Prefix for logging strings */\nconst PREFIX = 'Sentry Logger ';\n\nexport const CONSOLE_LEVELS = ['debug', 'info', 'warn', 'error', 'log', 'assert'] as const;\n\ntype LoggerMethod = (...args: unknown[]) => void;\ntype LoggerConsoleMethods = Record<typeof CONSOLE_LEVELS[number], LoggerMethod>;\n\n/** JSDoc */\ninterface Logger extends LoggerConsoleMethods {\n  disable(): void;\n  enable(): void;\n}\n\n/**\n * Temporarily disable sentry console instrumentations.\n *\n * @param callback The function to run against the original `console` messages\n * @returns The results of the callback\n */\nexport function consoleSandbox<T>(callback: () => T): T {\n  const global = getGlobalObject<Window>();\n\n  if (!('console' in global)) {\n    return callback();\n  }\n\n  const originalConsole = global.console as Console & Record<string, unknown>;\n  const wrappedLevels: Partial<LoggerConsoleMethods> = {};\n\n  // Restore all wrapped console methods\n  CONSOLE_LEVELS.forEach(level => {\n    // TODO(v7): Remove this check as it's only needed for Node 6\n    const originalWrappedFunc =\n      originalConsole[level] && (originalConsole[level] as WrappedFunction).__sentry_original__;\n    if (level in global.console && originalWrappedFunc) {\n      wrappedLevels[level] = originalConsole[level] as LoggerConsoleMethods[typeof level];\n      originalConsole[level] = originalWrappedFunc as Console[typeof level];\n    }\n  });\n\n  try {\n    return callback();\n  } finally {\n    // Revert restoration to wrapped state\n    Object.keys(wrappedLevels).forEach(level => {\n      originalConsole[level] = wrappedLevels[level as typeof CONSOLE_LEVELS[number]];\n    });\n  }\n}\n\nfunction makeLogger(): Logger {\n  let enabled = false;\n  const logger: Partial<Logger> = {\n    enable: () => {\n      enabled = true;\n    },\n    disable: () => {\n      enabled = false;\n    },\n  };\n\n  if (IS_DEBUG_BUILD) {\n    CONSOLE_LEVELS.forEach(name => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      logger[name] = (...args: any[]) => {\n        if (enabled) {\n          consoleSandbox(() => {\n            global.console[name](`${PREFIX}[${name}]:`, ...args);\n          });\n        }\n      };\n    });\n  } else {\n    CONSOLE_LEVELS.forEach(name => {\n      logger[name] = () => undefined;\n    });\n  }\n\n  return logger as Logger;\n}\n\n// Ensure we only have a single logger instance, even if multiple versions of @sentry/utils are being used\nlet logger: Logger;\nif (IS_DEBUG_BUILD) {\n  logger = getGlobalSingleton('logger', makeLogger);\n} else {\n  logger = makeLogger();\n}\n\nexport { logger };\n"]}export declare type MemoFunc = [(obj: any) => boolean, (obj: any) => void];
/**
 * Helper to decycle json objects
 */
export declare function memoBuilder(): MemoFunc;
//# sourceMappingURL=memo.d.ts.map{"version":3,"file":"memo.d.ts","sourceRoot":"","sources":["../../src/memo.ts"],"names":[],"mappings":"AAGA,oBAAY,QAAQ,GAAG,CAErB,CAAC,GAAG,EAAE,GAAG,KAAK,OAAO,EAErB,CAAC,GAAG,EAAE,GAAG,KAAK,IAAI,CACnB,CAAC;AAEF;;GAEG;AACH,wBAAgB,WAAW,IAAI,QAAQ,CAmCtC"}/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Helper to decycle json objects
 */
function memoBuilder() {
    var hasWeakSet = typeof WeakSet === 'function';
    var inner = hasWeakSet ? new WeakSet() : [];
    function memoize(obj) {
        if (hasWeakSet) {
            if (inner.has(obj)) {
                return true;
            }
            inner.add(obj);
            return false;
        }
        // eslint-disable-next-line @typescript-eslint/prefer-for-of
        for (var i = 0; i < inner.length; i++) {
            var value = inner[i];
            if (value === obj) {
                return true;
            }
        }
        inner.push(obj);
        return false;
    }
    function unmemoize(obj) {
        if (hasWeakSet) {
            inner.delete(obj);
        }
        else {
            for (var i = 0; i < inner.length; i++) {
                if (inner[i] === obj) {
                    inner.splice(i, 1);
                    break;
                }
            }
        }
    }
    return [memoize, unmemoize];
}
exports.memoBuilder = memoBuilder;
//# sourceMappingURL=memo.js.map{"version":3,"file":"memo.js","sourceRoot":"","sources":["../../src/memo.ts"],"names":[],"mappings":"AAAA,+DAA+D;AAC/D,uDAAuD;;AASvD;;GAEG;AACH,SAAgB,WAAW;IACzB,IAAM,UAAU,GAAG,OAAO,OAAO,KAAK,UAAU,CAAC;IACjD,IAAM,KAAK,GAAQ,UAAU,CAAC,CAAC,CAAC,IAAI,OAAO,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;IACnD,SAAS,OAAO,CAAC,GAAQ;QACvB,IAAI,UAAU,EAAE;YACd,IAAI,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;gBAClB,OAAO,IAAI,CAAC;aACb;YACD,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YACf,OAAO,KAAK,CAAC;SACd;QACD,4DAA4D;QAC5D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACrC,IAAM,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACvB,IAAI,KAAK,KAAK,GAAG,EAAE;gBACjB,OAAO,IAAI,CAAC;aACb;SACF;QACD,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAChB,OAAO,KAAK,CAAC;IACf,CAAC;IAED,SAAS,SAAS,CAAC,GAAQ;QACzB,IAAI,UAAU,EAAE;YACd,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;SACnB;aAAM;YACL,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACrC,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;oBACpB,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;oBACnB,MAAM;iBACP;aACF;SACF;IACH,CAAC;IACD,OAAO,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;AAC9B,CAAC;AAnCD,kCAmCC","sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nexport type MemoFunc = [\n  // memoize\n  (obj: any) => boolean,\n  // unmemoize\n  (obj: any) => void,\n];\n\n/**\n * Helper to decycle json objects\n */\nexport function memoBuilder(): MemoFunc {\n  const hasWeakSet = typeof WeakSet === 'function';\n  const inner: any = hasWeakSet ? new WeakSet() : [];\n  function memoize(obj: any): boolean {\n    if (hasWeakSet) {\n      if (inner.has(obj)) {\n        return true;\n      }\n      inner.add(obj);\n      return false;\n    }\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < inner.length; i++) {\n      const value = inner[i];\n      if (value === obj) {\n        return true;\n      }\n    }\n    inner.push(obj);\n    return false;\n  }\n\n  function unmemoize(obj: any): void {\n    if (hasWeakSet) {\n      inner.delete(obj);\n    } else {\n      for (let i = 0; i < inner.length; i++) {\n        if (inner[i] === obj) {\n          inner.splice(i, 1);\n          break;\n        }\n      }\n    }\n  }\n  return [memoize, unmemoize];\n}\n"]}import { Event, Mechanism, StackFrame } from '@sentry/types';
/**
 * UUID4 generator
 *
 * @returns string Generated UUID4.
 */
export declare function uuid4(): string;
/**
 * Parses string form of URL into an object
 * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B
 * // intentionally using regex and not <a/> href parsing trick because React Native and other
 * // environments where DOM might not be available
 * @returns parsed URL object
 */
export declare function parseUrl(url: string): {
    host?: string;
    path?: string;
    protocol?: string;
    relative?: string;
};
/**
 * Extracts either message or type+value from an event that can be used for user-facing logs
 * @returns event's description
 */
export declare function getEventDescription(event: Event): string;
/**
 * Adds exception values, type and value to an synthetic Exception.
 * @param event The event to modify.
 * @param value Value of the exception.
 * @param type Type of the exception.
 * @hidden
 */
export declare function addExceptionTypeValue(event: Event, value?: string, type?: string): void;
/**
 * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.
 *
 * @param event The event to modify.
 * @param newMechanism Mechanism data to add to the event.
 * @hidden
 */
export declare function addExceptionMechanism(event: Event, newMechanism?: Partial<Mechanism>): void;
/**
 * Represents Semantic Versioning object
 */
interface SemVer {
    major?: number;
    minor?: number;
    patch?: number;
    prerelease?: string;
    buildmetadata?: string;
}
/**
 * Parses input into a SemVer interface
 * @param input string representation of a semver version
 */
export declare function parseSemver(input: string): SemVer;
/**
 * This function adds context (pre/post/line) lines to the provided frame
 *
 * @param lines string[] containing all lines
 * @param frame StackFrame that will be mutated
 * @param linesOfContext number of context lines we want to add pre/post
 */
export declare function addContextToFrame(lines: string[], frame: StackFrame, linesOfContext?: number): void;
/**
 * Strip the query string and fragment off of a given URL or path (if present)
 *
 * @param urlPath Full URL or path, including possible query string and/or fragment
 * @returns URL or path without query string or fragment
 */
export declare function stripUrlQueryAndFragment(urlPath: string): string;
/**
 * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object
 * in question), and marks it captured if not.
 *
 * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and
 * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so
 * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because
 * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not
 * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This
 * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we
 * see it.
 *
 * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on
 * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent
 * object wrapper forms so that this check will always work. However, because we need to flag the exact object which
 * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification
 * must be done before the exception captured.
 *
 * @param A thrown exception to check or flag as having been seen
 * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)
 */
export declare function checkOrSetAlreadyCaught(exception: unknown): boolean;
export {};
//# sourceMappingURL=misc.d.ts.map{"version":3,"file":"misc.d.ts","sourceRoot":"","sources":["../../src/misc.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAa,SAAS,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAaxE;;;;GAIG;AACH,wBAAgB,KAAK,IAAI,MAAM,CAoC9B;AAED;;;;;;GAMG;AACH,wBAAgB,QAAQ,CAAC,GAAG,EAAE,MAAM,GAAG;IACrC,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,QAAQ,CAAC,EAAE,MAAM,CAAC;CACnB,CAoBA;AAMD;;;GAGG;AACH,wBAAgB,mBAAmB,CAAC,KAAK,EAAE,KAAK,GAAG,MAAM,CAcxD;AAED;;;;;;GAMG;AACH,wBAAgB,qBAAqB,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE,MAAM,EAAE,IAAI,CAAC,EAAE,MAAM,GAAG,IAAI,CAUvF;AAED;;;;;;GAMG;AACH,wBAAgB,qBAAqB,CAAC,KAAK,EAAE,KAAK,EAAE,YAAY,CAAC,EAAE,OAAO,CAAC,SAAS,CAAC,GAAG,IAAI,CAc3F;AAMD;;GAEG;AACH,UAAU,MAAM;IACd,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,aAAa,CAAC,EAAE,MAAM,CAAC;CACxB;AAED;;;GAGG;AACH,wBAAgB,WAAW,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,CAYjD;AAED;;;;;;GAMG;AACH,wBAAgB,iBAAiB,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,KAAK,EAAE,UAAU,EAAE,cAAc,GAAE,MAAU,GAAG,IAAI,CActG;AAED;;;;;GAKG;AACH,wBAAgB,wBAAwB,CAAC,OAAO,EAAE,MAAM,GAAG,MAAM,CAGhE;AAED;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,wBAAgB,uBAAuB,CAAC,SAAS,EAAE,OAAO,GAAG,OAAO,CAenE"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var global_1 = require("./global");
var object_1 = require("./object");
var string_1 = require("./string");
/**
 * UUID4 generator
 *
 * @returns string Generated UUID4.
 */
function uuid4() {
    var global = global_1.getGlobalObject();
    var crypto = global.crypto || global.msCrypto;
    if (!(crypto === void 0) && crypto.getRandomValues) {
        // Use window.crypto API if available
        var arr = new Uint16Array(8);
        crypto.getRandomValues(arr);
        // set 4 in byte 7
        // eslint-disable-next-line no-bitwise
        arr[3] = (arr[3] & 0xfff) | 0x4000;
        // set 2 most significant bits of byte 9 to '10'
        // eslint-disable-next-line no-bitwise
        arr[4] = (arr[4] & 0x3fff) | 0x8000;
        var pad = function (num) {
            var v = num.toString(16);
            while (v.length < 4) {
                v = "0" + v;
            }
            return v;
        };
        return (pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]));
    }
    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
    return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        // eslint-disable-next-line no-bitwise
        var r = (Math.random() * 16) | 0;
        // eslint-disable-next-line no-bitwise
        var v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}
exports.uuid4 = uuid4;
/**
 * Parses string form of URL into an object
 * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B
 * // intentionally using regex and not <a/> href parsing trick because React Native and other
 * // environments where DOM might not be available
 * @returns parsed URL object
 */
function parseUrl(url) {
    if (!url) {
        return {};
    }
    var match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
    if (!match) {
        return {};
    }
    // coerce to undefined values to empty string so we don't get 'undefined'
    var query = match[6] || '';
    var fragment = match[8] || '';
    return {
        host: match[4],
        path: match[5],
        protocol: match[2],
        relative: match[5] + query + fragment,
    };
}
exports.parseUrl = parseUrl;
function getFirstException(event) {
    return event.exception && event.exception.values ? event.exception.values[0] : undefined;
}
/**
 * Extracts either message or type+value from an event that can be used for user-facing logs
 * @returns event's description
 */
function getEventDescription(event) {
    var message = event.message, eventId = event.event_id;
    if (message) {
        return message;
    }
    var firstException = getFirstException(event);
    if (firstException) {
        if (firstException.type && firstException.value) {
            return firstException.type + ": " + firstException.value;
        }
        return firstException.type || firstException.value || eventId || '<unknown>';
    }
    return eventId || '<unknown>';
}
exports.getEventDescription = getEventDescription;
/**
 * Adds exception values, type and value to an synthetic Exception.
 * @param event The event to modify.
 * @param value Value of the exception.
 * @param type Type of the exception.
 * @hidden
 */
function addExceptionTypeValue(event, value, type) {
    var exception = (event.exception = event.exception || {});
    var values = (exception.values = exception.values || []);
    var firstException = (values[0] = values[0] || {});
    if (!firstException.value) {
        firstException.value = value || '';
    }
    if (!firstException.type) {
        firstException.type = type || 'Error';
    }
}
exports.addExceptionTypeValue = addExceptionTypeValue;
/**
 * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.
 *
 * @param event The event to modify.
 * @param newMechanism Mechanism data to add to the event.
 * @hidden
 */
function addExceptionMechanism(event, newMechanism) {
    var firstException = getFirstException(event);
    if (!firstException) {
        return;
    }
    var defaultMechanism = { type: 'generic', handled: true };
    var currentMechanism = firstException.mechanism;
    firstException.mechanism = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, defaultMechanism), currentMechanism), newMechanism);
    if (newMechanism && 'data' in newMechanism) {
        var mergedData = tslib_1.__assign(tslib_1.__assign({}, (currentMechanism && currentMechanism.data)), newMechanism.data);
        firstException.mechanism.data = mergedData;
    }
}
exports.addExceptionMechanism = addExceptionMechanism;
// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string
var SEMVER_REGEXP = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
/**
 * Parses input into a SemVer interface
 * @param input string representation of a semver version
 */
function parseSemver(input) {
    var match = input.match(SEMVER_REGEXP) || [];
    var major = parseInt(match[1], 10);
    var minor = parseInt(match[2], 10);
    var patch = parseInt(match[3], 10);
    return {
        buildmetadata: match[5],
        major: isNaN(major) ? undefined : major,
        minor: isNaN(minor) ? undefined : minor,
        patch: isNaN(patch) ? undefined : patch,
        prerelease: match[4],
    };
}
exports.parseSemver = parseSemver;
/**
 * This function adds context (pre/post/line) lines to the provided frame
 *
 * @param lines string[] containing all lines
 * @param frame StackFrame that will be mutated
 * @param linesOfContext number of context lines we want to add pre/post
 */
function addContextToFrame(lines, frame, linesOfContext) {
    if (linesOfContext === void 0) { linesOfContext = 5; }
    var lineno = frame.lineno || 0;
    var maxLines = lines.length;
    var sourceLine = Math.max(Math.min(maxLines, lineno - 1), 0);
    frame.pre_context = lines
        .slice(Math.max(0, sourceLine - linesOfContext), sourceLine)
        .map(function (line) { return string_1.snipLine(line, 0); });
    frame.context_line = string_1.snipLine(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);
    frame.post_context = lines
        .slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext)
        .map(function (line) { return string_1.snipLine(line, 0); });
}
exports.addContextToFrame = addContextToFrame;
/**
 * Strip the query string and fragment off of a given URL or path (if present)
 *
 * @param urlPath Full URL or path, including possible query string and/or fragment
 * @returns URL or path without query string or fragment
 */
function stripUrlQueryAndFragment(urlPath) {
    // eslint-disable-next-line no-useless-escape
    return urlPath.split(/[\?#]/, 1)[0];
}
exports.stripUrlQueryAndFragment = stripUrlQueryAndFragment;
/**
 * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object
 * in question), and marks it captured if not.
 *
 * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and
 * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so
 * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because
 * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not
 * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This
 * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we
 * see it.
 *
 * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on
 * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent
 * object wrapper forms so that this check will always work. However, because we need to flag the exact object which
 * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification
 * must be done before the exception captured.
 *
 * @param A thrown exception to check or flag as having been seen
 * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)
 */
function checkOrSetAlreadyCaught(exception) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    if (exception && exception.__sentry_captured__) {
        return true;
    }
    try {
        // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the
        // `ExtraErrorData` integration
        object_1.addNonEnumerableProperty(exception, '__sentry_captured__', true);
    }
    catch (err) {
        // `exception` is a primitive, so we can't mark it seen
    }
    return false;
}
exports.checkOrSetAlreadyCaught = checkOrSetAlreadyCaught;
//# sourceMappingURL=misc.js.map{"version":3,"file":"misc.js","sourceRoot":"","sources":["../../src/misc.ts"],"names":[],"mappings":";;AAGA,mCAA2C;AAC3C,mCAAoD;AACpD,mCAAoC;AASpC;;;;GAIG;AACH,SAAgB,KAAK;IACnB,IAAM,MAAM,GAAG,wBAAe,EAAoB,CAAC;IACnD,IAAM,MAAM,GAAG,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,QAAQ,CAAC;IAEhD,IAAI,CAAC,CAAC,MAAM,KAAK,KAAK,CAAC,CAAC,IAAI,MAAM,CAAC,eAAe,EAAE;QAClD,qCAAqC;QACrC,IAAM,GAAG,GAAG,IAAI,WAAW,CAAC,CAAC,CAAC,CAAC;QAC/B,MAAM,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC;QAE5B,kBAAkB;QAClB,sCAAsC;QACtC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,MAAM,CAAC;QACnC,gDAAgD;QAChD,sCAAsC;QACtC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,GAAG,MAAM,CAAC;QAEpC,IAAM,GAAG,GAAG,UAAC,GAAW;YACtB,IAAI,CAAC,GAAG,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;YACzB,OAAO,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;gBACnB,CAAC,GAAG,MAAI,CAAG,CAAC;aACb;YACD,OAAO,CAAC,CAAC;QACX,CAAC,CAAC;QAEF,OAAO,CACL,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAC9G,CAAC;KACH;IACD,oGAAoG;IACpG,OAAO,kCAAkC,CAAC,OAAO,CAAC,OAAO,EAAE,UAAA,CAAC;QAC1D,sCAAsC;QACtC,IAAM,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC;QACnC,sCAAsC;QACtC,IAAM,CAAC,GAAG,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC;QAC1C,OAAO,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;IACxB,CAAC,CAAC,CAAC;AACL,CAAC;AApCD,sBAoCC;AAED;;;;;;GAMG;AACH,SAAgB,QAAQ,CAAC,GAAW;IAMlC,IAAI,CAAC,GAAG,EAAE;QACR,OAAO,EAAE,CAAC;KACX;IAED,IAAM,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,8DAA8D,CAAC,CAAC;IAExF,IAAI,CAAC,KAAK,EAAE;QACV,OAAO,EAAE,CAAC;KACX;IAED,yEAAyE;IACzE,IAAM,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;IAC7B,IAAM,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;IAChC,OAAO;QACL,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;QACd,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;QACd,QAAQ,EAAE,KAAK,CAAC,CAAC,CAAC;QAClB,QAAQ,EAAE,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,GAAG,QAAQ;KACtC,CAAC;AACJ,CAAC;AAzBD,4BAyBC;AAED,SAAS,iBAAiB,CAAC,KAAY;IACrC,OAAO,KAAK,CAAC,SAAS,IAAI,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;AAC3F,CAAC;AAED;;;GAGG;AACH,SAAgB,mBAAmB,CAAC,KAAY;IACtC,IAAA,uBAAO,EAAE,wBAAiB,CAAW;IAC7C,IAAI,OAAO,EAAE;QACX,OAAO,OAAO,CAAC;KAChB;IAED,IAAM,cAAc,GAAG,iBAAiB,CAAC,KAAK,CAAC,CAAC;IAChD,IAAI,cAAc,EAAE;QAClB,IAAI,cAAc,CAAC,IAAI,IAAI,cAAc,CAAC,KAAK,EAAE;YAC/C,OAAU,cAAc,CAAC,IAAI,UAAK,cAAc,CAAC,KAAO,CAAC;SAC1D;QACD,OAAO,cAAc,CAAC,IAAI,IAAI,cAAc,CAAC,KAAK,IAAI,OAAO,IAAI,WAAW,CAAC;KAC9E;IACD,OAAO,OAAO,IAAI,WAAW,CAAC;AAChC,CAAC;AAdD,kDAcC;AAED;;;;;;GAMG;AACH,SAAgB,qBAAqB,CAAC,KAAY,EAAE,KAAc,EAAE,IAAa;IAC/E,IAAM,SAAS,GAAG,CAAC,KAAK,CAAC,SAAS,GAAG,KAAK,CAAC,SAAS,IAAI,EAAE,CAAC,CAAC;IAC5D,IAAM,MAAM,GAAG,CAAC,SAAS,CAAC,MAAM,GAAG,SAAS,CAAC,MAAM,IAAI,EAAE,CAAC,CAAC;IAC3D,IAAM,cAAc,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC;IACrD,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE;QACzB,cAAc,CAAC,KAAK,GAAG,KAAK,IAAI,EAAE,CAAC;KACpC;IACD,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE;QACxB,cAAc,CAAC,IAAI,GAAG,IAAI,IAAI,OAAO,CAAC;KACvC;AACH,CAAC;AAVD,sDAUC;AAED;;;;;;GAMG;AACH,SAAgB,qBAAqB,CAAC,KAAY,EAAE,YAAiC;IACnF,IAAM,cAAc,GAAG,iBAAiB,CAAC,KAAK,CAAC,CAAC;IAChD,IAAI,CAAC,cAAc,EAAE;QACnB,OAAO;KACR;IAED,IAAM,gBAAgB,GAAG,EAAE,IAAI,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC;IAC5D,IAAM,gBAAgB,GAAG,cAAc,CAAC,SAAS,CAAC;IAClD,cAAc,CAAC,SAAS,0DAAQ,gBAAgB,GAAK,gBAAgB,GAAK,YAAY,CAAE,CAAC;IAEzF,IAAI,YAAY,IAAI,MAAM,IAAI,YAAY,EAAE;QAC1C,IAAM,UAAU,yCAAQ,CAAC,gBAAgB,IAAI,gBAAgB,CAAC,IAAI,CAAC,GAAK,YAAY,CAAC,IAAI,CAAE,CAAC;QAC5F,cAAc,CAAC,SAAS,CAAC,IAAI,GAAG,UAAU,CAAC;KAC5C;AACH,CAAC;AAdD,sDAcC;AAED,6FAA6F;AAC7F,IAAM,aAAa,GACjB,qLAAqL,CAAC;AAaxL;;;GAGG;AACH,SAAgB,WAAW,CAAC,KAAa;IACvC,IAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC;IAC/C,IAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IACrC,IAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IACrC,IAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IACrC,OAAO;QACL,aAAa,EAAE,KAAK,CAAC,CAAC,CAAC;QACvB,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK;QACvC,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK;QACvC,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK;QACvC,UAAU,EAAE,KAAK,CAAC,CAAC,CAAC;KACrB,CAAC;AACJ,CAAC;AAZD,kCAYC;AAED;;;;;;GAMG;AACH,SAAgB,iBAAiB,CAAC,KAAe,EAAE,KAAiB,EAAE,cAA0B;IAA1B,+BAAA,EAAA,kBAA0B;IAC9F,IAAM,MAAM,GAAG,KAAK,CAAC,MAAM,IAAI,CAAC,CAAC;IACjC,IAAM,QAAQ,GAAG,KAAK,CAAC,MAAM,CAAC;IAC9B,IAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAE/D,KAAK,CAAC,WAAW,GAAG,KAAK;SACtB,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,UAAU,GAAG,cAAc,CAAC,EAAE,UAAU,CAAC;SAC3D,GAAG,CAAC,UAAC,IAAY,IAAK,OAAA,iBAAQ,CAAC,IAAI,EAAE,CAAC,CAAC,EAAjB,CAAiB,CAAC,CAAC;IAE5C,KAAK,CAAC,YAAY,GAAG,iBAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,GAAG,CAAC,EAAE,UAAU,CAAC,CAAC,EAAE,KAAK,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC;IAE3F,KAAK,CAAC,YAAY,GAAG,KAAK;SACvB,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,GAAG,CAAC,EAAE,QAAQ,CAAC,EAAE,UAAU,GAAG,CAAC,GAAG,cAAc,CAAC;SAC1E,GAAG,CAAC,UAAC,IAAY,IAAK,OAAA,iBAAQ,CAAC,IAAI,EAAE,CAAC,CAAC,EAAjB,CAAiB,CAAC,CAAC;AAC9C,CAAC;AAdD,8CAcC;AAED;;;;;GAKG;AACH,SAAgB,wBAAwB,CAAC,OAAe;IACtD,6CAA6C;IAC7C,OAAO,OAAO,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC,CAAC;AAHD,4DAGC;AAED;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,SAAgB,uBAAuB,CAAC,SAAkB;IACxD,sEAAsE;IACtE,IAAI,SAAS,IAAK,SAAiB,CAAC,mBAAmB,EAAE;QACvD,OAAO,IAAI,CAAC;KACb;IAED,IAAI;QACF,6GAA6G;QAC7G,+BAA+B;QAC/B,iCAAwB,CAAC,SAAuC,EAAE,qBAAqB,EAAE,IAAI,CAAC,CAAC;KAChG;IAAC,OAAO,GAAG,EAAE;QACZ,uDAAuD;KACxD;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AAfD,0DAeC","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Event, Exception, Mechanism, StackFrame } from '@sentry/types';\n\nimport { getGlobalObject } from './global';\nimport { addNonEnumerableProperty } from './object';\nimport { snipLine } from './string';\n\n/**\n * Extended Window interface that allows for Crypto API usage in IE browsers\n */\ninterface MsCryptoWindow extends Window {\n  msCrypto?: Crypto;\n}\n\n/**\n * UUID4 generator\n *\n * @returns string Generated UUID4.\n */\nexport function uuid4(): string {\n  const global = getGlobalObject() as MsCryptoWindow;\n  const crypto = global.crypto || global.msCrypto;\n\n  if (!(crypto === void 0) && crypto.getRandomValues) {\n    // Use window.crypto API if available\n    const arr = new Uint16Array(8);\n    crypto.getRandomValues(arr);\n\n    // set 4 in byte 7\n    // eslint-disable-next-line no-bitwise\n    arr[3] = (arr[3] & 0xfff) | 0x4000;\n    // set 2 most significant bits of byte 9 to '10'\n    // eslint-disable-next-line no-bitwise\n    arr[4] = (arr[4] & 0x3fff) | 0x8000;\n\n    const pad = (num: number): string => {\n      let v = num.toString(16);\n      while (v.length < 4) {\n        v = `0${v}`;\n      }\n      return v;\n    };\n\n    return (\n      pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7])\n    );\n  }\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n  return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    // eslint-disable-next-line no-bitwise\n    const r = (Math.random() * 16) | 0;\n    // eslint-disable-next-line no-bitwise\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\n/**\n * Parses string form of URL into an object\n * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B\n * // intentionally using regex and not <a/> href parsing trick because React Native and other\n * // environments where DOM might not be available\n * @returns parsed URL object\n */\nexport function parseUrl(url: string): {\n  host?: string;\n  path?: string;\n  protocol?: string;\n  relative?: string;\n} {\n  if (!url) {\n    return {};\n  }\n\n  const match = url.match(/^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/);\n\n  if (!match) {\n    return {};\n  }\n\n  // coerce to undefined values to empty string so we don't get 'undefined'\n  const query = match[6] || '';\n  const fragment = match[8] || '';\n  return {\n    host: match[4],\n    path: match[5],\n    protocol: match[2],\n    relative: match[5] + query + fragment, // everything minus origin\n  };\n}\n\nfunction getFirstException(event: Event): Exception | undefined {\n  return event.exception && event.exception.values ? event.exception.values[0] : undefined;\n}\n\n/**\n * Extracts either message or type+value from an event that can be used for user-facing logs\n * @returns event's description\n */\nexport function getEventDescription(event: Event): string {\n  const { message, event_id: eventId } = event;\n  if (message) {\n    return message;\n  }\n\n  const firstException = getFirstException(event);\n  if (firstException) {\n    if (firstException.type && firstException.value) {\n      return `${firstException.type}: ${firstException.value}`;\n    }\n    return firstException.type || firstException.value || eventId || '<unknown>';\n  }\n  return eventId || '<unknown>';\n}\n\n/**\n * Adds exception values, type and value to an synthetic Exception.\n * @param event The event to modify.\n * @param value Value of the exception.\n * @param type Type of the exception.\n * @hidden\n */\nexport function addExceptionTypeValue(event: Event, value?: string, type?: string): void {\n  const exception = (event.exception = event.exception || {});\n  const values = (exception.values = exception.values || []);\n  const firstException = (values[0] = values[0] || {});\n  if (!firstException.value) {\n    firstException.value = value || '';\n  }\n  if (!firstException.type) {\n    firstException.type = type || 'Error';\n  }\n}\n\n/**\n * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.\n *\n * @param event The event to modify.\n * @param newMechanism Mechanism data to add to the event.\n * @hidden\n */\nexport function addExceptionMechanism(event: Event, newMechanism?: Partial<Mechanism>): void {\n  const firstException = getFirstException(event);\n  if (!firstException) {\n    return;\n  }\n\n  const defaultMechanism = { type: 'generic', handled: true };\n  const currentMechanism = firstException.mechanism;\n  firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };\n\n  if (newMechanism && 'data' in newMechanism) {\n    const mergedData = { ...(currentMechanism && currentMechanism.data), ...newMechanism.data };\n    firstException.mechanism.data = mergedData;\n  }\n}\n\n// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\nconst SEMVER_REGEXP =\n  /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/;\n\n/**\n * Represents Semantic Versioning object\n */\ninterface SemVer {\n  major?: number;\n  minor?: number;\n  patch?: number;\n  prerelease?: string;\n  buildmetadata?: string;\n}\n\n/**\n * Parses input into a SemVer interface\n * @param input string representation of a semver version\n */\nexport function parseSemver(input: string): SemVer {\n  const match = input.match(SEMVER_REGEXP) || [];\n  const major = parseInt(match[1], 10);\n  const minor = parseInt(match[2], 10);\n  const patch = parseInt(match[3], 10);\n  return {\n    buildmetadata: match[5],\n    major: isNaN(major) ? undefined : major,\n    minor: isNaN(minor) ? undefined : minor,\n    patch: isNaN(patch) ? undefined : patch,\n    prerelease: match[4],\n  };\n}\n\n/**\n * This function adds context (pre/post/line) lines to the provided frame\n *\n * @param lines string[] containing all lines\n * @param frame StackFrame that will be mutated\n * @param linesOfContext number of context lines we want to add pre/post\n */\nexport function addContextToFrame(lines: string[], frame: StackFrame, linesOfContext: number = 5): void {\n  const lineno = frame.lineno || 0;\n  const maxLines = lines.length;\n  const sourceLine = Math.max(Math.min(maxLines, lineno - 1), 0);\n\n  frame.pre_context = lines\n    .slice(Math.max(0, sourceLine - linesOfContext), sourceLine)\n    .map((line: string) => snipLine(line, 0));\n\n  frame.context_line = snipLine(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);\n\n  frame.post_context = lines\n    .slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext)\n    .map((line: string) => snipLine(line, 0));\n}\n\n/**\n * Strip the query string and fragment off of a given URL or path (if present)\n *\n * @param urlPath Full URL or path, including possible query string and/or fragment\n * @returns URL or path without query string or fragment\n */\nexport function stripUrlQueryAndFragment(urlPath: string): string {\n  // eslint-disable-next-line no-useless-escape\n  return urlPath.split(/[\\?#]/, 1)[0];\n}\n\n/**\n * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object\n * in question), and marks it captured if not.\n *\n * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and\n * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so\n * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because\n * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not\n * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This\n * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we\n * see it.\n *\n * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on\n * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent\n * object wrapper forms so that this check will always work. However, because we need to flag the exact object which\n * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification\n * must be done before the exception captured.\n *\n * @param A thrown exception to check or flag as having been seen\n * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)\n */\nexport function checkOrSetAlreadyCaught(exception: unknown): boolean {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  if (exception && (exception as any).__sentry_captured__) {\n    return true;\n  }\n\n  try {\n    // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the\n    // `ExtraErrorData` integration\n    addNonEnumerableProperty(exception as { [key: string]: unknown }, '__sentry_captured__', true);\n  } catch (err) {\n    // `exception` is a primitive, so we can't mark it seen\n  }\n\n  return false;\n}\n"]}/**
 * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
 * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
 */
/**
 * Checks whether we're in the Node.js or Browser environment
 *
 * @returns Answer to given question
 */
export declare function isNodeEnv(): boolean;
/**
 * Requires a module which is protected against bundler minification.
 *
 * @param request The module path to resolve
 */
export declare function dynamicRequire(mod: any, request: string): any;
/**
 * Helper for dynamically loading module that should work with linked dependencies.
 * The problem is that we _should_ be using `require(require.resolve(moduleName, { paths: [cwd()] }))`
 * However it's _not possible_ to do that with Webpack, as it has to know all the dependencies during
 * build time. `require.resolve` is also not available in any other way, so we cannot create,
 * a fake helper like we do with `dynamicRequire`.
 *
 * We always prefer to use local package, thus the value is not returned early from each `try/catch` block.
 * That is to mimic the behavior of `require.resolve` exactly.
 *
 * @param moduleName module name to require
 * @returns possibly required module
 */
export declare function loadModule<T>(moduleName: string): T | undefined;
//# sourceMappingURL=node.d.ts.map{"version":3,"file":"node.d.ts","sourceRoot":"","sources":["../../src/node.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAIH;;;;GAIG;AACH,wBAAgB,SAAS,IAAI,OAAO,CAOnC;AAED;;;;GAIG;AAEH,wBAAgB,cAAc,CAAC,GAAG,EAAE,GAAG,EAAE,OAAO,EAAE,MAAM,GAAG,GAAG,CAG7D;AAED;;;;;;;;;;;;GAYG;AACH,wBAAgB,UAAU,CAAC,CAAC,EAAE,UAAU,EAAE,MAAM,GAAG,CAAC,GAAG,SAAS,CAiB/D"}/**
 * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
 * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var env_1 = require("./env");
/**
 * Checks whether we're in the Node.js or Browser environment
 *
 * @returns Answer to given question
 */
function isNodeEnv() {
    // explicitly check for browser bundles as those can be optimized statically
    // by terser/rollup.
    return (!env_1.isBrowserBundle() &&
        Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]');
}
exports.isNodeEnv = isNodeEnv;
/**
 * Requires a module which is protected against bundler minification.
 *
 * @param request The module path to resolve
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
function dynamicRequire(mod, request) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    return mod.require(request);
}
exports.dynamicRequire = dynamicRequire;
/**
 * Helper for dynamically loading module that should work with linked dependencies.
 * The problem is that we _should_ be using `require(require.resolve(moduleName, { paths: [cwd()] }))`
 * However it's _not possible_ to do that with Webpack, as it has to know all the dependencies during
 * build time. `require.resolve` is also not available in any other way, so we cannot create,
 * a fake helper like we do with `dynamicRequire`.
 *
 * We always prefer to use local package, thus the value is not returned early from each `try/catch` block.
 * That is to mimic the behavior of `require.resolve` exactly.
 *
 * @param moduleName module name to require
 * @returns possibly required module
 */
function loadModule(moduleName) {
    var mod;
    try {
        mod = dynamicRequire(module, moduleName);
    }
    catch (e) {
        // no-empty
    }
    try {
        var cwd = dynamicRequire(module, 'process').cwd;
        mod = dynamicRequire(module, cwd() + "/node_modules/" + moduleName);
    }
    catch (e) {
        // no-empty
    }
    return mod;
}
exports.loadModule = loadModule;
//# sourceMappingURL=node.js.map{"version":3,"file":"node.js","sourceRoot":"","sources":["../../src/node.ts"],"names":[],"mappings":"AAAA;;;GAGG;;AAEH,6BAAwC;AAExC;;;;GAIG;AACH,SAAgB,SAAS;IACvB,4EAA4E;IAC5E,oBAAoB;IACpB,OAAO,CACL,CAAC,qBAAe,EAAE;QAClB,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,OAAO,KAAK,WAAW,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,kBAAkB,CACpG,CAAC;AACJ,CAAC;AAPD,8BAOC;AAED;;;;GAIG;AACH,iHAAiH;AACjH,SAAgB,cAAc,CAAC,GAAQ,EAAE,OAAe;IACtD,sEAAsE;IACtE,OAAO,GAAG,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;AAC9B,CAAC;AAHD,wCAGC;AAED;;;;;;;;;;;;GAYG;AACH,SAAgB,UAAU,CAAI,UAAkB;IAC9C,IAAI,GAAkB,CAAC;IAEvB,IAAI;QACF,GAAG,GAAG,cAAc,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;KAC1C;IAAC,OAAO,CAAC,EAAE;QACV,WAAW;KACZ;IAED,IAAI;QACM,IAAA,2CAAG,CAAuC;QAClD,GAAG,GAAG,cAAc,CAAC,MAAM,EAAK,GAAG,EAAE,sBAAiB,UAAY,CAAM,CAAC;KAC1E;IAAC,OAAO,CAAC,EAAE;QACV,WAAW;KACZ;IAED,OAAO,GAAG,CAAC;AACb,CAAC;AAjBD,gCAiBC","sourcesContent":["/**\n * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,\n * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.\n */\n\nimport { isBrowserBundle } from './env';\n\n/**\n * Checks whether we're in the Node.js or Browser environment\n *\n * @returns Answer to given question\n */\nexport function isNodeEnv(): boolean {\n  // explicitly check for browser bundles as those can be optimized statically\n  // by terser/rollup.\n  return (\n    !isBrowserBundle() &&\n    Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]'\n  );\n}\n\n/**\n * Requires a module which is protected against bundler minification.\n *\n * @param request The module path to resolve\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\nexport function dynamicRequire(mod: any, request: string): any {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return mod.require(request);\n}\n\n/**\n * Helper for dynamically loading module that should work with linked dependencies.\n * The problem is that we _should_ be using `require(require.resolve(moduleName, { paths: [cwd()] }))`\n * However it's _not possible_ to do that with Webpack, as it has to know all the dependencies during\n * build time. `require.resolve` is also not available in any other way, so we cannot create,\n * a fake helper like we do with `dynamicRequire`.\n *\n * We always prefer to use local package, thus the value is not returned early from each `try/catch` block.\n * That is to mimic the behavior of `require.resolve` exactly.\n *\n * @param moduleName module name to require\n * @returns possibly required module\n */\nexport function loadModule<T>(moduleName: string): T | undefined {\n  let mod: T | undefined;\n\n  try {\n    mod = dynamicRequire(module, moduleName);\n  } catch (e) {\n    // no-empty\n  }\n\n  try {\n    const { cwd } = dynamicRequire(module, 'process');\n    mod = dynamicRequire(module, `${cwd()}/node_modules/${moduleName}`) as T;\n  } catch (e) {\n    // no-empty\n  }\n\n  return mod;\n}\n"]}import { Primitive } from '@sentry/types';
import { MemoFunc } from './memo';
declare type ObjOrArray<T> = {
    [key: string]: T;
};
/**
 * Recursively normalizes the given object.
 *
 * - Creates a copy to prevent original input mutation
 * - Skips non-enumerable properties
 * - When stringifying, calls `toJSON` if implemented
 * - Removes circular references
 * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format
 * - Translates known global objects/classes to a string representations
 * - Takes care of `Error` object serialization
 * - Optionally limits depth of final output
 * - Optionally limits number of properties/elements included in any single object/array
 *
 * @param input The object to be normalized.
 * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)
 * @param maxProperties The max number of elements or properties to be included in any single array or
 * object in the normallized output..
 * @returns A normalized version of the object, or `"**non-serializable**"` if any errors are thrown during normalization.
 */
export declare function normalize(input: unknown, depth?: number, maxProperties?: number): any;
/** JSDoc */
export declare function normalizeToSize<T>(object: {
    [key: string]: any;
}, depth?: number, maxSize?: number): T;
/**
 * Visits a node to perform normalization on it
 *
 * @param key The key corresponding to the given node
 * @param value The node to be visited
 * @param depth Optional number indicating the maximum recursion depth
 * @param maxProperties Optional maximum number of properties/elements included in any single object/array
 * @param memo Optional Memo class handling decycling
 */
declare function visit(key: string, value: unknown, depth?: number, maxProperties?: number, memo?: MemoFunc): Primitive | ObjOrArray<unknown>;
export { visit as walk };
//# sourceMappingURL=normalize.d.ts.map{"version":3,"file":"normalize.d.ts","sourceRoot":"","sources":["../../src/normalize.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAG1C,OAAO,EAAe,QAAQ,EAAE,MAAM,QAAQ,CAAC;AAS/C,aAAK,UAAU,CAAC,CAAC,IAAI;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,CAAC,CAAA;CAAE,CAAC;AAE1C;;;;;;;;;;;;;;;;;;GAkBG;AACH,wBAAgB,SAAS,CAAC,KAAK,EAAE,OAAO,EAAE,KAAK,GAAE,MAAkB,EAAE,aAAa,GAAE,MAAkB,GAAG,GAAG,CAO3G;AAED,YAAY;AACZ,wBAAgB,eAAe,CAAC,CAAC,EAC/B,MAAM,EAAE;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;CAAE,EAE9B,KAAK,GAAE,MAAU,EAEjB,OAAO,GAAE,MAAmB,GAC3B,CAAC,CAQH;AAED;;;;;;;;GAQG;AACH,iBAAS,KAAK,CACZ,GAAG,EAAE,MAAM,EACX,KAAK,EAAE,OAAO,EACd,KAAK,GAAE,MAAkB,EACzB,aAAa,GAAE,MAAkB,EACjC,IAAI,GAAE,QAAwB,GAC7B,SAAS,GAAG,UAAU,CAAC,OAAO,CAAC,CAsEjC;AAGD,OAAO,EAAE,KAAK,IAAI,IAAI,EAAE,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var is_1 = require("./is");
var memo_1 = require("./memo");
var object_1 = require("./object");
var stacktrace_1 = require("./stacktrace");
/**
 * Recursively normalizes the given object.
 *
 * - Creates a copy to prevent original input mutation
 * - Skips non-enumerable properties
 * - When stringifying, calls `toJSON` if implemented
 * - Removes circular references
 * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format
 * - Translates known global objects/classes to a string representations
 * - Takes care of `Error` object serialization
 * - Optionally limits depth of final output
 * - Optionally limits number of properties/elements included in any single object/array
 *
 * @param input The object to be normalized.
 * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)
 * @param maxProperties The max number of elements or properties to be included in any single array or
 * object in the normallized output..
 * @returns A normalized version of the object, or `"**non-serializable**"` if any errors are thrown during normalization.
 */
function normalize(input, depth, maxProperties) {
    if (depth === void 0) { depth = +Infinity; }
    if (maxProperties === void 0) { maxProperties = +Infinity; }
    try {
        // since we're at the outermost level, there is no key
        return visit('', input, depth, maxProperties);
    }
    catch (err) {
        return { ERROR: "**non-serializable** (" + err + ")" };
    }
}
exports.normalize = normalize;
/** JSDoc */
function normalizeToSize(object, 
// Default Node.js REPL depth
depth, 
// 100kB, as 200kB is max payload size, so half sounds reasonable
maxSize) {
    if (depth === void 0) { depth = 3; }
    if (maxSize === void 0) { maxSize = 100 * 1024; }
    var normalized = normalize(object, depth);
    if (jsonSize(normalized) > maxSize) {
        return normalizeToSize(object, depth - 1, maxSize);
    }
    return normalized;
}
exports.normalizeToSize = normalizeToSize;
/**
 * Visits a node to perform normalization on it
 *
 * @param key The key corresponding to the given node
 * @param value The node to be visited
 * @param depth Optional number indicating the maximum recursion depth
 * @param maxProperties Optional maximum number of properties/elements included in any single object/array
 * @param memo Optional Memo class handling decycling
 */
function visit(key, value, depth, maxProperties, memo) {
    if (depth === void 0) { depth = +Infinity; }
    if (maxProperties === void 0) { maxProperties = +Infinity; }
    if (memo === void 0) { memo = memo_1.memoBuilder(); }
    var _a = tslib_1.__read(memo, 2), memoize = _a[0], unmemoize = _a[1];
    // If the value has a `toJSON` method, see if we can bail and let it do the work
    var valueWithToJSON = value;
    if (valueWithToJSON && typeof valueWithToJSON.toJSON === 'function') {
        try {
            return valueWithToJSON.toJSON();
        }
        catch (err) {
            // pass (The built-in `toJSON` failed, but we can still try to do it ourselves)
        }
    }
    // Get the simple cases out of the way first
    if (value === null || (['number', 'boolean', 'string'].includes(typeof value) && !is_1.isNaN(value))) {
        return value;
    }
    var stringified = stringifyValue(key, value);
    // Anything we could potentially dig into more (objects or arrays) will have come back as `"[object XXXX]"`.
    // Everything else will have already been serialized, so if we don't see that pattern, we're done.
    if (!stringified.startsWith('[object ')) {
        return stringified;
    }
    // We're also done if we've reached the max depth
    if (depth === 0) {
        // At this point we know `serialized` is a string of the form `"[object XXXX]"`. Clean it up so it's just `"[XXXX]"`.
        return stringified.replace('object ', '');
    }
    // If we've already visited this branch, bail out, as it's circular reference. If not, note that we're seeing it now.
    if (memoize(value)) {
        return '[Circular ~]';
    }
    // At this point we know we either have an object or an array, we haven't seen it before, and we're going to recurse
    // because we haven't yet reached the max depth. Create an accumulator to hold the results of visiting each
    // property/entry, and keep track of the number of items we add to it.
    var normalized = (Array.isArray(value) ? [] : {});
    var numAdded = 0;
    // Before we begin, convert`Error` and`Event` instances into plain objects, since some of each of their relevant
    // properties are non-enumerable and otherwise would get missed.
    var visitable = (is_1.isError(value) || is_1.isEvent(value) ? object_1.convertToPlainObject(value) : value);
    for (var visitKey in visitable) {
        // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.
        if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
            continue;
        }
        if (numAdded >= maxProperties) {
            normalized[visitKey] = '[MaxProperties ~]';
            break;
        }
        // Recursively visit all the child nodes
        var visitValue = visitable[visitKey];
        normalized[visitKey] = visit(visitKey, visitValue, depth - 1, maxProperties, memo);
        numAdded += 1;
    }
    // Once we've visited all the branches, remove the parent from memo storage
    unmemoize(value);
    // Return accumulated values
    return normalized;
}
exports.walk = visit;
/**
 * Stringify the given value. Handles various known special values and types.
 *
 * Not meant to be used on simple primitives which already have a string representation, as it will, for example, turn
 * the number 1231 into "[Object Number]", nor on `null`, as it will throw.
 *
 * @param value The value to stringify
 * @returns A stringified representation of the given value
 */
function stringifyValue(key, 
// this type is a tiny bit of a cheat, since this function does handle NaN (which is technically a number), but for
// our internal use, it'll do
value) {
    try {
        if (key === 'domain' && value && typeof value === 'object' && value._events) {
            return '[Domain]';
        }
        if (key === 'domainEmitter') {
            return '[DomainEmitter]';
        }
        // It's safe to use `global`, `window`, and `document` here in this manner, as we are asserting using `typeof` first
        // which won't throw if they are not present.
        if (typeof global !== 'undefined' && value === global) {
            return '[Global]';
        }
        // eslint-disable-next-line no-restricted-globals
        if (typeof window !== 'undefined' && value === window) {
            return '[Window]';
        }
        // eslint-disable-next-line no-restricted-globals
        if (typeof document !== 'undefined' && value === document) {
            return '[Document]';
        }
        // React's SyntheticEvent thingy
        if (is_1.isSyntheticEvent(value)) {
            return '[SyntheticEvent]';
        }
        if (typeof value === 'number' && value !== value) {
            return '[NaN]';
        }
        // this catches `undefined` (but not `null`, which is a primitive and can be serialized on its own)
        if (value === void 0) {
            return '[undefined]';
        }
        if (typeof value === 'function') {
            return "[Function: " + stacktrace_1.getFunctionName(value) + "]";
        }
        if (typeof value === 'symbol') {
            return "[" + String(value) + "]";
        }
        // stringified BigInts are indistinguishable from regular numbers, so we need to label them to avoid confusion
        if (typeof value === 'bigint') {
            return "[BigInt: " + String(value) + "]";
        }
        // Now that we've knocked out all the special cases and the primitives, all we have left are objects. Simply casting
        // them to strings means that instances of classes which haven't defined their `toStringTag` will just come out as
        // `"[object Object]"`. If we instead look at the constructor's name (which is the same as the name of the class),
        // we can make sure that only plain objects come out that way.
        return "[object " + Object.getPrototypeOf(value).constructor.name + "]";
    }
    catch (err) {
        return "**non-serializable** (" + err + ")";
    }
}
/** Calculates bytes size of input string */
function utf8Length(value) {
    // eslint-disable-next-line no-bitwise
    return ~-encodeURI(value).split(/%..|./).length;
}
/** Calculates bytes size of input object */
function jsonSize(value) {
    return utf8Length(JSON.stringify(value));
}
//# sourceMappingURL=normalize.js.map{"version":3,"file":"normalize.js","sourceRoot":"","sources":["../../src/normalize.ts"],"names":[],"mappings":";;AAEA,2BAAiE;AACjE,+BAA+C;AAC/C,mCAAgD;AAChD,2CAA+C;AAS/C;;;;;;;;;;;;;;;;;;GAkBG;AACH,SAAgB,SAAS,CAAC,KAAc,EAAE,KAAyB,EAAE,aAAiC;IAA5D,sBAAA,EAAA,SAAiB,QAAQ;IAAE,8BAAA,EAAA,iBAAyB,QAAQ;IACpG,IAAI;QACF,sDAAsD;QACtD,OAAO,KAAK,CAAC,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,aAAa,CAAC,CAAC;KAC/C;IAAC,OAAO,GAAG,EAAE;QACZ,OAAO,EAAE,KAAK,EAAE,2BAAyB,GAAG,MAAG,EAAE,CAAC;KACnD;AACH,CAAC;AAPD,8BAOC;AAED,YAAY;AACZ,SAAgB,eAAe,CAC7B,MAA8B;AAC9B,6BAA6B;AAC7B,KAAiB;AACjB,iEAAiE;AACjE,OAA4B;IAF5B,sBAAA,EAAA,SAAiB;IAEjB,wBAAA,EAAA,UAAkB,GAAG,GAAG,IAAI;IAE5B,IAAM,UAAU,GAAG,SAAS,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;IAE5C,IAAI,QAAQ,CAAC,UAAU,CAAC,GAAG,OAAO,EAAE;QAClC,OAAO,eAAe,CAAC,MAAM,EAAE,KAAK,GAAG,CAAC,EAAE,OAAO,CAAC,CAAC;KACpD;IAED,OAAO,UAAe,CAAC;AACzB,CAAC;AAdD,0CAcC;AAED;;;;;;;;GAQG;AACH,SAAS,KAAK,CACZ,GAAW,EACX,KAAc,EACd,KAAyB,EACzB,aAAiC,EACjC,IAA8B;IAF9B,sBAAA,EAAA,SAAiB,QAAQ;IACzB,8BAAA,EAAA,iBAAyB,QAAQ;IACjC,qBAAA,EAAA,OAAiB,kBAAW,EAAE;IAExB,IAAA,4BAA2B,EAA1B,eAAO,EAAE,iBAAiB,CAAC;IAElC,gFAAgF;IAChF,IAAM,eAAe,GAAG,KAAqE,CAAC;IAC9F,IAAI,eAAe,IAAI,OAAO,eAAe,CAAC,MAAM,KAAK,UAAU,EAAE;QACnE,IAAI;YACF,OAAO,eAAe,CAAC,MAAM,EAAE,CAAC;SACjC;QAAC,OAAO,GAAG,EAAE;YACZ,+EAA+E;SAChF;KACF;IAED,4CAA4C;IAC5C,IAAI,KAAK,KAAK,IAAI,IAAI,CAAC,CAAC,QAAQ,EAAE,SAAS,EAAE,QAAQ,CAAC,CAAC,QAAQ,CAAC,OAAO,KAAK,CAAC,IAAI,CAAC,UAAK,CAAC,KAAK,CAAC,CAAC,EAAE;QAC/F,OAAO,KAAkB,CAAC;KAC3B;IAED,IAAM,WAAW,GAAG,cAAc,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;IAE/C,4GAA4G;IAC5G,kGAAkG;IAClG,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,UAAU,CAAC,EAAE;QACvC,OAAO,WAAW,CAAC;KACpB;IAED,iDAAiD;IACjD,IAAI,KAAK,KAAK,CAAC,EAAE;QACf,qHAAqH;QACrH,OAAO,WAAW,CAAC,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;KAC3C;IAED,qHAAqH;IACrH,IAAI,OAAO,CAAC,KAAK,CAAC,EAAE;QAClB,OAAO,cAAc,CAAC;KACvB;IAED,oHAAoH;IACpH,2GAA2G;IAC3G,sEAAsE;IACtE,IAAM,UAAU,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAwB,CAAC;IAC3E,IAAI,QAAQ,GAAG,CAAC,CAAC;IAEjB,gHAAgH;IAChH,gEAAgE;IAChE,IAAM,SAAS,GAAG,CAAC,YAAO,CAAC,KAAK,CAAC,IAAI,YAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,6BAAoB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAwB,CAAC;IAElH,KAAK,IAAM,QAAQ,IAAI,SAAS,EAAE;QAChC,+FAA+F;QAC/F,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,SAAS,EAAE,QAAQ,CAAC,EAAE;YAC9D,SAAS;SACV;QAED,IAAI,QAAQ,IAAI,aAAa,EAAE;YAC7B,UAAU,CAAC,QAAQ,CAAC,GAAG,mBAAmB,CAAC;YAC3C,MAAM;SACP;QAED,wCAAwC;QACxC,IAAM,UAAU,GAAG,SAAS,CAAC,QAAQ,CAAC,CAAC;QACvC,UAAU,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC,QAAQ,EAAE,UAAU,EAAE,KAAK,GAAG,CAAC,EAAE,aAAa,EAAE,IAAI,CAAC,CAAC;QAEnF,QAAQ,IAAI,CAAC,CAAC;KACf;IAED,2EAA2E;IAC3E,SAAS,CAAC,KAAK,CAAC,CAAC;IAEjB,4BAA4B;IAC5B,OAAO,UAAU,CAAC;AACpB,CAAC;AAGiB,qBAAI;AAEtB;;;;;;;;GAQG;AACH,SAAS,cAAc,CACrB,GAAY;AACZ,mHAAmH;AACnH,6BAA6B;AAC7B,KAAyD;IAEzD,IAAI;QACF,IAAI,GAAG,KAAK,QAAQ,IAAI,KAAK,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAK,KAA8B,CAAC,OAAO,EAAE;YACrG,OAAO,UAAU,CAAC;SACnB;QAED,IAAI,GAAG,KAAK,eAAe,EAAE;YAC3B,OAAO,iBAAiB,CAAC;SAC1B;QAED,oHAAoH;QACpH,6CAA6C;QAE7C,IAAI,OAAO,MAAM,KAAK,WAAW,IAAI,KAAK,KAAK,MAAM,EAAE;YACrD,OAAO,UAAU,CAAC;SACnB;QAED,iDAAiD;QACjD,IAAI,OAAO,MAAM,KAAK,WAAW,IAAI,KAAK,KAAK,MAAM,EAAE;YACrD,OAAO,UAAU,CAAC;SACnB;QAED,iDAAiD;QACjD,IAAI,OAAO,QAAQ,KAAK,WAAW,IAAI,KAAK,KAAK,QAAQ,EAAE;YACzD,OAAO,YAAY,CAAC;SACrB;QAED,gCAAgC;QAChC,IAAI,qBAAgB,CAAC,KAAK,CAAC,EAAE;YAC3B,OAAO,kBAAkB,CAAC;SAC3B;QAED,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,KAAK,EAAE;YAChD,OAAO,OAAO,CAAC;SAChB;QAED,mGAAmG;QACnG,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;YACpB,OAAO,aAAa,CAAC;SACtB;QAED,IAAI,OAAO,KAAK,KAAK,UAAU,EAAE;YAC/B,OAAO,gBAAc,4BAAe,CAAC,KAAK,CAAC,MAAG,CAAC;SAChD;QAED,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;YAC7B,OAAO,MAAI,MAAM,CAAC,KAAK,CAAC,MAAG,CAAC;SAC7B;QAED,8GAA8G;QAC9G,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;YAC7B,OAAO,cAAY,MAAM,CAAC,KAAK,CAAC,MAAG,CAAC;SACrC;QAED,oHAAoH;QACpH,kHAAkH;QAClH,kHAAkH;QAClH,8DAA8D;QAC9D,OAAO,aAAY,MAAM,CAAC,cAAc,CAAC,KAAK,CAAe,CAAC,WAAW,CAAC,IAAI,MAAG,CAAC;KACnF;IAAC,OAAO,GAAG,EAAE;QACZ,OAAO,2BAAyB,GAAG,MAAG,CAAC;KACxC;AACH,CAAC;AAED,4CAA4C;AAC5C,SAAS,UAAU,CAAC,KAAa;IAC/B,sCAAsC;IACtC,OAAO,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC;AAClD,CAAC;AAED,4CAA4C;AAC5C,SAAS,QAAQ,CAAC,KAAU;IAC1B,OAAO,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;AAC3C,CAAC","sourcesContent":["import { Primitive } from '@sentry/types';\n\nimport { isError, isEvent, isNaN, isSyntheticEvent } from './is';\nimport { memoBuilder, MemoFunc } from './memo';\nimport { convertToPlainObject } from './object';\nimport { getFunctionName } from './stacktrace';\n\ntype Prototype = { constructor: (...args: unknown[]) => unknown };\n// This is a hack to placate TS, relying on the fact that technically, arrays are objects with integer keys. Normally we\n// think of those keys as actual numbers, but `arr['0']` turns out to work just as well as `arr[0]`, and doing it this\n// way lets us use a single type in the places where behave as if we are only dealing with objects, even if some of them\n// might be arrays.\ntype ObjOrArray<T> = { [key: string]: T };\n\n/**\n * Recursively normalizes the given object.\n *\n * - Creates a copy to prevent original input mutation\n * - Skips non-enumerable properties\n * - When stringifying, calls `toJSON` if implemented\n * - Removes circular references\n * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format\n * - Translates known global objects/classes to a string representations\n * - Takes care of `Error` object serialization\n * - Optionally limits depth of final output\n * - Optionally limits number of properties/elements included in any single object/array\n *\n * @param input The object to be normalized.\n * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)\n * @param maxProperties The max number of elements or properties to be included in any single array or\n * object in the normallized output..\n * @returns A normalized version of the object, or `\"**non-serializable**\"` if any errors are thrown during normalization.\n */\nexport function normalize(input: unknown, depth: number = +Infinity, maxProperties: number = +Infinity): any {\n  try {\n    // since we're at the outermost level, there is no key\n    return visit('', input, depth, maxProperties);\n  } catch (err) {\n    return { ERROR: `**non-serializable** (${err})` };\n  }\n}\n\n/** JSDoc */\nexport function normalizeToSize<T>(\n  object: { [key: string]: any },\n  // Default Node.js REPL depth\n  depth: number = 3,\n  // 100kB, as 200kB is max payload size, so half sounds reasonable\n  maxSize: number = 100 * 1024,\n): T {\n  const normalized = normalize(object, depth);\n\n  if (jsonSize(normalized) > maxSize) {\n    return normalizeToSize(object, depth - 1, maxSize);\n  }\n\n  return normalized as T;\n}\n\n/**\n * Visits a node to perform normalization on it\n *\n * @param key The key corresponding to the given node\n * @param value The node to be visited\n * @param depth Optional number indicating the maximum recursion depth\n * @param maxProperties Optional maximum number of properties/elements included in any single object/array\n * @param memo Optional Memo class handling decycling\n */\nfunction visit(\n  key: string,\n  value: unknown,\n  depth: number = +Infinity,\n  maxProperties: number = +Infinity,\n  memo: MemoFunc = memoBuilder(),\n): Primitive | ObjOrArray<unknown> {\n  const [memoize, unmemoize] = memo;\n\n  // If the value has a `toJSON` method, see if we can bail and let it do the work\n  const valueWithToJSON = value as unknown & { toJSON?: () => Primitive | ObjOrArray<unknown> };\n  if (valueWithToJSON && typeof valueWithToJSON.toJSON === 'function') {\n    try {\n      return valueWithToJSON.toJSON();\n    } catch (err) {\n      // pass (The built-in `toJSON` failed, but we can still try to do it ourselves)\n    }\n  }\n\n  // Get the simple cases out of the way first\n  if (value === null || (['number', 'boolean', 'string'].includes(typeof value) && !isNaN(value))) {\n    return value as Primitive;\n  }\n\n  const stringified = stringifyValue(key, value);\n\n  // Anything we could potentially dig into more (objects or arrays) will have come back as `\"[object XXXX]\"`.\n  // Everything else will have already been serialized, so if we don't see that pattern, we're done.\n  if (!stringified.startsWith('[object ')) {\n    return stringified;\n  }\n\n  // We're also done if we've reached the max depth\n  if (depth === 0) {\n    // At this point we know `serialized` is a string of the form `\"[object XXXX]\"`. Clean it up so it's just `\"[XXXX]\"`.\n    return stringified.replace('object ', '');\n  }\n\n  // If we've already visited this branch, bail out, as it's circular reference. If not, note that we're seeing it now.\n  if (memoize(value)) {\n    return '[Circular ~]';\n  }\n\n  // At this point we know we either have an object or an array, we haven't seen it before, and we're going to recurse\n  // because we haven't yet reached the max depth. Create an accumulator to hold the results of visiting each\n  // property/entry, and keep track of the number of items we add to it.\n  const normalized = (Array.isArray(value) ? [] : {}) as ObjOrArray<unknown>;\n  let numAdded = 0;\n\n  // Before we begin, convert`Error` and`Event` instances into plain objects, since some of each of their relevant\n  // properties are non-enumerable and otherwise would get missed.\n  const visitable = (isError(value) || isEvent(value) ? convertToPlainObject(value) : value) as ObjOrArray<unknown>;\n\n  for (const visitKey in visitable) {\n    // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.\n    if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {\n      continue;\n    }\n\n    if (numAdded >= maxProperties) {\n      normalized[visitKey] = '[MaxProperties ~]';\n      break;\n    }\n\n    // Recursively visit all the child nodes\n    const visitValue = visitable[visitKey];\n    normalized[visitKey] = visit(visitKey, visitValue, depth - 1, maxProperties, memo);\n\n    numAdded += 1;\n  }\n\n  // Once we've visited all the branches, remove the parent from memo storage\n  unmemoize(value);\n\n  // Return accumulated values\n  return normalized;\n}\n\n// TODO remove this in v7 (this means the method will no longer be exported, under any name)\nexport { visit as walk };\n\n/**\n * Stringify the given value. Handles various known special values and types.\n *\n * Not meant to be used on simple primitives which already have a string representation, as it will, for example, turn\n * the number 1231 into \"[Object Number]\", nor on `null`, as it will throw.\n *\n * @param value The value to stringify\n * @returns A stringified representation of the given value\n */\nfunction stringifyValue(\n  key: unknown,\n  // this type is a tiny bit of a cheat, since this function does handle NaN (which is technically a number), but for\n  // our internal use, it'll do\n  value: Exclude<unknown, string | number | boolean | null>,\n): string {\n  try {\n    if (key === 'domain' && value && typeof value === 'object' && (value as { _events: unknown })._events) {\n      return '[Domain]';\n    }\n\n    if (key === 'domainEmitter') {\n      return '[DomainEmitter]';\n    }\n\n    // It's safe to use `global`, `window`, and `document` here in this manner, as we are asserting using `typeof` first\n    // which won't throw if they are not present.\n\n    if (typeof global !== 'undefined' && value === global) {\n      return '[Global]';\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof window !== 'undefined' && value === window) {\n      return '[Window]';\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof document !== 'undefined' && value === document) {\n      return '[Document]';\n    }\n\n    // React's SyntheticEvent thingy\n    if (isSyntheticEvent(value)) {\n      return '[SyntheticEvent]';\n    }\n\n    if (typeof value === 'number' && value !== value) {\n      return '[NaN]';\n    }\n\n    // this catches `undefined` (but not `null`, which is a primitive and can be serialized on its own)\n    if (value === void 0) {\n      return '[undefined]';\n    }\n\n    if (typeof value === 'function') {\n      return `[Function: ${getFunctionName(value)}]`;\n    }\n\n    if (typeof value === 'symbol') {\n      return `[${String(value)}]`;\n    }\n\n    // stringified BigInts are indistinguishable from regular numbers, so we need to label them to avoid confusion\n    if (typeof value === 'bigint') {\n      return `[BigInt: ${String(value)}]`;\n    }\n\n    // Now that we've knocked out all the special cases and the primitives, all we have left are objects. Simply casting\n    // them to strings means that instances of classes which haven't defined their `toStringTag` will just come out as\n    // `\"[object Object]\"`. If we instead look at the constructor's name (which is the same as the name of the class),\n    // we can make sure that only plain objects come out that way.\n    return `[object ${(Object.getPrototypeOf(value) as Prototype).constructor.name}]`;\n  } catch (err) {\n    return `**non-serializable** (${err})`;\n  }\n}\n\n/** Calculates bytes size of input string */\nfunction utf8Length(value: string): number {\n  // eslint-disable-next-line no-bitwise\n  return ~-encodeURI(value).split(/%..|./).length;\n}\n\n/** Calculates bytes size of input object */\nfunction jsonSize(value: any): number {\n  return utf8Length(JSON.stringify(value));\n}\n"]}import { WrappedFunction } from '@sentry/types';
/**
 * Replace a method in an object with a wrapped version of itself.
 *
 * @param source An object that contains a method to be wrapped.
 * @param name The name of the method to be wrapped.
 * @param replacementFactory A higher-order function that takes the original version of the given method and returns a
 * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to
 * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other
 * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.
 * @returns void
 */
export declare function fill(source: {
    [key: string]: any;
}, name: string, replacementFactory: (...args: any[]) => any): void;
/**
 * Defines a non-enumerable property on the given object.
 *
 * @param obj The object on which to set the property
 * @param name The name of the property to be set
 * @param value The value to which to set the property
 */
export declare function addNonEnumerableProperty(obj: {
    [key: string]: unknown;
}, name: string, value: unknown): void;
/**
 * Remembers the original function on the wrapped function and
 * patches up the prototype.
 *
 * @param wrapped the wrapper function
 * @param original the original function that gets wrapped
 */
export declare function markFunctionWrapped(wrapped: WrappedFunction, original: WrappedFunction): void;
/**
 * This extracts the original function if available.  See
 * `markFunctionWrapped` for more information.
 *
 * @param func the function to unwrap
 * @returns the unwrapped version of the function if available.
 */
export declare function getOriginalFunction(func: WrappedFunction): WrappedFunction | undefined;
/**
 * Encodes given object into url-friendly format
 *
 * @param object An object that contains serializable values
 * @returns string Encoded
 */
export declare function urlEncode(object: {
    [key: string]: any;
}): string;
/**
 * Transforms any object into an object literal with all its attributes
 * attached to it.
 *
 * @param value Initial source that we have to transform in order for it to be usable by the serializer
 */
export declare function convertToPlainObject(value: unknown): {
    [key: string]: unknown;
};
/**
 * Given any captured exception, extract its keys and create a sorted
 * and truncated list that will be used inside the event message.
 * eg. `Non-error exception captured with keys: foo, bar, baz`
 */
export declare function extractExceptionKeysForMessage(exception: any, maxLength?: number): string;
/**
 * Given any object, return the new object with removed keys that value was `undefined`.
 * Works recursively on objects and arrays.
 */
export declare function dropUndefinedKeys<T>(val: T): T;
/**
 * Ensure that something is an object.
 *
 * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper
 * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.
 *
 * @param wat The subject of the objectification
 * @returns A version of `wat` which can safely be used with `Object` class methods
 */
export declare function objectify(wat: unknown): typeof Object;
//# sourceMappingURL=object.d.ts.map{"version":3,"file":"object.d.ts","sourceRoot":"","sources":["../../src/object.ts"],"names":[],"mappings":"AAEA,OAAO,EAAiB,eAAe,EAAE,MAAM,eAAe,CAAC;AAM/D;;;;;;;;;;GAUG;AACH,wBAAgB,IAAI,CAAC,MAAM,EAAE;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;CAAE,EAAE,IAAI,EAAE,MAAM,EAAE,kBAAkB,EAAE,CAAC,GAAG,IAAI,EAAE,GAAG,EAAE,KAAK,GAAG,GAAG,IAAI,CAoBpH;AAED;;;;;;GAMG;AACH,wBAAgB,wBAAwB,CAAC,GAAG,EAAE;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAAA;CAAE,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,OAAO,GAAG,IAAI,CAO5G;AAED;;;;;;GAMG;AACH,wBAAgB,mBAAmB,CAAC,OAAO,EAAE,eAAe,EAAE,QAAQ,EAAE,eAAe,GAAG,IAAI,CAI7F;AAED;;;;;;GAMG;AACH,wBAAgB,mBAAmB,CAAC,IAAI,EAAE,eAAe,GAAG,eAAe,GAAG,SAAS,CAEtF;AAED;;;;;GAKG;AACH,wBAAgB,SAAS,CAAC,MAAM,EAAE;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;CAAE,GAAG,MAAM,CAIhE;AAED;;;;;GAKG;AACH,wBAAgB,oBAAoB,CAAC,KAAK,EAAE,OAAO,GAAG;IACpD,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAAC;CACxB,CAqCA;AAsBD;;;;GAIG;AAEH,wBAAgB,8BAA8B,CAAC,SAAS,EAAE,GAAG,EAAE,SAAS,GAAE,MAAW,GAAG,MAAM,CAwB7F;AAED;;;GAGG;AACH,wBAAgB,iBAAiB,CAAC,CAAC,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,CAgB9C;AAED;;;;;;;;GAQG;AACH,wBAAgB,SAAS,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,MAAM,CA0BrD"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var browser_1 = require("./browser");
var is_1 = require("./is");
var string_1 = require("./string");
/**
 * Replace a method in an object with a wrapped version of itself.
 *
 * @param source An object that contains a method to be wrapped.
 * @param name The name of the method to be wrapped.
 * @param replacementFactory A higher-order function that takes the original version of the given method and returns a
 * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to
 * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other
 * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.
 * @returns void
 */
function fill(source, name, replacementFactory) {
    if (!(name in source)) {
        return;
    }
    var original = source[name];
    var wrapped = replacementFactory(original);
    // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work
    // otherwise it'll throw "TypeError: Object.defineProperties called on non-object"
    if (typeof wrapped === 'function') {
        try {
            markFunctionWrapped(wrapped, original);
        }
        catch (_Oo) {
            // This can throw if multiple fill happens on a global object like XMLHttpRequest
            // Fixes https://github.com/getsentry/sentry-javascript/issues/2043
        }
    }
    source[name] = wrapped;
}
exports.fill = fill;
/**
 * Defines a non-enumerable property on the given object.
 *
 * @param obj The object on which to set the property
 * @param name The name of the property to be set
 * @param value The value to which to set the property
 */
function addNonEnumerableProperty(obj, name, value) {
    Object.defineProperty(obj, name, {
        // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
        value: value,
        writable: true,
        configurable: true,
    });
}
exports.addNonEnumerableProperty = addNonEnumerableProperty;
/**
 * Remembers the original function on the wrapped function and
 * patches up the prototype.
 *
 * @param wrapped the wrapper function
 * @param original the original function that gets wrapped
 */
function markFunctionWrapped(wrapped, original) {
    var proto = original.prototype || {};
    wrapped.prototype = original.prototype = proto;
    addNonEnumerableProperty(wrapped, '__sentry_original__', original);
}
exports.markFunctionWrapped = markFunctionWrapped;
/**
 * This extracts the original function if available.  See
 * `markFunctionWrapped` for more information.
 *
 * @param func the function to unwrap
 * @returns the unwrapped version of the function if available.
 */
function getOriginalFunction(func) {
    return func.__sentry_original__;
}
exports.getOriginalFunction = getOriginalFunction;
/**
 * Encodes given object into url-friendly format
 *
 * @param object An object that contains serializable values
 * @returns string Encoded
 */
function urlEncode(object) {
    return Object.keys(object)
        .map(function (key) { return encodeURIComponent(key) + "=" + encodeURIComponent(object[key]); })
        .join('&');
}
exports.urlEncode = urlEncode;
/**
 * Transforms any object into an object literal with all its attributes
 * attached to it.
 *
 * @param value Initial source that we have to transform in order for it to be usable by the serializer
 */
function convertToPlainObject(value) {
    var newObj = value;
    if (is_1.isError(value)) {
        newObj = tslib_1.__assign({ message: value.message, name: value.name, stack: value.stack }, getOwnProperties(value));
    }
    else if (is_1.isEvent(value)) {
        var event_1 = value;
        newObj = tslib_1.__assign({ type: event_1.type, target: serializeEventTarget(event_1.target), currentTarget: serializeEventTarget(event_1.currentTarget) }, getOwnProperties(event_1));
        if (typeof CustomEvent !== 'undefined' && is_1.isInstanceOf(value, CustomEvent)) {
            newObj.detail = event_1.detail;
        }
    }
    return newObj;
}
exports.convertToPlainObject = convertToPlainObject;
/** Creates a string representation of the target of an `Event` object */
function serializeEventTarget(target) {
    try {
        return is_1.isElement(target) ? browser_1.htmlTreeAsString(target) : Object.prototype.toString.call(target);
    }
    catch (_oO) {
        return '<unknown>';
    }
}
/** Filters out all but an object's own properties */
function getOwnProperties(obj) {
    var extractedProps = {};
    for (var property in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, property)) {
            extractedProps[property] = obj[property];
        }
    }
    return extractedProps;
}
/**
 * Given any captured exception, extract its keys and create a sorted
 * and truncated list that will be used inside the event message.
 * eg. `Non-error exception captured with keys: foo, bar, baz`
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function extractExceptionKeysForMessage(exception, maxLength) {
    if (maxLength === void 0) { maxLength = 40; }
    var keys = Object.keys(convertToPlainObject(exception));
    keys.sort();
    if (!keys.length) {
        return '[object has no keys]';
    }
    if (keys[0].length >= maxLength) {
        return string_1.truncate(keys[0], maxLength);
    }
    for (var includedKeys = keys.length; includedKeys > 0; includedKeys--) {
        var serialized = keys.slice(0, includedKeys).join(', ');
        if (serialized.length > maxLength) {
            continue;
        }
        if (includedKeys === keys.length) {
            return serialized;
        }
        return string_1.truncate(serialized, maxLength);
    }
    return '';
}
exports.extractExceptionKeysForMessage = extractExceptionKeysForMessage;
/**
 * Given any object, return the new object with removed keys that value was `undefined`.
 * Works recursively on objects and arrays.
 */
function dropUndefinedKeys(val) {
    var e_1, _a;
    if (is_1.isPlainObject(val)) {
        var rv = {};
        try {
            for (var _b = tslib_1.__values(Object.keys(val)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                if (typeof val[key] !== 'undefined') {
                    rv[key] = dropUndefinedKeys(val[key]);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return rv;
    }
    if (Array.isArray(val)) {
        return val.map(dropUndefinedKeys);
    }
    return val;
}
exports.dropUndefinedKeys = dropUndefinedKeys;
/**
 * Ensure that something is an object.
 *
 * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper
 * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.
 *
 * @param wat The subject of the objectification
 * @returns A version of `wat` which can safely be used with `Object` class methods
 */
function objectify(wat) {
    var objectified;
    switch (true) {
        case wat === undefined || wat === null:
            objectified = new String(wat);
            break;
        // Though symbols and bigints do have wrapper classes (`Symbol` and `BigInt`, respectively), for whatever reason
        // those classes don't have constructors which can be used with the `new` keyword. We therefore need to cast each as
        // an object in order to wrap it.
        case typeof wat === 'symbol' || typeof wat === 'bigint':
            objectified = Object(wat);
            break;
        // this will catch the remaining primitives: `String`, `Number`, and `Boolean`
        case is_1.isPrimitive(wat):
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            objectified = new wat.constructor(wat);
            break;
        // by process of elimination, at this point we know that `wat` must already be an object
        default:
            objectified = wat;
            break;
    }
    return objectified;
}
exports.objectify = objectify;
//# sourceMappingURL=object.js.map{"version":3,"file":"object.js","sourceRoot":"","sources":["../../src/object.ts"],"names":[],"mappings":";;AAIA,qCAA6C;AAC7C,2BAA6F;AAC7F,mCAAoC;AAEpC;;;;;;;;;;GAUG;AACH,SAAgB,IAAI,CAAC,MAA8B,EAAE,IAAY,EAAE,kBAA2C;IAC5G,IAAI,CAAC,CAAC,IAAI,IAAI,MAAM,CAAC,EAAE;QACrB,OAAO;KACR;IAED,IAAM,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAc,CAAC;IAC3C,IAAM,OAAO,GAAG,kBAAkB,CAAC,QAAQ,CAAoB,CAAC;IAEhE,0GAA0G;IAC1G,kFAAkF;IAClF,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE;QACjC,IAAI;YACF,mBAAmB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;SACxC;QAAC,OAAO,GAAG,EAAE;YACZ,iFAAiF;YACjF,mEAAmE;SACpE;KACF;IAED,MAAM,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC;AACzB,CAAC;AApBD,oBAoBC;AAED;;;;;;GAMG;AACH,SAAgB,wBAAwB,CAAC,GAA+B,EAAE,IAAY,EAAE,KAAc;IACpG,MAAM,CAAC,cAAc,CAAC,GAAG,EAAE,IAAI,EAAE;QAC/B,gGAAgG;QAChG,KAAK,EAAE,KAAK;QACZ,QAAQ,EAAE,IAAI;QACd,YAAY,EAAE,IAAI;KACnB,CAAC,CAAC;AACL,CAAC;AAPD,4DAOC;AAED;;;;;;GAMG;AACH,SAAgB,mBAAmB,CAAC,OAAwB,EAAE,QAAyB;IACrF,IAAM,KAAK,GAAG,QAAQ,CAAC,SAAS,IAAI,EAAE,CAAC;IACvC,OAAO,CAAC,SAAS,GAAG,QAAQ,CAAC,SAAS,GAAG,KAAK,CAAC;IAC/C,wBAAwB,CAAC,OAAO,EAAE,qBAAqB,EAAE,QAAQ,CAAC,CAAC;AACrE,CAAC;AAJD,kDAIC;AAED;;;;;;GAMG;AACH,SAAgB,mBAAmB,CAAC,IAAqB;IACvD,OAAO,IAAI,CAAC,mBAAmB,CAAC;AAClC,CAAC;AAFD,kDAEC;AAED;;;;;GAKG;AACH,SAAgB,SAAS,CAAC,MAA8B;IACtD,OAAO,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;SACvB,GAAG,CAAC,UAAA,GAAG,IAAI,OAAG,kBAAkB,CAAC,GAAG,CAAC,SAAI,kBAAkB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAG,EAA/D,CAA+D,CAAC;SAC3E,IAAI,CAAC,GAAG,CAAC,CAAC;AACf,CAAC;AAJD,8BAIC;AAED;;;;;GAKG;AACH,SAAgB,oBAAoB,CAAC,KAAc;IAGjD,IAAI,MAAM,GAAG,KAEZ,CAAC;IAEF,IAAI,YAAO,CAAC,KAAK,CAAC,EAAE;QAClB,MAAM,sBACJ,OAAO,EAAE,KAAK,CAAC,OAAO,EACtB,IAAI,EAAE,KAAK,CAAC,IAAI,EAChB,KAAK,EAAE,KAAK,CAAC,KAAK,IACf,gBAAgB,CAAC,KAAsB,CAAC,CAC5C,CAAC;KACH;SAAM,IAAI,YAAO,CAAC,KAAK,CAAC,EAAE;QAWzB,IAAM,OAAK,GAAG,KAAoB,CAAC;QAEnC,MAAM,sBACJ,IAAI,EAAE,OAAK,CAAC,IAAI,EAChB,MAAM,EAAE,oBAAoB,CAAC,OAAK,CAAC,MAAM,CAAC,EAC1C,aAAa,EAAE,oBAAoB,CAAC,OAAK,CAAC,aAAa,CAAC,IACrD,gBAAgB,CAAC,OAAK,CAAC,CAC3B,CAAC;QAEF,IAAI,OAAO,WAAW,KAAK,WAAW,IAAI,iBAAY,CAAC,KAAK,EAAE,WAAW,CAAC,EAAE;YAC1E,MAAM,CAAC,MAAM,GAAG,OAAK,CAAC,MAAM,CAAC;SAC9B;KACF;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAvCD,oDAuCC;AAED,yEAAyE;AACzE,SAAS,oBAAoB,CAAC,MAAe;IAC3C,IAAI;QACF,OAAO,cAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,0BAAgB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;KAC9F;IAAC,OAAO,GAAG,EAAE;QACZ,OAAO,WAAW,CAAC;KACpB;AACH,CAAC;AAED,qDAAqD;AACrD,SAAS,gBAAgB,CAAC,GAA+B;IACvD,IAAM,cAAc,GAA+B,EAAE,CAAC;IACtD,KAAK,IAAM,QAAQ,IAAI,GAAG,EAAE;QAC1B,IAAI,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,QAAQ,CAAC,EAAE;YACvD,cAAc,CAAC,QAAQ,CAAC,GAAG,GAAG,CAAC,QAAQ,CAAC,CAAC;SAC1C;KACF;IACD,OAAO,cAAc,CAAC;AACxB,CAAC;AAED;;;;GAIG;AACH,6EAA6E;AAC7E,SAAgB,8BAA8B,CAAC,SAAc,EAAE,SAAsB;IAAtB,0BAAA,EAAA,cAAsB;IACnF,IAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,CAAC,CAAC;IAC1D,IAAI,CAAC,IAAI,EAAE,CAAC;IAEZ,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;QAChB,OAAO,sBAAsB,CAAC;KAC/B;IAED,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,SAAS,EAAE;QAC/B,OAAO,iBAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;KACrC;IAED,KAAK,IAAI,YAAY,GAAG,IAAI,CAAC,MAAM,EAAE,YAAY,GAAG,CAAC,EAAE,YAAY,EAAE,EAAE;QACrE,IAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,YAAY,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC1D,IAAI,UAAU,CAAC,MAAM,GAAG,SAAS,EAAE;YACjC,SAAS;SACV;QACD,IAAI,YAAY,KAAK,IAAI,CAAC,MAAM,EAAE;YAChC,OAAO,UAAU,CAAC;SACnB;QACD,OAAO,iBAAQ,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;KACxC;IAED,OAAO,EAAE,CAAC;AACZ,CAAC;AAxBD,wEAwBC;AAED;;;GAGG;AACH,SAAgB,iBAAiB,CAAI,GAAM;;IACzC,IAAI,kBAAa,CAAC,GAAG,CAAC,EAAE;QACtB,IAAM,EAAE,GAA2B,EAAE,CAAC;;YACtC,KAAkB,IAAA,KAAA,iBAAA,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA,gBAAA,4BAAE;gBAA/B,IAAM,GAAG,WAAA;gBACZ,IAAI,OAAO,GAAG,CAAC,GAAG,CAAC,KAAK,WAAW,EAAE;oBACnC,EAAE,CAAC,GAAG,CAAC,GAAG,iBAAiB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;iBACvC;aACF;;;;;;;;;QACD,OAAO,EAAO,CAAC;KAChB;IAED,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;QACtB,OAAQ,GAAa,CAAC,GAAG,CAAC,iBAAiB,CAAQ,CAAC;KACrD;IAED,OAAO,GAAG,CAAC;AACb,CAAC;AAhBD,8CAgBC;AAED;;;;;;;;GAQG;AACH,SAAgB,SAAS,CAAC,GAAY;IACpC,IAAI,WAAW,CAAC;IAChB,QAAQ,IAAI,EAAE;QACZ,KAAK,GAAG,KAAK,SAAS,IAAI,GAAG,KAAK,IAAI;YACpC,WAAW,GAAG,IAAI,MAAM,CAAC,GAAG,CAAC,CAAC;YAC9B,MAAM;QAER,gHAAgH;QAChH,oHAAoH;QACpH,iCAAiC;QACjC,KAAK,OAAO,GAAG,KAAK,QAAQ,IAAI,OAAO,GAAG,KAAK,QAAQ;YACrD,WAAW,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;YAC1B,MAAM;QAER,8EAA8E;QAC9E,KAAK,gBAAW,CAAC,GAAG,CAAC;YACnB,sEAAsE;YACtE,WAAW,GAAG,IAAK,GAAW,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;YAChD,MAAM;QAER,wFAAwF;QACxF;YACE,WAAW,GAAG,GAAG,CAAC;YAClB,MAAM;KACT;IACD,OAAO,WAAW,CAAC;AACrB,CAAC;AA1BD,8BA0BC","sourcesContent":["/* eslint-disable max-lines */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { ExtendedError, WrappedFunction } from '@sentry/types';\n\nimport { htmlTreeAsString } from './browser';\nimport { isElement, isError, isEvent, isInstanceOf, isPlainObject, isPrimitive } from './is';\nimport { truncate } from './string';\n\n/**\n * Replace a method in an object with a wrapped version of itself.\n *\n * @param source An object that contains a method to be wrapped.\n * @param name The name of the method to be wrapped.\n * @param replacementFactory A higher-order function that takes the original version of the given method and returns a\n * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to\n * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other\n * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.\n * @returns void\n */\nexport function fill(source: { [key: string]: any }, name: string, replacementFactory: (...args: any[]) => any): void {\n  if (!(name in source)) {\n    return;\n  }\n\n  const original = source[name] as () => any;\n  const wrapped = replacementFactory(original) as WrappedFunction;\n\n  // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n  // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n  if (typeof wrapped === 'function') {\n    try {\n      markFunctionWrapped(wrapped, original);\n    } catch (_Oo) {\n      // This can throw if multiple fill happens on a global object like XMLHttpRequest\n      // Fixes https://github.com/getsentry/sentry-javascript/issues/2043\n    }\n  }\n\n  source[name] = wrapped;\n}\n\n/**\n * Defines a non-enumerable property on the given object.\n *\n * @param obj The object on which to set the property\n * @param name The name of the property to be set\n * @param value The value to which to set the property\n */\nexport function addNonEnumerableProperty(obj: { [key: string]: unknown }, name: string, value: unknown): void {\n  Object.defineProperty(obj, name, {\n    // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it\n    value: value,\n    writable: true,\n    configurable: true,\n  });\n}\n\n/**\n * Remembers the original function on the wrapped function and\n * patches up the prototype.\n *\n * @param wrapped the wrapper function\n * @param original the original function that gets wrapped\n */\nexport function markFunctionWrapped(wrapped: WrappedFunction, original: WrappedFunction): void {\n  const proto = original.prototype || {};\n  wrapped.prototype = original.prototype = proto;\n  addNonEnumerableProperty(wrapped, '__sentry_original__', original);\n}\n\n/**\n * This extracts the original function if available.  See\n * `markFunctionWrapped` for more information.\n *\n * @param func the function to unwrap\n * @returns the unwrapped version of the function if available.\n */\nexport function getOriginalFunction(func: WrappedFunction): WrappedFunction | undefined {\n  return func.__sentry_original__;\n}\n\n/**\n * Encodes given object into url-friendly format\n *\n * @param object An object that contains serializable values\n * @returns string Encoded\n */\nexport function urlEncode(object: { [key: string]: any }): string {\n  return Object.keys(object)\n    .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`)\n    .join('&');\n}\n\n/**\n * Transforms any object into an object literal with all its attributes\n * attached to it.\n *\n * @param value Initial source that we have to transform in order for it to be usable by the serializer\n */\nexport function convertToPlainObject(value: unknown): {\n  [key: string]: unknown;\n} {\n  let newObj = value as {\n    [key: string]: unknown;\n  };\n\n  if (isError(value)) {\n    newObj = {\n      message: value.message,\n      name: value.name,\n      stack: value.stack,\n      ...getOwnProperties(value as ExtendedError),\n    };\n  } else if (isEvent(value)) {\n    /**\n     * Event-like interface that's usable in browser and node\n     */\n    interface SimpleEvent {\n      [key: string]: unknown;\n      type: string;\n      target?: unknown;\n      currentTarget?: unknown;\n    }\n\n    const event = value as SimpleEvent;\n\n    newObj = {\n      type: event.type,\n      target: serializeEventTarget(event.target),\n      currentTarget: serializeEventTarget(event.currentTarget),\n      ...getOwnProperties(event),\n    };\n\n    if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {\n      newObj.detail = event.detail;\n    }\n  }\n  return newObj;\n}\n\n/** Creates a string representation of the target of an `Event` object */\nfunction serializeEventTarget(target: unknown): string {\n  try {\n    return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);\n  } catch (_oO) {\n    return '<unknown>';\n  }\n}\n\n/** Filters out all but an object's own properties */\nfunction getOwnProperties(obj: { [key: string]: unknown }): { [key: string]: unknown } {\n  const extractedProps: { [key: string]: unknown } = {};\n  for (const property in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, property)) {\n      extractedProps[property] = obj[property];\n    }\n  }\n  return extractedProps;\n}\n\n/**\n * Given any captured exception, extract its keys and create a sorted\n * and truncated list that will be used inside the event message.\n * eg. `Non-error exception captured with keys: foo, bar, baz`\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function extractExceptionKeysForMessage(exception: any, maxLength: number = 40): string {\n  const keys = Object.keys(convertToPlainObject(exception));\n  keys.sort();\n\n  if (!keys.length) {\n    return '[object has no keys]';\n  }\n\n  if (keys[0].length >= maxLength) {\n    return truncate(keys[0], maxLength);\n  }\n\n  for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {\n    const serialized = keys.slice(0, includedKeys).join(', ');\n    if (serialized.length > maxLength) {\n      continue;\n    }\n    if (includedKeys === keys.length) {\n      return serialized;\n    }\n    return truncate(serialized, maxLength);\n  }\n\n  return '';\n}\n\n/**\n * Given any object, return the new object with removed keys that value was `undefined`.\n * Works recursively on objects and arrays.\n */\nexport function dropUndefinedKeys<T>(val: T): T {\n  if (isPlainObject(val)) {\n    const rv: { [key: string]: any } = {};\n    for (const key of Object.keys(val)) {\n      if (typeof val[key] !== 'undefined') {\n        rv[key] = dropUndefinedKeys(val[key]);\n      }\n    }\n    return rv as T;\n  }\n\n  if (Array.isArray(val)) {\n    return (val as any[]).map(dropUndefinedKeys) as any;\n  }\n\n  return val;\n}\n\n/**\n * Ensure that something is an object.\n *\n * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper\n * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.\n *\n * @param wat The subject of the objectification\n * @returns A version of `wat` which can safely be used with `Object` class methods\n */\nexport function objectify(wat: unknown): typeof Object {\n  let objectified;\n  switch (true) {\n    case wat === undefined || wat === null:\n      objectified = new String(wat);\n      break;\n\n    // Though symbols and bigints do have wrapper classes (`Symbol` and `BigInt`, respectively), for whatever reason\n    // those classes don't have constructors which can be used with the `new` keyword. We therefore need to cast each as\n    // an object in order to wrap it.\n    case typeof wat === 'symbol' || typeof wat === 'bigint':\n      objectified = Object(wat);\n      break;\n\n    // this will catch the remaining primitives: `String`, `Number`, and `Boolean`\n    case isPrimitive(wat):\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      objectified = new (wat as any).constructor(wat);\n      break;\n\n    // by process of elimination, at this point we know that `wat` must already be an object\n    default:\n      objectified = wat;\n      break;\n  }\n  return objectified;\n}\n"]}/** JSDoc */
export declare function resolve(...args: string[]): string;
/** JSDoc */
export declare function relative(from: string, to: string): string;
/** JSDoc */
export declare function normalizePath(path: string): string;
/** JSDoc */
export declare function isAbsolute(path: string): boolean;
/** JSDoc */
export declare function join(...args: string[]): string;
/** JSDoc */
export declare function dirname(path: string): string;
/** JSDoc */
export declare function basename(path: string, ext?: string): string;
//# sourceMappingURL=path.d.ts.map{"version":3,"file":"path.d.ts","sourceRoot":"","sources":["../../src/path.ts"],"names":[],"mappings":"AA4CA,YAAY;AACZ,wBAAgB,OAAO,CAAC,GAAG,IAAI,EAAE,MAAM,EAAE,GAAG,MAAM,CA0BjD;AA0BD,YAAY;AACZ,wBAAgB,QAAQ,CAAC,IAAI,EAAE,MAAM,EAAE,EAAE,EAAE,MAAM,GAAG,MAAM,CA0BzD;AAID,YAAY;AACZ,wBAAgB,aAAa,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,CAkBlD;AAGD,YAAY;AACZ,wBAAgB,UAAU,CAAC,IAAI,EAAE,MAAM,GAAG,OAAO,CAEhD;AAGD,YAAY;AACZ,wBAAgB,IAAI,CAAC,GAAG,IAAI,EAAE,MAAM,EAAE,GAAG,MAAM,CAE9C;AAED,YAAY;AACZ,wBAAgB,OAAO,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,CAgB5C;AAED,YAAY;AACZ,wBAAgB,QAAQ,CAAC,IAAI,EAAE,MAAM,EAAE,GAAG,CAAC,EAAE,MAAM,GAAG,MAAM,CAM3D"}// Slightly modified (no IE8 support, ES6) and transcribed to TypeScript
// https://raw.githubusercontent.com/calvinmetcalf/rollup-plugin-node-builtins/master/src/es6/path.js
Object.defineProperty(exports, "__esModule", { value: true });
/** JSDoc */
function normalizeArray(parts, allowAboveRoot) {
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
            parts.splice(i, 1);
        }
        else if (last === '..') {
            parts.splice(i, 1);
            // eslint-disable-next-line no-plusplus
            up++;
        }
        else if (up) {
            parts.splice(i, 1);
            // eslint-disable-next-line no-plusplus
            up--;
        }
    }
    // if the path is allowed to go above the root, restore leading ..s
    if (allowAboveRoot) {
        // eslint-disable-next-line no-plusplus
        for (; up--; up) {
            parts.unshift('..');
        }
    }
    return parts;
}
// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^/]+?|)(\.[^./]*|))(?:[/]*)$/;
/** JSDoc */
function splitPath(filename) {
    var parts = splitPathRe.exec(filename);
    return parts ? parts.slice(1) : [];
}
// path.resolve([from ...], to)
// posix version
/** JSDoc */
function resolve() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var resolvedPath = '';
    var resolvedAbsolute = false;
    for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? args[i] : '/';
        // Skip empty entries
        if (!path) {
            continue;
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = path.charAt(0) === '/';
    }
    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)
    // Normalize the path
    resolvedPath = normalizeArray(resolvedPath.split('/').filter(function (p) { return !!p; }), !resolvedAbsolute).join('/');
    return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
}
exports.resolve = resolve;
/** JSDoc */
function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
        if (arr[start] !== '') {
            break;
        }
    }
    var end = arr.length - 1;
    for (; end >= 0; end--) {
        if (arr[end] !== '') {
            break;
        }
    }
    if (start > end) {
        return [];
    }
    return arr.slice(start, end - start + 1);
}
// path.relative(from, to)
// posix version
/** JSDoc */
function relative(from, to) {
    /* eslint-disable no-param-reassign */
    from = resolve(from).substr(1);
    to = resolve(to).substr(1);
    /* eslint-enable no-param-reassign */
    var fromParts = trim(from.split('/'));
    var toParts = trim(to.split('/'));
    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
        }
    }
    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push('..');
    }
    outputParts = outputParts.concat(toParts.slice(samePartsLength));
    return outputParts.join('/');
}
exports.relative = relative;
// path.normalize(path)
// posix version
/** JSDoc */
function normalizePath(path) {
    var isPathAbsolute = isAbsolute(path);
    var trailingSlash = path.substr(-1) === '/';
    // Normalize the path
    var normalizedPath = normalizeArray(path.split('/').filter(function (p) { return !!p; }), !isPathAbsolute).join('/');
    if (!normalizedPath && !isPathAbsolute) {
        normalizedPath = '.';
    }
    if (normalizedPath && trailingSlash) {
        normalizedPath += '/';
    }
    return (isPathAbsolute ? '/' : '') + normalizedPath;
}
exports.normalizePath = normalizePath;
// posix version
/** JSDoc */
function isAbsolute(path) {
    return path.charAt(0) === '/';
}
exports.isAbsolute = isAbsolute;
// posix version
/** JSDoc */
function join() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return normalizePath(args.join('/'));
}
exports.join = join;
/** JSDoc */
function dirname(path) {
    var result = splitPath(path);
    var root = result[0];
    var dir = result[1];
    if (!root && !dir) {
        // No dirname whatsoever
        return '.';
    }
    if (dir) {
        // It has a dirname, strip trailing slash
        dir = dir.substr(0, dir.length - 1);
    }
    return root + dir;
}
exports.dirname = dirname;
/** JSDoc */
function basename(path, ext) {
    var f = splitPath(path)[2];
    if (ext && f.substr(ext.length * -1) === ext) {
        f = f.substr(0, f.length - ext.length);
    }
    return f;
}
exports.basename = basename;
//# sourceMappingURL=path.js.map{"version":3,"file":"path.js","sourceRoot":"","sources":["../../src/path.ts"],"names":[],"mappings":"AAAA,wEAAwE;AACxE,qGAAqG;;AAErG,YAAY;AACZ,SAAS,cAAc,CAAC,KAAe,EAAE,cAAwB;IAC/D,2DAA2D;IAC3D,IAAI,EAAE,GAAG,CAAC,CAAC;IACX,KAAK,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;QAC1C,IAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QACtB,IAAI,IAAI,KAAK,GAAG,EAAE;YAChB,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;SACpB;aAAM,IAAI,IAAI,KAAK,IAAI,EAAE;YACxB,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YACnB,uCAAuC;YACvC,EAAE,EAAE,CAAC;SACN;aAAM,IAAI,EAAE,EAAE;YACb,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YACnB,uCAAuC;YACvC,EAAE,EAAE,CAAC;SACN;KACF;IAED,mEAAmE;IACnE,IAAI,cAAc,EAAE;QAClB,uCAAuC;QACvC,OAAO,EAAE,EAAE,EAAE,EAAE,EAAE;YACf,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;SACrB;KACF;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AAED,iEAAiE;AACjE,sCAAsC;AACtC,IAAM,WAAW,GAAG,4DAA4D,CAAC;AACjF,YAAY;AACZ,SAAS,SAAS,CAAC,QAAgB;IACjC,IAAM,KAAK,GAAG,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACzC,OAAO,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;AACrC,CAAC;AAED,+BAA+B;AAC/B,gBAAgB;AAChB,YAAY;AACZ,SAAgB,OAAO;IAAC,cAAiB;SAAjB,UAAiB,EAAjB,qBAAiB,EAAjB,IAAiB;QAAjB,yBAAiB;;IACvC,IAAI,YAAY,GAAG,EAAE,CAAC;IACtB,IAAI,gBAAgB,GAAG,KAAK,CAAC;IAE7B,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,gBAAgB,EAAE,CAAC,EAAE,EAAE;QAC/D,IAAM,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;QAEpC,qBAAqB;QACrB,IAAI,CAAC,IAAI,EAAE;YACT,SAAS;SACV;QAED,YAAY,GAAM,IAAI,SAAI,YAAc,CAAC;QACzC,gBAAgB,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC;KAC3C;IAED,yEAAyE;IACzE,2EAA2E;IAE3E,qBAAqB;IACrB,YAAY,GAAG,cAAc,CAC3B,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,CAAC,EAAH,CAAG,CAAC,EACxC,CAAC,gBAAgB,CAClB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAEZ,OAAO,CAAC,gBAAgB,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,YAAY,IAAI,GAAG,CAAC;AAC7D,CAAC;AA1BD,0BA0BC;AAED,YAAY;AACZ,SAAS,IAAI,CAAC,GAAa;IACzB,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,OAAO,KAAK,GAAG,GAAG,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;QAClC,IAAI,GAAG,CAAC,KAAK,CAAC,KAAK,EAAE,EAAE;YACrB,MAAM;SACP;KACF;IAED,IAAI,GAAG,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC;IACzB,OAAO,GAAG,IAAI,CAAC,EAAE,GAAG,EAAE,EAAE;QACtB,IAAI,GAAG,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE;YACnB,MAAM;SACP;KACF;IAED,IAAI,KAAK,GAAG,GAAG,EAAE;QACf,OAAO,EAAE,CAAC;KACX;IACD,OAAO,GAAG,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,GAAG,KAAK,GAAG,CAAC,CAAC,CAAC;AAC3C,CAAC;AAED,0BAA0B;AAC1B,gBAAgB;AAChB,YAAY;AACZ,SAAgB,QAAQ,CAAC,IAAY,EAAE,EAAU;IAC/C,sCAAsC;IACtC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IAC/B,EAAE,GAAG,OAAO,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IAC3B,qCAAqC;IAErC,IAAM,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;IACxC,IAAM,OAAO,GAAG,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;IAEpC,IAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;IAC1D,IAAI,eAAe,GAAG,MAAM,CAAC;IAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;QAC/B,IAAI,SAAS,CAAC,CAAC,CAAC,KAAK,OAAO,CAAC,CAAC,CAAC,EAAE;YAC/B,eAAe,GAAG,CAAC,CAAC;YACpB,MAAM;SACP;KACF;IAED,IAAI,WAAW,GAAG,EAAE,CAAC;IACrB,KAAK,IAAI,CAAC,GAAG,eAAe,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACvD,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KACxB;IAED,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC;IAEjE,OAAO,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAC/B,CAAC;AA1BD,4BA0BC;AAED,uBAAuB;AACvB,gBAAgB;AAChB,YAAY;AACZ,SAAgB,aAAa,CAAC,IAAY;IACxC,IAAM,cAAc,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC;IACxC,IAAM,aAAa,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC;IAE9C,qBAAqB;IACrB,IAAI,cAAc,GAAG,cAAc,CACjC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,CAAC,EAAH,CAAG,CAAC,EAChC,CAAC,cAAc,CAChB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAEZ,IAAI,CAAC,cAAc,IAAI,CAAC,cAAc,EAAE;QACtC,cAAc,GAAG,GAAG,CAAC;KACtB;IACD,IAAI,cAAc,IAAI,aAAa,EAAE;QACnC,cAAc,IAAI,GAAG,CAAC;KACvB;IAED,OAAO,CAAC,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,cAAc,CAAC;AACtD,CAAC;AAlBD,sCAkBC;AAED,gBAAgB;AAChB,YAAY;AACZ,SAAgB,UAAU,CAAC,IAAY;IACrC,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC;AAChC,CAAC;AAFD,gCAEC;AAED,gBAAgB;AAChB,YAAY;AACZ,SAAgB,IAAI;IAAC,cAAiB;SAAjB,UAAiB,EAAjB,qBAAiB,EAAjB,IAAiB;QAAjB,yBAAiB;;IACpC,OAAO,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;AACvC,CAAC;AAFD,oBAEC;AAED,YAAY;AACZ,SAAgB,OAAO,CAAC,IAAY;IAClC,IAAM,MAAM,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC;IAC/B,IAAM,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;IACvB,IAAI,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;IAEpB,IAAI,CAAC,IAAI,IAAI,CAAC,GAAG,EAAE;QACjB,wBAAwB;QACxB,OAAO,GAAG,CAAC;KACZ;IAED,IAAI,GAAG,EAAE;QACP,yCAAyC;QACzC,GAAG,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;KACrC;IAED,OAAO,IAAI,GAAG,GAAG,CAAC;AACpB,CAAC;AAhBD,0BAgBC;AAED,YAAY;AACZ,SAAgB,QAAQ,CAAC,IAAY,EAAE,GAAY;IACjD,IAAI,CAAC,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3B,IAAI,GAAG,IAAI,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAC5C,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC;KACxC;IACD,OAAO,CAAC,CAAC;AACX,CAAC;AAND,4BAMC","sourcesContent":["// Slightly modified (no IE8 support, ES6) and transcribed to TypeScript\n// https://raw.githubusercontent.com/calvinmetcalf/rollup-plugin-node-builtins/master/src/es6/path.js\n\n/** JSDoc */\nfunction normalizeArray(parts: string[], allowAboveRoot?: boolean): string[] {\n  // if the path tries to go above the root, `up` ends up > 0\n  let up = 0;\n  for (let i = parts.length - 1; i >= 0; i--) {\n    const last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      // eslint-disable-next-line no-plusplus\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      // eslint-disable-next-line no-plusplus\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    // eslint-disable-next-line no-plusplus\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nconst splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^/]+?|)(\\.[^./]*|))(?:[/]*)$/;\n/** JSDoc */\nfunction splitPath(filename: string): string[] {\n  const parts = splitPathRe.exec(filename);\n  return parts ? parts.slice(1) : [];\n}\n\n// path.resolve([from ...], to)\n// posix version\n/** JSDoc */\nexport function resolve(...args: string[]): string {\n  let resolvedPath = '';\n  let resolvedAbsolute = false;\n\n  for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    const path = i >= 0 ? args[i] : '/';\n\n    // Skip empty entries\n    if (!path) {\n      continue;\n    }\n\n    resolvedPath = `${path}/${resolvedPath}`;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(\n    resolvedPath.split('/').filter(p => !!p),\n    !resolvedAbsolute,\n  ).join('/');\n\n  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n}\n\n/** JSDoc */\nfunction trim(arr: string[]): string[] {\n  let start = 0;\n  for (; start < arr.length; start++) {\n    if (arr[start] !== '') {\n      break;\n    }\n  }\n\n  let end = arr.length - 1;\n  for (; end >= 0; end--) {\n    if (arr[end] !== '') {\n      break;\n    }\n  }\n\n  if (start > end) {\n    return [];\n  }\n  return arr.slice(start, end - start + 1);\n}\n\n// path.relative(from, to)\n// posix version\n/** JSDoc */\nexport function relative(from: string, to: string): string {\n  /* eslint-disable no-param-reassign */\n  from = resolve(from).substr(1);\n  to = resolve(to).substr(1);\n  /* eslint-enable no-param-reassign */\n\n  const fromParts = trim(from.split('/'));\n  const toParts = trim(to.split('/'));\n\n  const length = Math.min(fromParts.length, toParts.length);\n  let samePartsLength = length;\n  for (let i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  let outputParts = [];\n  for (let i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n}\n\n// path.normalize(path)\n// posix version\n/** JSDoc */\nexport function normalizePath(path: string): string {\n  const isPathAbsolute = isAbsolute(path);\n  const trailingSlash = path.substr(-1) === '/';\n\n  // Normalize the path\n  let normalizedPath = normalizeArray(\n    path.split('/').filter(p => !!p),\n    !isPathAbsolute,\n  ).join('/');\n\n  if (!normalizedPath && !isPathAbsolute) {\n    normalizedPath = '.';\n  }\n  if (normalizedPath && trailingSlash) {\n    normalizedPath += '/';\n  }\n\n  return (isPathAbsolute ? '/' : '') + normalizedPath;\n}\n\n// posix version\n/** JSDoc */\nexport function isAbsolute(path: string): boolean {\n  return path.charAt(0) === '/';\n}\n\n// posix version\n/** JSDoc */\nexport function join(...args: string[]): string {\n  return normalizePath(args.join('/'));\n}\n\n/** JSDoc */\nexport function dirname(path: string): string {\n  const result = splitPath(path);\n  const root = result[0];\n  let dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n}\n\n/** JSDoc */\nexport function basename(path: string, ext?: string): string {\n  let f = splitPath(path)[2];\n  if (ext && f.substr(ext.length * -1) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n}\n"]}export declare const setPrototypeOf: (o: any, proto: object | null) => any;
//# sourceMappingURL=polyfill.d.ts.map{"version":3,"file":"polyfill.d.ts","sourceRoot":"","sources":["../../src/polyfill.ts"],"names":[],"mappings":"AAAA,eAAO,MAAM,cAAc,uCACmE,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
exports.setPrototypeOf = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
/**
 * setPrototypeOf polyfill using __proto__
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function setProtoOf(obj, proto) {
    // @ts-ignore __proto__ does not exist on obj
    obj.__proto__ = proto;
    return obj;
}
/**
 * setPrototypeOf polyfill using mixin
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function mixinProperties(obj, proto) {
    for (var prop in proto) {
        if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
            // @ts-ignore typescript complains about indexing so we remove
            obj[prop] = proto[prop];
        }
    }
    return obj;
}
//# sourceMappingURL=polyfill.js.map{"version":3,"file":"polyfill.js","sourceRoot":"","sources":["../../src/polyfill.ts"],"names":[],"mappings":";AAAa,QAAA,cAAc,GACzB,MAAM,CAAC,cAAc,IAAI,CAAC,EAAE,SAAS,EAAE,EAAE,EAAE,YAAY,KAAK,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC;AAE/F;;GAEG;AACH,wDAAwD;AACxD,SAAS,UAAU,CAAiC,GAAY,EAAE,KAAa;IAC7E,6CAA6C;IAC7C,GAAG,CAAC,SAAS,GAAG,KAAK,CAAC;IACtB,OAAO,GAAuB,CAAC;AACjC,CAAC;AAED;;GAEG;AACH,wDAAwD;AACxD,SAAS,eAAe,CAAiC,GAAY,EAAE,KAAa;IAClF,KAAK,IAAM,IAAI,IAAI,KAAK,EAAE;QACxB,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,EAAE;YACpD,8DAA8D;YAC9D,GAAG,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;SACzB;KACF;IAED,OAAO,GAAuB,CAAC;AACjC,CAAC","sourcesContent":["export const setPrototypeOf =\n  Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);\n\n/**\n * setPrototypeOf polyfill using __proto__\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction setProtoOf<TTarget extends object, TProto>(obj: TTarget, proto: TProto): TTarget & TProto {\n  // @ts-ignore __proto__ does not exist on obj\n  obj.__proto__ = proto;\n  return obj as TTarget & TProto;\n}\n\n/**\n * setPrototypeOf polyfill using mixin\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction mixinProperties<TTarget extends object, TProto>(obj: TTarget, proto: TProto): TTarget & TProto {\n  for (const prop in proto) {\n    if (!Object.prototype.hasOwnProperty.call(obj, prop)) {\n      // @ts-ignore typescript complains about indexing so we remove\n      obj[prop] = proto[prop];\n    }\n  }\n\n  return obj as TTarget & TProto;\n}\n"]}export interface PromiseBuffer<T> {
    $: Array<PromiseLike<T>>;
    add(taskProducer: () => PromiseLike<T>): PromiseLike<T>;
    drain(timeout?: number): PromiseLike<boolean>;
}
/**
 * Creates an new PromiseBuffer object with the specified limit
 * @param limit max number of promises that can be stored in the buffer
 */
export declare function makePromiseBuffer<T>(limit?: number): PromiseBuffer<T>;
//# sourceMappingURL=promisebuffer.d.ts.map{"version":3,"file":"promisebuffer.d.ts","sourceRoot":"","sources":["../../src/promisebuffer.ts"],"names":[],"mappings":"AAGA,MAAM,WAAW,aAAa,CAAC,CAAC;IAG9B,CAAC,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;IACzB,GAAG,CAAC,YAAY,EAAE,MAAM,WAAW,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;IACxD,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC;CAC/C;AAED;;;GAGG;AACH,wBAAgB,iBAAiB,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE,MAAM,GAAG,aAAa,CAAC,CAAC,CAAC,CA4FrE"}Object.defineProperty(exports, "__esModule", { value: true });
var error_1 = require("./error");
var syncpromise_1 = require("./syncpromise");
/**
 * Creates an new PromiseBuffer object with the specified limit
 * @param limit max number of promises that can be stored in the buffer
 */
function makePromiseBuffer(limit) {
    var buffer = [];
    function isReady() {
        return limit === undefined || buffer.length < limit;
    }
    /**
     * Remove a promise from the queue.
     *
     * @param task Can be any PromiseLike<T>
     * @returns Removed promise.
     */
    function remove(task) {
        return buffer.splice(buffer.indexOf(task), 1)[0];
    }
    /**
     * Add a promise (representing an in-flight action) to the queue, and set it to remove itself on fulfillment.
     *
     * @param taskProducer A function producing any PromiseLike<T>; In previous versions this used to be `task:
     *        PromiseLike<T>`, but under that model, Promises were instantly created on the call-site and their executor
     *        functions therefore ran immediately. Thus, even if the buffer was full, the action still happened. By
     *        requiring the promise to be wrapped in a function, we can defer promise creation until after the buffer
     *        limit check.
     * @returns The original promise.
     */
    function add(taskProducer) {
        if (!isReady()) {
            return syncpromise_1.rejectedSyncPromise(new error_1.SentryError('Not adding Promise due to buffer limit reached.'));
        }
        // start the task and add its promise to the queue
        var task = taskProducer();
        if (buffer.indexOf(task) === -1) {
            buffer.push(task);
        }
        void task
            .then(function () { return remove(task); })
            // Use `then(null, rejectionHandler)` rather than `catch(rejectionHandler)` so that we can use `PromiseLike`
            // rather than `Promise`. `PromiseLike` doesn't have a `.catch` method, making its polyfill smaller. (ES5 didn't
            // have promises, so TS has to polyfill when down-compiling.)
            .then(null, function () {
            return remove(task).then(null, function () {
                // We have to add another catch here because `remove()` starts a new promise chain.
            });
        });
        return task;
    }
    /**
     * Wait for all promises in the queue to resolve or for timeout to expire, whichever comes first.
     *
     * @param timeout The time, in ms, after which to resolve to `false` if the queue is still non-empty. Passing `0` (or
     * not passing anything) will make the promise wait as long as it takes for the queue to drain before resolving to
     * `true`.
     * @returns A promise which will resolve to `true` if the queue is already empty or drains before the timeout, and
     * `false` otherwise
     */
    function drain(timeout) {
        return new syncpromise_1.SyncPromise(function (resolve, reject) {
            var counter = buffer.length;
            if (!counter) {
                return resolve(true);
            }
            // wait for `timeout` ms and then resolve to `false` (if not cancelled first)
            var capturedSetTimeout = setTimeout(function () {
                if (timeout && timeout > 0) {
                    resolve(false);
                }
            }, timeout);
            // if all promises resolve in time, cancel the timer and resolve to `true`
            buffer.forEach(function (item) {
                void syncpromise_1.resolvedSyncPromise(item).then(function () {
                    // eslint-disable-next-line no-plusplus
                    if (!--counter) {
                        clearTimeout(capturedSetTimeout);
                        resolve(true);
                    }
                }, reject);
            });
        });
    }
    return {
        $: buffer,
        add: add,
        drain: drain,
    };
}
exports.makePromiseBuffer = makePromiseBuffer;
//# sourceMappingURL=promisebuffer.js.map{"version":3,"file":"promisebuffer.js","sourceRoot":"","sources":["../../src/promisebuffer.ts"],"names":[],"mappings":";AAAA,iCAAsC;AACtC,6CAAsF;AAUtF;;;GAGG;AACH,SAAgB,iBAAiB,CAAI,KAAc;IACjD,IAAM,MAAM,GAA0B,EAAE,CAAC;IAEzC,SAAS,OAAO;QACd,OAAO,KAAK,KAAK,SAAS,IAAI,MAAM,CAAC,MAAM,GAAG,KAAK,CAAC;IACtD,CAAC;IAED;;;;;OAKG;IACH,SAAS,MAAM,CAAC,IAAoB;QAClC,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACnD,CAAC;IAED;;;;;;;;;OASG;IACH,SAAS,GAAG,CAAC,YAAkC;QAC7C,IAAI,CAAC,OAAO,EAAE,EAAE;YACd,OAAO,iCAAmB,CAAC,IAAI,mBAAW,CAAC,iDAAiD,CAAC,CAAC,CAAC;SAChG;QAED,kDAAkD;QAClD,IAAM,IAAI,GAAG,YAAY,EAAE,CAAC;QAC5B,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;YAC/B,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACnB;QACD,KAAK,IAAI;aACN,IAAI,CAAC,cAAM,OAAA,MAAM,CAAC,IAAI,CAAC,EAAZ,CAAY,CAAC;YACzB,4GAA4G;YAC5G,gHAAgH;YAChH,6DAA6D;aAC5D,IAAI,CAAC,IAAI,EAAE;YACV,OAAA,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE;gBACtB,mFAAmF;YACrF,CAAC,CAAC;QAFF,CAEE,CACH,CAAC;QACJ,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;;;;OAQG;IACH,SAAS,KAAK,CAAC,OAAgB;QAC7B,OAAO,IAAI,yBAAW,CAAU,UAAC,OAAO,EAAE,MAAM;YAC9C,IAAI,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC;YAE5B,IAAI,CAAC,OAAO,EAAE;gBACZ,OAAO,OAAO,CAAC,IAAI,CAAC,CAAC;aACtB;YAED,6EAA6E;YAC7E,IAAM,kBAAkB,GAAG,UAAU,CAAC;gBACpC,IAAI,OAAO,IAAI,OAAO,GAAG,CAAC,EAAE;oBAC1B,OAAO,CAAC,KAAK,CAAC,CAAC;iBAChB;YACH,CAAC,EAAE,OAAO,CAAC,CAAC;YAEZ,0EAA0E;YAC1E,MAAM,CAAC,OAAO,CAAC,UAAA,IAAI;gBACjB,KAAK,iCAAmB,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC;oBAClC,uCAAuC;oBACvC,IAAI,CAAC,EAAE,OAAO,EAAE;wBACd,YAAY,CAAC,kBAAkB,CAAC,CAAC;wBACjC,OAAO,CAAC,IAAI,CAAC,CAAC;qBACf;gBACH,CAAC,EAAE,MAAM,CAAC,CAAC;YACb,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAED,OAAO;QACL,CAAC,EAAE,MAAM;QACT,GAAG,KAAA;QACH,KAAK,OAAA;KACN,CAAC;AACJ,CAAC;AA5FD,8CA4FC","sourcesContent":["import { SentryError } from './error';\nimport { rejectedSyncPromise, resolvedSyncPromise, SyncPromise } from './syncpromise';\n\nexport interface PromiseBuffer<T> {\n  // exposes the internal array so tests can assert on the state of it.\n  // XXX: this really should not be public api.\n  $: Array<PromiseLike<T>>;\n  add(taskProducer: () => PromiseLike<T>): PromiseLike<T>;\n  drain(timeout?: number): PromiseLike<boolean>;\n}\n\n/**\n * Creates an new PromiseBuffer object with the specified limit\n * @param limit max number of promises that can be stored in the buffer\n */\nexport function makePromiseBuffer<T>(limit?: number): PromiseBuffer<T> {\n  const buffer: Array<PromiseLike<T>> = [];\n\n  function isReady(): boolean {\n    return limit === undefined || buffer.length < limit;\n  }\n\n  /**\n   * Remove a promise from the queue.\n   *\n   * @param task Can be any PromiseLike<T>\n   * @returns Removed promise.\n   */\n  function remove(task: PromiseLike<T>): PromiseLike<T> {\n    return buffer.splice(buffer.indexOf(task), 1)[0];\n  }\n\n  /**\n   * Add a promise (representing an in-flight action) to the queue, and set it to remove itself on fulfillment.\n   *\n   * @param taskProducer A function producing any PromiseLike<T>; In previous versions this used to be `task:\n   *        PromiseLike<T>`, but under that model, Promises were instantly created on the call-site and their executor\n   *        functions therefore ran immediately. Thus, even if the buffer was full, the action still happened. By\n   *        requiring the promise to be wrapped in a function, we can defer promise creation until after the buffer\n   *        limit check.\n   * @returns The original promise.\n   */\n  function add(taskProducer: () => PromiseLike<T>): PromiseLike<T> {\n    if (!isReady()) {\n      return rejectedSyncPromise(new SentryError('Not adding Promise due to buffer limit reached.'));\n    }\n\n    // start the task and add its promise to the queue\n    const task = taskProducer();\n    if (buffer.indexOf(task) === -1) {\n      buffer.push(task);\n    }\n    void task\n      .then(() => remove(task))\n      // Use `then(null, rejectionHandler)` rather than `catch(rejectionHandler)` so that we can use `PromiseLike`\n      // rather than `Promise`. `PromiseLike` doesn't have a `.catch` method, making its polyfill smaller. (ES5 didn't\n      // have promises, so TS has to polyfill when down-compiling.)\n      .then(null, () =>\n        remove(task).then(null, () => {\n          // We have to add another catch here because `remove()` starts a new promise chain.\n        }),\n      );\n    return task;\n  }\n\n  /**\n   * Wait for all promises in the queue to resolve or for timeout to expire, whichever comes first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the queue is still non-empty. Passing `0` (or\n   * not passing anything) will make the promise wait as long as it takes for the queue to drain before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if the queue is already empty or drains before the timeout, and\n   * `false` otherwise\n   */\n  function drain(timeout?: number): PromiseLike<boolean> {\n    return new SyncPromise<boolean>((resolve, reject) => {\n      let counter = buffer.length;\n\n      if (!counter) {\n        return resolve(true);\n      }\n\n      // wait for `timeout` ms and then resolve to `false` (if not cancelled first)\n      const capturedSetTimeout = setTimeout(() => {\n        if (timeout && timeout > 0) {\n          resolve(false);\n        }\n      }, timeout);\n\n      // if all promises resolve in time, cancel the timer and resolve to `true`\n      buffer.forEach(item => {\n        void resolvedSyncPromise(item).then(() => {\n          // eslint-disable-next-line no-plusplus\n          if (!--counter) {\n            clearTimeout(capturedSetTimeout);\n            resolve(true);\n          }\n        }, reject);\n      });\n    });\n  }\n\n  return {\n    $: buffer,\n    add,\n    drain,\n  };\n}\n"]}export declare type RateLimits = Record<string, number>;
export declare const DEFAULT_RETRY_AFTER: number;
/**
 * Extracts Retry-After value from the request header or returns default value
 * @param header string representation of 'Retry-After' header
 * @param now current unix timestamp
 *
 */
export declare function parseRetryAfterHeader(header: string, now?: number): number;
/**
 * Gets the time that given category is disabled until for rate limiting
 */
export declare function disabledUntil(limits: RateLimits, category: string): number;
/**
 * Checks if a category is rate limited
 */
export declare function isRateLimited(limits: RateLimits, category: string, now?: number): boolean;
/**
 * Update ratelimits from incoming headers.
 * Returns true if headers contains a non-empty rate limiting header.
 */
export declare function updateRateLimits(limits: RateLimits, headers: Record<string, string | null | undefined>, now?: number): RateLimits;
//# sourceMappingURL=ratelimit.d.ts.map{"version":3,"file":"ratelimit.d.ts","sourceRoot":"","sources":["../../src/ratelimit.ts"],"names":[],"mappings":"AACA,oBAAY,UAAU,GAAG,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;AAEhD,eAAO,MAAM,mBAAmB,QAAY,CAAC;AAE7C;;;;;GAKG;AACH,wBAAgB,qBAAqB,CAAC,MAAM,EAAE,MAAM,EAAE,GAAG,GAAE,MAAmB,GAAG,MAAM,CAYtF;AAED;;GAEG;AACH,wBAAgB,aAAa,CAAC,MAAM,EAAE,UAAU,EAAE,QAAQ,EAAE,MAAM,GAAG,MAAM,CAE1E;AAED;;GAEG;AACH,wBAAgB,aAAa,CAAC,MAAM,EAAE,UAAU,EAAE,QAAQ,EAAE,MAAM,EAAE,GAAG,GAAE,MAAmB,GAAG,OAAO,CAErG;AAED;;;GAGG;AACH,wBAAgB,gBAAgB,CAC9B,MAAM,EAAE,UAAU,EAClB,OAAO,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,GAAG,IAAI,GAAG,SAAS,CAAC,EAClD,GAAG,GAAE,MAAmB,GACvB,UAAU,CAwCZ"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
exports.DEFAULT_RETRY_AFTER = 60 * 1000; // 60 seconds
/**
 * Extracts Retry-After value from the request header or returns default value
 * @param header string representation of 'Retry-After' header
 * @param now current unix timestamp
 *
 */
function parseRetryAfterHeader(header, now) {
    if (now === void 0) { now = Date.now(); }
    var headerDelay = parseInt("" + header, 10);
    if (!isNaN(headerDelay)) {
        return headerDelay * 1000;
    }
    var headerDate = Date.parse("" + header);
    if (!isNaN(headerDate)) {
        return headerDate - now;
    }
    return exports.DEFAULT_RETRY_AFTER;
}
exports.parseRetryAfterHeader = parseRetryAfterHeader;
/**
 * Gets the time that given category is disabled until for rate limiting
 */
function disabledUntil(limits, category) {
    return limits[category] || limits.all || 0;
}
exports.disabledUntil = disabledUntil;
/**
 * Checks if a category is rate limited
 */
function isRateLimited(limits, category, now) {
    if (now === void 0) { now = Date.now(); }
    return disabledUntil(limits, category) > now;
}
exports.isRateLimited = isRateLimited;
/**
 * Update ratelimits from incoming headers.
 * Returns true if headers contains a non-empty rate limiting header.
 */
function updateRateLimits(limits, headers, now) {
    var e_1, _a, e_2, _b;
    if (now === void 0) { now = Date.now(); }
    var updatedRateLimits = tslib_1.__assign({}, limits);
    // "The name is case-insensitive."
    // https://developer.mozilla.org/en-US/docs/Web/API/Headers/get
    var rateLimitHeader = headers['x-sentry-rate-limits'];
    var retryAfterHeader = headers['retry-after'];
    if (rateLimitHeader) {
        try {
            /**
             * rate limit headers are of the form
             *     <header>,<header>,..
             * where each <header> is of the form
             *     <retry_after>: <categories>: <scope>: <reason_code>
             * where
             *     <retry_after> is a delay in seconds
             *     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form
             *         <category>;<category>;...
             *     <scope> is what's being limited (org, project, or key) - ignored by SDK
             *     <reason_code> is an arbitrary string like "org_quota" - ignored by SDK
             */
            for (var _c = tslib_1.__values(rateLimitHeader.trim().split(',')), _d = _c.next(); !_d.done; _d = _c.next()) {
                var limit = _d.value;
                var parameters = limit.split(':', 2);
                var headerDelay = parseInt(parameters[0], 10);
                var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default
                if (!parameters[1]) {
                    updatedRateLimits.all = now + delay;
                }
                else {
                    try {
                        for (var _e = (e_2 = void 0, tslib_1.__values(parameters[1].split(';'))), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var category = _f.value;
                            updatedRateLimits[category] = now + delay;
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    else if (retryAfterHeader) {
        updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
    }
    return updatedRateLimits;
}
exports.updateRateLimits = updateRateLimits;
//# sourceMappingURL=ratelimit.js.map{"version":3,"file":"ratelimit.js","sourceRoot":"","sources":["../../src/ratelimit.ts"],"names":[],"mappings":";;AAGa,QAAA,mBAAmB,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC,aAAa;AAE3D;;;;;GAKG;AACH,SAAgB,qBAAqB,CAAC,MAAc,EAAE,GAAwB;IAAxB,oBAAA,EAAA,MAAc,IAAI,CAAC,GAAG,EAAE;IAC5E,IAAM,WAAW,GAAG,QAAQ,CAAC,KAAG,MAAQ,EAAE,EAAE,CAAC,CAAC;IAC9C,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE;QACvB,OAAO,WAAW,GAAG,IAAI,CAAC;KAC3B;IAED,IAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,KAAG,MAAQ,CAAC,CAAC;IAC3C,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE;QACtB,OAAO,UAAU,GAAG,GAAG,CAAC;KACzB;IAED,OAAO,2BAAmB,CAAC;AAC7B,CAAC;AAZD,sDAYC;AAED;;GAEG;AACH,SAAgB,aAAa,CAAC,MAAkB,EAAE,QAAgB;IAChE,OAAO,MAAM,CAAC,QAAQ,CAAC,IAAI,MAAM,CAAC,GAAG,IAAI,CAAC,CAAC;AAC7C,CAAC;AAFD,sCAEC;AAED;;GAEG;AACH,SAAgB,aAAa,CAAC,MAAkB,EAAE,QAAgB,EAAE,GAAwB;IAAxB,oBAAA,EAAA,MAAc,IAAI,CAAC,GAAG,EAAE;IAC1F,OAAO,aAAa,CAAC,MAAM,EAAE,QAAQ,CAAC,GAAG,GAAG,CAAC;AAC/C,CAAC;AAFD,sCAEC;AAED;;;GAGG;AACH,SAAgB,gBAAgB,CAC9B,MAAkB,EAClB,OAAkD,EAClD,GAAwB;;IAAxB,oBAAA,EAAA,MAAc,IAAI,CAAC,GAAG,EAAE;IAExB,IAAM,iBAAiB,wBAClB,MAAM,CACV,CAAC;IAEF,kCAAkC;IAClC,+DAA+D;IAC/D,IAAM,eAAe,GAAG,OAAO,CAAC,sBAAsB,CAAC,CAAC;IACxD,IAAM,gBAAgB,GAAG,OAAO,CAAC,aAAa,CAAC,CAAC;IAEhD,IAAI,eAAe,EAAE;;YACnB;;;;;;;;;;;eAWG;YACH,KAAoB,IAAA,KAAA,iBAAA,eAAe,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA,gBAAA,4BAAE;gBAAlD,IAAM,KAAK,WAAA;gBACd,IAAM,UAAU,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;gBACvC,IAAM,WAAW,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;gBAChD,IAAM,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC,gBAAgB;gBAC/E,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE;oBAClB,iBAAiB,CAAC,GAAG,GAAG,GAAG,GAAG,KAAK,CAAC;iBACrC;qBAAM;;wBACL,KAAuB,IAAA,oBAAA,iBAAA,UAAU,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA,CAAA,gBAAA,4BAAE;4BAA5C,IAAM,QAAQ,WAAA;4BACjB,iBAAiB,CAAC,QAAQ,CAAC,GAAG,GAAG,GAAG,KAAK,CAAC;yBAC3C;;;;;;;;;iBACF;aACF;;;;;;;;;KACF;SAAM,IAAI,gBAAgB,EAAE;QAC3B,iBAAiB,CAAC,GAAG,GAAG,GAAG,GAAG,qBAAqB,CAAC,gBAAgB,EAAE,GAAG,CAAC,CAAC;KAC5E;IAED,OAAO,iBAAiB,CAAC;AAC3B,CAAC;AA5CD,4CA4CC","sourcesContent":["// Keeping the key broad until we add the new transports\nexport type RateLimits = Record<string, number>;\n\nexport const DEFAULT_RETRY_AFTER = 60 * 1000; // 60 seconds\n\n/**\n * Extracts Retry-After value from the request header or returns default value\n * @param header string representation of 'Retry-After' header\n * @param now current unix timestamp\n *\n */\nexport function parseRetryAfterHeader(header: string, now: number = Date.now()): number {\n  const headerDelay = parseInt(`${header}`, 10);\n  if (!isNaN(headerDelay)) {\n    return headerDelay * 1000;\n  }\n\n  const headerDate = Date.parse(`${header}`);\n  if (!isNaN(headerDate)) {\n    return headerDate - now;\n  }\n\n  return DEFAULT_RETRY_AFTER;\n}\n\n/**\n * Gets the time that given category is disabled until for rate limiting\n */\nexport function disabledUntil(limits: RateLimits, category: string): number {\n  return limits[category] || limits.all || 0;\n}\n\n/**\n * Checks if a category is rate limited\n */\nexport function isRateLimited(limits: RateLimits, category: string, now: number = Date.now()): boolean {\n  return disabledUntil(limits, category) > now;\n}\n\n/**\n * Update ratelimits from incoming headers.\n * Returns true if headers contains a non-empty rate limiting header.\n */\nexport function updateRateLimits(\n  limits: RateLimits,\n  headers: Record<string, string | null | undefined>,\n  now: number = Date.now(),\n): RateLimits {\n  const updatedRateLimits: RateLimits = {\n    ...limits,\n  };\n\n  // \"The name is case-insensitive.\"\n  // https://developer.mozilla.org/en-US/docs/Web/API/Headers/get\n  const rateLimitHeader = headers['x-sentry-rate-limits'];\n  const retryAfterHeader = headers['retry-after'];\n\n  if (rateLimitHeader) {\n    /**\n     * rate limit headers are of the form\n     *     <header>,<header>,..\n     * where each <header> is of the form\n     *     <retry_after>: <categories>: <scope>: <reason_code>\n     * where\n     *     <retry_after> is a delay in seconds\n     *     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n     *         <category>;<category>;...\n     *     <scope> is what's being limited (org, project, or key) - ignored by SDK\n     *     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n     */\n    for (const limit of rateLimitHeader.trim().split(',')) {\n      const parameters = limit.split(':', 2);\n      const headerDelay = parseInt(parameters[0], 10);\n      const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n      if (!parameters[1]) {\n        updatedRateLimits.all = now + delay;\n      } else {\n        for (const category of parameters[1].split(';')) {\n          updatedRateLimits[category] = now + delay;\n        }\n      }\n    }\n  } else if (retryAfterHeader) {\n    updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);\n  }\n\n  return updatedRateLimits;\n}\n"]}import { Severity } from '@sentry/types';
import { SeverityLevel } from './enums';
/**
 * Converts a string-based level into a {@link Severity}.
 *
 * @param level string representation of Severity
 * @returns Severity
 */
export declare function severityFromString(level: SeverityLevel | string): Severity;
//# sourceMappingURL=severity.d.ts.map{"version":3,"file":"severity.d.ts","sourceRoot":"","sources":["../../src/severity.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,eAAe,CAAC;AAEzC,OAAO,EAAE,aAAa,EAAkB,MAAM,SAAS,CAAC;AAKxD;;;;;GAKG;AACH,wBAAgB,kBAAkB,CAAC,KAAK,EAAE,aAAa,GAAG,MAAM,GAAG,QAAQ,CAM1E"}Object.defineProperty(exports, "__esModule", { value: true });
var types_1 = require("@sentry/types");
var enums_1 = require("./enums");
function isSupportedSeverity(level) {
    return enums_1.SeverityLevels.indexOf(level) !== -1;
}
/**
 * Converts a string-based level into a {@link Severity}.
 *
 * @param level string representation of Severity
 * @returns Severity
 */
function severityFromString(level) {
    if (level === 'warn')
        return types_1.Severity.Warning;
    if (isSupportedSeverity(level)) {
        return level;
    }
    return types_1.Severity.Log;
}
exports.severityFromString = severityFromString;
//# sourceMappingURL=severity.js.map{"version":3,"file":"severity.js","sourceRoot":"","sources":["../../src/severity.ts"],"names":[],"mappings":";AAAA,uCAAyC;AAEzC,iCAAwD;AAExD,SAAS,mBAAmB,CAAC,KAAa;IACxC,OAAO,sBAAc,CAAC,OAAO,CAAC,KAAsB,CAAC,KAAK,CAAC,CAAC,CAAC;AAC/D,CAAC;AACD;;;;;GAKG;AACH,SAAgB,kBAAkB,CAAC,KAA6B;IAC9D,IAAI,KAAK,KAAK,MAAM;QAAE,OAAO,gBAAQ,CAAC,OAAO,CAAC;IAC9C,IAAI,mBAAmB,CAAC,KAAK,CAAC,EAAE;QAC9B,OAAO,KAAK,CAAC;KACd;IACD,OAAO,gBAAQ,CAAC,GAAG,CAAC;AACtB,CAAC;AAND,gDAMC","sourcesContent":["import { Severity } from '@sentry/types';\n\nimport { SeverityLevel, SeverityLevels } from './enums';\n\nfunction isSupportedSeverity(level: string): level is Severity {\n  return SeverityLevels.indexOf(level as SeverityLevel) !== -1;\n}\n/**\n * Converts a string-based level into a {@link Severity}.\n *\n * @param level string representation of Severity\n * @returns Severity\n */\nexport function severityFromString(level: SeverityLevel | string): Severity {\n  if (level === 'warn') return Severity.Warning;\n  if (isSupportedSeverity(level)) {\n    return level;\n  }\n  return Severity.Log;\n}\n"]}import { StackFrame } from '@sentry/types';
export declare type StackParser = (stack: string, skipFirst?: number) => StackFrame[];
export declare type StackLineParserFn = (line: string) => StackFrame | undefined;
export declare type StackLineParser = [number, StackLineParserFn];
/**
 * Creates a stack parser with the supplied line parsers
 *
 * StackFrames are returned in the correct order for Sentry Exception
 * frames and with Sentry SDK internal frames removed from the top and bottom
 *
 */
export declare function createStackParser(...parsers: StackLineParser[]): StackParser;
/**
 * @hidden
 */
export declare function stripSentryFramesAndReverse(stack: StackFrame[]): StackFrame[];
/**
 * Safely extract function name from itself
 */
export declare function getFunctionName(fn: unknown): string;
//# sourceMappingURL=stacktrace.d.ts.map{"version":3,"file":"stacktrace.d.ts","sourceRoot":"","sources":["../../src/stacktrace.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAI3C,oBAAY,WAAW,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,SAAS,CAAC,EAAE,MAAM,KAAK,UAAU,EAAE,CAAC;AAC9E,oBAAY,iBAAiB,GAAG,CAAC,IAAI,EAAE,MAAM,KAAK,UAAU,GAAG,SAAS,CAAC;AACzE,oBAAY,eAAe,GAAG,CAAC,MAAM,EAAE,iBAAiB,CAAC,CAAC;AAE1D;;;;;;GAMG;AACH,wBAAgB,iBAAiB,CAAC,GAAG,OAAO,EAAE,eAAe,EAAE,GAAG,WAAW,CAmB5E;AAED;;GAEG;AACH,wBAAgB,2BAA2B,CAAC,KAAK,EAAE,UAAU,EAAE,GAAG,UAAU,EAAE,CA6B7E;AAID;;GAEG;AACH,wBAAgB,eAAe,CAAC,EAAE,EAAE,OAAO,GAAG,MAAM,CAWnD"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var STACKTRACE_LIMIT = 50;
/**
 * Creates a stack parser with the supplied line parsers
 *
 * StackFrames are returned in the correct order for Sentry Exception
 * frames and with Sentry SDK internal frames removed from the top and bottom
 *
 */
function createStackParser() {
    var parsers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        parsers[_i] = arguments[_i];
    }
    var sortedParsers = parsers.sort(function (a, b) { return a[0] - b[0]; }).map(function (p) { return p[1]; });
    return function (stack, skipFirst) {
        var e_1, _a, e_2, _b;
        if (skipFirst === void 0) { skipFirst = 0; }
        var frames = [];
        try {
            for (var _c = tslib_1.__values(stack.split('\n').slice(skipFirst)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var line = _d.value;
                try {
                    for (var sortedParsers_1 = (e_2 = void 0, tslib_1.__values(sortedParsers)), sortedParsers_1_1 = sortedParsers_1.next(); !sortedParsers_1_1.done; sortedParsers_1_1 = sortedParsers_1.next()) {
                        var parser = sortedParsers_1_1.value;
                        var frame = parser(line);
                        if (frame) {
                            frames.push(frame);
                            break;
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (sortedParsers_1_1 && !sortedParsers_1_1.done && (_b = sortedParsers_1.return)) _b.call(sortedParsers_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return stripSentryFramesAndReverse(frames);
    };
}
exports.createStackParser = createStackParser;
/**
 * @hidden
 */
function stripSentryFramesAndReverse(stack) {
    if (!stack.length) {
        return [];
    }
    var localStack = stack;
    var firstFrameFunction = localStack[0].function || '';
    var lastFrameFunction = localStack[localStack.length - 1].function || '';
    // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)
    if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {
        localStack = localStack.slice(1);
    }
    // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)
    if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {
        localStack = localStack.slice(0, -1);
    }
    // The frame where the crash happened, should be the last entry in the array
    return localStack
        .slice(0, STACKTRACE_LIMIT)
        .map(function (frame) { return (tslib_1.__assign(tslib_1.__assign({}, frame), { filename: frame.filename || localStack[0].filename, function: frame.function || '?' })); })
        .reverse();
}
exports.stripSentryFramesAndReverse = stripSentryFramesAndReverse;
var defaultFunctionName = '<anonymous>';
/**
 * Safely extract function name from itself
 */
function getFunctionName(fn) {
    try {
        if (!fn || typeof fn !== 'function') {
            return defaultFunctionName;
        }
        return fn.name || defaultFunctionName;
    }
    catch (e) {
        // Just accessing custom props in some Selenium environments
        // can cause a "Permission denied" exception (see raven-js#495).
        return defaultFunctionName;
    }
}
exports.getFunctionName = getFunctionName;
//# sourceMappingURL=stacktrace.js.map{"version":3,"file":"stacktrace.js","sourceRoot":"","sources":["../../src/stacktrace.ts"],"names":[],"mappings":";;AAEA,IAAM,gBAAgB,GAAG,EAAE,CAAC;AAM5B;;;;;;GAMG;AACH,SAAgB,iBAAiB;IAAC,iBAA6B;SAA7B,UAA6B,EAA7B,qBAA6B,EAA7B,IAA6B;QAA7B,4BAA6B;;IAC7D,IAAM,aAAa,GAAG,OAAO,CAAC,IAAI,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAX,CAAW,CAAC,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,CAAC,CAAC,EAAJ,CAAI,CAAC,CAAC;IAEzE,OAAO,UAAC,KAAa,EAAE,SAAqB;;QAArB,0BAAA,EAAA,aAAqB;QAC1C,IAAM,MAAM,GAAiB,EAAE,CAAC;;YAEhC,KAAmB,IAAA,KAAA,iBAAA,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,CAAA,gBAAA,4BAAE;gBAAlD,IAAM,IAAI,WAAA;;oBACb,KAAqB,IAAA,iCAAA,iBAAA,aAAa,CAAA,CAAA,4CAAA,uEAAE;wBAA/B,IAAM,MAAM,0BAAA;wBACf,IAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;wBAE3B,IAAI,KAAK,EAAE;4BACT,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;4BACnB,MAAM;yBACP;qBACF;;;;;;;;;aACF;;;;;;;;;QAED,OAAO,2BAA2B,CAAC,MAAM,CAAC,CAAC;IAC7C,CAAC,CAAC;AACJ,CAAC;AAnBD,8CAmBC;AAED;;GAEG;AACH,SAAgB,2BAA2B,CAAC,KAAmB;IAC7D,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;QACjB,OAAO,EAAE,CAAC;KACX;IAED,IAAI,UAAU,GAAG,KAAK,CAAC;IAEvB,IAAM,kBAAkB,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC,QAAQ,IAAI,EAAE,CAAC;IACxD,IAAM,iBAAiB,GAAG,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,QAAQ,IAAI,EAAE,CAAC;IAE3E,mHAAmH;IACnH,IAAI,kBAAkB,CAAC,OAAO,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC,IAAI,kBAAkB,CAAC,OAAO,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC,EAAE;QAChH,UAAU,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KAClC;IAED,+HAA+H;IAC/H,IAAI,iBAAiB,CAAC,OAAO,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC,EAAE;QACrD,UAAU,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;KACtC;IAED,4EAA4E;IAC5E,OAAO,UAAU;SACd,KAAK,CAAC,CAAC,EAAE,gBAAgB,CAAC;SAC1B,GAAG,CAAC,UAAA,KAAK,IAAI,OAAA,uCACT,KAAK,KACR,QAAQ,EAAE,KAAK,CAAC,QAAQ,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,QAAQ,EAClD,QAAQ,EAAE,KAAK,CAAC,QAAQ,IAAI,GAAG,IAC/B,EAJY,CAIZ,CAAC;SACF,OAAO,EAAE,CAAC;AACf,CAAC;AA7BD,kEA6BC;AAED,IAAM,mBAAmB,GAAG,aAAa,CAAC;AAE1C;;GAEG;AACH,SAAgB,eAAe,CAAC,EAAW;IACzC,IAAI;QACF,IAAI,CAAC,EAAE,IAAI,OAAO,EAAE,KAAK,UAAU,EAAE;YACnC,OAAO,mBAAmB,CAAC;SAC5B;QACD,OAAO,EAAE,CAAC,IAAI,IAAI,mBAAmB,CAAC;KACvC;IAAC,OAAO,CAAC,EAAE;QACV,4DAA4D;QAC5D,gEAAgE;QAChE,OAAO,mBAAmB,CAAC;KAC5B;AACH,CAAC;AAXD,0CAWC","sourcesContent":["import { StackFrame } from '@sentry/types';\n\nconst STACKTRACE_LIMIT = 50;\n\nexport type StackParser = (stack: string, skipFirst?: number) => StackFrame[];\nexport type StackLineParserFn = (line: string) => StackFrame | undefined;\nexport type StackLineParser = [number, StackLineParserFn];\n\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */\nexport function createStackParser(...parsers: StackLineParser[]): StackParser {\n  const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);\n\n  return (stack: string, skipFirst: number = 0): StackFrame[] => {\n    const frames: StackFrame[] = [];\n\n    for (const line of stack.split('\\n').slice(skipFirst)) {\n      for (const parser of sortedParsers) {\n        const frame = parser(line);\n\n        if (frame) {\n          frames.push(frame);\n          break;\n        }\n      }\n    }\n\n    return stripSentryFramesAndReverse(frames);\n  };\n}\n\n/**\n * @hidden\n */\nexport function stripSentryFramesAndReverse(stack: StackFrame[]): StackFrame[] {\n  if (!stack.length) {\n    return [];\n  }\n\n  let localStack = stack;\n\n  const firstFrameFunction = localStack[0].function || '';\n  const lastFrameFunction = localStack[localStack.length - 1].function || '';\n\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  }\n\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {\n    localStack = localStack.slice(0, -1);\n  }\n\n  // The frame where the crash happened, should be the last entry in the array\n  return localStack\n    .slice(0, STACKTRACE_LIMIT)\n    .map(frame => ({\n      ...frame,\n      filename: frame.filename || localStack[0].filename,\n      function: frame.function || '?',\n    }))\n    .reverse();\n}\n\nconst defaultFunctionName = '<anonymous>';\n\n/**\n * Safely extract function name from itself\n */\nexport function getFunctionName(fn: unknown): string {\n  try {\n    if (!fn || typeof fn !== 'function') {\n      return defaultFunctionName;\n    }\n    return fn.name || defaultFunctionName;\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    return defaultFunctionName;\n  }\n}\n"]}import { EventStatus } from '@sentry/types';
/**
 * Converts an HTTP status code to sentry status {@link EventStatus}.
 *
 * @param code number HTTP status code
 * @returns EventStatus
 */
export declare function eventStatusFromHttpCode(code: number): EventStatus;
//# sourceMappingURL=status.d.ts.map{"version":3,"file":"status.d.ts","sourceRoot":"","sources":["../../src/status.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C;;;;;GAKG;AACH,wBAAgB,uBAAuB,CAAC,IAAI,EAAE,MAAM,GAAG,WAAW,CAkBjE"}Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Converts an HTTP status code to sentry status {@link EventStatus}.
 *
 * @param code number HTTP status code
 * @returns EventStatus
 */
function eventStatusFromHttpCode(code) {
    if (code >= 200 && code < 300) {
        return 'success';
    }
    if (code === 429) {
        return 'rate_limit';
    }
    if (code >= 400 && code < 500) {
        return 'invalid';
    }
    if (code >= 500) {
        return 'failed';
    }
    return 'unknown';
}
exports.eventStatusFromHttpCode = eventStatusFromHttpCode;
//# sourceMappingURL=status.js.map{"version":3,"file":"status.js","sourceRoot":"","sources":["../../src/status.ts"],"names":[],"mappings":";AACA;;;;;GAKG;AACH,SAAgB,uBAAuB,CAAC,IAAY;IAClD,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,EAAE;QAC7B,OAAO,SAAS,CAAC;KAClB;IAED,IAAI,IAAI,KAAK,GAAG,EAAE;QAChB,OAAO,YAAY,CAAC;KACrB;IAED,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,EAAE;QAC7B,OAAO,SAAS,CAAC;KAClB;IAED,IAAI,IAAI,IAAI,GAAG,EAAE;QACf,OAAO,QAAQ,CAAC;KACjB;IAED,OAAO,SAAS,CAAC;AACnB,CAAC;AAlBD,0DAkBC","sourcesContent":["import { EventStatus } from '@sentry/types';\n/**\n * Converts an HTTP status code to sentry status {@link EventStatus}.\n *\n * @param code number HTTP status code\n * @returns EventStatus\n */\nexport function eventStatusFromHttpCode(code: number): EventStatus {\n  if (code >= 200 && code < 300) {\n    return 'success';\n  }\n\n  if (code === 429) {\n    return 'rate_limit';\n  }\n\n  if (code >= 400 && code < 500) {\n    return 'invalid';\n  }\n\n  if (code >= 500) {\n    return 'failed';\n  }\n\n  return 'unknown';\n}\n"]}/**
 * Truncates given string to the maximum characters count
 *
 * @param str An object that contains serializable values
 * @param max Maximum number of characters in truncated string (0 = unlimited)
 * @returns string Encoded
 */
export declare function truncate(str: string, max?: number): string;
/**
 * This is basically just `trim_line` from
 * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67
 *
 * @param str An object that contains serializable values
 * @param max Maximum number of characters in truncated string
 * @returns string Encoded
 */
export declare function snipLine(line: string, colno: number): string;
/**
 * Join values in array
 * @param input array of values to be joined together
 * @param delimiter string to be placed in-between values
 * @returns Joined values
 */
export declare function safeJoin(input: any[], delimiter?: string): string;
/**
 * Checks if the value matches a regex or includes the string
 * @param value The string value to be checked against
 * @param pattern Either a regex or a string that must be contained in value
 */
export declare function isMatchingPattern(value: string, pattern: RegExp | string): boolean;
/**
 * Given a string, escape characters which have meaning in the regex grammar, such that the result is safe to feed to
 * `new RegExp()`.
 *
 * Based on https://github.com/sindresorhus/escape-string-regexp. Vendored to a) reduce the size by skipping the runtime
 * type-checking, and b) ensure it gets down-compiled for old versions of Node (the published package only supports Node
 * 12+).
 *
 * @param regexString The string to escape
 * @returns An version of the string with all special regex characters escaped
 */
export declare function escapeStringForRegex(regexString: string): string;
//# sourceMappingURL=string.d.ts.map{"version":3,"file":"string.d.ts","sourceRoot":"","sources":["../../src/string.ts"],"names":[],"mappings":"AAEA;;;;;;GAMG;AACH,wBAAgB,QAAQ,CAAC,GAAG,EAAE,MAAM,EAAE,GAAG,GAAE,MAAU,GAAG,MAAM,CAK7D;AAED;;;;;;;GAOG;AACH,wBAAgB,QAAQ,CAAC,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,GAAG,MAAM,CAiC5D;AAED;;;;;GAKG;AAEH,wBAAgB,QAAQ,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE,SAAS,CAAC,EAAE,MAAM,GAAG,MAAM,CAiBjE;AAED;;;;GAIG;AACH,wBAAgB,iBAAiB,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,GAAG,MAAM,GAAG,OAAO,CAYlF;AAED;;;;;;;;;;GAUG;AACH,wBAAgB,oBAAoB,CAAC,WAAW,EAAE,MAAM,GAAG,MAAM,CAIhE"}Object.defineProperty(exports, "__esModule", { value: true });
var is_1 = require("./is");
/**
 * Truncates given string to the maximum characters count
 *
 * @param str An object that contains serializable values
 * @param max Maximum number of characters in truncated string (0 = unlimited)
 * @returns string Encoded
 */
function truncate(str, max) {
    if (max === void 0) { max = 0; }
    if (typeof str !== 'string' || max === 0) {
        return str;
    }
    return str.length <= max ? str : str.substr(0, max) + "...";
}
exports.truncate = truncate;
/**
 * This is basically just `trim_line` from
 * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67
 *
 * @param str An object that contains serializable values
 * @param max Maximum number of characters in truncated string
 * @returns string Encoded
 */
function snipLine(line, colno) {
    var newLine = line;
    var lineLength = newLine.length;
    if (lineLength <= 150) {
        return newLine;
    }
    if (colno > lineLength) {
        // eslint-disable-next-line no-param-reassign
        colno = lineLength;
    }
    var start = Math.max(colno - 60, 0);
    if (start < 5) {
        start = 0;
    }
    var end = Math.min(start + 140, lineLength);
    if (end > lineLength - 5) {
        end = lineLength;
    }
    if (end === lineLength) {
        start = Math.max(end - 140, 0);
    }
    newLine = newLine.slice(start, end);
    if (start > 0) {
        newLine = "'{snip} " + newLine;
    }
    if (end < lineLength) {
        newLine += ' {snip}';
    }
    return newLine;
}
exports.snipLine = snipLine;
/**
 * Join values in array
 * @param input array of values to be joined together
 * @param delimiter string to be placed in-between values
 * @returns Joined values
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function safeJoin(input, delimiter) {
    if (!Array.isArray(input)) {
        return '';
    }
    var output = [];
    // eslint-disable-next-line @typescript-eslint/prefer-for-of
    for (var i = 0; i < input.length; i++) {
        var value = input[i];
        try {
            output.push(String(value));
        }
        catch (e) {
            output.push('[value cannot be serialized]');
        }
    }
    return output.join(delimiter);
}
exports.safeJoin = safeJoin;
/**
 * Checks if the value matches a regex or includes the string
 * @param value The string value to be checked against
 * @param pattern Either a regex or a string that must be contained in value
 */
function isMatchingPattern(value, pattern) {
    if (!is_1.isString(value)) {
        return false;
    }
    if (is_1.isRegExp(pattern)) {
        return pattern.test(value);
    }
    if (typeof pattern === 'string') {
        return value.indexOf(pattern) !== -1;
    }
    return false;
}
exports.isMatchingPattern = isMatchingPattern;
/**
 * Given a string, escape characters which have meaning in the regex grammar, such that the result is safe to feed to
 * `new RegExp()`.
 *
 * Based on https://github.com/sindresorhus/escape-string-regexp. Vendored to a) reduce the size by skipping the runtime
 * type-checking, and b) ensure it gets down-compiled for old versions of Node (the published package only supports Node
 * 12+).
 *
 * @param regexString The string to escape
 * @returns An version of the string with all special regex characters escaped
 */
function escapeStringForRegex(regexString) {
    // escape the hyphen separately so we can also replace it with a unicode literal hyphen, to avoid the problems
    // discussed in https://github.com/sindresorhus/escape-string-regexp/issues/20.
    return regexString.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
}
exports.escapeStringForRegex = escapeStringForRegex;
//# sourceMappingURL=string.js.map{"version":3,"file":"string.js","sourceRoot":"","sources":["../../src/string.ts"],"names":[],"mappings":";AAAA,2BAA0C;AAE1C;;;;;;GAMG;AACH,SAAgB,QAAQ,CAAC,GAAW,EAAE,GAAe;IAAf,oBAAA,EAAA,OAAe;IACnD,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,KAAK,CAAC,EAAE;QACxC,OAAO,GAAG,CAAC;KACZ;IACD,OAAO,GAAG,CAAC,MAAM,IAAI,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAI,GAAG,CAAC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,QAAK,CAAC;AAC9D,CAAC;AALD,4BAKC;AAED;;;;;;;GAOG;AACH,SAAgB,QAAQ,CAAC,IAAY,EAAE,KAAa;IAClD,IAAI,OAAO,GAAG,IAAI,CAAC;IACnB,IAAM,UAAU,GAAG,OAAO,CAAC,MAAM,CAAC;IAClC,IAAI,UAAU,IAAI,GAAG,EAAE;QACrB,OAAO,OAAO,CAAC;KAChB;IACD,IAAI,KAAK,GAAG,UAAU,EAAE;QACtB,6CAA6C;QAC7C,KAAK,GAAG,UAAU,CAAC;KACpB;IAED,IAAI,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC;IACpC,IAAI,KAAK,GAAG,CAAC,EAAE;QACb,KAAK,GAAG,CAAC,CAAC;KACX;IAED,IAAI,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,GAAG,EAAE,UAAU,CAAC,CAAC;IAC5C,IAAI,GAAG,GAAG,UAAU,GAAG,CAAC,EAAE;QACxB,GAAG,GAAG,UAAU,CAAC;KAClB;IACD,IAAI,GAAG,KAAK,UAAU,EAAE;QACtB,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,EAAE,CAAC,CAAC,CAAC;KAChC;IAED,OAAO,GAAG,OAAO,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IACpC,IAAI,KAAK,GAAG,CAAC,EAAE;QACb,OAAO,GAAG,aAAW,OAAS,CAAC;KAChC;IACD,IAAI,GAAG,GAAG,UAAU,EAAE;QACpB,OAAO,IAAI,SAAS,CAAC;KACtB;IAED,OAAO,OAAO,CAAC;AACjB,CAAC;AAjCD,4BAiCC;AAED;;;;;GAKG;AACH,8DAA8D;AAC9D,SAAgB,QAAQ,CAAC,KAAY,EAAE,SAAkB;IACvD,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;QACzB,OAAO,EAAE,CAAC;KACX;IAED,IAAM,MAAM,GAAG,EAAE,CAAC;IAClB,4DAA4D;IAC5D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACrC,IAAM,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QACvB,IAAI;YACF,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;SAC5B;QAAC,OAAO,CAAC,EAAE;YACV,MAAM,CAAC,IAAI,CAAC,8BAA8B,CAAC,CAAC;SAC7C;KACF;IAED,OAAO,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;AAChC,CAAC;AAjBD,4BAiBC;AAED;;;;GAIG;AACH,SAAgB,iBAAiB,CAAC,KAAa,EAAE,OAAwB;IACvE,IAAI,CAAC,aAAQ,CAAC,KAAK,CAAC,EAAE;QACpB,OAAO,KAAK,CAAC;KACd;IAED,IAAI,aAAQ,CAAC,OAAO,CAAC,EAAE;QACrB,OAAO,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KAC5B;IACD,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;QAC/B,OAAO,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;KACtC;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAZD,8CAYC;AAED;;;;;;;;;;GAUG;AACH,SAAgB,oBAAoB,CAAC,WAAmB;IACtD,8GAA8G;IAC9G,+EAA+E;IAC/E,OAAO,WAAW,CAAC,OAAO,CAAC,qBAAqB,EAAE,MAAM,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;AACnF,CAAC;AAJD,oDAIC","sourcesContent":["import { isRegExp, isString } from './is';\n\n/**\n * Truncates given string to the maximum characters count\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string (0 = unlimited)\n * @returns string Encoded\n */\nexport function truncate(str: string, max: number = 0): string {\n  if (typeof str !== 'string' || max === 0) {\n    return str;\n  }\n  return str.length <= max ? str : `${str.substr(0, max)}...`;\n}\n\n/**\n * This is basically just `trim_line` from\n * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string\n * @returns string Encoded\n */\nexport function snipLine(line: string, colno: number): string {\n  let newLine = line;\n  const lineLength = newLine.length;\n  if (lineLength <= 150) {\n    return newLine;\n  }\n  if (colno > lineLength) {\n    // eslint-disable-next-line no-param-reassign\n    colno = lineLength;\n  }\n\n  let start = Math.max(colno - 60, 0);\n  if (start < 5) {\n    start = 0;\n  }\n\n  let end = Math.min(start + 140, lineLength);\n  if (end > lineLength - 5) {\n    end = lineLength;\n  }\n  if (end === lineLength) {\n    start = Math.max(end - 140, 0);\n  }\n\n  newLine = newLine.slice(start, end);\n  if (start > 0) {\n    newLine = `'{snip} ${newLine}`;\n  }\n  if (end < lineLength) {\n    newLine += ' {snip}';\n  }\n\n  return newLine;\n}\n\n/**\n * Join values in array\n * @param input array of values to be joined together\n * @param delimiter string to be placed in-between values\n * @returns Joined values\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function safeJoin(input: any[], delimiter?: string): string {\n  if (!Array.isArray(input)) {\n    return '';\n  }\n\n  const output = [];\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of\n  for (let i = 0; i < input.length; i++) {\n    const value = input[i];\n    try {\n      output.push(String(value));\n    } catch (e) {\n      output.push('[value cannot be serialized]');\n    }\n  }\n\n  return output.join(delimiter);\n}\n\n/**\n * Checks if the value matches a regex or includes the string\n * @param value The string value to be checked against\n * @param pattern Either a regex or a string that must be contained in value\n */\nexport function isMatchingPattern(value: string, pattern: RegExp | string): boolean {\n  if (!isString(value)) {\n    return false;\n  }\n\n  if (isRegExp(pattern)) {\n    return pattern.test(value);\n  }\n  if (typeof pattern === 'string') {\n    return value.indexOf(pattern) !== -1;\n  }\n  return false;\n}\n\n/**\n * Given a string, escape characters which have meaning in the regex grammar, such that the result is safe to feed to\n * `new RegExp()`.\n *\n * Based on https://github.com/sindresorhus/escape-string-regexp. Vendored to a) reduce the size by skipping the runtime\n * type-checking, and b) ensure it gets down-compiled for old versions of Node (the published package only supports Node\n * 12+).\n *\n * @param regexString The string to escape\n * @returns An version of the string with all special regex characters escaped\n */\nexport function escapeStringForRegex(regexString: string): string {\n  // escape the hyphen separately so we can also replace it with a unicode literal hyphen, to avoid the problems\n  // discussed in https://github.com/sindresorhus/escape-string-regexp/issues/20.\n  return regexString.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d');\n}\n"]}/**
 * Tells whether current environment supports ErrorEvent objects
 * {@link supportsErrorEvent}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsErrorEvent(): boolean;
/**
 * Tells whether current environment supports DOMError objects
 * {@link supportsDOMError}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsDOMError(): boolean;
/**
 * Tells whether current environment supports DOMException objects
 * {@link supportsDOMException}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsDOMException(): boolean;
/**
 * Tells whether current environment supports Fetch API
 * {@link supportsFetch}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsFetch(): boolean;
/**
 * isNativeFetch checks if the given function is a native implementation of fetch()
 */
export declare function isNativeFetch(func: Function): boolean;
/**
 * Tells whether current environment supports Fetch API natively
 * {@link supportsNativeFetch}.
 *
 * @returns true if `window.fetch` is natively implemented, false otherwise
 */
export declare function supportsNativeFetch(): boolean;
/**
 * Tells whether current environment supports ReportingObserver API
 * {@link supportsReportingObserver}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsReportingObserver(): boolean;
/**
 * Tells whether current environment supports Referrer Policy API
 * {@link supportsReferrerPolicy}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsReferrerPolicy(): boolean;
/**
 * Tells whether current environment supports History API
 * {@link supportsHistory}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsHistory(): boolean;
//# sourceMappingURL=supports.d.ts.map{"version":3,"file":"supports.d.ts","sourceRoot":"","sources":["../../src/supports.ts"],"names":[],"mappings":"AAIA;;;;;GAKG;AACH,wBAAgB,kBAAkB,IAAI,OAAO,CAO5C;AAED;;;;;GAKG;AACH,wBAAgB,gBAAgB,IAAI,OAAO,CAU1C;AAED;;;;;GAKG;AACH,wBAAgB,oBAAoB,IAAI,OAAO,CAO9C;AAED;;;;;GAKG;AACH,wBAAgB,aAAa,IAAI,OAAO,CAavC;AACD;;GAEG;AAEH,wBAAgB,aAAa,CAAC,IAAI,EAAE,QAAQ,GAAG,OAAO,CAErD;AAED;;;;;GAKG;AACH,wBAAgB,mBAAmB,IAAI,OAAO,CAmC7C;AAED;;;;;GAKG;AACH,wBAAgB,yBAAyB,IAAI,OAAO,CAEnD;AAED;;;;;GAKG;AACH,wBAAgB,sBAAsB,IAAI,OAAO,CAkBhD;AAED;;;;;GAKG;AACH,wBAAgB,eAAe,IAAI,OAAO,CAazC"}Object.defineProperty(exports, "__esModule", { value: true });
var flags_1 = require("./flags");
var global_1 = require("./global");
var logger_1 = require("./logger");
/**
 * Tells whether current environment supports ErrorEvent objects
 * {@link supportsErrorEvent}.
 *
 * @returns Answer to the given question.
 */
function supportsErrorEvent() {
    try {
        new ErrorEvent('');
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.supportsErrorEvent = supportsErrorEvent;
/**
 * Tells whether current environment supports DOMError objects
 * {@link supportsDOMError}.
 *
 * @returns Answer to the given question.
 */
function supportsDOMError() {
    try {
        // Chrome: VM89:1 Uncaught TypeError: Failed to construct 'DOMError':
        // 1 argument required, but only 0 present.
        // @ts-ignore It really needs 1 argument, not 0.
        new DOMError('');
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.supportsDOMError = supportsDOMError;
/**
 * Tells whether current environment supports DOMException objects
 * {@link supportsDOMException}.
 *
 * @returns Answer to the given question.
 */
function supportsDOMException() {
    try {
        new DOMException('');
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.supportsDOMException = supportsDOMException;
/**
 * Tells whether current environment supports Fetch API
 * {@link supportsFetch}.
 *
 * @returns Answer to the given question.
 */
function supportsFetch() {
    if (!('fetch' in global_1.getGlobalObject())) {
        return false;
    }
    try {
        new Headers();
        new Request('');
        new Response();
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.supportsFetch = supportsFetch;
/**
 * isNativeFetch checks if the given function is a native implementation of fetch()
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function isNativeFetch(func) {
    return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
}
exports.isNativeFetch = isNativeFetch;
/**
 * Tells whether current environment supports Fetch API natively
 * {@link supportsNativeFetch}.
 *
 * @returns true if `window.fetch` is natively implemented, false otherwise
 */
function supportsNativeFetch() {
    if (!supportsFetch()) {
        return false;
    }
    var global = global_1.getGlobalObject();
    // Fast path to avoid DOM I/O
    // eslint-disable-next-line @typescript-eslint/unbound-method
    if (isNativeFetch(global.fetch)) {
        return true;
    }
    // window.fetch is implemented, but is polyfilled or already wrapped (e.g: by a chrome extension)
    // so create a "pure" iframe to see if that has native fetch
    var result = false;
    var doc = global.document;
    // eslint-disable-next-line deprecation/deprecation
    if (doc && typeof doc.createElement === 'function') {
        try {
            var sandbox = doc.createElement('iframe');
            sandbox.hidden = true;
            doc.head.appendChild(sandbox);
            if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
                // eslint-disable-next-line @typescript-eslint/unbound-method
                result = isNativeFetch(sandbox.contentWindow.fetch);
            }
            doc.head.removeChild(sandbox);
        }
        catch (err) {
            flags_1.IS_DEBUG_BUILD &&
                logger_1.logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', err);
        }
    }
    return result;
}
exports.supportsNativeFetch = supportsNativeFetch;
/**
 * Tells whether current environment supports ReportingObserver API
 * {@link supportsReportingObserver}.
 *
 * @returns Answer to the given question.
 */
function supportsReportingObserver() {
    return 'ReportingObserver' in global_1.getGlobalObject();
}
exports.supportsReportingObserver = supportsReportingObserver;
/**
 * Tells whether current environment supports Referrer Policy API
 * {@link supportsReferrerPolicy}.
 *
 * @returns Answer to the given question.
 */
function supportsReferrerPolicy() {
    // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default'
    // (see https://caniuse.com/#feat=referrer-policy),
    // it doesn't. And it throws an exception instead of ignoring this parameter...
    // REF: https://github.com/getsentry/raven-js/issues/1233
    if (!supportsFetch()) {
        return false;
    }
    try {
        new Request('_', {
            referrerPolicy: 'origin',
        });
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.supportsReferrerPolicy = supportsReferrerPolicy;
/**
 * Tells whether current environment supports History API
 * {@link supportsHistory}.
 *
 * @returns Answer to the given question.
 */
function supportsHistory() {
    // NOTE: in Chrome App environment, touching history.pushState, *even inside
    //       a try/catch block*, will cause Chrome to output an error to console.error
    // borrowed from: https://github.com/angular/angular.js/pull/13945/files
    var global = global_1.getGlobalObject();
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var chrome = global.chrome;
    var isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
    var hasHistoryApi = 'history' in global && !!global.history.pushState && !!global.history.replaceState;
    return !isChromePackagedApp && hasHistoryApi;
}
exports.supportsHistory = supportsHistory;
//# sourceMappingURL=supports.js.map{"version":3,"file":"supports.js","sourceRoot":"","sources":["../../src/supports.ts"],"names":[],"mappings":";AAAA,iCAAyC;AACzC,mCAA2C;AAC3C,mCAAkC;AAElC;;;;;GAKG;AACH,SAAgB,kBAAkB;IAChC,IAAI;QACF,IAAI,UAAU,CAAC,EAAE,CAAC,CAAC;QACnB,OAAO,IAAI,CAAC;KACb;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAPD,gDAOC;AAED;;;;;GAKG;AACH,SAAgB,gBAAgB;IAC9B,IAAI;QACF,qEAAqE;QACrE,2CAA2C;QAC3C,gDAAgD;QAChD,IAAI,QAAQ,CAAC,EAAE,CAAC,CAAC;QACjB,OAAO,IAAI,CAAC;KACb;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAVD,4CAUC;AAED;;;;;GAKG;AACH,SAAgB,oBAAoB;IAClC,IAAI;QACF,IAAI,YAAY,CAAC,EAAE,CAAC,CAAC;QACrB,OAAO,IAAI,CAAC;KACb;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAPD,oDAOC;AAED;;;;;GAKG;AACH,SAAgB,aAAa;IAC3B,IAAI,CAAC,CAAC,OAAO,IAAI,wBAAe,EAAU,CAAC,EAAE;QAC3C,OAAO,KAAK,CAAC;KACd;IAED,IAAI;QACF,IAAI,OAAO,EAAE,CAAC;QACd,IAAI,OAAO,CAAC,EAAE,CAAC,CAAC;QAChB,IAAI,QAAQ,EAAE,CAAC;QACf,OAAO,IAAI,CAAC;KACb;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAbD,sCAaC;AACD;;GAEG;AACH,wDAAwD;AACxD,SAAgB,aAAa,CAAC,IAAc;IAC1C,OAAO,IAAI,IAAI,kDAAkD,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;AAC1F,CAAC;AAFD,sCAEC;AAED;;;;;GAKG;AACH,SAAgB,mBAAmB;IACjC,IAAI,CAAC,aAAa,EAAE,EAAE;QACpB,OAAO,KAAK,CAAC;KACd;IAED,IAAM,MAAM,GAAG,wBAAe,EAAU,CAAC;IAEzC,6BAA6B;IAC7B,6DAA6D;IAC7D,IAAI,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE;QAC/B,OAAO,IAAI,CAAC;KACb;IAED,iGAAiG;IACjG,4DAA4D;IAC5D,IAAI,MAAM,GAAG,KAAK,CAAC;IACnB,IAAM,GAAG,GAAG,MAAM,CAAC,QAAQ,CAAC;IAC5B,mDAAmD;IACnD,IAAI,GAAG,IAAI,OAAQ,GAAG,CAAC,aAAyB,KAAK,UAAU,EAAE;QAC/D,IAAI;YACF,IAAM,OAAO,GAAG,GAAG,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;YAC5C,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC;YACtB,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;YAC9B,IAAI,OAAO,CAAC,aAAa,IAAI,OAAO,CAAC,aAAa,CAAC,KAAK,EAAE;gBACxD,6DAA6D;gBAC7D,MAAM,GAAG,aAAa,CAAC,OAAO,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;aACrD;YACD,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;SAC/B;QAAC,OAAO,GAAG,EAAE;YACZ,sBAAc;gBACZ,eAAM,CAAC,IAAI,CAAC,iFAAiF,EAAE,GAAG,CAAC,CAAC;SACvG;KACF;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AAnCD,kDAmCC;AAED;;;;;GAKG;AACH,SAAgB,yBAAyB;IACvC,OAAO,mBAAmB,IAAI,wBAAe,EAAE,CAAC;AAClD,CAAC;AAFD,8DAEC;AAED;;;;;GAKG;AACH,SAAgB,sBAAsB;IACpC,yHAAyH;IACzH,mDAAmD;IACnD,+EAA+E;IAC/E,yDAAyD;IAEzD,IAAI,CAAC,aAAa,EAAE,EAAE;QACpB,OAAO,KAAK,CAAC;KACd;IAED,IAAI;QACF,IAAI,OAAO,CAAC,GAAG,EAAE;YACf,cAAc,EAAE,QAA0B;SAC3C,CAAC,CAAC;QACH,OAAO,IAAI,CAAC;KACb;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAlBD,wDAkBC;AAED;;;;;GAKG;AACH,SAAgB,eAAe;IAC7B,4EAA4E;IAC5E,kFAAkF;IAClF,wEAAwE;IACxE,IAAM,MAAM,GAAG,wBAAe,EAAU,CAAC;IACzC,+DAA+D;IAC/D,8DAA8D;IAC9D,IAAM,MAAM,GAAI,MAAc,CAAC,MAAM,CAAC;IACtC,IAAM,mBAAmB,GAAG,MAAM,IAAI,MAAM,CAAC,GAAG,IAAI,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC;IACvE,8DAA8D;IAC9D,IAAM,aAAa,GAAG,SAAS,IAAI,MAAM,IAAI,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,SAAS,IAAI,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,YAAY,CAAC;IAEzG,OAAO,CAAC,mBAAmB,IAAI,aAAa,CAAC;AAC/C,CAAC;AAbD,0CAaC","sourcesContent":["import { IS_DEBUG_BUILD } from './flags';\nimport { getGlobalObject } from './global';\nimport { logger } from './logger';\n\n/**\n * Tells whether current environment supports ErrorEvent objects\n * {@link supportsErrorEvent}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsErrorEvent(): boolean {\n  try {\n    new ErrorEvent('');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports DOMError objects\n * {@link supportsDOMError}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsDOMError(): boolean {\n  try {\n    // Chrome: VM89:1 Uncaught TypeError: Failed to construct 'DOMError':\n    // 1 argument required, but only 0 present.\n    // @ts-ignore It really needs 1 argument, not 0.\n    new DOMError('');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports DOMException objects\n * {@link supportsDOMException}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsDOMException(): boolean {\n  try {\n    new DOMException('');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports Fetch API\n * {@link supportsFetch}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsFetch(): boolean {\n  if (!('fetch' in getGlobalObject<Window>())) {\n    return false;\n  }\n\n  try {\n    new Headers();\n    new Request('');\n    new Response();\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * isNativeFetch checks if the given function is a native implementation of fetch()\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isNativeFetch(func: Function): boolean {\n  return func && /^function fetch\\(\\)\\s+\\{\\s+\\[native code\\]\\s+\\}$/.test(func.toString());\n}\n\n/**\n * Tells whether current environment supports Fetch API natively\n * {@link supportsNativeFetch}.\n *\n * @returns true if `window.fetch` is natively implemented, false otherwise\n */\nexport function supportsNativeFetch(): boolean {\n  if (!supportsFetch()) {\n    return false;\n  }\n\n  const global = getGlobalObject<Window>();\n\n  // Fast path to avoid DOM I/O\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  if (isNativeFetch(global.fetch)) {\n    return true;\n  }\n\n  // window.fetch is implemented, but is polyfilled or already wrapped (e.g: by a chrome extension)\n  // so create a \"pure\" iframe to see if that has native fetch\n  let result = false;\n  const doc = global.document;\n  // eslint-disable-next-line deprecation/deprecation\n  if (doc && typeof (doc.createElement as unknown) === 'function') {\n    try {\n      const sandbox = doc.createElement('iframe');\n      sandbox.hidden = true;\n      doc.head.appendChild(sandbox);\n      if (sandbox.contentWindow && sandbox.contentWindow.fetch) {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        result = isNativeFetch(sandbox.contentWindow.fetch);\n      }\n      doc.head.removeChild(sandbox);\n    } catch (err) {\n      IS_DEBUG_BUILD &&\n        logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', err);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Tells whether current environment supports ReportingObserver API\n * {@link supportsReportingObserver}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsReportingObserver(): boolean {\n  return 'ReportingObserver' in getGlobalObject();\n}\n\n/**\n * Tells whether current environment supports Referrer Policy API\n * {@link supportsReferrerPolicy}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsReferrerPolicy(): boolean {\n  // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default'\n  // (see https://caniuse.com/#feat=referrer-policy),\n  // it doesn't. And it throws an exception instead of ignoring this parameter...\n  // REF: https://github.com/getsentry/raven-js/issues/1233\n\n  if (!supportsFetch()) {\n    return false;\n  }\n\n  try {\n    new Request('_', {\n      referrerPolicy: 'origin' as ReferrerPolicy,\n    });\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports History API\n * {@link supportsHistory}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsHistory(): boolean {\n  // NOTE: in Chrome App environment, touching history.pushState, *even inside\n  //       a try/catch block*, will cause Chrome to output an error to console.error\n  // borrowed from: https://github.com/angular/angular.js/pull/13945/files\n  const global = getGlobalObject<Window>();\n  /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const chrome = (global as any).chrome;\n  const isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;\n  /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n  const hasHistoryApi = 'history' in global && !!global.history.pushState && !!global.history.replaceState;\n\n  return !isChromePackagedApp && hasHistoryApi;\n}\n"]}/**
 * Creates a resolved sync promise.
 *
 * @param value the value to resolve the promise with
 * @returns the resolved sync promise
 */
export declare function resolvedSyncPromise<T>(value: T | PromiseLike<T>): PromiseLike<T>;
/**
 * Creates a rejected sync promise.
 *
 * @param value the value to reject the promise with
 * @returns the rejected sync promise
 */
export declare function rejectedSyncPromise<T = never>(reason?: any): PromiseLike<T>;
/**
 * Thenable class that behaves like a Promise and follows it's interface
 * but is not async internally
 */
declare class SyncPromise<T> implements PromiseLike<T> {
    private _state;
    private _handlers;
    private _value;
    constructor(executor: (resolve: (value?: T | PromiseLike<T> | null) => void, reject: (reason?: any) => void) => void);
    /** JSDoc */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null): PromiseLike<TResult1 | TResult2>;
    /** JSDoc */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null): PromiseLike<T | TResult>;
    /** JSDoc */
    finally<TResult>(onfinally?: (() => void) | null): PromiseLike<TResult>;
    /** JSDoc */
    private readonly _resolve;
    /** JSDoc */
    private readonly _reject;
    /** JSDoc */
    private readonly _setResult;
    /** JSDoc */
    private readonly _executeHandlers;
}
export { SyncPromise };
//# sourceMappingURL=syncpromise.d.ts.map{"version":3,"file":"syncpromise.d.ts","sourceRoot":"","sources":["../../src/syncpromise.ts"],"names":[],"mappings":"AAgBA;;;;;GAKG;AACH,wBAAgB,mBAAmB,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAIhF;AAED;;;;;GAKG;AACH,wBAAgB,mBAAmB,CAAC,CAAC,GAAG,KAAK,EAAE,MAAM,CAAC,EAAE,GAAG,GAAG,WAAW,CAAC,CAAC,CAAC,CAI3E;AAED;;;GAGG;AACH,cAAM,WAAW,CAAC,CAAC,CAAE,YAAW,WAAW,CAAC,CAAC,CAAC;IAC5C,OAAO,CAAC,MAAM,CAA0B;IACxC,OAAO,CAAC,SAAS,CAAkE;IACnF,OAAO,CAAC,MAAM,CAAM;gBAGlB,QAAQ,EAAE,CAAC,OAAO,EAAE,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,GAAG,IAAI,KAAK,IAAI,EAAE,MAAM,EAAE,CAAC,MAAM,CAAC,EAAE,GAAG,KAAK,IAAI,KAAK,IAAI;IAS1G,YAAY;IACL,IAAI,CAAC,QAAQ,GAAG,CAAC,EAAE,QAAQ,GAAG,KAAK,EACxC,WAAW,CAAC,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,KAAK,QAAQ,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,EACrE,UAAU,CAAC,EAAE,CAAC,CAAC,MAAM,EAAE,GAAG,KAAK,QAAQ,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,GACtE,WAAW,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAiCnC,YAAY;IACL,KAAK,CAAC,OAAO,GAAG,KAAK,EAC1B,UAAU,CAAC,EAAE,CAAC,CAAC,MAAM,EAAE,GAAG,KAAK,OAAO,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC,GAAG,IAAI,GACpE,WAAW,CAAC,CAAC,GAAG,OAAO,CAAC;IAI3B,YAAY;IACL,OAAO,CAAC,OAAO,EAAE,SAAS,CAAC,EAAE,CAAC,MAAM,IAAI,CAAC,GAAG,IAAI,GAAG,WAAW,CAAC,OAAO,CAAC;IA+B9E,YAAY;IACZ,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAEvB;IAEF,YAAY;IACZ,OAAO,CAAC,QAAQ,CAAC,OAAO,CAEtB;IAEF,YAAY;IACZ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAczB;IAEF,YAAY;IACZ,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAwB/B;CACH;AAED,OAAO,EAAE,WAAW,EAAE,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/explicit-function-return-type */
/* eslint-disable @typescript-eslint/typedef */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
var is_1 = require("./is");
/**
 * Creates a resolved sync promise.
 *
 * @param value the value to resolve the promise with
 * @returns the resolved sync promise
 */
function resolvedSyncPromise(value) {
    return new SyncPromise(function (resolve) {
        resolve(value);
    });
}
exports.resolvedSyncPromise = resolvedSyncPromise;
/**
 * Creates a rejected sync promise.
 *
 * @param value the value to reject the promise with
 * @returns the rejected sync promise
 */
function rejectedSyncPromise(reason) {
    return new SyncPromise(function (_, reject) {
        reject(reason);
    });
}
exports.rejectedSyncPromise = rejectedSyncPromise;
/**
 * Thenable class that behaves like a Promise and follows it's interface
 * but is not async internally
 */
var SyncPromise = /** @class */ (function () {
    function SyncPromise(executor) {
        var _this = this;
        this._state = 0 /* PENDING */;
        this._handlers = [];
        /** JSDoc */
        this._resolve = function (value) {
            _this._setResult(1 /* RESOLVED */, value);
        };
        /** JSDoc */
        this._reject = function (reason) {
            _this._setResult(2 /* REJECTED */, reason);
        };
        /** JSDoc */
        this._setResult = function (state, value) {
            if (_this._state !== 0 /* PENDING */) {
                return;
            }
            if (is_1.isThenable(value)) {
                void value.then(_this._resolve, _this._reject);
                return;
            }
            _this._state = state;
            _this._value = value;
            _this._executeHandlers();
        };
        /** JSDoc */
        this._executeHandlers = function () {
            if (_this._state === 0 /* PENDING */) {
                return;
            }
            var cachedHandlers = _this._handlers.slice();
            _this._handlers = [];
            cachedHandlers.forEach(function (handler) {
                if (handler[0]) {
                    return;
                }
                if (_this._state === 1 /* RESOLVED */) {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    handler[1](_this._value);
                }
                if (_this._state === 2 /* REJECTED */) {
                    handler[2](_this._value);
                }
                handler[0] = true;
            });
        };
        try {
            executor(this._resolve, this._reject);
        }
        catch (e) {
            this._reject(e);
        }
    }
    /** JSDoc */
    SyncPromise.prototype.then = function (onfulfilled, onrejected) {
        var _this = this;
        return new SyncPromise(function (resolve, reject) {
            _this._handlers.push([
                false,
                function (result) {
                    if (!onfulfilled) {
                        // TODO: ¯\_(ツ)_/¯
                        // TODO: FIXME
                        resolve(result);
                    }
                    else {
                        try {
                            resolve(onfulfilled(result));
                        }
                        catch (e) {
                            reject(e);
                        }
                    }
                },
                function (reason) {
                    if (!onrejected) {
                        reject(reason);
                    }
                    else {
                        try {
                            resolve(onrejected(reason));
                        }
                        catch (e) {
                            reject(e);
                        }
                    }
                },
            ]);
            _this._executeHandlers();
        });
    };
    /** JSDoc */
    SyncPromise.prototype.catch = function (onrejected) {
        return this.then(function (val) { return val; }, onrejected);
    };
    /** JSDoc */
    SyncPromise.prototype.finally = function (onfinally) {
        var _this = this;
        return new SyncPromise(function (resolve, reject) {
            var val;
            var isRejected;
            return _this.then(function (value) {
                isRejected = false;
                val = value;
                if (onfinally) {
                    onfinally();
                }
            }, function (reason) {
                isRejected = true;
                val = reason;
                if (onfinally) {
                    onfinally();
                }
            }).then(function () {
                if (isRejected) {
                    reject(val);
                    return;
                }
                resolve(val);
            });
        });
    };
    return SyncPromise;
}());
exports.SyncPromise = SyncPromise;
//# sourceMappingURL=syncpromise.js.map{"version":3,"file":"syncpromise.js","sourceRoot":"","sources":["../../src/syncpromise.ts"],"names":[],"mappings":";AAAA,qEAAqE;AACrE,+CAA+C;AAC/C,sEAAsE;AACtE,uDAAuD;AACvD,2BAAkC;AAYlC;;;;;GAKG;AACH,SAAgB,mBAAmB,CAAI,KAAyB;IAC9D,OAAO,IAAI,WAAW,CAAC,UAAA,OAAO;QAC5B,OAAO,CAAC,KAAK,CAAC,CAAC;IACjB,CAAC,CAAC,CAAC;AACL,CAAC;AAJD,kDAIC;AAED;;;;;GAKG;AACH,SAAgB,mBAAmB,CAAY,MAAY;IACzD,OAAO,IAAI,WAAW,CAAC,UAAC,CAAC,EAAE,MAAM;QAC/B,MAAM,CAAC,MAAM,CAAC,CAAC;IACjB,CAAC,CAAC,CAAC;AACL,CAAC;AAJD,kDAIC;AAED;;;GAGG;AACH;IAKE,qBACE,QAAwG;QAD1G,iBAQC;QAZO,WAAM,mBAA0B;QAChC,cAAS,GAA+D,EAAE,CAAC;QAyFnF,YAAY;QACK,aAAQ,GAAG,UAAC,KAAiC;YAC5D,KAAI,CAAC,UAAU,mBAAkB,KAAK,CAAC,CAAC;QAC1C,CAAC,CAAC;QAEF,YAAY;QACK,YAAO,GAAG,UAAC,MAAY;YACtC,KAAI,CAAC,UAAU,mBAAkB,MAAM,CAAC,CAAC;QAC3C,CAAC,CAAC;QAEF,YAAY;QACK,eAAU,GAAG,UAAC,KAAa,EAAE,KAAgC;YAC5E,IAAI,KAAI,CAAC,MAAM,oBAAmB,EAAE;gBAClC,OAAO;aACR;YAED,IAAI,eAAU,CAAC,KAAK,CAAC,EAAE;gBACrB,KAAM,KAAwB,CAAC,IAAI,CAAC,KAAI,CAAC,QAAQ,EAAE,KAAI,CAAC,OAAO,CAAC,CAAC;gBACjE,OAAO;aACR;YAED,KAAI,CAAC,MAAM,GAAG,KAAK,CAAC;YACpB,KAAI,CAAC,MAAM,GAAG,KAAK,CAAC;YAEpB,KAAI,CAAC,gBAAgB,EAAE,CAAC;QAC1B,CAAC,CAAC;QAEF,YAAY;QACK,qBAAgB,GAAG;YAClC,IAAI,KAAI,CAAC,MAAM,oBAAmB,EAAE;gBAClC,OAAO;aACR;YAED,IAAM,cAAc,GAAG,KAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;YAC9C,KAAI,CAAC,SAAS,GAAG,EAAE,CAAC;YAEpB,cAAc,CAAC,OAAO,CAAC,UAAA,OAAO;gBAC5B,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE;oBACd,OAAO;iBACR;gBAED,IAAI,KAAI,CAAC,MAAM,qBAAoB,EAAE;oBACnC,mEAAmE;oBACnE,OAAO,CAAC,CAAC,CAAC,CAAC,KAAI,CAAC,MAAwB,CAAC,CAAC;iBAC3C;gBAED,IAAI,KAAI,CAAC,MAAM,qBAAoB,EAAE;oBACnC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAI,CAAC,MAAM,CAAC,CAAC;iBACzB;gBAED,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;YACpB,CAAC,CAAC,CAAC;QACL,CAAC,CAAC;QAvIA,IAAI;YACF,QAAQ,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;SACvC;QAAC,OAAO,CAAC,EAAE;YACV,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;SACjB;IACH,CAAC;IAED,YAAY;IACL,0BAAI,GAAX,UACE,WAAqE,EACrE,UAAuE;QAFzE,iBAkCC;QA9BC,OAAO,IAAI,WAAW,CAAC,UAAC,OAAO,EAAE,MAAM;YACrC,KAAI,CAAC,SAAS,CAAC,IAAI,CAAC;gBAClB,KAAK;gBACL,UAAA,MAAM;oBACJ,IAAI,CAAC,WAAW,EAAE;wBAChB,kBAAkB;wBAClB,cAAc;wBACd,OAAO,CAAC,MAAa,CAAC,CAAC;qBACxB;yBAAM;wBACL,IAAI;4BACF,OAAO,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC;yBAC9B;wBAAC,OAAO,CAAC,EAAE;4BACV,MAAM,CAAC,CAAC,CAAC,CAAC;yBACX;qBACF;gBACH,CAAC;gBACD,UAAA,MAAM;oBACJ,IAAI,CAAC,UAAU,EAAE;wBACf,MAAM,CAAC,MAAM,CAAC,CAAC;qBAChB;yBAAM;wBACL,IAAI;4BACF,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC;yBAC7B;wBAAC,OAAO,CAAC,EAAE;4BACV,MAAM,CAAC,CAAC,CAAC,CAAC;yBACX;qBACF;gBACH,CAAC;aACF,CAAC,CAAC;YACH,KAAI,CAAC,gBAAgB,EAAE,CAAC;QAC1B,CAAC,CAAC,CAAC;IACL,CAAC;IAED,YAAY;IACL,2BAAK,GAAZ,UACE,UAAqE;QAErE,OAAO,IAAI,CAAC,IAAI,CAAC,UAAA,GAAG,IAAI,OAAA,GAAG,EAAH,CAAG,EAAE,UAAU,CAAC,CAAC;IAC3C,CAAC;IAED,YAAY;IACL,6BAAO,GAAd,UAAwB,SAA+B;QAAvD,iBA6BC;QA5BC,OAAO,IAAI,WAAW,CAAU,UAAC,OAAO,EAAE,MAAM;YAC9C,IAAI,GAAkB,CAAC;YACvB,IAAI,UAAmB,CAAC;YAExB,OAAO,KAAI,CAAC,IAAI,CACd,UAAA,KAAK;gBACH,UAAU,GAAG,KAAK,CAAC;gBACnB,GAAG,GAAG,KAAK,CAAC;gBACZ,IAAI,SAAS,EAAE;oBACb,SAAS,EAAE,CAAC;iBACb;YACH,CAAC,EACD,UAAA,MAAM;gBACJ,UAAU,GAAG,IAAI,CAAC;gBAClB,GAAG,GAAG,MAAM,CAAC;gBACb,IAAI,SAAS,EAAE;oBACb,SAAS,EAAE,CAAC;iBACb;YACH,CAAC,CACF,CAAC,IAAI,CAAC;gBACL,IAAI,UAAU,EAAE;oBACd,MAAM,CAAC,GAAG,CAAC,CAAC;oBACZ,OAAO;iBACR;gBAED,OAAO,CAAC,GAAqB,CAAC,CAAC;YACjC,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAuDH,kBAAC;AAAD,CAAC,AAhJD,IAgJC;AAEQ,kCAAW","sourcesContent":["/* eslint-disable @typescript-eslint/explicit-function-return-type */\n/* eslint-disable @typescript-eslint/typedef */\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { isThenable } from './is';\n\n/** SyncPromise internal states */\nconst enum States {\n  /** Pending */\n  PENDING = 0,\n  /** Resolved / OK */\n  RESOLVED = 1,\n  /** Rejected / Error */\n  REJECTED = 2,\n}\n\n/**\n * Creates a resolved sync promise.\n *\n * @param value the value to resolve the promise with\n * @returns the resolved sync promise\n */\nexport function resolvedSyncPromise<T>(value: T | PromiseLike<T>): PromiseLike<T> {\n  return new SyncPromise(resolve => {\n    resolve(value);\n  });\n}\n\n/**\n * Creates a rejected sync promise.\n *\n * @param value the value to reject the promise with\n * @returns the rejected sync promise\n */\nexport function rejectedSyncPromise<T = never>(reason?: any): PromiseLike<T> {\n  return new SyncPromise((_, reject) => {\n    reject(reason);\n  });\n}\n\n/**\n * Thenable class that behaves like a Promise and follows it's interface\n * but is not async internally\n */\nclass SyncPromise<T> implements PromiseLike<T> {\n  private _state: States = States.PENDING;\n  private _handlers: Array<[boolean, (value: T) => void, (reason: any) => any]> = [];\n  private _value: any;\n\n  public constructor(\n    executor: (resolve: (value?: T | PromiseLike<T> | null) => void, reject: (reason?: any) => void) => void,\n  ) {\n    try {\n      executor(this._resolve, this._reject);\n    } catch (e) {\n      this._reject(e);\n    }\n  }\n\n  /** JSDoc */\n  public then<TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,\n  ): PromiseLike<TResult1 | TResult2> {\n    return new SyncPromise((resolve, reject) => {\n      this._handlers.push([\n        false,\n        result => {\n          if (!onfulfilled) {\n            // TODO: ¯\\_(ツ)_/¯\n            // TODO: FIXME\n            resolve(result as any);\n          } else {\n            try {\n              resolve(onfulfilled(result));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n        reason => {\n          if (!onrejected) {\n            reject(reason);\n          } else {\n            try {\n              resolve(onrejected(reason));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n      ]);\n      this._executeHandlers();\n    });\n  }\n\n  /** JSDoc */\n  public catch<TResult = never>(\n    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,\n  ): PromiseLike<T | TResult> {\n    return this.then(val => val, onrejected);\n  }\n\n  /** JSDoc */\n  public finally<TResult>(onfinally?: (() => void) | null): PromiseLike<TResult> {\n    return new SyncPromise<TResult>((resolve, reject) => {\n      let val: TResult | any;\n      let isRejected: boolean;\n\n      return this.then(\n        value => {\n          isRejected = false;\n          val = value;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n        reason => {\n          isRejected = true;\n          val = reason;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n      ).then(() => {\n        if (isRejected) {\n          reject(val);\n          return;\n        }\n\n        resolve(val as unknown as any);\n      });\n    });\n  }\n\n  /** JSDoc */\n  private readonly _resolve = (value?: T | PromiseLike<T> | null) => {\n    this._setResult(States.RESOLVED, value);\n  };\n\n  /** JSDoc */\n  private readonly _reject = (reason?: any) => {\n    this._setResult(States.REJECTED, reason);\n  };\n\n  /** JSDoc */\n  private readonly _setResult = (state: States, value?: T | PromiseLike<T> | any) => {\n    if (this._state !== States.PENDING) {\n      return;\n    }\n\n    if (isThenable(value)) {\n      void (value as PromiseLike<T>).then(this._resolve, this._reject);\n      return;\n    }\n\n    this._state = state;\n    this._value = value;\n\n    this._executeHandlers();\n  };\n\n  /** JSDoc */\n  private readonly _executeHandlers = () => {\n    if (this._state === States.PENDING) {\n      return;\n    }\n\n    const cachedHandlers = this._handlers.slice();\n    this._handlers = [];\n\n    cachedHandlers.forEach(handler => {\n      if (handler[0]) {\n        return;\n      }\n\n      if (this._state === States.RESOLVED) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        handler[1](this._value as unknown as any);\n      }\n\n      if (this._state === States.REJECTED) {\n        handler[2](this._value);\n      }\n\n      handler[0] = true;\n    });\n  };\n}\n\nexport { SyncPromise };\n"]}/**
 * Returns a timestamp in seconds since the UNIX epoch using the Date API.
 */
export declare const dateTimestampInSeconds: () => number;
/**
 * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the
 * availability of the Performance API.
 *
 * See `usingPerformanceAPI` to test whether the Performance API is used.
 *
 * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is
 * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The
 * skew can grow to arbitrary amounts like days, weeks or months.
 * See https://github.com/getsentry/sentry-javascript/issues/2590.
 */
export declare const timestampInSeconds: () => number;
export declare const timestampWithMs: () => number;
/**
 * A boolean that is true when timestampInSeconds uses the Performance API to produce monotonic timestamps.
 */
export declare const usingPerformanceAPI: boolean;
/**
 * Internal helper to store what is the source of browserPerformanceTimeOrigin below. For debugging only.
 */
export declare let _browserPerformanceTimeOriginMode: string;
/**
 * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the
 * performance API is available.
 */
export declare const browserPerformanceTimeOrigin: number | undefined;
//# sourceMappingURL=time.d.ts.map{"version":3,"file":"time.d.ts","sourceRoot":"","sources":["../../src/time.ts"],"names":[],"mappings":"AAsGA;;GAEG;AACH,eAAO,MAAM,sBAAsB,EAAE,MAAM,MAAiE,CAAC;AAE7G;;;;;;;;;;GAUG;AACH,eAAO,MAAM,kBAAkB,EAAE,MAAM,MAAyD,CAAC;AAGjG,eAAO,MAAM,eAAe,cAAqB,CAAC;AAElD;;GAEG;AACH,eAAO,MAAM,mBAAmB,SAAoC,CAAC;AAErE;;GAEG;AACH,eAAO,IAAI,iCAAiC,EAAE,MAAM,CAAC;AAErD;;;GAGG;AACH,eAAO,MAAM,4BAA4B,oBA+CrC,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
var global_1 = require("./global");
var node_1 = require("./node");
/**
 * A TimestampSource implementation for environments that do not support the Performance Web API natively.
 *
 * Note that this TimestampSource does not use a monotonic clock. A call to `nowSeconds` may return a timestamp earlier
 * than a previously returned value. We do not try to emulate a monotonic behavior in order to facilitate debugging. It
 * is more obvious to explain "why does my span have negative duration" than "why my spans have zero duration".
 */
var dateTimestampSource = {
    nowSeconds: function () { return Date.now() / 1000; },
};
/**
 * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not
 * support the API.
 *
 * Wrapping the native API works around differences in behavior from different browsers.
 */
function getBrowserPerformance() {
    var performance = global_1.getGlobalObject().performance;
    if (!performance || !performance.now) {
        return undefined;
    }
    // Replace performance.timeOrigin with our own timeOrigin based on Date.now().
    //
    // This is a partial workaround for browsers reporting performance.timeOrigin such that performance.timeOrigin +
    // performance.now() gives a date arbitrarily in the past.
    //
    // Additionally, computing timeOrigin in this way fills the gap for browsers where performance.timeOrigin is
    // undefined.
    //
    // The assumption that performance.timeOrigin + performance.now() ~= Date.now() is flawed, but we depend on it to
    // interact with data coming out of performance entries.
    //
    // Note that despite recommendations against it in the spec, browsers implement the Performance API with a clock that
    // might stop when the computer is asleep (and perhaps under other circumstances). Such behavior causes
    // performance.timeOrigin + performance.now() to have an arbitrary skew over Date.now(). In laptop computers, we have
    // observed skews that can be as long as days, weeks or months.
    //
    // See https://github.com/getsentry/sentry-javascript/issues/2590.
    //
    // BUG: despite our best intentions, this workaround has its limitations. It mostly addresses timings of pageload
    // transactions, but ignores the skew built up over time that can aversely affect timestamps of navigation
    // transactions of long-lived web pages.
    var timeOrigin = Date.now() - performance.now();
    return {
        now: function () { return performance.now(); },
        timeOrigin: timeOrigin,
    };
}
/**
 * Returns the native Performance API implementation from Node.js. Returns undefined in old Node.js versions that don't
 * implement the API.
 */
function getNodePerformance() {
    try {
        var perfHooks = node_1.dynamicRequire(module, 'perf_hooks');
        return perfHooks.performance;
    }
    catch (_) {
        return undefined;
    }
}
/**
 * The Performance API implementation for the current platform, if available.
 */
var platformPerformance = node_1.isNodeEnv() ? getNodePerformance() : getBrowserPerformance();
var timestampSource = platformPerformance === undefined
    ? dateTimestampSource
    : {
        nowSeconds: function () { return (platformPerformance.timeOrigin + platformPerformance.now()) / 1000; },
    };
/**
 * Returns a timestamp in seconds since the UNIX epoch using the Date API.
 */
exports.dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);
/**
 * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the
 * availability of the Performance API.
 *
 * See `usingPerformanceAPI` to test whether the Performance API is used.
 *
 * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is
 * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The
 * skew can grow to arbitrary amounts like days, weeks or months.
 * See https://github.com/getsentry/sentry-javascript/issues/2590.
 */
exports.timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);
// Re-exported with an old name for backwards-compatibility.
exports.timestampWithMs = exports.timestampInSeconds;
/**
 * A boolean that is true when timestampInSeconds uses the Performance API to produce monotonic timestamps.
 */
exports.usingPerformanceAPI = platformPerformance !== undefined;
/**
 * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the
 * performance API is available.
 */
exports.browserPerformanceTimeOrigin = (function () {
    // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or
    // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin
    // data as reliable if they are within a reasonable threshold of the current time.
    var performance = global_1.getGlobalObject().performance;
    if (!performance || !performance.now) {
        exports._browserPerformanceTimeOriginMode = 'none';
        return undefined;
    }
    var threshold = 3600 * 1000;
    var performanceNow = performance.now();
    var dateNow = Date.now();
    // if timeOrigin isn't available set delta to threshold so it isn't used
    var timeOriginDelta = performance.timeOrigin
        ? Math.abs(performance.timeOrigin + performanceNow - dateNow)
        : threshold;
    var timeOriginIsReliable = timeOriginDelta < threshold;
    // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin
    // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.
    // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always
    // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the
    // Date API.
    // eslint-disable-next-line deprecation/deprecation
    var navigationStart = performance.timing && performance.timing.navigationStart;
    var hasNavigationStart = typeof navigationStart === 'number';
    // if navigationStart isn't available set delta to threshold so it isn't used
    var navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
    var navigationStartIsReliable = navigationStartDelta < threshold;
    if (timeOriginIsReliable || navigationStartIsReliable) {
        // Use the more reliable time origin
        if (timeOriginDelta <= navigationStartDelta) {
            exports._browserPerformanceTimeOriginMode = 'timeOrigin';
            return performance.timeOrigin;
        }
        else {
            exports._browserPerformanceTimeOriginMode = 'navigationStart';
            return navigationStart;
        }
    }
    // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to Date.
    exports._browserPerformanceTimeOriginMode = 'dateNow';
    return dateNow;
})();
//# sourceMappingURL=time.js.map{"version":3,"file":"time.js","sourceRoot":"","sources":["../../src/time.ts"],"names":[],"mappings":";AAAA,mCAA2C;AAC3C,+BAAmD;AASnD;;;;;;GAMG;AACH,IAAM,mBAAmB,GAAoB;IAC3C,UAAU,EAAE,cAAM,OAAA,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,EAAjB,CAAiB;CACpC,CAAC;AAiBF;;;;;GAKG;AACH,SAAS,qBAAqB;IACpB,IAAA,oDAAW,CAA+B;IAClD,IAAI,CAAC,WAAW,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE;QACpC,OAAO,SAAS,CAAC;KAClB;IAED,8EAA8E;IAC9E,EAAE;IACF,gHAAgH;IAChH,0DAA0D;IAC1D,EAAE;IACF,4GAA4G;IAC5G,aAAa;IACb,EAAE;IACF,iHAAiH;IACjH,wDAAwD;IACxD,EAAE;IACF,qHAAqH;IACrH,uGAAuG;IACvG,qHAAqH;IACrH,+DAA+D;IAC/D,EAAE;IACF,kEAAkE;IAClE,EAAE;IACF,iHAAiH;IACjH,0GAA0G;IAC1G,wCAAwC;IACxC,IAAM,UAAU,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;IAElD,OAAO;QACL,GAAG,EAAE,cAAM,OAAA,WAAW,CAAC,GAAG,EAAE,EAAjB,CAAiB;QAC5B,UAAU,YAAA;KACX,CAAC;AACJ,CAAC;AAED;;;GAGG;AACH,SAAS,kBAAkB;IACzB,IAAI;QACF,IAAM,SAAS,GAAG,qBAAc,CAAC,MAAM,EAAE,YAAY,CAAiC,CAAC;QACvF,OAAO,SAAS,CAAC,WAAW,CAAC;KAC9B;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,SAAS,CAAC;KAClB;AACH,CAAC;AAED;;GAEG;AACH,IAAM,mBAAmB,GAA4B,gBAAS,EAAE,CAAC,CAAC,CAAC,kBAAkB,EAAE,CAAC,CAAC,CAAC,qBAAqB,EAAE,CAAC;AAElH,IAAM,eAAe,GACnB,mBAAmB,KAAK,SAAS;IAC/B,CAAC,CAAC,mBAAmB;IACrB,CAAC,CAAC;QACE,UAAU,EAAE,cAAM,OAAA,CAAC,mBAAmB,CAAC,UAAU,GAAG,mBAAmB,CAAC,GAAG,EAAE,CAAC,GAAG,IAAI,EAAnE,CAAmE;KACtF,CAAC;AAER;;GAEG;AACU,QAAA,sBAAsB,GAAiB,mBAAmB,CAAC,UAAU,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;AAE7G;;;;;;;;;;GAUG;AACU,QAAA,kBAAkB,GAAiB,eAAe,CAAC,UAAU,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;AAEjG,4DAA4D;AAC/C,QAAA,eAAe,GAAG,0BAAkB,CAAC;AAElD;;GAEG;AACU,QAAA,mBAAmB,GAAG,mBAAmB,KAAK,SAAS,CAAC;AAOrE;;;GAGG;AACU,QAAA,4BAA4B,GAAG,CAAC;IAC3C,6GAA6G;IAC7G,mHAAmH;IACnH,kFAAkF;IAE1E,IAAA,oDAAW,CAA+B;IAClD,IAAI,CAAC,WAAW,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE;QACpC,yCAAiC,GAAG,MAAM,CAAC;QAC3C,OAAO,SAAS,CAAC;KAClB;IAED,IAAM,SAAS,GAAG,IAAI,GAAG,IAAI,CAAC;IAC9B,IAAM,cAAc,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;IACzC,IAAM,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;IAE3B,wEAAwE;IACxE,IAAM,eAAe,GAAG,WAAW,CAAC,UAAU;QAC5C,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,UAAU,GAAG,cAAc,GAAG,OAAO,CAAC;QAC7D,CAAC,CAAC,SAAS,CAAC;IACd,IAAM,oBAAoB,GAAG,eAAe,GAAG,SAAS,CAAC;IAEzD,oHAAoH;IACpH,mGAAmG;IACnG,qHAAqH;IACrH,qHAAqH;IACrH,YAAY;IACZ,mDAAmD;IACnD,IAAM,eAAe,GAAG,WAAW,CAAC,MAAM,IAAI,WAAW,CAAC,MAAM,CAAC,eAAe,CAAC;IACjF,IAAM,kBAAkB,GAAG,OAAO,eAAe,KAAK,QAAQ,CAAC;IAC/D,6EAA6E;IAC7E,IAAM,oBAAoB,GAAG,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,eAAe,GAAG,cAAc,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IACnH,IAAM,yBAAyB,GAAG,oBAAoB,GAAG,SAAS,CAAC;IAEnE,IAAI,oBAAoB,IAAI,yBAAyB,EAAE;QACrD,oCAAoC;QACpC,IAAI,eAAe,IAAI,oBAAoB,EAAE;YAC3C,yCAAiC,GAAG,YAAY,CAAC;YACjD,OAAO,WAAW,CAAC,UAAU,CAAC;SAC/B;aAAM;YACL,yCAAiC,GAAG,iBAAiB,CAAC;YACtD,OAAO,eAAe,CAAC;SACxB;KACF;IAED,mGAAmG;IACnG,yCAAiC,GAAG,SAAS,CAAC;IAC9C,OAAO,OAAO,CAAC;AACjB,CAAC,CAAC,EAAE,CAAC","sourcesContent":["import { getGlobalObject } from './global';\nimport { dynamicRequire, isNodeEnv } from './node';\n\n/**\n * An object that can return the current timestamp in seconds since the UNIX epoch.\n */\ninterface TimestampSource {\n  nowSeconds(): number;\n}\n\n/**\n * A TimestampSource implementation for environments that do not support the Performance Web API natively.\n *\n * Note that this TimestampSource does not use a monotonic clock. A call to `nowSeconds` may return a timestamp earlier\n * than a previously returned value. We do not try to emulate a monotonic behavior in order to facilitate debugging. It\n * is more obvious to explain \"why does my span have negative duration\" than \"why my spans have zero duration\".\n */\nconst dateTimestampSource: TimestampSource = {\n  nowSeconds: () => Date.now() / 1000,\n};\n\n/**\n * A partial definition of the [Performance Web API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance}\n * for accessing a high-resolution monotonic clock.\n */\ninterface Performance {\n  /**\n   * The millisecond timestamp at which measurement began, measured in Unix time.\n   */\n  timeOrigin: number;\n  /**\n   * Returns the current millisecond timestamp, where 0 represents the start of measurement.\n   */\n  now(): number;\n}\n\n/**\n * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not\n * support the API.\n *\n * Wrapping the native API works around differences in behavior from different browsers.\n */\nfunction getBrowserPerformance(): Performance | undefined {\n  const { performance } = getGlobalObject<Window>();\n  if (!performance || !performance.now) {\n    return undefined;\n  }\n\n  // Replace performance.timeOrigin with our own timeOrigin based on Date.now().\n  //\n  // This is a partial workaround for browsers reporting performance.timeOrigin such that performance.timeOrigin +\n  // performance.now() gives a date arbitrarily in the past.\n  //\n  // Additionally, computing timeOrigin in this way fills the gap for browsers where performance.timeOrigin is\n  // undefined.\n  //\n  // The assumption that performance.timeOrigin + performance.now() ~= Date.now() is flawed, but we depend on it to\n  // interact with data coming out of performance entries.\n  //\n  // Note that despite recommendations against it in the spec, browsers implement the Performance API with a clock that\n  // might stop when the computer is asleep (and perhaps under other circumstances). Such behavior causes\n  // performance.timeOrigin + performance.now() to have an arbitrary skew over Date.now(). In laptop computers, we have\n  // observed skews that can be as long as days, weeks or months.\n  //\n  // See https://github.com/getsentry/sentry-javascript/issues/2590.\n  //\n  // BUG: despite our best intentions, this workaround has its limitations. It mostly addresses timings of pageload\n  // transactions, but ignores the skew built up over time that can aversely affect timestamps of navigation\n  // transactions of long-lived web pages.\n  const timeOrigin = Date.now() - performance.now();\n\n  return {\n    now: () => performance.now(),\n    timeOrigin,\n  };\n}\n\n/**\n * Returns the native Performance API implementation from Node.js. Returns undefined in old Node.js versions that don't\n * implement the API.\n */\nfunction getNodePerformance(): Performance | undefined {\n  try {\n    const perfHooks = dynamicRequire(module, 'perf_hooks') as { performance: Performance };\n    return perfHooks.performance;\n  } catch (_) {\n    return undefined;\n  }\n}\n\n/**\n * The Performance API implementation for the current platform, if available.\n */\nconst platformPerformance: Performance | undefined = isNodeEnv() ? getNodePerformance() : getBrowserPerformance();\n\nconst timestampSource: TimestampSource =\n  platformPerformance === undefined\n    ? dateTimestampSource\n    : {\n        nowSeconds: () => (platformPerformance.timeOrigin + platformPerformance.now()) / 1000,\n      };\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using the Date API.\n */\nexport const dateTimestampInSeconds: () => number = dateTimestampSource.nowSeconds.bind(dateTimestampSource);\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the\n * availability of the Performance API.\n *\n * See `usingPerformanceAPI` to test whether the Performance API is used.\n *\n * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is\n * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The\n * skew can grow to arbitrary amounts like days, weeks or months.\n * See https://github.com/getsentry/sentry-javascript/issues/2590.\n */\nexport const timestampInSeconds: () => number = timestampSource.nowSeconds.bind(timestampSource);\n\n// Re-exported with an old name for backwards-compatibility.\nexport const timestampWithMs = timestampInSeconds;\n\n/**\n * A boolean that is true when timestampInSeconds uses the Performance API to produce monotonic timestamps.\n */\nexport const usingPerformanceAPI = platformPerformance !== undefined;\n\n/**\n * Internal helper to store what is the source of browserPerformanceTimeOrigin below. For debugging only.\n */\nexport let _browserPerformanceTimeOriginMode: string;\n\n/**\n * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the\n * performance API is available.\n */\nexport const browserPerformanceTimeOrigin = ((): number | undefined => {\n  // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or\n  // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin\n  // data as reliable if they are within a reasonable threshold of the current time.\n\n  const { performance } = getGlobalObject<Window>();\n  if (!performance || !performance.now) {\n    _browserPerformanceTimeOriginMode = 'none';\n    return undefined;\n  }\n\n  const threshold = 3600 * 1000;\n  const performanceNow = performance.now();\n  const dateNow = Date.now();\n\n  // if timeOrigin isn't available set delta to threshold so it isn't used\n  const timeOriginDelta = performance.timeOrigin\n    ? Math.abs(performance.timeOrigin + performanceNow - dateNow)\n    : threshold;\n  const timeOriginIsReliable = timeOriginDelta < threshold;\n\n  // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin\n  // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.\n  // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always\n  // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the\n  // Date API.\n  // eslint-disable-next-line deprecation/deprecation\n  const navigationStart = performance.timing && performance.timing.navigationStart;\n  const hasNavigationStart = typeof navigationStart === 'number';\n  // if navigationStart isn't available set delta to threshold so it isn't used\n  const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;\n  const navigationStartIsReliable = navigationStartDelta < threshold;\n\n  if (timeOriginIsReliable || navigationStartIsReliable) {\n    // Use the more reliable time origin\n    if (timeOriginDelta <= navigationStartDelta) {\n      _browserPerformanceTimeOriginMode = 'timeOrigin';\n      return performance.timeOrigin;\n    } else {\n      _browserPerformanceTimeOriginMode = 'navigationStart';\n      return navigationStart;\n    }\n  }\n\n  // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to Date.\n  _browserPerformanceTimeOriginMode = 'dateNow';\n  return dateNow;\n})();\n"]}import { TraceparentData } from '@sentry/types';
export declare const TRACEPARENT_REGEXP: RegExp;
/**
 * Extract transaction context data from a `sentry-trace` header.
 *
 * @param traceparent Traceparent string
 *
 * @returns Object containing data from the header, or undefined if traceparent string is malformed
 */
export declare function extractTraceparentData(traceparent: string): TraceparentData | undefined;
//# sourceMappingURL=tracing.d.ts.map{"version":3,"file":"tracing.d.ts","sourceRoot":"","sources":["../../src/tracing.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,eAAe,EAAE,MAAM,eAAe,CAAC;AAEhD,eAAO,MAAM,kBAAkB,QAM9B,CAAC;AAEF;;;;;;GAMG;AACH,wBAAgB,sBAAsB,CAAC,WAAW,EAAE,MAAM,GAAG,eAAe,GAAG,SAAS,CAgBvF"}Object.defineProperty(exports, "__esModule", { value: true });
exports.TRACEPARENT_REGEXP = new RegExp('^[ \\t]*' + // whitespace
    '([0-9a-f]{32})?' + // trace_id
    '-?([0-9a-f]{16})?' + // span_id
    '-?([01])?' + // sampled
    '[ \\t]*$');
/**
 * Extract transaction context data from a `sentry-trace` header.
 *
 * @param traceparent Traceparent string
 *
 * @returns Object containing data from the header, or undefined if traceparent string is malformed
 */
function extractTraceparentData(traceparent) {
    var matches = traceparent.match(exports.TRACEPARENT_REGEXP);
    if (matches) {
        var parentSampled = void 0;
        if (matches[3] === '1') {
            parentSampled = true;
        }
        else if (matches[3] === '0') {
            parentSampled = false;
        }
        return {
            traceId: matches[1],
            parentSampled: parentSampled,
            parentSpanId: matches[2],
        };
    }
    return undefined;
}
exports.extractTraceparentData = extractTraceparentData;
//# sourceMappingURL=tracing.js.map{"version":3,"file":"tracing.js","sourceRoot":"","sources":["../../src/tracing.ts"],"names":[],"mappings":";AAEa,QAAA,kBAAkB,GAAG,IAAI,MAAM,CAC1C,UAAU,GAAG,aAAa;IACxB,iBAAiB,GAAG,WAAW;IAC/B,mBAAmB,GAAG,UAAU;IAChC,WAAW,GAAG,UAAU;IACxB,UAAU,CACb,CAAC;AAEF;;;;;;GAMG;AACH,SAAgB,sBAAsB,CAAC,WAAmB;IACxD,IAAM,OAAO,GAAG,WAAW,CAAC,KAAK,CAAC,0BAAkB,CAAC,CAAC;IACtD,IAAI,OAAO,EAAE;QACX,IAAI,aAAa,SAAqB,CAAC;QACvC,IAAI,OAAO,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;YACtB,aAAa,GAAG,IAAI,CAAC;SACtB;aAAM,IAAI,OAAO,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;YAC7B,aAAa,GAAG,KAAK,CAAC;SACvB;QACD,OAAO;YACL,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC;YACnB,aAAa,eAAA;YACb,YAAY,EAAE,OAAO,CAAC,CAAC,CAAC;SACzB,CAAC;KACH;IACD,OAAO,SAAS,CAAC;AACnB,CAAC;AAhBD,wDAgBC","sourcesContent":["import { TraceparentData } from '@sentry/types';\n\nexport const TRACEPARENT_REGEXP = new RegExp(\n  '^[ \\\\t]*' + // whitespace\n    '([0-9a-f]{32})?' + // trace_id\n    '-?([0-9a-f]{16})?' + // span_id\n    '-?([01])?' + // sampled\n    '[ \\\\t]*$', // whitespace\n);\n\n/**\n * Extract transaction context data from a `sentry-trace` header.\n *\n * @param traceparent Traceparent string\n *\n * @returns Object containing data from the header, or undefined if traceparent string is malformed\n */\nexport function extractTraceparentData(traceparent: string): TraceparentData | undefined {\n  const matches = traceparent.match(TRACEPARENT_REGEXP);\n  if (matches) {\n    let parentSampled: boolean | undefined;\n    if (matches[3] === '1') {\n      parentSampled = true;\n    } else if (matches[3] === '0') {\n      parentSampled = false;\n    }\n    return {\n      traceId: matches[1],\n      parentSampled,\n      parentSpanId: matches[2],\n    };\n  }\n  return undefined;\n}\n"]}/**
 * Consumes the promise and logs the error when it rejects.
 * @param promise A promise to forget.
 */
export declare function forget(promise: PromiseLike<any>): void;
//# sourceMappingURL=async.d.ts.map{"version":3,"file":"async.d.ts","sourceRoot":"","sources":["../../src/async.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,wBAAgB,MAAM,CAAC,OAAO,EAAE,WAAW,CAAC,GAAG,CAAC,GAAG,IAAI,CAMtD"}/**
 * Consumes the promise and logs the error when it rejects.
 * @param promise A promise to forget.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function forget(promise) {
    void promise.then(null, function (e) {
        // TODO: Use a better logging mechanism
        // eslint-disable-next-line no-console
        console.error(e);
    });
}
//# sourceMappingURL=async.js.map{"version":3,"file":"async.js","sourceRoot":"","sources":["../../src/async.ts"],"names":[],"mappings":"AAAA;;;GAGG;AACH,8DAA8D;AAC9D,MAAM,UAAU,MAAM,CAAC,OAAyB;IAC9C,KAAK,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,UAAA,CAAC;QACvB,uCAAuC;QACvC,sCAAsC;QACtC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACnB,CAAC,CAAC,CAAC;AACL,CAAC","sourcesContent":["/**\n * Consumes the promise and logs the error when it rejects.\n * @param promise A promise to forget.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function forget(promise: PromiseLike<any>): void {\n  void promise.then(null, e => {\n    // TODO: Use a better logging mechanism\n    // eslint-disable-next-line no-console\n    console.error(e);\n  });\n}\n"]}/**
 * Given a child DOM element, returns a query-selector statement describing that
 * and its ancestors
 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
 * @returns generated DOM path
 */
export declare function htmlTreeAsString(elem: unknown, keyAttrs?: string[]): string;
/**
 * A safe form of location.href
 */
export declare function getLocationHref(): string;
//# sourceMappingURL=browser.d.ts.map{"version":3,"file":"browser.d.ts","sourceRoot":"","sources":["../../src/browser.ts"],"names":[],"mappings":"AAGA;;;;;GAKG;AACH,wBAAgB,gBAAgB,CAAC,IAAI,EAAE,OAAO,EAAE,QAAQ,CAAC,EAAE,MAAM,EAAE,GAAG,MAAM,CAyC3E;AA+DD;;GAEG;AACH,wBAAgB,eAAe,IAAI,MAAM,CAOxC"}import { getGlobalObject } from './global';
import { isString } from './is';
/**
 * Given a child DOM element, returns a query-selector statement describing that
 * and its ancestors
 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
 * @returns generated DOM path
 */
export function htmlTreeAsString(elem, keyAttrs) {
    // try/catch both:
    // - accessing event.target (see getsentry/raven-js#838, #768)
    // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
    // - can throw an exception in some circumstances.
    try {
        var currentElem = elem;
        var MAX_TRAVERSE_HEIGHT = 5;
        var MAX_OUTPUT_LEN = 80;
        var out = [];
        var height = 0;
        var len = 0;
        var separator = ' > ';
        var sepLength = separator.length;
        var nextStr = void 0;
        // eslint-disable-next-line no-plusplus
        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
            nextStr = _htmlElementAsString(currentElem, keyAttrs);
            // bail out if
            // - nextStr is the 'html' element
            // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
            //   (ignore this limit if we are on the first iteration)
            if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)) {
                break;
            }
            out.push(nextStr);
            len += nextStr.length;
            currentElem = currentElem.parentNode;
        }
        return out.reverse().join(separator);
    }
    catch (_oO) {
        return '<unknown>';
    }
}
/**
 * Returns a simple, query-selector representation of a DOM element
 * e.g. [HTMLElement] => input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function _htmlElementAsString(el, keyAttrs) {
    var elem = el;
    var out = [];
    var className;
    var classes;
    var key;
    var attr;
    var i;
    if (!elem || !elem.tagName) {
        return '';
    }
    out.push(elem.tagName.toLowerCase());
    // Pairs of attribute keys defined in `serializeAttribute` and their values on element.
    var keyAttrPairs = keyAttrs && keyAttrs.length
        ? keyAttrs.filter(function (keyAttr) { return elem.getAttribute(keyAttr); }).map(function (keyAttr) { return [keyAttr, elem.getAttribute(keyAttr)]; })
        : null;
    if (keyAttrPairs && keyAttrPairs.length) {
        keyAttrPairs.forEach(function (keyAttrPair) {
            out.push("[" + keyAttrPair[0] + "=\"" + keyAttrPair[1] + "\"]");
        });
    }
    else {
        if (elem.id) {
            out.push("#" + elem.id);
        }
        // eslint-disable-next-line prefer-const
        className = elem.className;
        if (className && isString(className)) {
            classes = className.split(/\s+/);
            for (i = 0; i < classes.length; i++) {
                out.push("." + classes[i]);
            }
        }
    }
    var allowedAttrs = ['type', 'name', 'title', 'alt'];
    for (i = 0; i < allowedAttrs.length; i++) {
        key = allowedAttrs[i];
        attr = elem.getAttribute(key);
        if (attr) {
            out.push("[" + key + "=\"" + attr + "\"]");
        }
    }
    return out.join('');
}
/**
 * A safe form of location.href
 */
export function getLocationHref() {
    var global = getGlobalObject();
    try {
        return global.document.location.href;
    }
    catch (oO) {
        return '';
    }
}
//# sourceMappingURL=browser.js.map{"version":3,"file":"browser.js","sourceRoot":"","sources":["../../src/browser.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAC3C,OAAO,EAAE,QAAQ,EAAE,MAAM,MAAM,CAAC;AAEhC;;;;;GAKG;AACH,MAAM,UAAU,gBAAgB,CAAC,IAAa,EAAE,QAAmB;IAKjE,kBAAkB;IAClB,8DAA8D;IAC9D,oFAAoF;IACpF,kDAAkD;IAClD,IAAI;QACF,IAAI,WAAW,GAAG,IAAkB,CAAC;QACrC,IAAM,mBAAmB,GAAG,CAAC,CAAC;QAC9B,IAAM,cAAc,GAAG,EAAE,CAAC;QAC1B,IAAM,GAAG,GAAG,EAAE,CAAC;QACf,IAAI,MAAM,GAAG,CAAC,CAAC;QACf,IAAI,GAAG,GAAG,CAAC,CAAC;QACZ,IAAM,SAAS,GAAG,KAAK,CAAC;QACxB,IAAM,SAAS,GAAG,SAAS,CAAC,MAAM,CAAC;QACnC,IAAI,OAAO,SAAA,CAAC;QAEZ,uCAAuC;QACvC,OAAO,WAAW,IAAI,MAAM,EAAE,GAAG,mBAAmB,EAAE;YACpD,OAAO,GAAG,oBAAoB,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;YACtD,cAAc;YACd,kCAAkC;YAClC,0EAA0E;YAC1E,yDAAyD;YACzD,IAAI,OAAO,KAAK,MAAM,IAAI,CAAC,MAAM,GAAG,CAAC,IAAI,GAAG,GAAG,GAAG,CAAC,MAAM,GAAG,SAAS,GAAG,OAAO,CAAC,MAAM,IAAI,cAAc,CAAC,EAAE;gBACzG,MAAM;aACP;YAED,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YAElB,GAAG,IAAI,OAAO,CAAC,MAAM,CAAC;YACtB,WAAW,GAAG,WAAW,CAAC,UAAU,CAAC;SACtC;QAED,OAAO,GAAG,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;KACtC;IAAC,OAAO,GAAG,EAAE;QACZ,OAAO,WAAW,CAAC;KACpB;AACH,CAAC;AAED;;;;GAIG;AACH,SAAS,oBAAoB,CAAC,EAAW,EAAE,QAAmB;IAC5D,IAAM,IAAI,GAAG,EAKZ,CAAC;IAEF,IAAM,GAAG,GAAG,EAAE,CAAC;IACf,IAAI,SAAS,CAAC;IACd,IAAI,OAAO,CAAC;IACZ,IAAI,GAAG,CAAC;IACR,IAAI,IAAI,CAAC;IACT,IAAI,CAAC,CAAC;IAEN,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;QAC1B,OAAO,EAAE,CAAC;KACX;IAED,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC,CAAC;IAErC,uFAAuF;IACvF,IAAM,YAAY,GAChB,QAAQ,IAAI,QAAQ,CAAC,MAAM;QACzB,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAA,OAAO,IAAI,OAAA,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,EAA1B,CAA0B,CAAC,CAAC,GAAG,CAAC,UAAA,OAAO,IAAI,OAAA,CAAC,OAAO,EAAE,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,EAArC,CAAqC,CAAC;QAC9G,CAAC,CAAC,IAAI,CAAC;IAEX,IAAI,YAAY,IAAI,YAAY,CAAC,MAAM,EAAE;QACvC,YAAY,CAAC,OAAO,CAAC,UAAA,WAAW;YAC9B,GAAG,CAAC,IAAI,CAAC,MAAI,WAAW,CAAC,CAAC,CAAC,WAAK,WAAW,CAAC,CAAC,CAAC,QAAI,CAAC,CAAC;QACtD,CAAC,CAAC,CAAC;KACJ;SAAM;QACL,IAAI,IAAI,CAAC,EAAE,EAAE;YACX,GAAG,CAAC,IAAI,CAAC,MAAI,IAAI,CAAC,EAAI,CAAC,CAAC;SACzB;QAED,wCAAwC;QACxC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;QAC3B,IAAI,SAAS,IAAI,QAAQ,CAAC,SAAS,CAAC,EAAE;YACpC,OAAO,GAAG,SAAS,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;YACjC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACnC,GAAG,CAAC,IAAI,CAAC,MAAI,OAAO,CAAC,CAAC,CAAG,CAAC,CAAC;aAC5B;SACF;KACF;IACD,IAAM,YAAY,GAAG,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;IACtD,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACxC,GAAG,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;QACtB,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;QAC9B,IAAI,IAAI,EAAE;YACR,GAAG,CAAC,IAAI,CAAC,MAAI,GAAG,WAAK,IAAI,QAAI,CAAC,CAAC;SAChC;KACF;IACD,OAAO,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;AACtB,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,eAAe;IAC7B,IAAM,MAAM,GAAG,eAAe,EAAU,CAAC;IACzC,IAAI;QACF,OAAO,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC;KACtC;IAAC,OAAO,EAAE,EAAE;QACX,OAAO,EAAE,CAAC;KACX;AACH,CAAC","sourcesContent":["import { getGlobalObject } from './global';\nimport { isString } from './is';\n\n/**\n * Given a child DOM element, returns a query-selector statement describing that\n * and its ancestors\n * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]\n * @returns generated DOM path\n */\nexport function htmlTreeAsString(elem: unknown, keyAttrs?: string[]): string {\n  type SimpleNode = {\n    parentNode: SimpleNode;\n  } | null;\n\n  // try/catch both:\n  // - accessing event.target (see getsentry/raven-js#838, #768)\n  // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly\n  // - can throw an exception in some circumstances.\n  try {\n    let currentElem = elem as SimpleNode;\n    const MAX_TRAVERSE_HEIGHT = 5;\n    const MAX_OUTPUT_LEN = 80;\n    const out = [];\n    let height = 0;\n    let len = 0;\n    const separator = ' > ';\n    const sepLength = separator.length;\n    let nextStr;\n\n    // eslint-disable-next-line no-plusplus\n    while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {\n      nextStr = _htmlElementAsString(currentElem, keyAttrs);\n      // bail out if\n      // - nextStr is the 'html' element\n      // - the length of the string that would be created exceeds MAX_OUTPUT_LEN\n      //   (ignore this limit if we are on the first iteration)\n      if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)) {\n        break;\n      }\n\n      out.push(nextStr);\n\n      len += nextStr.length;\n      currentElem = currentElem.parentNode;\n    }\n\n    return out.reverse().join(separator);\n  } catch (_oO) {\n    return '<unknown>';\n  }\n}\n\n/**\n * Returns a simple, query-selector representation of a DOM element\n * e.g. [HTMLElement] => input#foo.btn[name=baz]\n * @returns generated DOM path\n */\nfunction _htmlElementAsString(el: unknown, keyAttrs?: string[]): string {\n  const elem = el as {\n    tagName?: string;\n    id?: string;\n    className?: string;\n    getAttribute(key: string): string;\n  };\n\n  const out = [];\n  let className;\n  let classes;\n  let key;\n  let attr;\n  let i;\n\n  if (!elem || !elem.tagName) {\n    return '';\n  }\n\n  out.push(elem.tagName.toLowerCase());\n\n  // Pairs of attribute keys defined in `serializeAttribute` and their values on element.\n  const keyAttrPairs =\n    keyAttrs && keyAttrs.length\n      ? keyAttrs.filter(keyAttr => elem.getAttribute(keyAttr)).map(keyAttr => [keyAttr, elem.getAttribute(keyAttr)])\n      : null;\n\n  if (keyAttrPairs && keyAttrPairs.length) {\n    keyAttrPairs.forEach(keyAttrPair => {\n      out.push(`[${keyAttrPair[0]}=\"${keyAttrPair[1]}\"]`);\n    });\n  } else {\n    if (elem.id) {\n      out.push(`#${elem.id}`);\n    }\n\n    // eslint-disable-next-line prefer-const\n    className = elem.className;\n    if (className && isString(className)) {\n      classes = className.split(/\\s+/);\n      for (i = 0; i < classes.length; i++) {\n        out.push(`.${classes[i]}`);\n      }\n    }\n  }\n  const allowedAttrs = ['type', 'name', 'title', 'alt'];\n  for (i = 0; i < allowedAttrs.length; i++) {\n    key = allowedAttrs[i];\n    attr = elem.getAttribute(key);\n    if (attr) {\n      out.push(`[${key}=\"${attr}\"]`);\n    }\n  }\n  return out.join('');\n}\n\n/**\n * A safe form of location.href\n */\nexport function getLocationHref(): string {\n  const global = getGlobalObject<Window>();\n  try {\n    return global.document.location.href;\n  } catch (oO) {\n    return '';\n  }\n}\n"]}import { ClientReport, ClientReportEnvelope } from '@sentry/types';
/**
 * Creates client report envelope
 * @param discarded_events An array of discard events
 * @param dsn A DSN that can be set on the header. Optional.
 */
export declare function createClientReportEnvelope(discarded_events: ClientReport['discarded_events'], dsn?: string, timestamp?: number): ClientReportEnvelope;
//# sourceMappingURL=clientreport.d.ts.map{"version":3,"file":"clientreport.d.ts","sourceRoot":"","sources":["../../src/clientreport.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,oBAAoB,EAAoB,MAAM,eAAe,CAAC;AAKrF;;;;GAIG;AACH,wBAAgB,0BAA0B,CACxC,gBAAgB,EAAE,YAAY,CAAC,kBAAkB,CAAC,EAClD,GAAG,CAAC,EAAE,MAAM,EACZ,SAAS,CAAC,EAAE,MAAM,GACjB,oBAAoB,CAStB"}import { createEnvelope } from './envelope';
import { dateTimestampInSeconds } from './time';
/**
 * Creates client report envelope
 * @param discarded_events An array of discard events
 * @param dsn A DSN that can be set on the header. Optional.
 */
export function createClientReportEnvelope(discarded_events, dsn, timestamp) {
    var clientReportItem = [
        { type: 'client_report' },
        {
            timestamp: timestamp || dateTimestampInSeconds(),
            discarded_events: discarded_events,
        },
    ];
    return createEnvelope(dsn ? { dsn: dsn } : {}, [clientReportItem]);
}
//# sourceMappingURL=clientreport.js.map{"version":3,"file":"clientreport.js","sourceRoot":"","sources":["../../src/clientreport.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,cAAc,EAAE,MAAM,YAAY,CAAC;AAC5C,OAAO,EAAE,sBAAsB,EAAE,MAAM,QAAQ,CAAC;AAEhD;;;;GAIG;AACH,MAAM,UAAU,0BAA0B,CACxC,gBAAkD,EAClD,GAAY,EACZ,SAAkB;IAElB,IAAM,gBAAgB,GAAqB;QACzC,EAAE,IAAI,EAAE,eAAe,EAAE;QACzB;YACE,SAAS,EAAE,SAAS,IAAI,sBAAsB,EAAE;YAChD,gBAAgB,kBAAA;SACjB;KACF,CAAC;IACF,OAAO,cAAc,CAAuB,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,KAAA,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,gBAAgB,CAAC,CAAC,CAAC;AACtF,CAAC","sourcesContent":["import { ClientReport, ClientReportEnvelope, ClientReportItem } from '@sentry/types';\n\nimport { createEnvelope } from './envelope';\nimport { dateTimestampInSeconds } from './time';\n\n/**\n * Creates client report envelope\n * @param discarded_events An array of discard events\n * @param dsn A DSN that can be set on the header. Optional.\n */\nexport function createClientReportEnvelope(\n  discarded_events: ClientReport['discarded_events'],\n  dsn?: string,\n  timestamp?: number,\n): ClientReportEnvelope {\n  const clientReportItem: ClientReportItem = [\n    { type: 'client_report' },\n    {\n      timestamp: timestamp || dateTimestampInSeconds(),\n      discarded_events,\n    },\n  ];\n  return createEnvelope<ClientReportEnvelope>(dsn ? { dsn } : {}, [clientReportItem]);\n}\n"]}import { DsnComponents, DsnLike } from '@sentry/types';
/**
 * Renders the string representation of this Dsn.
 *
 * By default, this will render the public representation without the password
 * component. To get the deprecated private representation, set `withPassword`
 * to true.
 *
 * @param withPassword When set to true, the password will be included.
 */
export declare function dsnToString(dsn: DsnComponents, withPassword?: boolean): string;
/** The Sentry Dsn, identifying a Sentry instance and project. */
export declare function makeDsn(from: DsnLike): DsnComponents;
//# sourceMappingURL=dsn.d.ts.map{"version":3,"file":"dsn.d.ts","sourceRoot":"","sources":["../../src/dsn.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,OAAO,EAAe,MAAM,eAAe,CAAC;AAYpE;;;;;;;;GAQG;AACH,wBAAgB,WAAW,CAAC,GAAG,EAAE,aAAa,EAAE,YAAY,GAAE,OAAe,GAAG,MAAM,CAMrF;AA4ED,iEAAiE;AACjE,wBAAgB,OAAO,CAAC,IAAI,EAAE,OAAO,GAAG,aAAa,CAMpD"}import { __read } from "tslib";
import { SentryError } from './error';
import { IS_DEBUG_BUILD } from './flags';
/** Regular expression used to parse a Dsn. */
var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+))?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function isValidProtocol(protocol) {
    return protocol === 'http' || protocol === 'https';
}
/**
 * Renders the string representation of this Dsn.
 *
 * By default, this will render the public representation without the password
 * component. To get the deprecated private representation, set `withPassword`
 * to true.
 *
 * @param withPassword When set to true, the password will be included.
 */
export function dsnToString(dsn, withPassword) {
    if (withPassword === void 0) { withPassword = false; }
    var host = dsn.host, path = dsn.path, pass = dsn.pass, port = dsn.port, projectId = dsn.projectId, protocol = dsn.protocol, publicKey = dsn.publicKey;
    return (protocol + "://" + publicKey + (withPassword && pass ? ":" + pass : '') +
        ("@" + host + (port ? ":" + port : '') + "/" + (path ? path + "/" : path) + projectId));
}
function dsnFromString(str) {
    var match = DSN_REGEX.exec(str);
    if (!match) {
        throw new SentryError("Invalid Sentry Dsn: " + str);
    }
    var _a = __read(match.slice(1), 6), protocol = _a[0], publicKey = _a[1], _b = _a[2], pass = _b === void 0 ? '' : _b, host = _a[3], _c = _a[4], port = _c === void 0 ? '' : _c, lastPath = _a[5];
    var path = '';
    var projectId = lastPath;
    var split = projectId.split('/');
    if (split.length > 1) {
        path = split.slice(0, -1).join('/');
        projectId = split.pop();
    }
    if (projectId) {
        var projectMatch = projectId.match(/^\d+/);
        if (projectMatch) {
            projectId = projectMatch[0];
        }
    }
    return dsnFromComponents({ host: host, pass: pass, path: path, projectId: projectId, port: port, protocol: protocol, publicKey: publicKey });
}
function dsnFromComponents(components) {
    // TODO this is for backwards compatibility, and can be removed in a future version
    if ('user' in components && !('publicKey' in components)) {
        components.publicKey = components.user;
    }
    return {
        user: components.publicKey || '',
        protocol: components.protocol,
        publicKey: components.publicKey || '',
        pass: components.pass || '',
        host: components.host,
        port: components.port || '',
        path: components.path || '',
        projectId: components.projectId,
    };
}
function validateDsn(dsn) {
    if (!IS_DEBUG_BUILD) {
        return;
    }
    var port = dsn.port, projectId = dsn.projectId, protocol = dsn.protocol;
    var requiredComponents = ['protocol', 'publicKey', 'host', 'projectId'];
    requiredComponents.forEach(function (component) {
        if (!dsn[component]) {
            throw new SentryError("Invalid Sentry Dsn: " + component + " missing");
        }
    });
    if (!projectId.match(/^\d+$/)) {
        throw new SentryError("Invalid Sentry Dsn: Invalid projectId " + projectId);
    }
    if (!isValidProtocol(protocol)) {
        throw new SentryError("Invalid Sentry Dsn: Invalid protocol " + protocol);
    }
    if (port && isNaN(parseInt(port, 10))) {
        throw new SentryError("Invalid Sentry Dsn: Invalid port " + port);
    }
    return true;
}
/** The Sentry Dsn, identifying a Sentry instance and project. */
export function makeDsn(from) {
    var components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);
    validateDsn(components);
    return components;
}
//# sourceMappingURL=dsn.js.map{"version":3,"file":"dsn.js","sourceRoot":"","sources":["../../src/dsn.ts"],"names":[],"mappings":";AAEA,OAAO,EAAE,WAAW,EAAE,MAAM,SAAS,CAAC;AACtC,OAAO,EAAE,cAAc,EAAE,MAAM,SAAS,CAAC;AAEzC,8CAA8C;AAC9C,IAAM,SAAS,GAAG,gEAAgE,CAAC;AAEnF,SAAS,eAAe,CAAC,QAAiB;IACxC,OAAO,QAAQ,KAAK,MAAM,IAAI,QAAQ,KAAK,OAAO,CAAC;AACrD,CAAC;AAED;;;;;;;;GAQG;AACH,MAAM,UAAU,WAAW,CAAC,GAAkB,EAAE,YAA6B;IAA7B,6BAAA,EAAA,oBAA6B;IACnE,IAAA,eAAI,EAAE,eAAI,EAAE,eAAI,EAAE,eAAI,EAAE,yBAAS,EAAE,uBAAQ,EAAE,yBAAS,CAAS;IACvE,OAAO,CACF,QAAQ,WAAM,SAAS,IAAG,YAAY,IAAI,IAAI,CAAC,CAAC,CAAC,MAAI,IAAM,CAAC,CAAC,CAAC,EAAE,CAAE;SACrE,MAAI,IAAI,IAAG,IAAI,CAAC,CAAC,CAAC,MAAI,IAAM,CAAC,CAAC,CAAC,EAAE,WAAI,IAAI,CAAC,CAAC,CAAI,IAAI,MAAG,CAAC,CAAC,CAAC,IAAI,IAAG,SAAW,CAAA,CAC5E,CAAC;AACJ,CAAC;AAED,SAAS,aAAa,CAAC,GAAW;IAChC,IAAM,KAAK,GAAG,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAElC,IAAI,CAAC,KAAK,EAAE;QACV,MAAM,IAAI,WAAW,CAAC,yBAAuB,GAAK,CAAC,CAAC;KACrD;IAEK,IAAA,8BAA4E,EAA3E,gBAAQ,EAAE,iBAAS,EAAE,UAAS,EAAT,8BAAS,EAAE,YAAI,EAAE,UAAS,EAAT,8BAAS,EAAE,gBAA0B,CAAC;IACnF,IAAI,IAAI,GAAG,EAAE,CAAC;IACd,IAAI,SAAS,GAAG,QAAQ,CAAC;IAEzB,IAAM,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACnC,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;QACpB,IAAI,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACpC,SAAS,GAAG,KAAK,CAAC,GAAG,EAAY,CAAC;KACnC;IAED,IAAI,SAAS,EAAE;QACb,IAAM,YAAY,GAAG,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;QAC7C,IAAI,YAAY,EAAE;YAChB,SAAS,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;SAC7B;KACF;IAED,OAAO,iBAAiB,CAAC,EAAE,IAAI,MAAA,EAAE,IAAI,MAAA,EAAE,IAAI,MAAA,EAAE,SAAS,WAAA,EAAE,IAAI,MAAA,EAAE,QAAQ,EAAE,QAAuB,EAAE,SAAS,WAAA,EAAE,CAAC,CAAC;AAChH,CAAC;AAED,SAAS,iBAAiB,CAAC,UAAyB;IAClD,mFAAmF;IACnF,IAAI,MAAM,IAAI,UAAU,IAAI,CAAC,CAAC,WAAW,IAAI,UAAU,CAAC,EAAE;QACxD,UAAU,CAAC,SAAS,GAAG,UAAU,CAAC,IAAI,CAAC;KACxC;IAED,OAAO;QACL,IAAI,EAAE,UAAU,CAAC,SAAS,IAAI,EAAE;QAChC,QAAQ,EAAE,UAAU,CAAC,QAAQ;QAC7B,SAAS,EAAE,UAAU,CAAC,SAAS,IAAI,EAAE;QACrC,IAAI,EAAE,UAAU,CAAC,IAAI,IAAI,EAAE;QAC3B,IAAI,EAAE,UAAU,CAAC,IAAI;QACrB,IAAI,EAAE,UAAU,CAAC,IAAI,IAAI,EAAE;QAC3B,IAAI,EAAE,UAAU,CAAC,IAAI,IAAI,EAAE;QAC3B,SAAS,EAAE,UAAU,CAAC,SAAS;KAChC,CAAC;AACJ,CAAC;AAED,SAAS,WAAW,CAAC,GAAkB;IACrC,IAAI,CAAC,cAAc,EAAE;QACnB,OAAO;KACR;IAEO,IAAA,eAAI,EAAE,yBAAS,EAAE,uBAAQ,CAAS;IAE1C,IAAM,kBAAkB,GAAuC,CAAC,UAAU,EAAE,WAAW,EAAE,MAAM,EAAE,WAAW,CAAC,CAAC;IAC9G,kBAAkB,CAAC,OAAO,CAAC,UAAA,SAAS;QAClC,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;YACnB,MAAM,IAAI,WAAW,CAAC,yBAAuB,SAAS,aAAU,CAAC,CAAC;SACnE;IACH,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE;QAC7B,MAAM,IAAI,WAAW,CAAC,2CAAyC,SAAW,CAAC,CAAC;KAC7E;IAED,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,EAAE;QAC9B,MAAM,IAAI,WAAW,CAAC,0CAAwC,QAAU,CAAC,CAAC;KAC3E;IAED,IAAI,IAAI,IAAI,KAAK,CAAC,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,EAAE;QACrC,MAAM,IAAI,WAAW,CAAC,sCAAoC,IAAM,CAAC,CAAC;KACnE;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAED,iEAAiE;AACjE,MAAM,UAAU,OAAO,CAAC,IAAa;IACnC,IAAM,UAAU,GAAG,OAAO,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;IAE5F,WAAW,CAAC,UAAU,CAAC,CAAC;IAExB,OAAO,UAAU,CAAC;AACpB,CAAC","sourcesContent":["import { DsnComponents, DsnLike, DsnProtocol } from '@sentry/types';\n\nimport { SentryError } from './error';\nimport { IS_DEBUG_BUILD } from './flags';\n\n/** Regular expression used to parse a Dsn. */\nconst DSN_REGEX = /^(?:(\\w+):)\\/\\/(?:(\\w+)(?::(\\w+))?@)([\\w.-]+)(?::(\\d+))?\\/(.+)/;\n\nfunction isValidProtocol(protocol?: string): protocol is DsnProtocol {\n  return protocol === 'http' || protocol === 'https';\n}\n\n/**\n * Renders the string representation of this Dsn.\n *\n * By default, this will render the public representation without the password\n * component. To get the deprecated private representation, set `withPassword`\n * to true.\n *\n * @param withPassword When set to true, the password will be included.\n */\nexport function dsnToString(dsn: DsnComponents, withPassword: boolean = false): string {\n  const { host, path, pass, port, projectId, protocol, publicKey } = dsn;\n  return (\n    `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ''}` +\n    `@${host}${port ? `:${port}` : ''}/${path ? `${path}/` : path}${projectId}`\n  );\n}\n\nfunction dsnFromString(str: string): DsnComponents {\n  const match = DSN_REGEX.exec(str);\n\n  if (!match) {\n    throw new SentryError(`Invalid Sentry Dsn: ${str}`);\n  }\n\n  const [protocol, publicKey, pass = '', host, port = '', lastPath] = match.slice(1);\n  let path = '';\n  let projectId = lastPath;\n\n  const split = projectId.split('/');\n  if (split.length > 1) {\n    path = split.slice(0, -1).join('/');\n    projectId = split.pop() as string;\n  }\n\n  if (projectId) {\n    const projectMatch = projectId.match(/^\\d+/);\n    if (projectMatch) {\n      projectId = projectMatch[0];\n    }\n  }\n\n  return dsnFromComponents({ host, pass, path, projectId, port, protocol: protocol as DsnProtocol, publicKey });\n}\n\nfunction dsnFromComponents(components: DsnComponents): DsnComponents {\n  // TODO this is for backwards compatibility, and can be removed in a future version\n  if ('user' in components && !('publicKey' in components)) {\n    components.publicKey = components.user;\n  }\n\n  return {\n    user: components.publicKey || '',\n    protocol: components.protocol,\n    publicKey: components.publicKey || '',\n    pass: components.pass || '',\n    host: components.host,\n    port: components.port || '',\n    path: components.path || '',\n    projectId: components.projectId,\n  };\n}\n\nfunction validateDsn(dsn: DsnComponents): boolean | void {\n  if (!IS_DEBUG_BUILD) {\n    return;\n  }\n\n  const { port, projectId, protocol } = dsn;\n\n  const requiredComponents: ReadonlyArray<keyof DsnComponents> = ['protocol', 'publicKey', 'host', 'projectId'];\n  requiredComponents.forEach(component => {\n    if (!dsn[component]) {\n      throw new SentryError(`Invalid Sentry Dsn: ${component} missing`);\n    }\n  });\n\n  if (!projectId.match(/^\\d+$/)) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);\n  }\n\n  if (!isValidProtocol(protocol)) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);\n  }\n\n  if (port && isNaN(parseInt(port, 10))) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid port ${port}`);\n  }\n\n  return true;\n}\n\n/** The Sentry Dsn, identifying a Sentry instance and project. */\nexport function makeDsn(from: DsnLike): DsnComponents {\n  const components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);\n\n  validateDsn(components);\n\n  return components;\n}\n"]}export declare const SeverityLevels: readonly ["fatal", "error", "warning", "log", "info", "debug", "critical"];
export declare type SeverityLevel = typeof SeverityLevels[number];
//# sourceMappingURL=enums.d.ts.map{"version":3,"file":"enums.d.ts","sourceRoot":"","sources":["../../src/enums.ts"],"names":[],"mappings":"AAAA,eAAO,MAAM,cAAc,4EAA6E,CAAC;AACzG,oBAAY,aAAa,GAAG,OAAO,cAAc,CAAC,MAAM,CAAC,CAAC"}export var SeverityLevels = ['fatal', 'error', 'warning', 'log', 'info', 'debug', 'critical'];
//# sourceMappingURL=enums.js.map{"version":3,"file":"enums.js","sourceRoot":"","sources":["../../src/enums.ts"],"names":[],"mappings":"AAAA,MAAM,CAAC,IAAM,cAAc,GAAG,CAAC,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,UAAU,CAAU,CAAC","sourcesContent":["export const SeverityLevels = ['fatal', 'error', 'warning', 'log', 'info', 'debug', 'critical'] as const;\nexport type SeverityLevel = typeof SeverityLevels[number];\n"]}/**
 * Figures out if we're building a browser bundle.
 *
 * @returns true if this is a browser bundle build.
 */
export declare function isBrowserBundle(): boolean;
//# sourceMappingURL=env.d.ts.map{"version":3,"file":"env.d.ts","sourceRoot":"","sources":["../../src/env.ts"],"names":[],"mappings":"AAiBA;;;;GAIG;AACH,wBAAgB,eAAe,IAAI,OAAO,CAEzC"}/*
 * This module exists for optimizations in the build process through rollup and terser.  We define some global
 * constants, which can be overridden during build. By guarding certain pieces of code with functions that return these
 * constants, we can control whether or not they appear in the final bundle. (Any code guarded by a false condition will
 * never run, and will hence be dropped during treeshaking.) The two primary uses for this are stripping out calls to
 * `logger` and preventing node-related code from appearing in browser bundles.
 *
 * Attention:
 * This file should not be used to define constants/flags that are intended to be used for tree-shaking conducted by
 * users. These fags should live in their respective packages, as we identified user tooling (specifically webpack)
 * having issues tree-shaking these constants across package boundaries.
 * An example for this is the __SENTRY_DEBUG__ constant. It is declared in each package individually because we want
 * users to be able to shake away expressions that it guards.
 */
/**
 * Figures out if we're building a browser bundle.
 *
 * @returns true if this is a browser bundle build.
 */
export function isBrowserBundle() {
    return typeof __SENTRY_BROWSER_BUNDLE__ !== 'undefined' && !!__SENTRY_BROWSER_BUNDLE__;
}
//# sourceMappingURL=env.js.map{"version":3,"file":"env.js","sourceRoot":"","sources":["../../src/env.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;GAaG;AAIH;;;;GAIG;AACH,MAAM,UAAU,eAAe;IAC7B,OAAO,OAAO,yBAAyB,KAAK,WAAW,IAAI,CAAC,CAAC,yBAAyB,CAAC;AACzF,CAAC","sourcesContent":["/*\n * This module exists for optimizations in the build process through rollup and terser.  We define some global\n * constants, which can be overridden during build. By guarding certain pieces of code with functions that return these\n * constants, we can control whether or not they appear in the final bundle. (Any code guarded by a false condition will\n * never run, and will hence be dropped during treeshaking.) The two primary uses for this are stripping out calls to\n * `logger` and preventing node-related code from appearing in browser bundles.\n *\n * Attention:\n * This file should not be used to define constants/flags that are intended to be used for tree-shaking conducted by\n * users. These fags should live in their respective packages, as we identified user tooling (specifically webpack)\n * having issues tree-shaking these constants across package boundaries.\n * An example for this is the __SENTRY_DEBUG__ constant. It is declared in each package individually because we want\n * users to be able to shake away expressions that it guards.\n */\n\ndeclare const __SENTRY_BROWSER_BUNDLE__: boolean | undefined;\n\n/**\n * Figures out if we're building a browser bundle.\n *\n * @returns true if this is a browser bundle build.\n */\nexport function isBrowserBundle(): boolean {\n  return typeof __SENTRY_BROWSER_BUNDLE__ !== 'undefined' && !!__SENTRY_BROWSER_BUNDLE__;\n}\n"]}import { Envelope } from '@sentry/types';
/**
 * Creates an envelope.
 * Make sure to always explicitly provide the generic to this function
 * so that the envelope types resolve correctly.
 */
export declare function createEnvelope<E extends Envelope>(headers: E[0], items?: E[1]): E;
/**
 * Add an item to an envelope.
 * Make sure to always explicitly provide the generic to this function
 * so that the envelope types resolve correctly.
 */
export declare function addItemToEnvelope<E extends Envelope>(envelope: E, newItem: E[1][number]): E;
/**
 * Get the type of the envelope. Grabs the type from the first envelope item.
 */
export declare function getEnvelopeType<E extends Envelope>(envelope: E): string;
/**
 * Serializes an envelope into a string.
 */
export declare function serializeEnvelope(envelope: Envelope): string;
//# sourceMappingURL=envelope.d.ts.map{"version":3,"file":"envelope.d.ts","sourceRoot":"","sources":["../../src/envelope.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,eAAe,CAAC;AAIzC;;;;GAIG;AACH,wBAAgB,cAAc,CAAC,CAAC,SAAS,QAAQ,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,GAAE,CAAC,CAAC,CAAC,CAAM,GAAG,CAAC,CAErF;AAED;;;;GAIG;AACH,wBAAgB,iBAAiB,CAAC,CAAC,SAAS,QAAQ,EAAE,QAAQ,EAAE,CAAC,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAG3F;AAED;;GAEG;AACH,wBAAgB,eAAe,CAAC,CAAC,SAAS,QAAQ,EAAE,QAAQ,EAAE,CAAC,GAAG,MAAM,CAGvE;AAED;;GAEG;AACH,wBAAgB,iBAAiB,CAAC,QAAQ,EAAE,QAAQ,GAAG,MAAM,CAe5D"}import { __read, __spread } from "tslib";
import { isPrimitive } from './is';
/**
 * Creates an envelope.
 * Make sure to always explicitly provide the generic to this function
 * so that the envelope types resolve correctly.
 */
export function createEnvelope(headers, items) {
    if (items === void 0) { items = []; }
    return [headers, items];
}
/**
 * Add an item to an envelope.
 * Make sure to always explicitly provide the generic to this function
 * so that the envelope types resolve correctly.
 */
export function addItemToEnvelope(envelope, newItem) {
    var _a = __read(envelope, 2), headers = _a[0], items = _a[1];
    return [headers, __spread(items, [newItem])];
}
/**
 * Get the type of the envelope. Grabs the type from the first envelope item.
 */
export function getEnvelopeType(envelope) {
    var _a = __read(envelope, 2), _b = __read(_a[1], 1), _c = __read(_b[0], 1), firstItemHeader = _c[0];
    return firstItemHeader.type;
}
/**
 * Serializes an envelope into a string.
 */
export function serializeEnvelope(envelope) {
    var _a = __read(envelope, 2), headers = _a[0], items = _a[1];
    var serializedHeaders = JSON.stringify(headers);
    // Have to cast items to any here since Envelope is a union type
    // Fixed in Typescript 4.2
    // TODO: Remove any[] cast when we upgrade to TS 4.2
    // https://github.com/microsoft/TypeScript/issues/36390
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return items.reduce(function (acc, item) {
        var _a = __read(item, 2), itemHeaders = _a[0], payload = _a[1];
        // We do not serialize payloads that are primitives
        var serializedPayload = isPrimitive(payload) ? String(payload) : JSON.stringify(payload);
        return acc + "\n" + JSON.stringify(itemHeaders) + "\n" + serializedPayload;
    }, serializedHeaders);
}
//# sourceMappingURL=envelope.js.map{"version":3,"file":"envelope.js","sourceRoot":"","sources":["../../src/envelope.ts"],"names":[],"mappings":";AAEA,OAAO,EAAE,WAAW,EAAE,MAAM,MAAM,CAAC;AAEnC;;;;GAIG;AACH,MAAM,UAAU,cAAc,CAAqB,OAAa,EAAE,KAAgB;IAAhB,sBAAA,EAAA,UAAgB;IAChF,OAAO,CAAC,OAAO,EAAE,KAAK,CAAM,CAAC;AAC/B,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,iBAAiB,CAAqB,QAAW,EAAE,OAAqB;IAChF,IAAA,wBAA2B,EAA1B,eAAO,EAAE,aAAiB,CAAC;IAClC,OAAO,CAAC,OAAO,WAAM,KAAK,GAAE,OAAO,GAAO,CAAC;AAC7C,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,eAAe,CAAqB,QAAW;IACvD,IAAA,wBAAkC,EAA/B,qBAAmB,EAAlB,qBAAiB,EAAhB,uBAA6B,CAAC;IACzC,OAAO,eAAe,CAAC,IAAI,CAAC;AAC9B,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,iBAAiB,CAAC,QAAkB;IAC5C,IAAA,wBAA2B,EAA1B,eAAO,EAAE,aAAiB,CAAC;IAClC,IAAM,iBAAiB,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;IAElD,gEAAgE;IAChE,0BAA0B;IAC1B,oDAAoD;IACpD,uDAAuD;IACvD,8DAA8D;IAC9D,OAAQ,KAAe,CAAC,MAAM,CAAC,UAAC,GAAG,EAAE,IAA0B;QACvD,IAAA,oBAA6B,EAA5B,mBAAW,EAAE,eAAe,CAAC;QACpC,mDAAmD;QACnD,IAAM,iBAAiB,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;QAC3F,OAAU,GAAG,UAAK,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,UAAK,iBAAmB,CAAC;IACxE,CAAC,EAAE,iBAAiB,CAAC,CAAC;AACxB,CAAC","sourcesContent":["import { Envelope } from '@sentry/types';\n\nimport { isPrimitive } from './is';\n\n/**\n * Creates an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nexport function createEnvelope<E extends Envelope>(headers: E[0], items: E[1] = []): E {\n  return [headers, items] as E;\n}\n\n/**\n * Add an item to an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nexport function addItemToEnvelope<E extends Envelope>(envelope: E, newItem: E[1][number]): E {\n  const [headers, items] = envelope;\n  return [headers, [...items, newItem]] as E;\n}\n\n/**\n * Get the type of the envelope. Grabs the type from the first envelope item.\n */\nexport function getEnvelopeType<E extends Envelope>(envelope: E): string {\n  const [, [[firstItemHeader]]] = envelope;\n  return firstItemHeader.type;\n}\n\n/**\n * Serializes an envelope into a string.\n */\nexport function serializeEnvelope(envelope: Envelope): string {\n  const [headers, items] = envelope;\n  const serializedHeaders = JSON.stringify(headers);\n\n  // Have to cast items to any here since Envelope is a union type\n  // Fixed in Typescript 4.2\n  // TODO: Remove any[] cast when we upgrade to TS 4.2\n  // https://github.com/microsoft/TypeScript/issues/36390\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return (items as any[]).reduce((acc, item: typeof items[number]) => {\n    const [itemHeaders, payload] = item;\n    // We do not serialize payloads that are primitives\n    const serializedPayload = isPrimitive(payload) ? String(payload) : JSON.stringify(payload);\n    return `${acc}\\n${JSON.stringify(itemHeaders)}\\n${serializedPayload}`;\n  }, serializedHeaders);\n}\n"]}/** An error emitted by Sentry SDKs and related utilities. */
export declare class SentryError extends Error {
    message: string;
    /** Display name of this error instance. */
    name: string;
    constructor(message: string);
}
//# sourceMappingURL=error.d.ts.map{"version":3,"file":"error.d.ts","sourceRoot":"","sources":["../../src/error.ts"],"names":[],"mappings":"AAEA,6DAA6D;AAC7D,qBAAa,WAAY,SAAQ,KAAK;IAIV,OAAO,EAAE,MAAM;IAHzC,2CAA2C;IACpC,IAAI,EAAE,MAAM,CAAC;gBAEM,OAAO,EAAE,MAAM;CAM1C"}import { __extends } from "tslib";
import { setPrototypeOf } from './polyfill';
/** An error emitted by Sentry SDKs and related utilities. */
var SentryError = /** @class */ (function (_super) {
    __extends(SentryError, _super);
    function SentryError(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = _newTarget.prototype.constructor.name;
        setPrototypeOf(_this, _newTarget.prototype);
        return _this;
    }
    return SentryError;
}(Error));
export { SentryError };
//# sourceMappingURL=error.js.map{"version":3,"file":"error.js","sourceRoot":"","sources":["../../src/error.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,YAAY,CAAC;AAE5C,6DAA6D;AAC7D;IAAiC,+BAAK;IAIpC,qBAA0B,OAAe;;QAAzC,YACE,kBAAM,OAAO,CAAC,SAIf;QALyB,aAAO,GAAP,OAAO,CAAQ;QAGvC,KAAI,CAAC,IAAI,GAAG,WAAW,SAAS,CAAC,WAAW,CAAC,IAAI,CAAC;QAClD,cAAc,CAAC,KAAI,EAAE,WAAW,SAAS,CAAC,CAAC;;IAC7C,CAAC;IACH,kBAAC;AAAD,CAAC,AAVD,CAAiC,KAAK,GAUrC","sourcesContent":["import { setPrototypeOf } from './polyfill';\n\n/** An error emitted by Sentry SDKs and related utilities. */\nexport class SentryError extends Error {\n  /** Display name of this error instance. */\n  public name: string;\n\n  public constructor(public message: string) {\n    super(message);\n\n    this.name = new.target.prototype.constructor.name;\n    setPrototypeOf(this, new.target.prototype);\n  }\n}\n"]}/** Flag that is true for debug builds, false otherwise. */
export declare const IS_DEBUG_BUILD: boolean;
//# sourceMappingURL=flags.d.ts.map{"version":3,"file":"flags.d.ts","sourceRoot":"","sources":["../../src/flags.ts"],"names":[],"mappings":"AAgBA,2DAA2D;AAC3D,eAAO,MAAM,cAAc,SAAoE,CAAC"}/*
 * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking
 * for users.
 *
 * Debug flags need to be declared in each package individually and must not be imported across package boundaries,
 * because some build tools have trouble tree-shaking imported guards.
 *
 * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.
 *
 * Debug flag files will contain "magic strings" like `__SENTRY_DEBUG__` that may get replaced with actual values during
 * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not
 * replaced.
 */
/** Flag that is true for debug builds, false otherwise. */
export var IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;
//# sourceMappingURL=flags.js.map{"version":3,"file":"flags.js","sourceRoot":"","sources":["../../src/flags.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;AAIH,2DAA2D;AAC3D,MAAM,CAAC,IAAM,cAAc,GAAG,OAAO,gBAAgB,KAAK,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,gBAAgB,CAAC","sourcesContent":["/*\n * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking\n * for users.\n *\n * Debug flags need to be declared in each package individually and must not be imported across package boundaries,\n * because some build tools have trouble tree-shaking imported guards.\n *\n * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.\n *\n * Debug flag files will contain \"magic strings\" like `__SENTRY_DEBUG__` that may get replaced with actual values during\n * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not\n * replaced.\n */\n\ndeclare const __SENTRY_DEBUG__: boolean;\n\n/** Flag that is true for debug builds, false otherwise. */\nexport const IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;\n"]}/**
 * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
 * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
 */
import { Integration } from '@sentry/types';
/** Internal */
interface SentryGlobal {
    Sentry?: {
        Integrations?: Integration[];
    };
    SENTRY_ENVIRONMENT?: string;
    SENTRY_DSN?: string;
    SENTRY_RELEASE?: {
        id?: string;
    };
    __SENTRY__: {
        globalEventProcessors: any;
        hub: any;
        logger: any;
    };
}
/**
 * Safely get global scope object
 *
 * @returns Global scope object
 */
export declare function getGlobalObject<T>(): T & SentryGlobal;
/**
 * Returns a global singleton contained in the global `__SENTRY__` object.
 *
 * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory
 * function and added to the `__SENTRY__` object.
 *
 * @param name name of the global singleton on __SENTRY__
 * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`
 * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `getGlobalObject`'s return value
 * @returns the singleton
 */
export declare function getGlobalSingleton<T>(name: keyof SentryGlobal['__SENTRY__'], creator: () => T, obj?: unknown): T;
export {};
//# sourceMappingURL=global.d.ts.map{"version":3,"file":"global.d.ts","sourceRoot":"","sources":["../../src/global.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAIH,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAI5C,eAAe;AACf,UAAU,YAAY;IACpB,MAAM,CAAC,EAAE;QACP,YAAY,CAAC,EAAE,WAAW,EAAE,CAAC;KAC9B,CAAC;IACF,kBAAkB,CAAC,EAAE,MAAM,CAAC;IAC5B,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,cAAc,CAAC,EAAE;QACf,EAAE,CAAC,EAAE,MAAM,CAAC;KACb,CAAC;IACF,UAAU,EAAE;QACV,qBAAqB,EAAE,GAAG,CAAC;QAC3B,GAAG,EAAE,GAAG,CAAC;QACT,MAAM,EAAE,GAAG,CAAC;KACb,CAAC;CACH;AAID;;;;GAIG;AACH,wBAAgB,eAAe,CAAC,CAAC,KAAK,CAAC,GAAG,YAAY,CAUrD;AAED;;;;;;;;;;GAUG;AACH,wBAAgB,kBAAkB,CAAC,CAAC,EAAE,IAAI,EAAE,MAAM,YAAY,CAAC,YAAY,CAAC,EAAE,OAAO,EAAE,MAAM,CAAC,EAAE,GAAG,CAAC,EAAE,OAAO,GAAG,CAAC,CAKhH"}/**
 * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
 * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
 */
import { isNodeEnv } from './node';
var fallbackGlobalObject = {};
/**
 * Safely get global scope object
 *
 * @returns Global scope object
 */
export function getGlobalObject() {
    return (isNodeEnv()
        ? global
        : typeof window !== 'undefined' // eslint-disable-line no-restricted-globals
            ? window // eslint-disable-line no-restricted-globals
            : typeof self !== 'undefined'
                ? self
                : fallbackGlobalObject);
}
/**
 * Returns a global singleton contained in the global `__SENTRY__` object.
 *
 * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory
 * function and added to the `__SENTRY__` object.
 *
 * @param name name of the global singleton on __SENTRY__
 * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`
 * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `getGlobalObject`'s return value
 * @returns the singleton
 */
export function getGlobalSingleton(name, creator, obj) {
    var global = (obj || getGlobalObject());
    var __SENTRY__ = (global.__SENTRY__ = global.__SENTRY__ || {});
    var singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());
    return singleton;
}
//# sourceMappingURL=global.js.map{"version":3,"file":"global.js","sourceRoot":"","sources":["../../src/global.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAMH,OAAO,EAAE,SAAS,EAAE,MAAM,QAAQ,CAAC;AAmBnC,IAAM,oBAAoB,GAAG,EAAE,CAAC;AAEhC;;;;GAIG;AACH,MAAM,UAAU,eAAe;IAC7B,OAAO,CACL,SAAS,EAAE;QACT,CAAC,CAAC,MAAM;QACR,CAAC,CAAC,OAAO,MAAM,KAAK,WAAW,CAAC,4CAA4C;YAC5E,CAAC,CAAC,MAAM,CAAC,4CAA4C;YACrD,CAAC,CAAC,OAAO,IAAI,KAAK,WAAW;gBAC7B,CAAC,CAAC,IAAI;gBACN,CAAC,CAAC,oBAAoB,CACL,CAAC;AACxB,CAAC;AAED;;;;;;;;;;GAUG;AACH,MAAM,UAAU,kBAAkB,CAAI,IAAsC,EAAE,OAAgB,EAAE,GAAa;IAC3G,IAAM,MAAM,GAAG,CAAC,GAAG,IAAI,eAAe,EAAE,CAAiB,CAAC;IAC1D,IAAM,UAAU,GAAG,CAAC,MAAM,CAAC,UAAU,GAAG,MAAM,CAAC,UAAU,IAAI,EAAE,CAAC,CAAC;IACjE,IAAM,SAAS,GAAG,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,OAAO,EAAE,CAAC,CAAC;IACrE,OAAO,SAAS,CAAC;AACnB,CAAC","sourcesContent":["/**\n * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,\n * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { Integration } from '@sentry/types';\n\nimport { isNodeEnv } from './node';\n\n/** Internal */\ninterface SentryGlobal {\n  Sentry?: {\n    Integrations?: Integration[];\n  };\n  SENTRY_ENVIRONMENT?: string;\n  SENTRY_DSN?: string;\n  SENTRY_RELEASE?: {\n    id?: string;\n  };\n  __SENTRY__: {\n    globalEventProcessors: any;\n    hub: any;\n    logger: any;\n  };\n}\n\nconst fallbackGlobalObject = {};\n\n/**\n * Safely get global scope object\n *\n * @returns Global scope object\n */\nexport function getGlobalObject<T>(): T & SentryGlobal {\n  return (\n    isNodeEnv()\n      ? global\n      : typeof window !== 'undefined' // eslint-disable-line no-restricted-globals\n      ? window // eslint-disable-line no-restricted-globals\n      : typeof self !== 'undefined'\n      ? self\n      : fallbackGlobalObject\n  ) as T & SentryGlobal;\n}\n\n/**\n * Returns a global singleton contained in the global `__SENTRY__` object.\n *\n * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory\n * function and added to the `__SENTRY__` object.\n *\n * @param name name of the global singleton on __SENTRY__\n * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`\n * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `getGlobalObject`'s return value\n * @returns the singleton\n */\nexport function getGlobalSingleton<T>(name: keyof SentryGlobal['__SENTRY__'], creator: () => T, obj?: unknown): T {\n  const global = (obj || getGlobalObject()) as SentryGlobal;\n  const __SENTRY__ = (global.__SENTRY__ = global.__SENTRY__ || {});\n  const singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());\n  return singleton;\n}\n"]}export * from './async';
export * from './browser';
export * from './dsn';
export * from './enums';
export * from './error';
export * from './global';
export * from './instrument';
export * from './is';
export * from './logger';
export * from './memo';
export * from './misc';
export * from './node';
export * from './normalize';
export * from './object';
export * from './path';
export * from './promisebuffer';
export * from './severity';
export * from './stacktrace';
export * from './status';
export * from './string';
export * from './supports';
export * from './syncpromise';
export * from './time';
export * from './tracing';
export * from './env';
export * from './envelope';
export * from './clientreport';
export * from './ratelimit';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,cAAc,SAAS,CAAC;AACxB,cAAc,WAAW,CAAC;AAC1B,cAAc,OAAO,CAAC;AACtB,cAAc,SAAS,CAAC;AACxB,cAAc,SAAS,CAAC;AACxB,cAAc,UAAU,CAAC;AACzB,cAAc,cAAc,CAAC;AAC7B,cAAc,MAAM,CAAC;AACrB,cAAc,UAAU,CAAC;AACzB,cAAc,QAAQ,CAAC;AACvB,cAAc,QAAQ,CAAC;AACvB,cAAc,QAAQ,CAAC;AACvB,cAAc,aAAa,CAAC;AAC5B,cAAc,UAAU,CAAC;AACzB,cAAc,QAAQ,CAAC;AACvB,cAAc,iBAAiB,CAAC;AAChC,cAAc,YAAY,CAAC;AAC3B,cAAc,cAAc,CAAC;AAC7B,cAAc,UAAU,CAAC;AACzB,cAAc,UAAU,CAAC;AACzB,cAAc,YAAY,CAAC;AAC3B,cAAc,eAAe,CAAC;AAC9B,cAAc,QAAQ,CAAC;AACvB,cAAc,WAAW,CAAC;AAC1B,cAAc,OAAO,CAAC;AACtB,cAAc,YAAY,CAAC;AAC3B,cAAc,gBAAgB,CAAC;AAC/B,cAAc,aAAa,CAAC"}export * from './async';
export * from './browser';
export * from './dsn';
export * from './enums';
export * from './error';
export * from './global';
export * from './instrument';
export * from './is';
export * from './logger';
export * from './memo';
export * from './misc';
export * from './node';
export * from './normalize';
export * from './object';
export * from './path';
export * from './promisebuffer';
export * from './severity';
export * from './stacktrace';
export * from './status';
export * from './string';
export * from './supports';
export * from './syncpromise';
export * from './time';
export * from './tracing';
export * from './env';
export * from './envelope';
export * from './clientreport';
export * from './ratelimit';
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,cAAc,SAAS,CAAC;AACxB,cAAc,WAAW,CAAC;AAC1B,cAAc,OAAO,CAAC;AACtB,cAAc,SAAS,CAAC;AACxB,cAAc,SAAS,CAAC;AACxB,cAAc,UAAU,CAAC;AACzB,cAAc,cAAc,CAAC;AAC7B,cAAc,MAAM,CAAC;AACrB,cAAc,UAAU,CAAC;AACzB,cAAc,QAAQ,CAAC;AACvB,cAAc,QAAQ,CAAC;AACvB,cAAc,QAAQ,CAAC;AACvB,cAAc,aAAa,CAAC;AAC5B,cAAc,UAAU,CAAC;AACzB,cAAc,QAAQ,CAAC;AACvB,cAAc,iBAAiB,CAAC;AAChC,cAAc,YAAY,CAAC;AAC3B,cAAc,cAAc,CAAC;AAC7B,cAAc,UAAU,CAAC;AACzB,cAAc,UAAU,CAAC;AACzB,cAAc,YAAY,CAAC;AAC3B,cAAc,eAAe,CAAC;AAC9B,cAAc,QAAQ,CAAC;AACvB,cAAc,WAAW,CAAC;AAC1B,cAAc,OAAO,CAAC;AACtB,cAAc,YAAY,CAAC;AAC3B,cAAc,gBAAgB,CAAC;AAC/B,cAAc,aAAa,CAAC","sourcesContent":["export * from './async';\nexport * from './browser';\nexport * from './dsn';\nexport * from './enums';\nexport * from './error';\nexport * from './global';\nexport * from './instrument';\nexport * from './is';\nexport * from './logger';\nexport * from './memo';\nexport * from './misc';\nexport * from './node';\nexport * from './normalize';\nexport * from './object';\nexport * from './path';\nexport * from './promisebuffer';\nexport * from './severity';\nexport * from './stacktrace';\nexport * from './status';\nexport * from './string';\nexport * from './supports';\nexport * from './syncpromise';\nexport * from './time';\nexport * from './tracing';\nexport * from './env';\nexport * from './envelope';\nexport * from './clientreport';\nexport * from './ratelimit';\n"]}declare type InstrumentHandlerType = 'console' | 'dom' | 'fetch' | 'history' | 'sentry' | 'xhr' | 'error' | 'unhandledrejection';
declare type InstrumentHandlerCallback = (data: any) => void;
/**
 * Add handler that will be called when given type of instrumentation triggers.
 * Use at your own risk, this might break without changelog notice, only used internally.
 * @hidden
 */
export declare function addInstrumentationHandler(type: InstrumentHandlerType, callback: InstrumentHandlerCallback): void;
export {};
//# sourceMappingURL=instrument.d.ts.map{"version":3,"file":"instrument.d.ts","sourceRoot":"","sources":["../../src/instrument.ts"],"names":[],"mappings":"AAeA,aAAK,qBAAqB,GACtB,SAAS,GACT,KAAK,GACL,OAAO,GACP,SAAS,GACT,QAAQ,GACR,KAAK,GACL,OAAO,GACP,oBAAoB,CAAC;AACzB,aAAK,yBAAyB,GAAG,CAAC,IAAI,EAAE,GAAG,KAAK,IAAI,CAAC;AAoDrD;;;;GAIG;AACH,wBAAgB,yBAAyB,CAAC,IAAI,EAAE,qBAAqB,EAAE,QAAQ,EAAE,yBAAyB,GAAG,IAAI,CAIhH"}import { __assign, __values } from "tslib";
import { IS_DEBUG_BUILD } from './flags';
import { getGlobalObject } from './global';
import { isInstanceOf, isString } from './is';
import { CONSOLE_LEVELS, logger } from './logger';
import { fill } from './object';
import { getFunctionName } from './stacktrace';
import { supportsHistory, supportsNativeFetch } from './supports';
var global = getGlobalObject();
/**
 * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.
 *  - Console API
 *  - Fetch API
 *  - XHR API
 *  - History API
 *  - DOM API (click/typing)
 *  - Error API
 *  - UnhandledRejection API
 */
var handlers = {};
var instrumented = {};
/** Instruments given API */
function instrument(type) {
    if (instrumented[type]) {
        return;
    }
    instrumented[type] = true;
    switch (type) {
        case 'console':
            instrumentConsole();
            break;
        case 'dom':
            instrumentDOM();
            break;
        case 'xhr':
            instrumentXHR();
            break;
        case 'fetch':
            instrumentFetch();
            break;
        case 'history':
            instrumentHistory();
            break;
        case 'error':
            instrumentError();
            break;
        case 'unhandledrejection':
            instrumentUnhandledRejection();
            break;
        default:
            IS_DEBUG_BUILD && logger.warn('unknown instrumentation type:', type);
            return;
    }
}
/**
 * Add handler that will be called when given type of instrumentation triggers.
 * Use at your own risk, this might break without changelog notice, only used internally.
 * @hidden
 */
export function addInstrumentationHandler(type, callback) {
    handlers[type] = handlers[type] || [];
    handlers[type].push(callback);
    instrument(type);
}
/** JSDoc */
function triggerHandlers(type, data) {
    var e_1, _a;
    if (!type || !handlers[type]) {
        return;
    }
    try {
        for (var _b = __values(handlers[type] || []), _c = _b.next(); !_c.done; _c = _b.next()) {
            var handler = _c.value;
            try {
                handler(data);
            }
            catch (e) {
                IS_DEBUG_BUILD &&
                    logger.error("Error while triggering instrumentation handler.\nType: " + type + "\nName: " + getFunctionName(handler) + "\nError:", e);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
/** JSDoc */
function instrumentConsole() {
    if (!('console' in global)) {
        return;
    }
    CONSOLE_LEVELS.forEach(function (level) {
        if (!(level in global.console)) {
            return;
        }
        fill(global.console, level, function (originalConsoleMethod) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                triggerHandlers('console', { args: args, level: level });
                // this fails for some browsers. :(
                if (originalConsoleMethod) {
                    originalConsoleMethod.apply(global.console, args);
                }
            };
        });
    });
}
/** JSDoc */
function instrumentFetch() {
    if (!supportsNativeFetch()) {
        return;
    }
    fill(global, 'fetch', function (originalFetch) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var handlerData = {
                args: args,
                fetchData: {
                    method: getFetchMethod(args),
                    url: getFetchUrl(args),
                },
                startTimestamp: Date.now(),
            };
            triggerHandlers('fetch', __assign({}, handlerData));
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            return originalFetch.apply(global, args).then(function (response) {
                triggerHandlers('fetch', __assign(__assign({}, handlerData), { endTimestamp: Date.now(), response: response }));
                return response;
            }, function (error) {
                triggerHandlers('fetch', __assign(__assign({}, handlerData), { endTimestamp: Date.now(), error: error }));
                // NOTE: If you are a Sentry user, and you are seeing this stack frame,
                //       it means the sentry.javascript SDK caught an error invoking your application code.
                //       This is expected behavior and NOT indicative of a bug with sentry.javascript.
                throw error;
            });
        };
    });
}
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/** Extract `method` from fetch call arguments */
function getFetchMethod(fetchArgs) {
    if (fetchArgs === void 0) { fetchArgs = []; }
    if ('Request' in global && isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {
        return String(fetchArgs[0].method).toUpperCase();
    }
    if (fetchArgs[1] && fetchArgs[1].method) {
        return String(fetchArgs[1].method).toUpperCase();
    }
    return 'GET';
}
/** Extract `url` from fetch call arguments */
function getFetchUrl(fetchArgs) {
    if (fetchArgs === void 0) { fetchArgs = []; }
    if (typeof fetchArgs[0] === 'string') {
        return fetchArgs[0];
    }
    if ('Request' in global && isInstanceOf(fetchArgs[0], Request)) {
        return fetchArgs[0].url;
    }
    return String(fetchArgs[0]);
}
/* eslint-enable @typescript-eslint/no-unsafe-member-access */
/** JSDoc */
function instrumentXHR() {
    if (!('XMLHttpRequest' in global)) {
        return;
    }
    var xhrproto = XMLHttpRequest.prototype;
    fill(xhrproto, 'open', function (originalOpen) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            var xhr = this;
            var url = args[1];
            var xhrInfo = (xhr.__sentry_xhr__ = {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                method: isString(args[0]) ? args[0].toUpperCase() : args[0],
                url: args[1],
            });
            // if Sentry key appears in URL, don't capture it as a request
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            if (isString(url) && xhrInfo.method === 'POST' && url.match(/sentry_key/)) {
                xhr.__sentry_own_request__ = true;
            }
            var onreadystatechangeHandler = function () {
                if (xhr.readyState === 4) {
                    try {
                        // touching statusCode in some platforms throws
                        // an exception
                        xhrInfo.status_code = xhr.status;
                    }
                    catch (e) {
                        /* do nothing */
                    }
                    triggerHandlers('xhr', {
                        args: args,
                        endTimestamp: Date.now(),
                        startTimestamp: Date.now(),
                        xhr: xhr,
                    });
                }
            };
            if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {
                fill(xhr, 'onreadystatechange', function (original) {
                    return function () {
                        var readyStateArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            readyStateArgs[_i] = arguments[_i];
                        }
                        onreadystatechangeHandler();
                        return original.apply(xhr, readyStateArgs);
                    };
                });
            }
            else {
                xhr.addEventListener('readystatechange', onreadystatechangeHandler);
            }
            return originalOpen.apply(xhr, args);
        };
    });
    fill(xhrproto, 'send', function (originalSend) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (this.__sentry_xhr__ && args[0] !== undefined) {
                this.__sentry_xhr__.body = args[0];
            }
            triggerHandlers('xhr', {
                args: args,
                startTimestamp: Date.now(),
                xhr: this,
            });
            return originalSend.apply(this, args);
        };
    });
}
var lastHref;
/** JSDoc */
function instrumentHistory() {
    if (!supportsHistory()) {
        return;
    }
    var oldOnPopState = global.onpopstate;
    global.onpopstate = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var to = global.location.href;
        // keep track of the current URL state, as we always receive only the updated state
        var from = lastHref;
        lastHref = to;
        triggerHandlers('history', {
            from: from,
            to: to,
        });
        if (oldOnPopState) {
            // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.
            // https://github.com/getsentry/sentry-javascript/issues/3344
            // https://github.com/bugsnag/bugsnag-js/issues/469
            try {
                return oldOnPopState.apply(this, args);
            }
            catch (_oO) {
                // no-empty
            }
        }
    };
    /** @hidden */
    function historyReplacementFunction(originalHistoryFunction) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var url = args.length > 2 ? args[2] : undefined;
            if (url) {
                // coerce to string (this is what pushState does)
                var from = lastHref;
                var to = String(url);
                // keep track of the current URL state, as we always receive only the updated state
                lastHref = to;
                triggerHandlers('history', {
                    from: from,
                    to: to,
                });
            }
            return originalHistoryFunction.apply(this, args);
        };
    }
    fill(global.history, 'pushState', historyReplacementFunction);
    fill(global.history, 'replaceState', historyReplacementFunction);
}
var debounceDuration = 1000;
var debounceTimerID;
var lastCapturedEvent;
/**
 * Decide whether the current event should finish the debounce of previously captured one.
 * @param previous previously captured event
 * @param current event to be captured
 */
function shouldShortcircuitPreviousDebounce(previous, current) {
    // If there was no previous event, it should always be swapped for the new one.
    if (!previous) {
        return true;
    }
    // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.
    if (previous.type !== current.type) {
        return true;
    }
    try {
        // If both events have the same type, it's still possible that actions were performed on different targets.
        // e.g. 2 clicks on different buttons.
        if (previous.target !== current.target) {
            return true;
        }
    }
    catch (e) {
        // just accessing `target` property can throw an exception in some rare circumstances
        // see: https://github.com/getsentry/sentry-javascript/issues/838
    }
    // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_
    // to which an event listener was attached), we treat them as the same action, as we want to capture
    // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.
    return false;
}
/**
 * Decide whether an event should be captured.
 * @param event event to be captured
 */
function shouldSkipDOMEvent(event) {
    // We are only interested in filtering `keypress` events for now.
    if (event.type !== 'keypress') {
        return false;
    }
    try {
        var target = event.target;
        if (!target || !target.tagName) {
            return true;
        }
        // Only consider keypress events on actual input elements. This will disregard keypresses targeting body
        // e.g.tabbing through elements, hotkeys, etc.
        if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
            return false;
        }
    }
    catch (e) {
        // just accessing `target` property can throw an exception in some rare circumstances
        // see: https://github.com/getsentry/sentry-javascript/issues/838
    }
    return true;
}
/**
 * Wraps addEventListener to capture UI breadcrumbs
 * @param handler function that will be triggered
 * @param globalListener indicates whether event was captured by the global event listener
 * @returns wrapped breadcrumb events handler
 * @hidden
 */
function makeDOMEventHandler(handler, globalListener) {
    if (globalListener === void 0) { globalListener = false; }
    return function (event) {
        // It's possible this handler might trigger multiple times for the same
        // event (e.g. event propagation through node ancestors).
        // Ignore if we've already captured that event.
        if (!event || lastCapturedEvent === event) {
            return;
        }
        // We always want to skip _some_ events.
        if (shouldSkipDOMEvent(event)) {
            return;
        }
        var name = event.type === 'keypress' ? 'input' : event.type;
        // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.
        if (debounceTimerID === undefined) {
            handler({
                event: event,
                name: name,
                global: globalListener,
            });
            lastCapturedEvent = event;
        }
        // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.
        // If that's the case, emit the previous event and store locally the newly-captured DOM event.
        else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {
            handler({
                event: event,
                name: name,
                global: globalListener,
            });
            lastCapturedEvent = event;
        }
        // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.
        clearTimeout(debounceTimerID);
        debounceTimerID = global.setTimeout(function () {
            debounceTimerID = undefined;
        }, debounceDuration);
    };
}
/** JSDoc */
function instrumentDOM() {
    if (!('document' in global)) {
        return;
    }
    // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom
    // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before
    // we instrument `addEventListener` so that we don't end up attaching this handler twice.
    var triggerDOMHandler = triggerHandlers.bind(null, 'dom');
    var globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
    global.document.addEventListener('click', globalDOMEventHandler, false);
    global.document.addEventListener('keypress', globalDOMEventHandler, false);
    // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled
    // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That
    // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler
    // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still
    // guaranteed to fire at least once.)
    ['EventTarget', 'Node'].forEach(function (target) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        var proto = global[target] && global[target].prototype;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins
        if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {
            return;
        }
        fill(proto, 'addEventListener', function (originalAddEventListener) {
            return function (type, listener, options) {
                if (type === 'click' || type == 'keypress') {
                    try {
                        var el = this;
                        var handlers_1 = (el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {});
                        var handlerForType = (handlers_1[type] = handlers_1[type] || { refCount: 0 });
                        if (!handlerForType.handler) {
                            var handler = makeDOMEventHandler(triggerDOMHandler);
                            handlerForType.handler = handler;
                            originalAddEventListener.call(this, type, handler, options);
                        }
                        handlerForType.refCount += 1;
                    }
                    catch (e) {
                        // Accessing dom properties is always fragile.
                        // Also allows us to skip `addEventListenrs` calls with no proper `this` context.
                    }
                }
                return originalAddEventListener.call(this, type, listener, options);
            };
        });
        fill(proto, 'removeEventListener', function (originalRemoveEventListener) {
            return function (type, listener, options) {
                if (type === 'click' || type == 'keypress') {
                    try {
                        var el = this;
                        var handlers_2 = el.__sentry_instrumentation_handlers__ || {};
                        var handlerForType = handlers_2[type];
                        if (handlerForType) {
                            handlerForType.refCount -= 1;
                            // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.
                            if (handlerForType.refCount <= 0) {
                                originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                                handlerForType.handler = undefined;
                                delete handlers_2[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete
                            }
                            // If there are no longer any custom handlers of any type on this element, cleanup everything.
                            if (Object.keys(handlers_2).length === 0) {
                                delete el.__sentry_instrumentation_handlers__;
                            }
                        }
                    }
                    catch (e) {
                        // Accessing dom properties is always fragile.
                        // Also allows us to skip `addEventListenrs` calls with no proper `this` context.
                    }
                }
                return originalRemoveEventListener.call(this, type, listener, options);
            };
        });
    });
}
var _oldOnErrorHandler = null;
/** JSDoc */
function instrumentError() {
    _oldOnErrorHandler = global.onerror;
    global.onerror = function (msg, url, line, column, error) {
        triggerHandlers('error', {
            column: column,
            error: error,
            line: line,
            msg: msg,
            url: url,
        });
        if (_oldOnErrorHandler) {
            // eslint-disable-next-line prefer-rest-params
            return _oldOnErrorHandler.apply(this, arguments);
        }
        return false;
    };
}
var _oldOnUnhandledRejectionHandler = null;
/** JSDoc */
function instrumentUnhandledRejection() {
    _oldOnUnhandledRejectionHandler = global.onunhandledrejection;
    global.onunhandledrejection = function (e) {
        triggerHandlers('unhandledrejection', e);
        if (_oldOnUnhandledRejectionHandler) {
            // eslint-disable-next-line prefer-rest-params
            return _oldOnUnhandledRejectionHandler.apply(this, arguments);
        }
        return true;
    };
}
//# sourceMappingURL=instrument.js.map{"version":3,"file":"instrument.js","sourceRoot":"","sources":["../../src/instrument.ts"],"names":[],"mappings":";AAKA,OAAO,EAAE,cAAc,EAAE,MAAM,SAAS,CAAC;AACzC,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAC3C,OAAO,EAAE,YAAY,EAAE,QAAQ,EAAE,MAAM,MAAM,CAAC;AAC9C,OAAO,EAAE,cAAc,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;AAClD,OAAO,EAAE,IAAI,EAAE,MAAM,UAAU,CAAC;AAChC,OAAO,EAAE,eAAe,EAAE,MAAM,cAAc,CAAC;AAC/C,OAAO,EAAE,eAAe,EAAE,mBAAmB,EAAE,MAAM,YAAY,CAAC;AAElE,IAAM,MAAM,GAAG,eAAe,EAAU,CAAC;AAazC;;;;;;;;;GASG;AAEH,IAAM,QAAQ,GAAqE,EAAE,CAAC;AACtF,IAAM,YAAY,GAAiD,EAAE,CAAC;AAEtE,4BAA4B;AAC5B,SAAS,UAAU,CAAC,IAA2B;IAC7C,IAAI,YAAY,CAAC,IAAI,CAAC,EAAE;QACtB,OAAO;KACR;IAED,YAAY,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;IAE1B,QAAQ,IAAI,EAAE;QACZ,KAAK,SAAS;YACZ,iBAAiB,EAAE,CAAC;YACpB,MAAM;QACR,KAAK,KAAK;YACR,aAAa,EAAE,CAAC;YAChB,MAAM;QACR,KAAK,KAAK;YACR,aAAa,EAAE,CAAC;YAChB,MAAM;QACR,KAAK,OAAO;YACV,eAAe,EAAE,CAAC;YAClB,MAAM;QACR,KAAK,SAAS;YACZ,iBAAiB,EAAE,CAAC;YACpB,MAAM;QACR,KAAK,OAAO;YACV,eAAe,EAAE,CAAC;YAClB,MAAM;QACR,KAAK,oBAAoB;YACvB,4BAA4B,EAAE,CAAC;YAC/B,MAAM;QACR;YACE,cAAc,IAAI,MAAM,CAAC,IAAI,CAAC,+BAA+B,EAAE,IAAI,CAAC,CAAC;YACrE,OAAO;KACV;AACH,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,yBAAyB,CAAC,IAA2B,EAAE,QAAmC;IACxG,QAAQ,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;IACrC,QAAQ,CAAC,IAAI,CAAiC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC/D,UAAU,CAAC,IAAI,CAAC,CAAC;AACnB,CAAC;AAED,YAAY;AACZ,SAAS,eAAe,CAAC,IAA2B,EAAE,IAAS;;IAC7D,IAAI,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;QAC5B,OAAO;KACR;;QAED,KAAsB,IAAA,KAAA,SAAA,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,CAAA,gBAAA,4BAAE;YAAvC,IAAM,OAAO,WAAA;YAChB,IAAI;gBACF,OAAO,CAAC,IAAI,CAAC,CAAC;aACf;YAAC,OAAO,CAAC,EAAE;gBACV,cAAc;oBACZ,MAAM,CAAC,KAAK,CACV,4DAA0D,IAAI,gBAAW,eAAe,CAAC,OAAO,CAAC,aAAU,EAC3G,CAAC,CACF,CAAC;aACL;SACF;;;;;;;;;AACH,CAAC;AAED,YAAY;AACZ,SAAS,iBAAiB;IACxB,IAAI,CAAC,CAAC,SAAS,IAAI,MAAM,CAAC,EAAE;QAC1B,OAAO;KACR;IAED,cAAc,CAAC,OAAO,CAAC,UAAU,KAAa;QAC5C,IAAI,CAAC,CAAC,KAAK,IAAI,MAAM,CAAC,OAAO,CAAC,EAAE;YAC9B,OAAO;SACR;QAED,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,KAAK,EAAE,UAAU,qBAAgC;YACpE,OAAO;gBAAU,cAAc;qBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;oBAAd,yBAAc;;gBAC7B,eAAe,CAAC,SAAS,EAAE,EAAE,IAAI,MAAA,EAAE,KAAK,OAAA,EAAE,CAAC,CAAC;gBAE5C,mCAAmC;gBACnC,IAAI,qBAAqB,EAAE;oBACzB,qBAAqB,CAAC,KAAK,CAAC,MAAM,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;iBACnD;YACH,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC;AAED,YAAY;AACZ,SAAS,eAAe;IACtB,IAAI,CAAC,mBAAmB,EAAE,EAAE;QAC1B,OAAO;KACR;IAED,IAAI,CAAC,MAAM,EAAE,OAAO,EAAE,UAAU,aAAyB;QACvD,OAAO;YAAU,cAAc;iBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;gBAAd,yBAAc;;YAC7B,IAAM,WAAW,GAAG;gBAClB,IAAI,MAAA;gBACJ,SAAS,EAAE;oBACT,MAAM,EAAE,cAAc,CAAC,IAAI,CAAC;oBAC5B,GAAG,EAAE,WAAW,CAAC,IAAI,CAAC;iBACvB;gBACD,cAAc,EAAE,IAAI,CAAC,GAAG,EAAE;aAC3B,CAAC;YAEF,eAAe,CAAC,OAAO,eAClB,WAAW,EACd,CAAC;YAEH,sEAAsE;YACtE,OAAO,aAAa,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,IAAI,CAC3C,UAAC,QAAkB;gBACjB,eAAe,CAAC,OAAO,wBAClB,WAAW,KACd,YAAY,EAAE,IAAI,CAAC,GAAG,EAAE,EACxB,QAAQ,UAAA,IACR,CAAC;gBACH,OAAO,QAAQ,CAAC;YAClB,CAAC,EACD,UAAC,KAAY;gBACX,eAAe,CAAC,OAAO,wBAClB,WAAW,KACd,YAAY,EAAE,IAAI,CAAC,GAAG,EAAE,EACxB,KAAK,OAAA,IACL,CAAC;gBACH,uEAAuE;gBACvE,2FAA2F;gBAC3F,sFAAsF;gBACtF,MAAM,KAAK,CAAC;YACd,CAAC,CACF,CAAC;QACJ,CAAC,CAAC;IACJ,CAAC,CAAC,CAAC;AACL,CAAC;AAeD,+DAA+D;AAC/D,iDAAiD;AACjD,SAAS,cAAc,CAAC,SAAqB;IAArB,0BAAA,EAAA,cAAqB;IAC3C,IAAI,SAAS,IAAI,MAAM,IAAI,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE;QACrF,OAAO,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,WAAW,EAAE,CAAC;KAClD;IACD,IAAI,SAAS,CAAC,CAAC,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE;QACvC,OAAO,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,WAAW,EAAE,CAAC;KAClD;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAED,8CAA8C;AAC9C,SAAS,WAAW,CAAC,SAAqB;IAArB,0BAAA,EAAA,cAAqB;IACxC,IAAI,OAAO,SAAS,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;QACpC,OAAO,SAAS,CAAC,CAAC,CAAC,CAAC;KACrB;IACD,IAAI,SAAS,IAAI,MAAM,IAAI,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,EAAE;QAC9D,OAAO,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;KACzB;IACD,OAAO,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC;AACD,8DAA8D;AAE9D,YAAY;AACZ,SAAS,aAAa;IACpB,IAAI,CAAC,CAAC,gBAAgB,IAAI,MAAM,CAAC,EAAE;QACjC,OAAO;KACR;IAED,IAAM,QAAQ,GAAG,cAAc,CAAC,SAAS,CAAC;IAE1C,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAE,UAAU,YAAwB;QACvD,OAAO;YAA6C,cAAc;iBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;gBAAd,yBAAc;;YAChE,4DAA4D;YAC5D,IAAM,GAAG,GAAG,IAAI,CAAC;YACjB,IAAM,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;YACpB,IAAM,OAAO,GAAkD,CAAC,GAAG,CAAC,cAAc,GAAG;gBACnF,sEAAsE;gBACtE,MAAM,EAAE,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;gBAC3D,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC;aACb,CAAC,CAAC;YAEH,8DAA8D;YAC9D,sEAAsE;YACtE,IAAI,QAAQ,CAAC,GAAG,CAAC,IAAI,OAAO,CAAC,MAAM,KAAK,MAAM,IAAI,GAAG,CAAC,KAAK,CAAC,YAAY,CAAC,EAAE;gBACzE,GAAG,CAAC,sBAAsB,GAAG,IAAI,CAAC;aACnC;YAED,IAAM,yBAAyB,GAAG;gBAChC,IAAI,GAAG,CAAC,UAAU,KAAK,CAAC,EAAE;oBACxB,IAAI;wBACF,+CAA+C;wBAC/C,eAAe;wBACf,OAAO,CAAC,WAAW,GAAG,GAAG,CAAC,MAAM,CAAC;qBAClC;oBAAC,OAAO,CAAC,EAAE;wBACV,gBAAgB;qBACjB;oBAED,eAAe,CAAC,KAAK,EAAE;wBACrB,IAAI,MAAA;wBACJ,YAAY,EAAE,IAAI,CAAC,GAAG,EAAE;wBACxB,cAAc,EAAE,IAAI,CAAC,GAAG,EAAE;wBAC1B,GAAG,KAAA;qBACJ,CAAC,CAAC;iBACJ;YACH,CAAC,CAAC;YAEF,IAAI,oBAAoB,IAAI,GAAG,IAAI,OAAO,GAAG,CAAC,kBAAkB,KAAK,UAAU,EAAE;gBAC/E,IAAI,CAAC,GAAG,EAAE,oBAAoB,EAAE,UAAU,QAAyB;oBACjE,OAAO;wBAAU,wBAAwB;6BAAxB,UAAwB,EAAxB,qBAAwB,EAAxB,IAAwB;4BAAxB,mCAAwB;;wBACvC,yBAAyB,EAAE,CAAC;wBAC5B,OAAO,QAAQ,CAAC,KAAK,CAAC,GAAG,EAAE,cAAc,CAAC,CAAC;oBAC7C,CAAC,CAAC;gBACJ,CAAC,CAAC,CAAC;aACJ;iBAAM;gBACL,GAAG,CAAC,gBAAgB,CAAC,kBAAkB,EAAE,yBAAyB,CAAC,CAAC;aACrE;YAED,OAAO,YAAY,CAAC,KAAK,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QACvC,CAAC,CAAC;IACJ,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAE,UAAU,YAAwB;QACvD,OAAO;YAA6C,cAAc;iBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;gBAAd,yBAAc;;YAChE,IAAI,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,SAAS,EAAE;gBAChD,IAAI,CAAC,cAAc,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;aACpC;YAED,eAAe,CAAC,KAAK,EAAE;gBACrB,IAAI,MAAA;gBACJ,cAAc,EAAE,IAAI,CAAC,GAAG,EAAE;gBAC1B,GAAG,EAAE,IAAI;aACV,CAAC,CAAC;YAEH,OAAO,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QACxC,CAAC,CAAC;IACJ,CAAC,CAAC,CAAC;AACL,CAAC;AAED,IAAI,QAAgB,CAAC;AAErB,YAAY;AACZ,SAAS,iBAAiB;IACxB,IAAI,CAAC,eAAe,EAAE,EAAE;QACtB,OAAO;KACR;IAED,IAAM,aAAa,GAAG,MAAM,CAAC,UAAU,CAAC;IACxC,MAAM,CAAC,UAAU,GAAG;QAAqC,cAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;YAAd,yBAAc;;QACrE,IAAM,EAAE,GAAG,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC;QAChC,mFAAmF;QACnF,IAAM,IAAI,GAAG,QAAQ,CAAC;QACtB,QAAQ,GAAG,EAAE,CAAC;QACd,eAAe,CAAC,SAAS,EAAE;YACzB,IAAI,MAAA;YACJ,EAAE,IAAA;SACH,CAAC,CAAC;QACH,IAAI,aAAa,EAAE;YACjB,yFAAyF;YACzF,6DAA6D;YAC7D,mDAAmD;YACnD,IAAI;gBACF,OAAO,aAAa,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;aACxC;YAAC,OAAO,GAAG,EAAE;gBACZ,WAAW;aACZ;SACF;IACH,CAAC,CAAC;IAEF,cAAc;IACd,SAAS,0BAA0B,CAAC,uBAAmC;QACrE,OAAO;YAAyB,cAAc;iBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;gBAAd,yBAAc;;YAC5C,IAAM,GAAG,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;YAClD,IAAI,GAAG,EAAE;gBACP,iDAAiD;gBACjD,IAAM,IAAI,GAAG,QAAQ,CAAC;gBACtB,IAAM,EAAE,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;gBACvB,mFAAmF;gBACnF,QAAQ,GAAG,EAAE,CAAC;gBACd,eAAe,CAAC,SAAS,EAAE;oBACzB,IAAI,MAAA;oBACJ,EAAE,IAAA;iBACH,CAAC,CAAC;aACJ;YACD,OAAO,uBAAuB,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QACnD,CAAC,CAAC;IACJ,CAAC;IAED,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,WAAW,EAAE,0BAA0B,CAAC,CAAC;IAC9D,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,cAAc,EAAE,0BAA0B,CAAC,CAAC;AACnE,CAAC;AAED,IAAM,gBAAgB,GAAG,IAAI,CAAC;AAC9B,IAAI,eAAmC,CAAC;AACxC,IAAI,iBAAoC,CAAC;AAEzC;;;;GAIG;AACH,SAAS,kCAAkC,CAAC,QAA2B,EAAE,OAAc;IACrF,+EAA+E;IAC/E,IAAI,CAAC,QAAQ,EAAE;QACb,OAAO,IAAI,CAAC;KACb;IAED,kHAAkH;IAClH,IAAI,QAAQ,CAAC,IAAI,KAAK,OAAO,CAAC,IAAI,EAAE;QAClC,OAAO,IAAI,CAAC;KACb;IAED,IAAI;QACF,2GAA2G;QAC3G,sCAAsC;QACtC,IAAI,QAAQ,CAAC,MAAM,KAAK,OAAO,CAAC,MAAM,EAAE;YACtC,OAAO,IAAI,CAAC;SACb;KACF;IAAC,OAAO,CAAC,EAAE;QACV,qFAAqF;QACrF,iEAAiE;KAClE;IAED,gHAAgH;IAChH,oGAAoG;IACpG,mGAAmG;IACnG,OAAO,KAAK,CAAC;AACf,CAAC;AAED;;;GAGG;AACH,SAAS,kBAAkB,CAAC,KAAY;IACtC,iEAAiE;IACjE,IAAI,KAAK,CAAC,IAAI,KAAK,UAAU,EAAE;QAC7B,OAAO,KAAK,CAAC;KACd;IAED,IAAI;QACF,IAAM,MAAM,GAAG,KAAK,CAAC,MAAqB,CAAC;QAE3C,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE;YAC9B,OAAO,IAAI,CAAC;SACb;QAED,wGAAwG;QACxG,8CAA8C;QAC9C,IAAI,MAAM,CAAC,OAAO,KAAK,OAAO,IAAI,MAAM,CAAC,OAAO,KAAK,UAAU,IAAI,MAAM,CAAC,iBAAiB,EAAE;YAC3F,OAAO,KAAK,CAAC;SACd;KACF;IAAC,OAAO,CAAC,EAAE;QACV,qFAAqF;QACrF,iEAAiE;KAClE;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;;;;;GAMG;AACH,SAAS,mBAAmB,CAAC,OAAiB,EAAE,cAA+B;IAA/B,+BAAA,EAAA,sBAA+B;IAC7E,OAAO,UAAC,KAAY;QAClB,uEAAuE;QACvE,yDAAyD;QACzD,+CAA+C;QAC/C,IAAI,CAAC,KAAK,IAAI,iBAAiB,KAAK,KAAK,EAAE;YACzC,OAAO;SACR;QAED,wCAAwC;QACxC,IAAI,kBAAkB,CAAC,KAAK,CAAC,EAAE;YAC7B,OAAO;SACR;QAED,IAAM,IAAI,GAAG,KAAK,CAAC,IAAI,KAAK,UAAU,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC;QAE9D,wHAAwH;QACxH,IAAI,eAAe,KAAK,SAAS,EAAE;YACjC,OAAO,CAAC;gBACN,KAAK,EAAE,KAAK;gBACZ,IAAI,MAAA;gBACJ,MAAM,EAAE,cAAc;aACvB,CAAC,CAAC;YACH,iBAAiB,GAAG,KAAK,CAAC;SAC3B;QACD,yGAAyG;QACzG,8FAA8F;aACzF,IAAI,kCAAkC,CAAC,iBAAiB,EAAE,KAAK,CAAC,EAAE;YACrE,OAAO,CAAC;gBACN,KAAK,EAAE,KAAK;gBACZ,IAAI,MAAA;gBACJ,MAAM,EAAE,cAAc;aACvB,CAAC,CAAC;YACH,iBAAiB,GAAG,KAAK,CAAC;SAC3B;QAED,kHAAkH;QAClH,YAAY,CAAC,eAAe,CAAC,CAAC;QAC9B,eAAe,GAAG,MAAM,CAAC,UAAU,CAAC;YAClC,eAAe,GAAG,SAAS,CAAC;QAC9B,CAAC,EAAE,gBAAgB,CAAC,CAAC;IACvB,CAAC,CAAC;AACJ,CAAC;AAuBD,YAAY;AACZ,SAAS,aAAa;IACpB,IAAI,CAAC,CAAC,UAAU,IAAI,MAAM,CAAC,EAAE;QAC3B,OAAO;KACR;IAED,oHAAoH;IACpH,gHAAgH;IAChH,yFAAyF;IACzF,IAAM,iBAAiB,GAAG,eAAe,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAC5D,IAAM,qBAAqB,GAAG,mBAAmB,CAAC,iBAAiB,EAAE,IAAI,CAAC,CAAC;IAC3E,MAAM,CAAC,QAAQ,CAAC,gBAAgB,CAAC,OAAO,EAAE,qBAAqB,EAAE,KAAK,CAAC,CAAC;IACxE,MAAM,CAAC,QAAQ,CAAC,gBAAgB,CAAC,UAAU,EAAE,qBAAqB,EAAE,KAAK,CAAC,CAAC;IAE3E,wGAAwG;IACxG,gHAAgH;IAChH,6GAA6G;IAC7G,gHAAgH;IAChH,qCAAqC;IACrC,CAAC,aAAa,EAAE,MAAM,CAAC,CAAC,OAAO,CAAC,UAAC,MAAc;QAC7C,sEAAsE;QACtE,IAAM,KAAK,GAAI,MAAc,CAAC,MAAM,CAAC,IAAK,MAAc,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC;QAC3E,6FAA6F;QAC7F,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,cAAc,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,kBAAkB,CAAC,EAAE;YAChF,OAAO;SACR;QAED,IAAI,CAAC,KAAK,EAAE,kBAAkB,EAAE,UAAU,wBAA0C;YAClF,OAAO,UAEL,IAAY,EACZ,QAA4C,EAC5C,OAA2C;gBAE3C,IAAI,IAAI,KAAK,OAAO,IAAI,IAAI,IAAI,UAAU,EAAE;oBAC1C,IAAI;wBACF,IAAM,EAAE,GAAG,IAA2B,CAAC;wBACvC,IAAM,UAAQ,GAAG,CAAC,EAAE,CAAC,mCAAmC,GAAG,EAAE,CAAC,mCAAmC,IAAI,EAAE,CAAC,CAAC;wBACzG,IAAM,cAAc,GAAG,CAAC,UAAQ,CAAC,IAAI,CAAC,GAAG,UAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;wBAE5E,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE;4BAC3B,IAAM,OAAO,GAAG,mBAAmB,CAAC,iBAAiB,CAAC,CAAC;4BACvD,cAAc,CAAC,OAAO,GAAG,OAAO,CAAC;4BACjC,wBAAwB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;yBAC7D;wBAED,cAAc,CAAC,QAAQ,IAAI,CAAC,CAAC;qBAC9B;oBAAC,OAAO,CAAC,EAAE;wBACV,8CAA8C;wBAC9C,iFAAiF;qBAClF;iBACF;gBAED,OAAO,wBAAwB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;YACtE,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;QAEH,IAAI,CACF,KAAK,EACL,qBAAqB,EACrB,UAAU,2BAAgD;YACxD,OAAO,UAEL,IAAY,EACZ,QAA4C,EAC5C,OAAwC;gBAExC,IAAI,IAAI,KAAK,OAAO,IAAI,IAAI,IAAI,UAAU,EAAE;oBAC1C,IAAI;wBACF,IAAM,EAAE,GAAG,IAA2B,CAAC;wBACvC,IAAM,UAAQ,GAAG,EAAE,CAAC,mCAAmC,IAAI,EAAE,CAAC;wBAC9D,IAAM,cAAc,GAAG,UAAQ,CAAC,IAAI,CAAC,CAAC;wBAEtC,IAAI,cAAc,EAAE;4BAClB,cAAc,CAAC,QAAQ,IAAI,CAAC,CAAC;4BAC7B,2GAA2G;4BAC3G,IAAI,cAAc,CAAC,QAAQ,IAAI,CAAC,EAAE;gCAChC,2BAA2B,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,cAAc,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;gCAC9E,cAAc,CAAC,OAAO,GAAG,SAAS,CAAC;gCACnC,OAAO,UAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,2DAA2D;6BACnF;4BAED,8FAA8F;4BAC9F,IAAI,MAAM,CAAC,IAAI,CAAC,UAAQ,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE;gCACtC,OAAO,EAAE,CAAC,mCAAmC,CAAC;6BAC/C;yBACF;qBACF;oBAAC,OAAO,CAAC,EAAE;wBACV,8CAA8C;wBAC9C,iFAAiF;qBAClF;iBACF;gBAED,OAAO,2BAA2B,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;YACzE,CAAC,CAAC;QACJ,CAAC,CACF,CAAC;IACJ,CAAC,CAAC,CAAC;AACL,CAAC;AAED,IAAI,kBAAkB,GAAwB,IAAI,CAAC;AACnD,YAAY;AACZ,SAAS,eAAe;IACtB,kBAAkB,GAAG,MAAM,CAAC,OAAO,CAAC;IAEpC,MAAM,CAAC,OAAO,GAAG,UAAU,GAAQ,EAAE,GAAQ,EAAE,IAAS,EAAE,MAAW,EAAE,KAAU;QAC/E,eAAe,CAAC,OAAO,EAAE;YACvB,MAAM,QAAA;YACN,KAAK,OAAA;YACL,IAAI,MAAA;YACJ,GAAG,KAAA;YACH,GAAG,KAAA;SACJ,CAAC,CAAC;QAEH,IAAI,kBAAkB,EAAE;YACtB,8CAA8C;YAC9C,OAAO,kBAAkB,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;SAClD;QAED,OAAO,KAAK,CAAC;IACf,CAAC,CAAC;AACJ,CAAC;AAED,IAAI,+BAA+B,GAA8B,IAAI,CAAC;AACtE,YAAY;AACZ,SAAS,4BAA4B;IACnC,+BAA+B,GAAG,MAAM,CAAC,oBAAoB,CAAC;IAE9D,MAAM,CAAC,oBAAoB,GAAG,UAAU,CAAM;QAC5C,eAAe,CAAC,oBAAoB,EAAE,CAAC,CAAC,CAAC;QAEzC,IAAI,+BAA+B,EAAE;YACnC,8CAA8C;YAC9C,OAAO,+BAA+B,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;SAC/D;QAED,OAAO,IAAI,CAAC;IACd,CAAC,CAAC;AACJ,CAAC","sourcesContent":["/* eslint-disable max-lines */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\nimport { WrappedFunction } from '@sentry/types';\n\nimport { IS_DEBUG_BUILD } from './flags';\nimport { getGlobalObject } from './global';\nimport { isInstanceOf, isString } from './is';\nimport { CONSOLE_LEVELS, logger } from './logger';\nimport { fill } from './object';\nimport { getFunctionName } from './stacktrace';\nimport { supportsHistory, supportsNativeFetch } from './supports';\n\nconst global = getGlobalObject<Window>();\n\ntype InstrumentHandlerType =\n  | 'console'\n  | 'dom'\n  | 'fetch'\n  | 'history'\n  | 'sentry'\n  | 'xhr'\n  | 'error'\n  | 'unhandledrejection';\ntype InstrumentHandlerCallback = (data: any) => void;\n\n/**\n * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.\n *  - Console API\n *  - Fetch API\n *  - XHR API\n *  - History API\n *  - DOM API (click/typing)\n *  - Error API\n *  - UnhandledRejection API\n */\n\nconst handlers: { [key in InstrumentHandlerType]?: InstrumentHandlerCallback[] } = {};\nconst instrumented: { [key in InstrumentHandlerType]?: boolean } = {};\n\n/** Instruments given API */\nfunction instrument(type: InstrumentHandlerType): void {\n  if (instrumented[type]) {\n    return;\n  }\n\n  instrumented[type] = true;\n\n  switch (type) {\n    case 'console':\n      instrumentConsole();\n      break;\n    case 'dom':\n      instrumentDOM();\n      break;\n    case 'xhr':\n      instrumentXHR();\n      break;\n    case 'fetch':\n      instrumentFetch();\n      break;\n    case 'history':\n      instrumentHistory();\n      break;\n    case 'error':\n      instrumentError();\n      break;\n    case 'unhandledrejection':\n      instrumentUnhandledRejection();\n      break;\n    default:\n      IS_DEBUG_BUILD && logger.warn('unknown instrumentation type:', type);\n      return;\n  }\n}\n\n/**\n * Add handler that will be called when given type of instrumentation triggers.\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addInstrumentationHandler(type: InstrumentHandlerType, callback: InstrumentHandlerCallback): void {\n  handlers[type] = handlers[type] || [];\n  (handlers[type] as InstrumentHandlerCallback[]).push(callback);\n  instrument(type);\n}\n\n/** JSDoc */\nfunction triggerHandlers(type: InstrumentHandlerType, data: any): void {\n  if (!type || !handlers[type]) {\n    return;\n  }\n\n  for (const handler of handlers[type] || []) {\n    try {\n      handler(data);\n    } catch (e) {\n      IS_DEBUG_BUILD &&\n        logger.error(\n          `Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`,\n          e,\n        );\n    }\n  }\n}\n\n/** JSDoc */\nfunction instrumentConsole(): void {\n  if (!('console' in global)) {\n    return;\n  }\n\n  CONSOLE_LEVELS.forEach(function (level: string): void {\n    if (!(level in global.console)) {\n      return;\n    }\n\n    fill(global.console, level, function (originalConsoleMethod: () => any): Function {\n      return function (...args: any[]): void {\n        triggerHandlers('console', { args, level });\n\n        // this fails for some browsers. :(\n        if (originalConsoleMethod) {\n          originalConsoleMethod.apply(global.console, args);\n        }\n      };\n    });\n  });\n}\n\n/** JSDoc */\nfunction instrumentFetch(): void {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n\n  fill(global, 'fetch', function (originalFetch: () => void): () => void {\n    return function (...args: any[]): void {\n      const handlerData = {\n        args,\n        fetchData: {\n          method: getFetchMethod(args),\n          url: getFetchUrl(args),\n        },\n        startTimestamp: Date.now(),\n      };\n\n      triggerHandlers('fetch', {\n        ...handlerData,\n      });\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalFetch.apply(global, args).then(\n        (response: Response) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            response,\n          });\n          return response;\n        },\n        (error: Error) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            error,\n          });\n          // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n          //       it means the sentry.javascript SDK caught an error invoking your application code.\n          //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n          throw error;\n        },\n      );\n    };\n  });\n}\n\ntype XHRSendInput = null | Blob | BufferSource | FormData | URLSearchParams | string;\n\n/** JSDoc */\ninterface SentryWrappedXMLHttpRequest extends XMLHttpRequest {\n  [key: string]: any;\n  __sentry_xhr__?: {\n    method?: string;\n    url?: string;\n    status_code?: number;\n    body?: XHRSendInput;\n  };\n}\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/** Extract `method` from fetch call arguments */\nfunction getFetchMethod(fetchArgs: any[] = []): string {\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {\n    return String(fetchArgs[0].method).toUpperCase();\n  }\n  if (fetchArgs[1] && fetchArgs[1].method) {\n    return String(fetchArgs[1].method).toUpperCase();\n  }\n  return 'GET';\n}\n\n/** Extract `url` from fetch call arguments */\nfunction getFetchUrl(fetchArgs: any[] = []): string {\n  if (typeof fetchArgs[0] === 'string') {\n    return fetchArgs[0];\n  }\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request)) {\n    return fetchArgs[0].url;\n  }\n  return String(fetchArgs[0]);\n}\n/* eslint-enable @typescript-eslint/no-unsafe-member-access */\n\n/** JSDoc */\nfunction instrumentXHR(): void {\n  if (!('XMLHttpRequest' in global)) {\n    return;\n  }\n\n  const xhrproto = XMLHttpRequest.prototype;\n\n  fill(xhrproto, 'open', function (originalOpen: () => void): () => void {\n    return function (this: SentryWrappedXMLHttpRequest, ...args: any[]): void {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const xhr = this;\n      const url = args[1];\n      const xhrInfo: SentryWrappedXMLHttpRequest['__sentry_xhr__'] = (xhr.__sentry_xhr__ = {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        method: isString(args[0]) ? args[0].toUpperCase() : args[0],\n        url: args[1],\n      });\n\n      // if Sentry key appears in URL, don't capture it as a request\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (isString(url) && xhrInfo.method === 'POST' && url.match(/sentry_key/)) {\n        xhr.__sentry_own_request__ = true;\n      }\n\n      const onreadystatechangeHandler = function (): void {\n        if (xhr.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = xhr.status;\n          } catch (e) {\n            /* do nothing */\n          }\n\n          triggerHandlers('xhr', {\n            args,\n            endTimestamp: Date.now(),\n            startTimestamp: Date.now(),\n            xhr,\n          });\n        }\n      };\n\n      if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {\n        fill(xhr, 'onreadystatechange', function (original: WrappedFunction): Function {\n          return function (...readyStateArgs: any[]): void {\n            onreadystatechangeHandler();\n            return original.apply(xhr, readyStateArgs);\n          };\n        });\n      } else {\n        xhr.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      return originalOpen.apply(xhr, args);\n    };\n  });\n\n  fill(xhrproto, 'send', function (originalSend: () => void): () => void {\n    return function (this: SentryWrappedXMLHttpRequest, ...args: any[]): void {\n      if (this.__sentry_xhr__ && args[0] !== undefined) {\n        this.__sentry_xhr__.body = args[0];\n      }\n\n      triggerHandlers('xhr', {\n        args,\n        startTimestamp: Date.now(),\n        xhr: this,\n      });\n\n      return originalSend.apply(this, args);\n    };\n  });\n}\n\nlet lastHref: string;\n\n/** JSDoc */\nfunction instrumentHistory(): void {\n  if (!supportsHistory()) {\n    return;\n  }\n\n  const oldOnPopState = global.onpopstate;\n  global.onpopstate = function (this: WindowEventHandlers, ...args: any[]): any {\n    const to = global.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n    triggerHandlers('history', {\n      from,\n      to,\n    });\n    if (oldOnPopState) {\n      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.\n      // https://github.com/getsentry/sentry-javascript/issues/3344\n      // https://github.com/bugsnag/bugsnag-js/issues/469\n      try {\n        return oldOnPopState.apply(this, args);\n      } catch (_oO) {\n        // no-empty\n      }\n    }\n  };\n\n  /** @hidden */\n  function historyReplacementFunction(originalHistoryFunction: () => void): () => void {\n    return function (this: History, ...args: any[]): void {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        const from = lastHref;\n        const to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        triggerHandlers('history', {\n          from,\n          to,\n        });\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(global.history, 'pushState', historyReplacementFunction);\n  fill(global.history, 'replaceState', historyReplacementFunction);\n}\n\nconst debounceDuration = 1000;\nlet debounceTimerID: number | undefined;\nlet lastCapturedEvent: Event | undefined;\n\n/**\n * Decide whether the current event should finish the debounce of previously captured one.\n * @param previous previously captured event\n * @param current event to be captured\n */\nfunction shouldShortcircuitPreviousDebounce(previous: Event | undefined, current: Event): boolean {\n  // If there was no previous event, it should always be swapped for the new one.\n  if (!previous) {\n    return true;\n  }\n\n  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n  if (previous.type !== current.type) {\n    return true;\n  }\n\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (previous.target !== current.target) {\n      return true;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n  return false;\n}\n\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\nfunction shouldSkipDOMEvent(event: Event): boolean {\n  // We are only interested in filtering `keypress` events for now.\n  if (event.type !== 'keypress') {\n    return false;\n  }\n\n  try {\n    const target = event.target as HTMLElement;\n\n    if (!target || !target.tagName) {\n      return true;\n    }\n\n    // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n    // e.g.tabbing through elements, hotkeys, etc.\n    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n      return false;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  return true;\n}\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n * @param handler function that will be triggered\n * @param globalListener indicates whether event was captured by the global event listener\n * @returns wrapped breadcrumb events handler\n * @hidden\n */\nfunction makeDOMEventHandler(handler: Function, globalListener: boolean = false): (event: Event) => void {\n  return (event: Event): void => {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || lastCapturedEvent === event) {\n      return;\n    }\n\n    // We always want to skip _some_ events.\n    if (shouldSkipDOMEvent(event)) {\n      return;\n    }\n\n    const name = event.type === 'keypress' ? 'input' : event.type;\n\n    // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.\n    if (debounceTimerID === undefined) {\n      handler({\n        event: event,\n        name,\n        global: globalListener,\n      });\n      lastCapturedEvent = event;\n    }\n    // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {\n      handler({\n        event: event,\n        name,\n        global: globalListener,\n      });\n      lastCapturedEvent = event;\n    }\n\n    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n    clearTimeout(debounceTimerID);\n    debounceTimerID = global.setTimeout(() => {\n      debounceTimerID = undefined;\n    }, debounceDuration);\n  };\n}\n\ntype AddEventListener = (\n  type: string,\n  listener: EventListenerOrEventListenerObject,\n  options?: boolean | AddEventListenerOptions,\n) => void;\ntype RemoveEventListener = (\n  type: string,\n  listener: EventListenerOrEventListenerObject,\n  options?: boolean | EventListenerOptions,\n) => void;\n\ntype InstrumentedElement = Element & {\n  __sentry_instrumentation_handlers__?: {\n    [key in 'click' | 'keypress']?: {\n      handler?: Function;\n      /** The number of custom listeners attached to this element */\n      refCount: number;\n    };\n  };\n};\n\n/** JSDoc */\nfunction instrumentDOM(): void {\n  if (!('document' in global)) {\n    return;\n  }\n\n  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n  const triggerDOMHandler = triggerHandlers.bind(null, 'dom');\n  const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  global.document.addEventListener('click', globalDOMEventHandler, false);\n  global.document.addEventListener('keypress', globalDOMEventHandler, false);\n\n  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n  ['EventTarget', 'Node'].forEach((target: string) => {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const proto = (global as any)[target] && (global as any)[target].prototype;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n\n    fill(proto, 'addEventListener', function (originalAddEventListener: AddEventListener): AddEventListener {\n      return function (\n        this: Element,\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: boolean | AddEventListenerOptions,\n      ): AddEventListener {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            const el = this as InstrumentedElement;\n            const handlers = (el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {});\n            const handlerForType = (handlers[type] = handlers[type] || { refCount: 0 });\n\n            if (!handlerForType.handler) {\n              const handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n\n            handlerForType.refCount += 1;\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n          }\n        }\n\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n\n    fill(\n      proto,\n      'removeEventListener',\n      function (originalRemoveEventListener: RemoveEventListener): RemoveEventListener {\n        return function (\n          this: Element,\n          type: string,\n          listener: EventListenerOrEventListenerObject,\n          options?: boolean | EventListenerOptions,\n        ): () => void {\n          if (type === 'click' || type == 'keypress') {\n            try {\n              const el = this as InstrumentedElement;\n              const handlers = el.__sentry_instrumentation_handlers__ || {};\n              const handlerForType = handlers[type];\n\n              if (handlerForType) {\n                handlerForType.refCount -= 1;\n                // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n                if (handlerForType.refCount <= 0) {\n                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                  handlerForType.handler = undefined;\n                  delete handlers[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n                }\n\n                // If there are no longer any custom handlers of any type on this element, cleanup everything.\n                if (Object.keys(handlers).length === 0) {\n                  delete el.__sentry_instrumentation_handlers__;\n                }\n              }\n            } catch (e) {\n              // Accessing dom properties is always fragile.\n              // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n            }\n          }\n\n          return originalRemoveEventListener.call(this, type, listener, options);\n        };\n      },\n    );\n  });\n}\n\nlet _oldOnErrorHandler: OnErrorEventHandler = null;\n/** JSDoc */\nfunction instrumentError(): void {\n  _oldOnErrorHandler = global.onerror;\n\n  global.onerror = function (msg: any, url: any, line: any, column: any, error: any): boolean {\n    triggerHandlers('error', {\n      column,\n      error,\n      line,\n      msg,\n      url,\n    });\n\n    if (_oldOnErrorHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnErrorHandler.apply(this, arguments);\n    }\n\n    return false;\n  };\n}\n\nlet _oldOnUnhandledRejectionHandler: ((e: any) => void) | null = null;\n/** JSDoc */\nfunction instrumentUnhandledRejection(): void {\n  _oldOnUnhandledRejectionHandler = global.onunhandledrejection;\n\n  global.onunhandledrejection = function (e: any): boolean {\n    triggerHandlers('unhandledrejection', e);\n\n    if (_oldOnUnhandledRejectionHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnUnhandledRejectionHandler.apply(this, arguments);\n    }\n\n    return true;\n  };\n}\n"]}import { Primitive } from '@sentry/types';
/**
 * Checks whether given value's type is one of a few Error or Error-like
 * {@link isError}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isError(wat: unknown): wat is Error;
/**
 * Checks whether given value's type is ErrorEvent
 * {@link isErrorEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isErrorEvent(wat: unknown): boolean;
/**
 * Checks whether given value's type is DOMError
 * {@link isDOMError}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isDOMError(wat: unknown): boolean;
/**
 * Checks whether given value's type is DOMException
 * {@link isDOMException}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isDOMException(wat: unknown): boolean;
/**
 * Checks whether given value's type is a string
 * {@link isString}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isString(wat: unknown): wat is string;
/**
 * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)
 * {@link isPrimitive}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isPrimitive(wat: unknown): wat is Primitive;
/**
 * Checks whether given value's type is an object literal
 * {@link isPlainObject}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isPlainObject(wat: unknown): wat is Record<string, unknown>;
/**
 * Checks whether given value's type is an Event instance
 * {@link isEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isEvent(wat: unknown): boolean;
/**
 * Checks whether given value's type is an Element instance
 * {@link isElement}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isElement(wat: unknown): boolean;
/**
 * Checks whether given value's type is an regexp
 * {@link isRegExp}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isRegExp(wat: unknown): wat is RegExp;
/**
 * Checks whether given value has a then function.
 * @param wat A value to be checked.
 */
export declare function isThenable(wat: any): wat is PromiseLike<any>;
/**
 * Checks whether given value's type is a SyntheticEvent
 * {@link isSyntheticEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isSyntheticEvent(wat: unknown): boolean;
/**
 * Checks whether given value is NaN
 * {@link isNaN}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isNaN(wat: unknown): boolean;
/**
 * Checks whether given value's type is an instance of provided constructor.
 * {@link isInstanceOf}.
 *
 * @param wat A value to be checked.
 * @param base A constructor to be used in a check.
 * @returns A boolean representing the result.
 */
export declare function isInstanceOf(wat: any, base: any): boolean;
//# sourceMappingURL=is.d.ts.map{"version":3,"file":"is.d.ts","sourceRoot":"","sources":["../../src/is.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAK1C;;;;;;GAMG;AACH,wBAAgB,OAAO,CAAC,GAAG,EAAE,OAAO,GAAG,GAAG,IAAI,KAAK,CASlD;AAMD;;;;;;GAMG;AACH,wBAAgB,YAAY,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAElD;AAED;;;;;;GAMG;AACH,wBAAgB,UAAU,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAEhD;AAED;;;;;;GAMG;AACH,wBAAgB,cAAc,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAEpD;AAED;;;;;;GAMG;AACH,wBAAgB,QAAQ,CAAC,GAAG,EAAE,OAAO,GAAG,GAAG,IAAI,MAAM,CAEpD;AAED;;;;;;GAMG;AACH,wBAAgB,WAAW,CAAC,GAAG,EAAE,OAAO,GAAG,GAAG,IAAI,SAAS,CAE1D;AAED;;;;;;GAMG;AACH,wBAAgB,aAAa,CAAC,GAAG,EAAE,OAAO,GAAG,GAAG,IAAI,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAE1E;AAED;;;;;;GAMG;AACH,wBAAgB,OAAO,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAE7C;AAED;;;;;;GAMG;AACH,wBAAgB,SAAS,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAE/C;AAED;;;;;;GAMG;AACH,wBAAgB,QAAQ,CAAC,GAAG,EAAE,OAAO,GAAG,GAAG,IAAI,MAAM,CAEpD;AAED;;;GAGG;AACH,wBAAgB,UAAU,CAAC,GAAG,EAAE,GAAG,GAAG,GAAG,IAAI,WAAW,CAAC,GAAG,CAAC,CAG5D;AAED;;;;;;GAMG;AACH,wBAAgB,gBAAgB,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAEtD;AAED;;;;;;GAMG;AACH,wBAAgB,KAAK,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAE3C;AAED;;;;;;;GAOG;AACH,wBAAgB,YAAY,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,OAAO,CAMzD"}/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
// eslint-disable-next-line @typescript-eslint/unbound-method
var objectToString = Object.prototype.toString;
/**
 * Checks whether given value's type is one of a few Error or Error-like
 * {@link isError}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export function isError(wat) {
    switch (objectToString.call(wat)) {
        case '[object Error]':
        case '[object Exception]':
        case '[object DOMException]':
            return true;
        default:
            return isInstanceOf(wat, Error);
    }
}
function isBuiltin(wat, ty) {
    return objectToString.call(wat) === "[object " + ty + "]";
}
/**
 * Checks whether given value's type is ErrorEvent
 * {@link isErrorEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export function isErrorEvent(wat) {
    return isBuiltin(wat, 'ErrorEvent');
}
/**
 * Checks whether given value's type is DOMError
 * {@link isDOMError}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export function isDOMError(wat) {
    return isBuiltin(wat, 'DOMError');
}
/**
 * Checks whether given value's type is DOMException
 * {@link isDOMException}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export function isDOMException(wat) {
    return isBuiltin(wat, 'DOMException');
}
/**
 * Checks whether given value's type is a string
 * {@link isString}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export function isString(wat) {
    return isBuiltin(wat, 'String');
}
/**
 * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)
 * {@link isPrimitive}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export function isPrimitive(wat) {
    return wat === null || (typeof wat !== 'object' && typeof wat !== 'function');
}
/**
 * Checks whether given value's type is an object literal
 * {@link isPlainObject}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export function isPlainObject(wat) {
    return isBuiltin(wat, 'Object');
}
/**
 * Checks whether given value's type is an Event instance
 * {@link isEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export function isEvent(wat) {
    return typeof Event !== 'undefined' && isInstanceOf(wat, Event);
}
/**
 * Checks whether given value's type is an Element instance
 * {@link isElement}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export function isElement(wat) {
    return typeof Element !== 'undefined' && isInstanceOf(wat, Element);
}
/**
 * Checks whether given value's type is an regexp
 * {@link isRegExp}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export function isRegExp(wat) {
    return isBuiltin(wat, 'RegExp');
}
/**
 * Checks whether given value has a then function.
 * @param wat A value to be checked.
 */
export function isThenable(wat) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    return Boolean(wat && wat.then && typeof wat.then === 'function');
}
/**
 * Checks whether given value's type is a SyntheticEvent
 * {@link isSyntheticEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export function isSyntheticEvent(wat) {
    return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;
}
/**
 * Checks whether given value is NaN
 * {@link isNaN}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export function isNaN(wat) {
    return typeof wat === 'number' && wat !== wat;
}
/**
 * Checks whether given value's type is an instance of provided constructor.
 * {@link isInstanceOf}.
 *
 * @param wat A value to be checked.
 * @param base A constructor to be used in a check.
 * @returns A boolean representing the result.
 */
export function isInstanceOf(wat, base) {
    try {
        return wat instanceof base;
    }
    catch (_e) {
        return false;
    }
}
//# sourceMappingURL=is.js.map{"version":3,"file":"is.js","sourceRoot":"","sources":["../../src/is.ts"],"names":[],"mappings":"AAAA,uDAAuD;AACvD,sEAAsE;AAItE,6DAA6D;AAC7D,IAAM,cAAc,GAAG,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC;AAEjD;;;;;;GAMG;AACH,MAAM,UAAU,OAAO,CAAC,GAAY;IAClC,QAAQ,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;QAChC,KAAK,gBAAgB,CAAC;QACtB,KAAK,oBAAoB,CAAC;QAC1B,KAAK,uBAAuB;YAC1B,OAAO,IAAI,CAAC;QACd;YACE,OAAO,YAAY,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;KACnC;AACH,CAAC;AAED,SAAS,SAAS,CAAC,GAAY,EAAE,EAAU;IACzC,OAAO,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,aAAW,EAAE,MAAG,CAAC;AACvD,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,YAAY,CAAC,GAAY;IACvC,OAAO,SAAS,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;AACtC,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,UAAU,CAAC,GAAY;IACrC,OAAO,SAAS,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC;AACpC,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,cAAc,CAAC,GAAY;IACzC,OAAO,SAAS,CAAC,GAAG,EAAE,cAAc,CAAC,CAAC;AACxC,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,QAAQ,CAAC,GAAY;IACnC,OAAO,SAAS,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;AAClC,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,WAAW,CAAC,GAAY;IACtC,OAAO,GAAG,KAAK,IAAI,IAAI,CAAC,OAAO,GAAG,KAAK,QAAQ,IAAI,OAAO,GAAG,KAAK,UAAU,CAAC,CAAC;AAChF,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,aAAa,CAAC,GAAY;IACxC,OAAO,SAAS,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;AAClC,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,OAAO,CAAC,GAAY;IAClC,OAAO,OAAO,KAAK,KAAK,WAAW,IAAI,YAAY,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;AAClE,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,SAAS,CAAC,GAAY;IACpC,OAAO,OAAO,OAAO,KAAK,WAAW,IAAI,YAAY,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;AACtE,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,QAAQ,CAAC,GAAY;IACnC,OAAO,SAAS,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;AAClC,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,UAAU,CAAC,GAAQ;IACjC,sEAAsE;IACtE,OAAO,OAAO,CAAC,GAAG,IAAI,GAAG,CAAC,IAAI,IAAI,OAAO,GAAG,CAAC,IAAI,KAAK,UAAU,CAAC,CAAC;AACpE,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,gBAAgB,CAAC,GAAY;IAC3C,OAAO,aAAa,CAAC,GAAG,CAAC,IAAI,aAAa,IAAI,GAAG,IAAI,gBAAgB,IAAI,GAAG,IAAI,iBAAiB,IAAI,GAAG,CAAC;AAC3G,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,KAAK,CAAC,GAAY;IAChC,OAAO,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,KAAK,GAAG,CAAC;AAChD,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,YAAY,CAAC,GAAQ,EAAE,IAAS;IAC9C,IAAI;QACF,OAAO,GAAG,YAAY,IAAI,CAAC;KAC5B;IAAC,OAAO,EAAE,EAAE;QACX,OAAO,KAAK,CAAC;KACd;AACH,CAAC","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n\nimport { Primitive } from '@sentry/types';\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst objectToString = Object.prototype.toString;\n\n/**\n * Checks whether given value's type is one of a few Error or Error-like\n * {@link isError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isError(wat: unknown): wat is Error {\n  switch (objectToString.call(wat)) {\n    case '[object Error]':\n    case '[object Exception]':\n    case '[object DOMException]':\n      return true;\n    default:\n      return isInstanceOf(wat, Error);\n  }\n}\n\nfunction isBuiltin(wat: unknown, ty: string): boolean {\n  return objectToString.call(wat) === `[object ${ty}]`;\n}\n\n/**\n * Checks whether given value's type is ErrorEvent\n * {@link isErrorEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isErrorEvent(wat: unknown): boolean {\n  return isBuiltin(wat, 'ErrorEvent');\n}\n\n/**\n * Checks whether given value's type is DOMError\n * {@link isDOMError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isDOMError(wat: unknown): boolean {\n  return isBuiltin(wat, 'DOMError');\n}\n\n/**\n * Checks whether given value's type is DOMException\n * {@link isDOMException}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isDOMException(wat: unknown): boolean {\n  return isBuiltin(wat, 'DOMException');\n}\n\n/**\n * Checks whether given value's type is a string\n * {@link isString}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isString(wat: unknown): wat is string {\n  return isBuiltin(wat, 'String');\n}\n\n/**\n * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)\n * {@link isPrimitive}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isPrimitive(wat: unknown): wat is Primitive {\n  return wat === null || (typeof wat !== 'object' && typeof wat !== 'function');\n}\n\n/**\n * Checks whether given value's type is an object literal\n * {@link isPlainObject}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isPlainObject(wat: unknown): wat is Record<string, unknown> {\n  return isBuiltin(wat, 'Object');\n}\n\n/**\n * Checks whether given value's type is an Event instance\n * {@link isEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isEvent(wat: unknown): boolean {\n  return typeof Event !== 'undefined' && isInstanceOf(wat, Event);\n}\n\n/**\n * Checks whether given value's type is an Element instance\n * {@link isElement}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isElement(wat: unknown): boolean {\n  return typeof Element !== 'undefined' && isInstanceOf(wat, Element);\n}\n\n/**\n * Checks whether given value's type is an regexp\n * {@link isRegExp}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isRegExp(wat: unknown): wat is RegExp {\n  return isBuiltin(wat, 'RegExp');\n}\n\n/**\n * Checks whether given value has a then function.\n * @param wat A value to be checked.\n */\nexport function isThenable(wat: any): wat is PromiseLike<any> {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return Boolean(wat && wat.then && typeof wat.then === 'function');\n}\n\n/**\n * Checks whether given value's type is a SyntheticEvent\n * {@link isSyntheticEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isSyntheticEvent(wat: unknown): boolean {\n  return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;\n}\n\n/**\n * Checks whether given value is NaN\n * {@link isNaN}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isNaN(wat: unknown): boolean {\n  return typeof wat === 'number' && wat !== wat;\n}\n\n/**\n * Checks whether given value's type is an instance of provided constructor.\n * {@link isInstanceOf}.\n *\n * @param wat A value to be checked.\n * @param base A constructor to be used in a check.\n * @returns A boolean representing the result.\n */\nexport function isInstanceOf(wat: any, base: any): boolean {\n  try {\n    return wat instanceof base;\n  } catch (_e) {\n    return false;\n  }\n}\n"]}export declare const CONSOLE_LEVELS: readonly ["debug", "info", "warn", "error", "log", "assert"];
declare type LoggerMethod = (...args: unknown[]) => void;
declare type LoggerConsoleMethods = Record<typeof CONSOLE_LEVELS[number], LoggerMethod>;
/** JSDoc */
interface Logger extends LoggerConsoleMethods {
    disable(): void;
    enable(): void;
}
/**
 * Temporarily disable sentry console instrumentations.
 *
 * @param callback The function to run against the original `console` messages
 * @returns The results of the callback
 */
export declare function consoleSandbox<T>(callback: () => T): T;
declare let logger: Logger;
export { logger };
//# sourceMappingURL=logger.d.ts.map{"version":3,"file":"logger.d.ts","sourceRoot":"","sources":["../../src/logger.ts"],"names":[],"mappings":"AAWA,eAAO,MAAM,cAAc,8DAA+D,CAAC;AAE3F,aAAK,YAAY,GAAG,CAAC,GAAG,IAAI,EAAE,OAAO,EAAE,KAAK,IAAI,CAAC;AACjD,aAAK,oBAAoB,GAAG,MAAM,CAAC,OAAO,cAAc,CAAC,MAAM,CAAC,EAAE,YAAY,CAAC,CAAC;AAEhF,YAAY;AACZ,UAAU,MAAO,SAAQ,oBAAoB;IAC3C,OAAO,IAAI,IAAI,CAAC;IAChB,MAAM,IAAI,IAAI,CAAC;CAChB;AAED;;;;;GAKG;AACH,wBAAgB,cAAc,CAAC,CAAC,EAAE,QAAQ,EAAE,MAAM,CAAC,GAAG,CAAC,CA6BtD;AAkCD,QAAA,IAAI,MAAM,EAAE,MAAM,CAAC;AAOnB,OAAO,EAAE,MAAM,EAAE,CAAC"}import { __read, __spread } from "tslib";
import { IS_DEBUG_BUILD } from './flags';
import { getGlobalObject, getGlobalSingleton } from './global';
// TODO: Implement different loggers for different environments
var global = getGlobalObject();
/** Prefix for logging strings */
var PREFIX = 'Sentry Logger ';
export var CONSOLE_LEVELS = ['debug', 'info', 'warn', 'error', 'log', 'assert'];
/**
 * Temporarily disable sentry console instrumentations.
 *
 * @param callback The function to run against the original `console` messages
 * @returns The results of the callback
 */
export function consoleSandbox(callback) {
    var global = getGlobalObject();
    if (!('console' in global)) {
        return callback();
    }
    var originalConsole = global.console;
    var wrappedLevels = {};
    // Restore all wrapped console methods
    CONSOLE_LEVELS.forEach(function (level) {
        // TODO(v7): Remove this check as it's only needed for Node 6
        var originalWrappedFunc = originalConsole[level] && originalConsole[level].__sentry_original__;
        if (level in global.console && originalWrappedFunc) {
            wrappedLevels[level] = originalConsole[level];
            originalConsole[level] = originalWrappedFunc;
        }
    });
    try {
        return callback();
    }
    finally {
        // Revert restoration to wrapped state
        Object.keys(wrappedLevels).forEach(function (level) {
            originalConsole[level] = wrappedLevels[level];
        });
    }
}
function makeLogger() {
    var enabled = false;
    var logger = {
        enable: function () {
            enabled = true;
        },
        disable: function () {
            enabled = false;
        },
    };
    if (IS_DEBUG_BUILD) {
        CONSOLE_LEVELS.forEach(function (name) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            logger[name] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (enabled) {
                    consoleSandbox(function () {
                        var _a;
                        (_a = global.console)[name].apply(_a, __spread([PREFIX + "[" + name + "]:"], args));
                    });
                }
            };
        });
    }
    else {
        CONSOLE_LEVELS.forEach(function (name) {
            logger[name] = function () { return undefined; };
        });
    }
    return logger;
}
// Ensure we only have a single logger instance, even if multiple versions of @sentry/utils are being used
var logger;
if (IS_DEBUG_BUILD) {
    logger = getGlobalSingleton('logger', makeLogger);
}
else {
    logger = makeLogger();
}
export { logger };
//# sourceMappingURL=logger.js.map{"version":3,"file":"logger.js","sourceRoot":"","sources":["../../src/logger.ts"],"names":[],"mappings":";AAEA,OAAO,EAAE,cAAc,EAAE,MAAM,SAAS,CAAC;AACzC,OAAO,EAAE,eAAe,EAAE,kBAAkB,EAAE,MAAM,UAAU,CAAC;AAE/D,+DAA+D;AAC/D,IAAM,MAAM,GAAG,eAAe,EAA0B,CAAC;AAEzD,iCAAiC;AACjC,IAAM,MAAM,GAAG,gBAAgB,CAAC;AAEhC,MAAM,CAAC,IAAM,cAAc,GAAG,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,QAAQ,CAAU,CAAC;AAW3F;;;;;GAKG;AACH,MAAM,UAAU,cAAc,CAAI,QAAiB;IACjD,IAAM,MAAM,GAAG,eAAe,EAAU,CAAC;IAEzC,IAAI,CAAC,CAAC,SAAS,IAAI,MAAM,CAAC,EAAE;QAC1B,OAAO,QAAQ,EAAE,CAAC;KACnB;IAED,IAAM,eAAe,GAAG,MAAM,CAAC,OAA4C,CAAC;IAC5E,IAAM,aAAa,GAAkC,EAAE,CAAC;IAExD,sCAAsC;IACtC,cAAc,CAAC,OAAO,CAAC,UAAA,KAAK;QAC1B,6DAA6D;QAC7D,IAAM,mBAAmB,GACvB,eAAe,CAAC,KAAK,CAAC,IAAK,eAAe,CAAC,KAAK,CAAqB,CAAC,mBAAmB,CAAC;QAC5F,IAAI,KAAK,IAAI,MAAM,CAAC,OAAO,IAAI,mBAAmB,EAAE;YAClD,aAAa,CAAC,KAAK,CAAC,GAAG,eAAe,CAAC,KAAK,CAAuC,CAAC;YACpF,eAAe,CAAC,KAAK,CAAC,GAAG,mBAA4C,CAAC;SACvE;IACH,CAAC,CAAC,CAAC;IAEH,IAAI;QACF,OAAO,QAAQ,EAAE,CAAC;KACnB;YAAS;QACR,sCAAsC;QACtC,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,OAAO,CAAC,UAAA,KAAK;YACtC,eAAe,CAAC,KAAK,CAAC,GAAG,aAAa,CAAC,KAAsC,CAAC,CAAC;QACjF,CAAC,CAAC,CAAC;KACJ;AACH,CAAC;AAED,SAAS,UAAU;IACjB,IAAI,OAAO,GAAG,KAAK,CAAC;IACpB,IAAM,MAAM,GAAoB;QAC9B,MAAM,EAAE;YACN,OAAO,GAAG,IAAI,CAAC;QACjB,CAAC;QACD,OAAO,EAAE;YACP,OAAO,GAAG,KAAK,CAAC;QAClB,CAAC;KACF,CAAC;IAEF,IAAI,cAAc,EAAE;QAClB,cAAc,CAAC,OAAO,CAAC,UAAA,IAAI;YACzB,8DAA8D;YAC9D,MAAM,CAAC,IAAI,CAAC,GAAG;gBAAC,cAAc;qBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;oBAAd,yBAAc;;gBAC5B,IAAI,OAAO,EAAE;oBACX,cAAc,CAAC;;wBACb,CAAA,KAAA,MAAM,CAAC,OAAO,CAAA,CAAC,IAAI,CAAC,qBAAI,MAAM,SAAI,IAAI,OAAI,GAAK,IAAI,GAAE;oBACvD,CAAC,CAAC,CAAC;iBACJ;YACH,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;KACJ;SAAM;QACL,cAAc,CAAC,OAAO,CAAC,UAAA,IAAI;YACzB,MAAM,CAAC,IAAI,CAAC,GAAG,cAAM,OAAA,SAAS,EAAT,CAAS,CAAC;QACjC,CAAC,CAAC,CAAC;KACJ;IAED,OAAO,MAAgB,CAAC;AAC1B,CAAC;AAED,0GAA0G;AAC1G,IAAI,MAAc,CAAC;AACnB,IAAI,cAAc,EAAE;IAClB,MAAM,GAAG,kBAAkB,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;CACnD;KAAM;IACL,MAAM,GAAG,UAAU,EAAE,CAAC;CACvB;AAED,OAAO,EAAE,MAAM,EAAE,CAAC","sourcesContent":["import { WrappedFunction } from '@sentry/types';\n\nimport { IS_DEBUG_BUILD } from './flags';\nimport { getGlobalObject, getGlobalSingleton } from './global';\n\n// TODO: Implement different loggers for different environments\nconst global = getGlobalObject<Window | NodeJS.Global>();\n\n/** Prefix for logging strings */\nconst PREFIX = 'Sentry Logger ';\n\nexport const CONSOLE_LEVELS = ['debug', 'info', 'warn', 'error', 'log', 'assert'] as const;\n\ntype LoggerMethod = (...args: unknown[]) => void;\ntype LoggerConsoleMethods = Record<typeof CONSOLE_LEVELS[number], LoggerMethod>;\n\n/** JSDoc */\ninterface Logger extends LoggerConsoleMethods {\n  disable(): void;\n  enable(): void;\n}\n\n/**\n * Temporarily disable sentry console instrumentations.\n *\n * @param callback The function to run against the original `console` messages\n * @returns The results of the callback\n */\nexport function consoleSandbox<T>(callback: () => T): T {\n  const global = getGlobalObject<Window>();\n\n  if (!('console' in global)) {\n    return callback();\n  }\n\n  const originalConsole = global.console as Console & Record<string, unknown>;\n  const wrappedLevels: Partial<LoggerConsoleMethods> = {};\n\n  // Restore all wrapped console methods\n  CONSOLE_LEVELS.forEach(level => {\n    // TODO(v7): Remove this check as it's only needed for Node 6\n    const originalWrappedFunc =\n      originalConsole[level] && (originalConsole[level] as WrappedFunction).__sentry_original__;\n    if (level in global.console && originalWrappedFunc) {\n      wrappedLevels[level] = originalConsole[level] as LoggerConsoleMethods[typeof level];\n      originalConsole[level] = originalWrappedFunc as Console[typeof level];\n    }\n  });\n\n  try {\n    return callback();\n  } finally {\n    // Revert restoration to wrapped state\n    Object.keys(wrappedLevels).forEach(level => {\n      originalConsole[level] = wrappedLevels[level as typeof CONSOLE_LEVELS[number]];\n    });\n  }\n}\n\nfunction makeLogger(): Logger {\n  let enabled = false;\n  const logger: Partial<Logger> = {\n    enable: () => {\n      enabled = true;\n    },\n    disable: () => {\n      enabled = false;\n    },\n  };\n\n  if (IS_DEBUG_BUILD) {\n    CONSOLE_LEVELS.forEach(name => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      logger[name] = (...args: any[]) => {\n        if (enabled) {\n          consoleSandbox(() => {\n            global.console[name](`${PREFIX}[${name}]:`, ...args);\n          });\n        }\n      };\n    });\n  } else {\n    CONSOLE_LEVELS.forEach(name => {\n      logger[name] = () => undefined;\n    });\n  }\n\n  return logger as Logger;\n}\n\n// Ensure we only have a single logger instance, even if multiple versions of @sentry/utils are being used\nlet logger: Logger;\nif (IS_DEBUG_BUILD) {\n  logger = getGlobalSingleton('logger', makeLogger);\n} else {\n  logger = makeLogger();\n}\n\nexport { logger };\n"]}export declare type MemoFunc = [(obj: any) => boolean, (obj: any) => void];
/**
 * Helper to decycle json objects
 */
export declare function memoBuilder(): MemoFunc;
//# sourceMappingURL=memo.d.ts.map{"version":3,"file":"memo.d.ts","sourceRoot":"","sources":["../../src/memo.ts"],"names":[],"mappings":"AAGA,oBAAY,QAAQ,GAAG,CAErB,CAAC,GAAG,EAAE,GAAG,KAAK,OAAO,EAErB,CAAC,GAAG,EAAE,GAAG,KAAK,IAAI,CACnB,CAAC;AAEF;;GAEG;AACH,wBAAgB,WAAW,IAAI,QAAQ,CAmCtC"}/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Helper to decycle json objects
 */
export function memoBuilder() {
    var hasWeakSet = typeof WeakSet === 'function';
    var inner = hasWeakSet ? new WeakSet() : [];
    function memoize(obj) {
        if (hasWeakSet) {
            if (inner.has(obj)) {
                return true;
            }
            inner.add(obj);
            return false;
        }
        // eslint-disable-next-line @typescript-eslint/prefer-for-of
        for (var i = 0; i < inner.length; i++) {
            var value = inner[i];
            if (value === obj) {
                return true;
            }
        }
        inner.push(obj);
        return false;
    }
    function unmemoize(obj) {
        if (hasWeakSet) {
            inner.delete(obj);
        }
        else {
            for (var i = 0; i < inner.length; i++) {
                if (inner[i] === obj) {
                    inner.splice(i, 1);
                    break;
                }
            }
        }
    }
    return [memoize, unmemoize];
}
//# sourceMappingURL=memo.js.map{"version":3,"file":"memo.js","sourceRoot":"","sources":["../../src/memo.ts"],"names":[],"mappings":"AAAA,+DAA+D;AAC/D,uDAAuD;AASvD;;GAEG;AACH,MAAM,UAAU,WAAW;IACzB,IAAM,UAAU,GAAG,OAAO,OAAO,KAAK,UAAU,CAAC;IACjD,IAAM,KAAK,GAAQ,UAAU,CAAC,CAAC,CAAC,IAAI,OAAO,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;IACnD,SAAS,OAAO,CAAC,GAAQ;QACvB,IAAI,UAAU,EAAE;YACd,IAAI,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;gBAClB,OAAO,IAAI,CAAC;aACb;YACD,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YACf,OAAO,KAAK,CAAC;SACd;QACD,4DAA4D;QAC5D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACrC,IAAM,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACvB,IAAI,KAAK,KAAK,GAAG,EAAE;gBACjB,OAAO,IAAI,CAAC;aACb;SACF;QACD,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAChB,OAAO,KAAK,CAAC;IACf,CAAC;IAED,SAAS,SAAS,CAAC,GAAQ;QACzB,IAAI,UAAU,EAAE;YACd,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;SACnB;aAAM;YACL,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACrC,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;oBACpB,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;oBACnB,MAAM;iBACP;aACF;SACF;IACH,CAAC;IACD,OAAO,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;AAC9B,CAAC","sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nexport type MemoFunc = [\n  // memoize\n  (obj: any) => boolean,\n  // unmemoize\n  (obj: any) => void,\n];\n\n/**\n * Helper to decycle json objects\n */\nexport function memoBuilder(): MemoFunc {\n  const hasWeakSet = typeof WeakSet === 'function';\n  const inner: any = hasWeakSet ? new WeakSet() : [];\n  function memoize(obj: any): boolean {\n    if (hasWeakSet) {\n      if (inner.has(obj)) {\n        return true;\n      }\n      inner.add(obj);\n      return false;\n    }\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < inner.length; i++) {\n      const value = inner[i];\n      if (value === obj) {\n        return true;\n      }\n    }\n    inner.push(obj);\n    return false;\n  }\n\n  function unmemoize(obj: any): void {\n    if (hasWeakSet) {\n      inner.delete(obj);\n    } else {\n      for (let i = 0; i < inner.length; i++) {\n        if (inner[i] === obj) {\n          inner.splice(i, 1);\n          break;\n        }\n      }\n    }\n  }\n  return [memoize, unmemoize];\n}\n"]}import { Event, Mechanism, StackFrame } from '@sentry/types';
/**
 * UUID4 generator
 *
 * @returns string Generated UUID4.
 */
export declare function uuid4(): string;
/**
 * Parses string form of URL into an object
 * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B
 * // intentionally using regex and not <a/> href parsing trick because React Native and other
 * // environments where DOM might not be available
 * @returns parsed URL object
 */
export declare function parseUrl(url: string): {
    host?: string;
    path?: string;
    protocol?: string;
    relative?: string;
};
/**
 * Extracts either message or type+value from an event that can be used for user-facing logs
 * @returns event's description
 */
export declare function getEventDescription(event: Event): string;
/**
 * Adds exception values, type and value to an synthetic Exception.
 * @param event The event to modify.
 * @param value Value of the exception.
 * @param type Type of the exception.
 * @hidden
 */
export declare function addExceptionTypeValue(event: Event, value?: string, type?: string): void;
/**
 * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.
 *
 * @param event The event to modify.
 * @param newMechanism Mechanism data to add to the event.
 * @hidden
 */
export declare function addExceptionMechanism(event: Event, newMechanism?: Partial<Mechanism>): void;
/**
 * Represents Semantic Versioning object
 */
interface SemVer {
    major?: number;
    minor?: number;
    patch?: number;
    prerelease?: string;
    buildmetadata?: string;
}
/**
 * Parses input into a SemVer interface
 * @param input string representation of a semver version
 */
export declare function parseSemver(input: string): SemVer;
/**
 * This function adds context (pre/post/line) lines to the provided frame
 *
 * @param lines string[] containing all lines
 * @param frame StackFrame that will be mutated
 * @param linesOfContext number of context lines we want to add pre/post
 */
export declare function addContextToFrame(lines: string[], frame: StackFrame, linesOfContext?: number): void;
/**
 * Strip the query string and fragment off of a given URL or path (if present)
 *
 * @param urlPath Full URL or path, including possible query string and/or fragment
 * @returns URL or path without query string or fragment
 */
export declare function stripUrlQueryAndFragment(urlPath: string): string;
/**
 * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object
 * in question), and marks it captured if not.
 *
 * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and
 * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so
 * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because
 * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not
 * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This
 * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we
 * see it.
 *
 * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on
 * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent
 * object wrapper forms so that this check will always work. However, because we need to flag the exact object which
 * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification
 * must be done before the exception captured.
 *
 * @param A thrown exception to check or flag as having been seen
 * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)
 */
export declare function checkOrSetAlreadyCaught(exception: unknown): boolean;
export {};
//# sourceMappingURL=misc.d.ts.map{"version":3,"file":"misc.d.ts","sourceRoot":"","sources":["../../src/misc.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAa,SAAS,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAaxE;;;;GAIG;AACH,wBAAgB,KAAK,IAAI,MAAM,CAoC9B;AAED;;;;;;GAMG;AACH,wBAAgB,QAAQ,CAAC,GAAG,EAAE,MAAM,GAAG;IACrC,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,QAAQ,CAAC,EAAE,MAAM,CAAC;CACnB,CAoBA;AAMD;;;GAGG;AACH,wBAAgB,mBAAmB,CAAC,KAAK,EAAE,KAAK,GAAG,MAAM,CAcxD;AAED;;;;;;GAMG;AACH,wBAAgB,qBAAqB,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE,MAAM,EAAE,IAAI,CAAC,EAAE,MAAM,GAAG,IAAI,CAUvF;AAED;;;;;;GAMG;AACH,wBAAgB,qBAAqB,CAAC,KAAK,EAAE,KAAK,EAAE,YAAY,CAAC,EAAE,OAAO,CAAC,SAAS,CAAC,GAAG,IAAI,CAc3F;AAMD;;GAEG;AACH,UAAU,MAAM;IACd,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,aAAa,CAAC,EAAE,MAAM,CAAC;CACxB;AAED;;;GAGG;AACH,wBAAgB,WAAW,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,CAYjD;AAED;;;;;;GAMG;AACH,wBAAgB,iBAAiB,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,KAAK,EAAE,UAAU,EAAE,cAAc,GAAE,MAAU,GAAG,IAAI,CActG;AAED;;;;;GAKG;AACH,wBAAgB,wBAAwB,CAAC,OAAO,EAAE,MAAM,GAAG,MAAM,CAGhE;AAED;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,wBAAgB,uBAAuB,CAAC,SAAS,EAAE,OAAO,GAAG,OAAO,CAenE"}import { __assign } from "tslib";
import { getGlobalObject } from './global';
import { addNonEnumerableProperty } from './object';
import { snipLine } from './string';
/**
 * UUID4 generator
 *
 * @returns string Generated UUID4.
 */
export function uuid4() {
    var global = getGlobalObject();
    var crypto = global.crypto || global.msCrypto;
    if (!(crypto === void 0) && crypto.getRandomValues) {
        // Use window.crypto API if available
        var arr = new Uint16Array(8);
        crypto.getRandomValues(arr);
        // set 4 in byte 7
        // eslint-disable-next-line no-bitwise
        arr[3] = (arr[3] & 0xfff) | 0x4000;
        // set 2 most significant bits of byte 9 to '10'
        // eslint-disable-next-line no-bitwise
        arr[4] = (arr[4] & 0x3fff) | 0x8000;
        var pad = function (num) {
            var v = num.toString(16);
            while (v.length < 4) {
                v = "0" + v;
            }
            return v;
        };
        return (pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]));
    }
    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
    return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        // eslint-disable-next-line no-bitwise
        var r = (Math.random() * 16) | 0;
        // eslint-disable-next-line no-bitwise
        var v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}
/**
 * Parses string form of URL into an object
 * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B
 * // intentionally using regex and not <a/> href parsing trick because React Native and other
 * // environments where DOM might not be available
 * @returns parsed URL object
 */
export function parseUrl(url) {
    if (!url) {
        return {};
    }
    var match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
    if (!match) {
        return {};
    }
    // coerce to undefined values to empty string so we don't get 'undefined'
    var query = match[6] || '';
    var fragment = match[8] || '';
    return {
        host: match[4],
        path: match[5],
        protocol: match[2],
        relative: match[5] + query + fragment,
    };
}
function getFirstException(event) {
    return event.exception && event.exception.values ? event.exception.values[0] : undefined;
}
/**
 * Extracts either message or type+value from an event that can be used for user-facing logs
 * @returns event's description
 */
export function getEventDescription(event) {
    var message = event.message, eventId = event.event_id;
    if (message) {
        return message;
    }
    var firstException = getFirstException(event);
    if (firstException) {
        if (firstException.type && firstException.value) {
            return firstException.type + ": " + firstException.value;
        }
        return firstException.type || firstException.value || eventId || '<unknown>';
    }
    return eventId || '<unknown>';
}
/**
 * Adds exception values, type and value to an synthetic Exception.
 * @param event The event to modify.
 * @param value Value of the exception.
 * @param type Type of the exception.
 * @hidden
 */
export function addExceptionTypeValue(event, value, type) {
    var exception = (event.exception = event.exception || {});
    var values = (exception.values = exception.values || []);
    var firstException = (values[0] = values[0] || {});
    if (!firstException.value) {
        firstException.value = value || '';
    }
    if (!firstException.type) {
        firstException.type = type || 'Error';
    }
}
/**
 * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.
 *
 * @param event The event to modify.
 * @param newMechanism Mechanism data to add to the event.
 * @hidden
 */
export function addExceptionMechanism(event, newMechanism) {
    var firstException = getFirstException(event);
    if (!firstException) {
        return;
    }
    var defaultMechanism = { type: 'generic', handled: true };
    var currentMechanism = firstException.mechanism;
    firstException.mechanism = __assign(__assign(__assign({}, defaultMechanism), currentMechanism), newMechanism);
    if (newMechanism && 'data' in newMechanism) {
        var mergedData = __assign(__assign({}, (currentMechanism && currentMechanism.data)), newMechanism.data);
        firstException.mechanism.data = mergedData;
    }
}
// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string
var SEMVER_REGEXP = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
/**
 * Parses input into a SemVer interface
 * @param input string representation of a semver version
 */
export function parseSemver(input) {
    var match = input.match(SEMVER_REGEXP) || [];
    var major = parseInt(match[1], 10);
    var minor = parseInt(match[2], 10);
    var patch = parseInt(match[3], 10);
    return {
        buildmetadata: match[5],
        major: isNaN(major) ? undefined : major,
        minor: isNaN(minor) ? undefined : minor,
        patch: isNaN(patch) ? undefined : patch,
        prerelease: match[4],
    };
}
/**
 * This function adds context (pre/post/line) lines to the provided frame
 *
 * @param lines string[] containing all lines
 * @param frame StackFrame that will be mutated
 * @param linesOfContext number of context lines we want to add pre/post
 */
export function addContextToFrame(lines, frame, linesOfContext) {
    if (linesOfContext === void 0) { linesOfContext = 5; }
    var lineno = frame.lineno || 0;
    var maxLines = lines.length;
    var sourceLine = Math.max(Math.min(maxLines, lineno - 1), 0);
    frame.pre_context = lines
        .slice(Math.max(0, sourceLine - linesOfContext), sourceLine)
        .map(function (line) { return snipLine(line, 0); });
    frame.context_line = snipLine(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);
    frame.post_context = lines
        .slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext)
        .map(function (line) { return snipLine(line, 0); });
}
/**
 * Strip the query string and fragment off of a given URL or path (if present)
 *
 * @param urlPath Full URL or path, including possible query string and/or fragment
 * @returns URL or path without query string or fragment
 */
export function stripUrlQueryAndFragment(urlPath) {
    // eslint-disable-next-line no-useless-escape
    return urlPath.split(/[\?#]/, 1)[0];
}
/**
 * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object
 * in question), and marks it captured if not.
 *
 * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and
 * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so
 * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because
 * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not
 * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This
 * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we
 * see it.
 *
 * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on
 * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent
 * object wrapper forms so that this check will always work. However, because we need to flag the exact object which
 * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification
 * must be done before the exception captured.
 *
 * @param A thrown exception to check or flag as having been seen
 * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)
 */
export function checkOrSetAlreadyCaught(exception) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    if (exception && exception.__sentry_captured__) {
        return true;
    }
    try {
        // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the
        // `ExtraErrorData` integration
        addNonEnumerableProperty(exception, '__sentry_captured__', true);
    }
    catch (err) {
        // `exception` is a primitive, so we can't mark it seen
    }
    return false;
}
//# sourceMappingURL=misc.js.map{"version":3,"file":"misc.js","sourceRoot":"","sources":["../../src/misc.ts"],"names":[],"mappings":";AAGA,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAC3C,OAAO,EAAE,wBAAwB,EAAE,MAAM,UAAU,CAAC;AACpD,OAAO,EAAE,QAAQ,EAAE,MAAM,UAAU,CAAC;AASpC;;;;GAIG;AACH,MAAM,UAAU,KAAK;IACnB,IAAM,MAAM,GAAG,eAAe,EAAoB,CAAC;IACnD,IAAM,MAAM,GAAG,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,QAAQ,CAAC;IAEhD,IAAI,CAAC,CAAC,MAAM,KAAK,KAAK,CAAC,CAAC,IAAI,MAAM,CAAC,eAAe,EAAE;QAClD,qCAAqC;QACrC,IAAM,GAAG,GAAG,IAAI,WAAW,CAAC,CAAC,CAAC,CAAC;QAC/B,MAAM,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC;QAE5B,kBAAkB;QAClB,sCAAsC;QACtC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,MAAM,CAAC;QACnC,gDAAgD;QAChD,sCAAsC;QACtC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,GAAG,MAAM,CAAC;QAEpC,IAAM,GAAG,GAAG,UAAC,GAAW;YACtB,IAAI,CAAC,GAAG,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;YACzB,OAAO,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;gBACnB,CAAC,GAAG,MAAI,CAAG,CAAC;aACb;YACD,OAAO,CAAC,CAAC;QACX,CAAC,CAAC;QAEF,OAAO,CACL,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAC9G,CAAC;KACH;IACD,oGAAoG;IACpG,OAAO,kCAAkC,CAAC,OAAO,CAAC,OAAO,EAAE,UAAA,CAAC;QAC1D,sCAAsC;QACtC,IAAM,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC;QACnC,sCAAsC;QACtC,IAAM,CAAC,GAAG,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC;QAC1C,OAAO,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;IACxB,CAAC,CAAC,CAAC;AACL,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,QAAQ,CAAC,GAAW;IAMlC,IAAI,CAAC,GAAG,EAAE;QACR,OAAO,EAAE,CAAC;KACX;IAED,IAAM,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,8DAA8D,CAAC,CAAC;IAExF,IAAI,CAAC,KAAK,EAAE;QACV,OAAO,EAAE,CAAC;KACX;IAED,yEAAyE;IACzE,IAAM,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;IAC7B,IAAM,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;IAChC,OAAO;QACL,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;QACd,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;QACd,QAAQ,EAAE,KAAK,CAAC,CAAC,CAAC;QAClB,QAAQ,EAAE,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,GAAG,QAAQ;KACtC,CAAC;AACJ,CAAC;AAED,SAAS,iBAAiB,CAAC,KAAY;IACrC,OAAO,KAAK,CAAC,SAAS,IAAI,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;AAC3F,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,mBAAmB,CAAC,KAAY;IACtC,IAAA,uBAAO,EAAE,wBAAiB,CAAW;IAC7C,IAAI,OAAO,EAAE;QACX,OAAO,OAAO,CAAC;KAChB;IAED,IAAM,cAAc,GAAG,iBAAiB,CAAC,KAAK,CAAC,CAAC;IAChD,IAAI,cAAc,EAAE;QAClB,IAAI,cAAc,CAAC,IAAI,IAAI,cAAc,CAAC,KAAK,EAAE;YAC/C,OAAU,cAAc,CAAC,IAAI,UAAK,cAAc,CAAC,KAAO,CAAC;SAC1D;QACD,OAAO,cAAc,CAAC,IAAI,IAAI,cAAc,CAAC,KAAK,IAAI,OAAO,IAAI,WAAW,CAAC;KAC9E;IACD,OAAO,OAAO,IAAI,WAAW,CAAC;AAChC,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,qBAAqB,CAAC,KAAY,EAAE,KAAc,EAAE,IAAa;IAC/E,IAAM,SAAS,GAAG,CAAC,KAAK,CAAC,SAAS,GAAG,KAAK,CAAC,SAAS,IAAI,EAAE,CAAC,CAAC;IAC5D,IAAM,MAAM,GAAG,CAAC,SAAS,CAAC,MAAM,GAAG,SAAS,CAAC,MAAM,IAAI,EAAE,CAAC,CAAC;IAC3D,IAAM,cAAc,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC;IACrD,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE;QACzB,cAAc,CAAC,KAAK,GAAG,KAAK,IAAI,EAAE,CAAC;KACpC;IACD,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE;QACxB,cAAc,CAAC,IAAI,GAAG,IAAI,IAAI,OAAO,CAAC;KACvC;AACH,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,qBAAqB,CAAC,KAAY,EAAE,YAAiC;IACnF,IAAM,cAAc,GAAG,iBAAiB,CAAC,KAAK,CAAC,CAAC;IAChD,IAAI,CAAC,cAAc,EAAE;QACnB,OAAO;KACR;IAED,IAAM,gBAAgB,GAAG,EAAE,IAAI,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC;IAC5D,IAAM,gBAAgB,GAAG,cAAc,CAAC,SAAS,CAAC;IAClD,cAAc,CAAC,SAAS,kCAAQ,gBAAgB,GAAK,gBAAgB,GAAK,YAAY,CAAE,CAAC;IAEzF,IAAI,YAAY,IAAI,MAAM,IAAI,YAAY,EAAE;QAC1C,IAAM,UAAU,yBAAQ,CAAC,gBAAgB,IAAI,gBAAgB,CAAC,IAAI,CAAC,GAAK,YAAY,CAAC,IAAI,CAAE,CAAC;QAC5F,cAAc,CAAC,SAAS,CAAC,IAAI,GAAG,UAAU,CAAC;KAC5C;AACH,CAAC;AAED,6FAA6F;AAC7F,IAAM,aAAa,GACjB,qLAAqL,CAAC;AAaxL;;;GAGG;AACH,MAAM,UAAU,WAAW,CAAC,KAAa;IACvC,IAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC;IAC/C,IAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IACrC,IAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IACrC,IAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IACrC,OAAO;QACL,aAAa,EAAE,KAAK,CAAC,CAAC,CAAC;QACvB,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK;QACvC,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK;QACvC,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK;QACvC,UAAU,EAAE,KAAK,CAAC,CAAC,CAAC;KACrB,CAAC;AACJ,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,iBAAiB,CAAC,KAAe,EAAE,KAAiB,EAAE,cAA0B;IAA1B,+BAAA,EAAA,kBAA0B;IAC9F,IAAM,MAAM,GAAG,KAAK,CAAC,MAAM,IAAI,CAAC,CAAC;IACjC,IAAM,QAAQ,GAAG,KAAK,CAAC,MAAM,CAAC;IAC9B,IAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAE/D,KAAK,CAAC,WAAW,GAAG,KAAK;SACtB,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,UAAU,GAAG,cAAc,CAAC,EAAE,UAAU,CAAC;SAC3D,GAAG,CAAC,UAAC,IAAY,IAAK,OAAA,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC,EAAjB,CAAiB,CAAC,CAAC;IAE5C,KAAK,CAAC,YAAY,GAAG,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,GAAG,CAAC,EAAE,UAAU,CAAC,CAAC,EAAE,KAAK,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC;IAE3F,KAAK,CAAC,YAAY,GAAG,KAAK;SACvB,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,GAAG,CAAC,EAAE,QAAQ,CAAC,EAAE,UAAU,GAAG,CAAC,GAAG,cAAc,CAAC;SAC1E,GAAG,CAAC,UAAC,IAAY,IAAK,OAAA,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC,EAAjB,CAAiB,CAAC,CAAC;AAC9C,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,wBAAwB,CAAC,OAAe;IACtD,6CAA6C;IAC7C,OAAO,OAAO,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC,CAAC;AAED;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,MAAM,UAAU,uBAAuB,CAAC,SAAkB;IACxD,sEAAsE;IACtE,IAAI,SAAS,IAAK,SAAiB,CAAC,mBAAmB,EAAE;QACvD,OAAO,IAAI,CAAC;KACb;IAED,IAAI;QACF,6GAA6G;QAC7G,+BAA+B;QAC/B,wBAAwB,CAAC,SAAuC,EAAE,qBAAqB,EAAE,IAAI,CAAC,CAAC;KAChG;IAAC,OAAO,GAAG,EAAE;QACZ,uDAAuD;KACxD;IAED,OAAO,KAAK,CAAC;AACf,CAAC","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Event, Exception, Mechanism, StackFrame } from '@sentry/types';\n\nimport { getGlobalObject } from './global';\nimport { addNonEnumerableProperty } from './object';\nimport { snipLine } from './string';\n\n/**\n * Extended Window interface that allows for Crypto API usage in IE browsers\n */\ninterface MsCryptoWindow extends Window {\n  msCrypto?: Crypto;\n}\n\n/**\n * UUID4 generator\n *\n * @returns string Generated UUID4.\n */\nexport function uuid4(): string {\n  const global = getGlobalObject() as MsCryptoWindow;\n  const crypto = global.crypto || global.msCrypto;\n\n  if (!(crypto === void 0) && crypto.getRandomValues) {\n    // Use window.crypto API if available\n    const arr = new Uint16Array(8);\n    crypto.getRandomValues(arr);\n\n    // set 4 in byte 7\n    // eslint-disable-next-line no-bitwise\n    arr[3] = (arr[3] & 0xfff) | 0x4000;\n    // set 2 most significant bits of byte 9 to '10'\n    // eslint-disable-next-line no-bitwise\n    arr[4] = (arr[4] & 0x3fff) | 0x8000;\n\n    const pad = (num: number): string => {\n      let v = num.toString(16);\n      while (v.length < 4) {\n        v = `0${v}`;\n      }\n      return v;\n    };\n\n    return (\n      pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7])\n    );\n  }\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n  return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    // eslint-disable-next-line no-bitwise\n    const r = (Math.random() * 16) | 0;\n    // eslint-disable-next-line no-bitwise\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\n/**\n * Parses string form of URL into an object\n * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B\n * // intentionally using regex and not <a/> href parsing trick because React Native and other\n * // environments where DOM might not be available\n * @returns parsed URL object\n */\nexport function parseUrl(url: string): {\n  host?: string;\n  path?: string;\n  protocol?: string;\n  relative?: string;\n} {\n  if (!url) {\n    return {};\n  }\n\n  const match = url.match(/^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/);\n\n  if (!match) {\n    return {};\n  }\n\n  // coerce to undefined values to empty string so we don't get 'undefined'\n  const query = match[6] || '';\n  const fragment = match[8] || '';\n  return {\n    host: match[4],\n    path: match[5],\n    protocol: match[2],\n    relative: match[5] + query + fragment, // everything minus origin\n  };\n}\n\nfunction getFirstException(event: Event): Exception | undefined {\n  return event.exception && event.exception.values ? event.exception.values[0] : undefined;\n}\n\n/**\n * Extracts either message or type+value from an event that can be used for user-facing logs\n * @returns event's description\n */\nexport function getEventDescription(event: Event): string {\n  const { message, event_id: eventId } = event;\n  if (message) {\n    return message;\n  }\n\n  const firstException = getFirstException(event);\n  if (firstException) {\n    if (firstException.type && firstException.value) {\n      return `${firstException.type}: ${firstException.value}`;\n    }\n    return firstException.type || firstException.value || eventId || '<unknown>';\n  }\n  return eventId || '<unknown>';\n}\n\n/**\n * Adds exception values, type and value to an synthetic Exception.\n * @param event The event to modify.\n * @param value Value of the exception.\n * @param type Type of the exception.\n * @hidden\n */\nexport function addExceptionTypeValue(event: Event, value?: string, type?: string): void {\n  const exception = (event.exception = event.exception || {});\n  const values = (exception.values = exception.values || []);\n  const firstException = (values[0] = values[0] || {});\n  if (!firstException.value) {\n    firstException.value = value || '';\n  }\n  if (!firstException.type) {\n    firstException.type = type || 'Error';\n  }\n}\n\n/**\n * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.\n *\n * @param event The event to modify.\n * @param newMechanism Mechanism data to add to the event.\n * @hidden\n */\nexport function addExceptionMechanism(event: Event, newMechanism?: Partial<Mechanism>): void {\n  const firstException = getFirstException(event);\n  if (!firstException) {\n    return;\n  }\n\n  const defaultMechanism = { type: 'generic', handled: true };\n  const currentMechanism = firstException.mechanism;\n  firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };\n\n  if (newMechanism && 'data' in newMechanism) {\n    const mergedData = { ...(currentMechanism && currentMechanism.data), ...newMechanism.data };\n    firstException.mechanism.data = mergedData;\n  }\n}\n\n// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\nconst SEMVER_REGEXP =\n  /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/;\n\n/**\n * Represents Semantic Versioning object\n */\ninterface SemVer {\n  major?: number;\n  minor?: number;\n  patch?: number;\n  prerelease?: string;\n  buildmetadata?: string;\n}\n\n/**\n * Parses input into a SemVer interface\n * @param input string representation of a semver version\n */\nexport function parseSemver(input: string): SemVer {\n  const match = input.match(SEMVER_REGEXP) || [];\n  const major = parseInt(match[1], 10);\n  const minor = parseInt(match[2], 10);\n  const patch = parseInt(match[3], 10);\n  return {\n    buildmetadata: match[5],\n    major: isNaN(major) ? undefined : major,\n    minor: isNaN(minor) ? undefined : minor,\n    patch: isNaN(patch) ? undefined : patch,\n    prerelease: match[4],\n  };\n}\n\n/**\n * This function adds context (pre/post/line) lines to the provided frame\n *\n * @param lines string[] containing all lines\n * @param frame StackFrame that will be mutated\n * @param linesOfContext number of context lines we want to add pre/post\n */\nexport function addContextToFrame(lines: string[], frame: StackFrame, linesOfContext: number = 5): void {\n  const lineno = frame.lineno || 0;\n  const maxLines = lines.length;\n  const sourceLine = Math.max(Math.min(maxLines, lineno - 1), 0);\n\n  frame.pre_context = lines\n    .slice(Math.max(0, sourceLine - linesOfContext), sourceLine)\n    .map((line: string) => snipLine(line, 0));\n\n  frame.context_line = snipLine(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);\n\n  frame.post_context = lines\n    .slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext)\n    .map((line: string) => snipLine(line, 0));\n}\n\n/**\n * Strip the query string and fragment off of a given URL or path (if present)\n *\n * @param urlPath Full URL or path, including possible query string and/or fragment\n * @returns URL or path without query string or fragment\n */\nexport function stripUrlQueryAndFragment(urlPath: string): string {\n  // eslint-disable-next-line no-useless-escape\n  return urlPath.split(/[\\?#]/, 1)[0];\n}\n\n/**\n * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object\n * in question), and marks it captured if not.\n *\n * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and\n * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so\n * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because\n * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not\n * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This\n * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we\n * see it.\n *\n * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on\n * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent\n * object wrapper forms so that this check will always work. However, because we need to flag the exact object which\n * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification\n * must be done before the exception captured.\n *\n * @param A thrown exception to check or flag as having been seen\n * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)\n */\nexport function checkOrSetAlreadyCaught(exception: unknown): boolean {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  if (exception && (exception as any).__sentry_captured__) {\n    return true;\n  }\n\n  try {\n    // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the\n    // `ExtraErrorData` integration\n    addNonEnumerableProperty(exception as { [key: string]: unknown }, '__sentry_captured__', true);\n  } catch (err) {\n    // `exception` is a primitive, so we can't mark it seen\n  }\n\n  return false;\n}\n"]}/**
 * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
 * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
 */
/**
 * Checks whether we're in the Node.js or Browser environment
 *
 * @returns Answer to given question
 */
export declare function isNodeEnv(): boolean;
/**
 * Requires a module which is protected against bundler minification.
 *
 * @param request The module path to resolve
 */
export declare function dynamicRequire(mod: any, request: string): any;
/**
 * Helper for dynamically loading module that should work with linked dependencies.
 * The problem is that we _should_ be using `require(require.resolve(moduleName, { paths: [cwd()] }))`
 * However it's _not possible_ to do that with Webpack, as it has to know all the dependencies during
 * build time. `require.resolve` is also not available in any other way, so we cannot create,
 * a fake helper like we do with `dynamicRequire`.
 *
 * We always prefer to use local package, thus the value is not returned early from each `try/catch` block.
 * That is to mimic the behavior of `require.resolve` exactly.
 *
 * @param moduleName module name to require
 * @returns possibly required module
 */
export declare function loadModule<T>(moduleName: string): T | undefined;
//# sourceMappingURL=node.d.ts.map{"version":3,"file":"node.d.ts","sourceRoot":"","sources":["../../src/node.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAIH;;;;GAIG;AACH,wBAAgB,SAAS,IAAI,OAAO,CAOnC;AAED;;;;GAIG;AAEH,wBAAgB,cAAc,CAAC,GAAG,EAAE,GAAG,EAAE,OAAO,EAAE,MAAM,GAAG,GAAG,CAG7D;AAED;;;;;;;;;;;;GAYG;AACH,wBAAgB,UAAU,CAAC,CAAC,EAAE,UAAU,EAAE,MAAM,GAAG,CAAC,GAAG,SAAS,CAiB/D"}/**
 * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
 * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
 */
import { isBrowserBundle } from './env';
/**
 * Checks whether we're in the Node.js or Browser environment
 *
 * @returns Answer to given question
 */
export function isNodeEnv() {
    // explicitly check for browser bundles as those can be optimized statically
    // by terser/rollup.
    return (!isBrowserBundle() &&
        Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]');
}
/**
 * Requires a module which is protected against bundler minification.
 *
 * @param request The module path to resolve
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
export function dynamicRequire(mod, request) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    return mod.require(request);
}
/**
 * Helper for dynamically loading module that should work with linked dependencies.
 * The problem is that we _should_ be using `require(require.resolve(moduleName, { paths: [cwd()] }))`
 * However it's _not possible_ to do that with Webpack, as it has to know all the dependencies during
 * build time. `require.resolve` is also not available in any other way, so we cannot create,
 * a fake helper like we do with `dynamicRequire`.
 *
 * We always prefer to use local package, thus the value is not returned early from each `try/catch` block.
 * That is to mimic the behavior of `require.resolve` exactly.
 *
 * @param moduleName module name to require
 * @returns possibly required module
 */
export function loadModule(moduleName) {
    var mod;
    try {
        mod = dynamicRequire(module, moduleName);
    }
    catch (e) {
        // no-empty
    }
    try {
        var cwd = dynamicRequire(module, 'process').cwd;
        mod = dynamicRequire(module, cwd() + "/node_modules/" + moduleName);
    }
    catch (e) {
        // no-empty
    }
    return mod;
}
//# sourceMappingURL=node.js.map{"version":3,"file":"node.js","sourceRoot":"","sources":["../../src/node.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,EAAE,eAAe,EAAE,MAAM,OAAO,CAAC;AAExC;;;;GAIG;AACH,MAAM,UAAU,SAAS;IACvB,4EAA4E;IAC5E,oBAAoB;IACpB,OAAO,CACL,CAAC,eAAe,EAAE;QAClB,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,OAAO,KAAK,WAAW,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,kBAAkB,CACpG,CAAC;AACJ,CAAC;AAED;;;;GAIG;AACH,iHAAiH;AACjH,MAAM,UAAU,cAAc,CAAC,GAAQ,EAAE,OAAe;IACtD,sEAAsE;IACtE,OAAO,GAAG,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;AAC9B,CAAC;AAED;;;;;;;;;;;;GAYG;AACH,MAAM,UAAU,UAAU,CAAI,UAAkB;IAC9C,IAAI,GAAkB,CAAC;IAEvB,IAAI;QACF,GAAG,GAAG,cAAc,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;KAC1C;IAAC,OAAO,CAAC,EAAE;QACV,WAAW;KACZ;IAED,IAAI;QACM,IAAA,2CAAG,CAAuC;QAClD,GAAG,GAAG,cAAc,CAAC,MAAM,EAAK,GAAG,EAAE,sBAAiB,UAAY,CAAM,CAAC;KAC1E;IAAC,OAAO,CAAC,EAAE;QACV,WAAW;KACZ;IAED,OAAO,GAAG,CAAC;AACb,CAAC","sourcesContent":["/**\n * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,\n * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.\n */\n\nimport { isBrowserBundle } from './env';\n\n/**\n * Checks whether we're in the Node.js or Browser environment\n *\n * @returns Answer to given question\n */\nexport function isNodeEnv(): boolean {\n  // explicitly check for browser bundles as those can be optimized statically\n  // by terser/rollup.\n  return (\n    !isBrowserBundle() &&\n    Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]'\n  );\n}\n\n/**\n * Requires a module which is protected against bundler minification.\n *\n * @param request The module path to resolve\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\nexport function dynamicRequire(mod: any, request: string): any {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return mod.require(request);\n}\n\n/**\n * Helper for dynamically loading module that should work with linked dependencies.\n * The problem is that we _should_ be using `require(require.resolve(moduleName, { paths: [cwd()] }))`\n * However it's _not possible_ to do that with Webpack, as it has to know all the dependencies during\n * build time. `require.resolve` is also not available in any other way, so we cannot create,\n * a fake helper like we do with `dynamicRequire`.\n *\n * We always prefer to use local package, thus the value is not returned early from each `try/catch` block.\n * That is to mimic the behavior of `require.resolve` exactly.\n *\n * @param moduleName module name to require\n * @returns possibly required module\n */\nexport function loadModule<T>(moduleName: string): T | undefined {\n  let mod: T | undefined;\n\n  try {\n    mod = dynamicRequire(module, moduleName);\n  } catch (e) {\n    // no-empty\n  }\n\n  try {\n    const { cwd } = dynamicRequire(module, 'process');\n    mod = dynamicRequire(module, `${cwd()}/node_modules/${moduleName}`) as T;\n  } catch (e) {\n    // no-empty\n  }\n\n  return mod;\n}\n"]}import { Primitive } from '@sentry/types';
import { MemoFunc } from './memo';
declare type ObjOrArray<T> = {
    [key: string]: T;
};
/**
 * Recursively normalizes the given object.
 *
 * - Creates a copy to prevent original input mutation
 * - Skips non-enumerable properties
 * - When stringifying, calls `toJSON` if implemented
 * - Removes circular references
 * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format
 * - Translates known global objects/classes to a string representations
 * - Takes care of `Error` object serialization
 * - Optionally limits depth of final output
 * - Optionally limits number of properties/elements included in any single object/array
 *
 * @param input The object to be normalized.
 * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)
 * @param maxProperties The max number of elements or properties to be included in any single array or
 * object in the normallized output..
 * @returns A normalized version of the object, or `"**non-serializable**"` if any errors are thrown during normalization.
 */
export declare function normalize(input: unknown, depth?: number, maxProperties?: number): any;
/** JSDoc */
export declare function normalizeToSize<T>(object: {
    [key: string]: any;
}, depth?: number, maxSize?: number): T;
/**
 * Visits a node to perform normalization on it
 *
 * @param key The key corresponding to the given node
 * @param value The node to be visited
 * @param depth Optional number indicating the maximum recursion depth
 * @param maxProperties Optional maximum number of properties/elements included in any single object/array
 * @param memo Optional Memo class handling decycling
 */
declare function visit(key: string, value: unknown, depth?: number, maxProperties?: number, memo?: MemoFunc): Primitive | ObjOrArray<unknown>;
export { visit as walk };
//# sourceMappingURL=normalize.d.ts.map{"version":3,"file":"normalize.d.ts","sourceRoot":"","sources":["../../src/normalize.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAG1C,OAAO,EAAe,QAAQ,EAAE,MAAM,QAAQ,CAAC;AAS/C,aAAK,UAAU,CAAC,CAAC,IAAI;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,CAAC,CAAA;CAAE,CAAC;AAE1C;;;;;;;;;;;;;;;;;;GAkBG;AACH,wBAAgB,SAAS,CAAC,KAAK,EAAE,OAAO,EAAE,KAAK,GAAE,MAAkB,EAAE,aAAa,GAAE,MAAkB,GAAG,GAAG,CAO3G;AAED,YAAY;AACZ,wBAAgB,eAAe,CAAC,CAAC,EAC/B,MAAM,EAAE;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;CAAE,EAE9B,KAAK,GAAE,MAAU,EAEjB,OAAO,GAAE,MAAmB,GAC3B,CAAC,CAQH;AAED;;;;;;;;GAQG;AACH,iBAAS,KAAK,CACZ,GAAG,EAAE,MAAM,EACX,KAAK,EAAE,OAAO,EACd,KAAK,GAAE,MAAkB,EACzB,aAAa,GAAE,MAAkB,EACjC,IAAI,GAAE,QAAwB,GAC7B,SAAS,GAAG,UAAU,CAAC,OAAO,CAAC,CAsEjC;AAGD,OAAO,EAAE,KAAK,IAAI,IAAI,EAAE,CAAC"}import { __read } from "tslib";
import { isError, isEvent, isNaN, isSyntheticEvent } from './is';
import { memoBuilder } from './memo';
import { convertToPlainObject } from './object';
import { getFunctionName } from './stacktrace';
/**
 * Recursively normalizes the given object.
 *
 * - Creates a copy to prevent original input mutation
 * - Skips non-enumerable properties
 * - When stringifying, calls `toJSON` if implemented
 * - Removes circular references
 * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format
 * - Translates known global objects/classes to a string representations
 * - Takes care of `Error` object serialization
 * - Optionally limits depth of final output
 * - Optionally limits number of properties/elements included in any single object/array
 *
 * @param input The object to be normalized.
 * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)
 * @param maxProperties The max number of elements or properties to be included in any single array or
 * object in the normallized output..
 * @returns A normalized version of the object, or `"**non-serializable**"` if any errors are thrown during normalization.
 */
export function normalize(input, depth, maxProperties) {
    if (depth === void 0) { depth = +Infinity; }
    if (maxProperties === void 0) { maxProperties = +Infinity; }
    try {
        // since we're at the outermost level, there is no key
        return visit('', input, depth, maxProperties);
    }
    catch (err) {
        return { ERROR: "**non-serializable** (" + err + ")" };
    }
}
/** JSDoc */
export function normalizeToSize(object, 
// Default Node.js REPL depth
depth, 
// 100kB, as 200kB is max payload size, so half sounds reasonable
maxSize) {
    if (depth === void 0) { depth = 3; }
    if (maxSize === void 0) { maxSize = 100 * 1024; }
    var normalized = normalize(object, depth);
    if (jsonSize(normalized) > maxSize) {
        return normalizeToSize(object, depth - 1, maxSize);
    }
    return normalized;
}
/**
 * Visits a node to perform normalization on it
 *
 * @param key The key corresponding to the given node
 * @param value The node to be visited
 * @param depth Optional number indicating the maximum recursion depth
 * @param maxProperties Optional maximum number of properties/elements included in any single object/array
 * @param memo Optional Memo class handling decycling
 */
function visit(key, value, depth, maxProperties, memo) {
    if (depth === void 0) { depth = +Infinity; }
    if (maxProperties === void 0) { maxProperties = +Infinity; }
    if (memo === void 0) { memo = memoBuilder(); }
    var _a = __read(memo, 2), memoize = _a[0], unmemoize = _a[1];
    // If the value has a `toJSON` method, see if we can bail and let it do the work
    var valueWithToJSON = value;
    if (valueWithToJSON && typeof valueWithToJSON.toJSON === 'function') {
        try {
            return valueWithToJSON.toJSON();
        }
        catch (err) {
            // pass (The built-in `toJSON` failed, but we can still try to do it ourselves)
        }
    }
    // Get the simple cases out of the way first
    if (value === null || (['number', 'boolean', 'string'].includes(typeof value) && !isNaN(value))) {
        return value;
    }
    var stringified = stringifyValue(key, value);
    // Anything we could potentially dig into more (objects or arrays) will have come back as `"[object XXXX]"`.
    // Everything else will have already been serialized, so if we don't see that pattern, we're done.
    if (!stringified.startsWith('[object ')) {
        return stringified;
    }
    // We're also done if we've reached the max depth
    if (depth === 0) {
        // At this point we know `serialized` is a string of the form `"[object XXXX]"`. Clean it up so it's just `"[XXXX]"`.
        return stringified.replace('object ', '');
    }
    // If we've already visited this branch, bail out, as it's circular reference. If not, note that we're seeing it now.
    if (memoize(value)) {
        return '[Circular ~]';
    }
    // At this point we know we either have an object or an array, we haven't seen it before, and we're going to recurse
    // because we haven't yet reached the max depth. Create an accumulator to hold the results of visiting each
    // property/entry, and keep track of the number of items we add to it.
    var normalized = (Array.isArray(value) ? [] : {});
    var numAdded = 0;
    // Before we begin, convert`Error` and`Event` instances into plain objects, since some of each of their relevant
    // properties are non-enumerable and otherwise would get missed.
    var visitable = (isError(value) || isEvent(value) ? convertToPlainObject(value) : value);
    for (var visitKey in visitable) {
        // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.
        if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
            continue;
        }
        if (numAdded >= maxProperties) {
            normalized[visitKey] = '[MaxProperties ~]';
            break;
        }
        // Recursively visit all the child nodes
        var visitValue = visitable[visitKey];
        normalized[visitKey] = visit(visitKey, visitValue, depth - 1, maxProperties, memo);
        numAdded += 1;
    }
    // Once we've visited all the branches, remove the parent from memo storage
    unmemoize(value);
    // Return accumulated values
    return normalized;
}
// TODO remove this in v7 (this means the method will no longer be exported, under any name)
export { visit as walk };
/**
 * Stringify the given value. Handles various known special values and types.
 *
 * Not meant to be used on simple primitives which already have a string representation, as it will, for example, turn
 * the number 1231 into "[Object Number]", nor on `null`, as it will throw.
 *
 * @param value The value to stringify
 * @returns A stringified representation of the given value
 */
function stringifyValue(key, 
// this type is a tiny bit of a cheat, since this function does handle NaN (which is technically a number), but for
// our internal use, it'll do
value) {
    try {
        if (key === 'domain' && value && typeof value === 'object' && value._events) {
            return '[Domain]';
        }
        if (key === 'domainEmitter') {
            return '[DomainEmitter]';
        }
        // It's safe to use `global`, `window`, and `document` here in this manner, as we are asserting using `typeof` first
        // which won't throw if they are not present.
        if (typeof global !== 'undefined' && value === global) {
            return '[Global]';
        }
        // eslint-disable-next-line no-restricted-globals
        if (typeof window !== 'undefined' && value === window) {
            return '[Window]';
        }
        // eslint-disable-next-line no-restricted-globals
        if (typeof document !== 'undefined' && value === document) {
            return '[Document]';
        }
        // React's SyntheticEvent thingy
        if (isSyntheticEvent(value)) {
            return '[SyntheticEvent]';
        }
        if (typeof value === 'number' && value !== value) {
            return '[NaN]';
        }
        // this catches `undefined` (but not `null`, which is a primitive and can be serialized on its own)
        if (value === void 0) {
            return '[undefined]';
        }
        if (typeof value === 'function') {
            return "[Function: " + getFunctionName(value) + "]";
        }
        if (typeof value === 'symbol') {
            return "[" + String(value) + "]";
        }
        // stringified BigInts are indistinguishable from regular numbers, so we need to label them to avoid confusion
        if (typeof value === 'bigint') {
            return "[BigInt: " + String(value) + "]";
        }
        // Now that we've knocked out all the special cases and the primitives, all we have left are objects. Simply casting
        // them to strings means that instances of classes which haven't defined their `toStringTag` will just come out as
        // `"[object Object]"`. If we instead look at the constructor's name (which is the same as the name of the class),
        // we can make sure that only plain objects come out that way.
        return "[object " + Object.getPrototypeOf(value).constructor.name + "]";
    }
    catch (err) {
        return "**non-serializable** (" + err + ")";
    }
}
/** Calculates bytes size of input string */
function utf8Length(value) {
    // eslint-disable-next-line no-bitwise
    return ~-encodeURI(value).split(/%..|./).length;
}
/** Calculates bytes size of input object */
function jsonSize(value) {
    return utf8Length(JSON.stringify(value));
}
//# sourceMappingURL=normalize.js.map{"version":3,"file":"normalize.js","sourceRoot":"","sources":["../../src/normalize.ts"],"names":[],"mappings":";AAEA,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,gBAAgB,EAAE,MAAM,MAAM,CAAC;AACjE,OAAO,EAAE,WAAW,EAAY,MAAM,QAAQ,CAAC;AAC/C,OAAO,EAAE,oBAAoB,EAAE,MAAM,UAAU,CAAC;AAChD,OAAO,EAAE,eAAe,EAAE,MAAM,cAAc,CAAC;AAS/C;;;;;;;;;;;;;;;;;;GAkBG;AACH,MAAM,UAAU,SAAS,CAAC,KAAc,EAAE,KAAyB,EAAE,aAAiC;IAA5D,sBAAA,EAAA,SAAiB,QAAQ;IAAE,8BAAA,EAAA,iBAAyB,QAAQ;IACpG,IAAI;QACF,sDAAsD;QACtD,OAAO,KAAK,CAAC,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,aAAa,CAAC,CAAC;KAC/C;IAAC,OAAO,GAAG,EAAE;QACZ,OAAO,EAAE,KAAK,EAAE,2BAAyB,GAAG,MAAG,EAAE,CAAC;KACnD;AACH,CAAC;AAED,YAAY;AACZ,MAAM,UAAU,eAAe,CAC7B,MAA8B;AAC9B,6BAA6B;AAC7B,KAAiB;AACjB,iEAAiE;AACjE,OAA4B;IAF5B,sBAAA,EAAA,SAAiB;IAEjB,wBAAA,EAAA,UAAkB,GAAG,GAAG,IAAI;IAE5B,IAAM,UAAU,GAAG,SAAS,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;IAE5C,IAAI,QAAQ,CAAC,UAAU,CAAC,GAAG,OAAO,EAAE;QAClC,OAAO,eAAe,CAAC,MAAM,EAAE,KAAK,GAAG,CAAC,EAAE,OAAO,CAAC,CAAC;KACpD;IAED,OAAO,UAAe,CAAC;AACzB,CAAC;AAED;;;;;;;;GAQG;AACH,SAAS,KAAK,CACZ,GAAW,EACX,KAAc,EACd,KAAyB,EACzB,aAAiC,EACjC,IAA8B;IAF9B,sBAAA,EAAA,SAAiB,QAAQ;IACzB,8BAAA,EAAA,iBAAyB,QAAQ;IACjC,qBAAA,EAAA,OAAiB,WAAW,EAAE;IAExB,IAAA,oBAA2B,EAA1B,eAAO,EAAE,iBAAiB,CAAC;IAElC,gFAAgF;IAChF,IAAM,eAAe,GAAG,KAAqE,CAAC;IAC9F,IAAI,eAAe,IAAI,OAAO,eAAe,CAAC,MAAM,KAAK,UAAU,EAAE;QACnE,IAAI;YACF,OAAO,eAAe,CAAC,MAAM,EAAE,CAAC;SACjC;QAAC,OAAO,GAAG,EAAE;YACZ,+EAA+E;SAChF;KACF;IAED,4CAA4C;IAC5C,IAAI,KAAK,KAAK,IAAI,IAAI,CAAC,CAAC,QAAQ,EAAE,SAAS,EAAE,QAAQ,CAAC,CAAC,QAAQ,CAAC,OAAO,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;QAC/F,OAAO,KAAkB,CAAC;KAC3B;IAED,IAAM,WAAW,GAAG,cAAc,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;IAE/C,4GAA4G;IAC5G,kGAAkG;IAClG,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,UAAU,CAAC,EAAE;QACvC,OAAO,WAAW,CAAC;KACpB;IAED,iDAAiD;IACjD,IAAI,KAAK,KAAK,CAAC,EAAE;QACf,qHAAqH;QACrH,OAAO,WAAW,CAAC,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;KAC3C;IAED,qHAAqH;IACrH,IAAI,OAAO,CAAC,KAAK,CAAC,EAAE;QAClB,OAAO,cAAc,CAAC;KACvB;IAED,oHAAoH;IACpH,2GAA2G;IAC3G,sEAAsE;IACtE,IAAM,UAAU,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAwB,CAAC;IAC3E,IAAI,QAAQ,GAAG,CAAC,CAAC;IAEjB,gHAAgH;IAChH,gEAAgE;IAChE,IAAM,SAAS,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAwB,CAAC;IAElH,KAAK,IAAM,QAAQ,IAAI,SAAS,EAAE;QAChC,+FAA+F;QAC/F,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,SAAS,EAAE,QAAQ,CAAC,EAAE;YAC9D,SAAS;SACV;QAED,IAAI,QAAQ,IAAI,aAAa,EAAE;YAC7B,UAAU,CAAC,QAAQ,CAAC,GAAG,mBAAmB,CAAC;YAC3C,MAAM;SACP;QAED,wCAAwC;QACxC,IAAM,UAAU,GAAG,SAAS,CAAC,QAAQ,CAAC,CAAC;QACvC,UAAU,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC,QAAQ,EAAE,UAAU,EAAE,KAAK,GAAG,CAAC,EAAE,aAAa,EAAE,IAAI,CAAC,CAAC;QAEnF,QAAQ,IAAI,CAAC,CAAC;KACf;IAED,2EAA2E;IAC3E,SAAS,CAAC,KAAK,CAAC,CAAC;IAEjB,4BAA4B;IAC5B,OAAO,UAAU,CAAC;AACpB,CAAC;AAED,4FAA4F;AAC5F,OAAO,EAAE,KAAK,IAAI,IAAI,EAAE,CAAC;AAEzB;;;;;;;;GAQG;AACH,SAAS,cAAc,CACrB,GAAY;AACZ,mHAAmH;AACnH,6BAA6B;AAC7B,KAAyD;IAEzD,IAAI;QACF,IAAI,GAAG,KAAK,QAAQ,IAAI,KAAK,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAK,KAA8B,CAAC,OAAO,EAAE;YACrG,OAAO,UAAU,CAAC;SACnB;QAED,IAAI,GAAG,KAAK,eAAe,EAAE;YAC3B,OAAO,iBAAiB,CAAC;SAC1B;QAED,oHAAoH;QACpH,6CAA6C;QAE7C,IAAI,OAAO,MAAM,KAAK,WAAW,IAAI,KAAK,KAAK,MAAM,EAAE;YACrD,OAAO,UAAU,CAAC;SACnB;QAED,iDAAiD;QACjD,IAAI,OAAO,MAAM,KAAK,WAAW,IAAI,KAAK,KAAK,MAAM,EAAE;YACrD,OAAO,UAAU,CAAC;SACnB;QAED,iDAAiD;QACjD,IAAI,OAAO,QAAQ,KAAK,WAAW,IAAI,KAAK,KAAK,QAAQ,EAAE;YACzD,OAAO,YAAY,CAAC;SACrB;QAED,gCAAgC;QAChC,IAAI,gBAAgB,CAAC,KAAK,CAAC,EAAE;YAC3B,OAAO,kBAAkB,CAAC;SAC3B;QAED,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,KAAK,EAAE;YAChD,OAAO,OAAO,CAAC;SAChB;QAED,mGAAmG;QACnG,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;YACpB,OAAO,aAAa,CAAC;SACtB;QAED,IAAI,OAAO,KAAK,KAAK,UAAU,EAAE;YAC/B,OAAO,gBAAc,eAAe,CAAC,KAAK,CAAC,MAAG,CAAC;SAChD;QAED,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;YAC7B,OAAO,MAAI,MAAM,CAAC,KAAK,CAAC,MAAG,CAAC;SAC7B;QAED,8GAA8G;QAC9G,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;YAC7B,OAAO,cAAY,MAAM,CAAC,KAAK,CAAC,MAAG,CAAC;SACrC;QAED,oHAAoH;QACpH,kHAAkH;QAClH,kHAAkH;QAClH,8DAA8D;QAC9D,OAAO,aAAY,MAAM,CAAC,cAAc,CAAC,KAAK,CAAe,CAAC,WAAW,CAAC,IAAI,MAAG,CAAC;KACnF;IAAC,OAAO,GAAG,EAAE;QACZ,OAAO,2BAAyB,GAAG,MAAG,CAAC;KACxC;AACH,CAAC;AAED,4CAA4C;AAC5C,SAAS,UAAU,CAAC,KAAa;IAC/B,sCAAsC;IACtC,OAAO,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC;AAClD,CAAC;AAED,4CAA4C;AAC5C,SAAS,QAAQ,CAAC,KAAU;IAC1B,OAAO,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;AAC3C,CAAC","sourcesContent":["import { Primitive } from '@sentry/types';\n\nimport { isError, isEvent, isNaN, isSyntheticEvent } from './is';\nimport { memoBuilder, MemoFunc } from './memo';\nimport { convertToPlainObject } from './object';\nimport { getFunctionName } from './stacktrace';\n\ntype Prototype = { constructor: (...args: unknown[]) => unknown };\n// This is a hack to placate TS, relying on the fact that technically, arrays are objects with integer keys. Normally we\n// think of those keys as actual numbers, but `arr['0']` turns out to work just as well as `arr[0]`, and doing it this\n// way lets us use a single type in the places where behave as if we are only dealing with objects, even if some of them\n// might be arrays.\ntype ObjOrArray<T> = { [key: string]: T };\n\n/**\n * Recursively normalizes the given object.\n *\n * - Creates a copy to prevent original input mutation\n * - Skips non-enumerable properties\n * - When stringifying, calls `toJSON` if implemented\n * - Removes circular references\n * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format\n * - Translates known global objects/classes to a string representations\n * - Takes care of `Error` object serialization\n * - Optionally limits depth of final output\n * - Optionally limits number of properties/elements included in any single object/array\n *\n * @param input The object to be normalized.\n * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)\n * @param maxProperties The max number of elements or properties to be included in any single array or\n * object in the normallized output..\n * @returns A normalized version of the object, or `\"**non-serializable**\"` if any errors are thrown during normalization.\n */\nexport function normalize(input: unknown, depth: number = +Infinity, maxProperties: number = +Infinity): any {\n  try {\n    // since we're at the outermost level, there is no key\n    return visit('', input, depth, maxProperties);\n  } catch (err) {\n    return { ERROR: `**non-serializable** (${err})` };\n  }\n}\n\n/** JSDoc */\nexport function normalizeToSize<T>(\n  object: { [key: string]: any },\n  // Default Node.js REPL depth\n  depth: number = 3,\n  // 100kB, as 200kB is max payload size, so half sounds reasonable\n  maxSize: number = 100 * 1024,\n): T {\n  const normalized = normalize(object, depth);\n\n  if (jsonSize(normalized) > maxSize) {\n    return normalizeToSize(object, depth - 1, maxSize);\n  }\n\n  return normalized as T;\n}\n\n/**\n * Visits a node to perform normalization on it\n *\n * @param key The key corresponding to the given node\n * @param value The node to be visited\n * @param depth Optional number indicating the maximum recursion depth\n * @param maxProperties Optional maximum number of properties/elements included in any single object/array\n * @param memo Optional Memo class handling decycling\n */\nfunction visit(\n  key: string,\n  value: unknown,\n  depth: number = +Infinity,\n  maxProperties: number = +Infinity,\n  memo: MemoFunc = memoBuilder(),\n): Primitive | ObjOrArray<unknown> {\n  const [memoize, unmemoize] = memo;\n\n  // If the value has a `toJSON` method, see if we can bail and let it do the work\n  const valueWithToJSON = value as unknown & { toJSON?: () => Primitive | ObjOrArray<unknown> };\n  if (valueWithToJSON && typeof valueWithToJSON.toJSON === 'function') {\n    try {\n      return valueWithToJSON.toJSON();\n    } catch (err) {\n      // pass (The built-in `toJSON` failed, but we can still try to do it ourselves)\n    }\n  }\n\n  // Get the simple cases out of the way first\n  if (value === null || (['number', 'boolean', 'string'].includes(typeof value) && !isNaN(value))) {\n    return value as Primitive;\n  }\n\n  const stringified = stringifyValue(key, value);\n\n  // Anything we could potentially dig into more (objects or arrays) will have come back as `\"[object XXXX]\"`.\n  // Everything else will have already been serialized, so if we don't see that pattern, we're done.\n  if (!stringified.startsWith('[object ')) {\n    return stringified;\n  }\n\n  // We're also done if we've reached the max depth\n  if (depth === 0) {\n    // At this point we know `serialized` is a string of the form `\"[object XXXX]\"`. Clean it up so it's just `\"[XXXX]\"`.\n    return stringified.replace('object ', '');\n  }\n\n  // If we've already visited this branch, bail out, as it's circular reference. If not, note that we're seeing it now.\n  if (memoize(value)) {\n    return '[Circular ~]';\n  }\n\n  // At this point we know we either have an object or an array, we haven't seen it before, and we're going to recurse\n  // because we haven't yet reached the max depth. Create an accumulator to hold the results of visiting each\n  // property/entry, and keep track of the number of items we add to it.\n  const normalized = (Array.isArray(value) ? [] : {}) as ObjOrArray<unknown>;\n  let numAdded = 0;\n\n  // Before we begin, convert`Error` and`Event` instances into plain objects, since some of each of their relevant\n  // properties are non-enumerable and otherwise would get missed.\n  const visitable = (isError(value) || isEvent(value) ? convertToPlainObject(value) : value) as ObjOrArray<unknown>;\n\n  for (const visitKey in visitable) {\n    // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.\n    if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {\n      continue;\n    }\n\n    if (numAdded >= maxProperties) {\n      normalized[visitKey] = '[MaxProperties ~]';\n      break;\n    }\n\n    // Recursively visit all the child nodes\n    const visitValue = visitable[visitKey];\n    normalized[visitKey] = visit(visitKey, visitValue, depth - 1, maxProperties, memo);\n\n    numAdded += 1;\n  }\n\n  // Once we've visited all the branches, remove the parent from memo storage\n  unmemoize(value);\n\n  // Return accumulated values\n  return normalized;\n}\n\n// TODO remove this in v7 (this means the method will no longer be exported, under any name)\nexport { visit as walk };\n\n/**\n * Stringify the given value. Handles various known special values and types.\n *\n * Not meant to be used on simple primitives which already have a string representation, as it will, for example, turn\n * the number 1231 into \"[Object Number]\", nor on `null`, as it will throw.\n *\n * @param value The value to stringify\n * @returns A stringified representation of the given value\n */\nfunction stringifyValue(\n  key: unknown,\n  // this type is a tiny bit of a cheat, since this function does handle NaN (which is technically a number), but for\n  // our internal use, it'll do\n  value: Exclude<unknown, string | number | boolean | null>,\n): string {\n  try {\n    if (key === 'domain' && value && typeof value === 'object' && (value as { _events: unknown })._events) {\n      return '[Domain]';\n    }\n\n    if (key === 'domainEmitter') {\n      return '[DomainEmitter]';\n    }\n\n    // It's safe to use `global`, `window`, and `document` here in this manner, as we are asserting using `typeof` first\n    // which won't throw if they are not present.\n\n    if (typeof global !== 'undefined' && value === global) {\n      return '[Global]';\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof window !== 'undefined' && value === window) {\n      return '[Window]';\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof document !== 'undefined' && value === document) {\n      return '[Document]';\n    }\n\n    // React's SyntheticEvent thingy\n    if (isSyntheticEvent(value)) {\n      return '[SyntheticEvent]';\n    }\n\n    if (typeof value === 'number' && value !== value) {\n      return '[NaN]';\n    }\n\n    // this catches `undefined` (but not `null`, which is a primitive and can be serialized on its own)\n    if (value === void 0) {\n      return '[undefined]';\n    }\n\n    if (typeof value === 'function') {\n      return `[Function: ${getFunctionName(value)}]`;\n    }\n\n    if (typeof value === 'symbol') {\n      return `[${String(value)}]`;\n    }\n\n    // stringified BigInts are indistinguishable from regular numbers, so we need to label them to avoid confusion\n    if (typeof value === 'bigint') {\n      return `[BigInt: ${String(value)}]`;\n    }\n\n    // Now that we've knocked out all the special cases and the primitives, all we have left are objects. Simply casting\n    // them to strings means that instances of classes which haven't defined their `toStringTag` will just come out as\n    // `\"[object Object]\"`. If we instead look at the constructor's name (which is the same as the name of the class),\n    // we can make sure that only plain objects come out that way.\n    return `[object ${(Object.getPrototypeOf(value) as Prototype).constructor.name}]`;\n  } catch (err) {\n    return `**non-serializable** (${err})`;\n  }\n}\n\n/** Calculates bytes size of input string */\nfunction utf8Length(value: string): number {\n  // eslint-disable-next-line no-bitwise\n  return ~-encodeURI(value).split(/%..|./).length;\n}\n\n/** Calculates bytes size of input object */\nfunction jsonSize(value: any): number {\n  return utf8Length(JSON.stringify(value));\n}\n"]}import { WrappedFunction } from '@sentry/types';
/**
 * Replace a method in an object with a wrapped version of itself.
 *
 * @param source An object that contains a method to be wrapped.
 * @param name The name of the method to be wrapped.
 * @param replacementFactory A higher-order function that takes the original version of the given method and returns a
 * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to
 * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other
 * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.
 * @returns void
 */
export declare function fill(source: {
    [key: string]: any;
}, name: string, replacementFactory: (...args: any[]) => any): void;
/**
 * Defines a non-enumerable property on the given object.
 *
 * @param obj The object on which to set the property
 * @param name The name of the property to be set
 * @param value The value to which to set the property
 */
export declare function addNonEnumerableProperty(obj: {
    [key: string]: unknown;
}, name: string, value: unknown): void;
/**
 * Remembers the original function on the wrapped function and
 * patches up the prototype.
 *
 * @param wrapped the wrapper function
 * @param original the original function that gets wrapped
 */
export declare function markFunctionWrapped(wrapped: WrappedFunction, original: WrappedFunction): void;
/**
 * This extracts the original function if available.  See
 * `markFunctionWrapped` for more information.
 *
 * @param func the function to unwrap
 * @returns the unwrapped version of the function if available.
 */
export declare function getOriginalFunction(func: WrappedFunction): WrappedFunction | undefined;
/**
 * Encodes given object into url-friendly format
 *
 * @param object An object that contains serializable values
 * @returns string Encoded
 */
export declare function urlEncode(object: {
    [key: string]: any;
}): string;
/**
 * Transforms any object into an object literal with all its attributes
 * attached to it.
 *
 * @param value Initial source that we have to transform in order for it to be usable by the serializer
 */
export declare function convertToPlainObject(value: unknown): {
    [key: string]: unknown;
};
/**
 * Given any captured exception, extract its keys and create a sorted
 * and truncated list that will be used inside the event message.
 * eg. `Non-error exception captured with keys: foo, bar, baz`
 */
export declare function extractExceptionKeysForMessage(exception: any, maxLength?: number): string;
/**
 * Given any object, return the new object with removed keys that value was `undefined`.
 * Works recursively on objects and arrays.
 */
export declare function dropUndefinedKeys<T>(val: T): T;
/**
 * Ensure that something is an object.
 *
 * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper
 * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.
 *
 * @param wat The subject of the objectification
 * @returns A version of `wat` which can safely be used with `Object` class methods
 */
export declare function objectify(wat: unknown): typeof Object;
//# sourceMappingURL=object.d.ts.map{"version":3,"file":"object.d.ts","sourceRoot":"","sources":["../../src/object.ts"],"names":[],"mappings":"AAEA,OAAO,EAAiB,eAAe,EAAE,MAAM,eAAe,CAAC;AAM/D;;;;;;;;;;GAUG;AACH,wBAAgB,IAAI,CAAC,MAAM,EAAE;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;CAAE,EAAE,IAAI,EAAE,MAAM,EAAE,kBAAkB,EAAE,CAAC,GAAG,IAAI,EAAE,GAAG,EAAE,KAAK,GAAG,GAAG,IAAI,CAoBpH;AAED;;;;;;GAMG;AACH,wBAAgB,wBAAwB,CAAC,GAAG,EAAE;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAAA;CAAE,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,OAAO,GAAG,IAAI,CAO5G;AAED;;;;;;GAMG;AACH,wBAAgB,mBAAmB,CAAC,OAAO,EAAE,eAAe,EAAE,QAAQ,EAAE,eAAe,GAAG,IAAI,CAI7F;AAED;;;;;;GAMG;AACH,wBAAgB,mBAAmB,CAAC,IAAI,EAAE,eAAe,GAAG,eAAe,GAAG,SAAS,CAEtF;AAED;;;;;GAKG;AACH,wBAAgB,SAAS,CAAC,MAAM,EAAE;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;CAAE,GAAG,MAAM,CAIhE;AAED;;;;;GAKG;AACH,wBAAgB,oBAAoB,CAAC,KAAK,EAAE,OAAO,GAAG;IACpD,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAAC;CACxB,CAqCA;AAsBD;;;;GAIG;AAEH,wBAAgB,8BAA8B,CAAC,SAAS,EAAE,GAAG,EAAE,SAAS,GAAE,MAAW,GAAG,MAAM,CAwB7F;AAED;;;GAGG;AACH,wBAAgB,iBAAiB,CAAC,CAAC,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,CAgB9C;AAED;;;;;;;;GAQG;AACH,wBAAgB,SAAS,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,MAAM,CA0BrD"}import { __assign, __values } from "tslib";
import { htmlTreeAsString } from './browser';
import { isElement, isError, isEvent, isInstanceOf, isPlainObject, isPrimitive } from './is';
import { truncate } from './string';
/**
 * Replace a method in an object with a wrapped version of itself.
 *
 * @param source An object that contains a method to be wrapped.
 * @param name The name of the method to be wrapped.
 * @param replacementFactory A higher-order function that takes the original version of the given method and returns a
 * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to
 * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other
 * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.
 * @returns void
 */
export function fill(source, name, replacementFactory) {
    if (!(name in source)) {
        return;
    }
    var original = source[name];
    var wrapped = replacementFactory(original);
    // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work
    // otherwise it'll throw "TypeError: Object.defineProperties called on non-object"
    if (typeof wrapped === 'function') {
        try {
            markFunctionWrapped(wrapped, original);
        }
        catch (_Oo) {
            // This can throw if multiple fill happens on a global object like XMLHttpRequest
            // Fixes https://github.com/getsentry/sentry-javascript/issues/2043
        }
    }
    source[name] = wrapped;
}
/**
 * Defines a non-enumerable property on the given object.
 *
 * @param obj The object on which to set the property
 * @param name The name of the property to be set
 * @param value The value to which to set the property
 */
export function addNonEnumerableProperty(obj, name, value) {
    Object.defineProperty(obj, name, {
        // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
        value: value,
        writable: true,
        configurable: true,
    });
}
/**
 * Remembers the original function on the wrapped function and
 * patches up the prototype.
 *
 * @param wrapped the wrapper function
 * @param original the original function that gets wrapped
 */
export function markFunctionWrapped(wrapped, original) {
    var proto = original.prototype || {};
    wrapped.prototype = original.prototype = proto;
    addNonEnumerableProperty(wrapped, '__sentry_original__', original);
}
/**
 * This extracts the original function if available.  See
 * `markFunctionWrapped` for more information.
 *
 * @param func the function to unwrap
 * @returns the unwrapped version of the function if available.
 */
export function getOriginalFunction(func) {
    return func.__sentry_original__;
}
/**
 * Encodes given object into url-friendly format
 *
 * @param object An object that contains serializable values
 * @returns string Encoded
 */
export function urlEncode(object) {
    return Object.keys(object)
        .map(function (key) { return encodeURIComponent(key) + "=" + encodeURIComponent(object[key]); })
        .join('&');
}
/**
 * Transforms any object into an object literal with all its attributes
 * attached to it.
 *
 * @param value Initial source that we have to transform in order for it to be usable by the serializer
 */
export function convertToPlainObject(value) {
    var newObj = value;
    if (isError(value)) {
        newObj = __assign({ message: value.message, name: value.name, stack: value.stack }, getOwnProperties(value));
    }
    else if (isEvent(value)) {
        var event_1 = value;
        newObj = __assign({ type: event_1.type, target: serializeEventTarget(event_1.target), currentTarget: serializeEventTarget(event_1.currentTarget) }, getOwnProperties(event_1));
        if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {
            newObj.detail = event_1.detail;
        }
    }
    return newObj;
}
/** Creates a string representation of the target of an `Event` object */
function serializeEventTarget(target) {
    try {
        return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);
    }
    catch (_oO) {
        return '<unknown>';
    }
}
/** Filters out all but an object's own properties */
function getOwnProperties(obj) {
    var extractedProps = {};
    for (var property in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, property)) {
            extractedProps[property] = obj[property];
        }
    }
    return extractedProps;
}
/**
 * Given any captured exception, extract its keys and create a sorted
 * and truncated list that will be used inside the event message.
 * eg. `Non-error exception captured with keys: foo, bar, baz`
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function extractExceptionKeysForMessage(exception, maxLength) {
    if (maxLength === void 0) { maxLength = 40; }
    var keys = Object.keys(convertToPlainObject(exception));
    keys.sort();
    if (!keys.length) {
        return '[object has no keys]';
    }
    if (keys[0].length >= maxLength) {
        return truncate(keys[0], maxLength);
    }
    for (var includedKeys = keys.length; includedKeys > 0; includedKeys--) {
        var serialized = keys.slice(0, includedKeys).join(', ');
        if (serialized.length > maxLength) {
            continue;
        }
        if (includedKeys === keys.length) {
            return serialized;
        }
        return truncate(serialized, maxLength);
    }
    return '';
}
/**
 * Given any object, return the new object with removed keys that value was `undefined`.
 * Works recursively on objects and arrays.
 */
export function dropUndefinedKeys(val) {
    var e_1, _a;
    if (isPlainObject(val)) {
        var rv = {};
        try {
            for (var _b = __values(Object.keys(val)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                if (typeof val[key] !== 'undefined') {
                    rv[key] = dropUndefinedKeys(val[key]);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return rv;
    }
    if (Array.isArray(val)) {
        return val.map(dropUndefinedKeys);
    }
    return val;
}
/**
 * Ensure that something is an object.
 *
 * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper
 * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.
 *
 * @param wat The subject of the objectification
 * @returns A version of `wat` which can safely be used with `Object` class methods
 */
export function objectify(wat) {
    var objectified;
    switch (true) {
        case wat === undefined || wat === null:
            objectified = new String(wat);
            break;
        // Though symbols and bigints do have wrapper classes (`Symbol` and `BigInt`, respectively), for whatever reason
        // those classes don't have constructors which can be used with the `new` keyword. We therefore need to cast each as
        // an object in order to wrap it.
        case typeof wat === 'symbol' || typeof wat === 'bigint':
            objectified = Object(wat);
            break;
        // this will catch the remaining primitives: `String`, `Number`, and `Boolean`
        case isPrimitive(wat):
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            objectified = new wat.constructor(wat);
            break;
        // by process of elimination, at this point we know that `wat` must already be an object
        default:
            objectified = wat;
            break;
    }
    return objectified;
}
//# sourceMappingURL=object.js.map{"version":3,"file":"object.js","sourceRoot":"","sources":["../../src/object.ts"],"names":[],"mappings":";AAIA,OAAO,EAAE,gBAAgB,EAAE,MAAM,WAAW,CAAC;AAC7C,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,OAAO,EAAE,YAAY,EAAE,aAAa,EAAE,WAAW,EAAE,MAAM,MAAM,CAAC;AAC7F,OAAO,EAAE,QAAQ,EAAE,MAAM,UAAU,CAAC;AAEpC;;;;;;;;;;GAUG;AACH,MAAM,UAAU,IAAI,CAAC,MAA8B,EAAE,IAAY,EAAE,kBAA2C;IAC5G,IAAI,CAAC,CAAC,IAAI,IAAI,MAAM,CAAC,EAAE;QACrB,OAAO;KACR;IAED,IAAM,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAc,CAAC;IAC3C,IAAM,OAAO,GAAG,kBAAkB,CAAC,QAAQ,CAAoB,CAAC;IAEhE,0GAA0G;IAC1G,kFAAkF;IAClF,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE;QACjC,IAAI;YACF,mBAAmB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;SACxC;QAAC,OAAO,GAAG,EAAE;YACZ,iFAAiF;YACjF,mEAAmE;SACpE;KACF;IAED,MAAM,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC;AACzB,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,wBAAwB,CAAC,GAA+B,EAAE,IAAY,EAAE,KAAc;IACpG,MAAM,CAAC,cAAc,CAAC,GAAG,EAAE,IAAI,EAAE;QAC/B,gGAAgG;QAChG,KAAK,EAAE,KAAK;QACZ,QAAQ,EAAE,IAAI;QACd,YAAY,EAAE,IAAI;KACnB,CAAC,CAAC;AACL,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,mBAAmB,CAAC,OAAwB,EAAE,QAAyB;IACrF,IAAM,KAAK,GAAG,QAAQ,CAAC,SAAS,IAAI,EAAE,CAAC;IACvC,OAAO,CAAC,SAAS,GAAG,QAAQ,CAAC,SAAS,GAAG,KAAK,CAAC;IAC/C,wBAAwB,CAAC,OAAO,EAAE,qBAAqB,EAAE,QAAQ,CAAC,CAAC;AACrE,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,mBAAmB,CAAC,IAAqB;IACvD,OAAO,IAAI,CAAC,mBAAmB,CAAC;AAClC,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,SAAS,CAAC,MAA8B;IACtD,OAAO,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;SACvB,GAAG,CAAC,UAAA,GAAG,IAAI,OAAG,kBAAkB,CAAC,GAAG,CAAC,SAAI,kBAAkB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAG,EAA/D,CAA+D,CAAC;SAC3E,IAAI,CAAC,GAAG,CAAC,CAAC;AACf,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,oBAAoB,CAAC,KAAc;IAGjD,IAAI,MAAM,GAAG,KAEZ,CAAC;IAEF,IAAI,OAAO,CAAC,KAAK,CAAC,EAAE;QAClB,MAAM,cACJ,OAAO,EAAE,KAAK,CAAC,OAAO,EACtB,IAAI,EAAE,KAAK,CAAC,IAAI,EAChB,KAAK,EAAE,KAAK,CAAC,KAAK,IACf,gBAAgB,CAAC,KAAsB,CAAC,CAC5C,CAAC;KACH;SAAM,IAAI,OAAO,CAAC,KAAK,CAAC,EAAE;QAWzB,IAAM,OAAK,GAAG,KAAoB,CAAC;QAEnC,MAAM,cACJ,IAAI,EAAE,OAAK,CAAC,IAAI,EAChB,MAAM,EAAE,oBAAoB,CAAC,OAAK,CAAC,MAAM,CAAC,EAC1C,aAAa,EAAE,oBAAoB,CAAC,OAAK,CAAC,aAAa,CAAC,IACrD,gBAAgB,CAAC,OAAK,CAAC,CAC3B,CAAC;QAEF,IAAI,OAAO,WAAW,KAAK,WAAW,IAAI,YAAY,CAAC,KAAK,EAAE,WAAW,CAAC,EAAE;YAC1E,MAAM,CAAC,MAAM,GAAG,OAAK,CAAC,MAAM,CAAC;SAC9B;KACF;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,yEAAyE;AACzE,SAAS,oBAAoB,CAAC,MAAe;IAC3C,IAAI;QACF,OAAO,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;KAC9F;IAAC,OAAO,GAAG,EAAE;QACZ,OAAO,WAAW,CAAC;KACpB;AACH,CAAC;AAED,qDAAqD;AACrD,SAAS,gBAAgB,CAAC,GAA+B;IACvD,IAAM,cAAc,GAA+B,EAAE,CAAC;IACtD,KAAK,IAAM,QAAQ,IAAI,GAAG,EAAE;QAC1B,IAAI,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,QAAQ,CAAC,EAAE;YACvD,cAAc,CAAC,QAAQ,CAAC,GAAG,GAAG,CAAC,QAAQ,CAAC,CAAC;SAC1C;KACF;IACD,OAAO,cAAc,CAAC;AACxB,CAAC;AAED;;;;GAIG;AACH,6EAA6E;AAC7E,MAAM,UAAU,8BAA8B,CAAC,SAAc,EAAE,SAAsB;IAAtB,0BAAA,EAAA,cAAsB;IACnF,IAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,CAAC,CAAC;IAC1D,IAAI,CAAC,IAAI,EAAE,CAAC;IAEZ,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;QAChB,OAAO,sBAAsB,CAAC;KAC/B;IAED,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,SAAS,EAAE;QAC/B,OAAO,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;KACrC;IAED,KAAK,IAAI,YAAY,GAAG,IAAI,CAAC,MAAM,EAAE,YAAY,GAAG,CAAC,EAAE,YAAY,EAAE,EAAE;QACrE,IAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,YAAY,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC1D,IAAI,UAAU,CAAC,MAAM,GAAG,SAAS,EAAE;YACjC,SAAS;SACV;QACD,IAAI,YAAY,KAAK,IAAI,CAAC,MAAM,EAAE;YAChC,OAAO,UAAU,CAAC;SACnB;QACD,OAAO,QAAQ,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;KACxC;IAED,OAAO,EAAE,CAAC;AACZ,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,iBAAiB,CAAI,GAAM;;IACzC,IAAI,aAAa,CAAC,GAAG,CAAC,EAAE;QACtB,IAAM,EAAE,GAA2B,EAAE,CAAC;;YACtC,KAAkB,IAAA,KAAA,SAAA,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA,gBAAA,4BAAE;gBAA/B,IAAM,GAAG,WAAA;gBACZ,IAAI,OAAO,GAAG,CAAC,GAAG,CAAC,KAAK,WAAW,EAAE;oBACnC,EAAE,CAAC,GAAG,CAAC,GAAG,iBAAiB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;iBACvC;aACF;;;;;;;;;QACD,OAAO,EAAO,CAAC;KAChB;IAED,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;QACtB,OAAQ,GAAa,CAAC,GAAG,CAAC,iBAAiB,CAAQ,CAAC;KACrD;IAED,OAAO,GAAG,CAAC;AACb,CAAC;AAED;;;;;;;;GAQG;AACH,MAAM,UAAU,SAAS,CAAC,GAAY;IACpC,IAAI,WAAW,CAAC;IAChB,QAAQ,IAAI,EAAE;QACZ,KAAK,GAAG,KAAK,SAAS,IAAI,GAAG,KAAK,IAAI;YACpC,WAAW,GAAG,IAAI,MAAM,CAAC,GAAG,CAAC,CAAC;YAC9B,MAAM;QAER,gHAAgH;QAChH,oHAAoH;QACpH,iCAAiC;QACjC,KAAK,OAAO,GAAG,KAAK,QAAQ,IAAI,OAAO,GAAG,KAAK,QAAQ;YACrD,WAAW,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;YAC1B,MAAM;QAER,8EAA8E;QAC9E,KAAK,WAAW,CAAC,GAAG,CAAC;YACnB,sEAAsE;YACtE,WAAW,GAAG,IAAK,GAAW,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;YAChD,MAAM;QAER,wFAAwF;QACxF;YACE,WAAW,GAAG,GAAG,CAAC;YAClB,MAAM;KACT;IACD,OAAO,WAAW,CAAC;AACrB,CAAC","sourcesContent":["/* eslint-disable max-lines */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { ExtendedError, WrappedFunction } from '@sentry/types';\n\nimport { htmlTreeAsString } from './browser';\nimport { isElement, isError, isEvent, isInstanceOf, isPlainObject, isPrimitive } from './is';\nimport { truncate } from './string';\n\n/**\n * Replace a method in an object with a wrapped version of itself.\n *\n * @param source An object that contains a method to be wrapped.\n * @param name The name of the method to be wrapped.\n * @param replacementFactory A higher-order function that takes the original version of the given method and returns a\n * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to\n * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other\n * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.\n * @returns void\n */\nexport function fill(source: { [key: string]: any }, name: string, replacementFactory: (...args: any[]) => any): void {\n  if (!(name in source)) {\n    return;\n  }\n\n  const original = source[name] as () => any;\n  const wrapped = replacementFactory(original) as WrappedFunction;\n\n  // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n  // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n  if (typeof wrapped === 'function') {\n    try {\n      markFunctionWrapped(wrapped, original);\n    } catch (_Oo) {\n      // This can throw if multiple fill happens on a global object like XMLHttpRequest\n      // Fixes https://github.com/getsentry/sentry-javascript/issues/2043\n    }\n  }\n\n  source[name] = wrapped;\n}\n\n/**\n * Defines a non-enumerable property on the given object.\n *\n * @param obj The object on which to set the property\n * @param name The name of the property to be set\n * @param value The value to which to set the property\n */\nexport function addNonEnumerableProperty(obj: { [key: string]: unknown }, name: string, value: unknown): void {\n  Object.defineProperty(obj, name, {\n    // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it\n    value: value,\n    writable: true,\n    configurable: true,\n  });\n}\n\n/**\n * Remembers the original function on the wrapped function and\n * patches up the prototype.\n *\n * @param wrapped the wrapper function\n * @param original the original function that gets wrapped\n */\nexport function markFunctionWrapped(wrapped: WrappedFunction, original: WrappedFunction): void {\n  const proto = original.prototype || {};\n  wrapped.prototype = original.prototype = proto;\n  addNonEnumerableProperty(wrapped, '__sentry_original__', original);\n}\n\n/**\n * This extracts the original function if available.  See\n * `markFunctionWrapped` for more information.\n *\n * @param func the function to unwrap\n * @returns the unwrapped version of the function if available.\n */\nexport function getOriginalFunction(func: WrappedFunction): WrappedFunction | undefined {\n  return func.__sentry_original__;\n}\n\n/**\n * Encodes given object into url-friendly format\n *\n * @param object An object that contains serializable values\n * @returns string Encoded\n */\nexport function urlEncode(object: { [key: string]: any }): string {\n  return Object.keys(object)\n    .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`)\n    .join('&');\n}\n\n/**\n * Transforms any object into an object literal with all its attributes\n * attached to it.\n *\n * @param value Initial source that we have to transform in order for it to be usable by the serializer\n */\nexport function convertToPlainObject(value: unknown): {\n  [key: string]: unknown;\n} {\n  let newObj = value as {\n    [key: string]: unknown;\n  };\n\n  if (isError(value)) {\n    newObj = {\n      message: value.message,\n      name: value.name,\n      stack: value.stack,\n      ...getOwnProperties(value as ExtendedError),\n    };\n  } else if (isEvent(value)) {\n    /**\n     * Event-like interface that's usable in browser and node\n     */\n    interface SimpleEvent {\n      [key: string]: unknown;\n      type: string;\n      target?: unknown;\n      currentTarget?: unknown;\n    }\n\n    const event = value as SimpleEvent;\n\n    newObj = {\n      type: event.type,\n      target: serializeEventTarget(event.target),\n      currentTarget: serializeEventTarget(event.currentTarget),\n      ...getOwnProperties(event),\n    };\n\n    if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {\n      newObj.detail = event.detail;\n    }\n  }\n  return newObj;\n}\n\n/** Creates a string representation of the target of an `Event` object */\nfunction serializeEventTarget(target: unknown): string {\n  try {\n    return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);\n  } catch (_oO) {\n    return '<unknown>';\n  }\n}\n\n/** Filters out all but an object's own properties */\nfunction getOwnProperties(obj: { [key: string]: unknown }): { [key: string]: unknown } {\n  const extractedProps: { [key: string]: unknown } = {};\n  for (const property in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, property)) {\n      extractedProps[property] = obj[property];\n    }\n  }\n  return extractedProps;\n}\n\n/**\n * Given any captured exception, extract its keys and create a sorted\n * and truncated list that will be used inside the event message.\n * eg. `Non-error exception captured with keys: foo, bar, baz`\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function extractExceptionKeysForMessage(exception: any, maxLength: number = 40): string {\n  const keys = Object.keys(convertToPlainObject(exception));\n  keys.sort();\n\n  if (!keys.length) {\n    return '[object has no keys]';\n  }\n\n  if (keys[0].length >= maxLength) {\n    return truncate(keys[0], maxLength);\n  }\n\n  for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {\n    const serialized = keys.slice(0, includedKeys).join(', ');\n    if (serialized.length > maxLength) {\n      continue;\n    }\n    if (includedKeys === keys.length) {\n      return serialized;\n    }\n    return truncate(serialized, maxLength);\n  }\n\n  return '';\n}\n\n/**\n * Given any object, return the new object with removed keys that value was `undefined`.\n * Works recursively on objects and arrays.\n */\nexport function dropUndefinedKeys<T>(val: T): T {\n  if (isPlainObject(val)) {\n    const rv: { [key: string]: any } = {};\n    for (const key of Object.keys(val)) {\n      if (typeof val[key] !== 'undefined') {\n        rv[key] = dropUndefinedKeys(val[key]);\n      }\n    }\n    return rv as T;\n  }\n\n  if (Array.isArray(val)) {\n    return (val as any[]).map(dropUndefinedKeys) as any;\n  }\n\n  return val;\n}\n\n/**\n * Ensure that something is an object.\n *\n * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper\n * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.\n *\n * @param wat The subject of the objectification\n * @returns A version of `wat` which can safely be used with `Object` class methods\n */\nexport function objectify(wat: unknown): typeof Object {\n  let objectified;\n  switch (true) {\n    case wat === undefined || wat === null:\n      objectified = new String(wat);\n      break;\n\n    // Though symbols and bigints do have wrapper classes (`Symbol` and `BigInt`, respectively), for whatever reason\n    // those classes don't have constructors which can be used with the `new` keyword. We therefore need to cast each as\n    // an object in order to wrap it.\n    case typeof wat === 'symbol' || typeof wat === 'bigint':\n      objectified = Object(wat);\n      break;\n\n    // this will catch the remaining primitives: `String`, `Number`, and `Boolean`\n    case isPrimitive(wat):\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      objectified = new (wat as any).constructor(wat);\n      break;\n\n    // by process of elimination, at this point we know that `wat` must already be an object\n    default:\n      objectified = wat;\n      break;\n  }\n  return objectified;\n}\n"]}/** JSDoc */
export declare function resolve(...args: string[]): string;
/** JSDoc */
export declare function relative(from: string, to: string): string;
/** JSDoc */
export declare function normalizePath(path: string): string;
/** JSDoc */
export declare function isAbsolute(path: string): boolean;
/** JSDoc */
export declare function join(...args: string[]): string;
/** JSDoc */
export declare function dirname(path: string): string;
/** JSDoc */
export declare function basename(path: string, ext?: string): string;
//# sourceMappingURL=path.d.ts.map{"version":3,"file":"path.d.ts","sourceRoot":"","sources":["../../src/path.ts"],"names":[],"mappings":"AA4CA,YAAY;AACZ,wBAAgB,OAAO,CAAC,GAAG,IAAI,EAAE,MAAM,EAAE,GAAG,MAAM,CA0BjD;AA0BD,YAAY;AACZ,wBAAgB,QAAQ,CAAC,IAAI,EAAE,MAAM,EAAE,EAAE,EAAE,MAAM,GAAG,MAAM,CA0BzD;AAID,YAAY;AACZ,wBAAgB,aAAa,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,CAkBlD;AAGD,YAAY;AACZ,wBAAgB,UAAU,CAAC,IAAI,EAAE,MAAM,GAAG,OAAO,CAEhD;AAGD,YAAY;AACZ,wBAAgB,IAAI,CAAC,GAAG,IAAI,EAAE,MAAM,EAAE,GAAG,MAAM,CAE9C;AAED,YAAY;AACZ,wBAAgB,OAAO,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,CAgB5C;AAED,YAAY;AACZ,wBAAgB,QAAQ,CAAC,IAAI,EAAE,MAAM,EAAE,GAAG,CAAC,EAAE,MAAM,GAAG,MAAM,CAM3D"}// Slightly modified (no IE8 support, ES6) and transcribed to TypeScript
// https://raw.githubusercontent.com/calvinmetcalf/rollup-plugin-node-builtins/master/src/es6/path.js
/** JSDoc */
function normalizeArray(parts, allowAboveRoot) {
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
            parts.splice(i, 1);
        }
        else if (last === '..') {
            parts.splice(i, 1);
            // eslint-disable-next-line no-plusplus
            up++;
        }
        else if (up) {
            parts.splice(i, 1);
            // eslint-disable-next-line no-plusplus
            up--;
        }
    }
    // if the path is allowed to go above the root, restore leading ..s
    if (allowAboveRoot) {
        // eslint-disable-next-line no-plusplus
        for (; up--; up) {
            parts.unshift('..');
        }
    }
    return parts;
}
// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^/]+?|)(\.[^./]*|))(?:[/]*)$/;
/** JSDoc */
function splitPath(filename) {
    var parts = splitPathRe.exec(filename);
    return parts ? parts.slice(1) : [];
}
// path.resolve([from ...], to)
// posix version
/** JSDoc */
export function resolve() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var resolvedPath = '';
    var resolvedAbsolute = false;
    for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? args[i] : '/';
        // Skip empty entries
        if (!path) {
            continue;
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = path.charAt(0) === '/';
    }
    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)
    // Normalize the path
    resolvedPath = normalizeArray(resolvedPath.split('/').filter(function (p) { return !!p; }), !resolvedAbsolute).join('/');
    return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
}
/** JSDoc */
function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
        if (arr[start] !== '') {
            break;
        }
    }
    var end = arr.length - 1;
    for (; end >= 0; end--) {
        if (arr[end] !== '') {
            break;
        }
    }
    if (start > end) {
        return [];
    }
    return arr.slice(start, end - start + 1);
}
// path.relative(from, to)
// posix version
/** JSDoc */
export function relative(from, to) {
    /* eslint-disable no-param-reassign */
    from = resolve(from).substr(1);
    to = resolve(to).substr(1);
    /* eslint-enable no-param-reassign */
    var fromParts = trim(from.split('/'));
    var toParts = trim(to.split('/'));
    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
        }
    }
    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push('..');
    }
    outputParts = outputParts.concat(toParts.slice(samePartsLength));
    return outputParts.join('/');
}
// path.normalize(path)
// posix version
/** JSDoc */
export function normalizePath(path) {
    var isPathAbsolute = isAbsolute(path);
    var trailingSlash = path.substr(-1) === '/';
    // Normalize the path
    var normalizedPath = normalizeArray(path.split('/').filter(function (p) { return !!p; }), !isPathAbsolute).join('/');
    if (!normalizedPath && !isPathAbsolute) {
        normalizedPath = '.';
    }
    if (normalizedPath && trailingSlash) {
        normalizedPath += '/';
    }
    return (isPathAbsolute ? '/' : '') + normalizedPath;
}
// posix version
/** JSDoc */
export function isAbsolute(path) {
    return path.charAt(0) === '/';
}
// posix version
/** JSDoc */
export function join() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return normalizePath(args.join('/'));
}
/** JSDoc */
export function dirname(path) {
    var result = splitPath(path);
    var root = result[0];
    var dir = result[1];
    if (!root && !dir) {
        // No dirname whatsoever
        return '.';
    }
    if (dir) {
        // It has a dirname, strip trailing slash
        dir = dir.substr(0, dir.length - 1);
    }
    return root + dir;
}
/** JSDoc */
export function basename(path, ext) {
    var f = splitPath(path)[2];
    if (ext && f.substr(ext.length * -1) === ext) {
        f = f.substr(0, f.length - ext.length);
    }
    return f;
}
//# sourceMappingURL=path.js.map{"version":3,"file":"path.js","sourceRoot":"","sources":["../../src/path.ts"],"names":[],"mappings":"AAAA,wEAAwE;AACxE,qGAAqG;AAErG,YAAY;AACZ,SAAS,cAAc,CAAC,KAAe,EAAE,cAAwB;IAC/D,2DAA2D;IAC3D,IAAI,EAAE,GAAG,CAAC,CAAC;IACX,KAAK,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;QAC1C,IAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QACtB,IAAI,IAAI,KAAK,GAAG,EAAE;YAChB,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;SACpB;aAAM,IAAI,IAAI,KAAK,IAAI,EAAE;YACxB,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YACnB,uCAAuC;YACvC,EAAE,EAAE,CAAC;SACN;aAAM,IAAI,EAAE,EAAE;YACb,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YACnB,uCAAuC;YACvC,EAAE,EAAE,CAAC;SACN;KACF;IAED,mEAAmE;IACnE,IAAI,cAAc,EAAE;QAClB,uCAAuC;QACvC,OAAO,EAAE,EAAE,EAAE,EAAE,EAAE;YACf,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;SACrB;KACF;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AAED,iEAAiE;AACjE,sCAAsC;AACtC,IAAM,WAAW,GAAG,4DAA4D,CAAC;AACjF,YAAY;AACZ,SAAS,SAAS,CAAC,QAAgB;IACjC,IAAM,KAAK,GAAG,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACzC,OAAO,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;AACrC,CAAC;AAED,+BAA+B;AAC/B,gBAAgB;AAChB,YAAY;AACZ,MAAM,UAAU,OAAO;IAAC,cAAiB;SAAjB,UAAiB,EAAjB,qBAAiB,EAAjB,IAAiB;QAAjB,yBAAiB;;IACvC,IAAI,YAAY,GAAG,EAAE,CAAC;IACtB,IAAI,gBAAgB,GAAG,KAAK,CAAC;IAE7B,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,gBAAgB,EAAE,CAAC,EAAE,EAAE;QAC/D,IAAM,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;QAEpC,qBAAqB;QACrB,IAAI,CAAC,IAAI,EAAE;YACT,SAAS;SACV;QAED,YAAY,GAAM,IAAI,SAAI,YAAc,CAAC;QACzC,gBAAgB,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC;KAC3C;IAED,yEAAyE;IACzE,2EAA2E;IAE3E,qBAAqB;IACrB,YAAY,GAAG,cAAc,CAC3B,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,CAAC,EAAH,CAAG,CAAC,EACxC,CAAC,gBAAgB,CAClB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAEZ,OAAO,CAAC,gBAAgB,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,YAAY,IAAI,GAAG,CAAC;AAC7D,CAAC;AAED,YAAY;AACZ,SAAS,IAAI,CAAC,GAAa;IACzB,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,OAAO,KAAK,GAAG,GAAG,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;QAClC,IAAI,GAAG,CAAC,KAAK,CAAC,KAAK,EAAE,EAAE;YACrB,MAAM;SACP;KACF;IAED,IAAI,GAAG,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC;IACzB,OAAO,GAAG,IAAI,CAAC,EAAE,GAAG,EAAE,EAAE;QACtB,IAAI,GAAG,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE;YACnB,MAAM;SACP;KACF;IAED,IAAI,KAAK,GAAG,GAAG,EAAE;QACf,OAAO,EAAE,CAAC;KACX;IACD,OAAO,GAAG,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,GAAG,KAAK,GAAG,CAAC,CAAC,CAAC;AAC3C,CAAC;AAED,0BAA0B;AAC1B,gBAAgB;AAChB,YAAY;AACZ,MAAM,UAAU,QAAQ,CAAC,IAAY,EAAE,EAAU;IAC/C,sCAAsC;IACtC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IAC/B,EAAE,GAAG,OAAO,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IAC3B,qCAAqC;IAErC,IAAM,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;IACxC,IAAM,OAAO,GAAG,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;IAEpC,IAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;IAC1D,IAAI,eAAe,GAAG,MAAM,CAAC;IAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;QAC/B,IAAI,SAAS,CAAC,CAAC,CAAC,KAAK,OAAO,CAAC,CAAC,CAAC,EAAE;YAC/B,eAAe,GAAG,CAAC,CAAC;YACpB,MAAM;SACP;KACF;IAED,IAAI,WAAW,GAAG,EAAE,CAAC;IACrB,KAAK,IAAI,CAAC,GAAG,eAAe,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACvD,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KACxB;IAED,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC;IAEjE,OAAO,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAC/B,CAAC;AAED,uBAAuB;AACvB,gBAAgB;AAChB,YAAY;AACZ,MAAM,UAAU,aAAa,CAAC,IAAY;IACxC,IAAM,cAAc,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC;IACxC,IAAM,aAAa,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC;IAE9C,qBAAqB;IACrB,IAAI,cAAc,GAAG,cAAc,CACjC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,CAAC,EAAH,CAAG,CAAC,EAChC,CAAC,cAAc,CAChB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAEZ,IAAI,CAAC,cAAc,IAAI,CAAC,cAAc,EAAE;QACtC,cAAc,GAAG,GAAG,CAAC;KACtB;IACD,IAAI,cAAc,IAAI,aAAa,EAAE;QACnC,cAAc,IAAI,GAAG,CAAC;KACvB;IAED,OAAO,CAAC,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,cAAc,CAAC;AACtD,CAAC;AAED,gBAAgB;AAChB,YAAY;AACZ,MAAM,UAAU,UAAU,CAAC,IAAY;IACrC,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC;AAChC,CAAC;AAED,gBAAgB;AAChB,YAAY;AACZ,MAAM,UAAU,IAAI;IAAC,cAAiB;SAAjB,UAAiB,EAAjB,qBAAiB,EAAjB,IAAiB;QAAjB,yBAAiB;;IACpC,OAAO,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;AACvC,CAAC;AAED,YAAY;AACZ,MAAM,UAAU,OAAO,CAAC,IAAY;IAClC,IAAM,MAAM,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC;IAC/B,IAAM,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;IACvB,IAAI,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;IAEpB,IAAI,CAAC,IAAI,IAAI,CAAC,GAAG,EAAE;QACjB,wBAAwB;QACxB,OAAO,GAAG,CAAC;KACZ;IAED,IAAI,GAAG,EAAE;QACP,yCAAyC;QACzC,GAAG,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;KACrC;IAED,OAAO,IAAI,GAAG,GAAG,CAAC;AACpB,CAAC;AAED,YAAY;AACZ,MAAM,UAAU,QAAQ,CAAC,IAAY,EAAE,GAAY;IACjD,IAAI,CAAC,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3B,IAAI,GAAG,IAAI,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAC5C,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC;KACxC;IACD,OAAO,CAAC,CAAC;AACX,CAAC","sourcesContent":["// Slightly modified (no IE8 support, ES6) and transcribed to TypeScript\n// https://raw.githubusercontent.com/calvinmetcalf/rollup-plugin-node-builtins/master/src/es6/path.js\n\n/** JSDoc */\nfunction normalizeArray(parts: string[], allowAboveRoot?: boolean): string[] {\n  // if the path tries to go above the root, `up` ends up > 0\n  let up = 0;\n  for (let i = parts.length - 1; i >= 0; i--) {\n    const last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      // eslint-disable-next-line no-plusplus\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      // eslint-disable-next-line no-plusplus\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    // eslint-disable-next-line no-plusplus\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nconst splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^/]+?|)(\\.[^./]*|))(?:[/]*)$/;\n/** JSDoc */\nfunction splitPath(filename: string): string[] {\n  const parts = splitPathRe.exec(filename);\n  return parts ? parts.slice(1) : [];\n}\n\n// path.resolve([from ...], to)\n// posix version\n/** JSDoc */\nexport function resolve(...args: string[]): string {\n  let resolvedPath = '';\n  let resolvedAbsolute = false;\n\n  for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    const path = i >= 0 ? args[i] : '/';\n\n    // Skip empty entries\n    if (!path) {\n      continue;\n    }\n\n    resolvedPath = `${path}/${resolvedPath}`;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(\n    resolvedPath.split('/').filter(p => !!p),\n    !resolvedAbsolute,\n  ).join('/');\n\n  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n}\n\n/** JSDoc */\nfunction trim(arr: string[]): string[] {\n  let start = 0;\n  for (; start < arr.length; start++) {\n    if (arr[start] !== '') {\n      break;\n    }\n  }\n\n  let end = arr.length - 1;\n  for (; end >= 0; end--) {\n    if (arr[end] !== '') {\n      break;\n    }\n  }\n\n  if (start > end) {\n    return [];\n  }\n  return arr.slice(start, end - start + 1);\n}\n\n// path.relative(from, to)\n// posix version\n/** JSDoc */\nexport function relative(from: string, to: string): string {\n  /* eslint-disable no-param-reassign */\n  from = resolve(from).substr(1);\n  to = resolve(to).substr(1);\n  /* eslint-enable no-param-reassign */\n\n  const fromParts = trim(from.split('/'));\n  const toParts = trim(to.split('/'));\n\n  const length = Math.min(fromParts.length, toParts.length);\n  let samePartsLength = length;\n  for (let i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  let outputParts = [];\n  for (let i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n}\n\n// path.normalize(path)\n// posix version\n/** JSDoc */\nexport function normalizePath(path: string): string {\n  const isPathAbsolute = isAbsolute(path);\n  const trailingSlash = path.substr(-1) === '/';\n\n  // Normalize the path\n  let normalizedPath = normalizeArray(\n    path.split('/').filter(p => !!p),\n    !isPathAbsolute,\n  ).join('/');\n\n  if (!normalizedPath && !isPathAbsolute) {\n    normalizedPath = '.';\n  }\n  if (normalizedPath && trailingSlash) {\n    normalizedPath += '/';\n  }\n\n  return (isPathAbsolute ? '/' : '') + normalizedPath;\n}\n\n// posix version\n/** JSDoc */\nexport function isAbsolute(path: string): boolean {\n  return path.charAt(0) === '/';\n}\n\n// posix version\n/** JSDoc */\nexport function join(...args: string[]): string {\n  return normalizePath(args.join('/'));\n}\n\n/** JSDoc */\nexport function dirname(path: string): string {\n  const result = splitPath(path);\n  const root = result[0];\n  let dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n}\n\n/** JSDoc */\nexport function basename(path: string, ext?: string): string {\n  let f = splitPath(path)[2];\n  if (ext && f.substr(ext.length * -1) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n}\n"]}export declare const setPrototypeOf: (o: any, proto: object | null) => any;
//# sourceMappingURL=polyfill.d.ts.map{"version":3,"file":"polyfill.d.ts","sourceRoot":"","sources":["../../src/polyfill.ts"],"names":[],"mappings":"AAAA,eAAO,MAAM,cAAc,uCACmE,CAAC"}export var setPrototypeOf = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
/**
 * setPrototypeOf polyfill using __proto__
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function setProtoOf(obj, proto) {
    // @ts-ignore __proto__ does not exist on obj
    obj.__proto__ = proto;
    return obj;
}
/**
 * setPrototypeOf polyfill using mixin
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function mixinProperties(obj, proto) {
    for (var prop in proto) {
        if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
            // @ts-ignore typescript complains about indexing so we remove
            obj[prop] = proto[prop];
        }
    }
    return obj;
}
//# sourceMappingURL=polyfill.js.map{"version":3,"file":"polyfill.js","sourceRoot":"","sources":["../../src/polyfill.ts"],"names":[],"mappings":"AAAA,MAAM,CAAC,IAAM,cAAc,GACzB,MAAM,CAAC,cAAc,IAAI,CAAC,EAAE,SAAS,EAAE,EAAE,EAAE,YAAY,KAAK,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC;AAE/F;;GAEG;AACH,wDAAwD;AACxD,SAAS,UAAU,CAAiC,GAAY,EAAE,KAAa;IAC7E,6CAA6C;IAC7C,GAAG,CAAC,SAAS,GAAG,KAAK,CAAC;IACtB,OAAO,GAAuB,CAAC;AACjC,CAAC;AAED;;GAEG;AACH,wDAAwD;AACxD,SAAS,eAAe,CAAiC,GAAY,EAAE,KAAa;IAClF,KAAK,IAAM,IAAI,IAAI,KAAK,EAAE;QACxB,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,EAAE;YACpD,8DAA8D;YAC9D,GAAG,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;SACzB;KACF;IAED,OAAO,GAAuB,CAAC;AACjC,CAAC","sourcesContent":["export const setPrototypeOf =\n  Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);\n\n/**\n * setPrototypeOf polyfill using __proto__\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction setProtoOf<TTarget extends object, TProto>(obj: TTarget, proto: TProto): TTarget & TProto {\n  // @ts-ignore __proto__ does not exist on obj\n  obj.__proto__ = proto;\n  return obj as TTarget & TProto;\n}\n\n/**\n * setPrototypeOf polyfill using mixin\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction mixinProperties<TTarget extends object, TProto>(obj: TTarget, proto: TProto): TTarget & TProto {\n  for (const prop in proto) {\n    if (!Object.prototype.hasOwnProperty.call(obj, prop)) {\n      // @ts-ignore typescript complains about indexing so we remove\n      obj[prop] = proto[prop];\n    }\n  }\n\n  return obj as TTarget & TProto;\n}\n"]}export interface PromiseBuffer<T> {
    $: Array<PromiseLike<T>>;
    add(taskProducer: () => PromiseLike<T>): PromiseLike<T>;
    drain(timeout?: number): PromiseLike<boolean>;
}
/**
 * Creates an new PromiseBuffer object with the specified limit
 * @param limit max number of promises that can be stored in the buffer
 */
export declare function makePromiseBuffer<T>(limit?: number): PromiseBuffer<T>;
//# sourceMappingURL=promisebuffer.d.ts.map{"version":3,"file":"promisebuffer.d.ts","sourceRoot":"","sources":["../../src/promisebuffer.ts"],"names":[],"mappings":"AAGA,MAAM,WAAW,aAAa,CAAC,CAAC;IAG9B,CAAC,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;IACzB,GAAG,CAAC,YAAY,EAAE,MAAM,WAAW,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;IACxD,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC;CAC/C;AAED;;;GAGG;AACH,wBAAgB,iBAAiB,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE,MAAM,GAAG,aAAa,CAAC,CAAC,CAAC,CA4FrE"}import { SentryError } from './error';
import { rejectedSyncPromise, resolvedSyncPromise, SyncPromise } from './syncpromise';
/**
 * Creates an new PromiseBuffer object with the specified limit
 * @param limit max number of promises that can be stored in the buffer
 */
export function makePromiseBuffer(limit) {
    var buffer = [];
    function isReady() {
        return limit === undefined || buffer.length < limit;
    }
    /**
     * Remove a promise from the queue.
     *
     * @param task Can be any PromiseLike<T>
     * @returns Removed promise.
     */
    function remove(task) {
        return buffer.splice(buffer.indexOf(task), 1)[0];
    }
    /**
     * Add a promise (representing an in-flight action) to the queue, and set it to remove itself on fulfillment.
     *
     * @param taskProducer A function producing any PromiseLike<T>; In previous versions this used to be `task:
     *        PromiseLike<T>`, but under that model, Promises were instantly created on the call-site and their executor
     *        functions therefore ran immediately. Thus, even if the buffer was full, the action still happened. By
     *        requiring the promise to be wrapped in a function, we can defer promise creation until after the buffer
     *        limit check.
     * @returns The original promise.
     */
    function add(taskProducer) {
        if (!isReady()) {
            return rejectedSyncPromise(new SentryError('Not adding Promise due to buffer limit reached.'));
        }
        // start the task and add its promise to the queue
        var task = taskProducer();
        if (buffer.indexOf(task) === -1) {
            buffer.push(task);
        }
        void task
            .then(function () { return remove(task); })
            // Use `then(null, rejectionHandler)` rather than `catch(rejectionHandler)` so that we can use `PromiseLike`
            // rather than `Promise`. `PromiseLike` doesn't have a `.catch` method, making its polyfill smaller. (ES5 didn't
            // have promises, so TS has to polyfill when down-compiling.)
            .then(null, function () {
            return remove(task).then(null, function () {
                // We have to add another catch here because `remove()` starts a new promise chain.
            });
        });
        return task;
    }
    /**
     * Wait for all promises in the queue to resolve or for timeout to expire, whichever comes first.
     *
     * @param timeout The time, in ms, after which to resolve to `false` if the queue is still non-empty. Passing `0` (or
     * not passing anything) will make the promise wait as long as it takes for the queue to drain before resolving to
     * `true`.
     * @returns A promise which will resolve to `true` if the queue is already empty or drains before the timeout, and
     * `false` otherwise
     */
    function drain(timeout) {
        return new SyncPromise(function (resolve, reject) {
            var counter = buffer.length;
            if (!counter) {
                return resolve(true);
            }
            // wait for `timeout` ms and then resolve to `false` (if not cancelled first)
            var capturedSetTimeout = setTimeout(function () {
                if (timeout && timeout > 0) {
                    resolve(false);
                }
            }, timeout);
            // if all promises resolve in time, cancel the timer and resolve to `true`
            buffer.forEach(function (item) {
                void resolvedSyncPromise(item).then(function () {
                    // eslint-disable-next-line no-plusplus
                    if (!--counter) {
                        clearTimeout(capturedSetTimeout);
                        resolve(true);
                    }
                }, reject);
            });
        });
    }
    return {
        $: buffer,
        add: add,
        drain: drain,
    };
}
//# sourceMappingURL=promisebuffer.js.map{"version":3,"file":"promisebuffer.js","sourceRoot":"","sources":["../../src/promisebuffer.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,SAAS,CAAC;AACtC,OAAO,EAAE,mBAAmB,EAAE,mBAAmB,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAUtF;;;GAGG;AACH,MAAM,UAAU,iBAAiB,CAAI,KAAc;IACjD,IAAM,MAAM,GAA0B,EAAE,CAAC;IAEzC,SAAS,OAAO;QACd,OAAO,KAAK,KAAK,SAAS,IAAI,MAAM,CAAC,MAAM,GAAG,KAAK,CAAC;IACtD,CAAC;IAED;;;;;OAKG;IACH,SAAS,MAAM,CAAC,IAAoB;QAClC,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACnD,CAAC;IAED;;;;;;;;;OASG;IACH,SAAS,GAAG,CAAC,YAAkC;QAC7C,IAAI,CAAC,OAAO,EAAE,EAAE;YACd,OAAO,mBAAmB,CAAC,IAAI,WAAW,CAAC,iDAAiD,CAAC,CAAC,CAAC;SAChG;QAED,kDAAkD;QAClD,IAAM,IAAI,GAAG,YAAY,EAAE,CAAC;QAC5B,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;YAC/B,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACnB;QACD,KAAK,IAAI;aACN,IAAI,CAAC,cAAM,OAAA,MAAM,CAAC,IAAI,CAAC,EAAZ,CAAY,CAAC;YACzB,4GAA4G;YAC5G,gHAAgH;YAChH,6DAA6D;aAC5D,IAAI,CAAC,IAAI,EAAE;YACV,OAAA,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE;gBACtB,mFAAmF;YACrF,CAAC,CAAC;QAFF,CAEE,CACH,CAAC;QACJ,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;;;;OAQG;IACH,SAAS,KAAK,CAAC,OAAgB;QAC7B,OAAO,IAAI,WAAW,CAAU,UAAC,OAAO,EAAE,MAAM;YAC9C,IAAI,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC;YAE5B,IAAI,CAAC,OAAO,EAAE;gBACZ,OAAO,OAAO,CAAC,IAAI,CAAC,CAAC;aACtB;YAED,6EAA6E;YAC7E,IAAM,kBAAkB,GAAG,UAAU,CAAC;gBACpC,IAAI,OAAO,IAAI,OAAO,GAAG,CAAC,EAAE;oBAC1B,OAAO,CAAC,KAAK,CAAC,CAAC;iBAChB;YACH,CAAC,EAAE,OAAO,CAAC,CAAC;YAEZ,0EAA0E;YAC1E,MAAM,CAAC,OAAO,CAAC,UAAA,IAAI;gBACjB,KAAK,mBAAmB,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC;oBAClC,uCAAuC;oBACvC,IAAI,CAAC,EAAE,OAAO,EAAE;wBACd,YAAY,CAAC,kBAAkB,CAAC,CAAC;wBACjC,OAAO,CAAC,IAAI,CAAC,CAAC;qBACf;gBACH,CAAC,EAAE,MAAM,CAAC,CAAC;YACb,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAED,OAAO;QACL,CAAC,EAAE,MAAM;QACT,GAAG,KAAA;QACH,KAAK,OAAA;KACN,CAAC;AACJ,CAAC","sourcesContent":["import { SentryError } from './error';\nimport { rejectedSyncPromise, resolvedSyncPromise, SyncPromise } from './syncpromise';\n\nexport interface PromiseBuffer<T> {\n  // exposes the internal array so tests can assert on the state of it.\n  // XXX: this really should not be public api.\n  $: Array<PromiseLike<T>>;\n  add(taskProducer: () => PromiseLike<T>): PromiseLike<T>;\n  drain(timeout?: number): PromiseLike<boolean>;\n}\n\n/**\n * Creates an new PromiseBuffer object with the specified limit\n * @param limit max number of promises that can be stored in the buffer\n */\nexport function makePromiseBuffer<T>(limit?: number): PromiseBuffer<T> {\n  const buffer: Array<PromiseLike<T>> = [];\n\n  function isReady(): boolean {\n    return limit === undefined || buffer.length < limit;\n  }\n\n  /**\n   * Remove a promise from the queue.\n   *\n   * @param task Can be any PromiseLike<T>\n   * @returns Removed promise.\n   */\n  function remove(task: PromiseLike<T>): PromiseLike<T> {\n    return buffer.splice(buffer.indexOf(task), 1)[0];\n  }\n\n  /**\n   * Add a promise (representing an in-flight action) to the queue, and set it to remove itself on fulfillment.\n   *\n   * @param taskProducer A function producing any PromiseLike<T>; In previous versions this used to be `task:\n   *        PromiseLike<T>`, but under that model, Promises were instantly created on the call-site and their executor\n   *        functions therefore ran immediately. Thus, even if the buffer was full, the action still happened. By\n   *        requiring the promise to be wrapped in a function, we can defer promise creation until after the buffer\n   *        limit check.\n   * @returns The original promise.\n   */\n  function add(taskProducer: () => PromiseLike<T>): PromiseLike<T> {\n    if (!isReady()) {\n      return rejectedSyncPromise(new SentryError('Not adding Promise due to buffer limit reached.'));\n    }\n\n    // start the task and add its promise to the queue\n    const task = taskProducer();\n    if (buffer.indexOf(task) === -1) {\n      buffer.push(task);\n    }\n    void task\n      .then(() => remove(task))\n      // Use `then(null, rejectionHandler)` rather than `catch(rejectionHandler)` so that we can use `PromiseLike`\n      // rather than `Promise`. `PromiseLike` doesn't have a `.catch` method, making its polyfill smaller. (ES5 didn't\n      // have promises, so TS has to polyfill when down-compiling.)\n      .then(null, () =>\n        remove(task).then(null, () => {\n          // We have to add another catch here because `remove()` starts a new promise chain.\n        }),\n      );\n    return task;\n  }\n\n  /**\n   * Wait for all promises in the queue to resolve or for timeout to expire, whichever comes first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the queue is still non-empty. Passing `0` (or\n   * not passing anything) will make the promise wait as long as it takes for the queue to drain before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if the queue is already empty or drains before the timeout, and\n   * `false` otherwise\n   */\n  function drain(timeout?: number): PromiseLike<boolean> {\n    return new SyncPromise<boolean>((resolve, reject) => {\n      let counter = buffer.length;\n\n      if (!counter) {\n        return resolve(true);\n      }\n\n      // wait for `timeout` ms and then resolve to `false` (if not cancelled first)\n      const capturedSetTimeout = setTimeout(() => {\n        if (timeout && timeout > 0) {\n          resolve(false);\n        }\n      }, timeout);\n\n      // if all promises resolve in time, cancel the timer and resolve to `true`\n      buffer.forEach(item => {\n        void resolvedSyncPromise(item).then(() => {\n          // eslint-disable-next-line no-plusplus\n          if (!--counter) {\n            clearTimeout(capturedSetTimeout);\n            resolve(true);\n          }\n        }, reject);\n      });\n    });\n  }\n\n  return {\n    $: buffer,\n    add,\n    drain,\n  };\n}\n"]}export declare type RateLimits = Record<string, number>;
export declare const DEFAULT_RETRY_AFTER: number;
/**
 * Extracts Retry-After value from the request header or returns default value
 * @param header string representation of 'Retry-After' header
 * @param now current unix timestamp
 *
 */
export declare function parseRetryAfterHeader(header: string, now?: number): number;
/**
 * Gets the time that given category is disabled until for rate limiting
 */
export declare function disabledUntil(limits: RateLimits, category: string): number;
/**
 * Checks if a category is rate limited
 */
export declare function isRateLimited(limits: RateLimits, category: string, now?: number): boolean;
/**
 * Update ratelimits from incoming headers.
 * Returns true if headers contains a non-empty rate limiting header.
 */
export declare function updateRateLimits(limits: RateLimits, headers: Record<string, string | null | undefined>, now?: number): RateLimits;
//# sourceMappingURL=ratelimit.d.ts.map{"version":3,"file":"ratelimit.d.ts","sourceRoot":"","sources":["../../src/ratelimit.ts"],"names":[],"mappings":"AACA,oBAAY,UAAU,GAAG,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;AAEhD,eAAO,MAAM,mBAAmB,QAAY,CAAC;AAE7C;;;;;GAKG;AACH,wBAAgB,qBAAqB,CAAC,MAAM,EAAE,MAAM,EAAE,GAAG,GAAE,MAAmB,GAAG,MAAM,CAYtF;AAED;;GAEG;AACH,wBAAgB,aAAa,CAAC,MAAM,EAAE,UAAU,EAAE,QAAQ,EAAE,MAAM,GAAG,MAAM,CAE1E;AAED;;GAEG;AACH,wBAAgB,aAAa,CAAC,MAAM,EAAE,UAAU,EAAE,QAAQ,EAAE,MAAM,EAAE,GAAG,GAAE,MAAmB,GAAG,OAAO,CAErG;AAED;;;GAGG;AACH,wBAAgB,gBAAgB,CAC9B,MAAM,EAAE,UAAU,EAClB,OAAO,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,GAAG,IAAI,GAAG,SAAS,CAAC,EAClD,GAAG,GAAE,MAAmB,GACvB,UAAU,CAwCZ"}import { __assign, __values } from "tslib";
export var DEFAULT_RETRY_AFTER = 60 * 1000; // 60 seconds
/**
 * Extracts Retry-After value from the request header or returns default value
 * @param header string representation of 'Retry-After' header
 * @param now current unix timestamp
 *
 */
export function parseRetryAfterHeader(header, now) {
    if (now === void 0) { now = Date.now(); }
    var headerDelay = parseInt("" + header, 10);
    if (!isNaN(headerDelay)) {
        return headerDelay * 1000;
    }
    var headerDate = Date.parse("" + header);
    if (!isNaN(headerDate)) {
        return headerDate - now;
    }
    return DEFAULT_RETRY_AFTER;
}
/**
 * Gets the time that given category is disabled until for rate limiting
 */
export function disabledUntil(limits, category) {
    return limits[category] || limits.all || 0;
}
/**
 * Checks if a category is rate limited
 */
export function isRateLimited(limits, category, now) {
    if (now === void 0) { now = Date.now(); }
    return disabledUntil(limits, category) > now;
}
/**
 * Update ratelimits from incoming headers.
 * Returns true if headers contains a non-empty rate limiting header.
 */
export function updateRateLimits(limits, headers, now) {
    var e_1, _a, e_2, _b;
    if (now === void 0) { now = Date.now(); }
    var updatedRateLimits = __assign({}, limits);
    // "The name is case-insensitive."
    // https://developer.mozilla.org/en-US/docs/Web/API/Headers/get
    var rateLimitHeader = headers['x-sentry-rate-limits'];
    var retryAfterHeader = headers['retry-after'];
    if (rateLimitHeader) {
        try {
            /**
             * rate limit headers are of the form
             *     <header>,<header>,..
             * where each <header> is of the form
             *     <retry_after>: <categories>: <scope>: <reason_code>
             * where
             *     <retry_after> is a delay in seconds
             *     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form
             *         <category>;<category>;...
             *     <scope> is what's being limited (org, project, or key) - ignored by SDK
             *     <reason_code> is an arbitrary string like "org_quota" - ignored by SDK
             */
            for (var _c = __values(rateLimitHeader.trim().split(',')), _d = _c.next(); !_d.done; _d = _c.next()) {
                var limit = _d.value;
                var parameters = limit.split(':', 2);
                var headerDelay = parseInt(parameters[0], 10);
                var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default
                if (!parameters[1]) {
                    updatedRateLimits.all = now + delay;
                }
                else {
                    try {
                        for (var _e = (e_2 = void 0, __values(parameters[1].split(';'))), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var category = _f.value;
                            updatedRateLimits[category] = now + delay;
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    else if (retryAfterHeader) {
        updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
    }
    return updatedRateLimits;
}
//# sourceMappingURL=ratelimit.js.map{"version":3,"file":"ratelimit.js","sourceRoot":"","sources":["../../src/ratelimit.ts"],"names":[],"mappings":";AAGA,MAAM,CAAC,IAAM,mBAAmB,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC,aAAa;AAE3D;;;;;GAKG;AACH,MAAM,UAAU,qBAAqB,CAAC,MAAc,EAAE,GAAwB;IAAxB,oBAAA,EAAA,MAAc,IAAI,CAAC,GAAG,EAAE;IAC5E,IAAM,WAAW,GAAG,QAAQ,CAAC,KAAG,MAAQ,EAAE,EAAE,CAAC,CAAC;IAC9C,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE;QACvB,OAAO,WAAW,GAAG,IAAI,CAAC;KAC3B;IAED,IAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,KAAG,MAAQ,CAAC,CAAC;IAC3C,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE;QACtB,OAAO,UAAU,GAAG,GAAG,CAAC;KACzB;IAED,OAAO,mBAAmB,CAAC;AAC7B,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,aAAa,CAAC,MAAkB,EAAE,QAAgB;IAChE,OAAO,MAAM,CAAC,QAAQ,CAAC,IAAI,MAAM,CAAC,GAAG,IAAI,CAAC,CAAC;AAC7C,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,aAAa,CAAC,MAAkB,EAAE,QAAgB,EAAE,GAAwB;IAAxB,oBAAA,EAAA,MAAc,IAAI,CAAC,GAAG,EAAE;IAC1F,OAAO,aAAa,CAAC,MAAM,EAAE,QAAQ,CAAC,GAAG,GAAG,CAAC;AAC/C,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,gBAAgB,CAC9B,MAAkB,EAClB,OAAkD,EAClD,GAAwB;;IAAxB,oBAAA,EAAA,MAAc,IAAI,CAAC,GAAG,EAAE;IAExB,IAAM,iBAAiB,gBAClB,MAAM,CACV,CAAC;IAEF,kCAAkC;IAClC,+DAA+D;IAC/D,IAAM,eAAe,GAAG,OAAO,CAAC,sBAAsB,CAAC,CAAC;IACxD,IAAM,gBAAgB,GAAG,OAAO,CAAC,aAAa,CAAC,CAAC;IAEhD,IAAI,eAAe,EAAE;;YACnB;;;;;;;;;;;eAWG;YACH,KAAoB,IAAA,KAAA,SAAA,eAAe,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA,gBAAA,4BAAE;gBAAlD,IAAM,KAAK,WAAA;gBACd,IAAM,UAAU,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;gBACvC,IAAM,WAAW,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;gBAChD,IAAM,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC,gBAAgB;gBAC/E,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE;oBAClB,iBAAiB,CAAC,GAAG,GAAG,GAAG,GAAG,KAAK,CAAC;iBACrC;qBAAM;;wBACL,KAAuB,IAAA,oBAAA,SAAA,UAAU,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA,CAAA,gBAAA,4BAAE;4BAA5C,IAAM,QAAQ,WAAA;4BACjB,iBAAiB,CAAC,QAAQ,CAAC,GAAG,GAAG,GAAG,KAAK,CAAC;yBAC3C;;;;;;;;;iBACF;aACF;;;;;;;;;KACF;SAAM,IAAI,gBAAgB,EAAE;QAC3B,iBAAiB,CAAC,GAAG,GAAG,GAAG,GAAG,qBAAqB,CAAC,gBAAgB,EAAE,GAAG,CAAC,CAAC;KAC5E;IAED,OAAO,iBAAiB,CAAC;AAC3B,CAAC","sourcesContent":["// Keeping the key broad until we add the new transports\nexport type RateLimits = Record<string, number>;\n\nexport const DEFAULT_RETRY_AFTER = 60 * 1000; // 60 seconds\n\n/**\n * Extracts Retry-After value from the request header or returns default value\n * @param header string representation of 'Retry-After' header\n * @param now current unix timestamp\n *\n */\nexport function parseRetryAfterHeader(header: string, now: number = Date.now()): number {\n  const headerDelay = parseInt(`${header}`, 10);\n  if (!isNaN(headerDelay)) {\n    return headerDelay * 1000;\n  }\n\n  const headerDate = Date.parse(`${header}`);\n  if (!isNaN(headerDate)) {\n    return headerDate - now;\n  }\n\n  return DEFAULT_RETRY_AFTER;\n}\n\n/**\n * Gets the time that given category is disabled until for rate limiting\n */\nexport function disabledUntil(limits: RateLimits, category: string): number {\n  return limits[category] || limits.all || 0;\n}\n\n/**\n * Checks if a category is rate limited\n */\nexport function isRateLimited(limits: RateLimits, category: string, now: number = Date.now()): boolean {\n  return disabledUntil(limits, category) > now;\n}\n\n/**\n * Update ratelimits from incoming headers.\n * Returns true if headers contains a non-empty rate limiting header.\n */\nexport function updateRateLimits(\n  limits: RateLimits,\n  headers: Record<string, string | null | undefined>,\n  now: number = Date.now(),\n): RateLimits {\n  const updatedRateLimits: RateLimits = {\n    ...limits,\n  };\n\n  // \"The name is case-insensitive.\"\n  // https://developer.mozilla.org/en-US/docs/Web/API/Headers/get\n  const rateLimitHeader = headers['x-sentry-rate-limits'];\n  const retryAfterHeader = headers['retry-after'];\n\n  if (rateLimitHeader) {\n    /**\n     * rate limit headers are of the form\n     *     <header>,<header>,..\n     * where each <header> is of the form\n     *     <retry_after>: <categories>: <scope>: <reason_code>\n     * where\n     *     <retry_after> is a delay in seconds\n     *     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n     *         <category>;<category>;...\n     *     <scope> is what's being limited (org, project, or key) - ignored by SDK\n     *     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n     */\n    for (const limit of rateLimitHeader.trim().split(',')) {\n      const parameters = limit.split(':', 2);\n      const headerDelay = parseInt(parameters[0], 10);\n      const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n      if (!parameters[1]) {\n        updatedRateLimits.all = now + delay;\n      } else {\n        for (const category of parameters[1].split(';')) {\n          updatedRateLimits[category] = now + delay;\n        }\n      }\n    }\n  } else if (retryAfterHeader) {\n    updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);\n  }\n\n  return updatedRateLimits;\n}\n"]}import { Severity } from '@sentry/types';
import { SeverityLevel } from './enums';
/**
 * Converts a string-based level into a {@link Severity}.
 *
 * @param level string representation of Severity
 * @returns Severity
 */
export declare function severityFromString(level: SeverityLevel | string): Severity;
//# sourceMappingURL=severity.d.ts.map{"version":3,"file":"severity.d.ts","sourceRoot":"","sources":["../../src/severity.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,eAAe,CAAC;AAEzC,OAAO,EAAE,aAAa,EAAkB,MAAM,SAAS,CAAC;AAKxD;;;;;GAKG;AACH,wBAAgB,kBAAkB,CAAC,KAAK,EAAE,aAAa,GAAG,MAAM,GAAG,QAAQ,CAM1E"}import { Severity } from '@sentry/types';
import { SeverityLevels } from './enums';
function isSupportedSeverity(level) {
    return SeverityLevels.indexOf(level) !== -1;
}
/**
 * Converts a string-based level into a {@link Severity}.
 *
 * @param level string representation of Severity
 * @returns Severity
 */
export function severityFromString(level) {
    if (level === 'warn')
        return Severity.Warning;
    if (isSupportedSeverity(level)) {
        return level;
    }
    return Severity.Log;
}
//# sourceMappingURL=severity.js.map{"version":3,"file":"severity.js","sourceRoot":"","sources":["../../src/severity.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,eAAe,CAAC;AAEzC,OAAO,EAAiB,cAAc,EAAE,MAAM,SAAS,CAAC;AAExD,SAAS,mBAAmB,CAAC,KAAa;IACxC,OAAO,cAAc,CAAC,OAAO,CAAC,KAAsB,CAAC,KAAK,CAAC,CAAC,CAAC;AAC/D,CAAC;AACD;;;;;GAKG;AACH,MAAM,UAAU,kBAAkB,CAAC,KAA6B;IAC9D,IAAI,KAAK,KAAK,MAAM;QAAE,OAAO,QAAQ,CAAC,OAAO,CAAC;IAC9C,IAAI,mBAAmB,CAAC,KAAK,CAAC,EAAE;QAC9B,OAAO,KAAK,CAAC;KACd;IACD,OAAO,QAAQ,CAAC,GAAG,CAAC;AACtB,CAAC","sourcesContent":["import { Severity } from '@sentry/types';\n\nimport { SeverityLevel, SeverityLevels } from './enums';\n\nfunction isSupportedSeverity(level: string): level is Severity {\n  return SeverityLevels.indexOf(level as SeverityLevel) !== -1;\n}\n/**\n * Converts a string-based level into a {@link Severity}.\n *\n * @param level string representation of Severity\n * @returns Severity\n */\nexport function severityFromString(level: SeverityLevel | string): Severity {\n  if (level === 'warn') return Severity.Warning;\n  if (isSupportedSeverity(level)) {\n    return level;\n  }\n  return Severity.Log;\n}\n"]}import { StackFrame } from '@sentry/types';
export declare type StackParser = (stack: string, skipFirst?: number) => StackFrame[];
export declare type StackLineParserFn = (line: string) => StackFrame | undefined;
export declare type StackLineParser = [number, StackLineParserFn];
/**
 * Creates a stack parser with the supplied line parsers
 *
 * StackFrames are returned in the correct order for Sentry Exception
 * frames and with Sentry SDK internal frames removed from the top and bottom
 *
 */
export declare function createStackParser(...parsers: StackLineParser[]): StackParser;
/**
 * @hidden
 */
export declare function stripSentryFramesAndReverse(stack: StackFrame[]): StackFrame[];
/**
 * Safely extract function name from itself
 */
export declare function getFunctionName(fn: unknown): string;
//# sourceMappingURL=stacktrace.d.ts.map{"version":3,"file":"stacktrace.d.ts","sourceRoot":"","sources":["../../src/stacktrace.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAI3C,oBAAY,WAAW,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,SAAS,CAAC,EAAE,MAAM,KAAK,UAAU,EAAE,CAAC;AAC9E,oBAAY,iBAAiB,GAAG,CAAC,IAAI,EAAE,MAAM,KAAK,UAAU,GAAG,SAAS,CAAC;AACzE,oBAAY,eAAe,GAAG,CAAC,MAAM,EAAE,iBAAiB,CAAC,CAAC;AAE1D;;;;;;GAMG;AACH,wBAAgB,iBAAiB,CAAC,GAAG,OAAO,EAAE,eAAe,EAAE,GAAG,WAAW,CAmB5E;AAED;;GAEG;AACH,wBAAgB,2BAA2B,CAAC,KAAK,EAAE,UAAU,EAAE,GAAG,UAAU,EAAE,CA6B7E;AAID;;GAEG;AACH,wBAAgB,eAAe,CAAC,EAAE,EAAE,OAAO,GAAG,MAAM,CAWnD"}import { __assign, __values } from "tslib";
var STACKTRACE_LIMIT = 50;
/**
 * Creates a stack parser with the supplied line parsers
 *
 * StackFrames are returned in the correct order for Sentry Exception
 * frames and with Sentry SDK internal frames removed from the top and bottom
 *
 */
export function createStackParser() {
    var parsers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        parsers[_i] = arguments[_i];
    }
    var sortedParsers = parsers.sort(function (a, b) { return a[0] - b[0]; }).map(function (p) { return p[1]; });
    return function (stack, skipFirst) {
        var e_1, _a, e_2, _b;
        if (skipFirst === void 0) { skipFirst = 0; }
        var frames = [];
        try {
            for (var _c = __values(stack.split('\n').slice(skipFirst)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var line = _d.value;
                try {
                    for (var sortedParsers_1 = (e_2 = void 0, __values(sortedParsers)), sortedParsers_1_1 = sortedParsers_1.next(); !sortedParsers_1_1.done; sortedParsers_1_1 = sortedParsers_1.next()) {
                        var parser = sortedParsers_1_1.value;
                        var frame = parser(line);
                        if (frame) {
                            frames.push(frame);
                            break;
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (sortedParsers_1_1 && !sortedParsers_1_1.done && (_b = sortedParsers_1.return)) _b.call(sortedParsers_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return stripSentryFramesAndReverse(frames);
    };
}
/**
 * @hidden
 */
export function stripSentryFramesAndReverse(stack) {
    if (!stack.length) {
        return [];
    }
    var localStack = stack;
    var firstFrameFunction = localStack[0].function || '';
    var lastFrameFunction = localStack[localStack.length - 1].function || '';
    // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)
    if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {
        localStack = localStack.slice(1);
    }
    // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)
    if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {
        localStack = localStack.slice(0, -1);
    }
    // The frame where the crash happened, should be the last entry in the array
    return localStack
        .slice(0, STACKTRACE_LIMIT)
        .map(function (frame) { return (__assign(__assign({}, frame), { filename: frame.filename || localStack[0].filename, function: frame.function || '?' })); })
        .reverse();
}
var defaultFunctionName = '<anonymous>';
/**
 * Safely extract function name from itself
 */
export function getFunctionName(fn) {
    try {
        if (!fn || typeof fn !== 'function') {
            return defaultFunctionName;
        }
        return fn.name || defaultFunctionName;
    }
    catch (e) {
        // Just accessing custom props in some Selenium environments
        // can cause a "Permission denied" exception (see raven-js#495).
        return defaultFunctionName;
    }
}
//# sourceMappingURL=stacktrace.js.map{"version":3,"file":"stacktrace.js","sourceRoot":"","sources":["../../src/stacktrace.ts"],"names":[],"mappings":";AAEA,IAAM,gBAAgB,GAAG,EAAE,CAAC;AAM5B;;;;;;GAMG;AACH,MAAM,UAAU,iBAAiB;IAAC,iBAA6B;SAA7B,UAA6B,EAA7B,qBAA6B,EAA7B,IAA6B;QAA7B,4BAA6B;;IAC7D,IAAM,aAAa,GAAG,OAAO,CAAC,IAAI,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAX,CAAW,CAAC,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,CAAC,CAAC,EAAJ,CAAI,CAAC,CAAC;IAEzE,OAAO,UAAC,KAAa,EAAE,SAAqB;;QAArB,0BAAA,EAAA,aAAqB;QAC1C,IAAM,MAAM,GAAiB,EAAE,CAAC;;YAEhC,KAAmB,IAAA,KAAA,SAAA,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,CAAA,gBAAA,4BAAE;gBAAlD,IAAM,IAAI,WAAA;;oBACb,KAAqB,IAAA,iCAAA,SAAA,aAAa,CAAA,CAAA,4CAAA,uEAAE;wBAA/B,IAAM,MAAM,0BAAA;wBACf,IAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;wBAE3B,IAAI,KAAK,EAAE;4BACT,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;4BACnB,MAAM;yBACP;qBACF;;;;;;;;;aACF;;;;;;;;;QAED,OAAO,2BAA2B,CAAC,MAAM,CAAC,CAAC;IAC7C,CAAC,CAAC;AACJ,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,2BAA2B,CAAC,KAAmB;IAC7D,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;QACjB,OAAO,EAAE,CAAC;KACX;IAED,IAAI,UAAU,GAAG,KAAK,CAAC;IAEvB,IAAM,kBAAkB,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC,QAAQ,IAAI,EAAE,CAAC;IACxD,IAAM,iBAAiB,GAAG,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,QAAQ,IAAI,EAAE,CAAC;IAE3E,mHAAmH;IACnH,IAAI,kBAAkB,CAAC,OAAO,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC,IAAI,kBAAkB,CAAC,OAAO,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC,EAAE;QAChH,UAAU,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KAClC;IAED,+HAA+H;IAC/H,IAAI,iBAAiB,CAAC,OAAO,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC,EAAE;QACrD,UAAU,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;KACtC;IAED,4EAA4E;IAC5E,OAAO,UAAU;SACd,KAAK,CAAC,CAAC,EAAE,gBAAgB,CAAC;SAC1B,GAAG,CAAC,UAAA,KAAK,IAAI,OAAA,uBACT,KAAK,KACR,QAAQ,EAAE,KAAK,CAAC,QAAQ,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,QAAQ,EAClD,QAAQ,EAAE,KAAK,CAAC,QAAQ,IAAI,GAAG,IAC/B,EAJY,CAIZ,CAAC;SACF,OAAO,EAAE,CAAC;AACf,CAAC;AAED,IAAM,mBAAmB,GAAG,aAAa,CAAC;AAE1C;;GAEG;AACH,MAAM,UAAU,eAAe,CAAC,EAAW;IACzC,IAAI;QACF,IAAI,CAAC,EAAE,IAAI,OAAO,EAAE,KAAK,UAAU,EAAE;YACnC,OAAO,mBAAmB,CAAC;SAC5B;QACD,OAAO,EAAE,CAAC,IAAI,IAAI,mBAAmB,CAAC;KACvC;IAAC,OAAO,CAAC,EAAE;QACV,4DAA4D;QAC5D,gEAAgE;QAChE,OAAO,mBAAmB,CAAC;KAC5B;AACH,CAAC","sourcesContent":["import { StackFrame } from '@sentry/types';\n\nconst STACKTRACE_LIMIT = 50;\n\nexport type StackParser = (stack: string, skipFirst?: number) => StackFrame[];\nexport type StackLineParserFn = (line: string) => StackFrame | undefined;\nexport type StackLineParser = [number, StackLineParserFn];\n\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */\nexport function createStackParser(...parsers: StackLineParser[]): StackParser {\n  const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);\n\n  return (stack: string, skipFirst: number = 0): StackFrame[] => {\n    const frames: StackFrame[] = [];\n\n    for (const line of stack.split('\\n').slice(skipFirst)) {\n      for (const parser of sortedParsers) {\n        const frame = parser(line);\n\n        if (frame) {\n          frames.push(frame);\n          break;\n        }\n      }\n    }\n\n    return stripSentryFramesAndReverse(frames);\n  };\n}\n\n/**\n * @hidden\n */\nexport function stripSentryFramesAndReverse(stack: StackFrame[]): StackFrame[] {\n  if (!stack.length) {\n    return [];\n  }\n\n  let localStack = stack;\n\n  const firstFrameFunction = localStack[0].function || '';\n  const lastFrameFunction = localStack[localStack.length - 1].function || '';\n\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  }\n\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {\n    localStack = localStack.slice(0, -1);\n  }\n\n  // The frame where the crash happened, should be the last entry in the array\n  return localStack\n    .slice(0, STACKTRACE_LIMIT)\n    .map(frame => ({\n      ...frame,\n      filename: frame.filename || localStack[0].filename,\n      function: frame.function || '?',\n    }))\n    .reverse();\n}\n\nconst defaultFunctionName = '<anonymous>';\n\n/**\n * Safely extract function name from itself\n */\nexport function getFunctionName(fn: unknown): string {\n  try {\n    if (!fn || typeof fn !== 'function') {\n      return defaultFunctionName;\n    }\n    return fn.name || defaultFunctionName;\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    return defaultFunctionName;\n  }\n}\n"]}import { EventStatus } from '@sentry/types';
/**
 * Converts an HTTP status code to sentry status {@link EventStatus}.
 *
 * @param code number HTTP status code
 * @returns EventStatus
 */
export declare function eventStatusFromHttpCode(code: number): EventStatus;
//# sourceMappingURL=status.d.ts.map{"version":3,"file":"status.d.ts","sourceRoot":"","sources":["../../src/status.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C;;;;;GAKG;AACH,wBAAgB,uBAAuB,CAAC,IAAI,EAAE,MAAM,GAAG,WAAW,CAkBjE"}/**
 * Converts an HTTP status code to sentry status {@link EventStatus}.
 *
 * @param code number HTTP status code
 * @returns EventStatus
 */
export function eventStatusFromHttpCode(code) {
    if (code >= 200 && code < 300) {
        return 'success';
    }
    if (code === 429) {
        return 'rate_limit';
    }
    if (code >= 400 && code < 500) {
        return 'invalid';
    }
    if (code >= 500) {
        return 'failed';
    }
    return 'unknown';
}
//# sourceMappingURL=status.js.map{"version":3,"file":"status.js","sourceRoot":"","sources":["../../src/status.ts"],"names":[],"mappings":"AACA;;;;;GAKG;AACH,MAAM,UAAU,uBAAuB,CAAC,IAAY;IAClD,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,EAAE;QAC7B,OAAO,SAAS,CAAC;KAClB;IAED,IAAI,IAAI,KAAK,GAAG,EAAE;QAChB,OAAO,YAAY,CAAC;KACrB;IAED,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,EAAE;QAC7B,OAAO,SAAS,CAAC;KAClB;IAED,IAAI,IAAI,IAAI,GAAG,EAAE;QACf,OAAO,QAAQ,CAAC;KACjB;IAED,OAAO,SAAS,CAAC;AACnB,CAAC","sourcesContent":["import { EventStatus } from '@sentry/types';\n/**\n * Converts an HTTP status code to sentry status {@link EventStatus}.\n *\n * @param code number HTTP status code\n * @returns EventStatus\n */\nexport function eventStatusFromHttpCode(code: number): EventStatus {\n  if (code >= 200 && code < 300) {\n    return 'success';\n  }\n\n  if (code === 429) {\n    return 'rate_limit';\n  }\n\n  if (code >= 400 && code < 500) {\n    return 'invalid';\n  }\n\n  if (code >= 500) {\n    return 'failed';\n  }\n\n  return 'unknown';\n}\n"]}/**
 * Truncates given string to the maximum characters count
 *
 * @param str An object that contains serializable values
 * @param max Maximum number of characters in truncated string (0 = unlimited)
 * @returns string Encoded
 */
export declare function truncate(str: string, max?: number): string;
/**
 * This is basically just `trim_line` from
 * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67
 *
 * @param str An object that contains serializable values
 * @param max Maximum number of characters in truncated string
 * @returns string Encoded
 */
export declare function snipLine(line: string, colno: number): string;
/**
 * Join values in array
 * @param input array of values to be joined together
 * @param delimiter string to be placed in-between values
 * @returns Joined values
 */
export declare function safeJoin(input: any[], delimiter?: string): string;
/**
 * Checks if the value matches a regex or includes the string
 * @param value The string value to be checked against
 * @param pattern Either a regex or a string that must be contained in value
 */
export declare function isMatchingPattern(value: string, pattern: RegExp | string): boolean;
/**
 * Given a string, escape characters which have meaning in the regex grammar, such that the result is safe to feed to
 * `new RegExp()`.
 *
 * Based on https://github.com/sindresorhus/escape-string-regexp. Vendored to a) reduce the size by skipping the runtime
 * type-checking, and b) ensure it gets down-compiled for old versions of Node (the published package only supports Node
 * 12+).
 *
 * @param regexString The string to escape
 * @returns An version of the string with all special regex characters escaped
 */
export declare function escapeStringForRegex(regexString: string): string;
//# sourceMappingURL=string.d.ts.map{"version":3,"file":"string.d.ts","sourceRoot":"","sources":["../../src/string.ts"],"names":[],"mappings":"AAEA;;;;;;GAMG;AACH,wBAAgB,QAAQ,CAAC,GAAG,EAAE,MAAM,EAAE,GAAG,GAAE,MAAU,GAAG,MAAM,CAK7D;AAED;;;;;;;GAOG;AACH,wBAAgB,QAAQ,CAAC,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,GAAG,MAAM,CAiC5D;AAED;;;;;GAKG;AAEH,wBAAgB,QAAQ,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE,SAAS,CAAC,EAAE,MAAM,GAAG,MAAM,CAiBjE;AAED;;;;GAIG;AACH,wBAAgB,iBAAiB,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,GAAG,MAAM,GAAG,OAAO,CAYlF;AAED;;;;;;;;;;GAUG;AACH,wBAAgB,oBAAoB,CAAC,WAAW,EAAE,MAAM,GAAG,MAAM,CAIhE"}import { isRegExp, isString } from './is';
/**
 * Truncates given string to the maximum characters count
 *
 * @param str An object that contains serializable values
 * @param max Maximum number of characters in truncated string (0 = unlimited)
 * @returns string Encoded
 */
export function truncate(str, max) {
    if (max === void 0) { max = 0; }
    if (typeof str !== 'string' || max === 0) {
        return str;
    }
    return str.length <= max ? str : str.substr(0, max) + "...";
}
/**
 * This is basically just `trim_line` from
 * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67
 *
 * @param str An object that contains serializable values
 * @param max Maximum number of characters in truncated string
 * @returns string Encoded
 */
export function snipLine(line, colno) {
    var newLine = line;
    var lineLength = newLine.length;
    if (lineLength <= 150) {
        return newLine;
    }
    if (colno > lineLength) {
        // eslint-disable-next-line no-param-reassign
        colno = lineLength;
    }
    var start = Math.max(colno - 60, 0);
    if (start < 5) {
        start = 0;
    }
    var end = Math.min(start + 140, lineLength);
    if (end > lineLength - 5) {
        end = lineLength;
    }
    if (end === lineLength) {
        start = Math.max(end - 140, 0);
    }
    newLine = newLine.slice(start, end);
    if (start > 0) {
        newLine = "'{snip} " + newLine;
    }
    if (end < lineLength) {
        newLine += ' {snip}';
    }
    return newLine;
}
/**
 * Join values in array
 * @param input array of values to be joined together
 * @param delimiter string to be placed in-between values
 * @returns Joined values
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function safeJoin(input, delimiter) {
    if (!Array.isArray(input)) {
        return '';
    }
    var output = [];
    // eslint-disable-next-line @typescript-eslint/prefer-for-of
    for (var i = 0; i < input.length; i++) {
        var value = input[i];
        try {
            output.push(String(value));
        }
        catch (e) {
            output.push('[value cannot be serialized]');
        }
    }
    return output.join(delimiter);
}
/**
 * Checks if the value matches a regex or includes the string
 * @param value The string value to be checked against
 * @param pattern Either a regex or a string that must be contained in value
 */
export function isMatchingPattern(value, pattern) {
    if (!isString(value)) {
        return false;
    }
    if (isRegExp(pattern)) {
        return pattern.test(value);
    }
    if (typeof pattern === 'string') {
        return value.indexOf(pattern) !== -1;
    }
    return false;
}
/**
 * Given a string, escape characters which have meaning in the regex grammar, such that the result is safe to feed to
 * `new RegExp()`.
 *
 * Based on https://github.com/sindresorhus/escape-string-regexp. Vendored to a) reduce the size by skipping the runtime
 * type-checking, and b) ensure it gets down-compiled for old versions of Node (the published package only supports Node
 * 12+).
 *
 * @param regexString The string to escape
 * @returns An version of the string with all special regex characters escaped
 */
export function escapeStringForRegex(regexString) {
    // escape the hyphen separately so we can also replace it with a unicode literal hyphen, to avoid the problems
    // discussed in https://github.com/sindresorhus/escape-string-regexp/issues/20.
    return regexString.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
}
//# sourceMappingURL=string.js.map{"version":3,"file":"string.js","sourceRoot":"","sources":["../../src/string.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,MAAM,CAAC;AAE1C;;;;;;GAMG;AACH,MAAM,UAAU,QAAQ,CAAC,GAAW,EAAE,GAAe;IAAf,oBAAA,EAAA,OAAe;IACnD,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,KAAK,CAAC,EAAE;QACxC,OAAO,GAAG,CAAC;KACZ;IACD,OAAO,GAAG,CAAC,MAAM,IAAI,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAI,GAAG,CAAC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,QAAK,CAAC;AAC9D,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,QAAQ,CAAC,IAAY,EAAE,KAAa;IAClD,IAAI,OAAO,GAAG,IAAI,CAAC;IACnB,IAAM,UAAU,GAAG,OAAO,CAAC,MAAM,CAAC;IAClC,IAAI,UAAU,IAAI,GAAG,EAAE;QACrB,OAAO,OAAO,CAAC;KAChB;IACD,IAAI,KAAK,GAAG,UAAU,EAAE;QACtB,6CAA6C;QAC7C,KAAK,GAAG,UAAU,CAAC;KACpB;IAED,IAAI,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC;IACpC,IAAI,KAAK,GAAG,CAAC,EAAE;QACb,KAAK,GAAG,CAAC,CAAC;KACX;IAED,IAAI,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,GAAG,EAAE,UAAU,CAAC,CAAC;IAC5C,IAAI,GAAG,GAAG,UAAU,GAAG,CAAC,EAAE;QACxB,GAAG,GAAG,UAAU,CAAC;KAClB;IACD,IAAI,GAAG,KAAK,UAAU,EAAE;QACtB,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,EAAE,CAAC,CAAC,CAAC;KAChC;IAED,OAAO,GAAG,OAAO,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IACpC,IAAI,KAAK,GAAG,CAAC,EAAE;QACb,OAAO,GAAG,aAAW,OAAS,CAAC;KAChC;IACD,IAAI,GAAG,GAAG,UAAU,EAAE;QACpB,OAAO,IAAI,SAAS,CAAC;KACtB;IAED,OAAO,OAAO,CAAC;AACjB,CAAC;AAED;;;;;GAKG;AACH,8DAA8D;AAC9D,MAAM,UAAU,QAAQ,CAAC,KAAY,EAAE,SAAkB;IACvD,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;QACzB,OAAO,EAAE,CAAC;KACX;IAED,IAAM,MAAM,GAAG,EAAE,CAAC;IAClB,4DAA4D;IAC5D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACrC,IAAM,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QACvB,IAAI;YACF,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;SAC5B;QAAC,OAAO,CAAC,EAAE;YACV,MAAM,CAAC,IAAI,CAAC,8BAA8B,CAAC,CAAC;SAC7C;KACF;IAED,OAAO,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;AAChC,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,iBAAiB,CAAC,KAAa,EAAE,OAAwB;IACvE,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;QACpB,OAAO,KAAK,CAAC;KACd;IAED,IAAI,QAAQ,CAAC,OAAO,CAAC,EAAE;QACrB,OAAO,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KAC5B;IACD,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;QAC/B,OAAO,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;KACtC;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAED;;;;;;;;;;GAUG;AACH,MAAM,UAAU,oBAAoB,CAAC,WAAmB;IACtD,8GAA8G;IAC9G,+EAA+E;IAC/E,OAAO,WAAW,CAAC,OAAO,CAAC,qBAAqB,EAAE,MAAM,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;AACnF,CAAC","sourcesContent":["import { isRegExp, isString } from './is';\n\n/**\n * Truncates given string to the maximum characters count\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string (0 = unlimited)\n * @returns string Encoded\n */\nexport function truncate(str: string, max: number = 0): string {\n  if (typeof str !== 'string' || max === 0) {\n    return str;\n  }\n  return str.length <= max ? str : `${str.substr(0, max)}...`;\n}\n\n/**\n * This is basically just `trim_line` from\n * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string\n * @returns string Encoded\n */\nexport function snipLine(line: string, colno: number): string {\n  let newLine = line;\n  const lineLength = newLine.length;\n  if (lineLength <= 150) {\n    return newLine;\n  }\n  if (colno > lineLength) {\n    // eslint-disable-next-line no-param-reassign\n    colno = lineLength;\n  }\n\n  let start = Math.max(colno - 60, 0);\n  if (start < 5) {\n    start = 0;\n  }\n\n  let end = Math.min(start + 140, lineLength);\n  if (end > lineLength - 5) {\n    end = lineLength;\n  }\n  if (end === lineLength) {\n    start = Math.max(end - 140, 0);\n  }\n\n  newLine = newLine.slice(start, end);\n  if (start > 0) {\n    newLine = `'{snip} ${newLine}`;\n  }\n  if (end < lineLength) {\n    newLine += ' {snip}';\n  }\n\n  return newLine;\n}\n\n/**\n * Join values in array\n * @param input array of values to be joined together\n * @param delimiter string to be placed in-between values\n * @returns Joined values\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function safeJoin(input: any[], delimiter?: string): string {\n  if (!Array.isArray(input)) {\n    return '';\n  }\n\n  const output = [];\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of\n  for (let i = 0; i < input.length; i++) {\n    const value = input[i];\n    try {\n      output.push(String(value));\n    } catch (e) {\n      output.push('[value cannot be serialized]');\n    }\n  }\n\n  return output.join(delimiter);\n}\n\n/**\n * Checks if the value matches a regex or includes the string\n * @param value The string value to be checked against\n * @param pattern Either a regex or a string that must be contained in value\n */\nexport function isMatchingPattern(value: string, pattern: RegExp | string): boolean {\n  if (!isString(value)) {\n    return false;\n  }\n\n  if (isRegExp(pattern)) {\n    return pattern.test(value);\n  }\n  if (typeof pattern === 'string') {\n    return value.indexOf(pattern) !== -1;\n  }\n  return false;\n}\n\n/**\n * Given a string, escape characters which have meaning in the regex grammar, such that the result is safe to feed to\n * `new RegExp()`.\n *\n * Based on https://github.com/sindresorhus/escape-string-regexp. Vendored to a) reduce the size by skipping the runtime\n * type-checking, and b) ensure it gets down-compiled for old versions of Node (the published package only supports Node\n * 12+).\n *\n * @param regexString The string to escape\n * @returns An version of the string with all special regex characters escaped\n */\nexport function escapeStringForRegex(regexString: string): string {\n  // escape the hyphen separately so we can also replace it with a unicode literal hyphen, to avoid the problems\n  // discussed in https://github.com/sindresorhus/escape-string-regexp/issues/20.\n  return regexString.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d');\n}\n"]}/**
 * Tells whether current environment supports ErrorEvent objects
 * {@link supportsErrorEvent}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsErrorEvent(): boolean;
/**
 * Tells whether current environment supports DOMError objects
 * {@link supportsDOMError}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsDOMError(): boolean;
/**
 * Tells whether current environment supports DOMException objects
 * {@link supportsDOMException}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsDOMException(): boolean;
/**
 * Tells whether current environment supports Fetch API
 * {@link supportsFetch}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsFetch(): boolean;
/**
 * isNativeFetch checks if the given function is a native implementation of fetch()
 */
export declare function isNativeFetch(func: Function): boolean;
/**
 * Tells whether current environment supports Fetch API natively
 * {@link supportsNativeFetch}.
 *
 * @returns true if `window.fetch` is natively implemented, false otherwise
 */
export declare function supportsNativeFetch(): boolean;
/**
 * Tells whether current environment supports ReportingObserver API
 * {@link supportsReportingObserver}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsReportingObserver(): boolean;
/**
 * Tells whether current environment supports Referrer Policy API
 * {@link supportsReferrerPolicy}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsReferrerPolicy(): boolean;
/**
 * Tells whether current environment supports History API
 * {@link supportsHistory}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsHistory(): boolean;
//# sourceMappingURL=supports.d.ts.map{"version":3,"file":"supports.d.ts","sourceRoot":"","sources":["../../src/supports.ts"],"names":[],"mappings":"AAIA;;;;;GAKG;AACH,wBAAgB,kBAAkB,IAAI,OAAO,CAO5C;AAED;;;;;GAKG;AACH,wBAAgB,gBAAgB,IAAI,OAAO,CAU1C;AAED;;;;;GAKG;AACH,wBAAgB,oBAAoB,IAAI,OAAO,CAO9C;AAED;;;;;GAKG;AACH,wBAAgB,aAAa,IAAI,OAAO,CAavC;AACD;;GAEG;AAEH,wBAAgB,aAAa,CAAC,IAAI,EAAE,QAAQ,GAAG,OAAO,CAErD;AAED;;;;;GAKG;AACH,wBAAgB,mBAAmB,IAAI,OAAO,CAmC7C;AAED;;;;;GAKG;AACH,wBAAgB,yBAAyB,IAAI,OAAO,CAEnD;AAED;;;;;GAKG;AACH,wBAAgB,sBAAsB,IAAI,OAAO,CAkBhD;AAED;;;;;GAKG;AACH,wBAAgB,eAAe,IAAI,OAAO,CAazC"}import { IS_DEBUG_BUILD } from './flags';
import { getGlobalObject } from './global';
import { logger } from './logger';
/**
 * Tells whether current environment supports ErrorEvent objects
 * {@link supportsErrorEvent}.
 *
 * @returns Answer to the given question.
 */
export function supportsErrorEvent() {
    try {
        new ErrorEvent('');
        return true;
    }
    catch (e) {
        return false;
    }
}
/**
 * Tells whether current environment supports DOMError objects
 * {@link supportsDOMError}.
 *
 * @returns Answer to the given question.
 */
export function supportsDOMError() {
    try {
        // Chrome: VM89:1 Uncaught TypeError: Failed to construct 'DOMError':
        // 1 argument required, but only 0 present.
        // @ts-ignore It really needs 1 argument, not 0.
        new DOMError('');
        return true;
    }
    catch (e) {
        return false;
    }
}
/**
 * Tells whether current environment supports DOMException objects
 * {@link supportsDOMException}.
 *
 * @returns Answer to the given question.
 */
export function supportsDOMException() {
    try {
        new DOMException('');
        return true;
    }
    catch (e) {
        return false;
    }
}
/**
 * Tells whether current environment supports Fetch API
 * {@link supportsFetch}.
 *
 * @returns Answer to the given question.
 */
export function supportsFetch() {
    if (!('fetch' in getGlobalObject())) {
        return false;
    }
    try {
        new Headers();
        new Request('');
        new Response();
        return true;
    }
    catch (e) {
        return false;
    }
}
/**
 * isNativeFetch checks if the given function is a native implementation of fetch()
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export function isNativeFetch(func) {
    return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
}
/**
 * Tells whether current environment supports Fetch API natively
 * {@link supportsNativeFetch}.
 *
 * @returns true if `window.fetch` is natively implemented, false otherwise
 */
export function supportsNativeFetch() {
    if (!supportsFetch()) {
        return false;
    }
    var global = getGlobalObject();
    // Fast path to avoid DOM I/O
    // eslint-disable-next-line @typescript-eslint/unbound-method
    if (isNativeFetch(global.fetch)) {
        return true;
    }
    // window.fetch is implemented, but is polyfilled or already wrapped (e.g: by a chrome extension)
    // so create a "pure" iframe to see if that has native fetch
    var result = false;
    var doc = global.document;
    // eslint-disable-next-line deprecation/deprecation
    if (doc && typeof doc.createElement === 'function') {
        try {
            var sandbox = doc.createElement('iframe');
            sandbox.hidden = true;
            doc.head.appendChild(sandbox);
            if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
                // eslint-disable-next-line @typescript-eslint/unbound-method
                result = isNativeFetch(sandbox.contentWindow.fetch);
            }
            doc.head.removeChild(sandbox);
        }
        catch (err) {
            IS_DEBUG_BUILD &&
                logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', err);
        }
    }
    return result;
}
/**
 * Tells whether current environment supports ReportingObserver API
 * {@link supportsReportingObserver}.
 *
 * @returns Answer to the given question.
 */
export function supportsReportingObserver() {
    return 'ReportingObserver' in getGlobalObject();
}
/**
 * Tells whether current environment supports Referrer Policy API
 * {@link supportsReferrerPolicy}.
 *
 * @returns Answer to the given question.
 */
export function supportsReferrerPolicy() {
    // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default'
    // (see https://caniuse.com/#feat=referrer-policy),
    // it doesn't. And it throws an exception instead of ignoring this parameter...
    // REF: https://github.com/getsentry/raven-js/issues/1233
    if (!supportsFetch()) {
        return false;
    }
    try {
        new Request('_', {
            referrerPolicy: 'origin',
        });
        return true;
    }
    catch (e) {
        return false;
    }
}
/**
 * Tells whether current environment supports History API
 * {@link supportsHistory}.
 *
 * @returns Answer to the given question.
 */
export function supportsHistory() {
    // NOTE: in Chrome App environment, touching history.pushState, *even inside
    //       a try/catch block*, will cause Chrome to output an error to console.error
    // borrowed from: https://github.com/angular/angular.js/pull/13945/files
    var global = getGlobalObject();
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var chrome = global.chrome;
    var isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
    var hasHistoryApi = 'history' in global && !!global.history.pushState && !!global.history.replaceState;
    return !isChromePackagedApp && hasHistoryApi;
}
//# sourceMappingURL=supports.js.map{"version":3,"file":"supports.js","sourceRoot":"","sources":["../../src/supports.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,SAAS,CAAC;AACzC,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAC3C,OAAO,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;AAElC;;;;;GAKG;AACH,MAAM,UAAU,kBAAkB;IAChC,IAAI;QACF,IAAI,UAAU,CAAC,EAAE,CAAC,CAAC;QACnB,OAAO,IAAI,CAAC;KACb;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,gBAAgB;IAC9B,IAAI;QACF,qEAAqE;QACrE,2CAA2C;QAC3C,gDAAgD;QAChD,IAAI,QAAQ,CAAC,EAAE,CAAC,CAAC;QACjB,OAAO,IAAI,CAAC;KACb;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,oBAAoB;IAClC,IAAI;QACF,IAAI,YAAY,CAAC,EAAE,CAAC,CAAC;QACrB,OAAO,IAAI,CAAC;KACb;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,aAAa;IAC3B,IAAI,CAAC,CAAC,OAAO,IAAI,eAAe,EAAU,CAAC,EAAE;QAC3C,OAAO,KAAK,CAAC;KACd;IAED,IAAI;QACF,IAAI,OAAO,EAAE,CAAC;QACd,IAAI,OAAO,CAAC,EAAE,CAAC,CAAC;QAChB,IAAI,QAAQ,EAAE,CAAC;QACf,OAAO,IAAI,CAAC;KACb;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AACD;;GAEG;AACH,wDAAwD;AACxD,MAAM,UAAU,aAAa,CAAC,IAAc;IAC1C,OAAO,IAAI,IAAI,kDAAkD,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;AAC1F,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,mBAAmB;IACjC,IAAI,CAAC,aAAa,EAAE,EAAE;QACpB,OAAO,KAAK,CAAC;KACd;IAED,IAAM,MAAM,GAAG,eAAe,EAAU,CAAC;IAEzC,6BAA6B;IAC7B,6DAA6D;IAC7D,IAAI,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE;QAC/B,OAAO,IAAI,CAAC;KACb;IAED,iGAAiG;IACjG,4DAA4D;IAC5D,IAAI,MAAM,GAAG,KAAK,CAAC;IACnB,IAAM,GAAG,GAAG,MAAM,CAAC,QAAQ,CAAC;IAC5B,mDAAmD;IACnD,IAAI,GAAG,IAAI,OAAQ,GAAG,CAAC,aAAyB,KAAK,UAAU,EAAE;QAC/D,IAAI;YACF,IAAM,OAAO,GAAG,GAAG,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;YAC5C,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC;YACtB,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;YAC9B,IAAI,OAAO,CAAC,aAAa,IAAI,OAAO,CAAC,aAAa,CAAC,KAAK,EAAE;gBACxD,6DAA6D;gBAC7D,MAAM,GAAG,aAAa,CAAC,OAAO,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;aACrD;YACD,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;SAC/B;QAAC,OAAO,GAAG,EAAE;YACZ,cAAc;gBACZ,MAAM,CAAC,IAAI,CAAC,iFAAiF,EAAE,GAAG,CAAC,CAAC;SACvG;KACF;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,yBAAyB;IACvC,OAAO,mBAAmB,IAAI,eAAe,EAAE,CAAC;AAClD,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,sBAAsB;IACpC,yHAAyH;IACzH,mDAAmD;IACnD,+EAA+E;IAC/E,yDAAyD;IAEzD,IAAI,CAAC,aAAa,EAAE,EAAE;QACpB,OAAO,KAAK,CAAC;KACd;IAED,IAAI;QACF,IAAI,OAAO,CAAC,GAAG,EAAE;YACf,cAAc,EAAE,QAA0B;SAC3C,CAAC,CAAC;QACH,OAAO,IAAI,CAAC;KACb;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,eAAe;IAC7B,4EAA4E;IAC5E,kFAAkF;IAClF,wEAAwE;IACxE,IAAM,MAAM,GAAG,eAAe,EAAU,CAAC;IACzC,+DAA+D;IAC/D,8DAA8D;IAC9D,IAAM,MAAM,GAAI,MAAc,CAAC,MAAM,CAAC;IACtC,IAAM,mBAAmB,GAAG,MAAM,IAAI,MAAM,CAAC,GAAG,IAAI,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC;IACvE,8DAA8D;IAC9D,IAAM,aAAa,GAAG,SAAS,IAAI,MAAM,IAAI,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,SAAS,IAAI,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,YAAY,CAAC;IAEzG,OAAO,CAAC,mBAAmB,IAAI,aAAa,CAAC;AAC/C,CAAC","sourcesContent":["import { IS_DEBUG_BUILD } from './flags';\nimport { getGlobalObject } from './global';\nimport { logger } from './logger';\n\n/**\n * Tells whether current environment supports ErrorEvent objects\n * {@link supportsErrorEvent}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsErrorEvent(): boolean {\n  try {\n    new ErrorEvent('');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports DOMError objects\n * {@link supportsDOMError}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsDOMError(): boolean {\n  try {\n    // Chrome: VM89:1 Uncaught TypeError: Failed to construct 'DOMError':\n    // 1 argument required, but only 0 present.\n    // @ts-ignore It really needs 1 argument, not 0.\n    new DOMError('');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports DOMException objects\n * {@link supportsDOMException}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsDOMException(): boolean {\n  try {\n    new DOMException('');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports Fetch API\n * {@link supportsFetch}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsFetch(): boolean {\n  if (!('fetch' in getGlobalObject<Window>())) {\n    return false;\n  }\n\n  try {\n    new Headers();\n    new Request('');\n    new Response();\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * isNativeFetch checks if the given function is a native implementation of fetch()\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isNativeFetch(func: Function): boolean {\n  return func && /^function fetch\\(\\)\\s+\\{\\s+\\[native code\\]\\s+\\}$/.test(func.toString());\n}\n\n/**\n * Tells whether current environment supports Fetch API natively\n * {@link supportsNativeFetch}.\n *\n * @returns true if `window.fetch` is natively implemented, false otherwise\n */\nexport function supportsNativeFetch(): boolean {\n  if (!supportsFetch()) {\n    return false;\n  }\n\n  const global = getGlobalObject<Window>();\n\n  // Fast path to avoid DOM I/O\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  if (isNativeFetch(global.fetch)) {\n    return true;\n  }\n\n  // window.fetch is implemented, but is polyfilled or already wrapped (e.g: by a chrome extension)\n  // so create a \"pure\" iframe to see if that has native fetch\n  let result = false;\n  const doc = global.document;\n  // eslint-disable-next-line deprecation/deprecation\n  if (doc && typeof (doc.createElement as unknown) === 'function') {\n    try {\n      const sandbox = doc.createElement('iframe');\n      sandbox.hidden = true;\n      doc.head.appendChild(sandbox);\n      if (sandbox.contentWindow && sandbox.contentWindow.fetch) {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        result = isNativeFetch(sandbox.contentWindow.fetch);\n      }\n      doc.head.removeChild(sandbox);\n    } catch (err) {\n      IS_DEBUG_BUILD &&\n        logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', err);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Tells whether current environment supports ReportingObserver API\n * {@link supportsReportingObserver}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsReportingObserver(): boolean {\n  return 'ReportingObserver' in getGlobalObject();\n}\n\n/**\n * Tells whether current environment supports Referrer Policy API\n * {@link supportsReferrerPolicy}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsReferrerPolicy(): boolean {\n  // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default'\n  // (see https://caniuse.com/#feat=referrer-policy),\n  // it doesn't. And it throws an exception instead of ignoring this parameter...\n  // REF: https://github.com/getsentry/raven-js/issues/1233\n\n  if (!supportsFetch()) {\n    return false;\n  }\n\n  try {\n    new Request('_', {\n      referrerPolicy: 'origin' as ReferrerPolicy,\n    });\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports History API\n * {@link supportsHistory}.\n *\n * @returns Answer to the given question.\n */\nexport function supportsHistory(): boolean {\n  // NOTE: in Chrome App environment, touching history.pushState, *even inside\n  //       a try/catch block*, will cause Chrome to output an error to console.error\n  // borrowed from: https://github.com/angular/angular.js/pull/13945/files\n  const global = getGlobalObject<Window>();\n  /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const chrome = (global as any).chrome;\n  const isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;\n  /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n  const hasHistoryApi = 'history' in global && !!global.history.pushState && !!global.history.replaceState;\n\n  return !isChromePackagedApp && hasHistoryApi;\n}\n"]}/**
 * Creates a resolved sync promise.
 *
 * @param value the value to resolve the promise with
 * @returns the resolved sync promise
 */
export declare function resolvedSyncPromise<T>(value: T | PromiseLike<T>): PromiseLike<T>;
/**
 * Creates a rejected sync promise.
 *
 * @param value the value to reject the promise with
 * @returns the rejected sync promise
 */
export declare function rejectedSyncPromise<T = never>(reason?: any): PromiseLike<T>;
/**
 * Thenable class that behaves like a Promise and follows it's interface
 * but is not async internally
 */
declare class SyncPromise<T> implements PromiseLike<T> {
    private _state;
    private _handlers;
    private _value;
    constructor(executor: (resolve: (value?: T | PromiseLike<T> | null) => void, reject: (reason?: any) => void) => void);
    /** JSDoc */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null): PromiseLike<TResult1 | TResult2>;
    /** JSDoc */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null): PromiseLike<T | TResult>;
    /** JSDoc */
    finally<TResult>(onfinally?: (() => void) | null): PromiseLike<TResult>;
    /** JSDoc */
    private readonly _resolve;
    /** JSDoc */
    private readonly _reject;
    /** JSDoc */
    private readonly _setResult;
    /** JSDoc */
    private readonly _executeHandlers;
}
export { SyncPromise };
//# sourceMappingURL=syncpromise.d.ts.map{"version":3,"file":"syncpromise.d.ts","sourceRoot":"","sources":["../../src/syncpromise.ts"],"names":[],"mappings":"AAgBA;;;;;GAKG;AACH,wBAAgB,mBAAmB,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAIhF;AAED;;;;;GAKG;AACH,wBAAgB,mBAAmB,CAAC,CAAC,GAAG,KAAK,EAAE,MAAM,CAAC,EAAE,GAAG,GAAG,WAAW,CAAC,CAAC,CAAC,CAI3E;AAED;;;GAGG;AACH,cAAM,WAAW,CAAC,CAAC,CAAE,YAAW,WAAW,CAAC,CAAC,CAAC;IAC5C,OAAO,CAAC,MAAM,CAA0B;IACxC,OAAO,CAAC,SAAS,CAAkE;IACnF,OAAO,CAAC,MAAM,CAAM;gBAGlB,QAAQ,EAAE,CAAC,OAAO,EAAE,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,GAAG,IAAI,KAAK,IAAI,EAAE,MAAM,EAAE,CAAC,MAAM,CAAC,EAAE,GAAG,KAAK,IAAI,KAAK,IAAI;IAS1G,YAAY;IACL,IAAI,CAAC,QAAQ,GAAG,CAAC,EAAE,QAAQ,GAAG,KAAK,EACxC,WAAW,CAAC,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,KAAK,QAAQ,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,EACrE,UAAU,CAAC,EAAE,CAAC,CAAC,MAAM,EAAE,GAAG,KAAK,QAAQ,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,GACtE,WAAW,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAiCnC,YAAY;IACL,KAAK,CAAC,OAAO,GAAG,KAAK,EAC1B,UAAU,CAAC,EAAE,CAAC,CAAC,MAAM,EAAE,GAAG,KAAK,OAAO,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC,GAAG,IAAI,GACpE,WAAW,CAAC,CAAC,GAAG,OAAO,CAAC;IAI3B,YAAY;IACL,OAAO,CAAC,OAAO,EAAE,SAAS,CAAC,EAAE,CAAC,MAAM,IAAI,CAAC,GAAG,IAAI,GAAG,WAAW,CAAC,OAAO,CAAC;IA+B9E,YAAY;IACZ,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAEvB;IAEF,YAAY;IACZ,OAAO,CAAC,QAAQ,CAAC,OAAO,CAEtB;IAEF,YAAY;IACZ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAczB;IAEF,YAAY;IACZ,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAwB/B;CACH;AAED,OAAO,EAAE,WAAW,EAAE,CAAC"}/* eslint-disable @typescript-eslint/explicit-function-return-type */
/* eslint-disable @typescript-eslint/typedef */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { isThenable } from './is';
/**
 * Creates a resolved sync promise.
 *
 * @param value the value to resolve the promise with
 * @returns the resolved sync promise
 */
export function resolvedSyncPromise(value) {
    return new SyncPromise(function (resolve) {
        resolve(value);
    });
}
/**
 * Creates a rejected sync promise.
 *
 * @param value the value to reject the promise with
 * @returns the rejected sync promise
 */
export function rejectedSyncPromise(reason) {
    return new SyncPromise(function (_, reject) {
        reject(reason);
    });
}
/**
 * Thenable class that behaves like a Promise and follows it's interface
 * but is not async internally
 */
var SyncPromise = /** @class */ (function () {
    function SyncPromise(executor) {
        var _this = this;
        this._state = 0 /* PENDING */;
        this._handlers = [];
        /** JSDoc */
        this._resolve = function (value) {
            _this._setResult(1 /* RESOLVED */, value);
        };
        /** JSDoc */
        this._reject = function (reason) {
            _this._setResult(2 /* REJECTED */, reason);
        };
        /** JSDoc */
        this._setResult = function (state, value) {
            if (_this._state !== 0 /* PENDING */) {
                return;
            }
            if (isThenable(value)) {
                void value.then(_this._resolve, _this._reject);
                return;
            }
            _this._state = state;
            _this._value = value;
            _this._executeHandlers();
        };
        /** JSDoc */
        this._executeHandlers = function () {
            if (_this._state === 0 /* PENDING */) {
                return;
            }
            var cachedHandlers = _this._handlers.slice();
            _this._handlers = [];
            cachedHandlers.forEach(function (handler) {
                if (handler[0]) {
                    return;
                }
                if (_this._state === 1 /* RESOLVED */) {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    handler[1](_this._value);
                }
                if (_this._state === 2 /* REJECTED */) {
                    handler[2](_this._value);
                }
                handler[0] = true;
            });
        };
        try {
            executor(this._resolve, this._reject);
        }
        catch (e) {
            this._reject(e);
        }
    }
    /** JSDoc */
    SyncPromise.prototype.then = function (onfulfilled, onrejected) {
        var _this = this;
        return new SyncPromise(function (resolve, reject) {
            _this._handlers.push([
                false,
                function (result) {
                    if (!onfulfilled) {
                        // TODO: ¯\_(ツ)_/¯
                        // TODO: FIXME
                        resolve(result);
                    }
                    else {
                        try {
                            resolve(onfulfilled(result));
                        }
                        catch (e) {
                            reject(e);
                        }
                    }
                },
                function (reason) {
                    if (!onrejected) {
                        reject(reason);
                    }
                    else {
                        try {
                            resolve(onrejected(reason));
                        }
                        catch (e) {
                            reject(e);
                        }
                    }
                },
            ]);
            _this._executeHandlers();
        });
    };
    /** JSDoc */
    SyncPromise.prototype.catch = function (onrejected) {
        return this.then(function (val) { return val; }, onrejected);
    };
    /** JSDoc */
    SyncPromise.prototype.finally = function (onfinally) {
        var _this = this;
        return new SyncPromise(function (resolve, reject) {
            var val;
            var isRejected;
            return _this.then(function (value) {
                isRejected = false;
                val = value;
                if (onfinally) {
                    onfinally();
                }
            }, function (reason) {
                isRejected = true;
                val = reason;
                if (onfinally) {
                    onfinally();
                }
            }).then(function () {
                if (isRejected) {
                    reject(val);
                    return;
                }
                resolve(val);
            });
        });
    };
    return SyncPromise;
}());
export { SyncPromise };
//# sourceMappingURL=syncpromise.js.map{"version":3,"file":"syncpromise.js","sourceRoot":"","sources":["../../src/syncpromise.ts"],"names":[],"mappings":"AAAA,qEAAqE;AACrE,+CAA+C;AAC/C,sEAAsE;AACtE,uDAAuD;AACvD,OAAO,EAAE,UAAU,EAAE,MAAM,MAAM,CAAC;AAYlC;;;;;GAKG;AACH,MAAM,UAAU,mBAAmB,CAAI,KAAyB;IAC9D,OAAO,IAAI,WAAW,CAAC,UAAA,OAAO;QAC5B,OAAO,CAAC,KAAK,CAAC,CAAC;IACjB,CAAC,CAAC,CAAC;AACL,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,mBAAmB,CAAY,MAAY;IACzD,OAAO,IAAI,WAAW,CAAC,UAAC,CAAC,EAAE,MAAM;QAC/B,MAAM,CAAC,MAAM,CAAC,CAAC;IACjB,CAAC,CAAC,CAAC;AACL,CAAC;AAED;;;GAGG;AACH;IAKE,qBACE,QAAwG;QAD1G,iBAQC;QAZO,WAAM,mBAA0B;QAChC,cAAS,GAA+D,EAAE,CAAC;QAyFnF,YAAY;QACK,aAAQ,GAAG,UAAC,KAAiC;YAC5D,KAAI,CAAC,UAAU,mBAAkB,KAAK,CAAC,CAAC;QAC1C,CAAC,CAAC;QAEF,YAAY;QACK,YAAO,GAAG,UAAC,MAAY;YACtC,KAAI,CAAC,UAAU,mBAAkB,MAAM,CAAC,CAAC;QAC3C,CAAC,CAAC;QAEF,YAAY;QACK,eAAU,GAAG,UAAC,KAAa,EAAE,KAAgC;YAC5E,IAAI,KAAI,CAAC,MAAM,oBAAmB,EAAE;gBAClC,OAAO;aACR;YAED,IAAI,UAAU,CAAC,KAAK,CAAC,EAAE;gBACrB,KAAM,KAAwB,CAAC,IAAI,CAAC,KAAI,CAAC,QAAQ,EAAE,KAAI,CAAC,OAAO,CAAC,CAAC;gBACjE,OAAO;aACR;YAED,KAAI,CAAC,MAAM,GAAG,KAAK,CAAC;YACpB,KAAI,CAAC,MAAM,GAAG,KAAK,CAAC;YAEpB,KAAI,CAAC,gBAAgB,EAAE,CAAC;QAC1B,CAAC,CAAC;QAEF,YAAY;QACK,qBAAgB,GAAG;YAClC,IAAI,KAAI,CAAC,MAAM,oBAAmB,EAAE;gBAClC,OAAO;aACR;YAED,IAAM,cAAc,GAAG,KAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;YAC9C,KAAI,CAAC,SAAS,GAAG,EAAE,CAAC;YAEpB,cAAc,CAAC,OAAO,CAAC,UAAA,OAAO;gBAC5B,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE;oBACd,OAAO;iBACR;gBAED,IAAI,KAAI,CAAC,MAAM,qBAAoB,EAAE;oBACnC,mEAAmE;oBACnE,OAAO,CAAC,CAAC,CAAC,CAAC,KAAI,CAAC,MAAwB,CAAC,CAAC;iBAC3C;gBAED,IAAI,KAAI,CAAC,MAAM,qBAAoB,EAAE;oBACnC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAI,CAAC,MAAM,CAAC,CAAC;iBACzB;gBAED,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;YACpB,CAAC,CAAC,CAAC;QACL,CAAC,CAAC;QAvIA,IAAI;YACF,QAAQ,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;SACvC;QAAC,OAAO,CAAC,EAAE;YACV,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;SACjB;IACH,CAAC;IAED,YAAY;IACL,0BAAI,GAAX,UACE,WAAqE,EACrE,UAAuE;QAFzE,iBAkCC;QA9BC,OAAO,IAAI,WAAW,CAAC,UAAC,OAAO,EAAE,MAAM;YACrC,KAAI,CAAC,SAAS,CAAC,IAAI,CAAC;gBAClB,KAAK;gBACL,UAAA,MAAM;oBACJ,IAAI,CAAC,WAAW,EAAE;wBAChB,kBAAkB;wBAClB,cAAc;wBACd,OAAO,CAAC,MAAa,CAAC,CAAC;qBACxB;yBAAM;wBACL,IAAI;4BACF,OAAO,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC;yBAC9B;wBAAC,OAAO,CAAC,EAAE;4BACV,MAAM,CAAC,CAAC,CAAC,CAAC;yBACX;qBACF;gBACH,CAAC;gBACD,UAAA,MAAM;oBACJ,IAAI,CAAC,UAAU,EAAE;wBACf,MAAM,CAAC,MAAM,CAAC,CAAC;qBAChB;yBAAM;wBACL,IAAI;4BACF,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC;yBAC7B;wBAAC,OAAO,CAAC,EAAE;4BACV,MAAM,CAAC,CAAC,CAAC,CAAC;yBACX;qBACF;gBACH,CAAC;aACF,CAAC,CAAC;YACH,KAAI,CAAC,gBAAgB,EAAE,CAAC;QAC1B,CAAC,CAAC,CAAC;IACL,CAAC;IAED,YAAY;IACL,2BAAK,GAAZ,UACE,UAAqE;QAErE,OAAO,IAAI,CAAC,IAAI,CAAC,UAAA,GAAG,IAAI,OAAA,GAAG,EAAH,CAAG,EAAE,UAAU,CAAC,CAAC;IAC3C,CAAC;IAED,YAAY;IACL,6BAAO,GAAd,UAAwB,SAA+B;QAAvD,iBA6BC;QA5BC,OAAO,IAAI,WAAW,CAAU,UAAC,OAAO,EAAE,MAAM;YAC9C,IAAI,GAAkB,CAAC;YACvB,IAAI,UAAmB,CAAC;YAExB,OAAO,KAAI,CAAC,IAAI,CACd,UAAA,KAAK;gBACH,UAAU,GAAG,KAAK,CAAC;gBACnB,GAAG,GAAG,KAAK,CAAC;gBACZ,IAAI,SAAS,EAAE;oBACb,SAAS,EAAE,CAAC;iBACb;YACH,CAAC,EACD,UAAA,MAAM;gBACJ,UAAU,GAAG,IAAI,CAAC;gBAClB,GAAG,GAAG,MAAM,CAAC;gBACb,IAAI,SAAS,EAAE;oBACb,SAAS,EAAE,CAAC;iBACb;YACH,CAAC,CACF,CAAC,IAAI,CAAC;gBACL,IAAI,UAAU,EAAE;oBACd,MAAM,CAAC,GAAG,CAAC,CAAC;oBACZ,OAAO;iBACR;gBAED,OAAO,CAAC,GAAqB,CAAC,CAAC;YACjC,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAuDH,kBAAC;AAAD,CAAC,AAhJD,IAgJC;AAED,OAAO,EAAE,WAAW,EAAE,CAAC","sourcesContent":["/* eslint-disable @typescript-eslint/explicit-function-return-type */\n/* eslint-disable @typescript-eslint/typedef */\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { isThenable } from './is';\n\n/** SyncPromise internal states */\nconst enum States {\n  /** Pending */\n  PENDING = 0,\n  /** Resolved / OK */\n  RESOLVED = 1,\n  /** Rejected / Error */\n  REJECTED = 2,\n}\n\n/**\n * Creates a resolved sync promise.\n *\n * @param value the value to resolve the promise with\n * @returns the resolved sync promise\n */\nexport function resolvedSyncPromise<T>(value: T | PromiseLike<T>): PromiseLike<T> {\n  return new SyncPromise(resolve => {\n    resolve(value);\n  });\n}\n\n/**\n * Creates a rejected sync promise.\n *\n * @param value the value to reject the promise with\n * @returns the rejected sync promise\n */\nexport function rejectedSyncPromise<T = never>(reason?: any): PromiseLike<T> {\n  return new SyncPromise((_, reject) => {\n    reject(reason);\n  });\n}\n\n/**\n * Thenable class that behaves like a Promise and follows it's interface\n * but is not async internally\n */\nclass SyncPromise<T> implements PromiseLike<T> {\n  private _state: States = States.PENDING;\n  private _handlers: Array<[boolean, (value: T) => void, (reason: any) => any]> = [];\n  private _value: any;\n\n  public constructor(\n    executor: (resolve: (value?: T | PromiseLike<T> | null) => void, reject: (reason?: any) => void) => void,\n  ) {\n    try {\n      executor(this._resolve, this._reject);\n    } catch (e) {\n      this._reject(e);\n    }\n  }\n\n  /** JSDoc */\n  public then<TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,\n  ): PromiseLike<TResult1 | TResult2> {\n    return new SyncPromise((resolve, reject) => {\n      this._handlers.push([\n        false,\n        result => {\n          if (!onfulfilled) {\n            // TODO: ¯\\_(ツ)_/¯\n            // TODO: FIXME\n            resolve(result as any);\n          } else {\n            try {\n              resolve(onfulfilled(result));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n        reason => {\n          if (!onrejected) {\n            reject(reason);\n          } else {\n            try {\n              resolve(onrejected(reason));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n      ]);\n      this._executeHandlers();\n    });\n  }\n\n  /** JSDoc */\n  public catch<TResult = never>(\n    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,\n  ): PromiseLike<T | TResult> {\n    return this.then(val => val, onrejected);\n  }\n\n  /** JSDoc */\n  public finally<TResult>(onfinally?: (() => void) | null): PromiseLike<TResult> {\n    return new SyncPromise<TResult>((resolve, reject) => {\n      let val: TResult | any;\n      let isRejected: boolean;\n\n      return this.then(\n        value => {\n          isRejected = false;\n          val = value;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n        reason => {\n          isRejected = true;\n          val = reason;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n      ).then(() => {\n        if (isRejected) {\n          reject(val);\n          return;\n        }\n\n        resolve(val as unknown as any);\n      });\n    });\n  }\n\n  /** JSDoc */\n  private readonly _resolve = (value?: T | PromiseLike<T> | null) => {\n    this._setResult(States.RESOLVED, value);\n  };\n\n  /** JSDoc */\n  private readonly _reject = (reason?: any) => {\n    this._setResult(States.REJECTED, reason);\n  };\n\n  /** JSDoc */\n  private readonly _setResult = (state: States, value?: T | PromiseLike<T> | any) => {\n    if (this._state !== States.PENDING) {\n      return;\n    }\n\n    if (isThenable(value)) {\n      void (value as PromiseLike<T>).then(this._resolve, this._reject);\n      return;\n    }\n\n    this._state = state;\n    this._value = value;\n\n    this._executeHandlers();\n  };\n\n  /** JSDoc */\n  private readonly _executeHandlers = () => {\n    if (this._state === States.PENDING) {\n      return;\n    }\n\n    const cachedHandlers = this._handlers.slice();\n    this._handlers = [];\n\n    cachedHandlers.forEach(handler => {\n      if (handler[0]) {\n        return;\n      }\n\n      if (this._state === States.RESOLVED) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        handler[1](this._value as unknown as any);\n      }\n\n      if (this._state === States.REJECTED) {\n        handler[2](this._value);\n      }\n\n      handler[0] = true;\n    });\n  };\n}\n\nexport { SyncPromise };\n"]}/**
 * Returns a timestamp in seconds since the UNIX epoch using the Date API.
 */
export declare const dateTimestampInSeconds: () => number;
/**
 * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the
 * availability of the Performance API.
 *
 * See `usingPerformanceAPI` to test whether the Performance API is used.
 *
 * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is
 * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The
 * skew can grow to arbitrary amounts like days, weeks or months.
 * See https://github.com/getsentry/sentry-javascript/issues/2590.
 */
export declare const timestampInSeconds: () => number;
export declare const timestampWithMs: () => number;
/**
 * A boolean that is true when timestampInSeconds uses the Performance API to produce monotonic timestamps.
 */
export declare const usingPerformanceAPI: boolean;
/**
 * Internal helper to store what is the source of browserPerformanceTimeOrigin below. For debugging only.
 */
export declare let _browserPerformanceTimeOriginMode: string;
/**
 * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the
 * performance API is available.
 */
export declare const browserPerformanceTimeOrigin: number | undefined;
//# sourceMappingURL=time.d.ts.map{"version":3,"file":"time.d.ts","sourceRoot":"","sources":["../../src/time.ts"],"names":[],"mappings":"AAsGA;;GAEG;AACH,eAAO,MAAM,sBAAsB,EAAE,MAAM,MAAiE,CAAC;AAE7G;;;;;;;;;;GAUG;AACH,eAAO,MAAM,kBAAkB,EAAE,MAAM,MAAyD,CAAC;AAGjG,eAAO,MAAM,eAAe,cAAqB,CAAC;AAElD;;GAEG;AACH,eAAO,MAAM,mBAAmB,SAAoC,CAAC;AAErE;;GAEG;AACH,eAAO,IAAI,iCAAiC,EAAE,MAAM,CAAC;AAErD;;;GAGG;AACH,eAAO,MAAM,4BAA4B,oBA+CrC,CAAC"}import { getGlobalObject } from './global';
import { dynamicRequire, isNodeEnv } from './node';
/**
 * A TimestampSource implementation for environments that do not support the Performance Web API natively.
 *
 * Note that this TimestampSource does not use a monotonic clock. A call to `nowSeconds` may return a timestamp earlier
 * than a previously returned value. We do not try to emulate a monotonic behavior in order to facilitate debugging. It
 * is more obvious to explain "why does my span have negative duration" than "why my spans have zero duration".
 */
var dateTimestampSource = {
    nowSeconds: function () { return Date.now() / 1000; },
};
/**
 * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not
 * support the API.
 *
 * Wrapping the native API works around differences in behavior from different browsers.
 */
function getBrowserPerformance() {
    var performance = getGlobalObject().performance;
    if (!performance || !performance.now) {
        return undefined;
    }
    // Replace performance.timeOrigin with our own timeOrigin based on Date.now().
    //
    // This is a partial workaround for browsers reporting performance.timeOrigin such that performance.timeOrigin +
    // performance.now() gives a date arbitrarily in the past.
    //
    // Additionally, computing timeOrigin in this way fills the gap for browsers where performance.timeOrigin is
    // undefined.
    //
    // The assumption that performance.timeOrigin + performance.now() ~= Date.now() is flawed, but we depend on it to
    // interact with data coming out of performance entries.
    //
    // Note that despite recommendations against it in the spec, browsers implement the Performance API with a clock that
    // might stop when the computer is asleep (and perhaps under other circumstances). Such behavior causes
    // performance.timeOrigin + performance.now() to have an arbitrary skew over Date.now(). In laptop computers, we have
    // observed skews that can be as long as days, weeks or months.
    //
    // See https://github.com/getsentry/sentry-javascript/issues/2590.
    //
    // BUG: despite our best intentions, this workaround has its limitations. It mostly addresses timings of pageload
    // transactions, but ignores the skew built up over time that can aversely affect timestamps of navigation
    // transactions of long-lived web pages.
    var timeOrigin = Date.now() - performance.now();
    return {
        now: function () { return performance.now(); },
        timeOrigin: timeOrigin,
    };
}
/**
 * Returns the native Performance API implementation from Node.js. Returns undefined in old Node.js versions that don't
 * implement the API.
 */
function getNodePerformance() {
    try {
        var perfHooks = dynamicRequire(module, 'perf_hooks');
        return perfHooks.performance;
    }
    catch (_) {
        return undefined;
    }
}
/**
 * The Performance API implementation for the current platform, if available.
 */
var platformPerformance = isNodeEnv() ? getNodePerformance() : getBrowserPerformance();
var timestampSource = platformPerformance === undefined
    ? dateTimestampSource
    : {
        nowSeconds: function () { return (platformPerformance.timeOrigin + platformPerformance.now()) / 1000; },
    };
/**
 * Returns a timestamp in seconds since the UNIX epoch using the Date API.
 */
export var dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);
/**
 * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the
 * availability of the Performance API.
 *
 * See `usingPerformanceAPI` to test whether the Performance API is used.
 *
 * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is
 * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The
 * skew can grow to arbitrary amounts like days, weeks or months.
 * See https://github.com/getsentry/sentry-javascript/issues/2590.
 */
export var timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);
// Re-exported with an old name for backwards-compatibility.
export var timestampWithMs = timestampInSeconds;
/**
 * A boolean that is true when timestampInSeconds uses the Performance API to produce monotonic timestamps.
 */
export var usingPerformanceAPI = platformPerformance !== undefined;
/**
 * Internal helper to store what is the source of browserPerformanceTimeOrigin below. For debugging only.
 */
export var _browserPerformanceTimeOriginMode;
/**
 * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the
 * performance API is available.
 */
export var browserPerformanceTimeOrigin = (function () {
    // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or
    // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin
    // data as reliable if they are within a reasonable threshold of the current time.
    var performance = getGlobalObject().performance;
    if (!performance || !performance.now) {
        _browserPerformanceTimeOriginMode = 'none';
        return undefined;
    }
    var threshold = 3600 * 1000;
    var performanceNow = performance.now();
    var dateNow = Date.now();
    // if timeOrigin isn't available set delta to threshold so it isn't used
    var timeOriginDelta = performance.timeOrigin
        ? Math.abs(performance.timeOrigin + performanceNow - dateNow)
        : threshold;
    var timeOriginIsReliable = timeOriginDelta < threshold;
    // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin
    // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.
    // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always
    // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the
    // Date API.
    // eslint-disable-next-line deprecation/deprecation
    var navigationStart = performance.timing && performance.timing.navigationStart;
    var hasNavigationStart = typeof navigationStart === 'number';
    // if navigationStart isn't available set delta to threshold so it isn't used
    var navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
    var navigationStartIsReliable = navigationStartDelta < threshold;
    if (timeOriginIsReliable || navigationStartIsReliable) {
        // Use the more reliable time origin
        if (timeOriginDelta <= navigationStartDelta) {
            _browserPerformanceTimeOriginMode = 'timeOrigin';
            return performance.timeOrigin;
        }
        else {
            _browserPerformanceTimeOriginMode = 'navigationStart';
            return navigationStart;
        }
    }
    // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to Date.
    _browserPerformanceTimeOriginMode = 'dateNow';
    return dateNow;
})();
//# sourceMappingURL=time.js.map{"version":3,"file":"time.js","sourceRoot":"","sources":["../../src/time.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAC3C,OAAO,EAAE,cAAc,EAAE,SAAS,EAAE,MAAM,QAAQ,CAAC;AASnD;;;;;;GAMG;AACH,IAAM,mBAAmB,GAAoB;IAC3C,UAAU,EAAE,cAAM,OAAA,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,EAAjB,CAAiB;CACpC,CAAC;AAiBF;;;;;GAKG;AACH,SAAS,qBAAqB;IACpB,IAAA,2CAAW,CAA+B;IAClD,IAAI,CAAC,WAAW,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE;QACpC,OAAO,SAAS,CAAC;KAClB;IAED,8EAA8E;IAC9E,EAAE;IACF,gHAAgH;IAChH,0DAA0D;IAC1D,EAAE;IACF,4GAA4G;IAC5G,aAAa;IACb,EAAE;IACF,iHAAiH;IACjH,wDAAwD;IACxD,EAAE;IACF,qHAAqH;IACrH,uGAAuG;IACvG,qHAAqH;IACrH,+DAA+D;IAC/D,EAAE;IACF,kEAAkE;IAClE,EAAE;IACF,iHAAiH;IACjH,0GAA0G;IAC1G,wCAAwC;IACxC,IAAM,UAAU,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;IAElD,OAAO;QACL,GAAG,EAAE,cAAM,OAAA,WAAW,CAAC,GAAG,EAAE,EAAjB,CAAiB;QAC5B,UAAU,YAAA;KACX,CAAC;AACJ,CAAC;AAED;;;GAGG;AACH,SAAS,kBAAkB;IACzB,IAAI;QACF,IAAM,SAAS,GAAG,cAAc,CAAC,MAAM,EAAE,YAAY,CAAiC,CAAC;QACvF,OAAO,SAAS,CAAC,WAAW,CAAC;KAC9B;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,SAAS,CAAC;KAClB;AACH,CAAC;AAED;;GAEG;AACH,IAAM,mBAAmB,GAA4B,SAAS,EAAE,CAAC,CAAC,CAAC,kBAAkB,EAAE,CAAC,CAAC,CAAC,qBAAqB,EAAE,CAAC;AAElH,IAAM,eAAe,GACnB,mBAAmB,KAAK,SAAS;IAC/B,CAAC,CAAC,mBAAmB;IACrB,CAAC,CAAC;QACE,UAAU,EAAE,cAAM,OAAA,CAAC,mBAAmB,CAAC,UAAU,GAAG,mBAAmB,CAAC,GAAG,EAAE,CAAC,GAAG,IAAI,EAAnE,CAAmE;KACtF,CAAC;AAER;;GAEG;AACH,MAAM,CAAC,IAAM,sBAAsB,GAAiB,mBAAmB,CAAC,UAAU,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;AAE7G;;;;;;;;;;GAUG;AACH,MAAM,CAAC,IAAM,kBAAkB,GAAiB,eAAe,CAAC,UAAU,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;AAEjG,4DAA4D;AAC5D,MAAM,CAAC,IAAM,eAAe,GAAG,kBAAkB,CAAC;AAElD;;GAEG;AACH,MAAM,CAAC,IAAM,mBAAmB,GAAG,mBAAmB,KAAK,SAAS,CAAC;AAErE;;GAEG;AACH,MAAM,CAAC,IAAI,iCAAyC,CAAC;AAErD;;;GAGG;AACH,MAAM,CAAC,IAAM,4BAA4B,GAAG,CAAC;IAC3C,6GAA6G;IAC7G,mHAAmH;IACnH,kFAAkF;IAE1E,IAAA,2CAAW,CAA+B;IAClD,IAAI,CAAC,WAAW,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE;QACpC,iCAAiC,GAAG,MAAM,CAAC;QAC3C,OAAO,SAAS,CAAC;KAClB;IAED,IAAM,SAAS,GAAG,IAAI,GAAG,IAAI,CAAC;IAC9B,IAAM,cAAc,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;IACzC,IAAM,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;IAE3B,wEAAwE;IACxE,IAAM,eAAe,GAAG,WAAW,CAAC,UAAU;QAC5C,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,UAAU,GAAG,cAAc,GAAG,OAAO,CAAC;QAC7D,CAAC,CAAC,SAAS,CAAC;IACd,IAAM,oBAAoB,GAAG,eAAe,GAAG,SAAS,CAAC;IAEzD,oHAAoH;IACpH,mGAAmG;IACnG,qHAAqH;IACrH,qHAAqH;IACrH,YAAY;IACZ,mDAAmD;IACnD,IAAM,eAAe,GAAG,WAAW,CAAC,MAAM,IAAI,WAAW,CAAC,MAAM,CAAC,eAAe,CAAC;IACjF,IAAM,kBAAkB,GAAG,OAAO,eAAe,KAAK,QAAQ,CAAC;IAC/D,6EAA6E;IAC7E,IAAM,oBAAoB,GAAG,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,eAAe,GAAG,cAAc,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IACnH,IAAM,yBAAyB,GAAG,oBAAoB,GAAG,SAAS,CAAC;IAEnE,IAAI,oBAAoB,IAAI,yBAAyB,EAAE;QACrD,oCAAoC;QACpC,IAAI,eAAe,IAAI,oBAAoB,EAAE;YAC3C,iCAAiC,GAAG,YAAY,CAAC;YACjD,OAAO,WAAW,CAAC,UAAU,CAAC;SAC/B;aAAM;YACL,iCAAiC,GAAG,iBAAiB,CAAC;YACtD,OAAO,eAAe,CAAC;SACxB;KACF;IAED,mGAAmG;IACnG,iCAAiC,GAAG,SAAS,CAAC;IAC9C,OAAO,OAAO,CAAC;AACjB,CAAC,CAAC,EAAE,CAAC","sourcesContent":["import { getGlobalObject } from './global';\nimport { dynamicRequire, isNodeEnv } from './node';\n\n/**\n * An object that can return the current timestamp in seconds since the UNIX epoch.\n */\ninterface TimestampSource {\n  nowSeconds(): number;\n}\n\n/**\n * A TimestampSource implementation for environments that do not support the Performance Web API natively.\n *\n * Note that this TimestampSource does not use a monotonic clock. A call to `nowSeconds` may return a timestamp earlier\n * than a previously returned value. We do not try to emulate a monotonic behavior in order to facilitate debugging. It\n * is more obvious to explain \"why does my span have negative duration\" than \"why my spans have zero duration\".\n */\nconst dateTimestampSource: TimestampSource = {\n  nowSeconds: () => Date.now() / 1000,\n};\n\n/**\n * A partial definition of the [Performance Web API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance}\n * for accessing a high-resolution monotonic clock.\n */\ninterface Performance {\n  /**\n   * The millisecond timestamp at which measurement began, measured in Unix time.\n   */\n  timeOrigin: number;\n  /**\n   * Returns the current millisecond timestamp, where 0 represents the start of measurement.\n   */\n  now(): number;\n}\n\n/**\n * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not\n * support the API.\n *\n * Wrapping the native API works around differences in behavior from different browsers.\n */\nfunction getBrowserPerformance(): Performance | undefined {\n  const { performance } = getGlobalObject<Window>();\n  if (!performance || !performance.now) {\n    return undefined;\n  }\n\n  // Replace performance.timeOrigin with our own timeOrigin based on Date.now().\n  //\n  // This is a partial workaround for browsers reporting performance.timeOrigin such that performance.timeOrigin +\n  // performance.now() gives a date arbitrarily in the past.\n  //\n  // Additionally, computing timeOrigin in this way fills the gap for browsers where performance.timeOrigin is\n  // undefined.\n  //\n  // The assumption that performance.timeOrigin + performance.now() ~= Date.now() is flawed, but we depend on it to\n  // interact with data coming out of performance entries.\n  //\n  // Note that despite recommendations against it in the spec, browsers implement the Performance API with a clock that\n  // might stop when the computer is asleep (and perhaps under other circumstances). Such behavior causes\n  // performance.timeOrigin + performance.now() to have an arbitrary skew over Date.now(). In laptop computers, we have\n  // observed skews that can be as long as days, weeks or months.\n  //\n  // See https://github.com/getsentry/sentry-javascript/issues/2590.\n  //\n  // BUG: despite our best intentions, this workaround has its limitations. It mostly addresses timings of pageload\n  // transactions, but ignores the skew built up over time that can aversely affect timestamps of navigation\n  // transactions of long-lived web pages.\n  const timeOrigin = Date.now() - performance.now();\n\n  return {\n    now: () => performance.now(),\n    timeOrigin,\n  };\n}\n\n/**\n * Returns the native Performance API implementation from Node.js. Returns undefined in old Node.js versions that don't\n * implement the API.\n */\nfunction getNodePerformance(): Performance | undefined {\n  try {\n    const perfHooks = dynamicRequire(module, 'perf_hooks') as { performance: Performance };\n    return perfHooks.performance;\n  } catch (_) {\n    return undefined;\n  }\n}\n\n/**\n * The Performance API implementation for the current platform, if available.\n */\nconst platformPerformance: Performance | undefined = isNodeEnv() ? getNodePerformance() : getBrowserPerformance();\n\nconst timestampSource: TimestampSource =\n  platformPerformance === undefined\n    ? dateTimestampSource\n    : {\n        nowSeconds: () => (platformPerformance.timeOrigin + platformPerformance.now()) / 1000,\n      };\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using the Date API.\n */\nexport const dateTimestampInSeconds: () => number = dateTimestampSource.nowSeconds.bind(dateTimestampSource);\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the\n * availability of the Performance API.\n *\n * See `usingPerformanceAPI` to test whether the Performance API is used.\n *\n * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is\n * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The\n * skew can grow to arbitrary amounts like days, weeks or months.\n * See https://github.com/getsentry/sentry-javascript/issues/2590.\n */\nexport const timestampInSeconds: () => number = timestampSource.nowSeconds.bind(timestampSource);\n\n// Re-exported with an old name for backwards-compatibility.\nexport const timestampWithMs = timestampInSeconds;\n\n/**\n * A boolean that is true when timestampInSeconds uses the Performance API to produce monotonic timestamps.\n */\nexport const usingPerformanceAPI = platformPerformance !== undefined;\n\n/**\n * Internal helper to store what is the source of browserPerformanceTimeOrigin below. For debugging only.\n */\nexport let _browserPerformanceTimeOriginMode: string;\n\n/**\n * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the\n * performance API is available.\n */\nexport const browserPerformanceTimeOrigin = ((): number | undefined => {\n  // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or\n  // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin\n  // data as reliable if they are within a reasonable threshold of the current time.\n\n  const { performance } = getGlobalObject<Window>();\n  if (!performance || !performance.now) {\n    _browserPerformanceTimeOriginMode = 'none';\n    return undefined;\n  }\n\n  const threshold = 3600 * 1000;\n  const performanceNow = performance.now();\n  const dateNow = Date.now();\n\n  // if timeOrigin isn't available set delta to threshold so it isn't used\n  const timeOriginDelta = performance.timeOrigin\n    ? Math.abs(performance.timeOrigin + performanceNow - dateNow)\n    : threshold;\n  const timeOriginIsReliable = timeOriginDelta < threshold;\n\n  // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin\n  // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.\n  // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always\n  // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the\n  // Date API.\n  // eslint-disable-next-line deprecation/deprecation\n  const navigationStart = performance.timing && performance.timing.navigationStart;\n  const hasNavigationStart = typeof navigationStart === 'number';\n  // if navigationStart isn't available set delta to threshold so it isn't used\n  const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;\n  const navigationStartIsReliable = navigationStartDelta < threshold;\n\n  if (timeOriginIsReliable || navigationStartIsReliable) {\n    // Use the more reliable time origin\n    if (timeOriginDelta <= navigationStartDelta) {\n      _browserPerformanceTimeOriginMode = 'timeOrigin';\n      return performance.timeOrigin;\n    } else {\n      _browserPerformanceTimeOriginMode = 'navigationStart';\n      return navigationStart;\n    }\n  }\n\n  // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to Date.\n  _browserPerformanceTimeOriginMode = 'dateNow';\n  return dateNow;\n})();\n"]}import { TraceparentData } from '@sentry/types';
export declare const TRACEPARENT_REGEXP: RegExp;
/**
 * Extract transaction context data from a `sentry-trace` header.
 *
 * @param traceparent Traceparent string
 *
 * @returns Object containing data from the header, or undefined if traceparent string is malformed
 */
export declare function extractTraceparentData(traceparent: string): TraceparentData | undefined;
//# sourceMappingURL=tracing.d.ts.map{"version":3,"file":"tracing.d.ts","sourceRoot":"","sources":["../../src/tracing.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,eAAe,EAAE,MAAM,eAAe,CAAC;AAEhD,eAAO,MAAM,kBAAkB,QAM9B,CAAC;AAEF;;;;;;GAMG;AACH,wBAAgB,sBAAsB,CAAC,WAAW,EAAE,MAAM,GAAG,eAAe,GAAG,SAAS,CAgBvF"}export var TRACEPARENT_REGEXP = new RegExp('^[ \\t]*' + // whitespace
    '([0-9a-f]{32})?' + // trace_id
    '-?([0-9a-f]{16})?' + // span_id
    '-?([01])?' + // sampled
    '[ \\t]*$');
/**
 * Extract transaction context data from a `sentry-trace` header.
 *
 * @param traceparent Traceparent string
 *
 * @returns Object containing data from the header, or undefined if traceparent string is malformed
 */
export function extractTraceparentData(traceparent) {
    var matches = traceparent.match(TRACEPARENT_REGEXP);
    if (matches) {
        var parentSampled = void 0;
        if (matches[3] === '1') {
            parentSampled = true;
        }
        else if (matches[3] === '0') {
            parentSampled = false;
        }
        return {
            traceId: matches[1],
            parentSampled: parentSampled,
            parentSpanId: matches[2],
        };
    }
    return undefined;
}
//# sourceMappingURL=tracing.js.map{"version":3,"file":"tracing.js","sourceRoot":"","sources":["../../src/tracing.ts"],"names":[],"mappings":"AAEA,MAAM,CAAC,IAAM,kBAAkB,GAAG,IAAI,MAAM,CAC1C,UAAU,GAAG,aAAa;IACxB,iBAAiB,GAAG,WAAW;IAC/B,mBAAmB,GAAG,UAAU;IAChC,WAAW,GAAG,UAAU;IACxB,UAAU,CACb,CAAC;AAEF;;;;;;GAMG;AACH,MAAM,UAAU,sBAAsB,CAAC,WAAmB;IACxD,IAAM,OAAO,GAAG,WAAW,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC;IACtD,IAAI,OAAO,EAAE;QACX,IAAI,aAAa,SAAqB,CAAC;QACvC,IAAI,OAAO,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;YACtB,aAAa,GAAG,IAAI,CAAC;SACtB;aAAM,IAAI,OAAO,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;YAC7B,aAAa,GAAG,KAAK,CAAC;SACvB;QACD,OAAO;YACL,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC;YACnB,aAAa,eAAA;YACb,YAAY,EAAE,OAAO,CAAC,CAAC,CAAC;SACzB,CAAC;KACH;IACD,OAAO,SAAS,CAAC;AACnB,CAAC","sourcesContent":["import { TraceparentData } from '@sentry/types';\n\nexport const TRACEPARENT_REGEXP = new RegExp(\n  '^[ \\\\t]*' + // whitespace\n    '([0-9a-f]{32})?' + // trace_id\n    '-?([0-9a-f]{16})?' + // span_id\n    '-?([01])?' + // sampled\n    '[ \\\\t]*$', // whitespace\n);\n\n/**\n * Extract transaction context data from a `sentry-trace` header.\n *\n * @param traceparent Traceparent string\n *\n * @returns Object containing data from the header, or undefined if traceparent string is malformed\n */\nexport function extractTraceparentData(traceparent: string): TraceparentData | undefined {\n  const matches = traceparent.match(TRACEPARENT_REGEXP);\n  if (matches) {\n    let parentSampled: boolean | undefined;\n    if (matches[3] === '1') {\n      parentSampled = true;\n    } else if (matches[3] === '0') {\n      parentSampled = false;\n    }\n    return {\n      traceId: matches[1],\n      parentSampled,\n      parentSpanId: matches[2],\n    };\n  }\n  return undefined;\n}\n"]}BSD 3-Clause License

Copyright (c) 2019, Sentry
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{
  "name": "@sentry/utils",
  "version": "6.19.7",
  "description": "Utilities for all Sentry JavaScript SDKs",
  "repository": "git://github.com/getsentry/sentry-javascript.git",
  "homepage": "https://github.com/getsentry/sentry-javascript/tree/master/packages/utils",
  "author": "Sentry",
  "license": "BSD-3-Clause",
  "engines": {
    "node": ">=6"
  },
  "main": "dist/index.js",
  "module": "esm/index.js",
  "types": "types/index.d.ts",
  "publishConfig": {
    "access": "public"
  },
  "dependencies": {
    "@sentry/types": "6.19.7",
    "tslib": "^1.9.3"
  },
  "devDependencies": {
    "chai": "^4.1.2",
    "jsdom": "^16.2.2"
  },
  "sideEffects": false
}<p align="center">
  <a href="https://sentry.io" target="_blank" align="center">
    <img src="https://sentry-brand.storage.googleapis.com/sentry-logo-black.png" width="280">
  </a>
  <br />
</p>

# Sentry JavaScript SDK Utilities

[![npm version](https://img.shields.io/npm/v/@sentry/utils.svg)](https://www.npmjs.com/package/@sentry/utils)
[![npm dm](https://img.shields.io/npm/dm/@sentry/utils.svg)](https://www.npmjs.com/package/@sentry/utils)
[![npm dt](https://img.shields.io/npm/dt/@sentry/utils.svg)](https://www.npmjs.com/package/@sentry/utils)
[![typedoc](https://img.shields.io/badge/docs-typedoc-blue.svg)](http://getsentry.github.io/sentry-javascript/)

## Links

- [Official SDK Docs](https://docs.sentry.io/quickstart/)
- [TypeDoc](http://getsentry.github.io/sentry-javascript/)

## General

Common utilities used by the Sentry JavaScript SDKs. **Warning, only submodule imports are allowed here.** Also note,
this function shouldn't be used externally, we will break them from time to time. This package is not part of our public
API contract, we use them only internally.
/**
 * Consumes the promise and logs the error when it rejects.
 * @param promise A promise to forget.
 */
export declare function forget(promise: PromiseLike<any>): void;
//# sourceMappingURL=async.d.ts.map{"version":3,"file":"async.d.ts","sourceRoot":"","sources":["../../src/async.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,wBAAgB,MAAM,CAAC,OAAO,EAAE,WAAW,CAAC,GAAG,CAAC,GAAG,IAAI,CAMtD"}/**
 * Given a child DOM element, returns a query-selector statement describing that
 * and its ancestors
 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
 * @returns generated DOM path
 */
export declare function htmlTreeAsString(elem: unknown, keyAttrs?: string[]): string;
/**
 * A safe form of location.href
 */
export declare function getLocationHref(): string;
//# sourceMappingURL=browser.d.ts.map{"version":3,"file":"browser.d.ts","sourceRoot":"","sources":["../../src/browser.ts"],"names":[],"mappings":"AAGA;;;;;GAKG;AACH,wBAAgB,gBAAgB,CAAC,IAAI,EAAE,OAAO,EAAE,QAAQ,CAAC,EAAE,MAAM,EAAE,GAAG,MAAM,CAyC3E;AA+DD;;GAEG;AACH,wBAAgB,eAAe,IAAI,MAAM,CAOxC"}import { ClientReport, ClientReportEnvelope } from '@sentry/types';
/**
 * Creates client report envelope
 * @param discarded_events An array of discard events
 * @param dsn A DSN that can be set on the header. Optional.
 */
export declare function createClientReportEnvelope(discarded_events: ClientReport['discarded_events'], dsn?: string, timestamp?: number): ClientReportEnvelope;
//# sourceMappingURL=clientreport.d.ts.map{"version":3,"file":"clientreport.d.ts","sourceRoot":"","sources":["../../src/clientreport.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,oBAAoB,EAAoB,MAAM,eAAe,CAAC;AAKrF;;;;GAIG;AACH,wBAAgB,0BAA0B,CACxC,gBAAgB,EAAE,YAAY,CAAC,kBAAkB,CAAC,EAClD,GAAG,CAAC,EAAE,MAAM,EACZ,SAAS,CAAC,EAAE,MAAM,GACjB,oBAAoB,CAStB"}import { DsnComponents, DsnLike } from '@sentry/types';
/**
 * Renders the string representation of this Dsn.
 *
 * By default, this will render the public representation without the password
 * component. To get the deprecated private representation, set `withPassword`
 * to true.
 *
 * @param withPassword When set to true, the password will be included.
 */
export declare function dsnToString(dsn: DsnComponents, withPassword?: boolean): string;
/** The Sentry Dsn, identifying a Sentry instance and project. */
export declare function makeDsn(from: DsnLike): DsnComponents;
//# sourceMappingURL=dsn.d.ts.map{"version":3,"file":"dsn.d.ts","sourceRoot":"","sources":["../../src/dsn.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,OAAO,EAAe,MAAM,eAAe,CAAC;AAYpE;;;;;;;;GAQG;AACH,wBAAgB,WAAW,CAAC,GAAG,EAAE,aAAa,EAAE,YAAY,GAAE,OAAe,GAAG,MAAM,CAMrF;AA4ED,iEAAiE;AACjE,wBAAgB,OAAO,CAAC,IAAI,EAAE,OAAO,GAAG,aAAa,CAMpD"}export declare const SeverityLevels: readonly ["fatal", "error", "warning", "log", "info", "debug", "critical"];
export declare type SeverityLevel = typeof SeverityLevels[number];
//# sourceMappingURL=enums.d.ts.map{"version":3,"file":"enums.d.ts","sourceRoot":"","sources":["../../src/enums.ts"],"names":[],"mappings":"AAAA,eAAO,MAAM,cAAc,4EAA6E,CAAC;AACzG,oBAAY,aAAa,GAAG,OAAO,cAAc,CAAC,MAAM,CAAC,CAAC"}/**
 * Figures out if we're building a browser bundle.
 *
 * @returns true if this is a browser bundle build.
 */
export declare function isBrowserBundle(): boolean;
//# sourceMappingURL=env.d.ts.map{"version":3,"file":"env.d.ts","sourceRoot":"","sources":["../../src/env.ts"],"names":[],"mappings":"AAiBA;;;;GAIG;AACH,wBAAgB,eAAe,IAAI,OAAO,CAEzC"}import { Envelope } from '@sentry/types';
/**
 * Creates an envelope.
 * Make sure to always explicitly provide the generic to this function
 * so that the envelope types resolve correctly.
 */
export declare function createEnvelope<E extends Envelope>(headers: E[0], items?: E[1]): E;
/**
 * Add an item to an envelope.
 * Make sure to always explicitly provide the generic to this function
 * so that the envelope types resolve correctly.
 */
export declare function addItemToEnvelope<E extends Envelope>(envelope: E, newItem: E[1][number]): E;
/**
 * Get the type of the envelope. Grabs the type from the first envelope item.
 */
export declare function getEnvelopeType<E extends Envelope>(envelope: E): string;
/**
 * Serializes an envelope into a string.
 */
export declare function serializeEnvelope(envelope: Envelope): string;
//# sourceMappingURL=envelope.d.ts.map{"version":3,"file":"envelope.d.ts","sourceRoot":"","sources":["../../src/envelope.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,eAAe,CAAC;AAIzC;;;;GAIG;AACH,wBAAgB,cAAc,CAAC,CAAC,SAAS,QAAQ,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,GAAE,CAAC,CAAC,CAAC,CAAM,GAAG,CAAC,CAErF;AAED;;;;GAIG;AACH,wBAAgB,iBAAiB,CAAC,CAAC,SAAS,QAAQ,EAAE,QAAQ,EAAE,CAAC,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAG3F;AAED;;GAEG;AACH,wBAAgB,eAAe,CAAC,CAAC,SAAS,QAAQ,EAAE,QAAQ,EAAE,CAAC,GAAG,MAAM,CAGvE;AAED;;GAEG;AACH,wBAAgB,iBAAiB,CAAC,QAAQ,EAAE,QAAQ,GAAG,MAAM,CAe5D"}/** An error emitted by Sentry SDKs and related utilities. */
export declare class SentryError extends Error {
    message: string;
    /** Display name of this error instance. */
    name: string;
    constructor(message: string);
}
//# sourceMappingURL=error.d.ts.map{"version":3,"file":"error.d.ts","sourceRoot":"","sources":["../../src/error.ts"],"names":[],"mappings":"AAEA,6DAA6D;AAC7D,qBAAa,WAAY,SAAQ,KAAK;IAIV,OAAO,EAAE,MAAM;IAHzC,2CAA2C;IACpC,IAAI,EAAE,MAAM,CAAC;gBAEM,OAAO,EAAE,MAAM;CAM1C"}/** Flag that is true for debug builds, false otherwise. */
export declare const IS_DEBUG_BUILD: boolean;
//# sourceMappingURL=flags.d.ts.map{"version":3,"file":"flags.d.ts","sourceRoot":"","sources":["../../src/flags.ts"],"names":[],"mappings":"AAgBA,2DAA2D;AAC3D,eAAO,MAAM,cAAc,SAAoE,CAAC"}/**
 * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
 * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
 */
import { Integration } from '@sentry/types';
/** Internal */
interface SentryGlobal {
    Sentry?: {
        Integrations?: Integration[];
    };
    SENTRY_ENVIRONMENT?: string;
    SENTRY_DSN?: string;
    SENTRY_RELEASE?: {
        id?: string;
    };
    __SENTRY__: {
        globalEventProcessors: any;
        hub: any;
        logger: any;
    };
}
/**
 * Safely get global scope object
 *
 * @returns Global scope object
 */
export declare function getGlobalObject<T>(): T & SentryGlobal;
/**
 * Returns a global singleton contained in the global `__SENTRY__` object.
 *
 * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory
 * function and added to the `__SENTRY__` object.
 *
 * @param name name of the global singleton on __SENTRY__
 * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`
 * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `getGlobalObject`'s return value
 * @returns the singleton
 */
export declare function getGlobalSingleton<T>(name: keyof SentryGlobal['__SENTRY__'], creator: () => T, obj?: unknown): T;
export {};
//# sourceMappingURL=global.d.ts.map{"version":3,"file":"global.d.ts","sourceRoot":"","sources":["../../src/global.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAIH,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAI5C,eAAe;AACf,UAAU,YAAY;IACpB,MAAM,CAAC,EAAE;QACP,YAAY,CAAC,EAAE,WAAW,EAAE,CAAC;KAC9B,CAAC;IACF,kBAAkB,CAAC,EAAE,MAAM,CAAC;IAC5B,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,cAAc,CAAC,EAAE;QACf,EAAE,CAAC,EAAE,MAAM,CAAC;KACb,CAAC;IACF,UAAU,EAAE;QACV,qBAAqB,EAAE,GAAG,CAAC;QAC3B,GAAG,EAAE,GAAG,CAAC;QACT,MAAM,EAAE,GAAG,CAAC;KACb,CAAC;CACH;AAID;;;;GAIG;AACH,wBAAgB,eAAe,CAAC,CAAC,KAAK,CAAC,GAAG,YAAY,CAUrD;AAED;;;;;;;;;;GAUG;AACH,wBAAgB,kBAAkB,CAAC,CAAC,EAAE,IAAI,EAAE,MAAM,YAAY,CAAC,YAAY,CAAC,EAAE,OAAO,EAAE,MAAM,CAAC,EAAE,GAAG,CAAC,EAAE,OAAO,GAAG,CAAC,CAKhH"}export * from './async';
export * from './browser';
export * from './dsn';
export * from './enums';
export * from './error';
export * from './global';
export * from './instrument';
export * from './is';
export * from './logger';
export * from './memo';
export * from './misc';
export * from './node';
export * from './normalize';
export * from './object';
export * from './path';
export * from './promisebuffer';
export * from './severity';
export * from './stacktrace';
export * from './status';
export * from './string';
export * from './supports';
export * from './syncpromise';
export * from './time';
export * from './tracing';
export * from './env';
export * from './envelope';
export * from './clientreport';
export * from './ratelimit';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,cAAc,SAAS,CAAC;AACxB,cAAc,WAAW,CAAC;AAC1B,cAAc,OAAO,CAAC;AACtB,cAAc,SAAS,CAAC;AACxB,cAAc,SAAS,CAAC;AACxB,cAAc,UAAU,CAAC;AACzB,cAAc,cAAc,CAAC;AAC7B,cAAc,MAAM,CAAC;AACrB,cAAc,UAAU,CAAC;AACzB,cAAc,QAAQ,CAAC;AACvB,cAAc,QAAQ,CAAC;AACvB,cAAc,QAAQ,CAAC;AACvB,cAAc,aAAa,CAAC;AAC5B,cAAc,UAAU,CAAC;AACzB,cAAc,QAAQ,CAAC;AACvB,cAAc,iBAAiB,CAAC;AAChC,cAAc,YAAY,CAAC;AAC3B,cAAc,cAAc,CAAC;AAC7B,cAAc,UAAU,CAAC;AACzB,cAAc,UAAU,CAAC;AACzB,cAAc,YAAY,CAAC;AAC3B,cAAc,eAAe,CAAC;AAC9B,cAAc,QAAQ,CAAC;AACvB,cAAc,WAAW,CAAC;AAC1B,cAAc,OAAO,CAAC;AACtB,cAAc,YAAY,CAAC;AAC3B,cAAc,gBAAgB,CAAC;AAC/B,cAAc,aAAa,CAAC"}declare type InstrumentHandlerType = 'console' | 'dom' | 'fetch' | 'history' | 'sentry' | 'xhr' | 'error' | 'unhandledrejection';
declare type InstrumentHandlerCallback = (data: any) => void;
/**
 * Add handler that will be called when given type of instrumentation triggers.
 * Use at your own risk, this might break without changelog notice, only used internally.
 * @hidden
 */
export declare function addInstrumentationHandler(type: InstrumentHandlerType, callback: InstrumentHandlerCallback): void;
export {};
//# sourceMappingURL=instrument.d.ts.map{"version":3,"file":"instrument.d.ts","sourceRoot":"","sources":["../../src/instrument.ts"],"names":[],"mappings":"AAeA,aAAK,qBAAqB,GACtB,SAAS,GACT,KAAK,GACL,OAAO,GACP,SAAS,GACT,QAAQ,GACR,KAAK,GACL,OAAO,GACP,oBAAoB,CAAC;AACzB,aAAK,yBAAyB,GAAG,CAAC,IAAI,EAAE,GAAG,KAAK,IAAI,CAAC;AAoDrD;;;;GAIG;AACH,wBAAgB,yBAAyB,CAAC,IAAI,EAAE,qBAAqB,EAAE,QAAQ,EAAE,yBAAyB,GAAG,IAAI,CAIhH"}import { Primitive } from '@sentry/types';
/**
 * Checks whether given value's type is one of a few Error or Error-like
 * {@link isError}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isError(wat: unknown): wat is Error;
/**
 * Checks whether given value's type is ErrorEvent
 * {@link isErrorEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isErrorEvent(wat: unknown): boolean;
/**
 * Checks whether given value's type is DOMError
 * {@link isDOMError}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isDOMError(wat: unknown): boolean;
/**
 * Checks whether given value's type is DOMException
 * {@link isDOMException}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isDOMException(wat: unknown): boolean;
/**
 * Checks whether given value's type is a string
 * {@link isString}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isString(wat: unknown): wat is string;
/**
 * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)
 * {@link isPrimitive}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isPrimitive(wat: unknown): wat is Primitive;
/**
 * Checks whether given value's type is an object literal
 * {@link isPlainObject}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isPlainObject(wat: unknown): wat is Record<string, unknown>;
/**
 * Checks whether given value's type is an Event instance
 * {@link isEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isEvent(wat: unknown): boolean;
/**
 * Checks whether given value's type is an Element instance
 * {@link isElement}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isElement(wat: unknown): boolean;
/**
 * Checks whether given value's type is an regexp
 * {@link isRegExp}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isRegExp(wat: unknown): wat is RegExp;
/**
 * Checks whether given value has a then function.
 * @param wat A value to be checked.
 */
export declare function isThenable(wat: any): wat is PromiseLike<any>;
/**
 * Checks whether given value's type is a SyntheticEvent
 * {@link isSyntheticEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isSyntheticEvent(wat: unknown): boolean;
/**
 * Checks whether given value is NaN
 * {@link isNaN}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
export declare function isNaN(wat: unknown): boolean;
/**
 * Checks whether given value's type is an instance of provided constructor.
 * {@link isInstanceOf}.
 *
 * @param wat A value to be checked.
 * @param base A constructor to be used in a check.
 * @returns A boolean representing the result.
 */
export declare function isInstanceOf(wat: any, base: any): boolean;
//# sourceMappingURL=is.d.ts.map{"version":3,"file":"is.d.ts","sourceRoot":"","sources":["../../src/is.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAK1C;;;;;;GAMG;AACH,wBAAgB,OAAO,CAAC,GAAG,EAAE,OAAO,GAAG,GAAG,IAAI,KAAK,CASlD;AAMD;;;;;;GAMG;AACH,wBAAgB,YAAY,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAElD;AAED;;;;;;GAMG;AACH,wBAAgB,UAAU,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAEhD;AAED;;;;;;GAMG;AACH,wBAAgB,cAAc,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAEpD;AAED;;;;;;GAMG;AACH,wBAAgB,QAAQ,CAAC,GAAG,EAAE,OAAO,GAAG,GAAG,IAAI,MAAM,CAEpD;AAED;;;;;;GAMG;AACH,wBAAgB,WAAW,CAAC,GAAG,EAAE,OAAO,GAAG,GAAG,IAAI,SAAS,CAE1D;AAED;;;;;;GAMG;AACH,wBAAgB,aAAa,CAAC,GAAG,EAAE,OAAO,GAAG,GAAG,IAAI,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAE1E;AAED;;;;;;GAMG;AACH,wBAAgB,OAAO,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAE7C;AAED;;;;;;GAMG;AACH,wBAAgB,SAAS,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAE/C;AAED;;;;;;GAMG;AACH,wBAAgB,QAAQ,CAAC,GAAG,EAAE,OAAO,GAAG,GAAG,IAAI,MAAM,CAEpD;AAED;;;GAGG;AACH,wBAAgB,UAAU,CAAC,GAAG,EAAE,GAAG,GAAG,GAAG,IAAI,WAAW,CAAC,GAAG,CAAC,CAG5D;AAED;;;;;;GAMG;AACH,wBAAgB,gBAAgB,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAEtD;AAED;;;;;;GAMG;AACH,wBAAgB,KAAK,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAE3C;AAED;;;;;;;GAOG;AACH,wBAAgB,YAAY,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,OAAO,CAMzD"}export declare const CONSOLE_LEVELS: readonly ["debug", "info", "warn", "error", "log", "assert"];
declare type LoggerMethod = (...args: unknown[]) => void;
declare type LoggerConsoleMethods = Record<typeof CONSOLE_LEVELS[number], LoggerMethod>;
/** JSDoc */
interface Logger extends LoggerConsoleMethods {
    disable(): void;
    enable(): void;
}
/**
 * Temporarily disable sentry console instrumentations.
 *
 * @param callback The function to run against the original `console` messages
 * @returns The results of the callback
 */
export declare function consoleSandbox<T>(callback: () => T): T;
declare let logger: Logger;
export { logger };
//# sourceMappingURL=logger.d.ts.map{"version":3,"file":"logger.d.ts","sourceRoot":"","sources":["../../src/logger.ts"],"names":[],"mappings":"AAWA,eAAO,MAAM,cAAc,8DAA+D,CAAC;AAE3F,aAAK,YAAY,GAAG,CAAC,GAAG,IAAI,EAAE,OAAO,EAAE,KAAK,IAAI,CAAC;AACjD,aAAK,oBAAoB,GAAG,MAAM,CAAC,OAAO,cAAc,CAAC,MAAM,CAAC,EAAE,YAAY,CAAC,CAAC;AAEhF,YAAY;AACZ,UAAU,MAAO,SAAQ,oBAAoB;IAC3C,OAAO,IAAI,IAAI,CAAC;IAChB,MAAM,IAAI,IAAI,CAAC;CAChB;AAED;;;;;GAKG;AACH,wBAAgB,cAAc,CAAC,CAAC,EAAE,QAAQ,EAAE,MAAM,CAAC,GAAG,CAAC,CA6BtD;AAkCD,QAAA,IAAI,MAAM,EAAE,MAAM,CAAC;AAOnB,OAAO,EAAE,MAAM,EAAE,CAAC"}export declare type MemoFunc = [(obj: any) => boolean, (obj: any) => void];
/**
 * Helper to decycle json objects
 */
export declare function memoBuilder(): MemoFunc;
//# sourceMappingURL=memo.d.ts.map{"version":3,"file":"memo.d.ts","sourceRoot":"","sources":["../../src/memo.ts"],"names":[],"mappings":"AAGA,oBAAY,QAAQ,GAAG,CAErB,CAAC,GAAG,EAAE,GAAG,KAAK,OAAO,EAErB,CAAC,GAAG,EAAE,GAAG,KAAK,IAAI,CACnB,CAAC;AAEF;;GAEG;AACH,wBAAgB,WAAW,IAAI,QAAQ,CAmCtC"}import { Event, Mechanism, StackFrame } from '@sentry/types';
/**
 * UUID4 generator
 *
 * @returns string Generated UUID4.
 */
export declare function uuid4(): string;
/**
 * Parses string form of URL into an object
 * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B
 * // intentionally using regex and not <a/> href parsing trick because React Native and other
 * // environments where DOM might not be available
 * @returns parsed URL object
 */
export declare function parseUrl(url: string): {
    host?: string;
    path?: string;
    protocol?: string;
    relative?: string;
};
/**
 * Extracts either message or type+value from an event that can be used for user-facing logs
 * @returns event's description
 */
export declare function getEventDescription(event: Event): string;
/**
 * Adds exception values, type and value to an synthetic Exception.
 * @param event The event to modify.
 * @param value Value of the exception.
 * @param type Type of the exception.
 * @hidden
 */
export declare function addExceptionTypeValue(event: Event, value?: string, type?: string): void;
/**
 * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.
 *
 * @param event The event to modify.
 * @param newMechanism Mechanism data to add to the event.
 * @hidden
 */
export declare function addExceptionMechanism(event: Event, newMechanism?: Partial<Mechanism>): void;
/**
 * Represents Semantic Versioning object
 */
interface SemVer {
    major?: number;
    minor?: number;
    patch?: number;
    prerelease?: string;
    buildmetadata?: string;
}
/**
 * Parses input into a SemVer interface
 * @param input string representation of a semver version
 */
export declare function parseSemver(input: string): SemVer;
/**
 * This function adds context (pre/post/line) lines to the provided frame
 *
 * @param lines string[] containing all lines
 * @param frame StackFrame that will be mutated
 * @param linesOfContext number of context lines we want to add pre/post
 */
export declare function addContextToFrame(lines: string[], frame: StackFrame, linesOfContext?: number): void;
/**
 * Strip the query string and fragment off of a given URL or path (if present)
 *
 * @param urlPath Full URL or path, including possible query string and/or fragment
 * @returns URL or path without query string or fragment
 */
export declare function stripUrlQueryAndFragment(urlPath: string): string;
/**
 * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object
 * in question), and marks it captured if not.
 *
 * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and
 * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so
 * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because
 * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not
 * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This
 * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we
 * see it.
 *
 * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on
 * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent
 * object wrapper forms so that this check will always work. However, because we need to flag the exact object which
 * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification
 * must be done before the exception captured.
 *
 * @param A thrown exception to check or flag as having been seen
 * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)
 */
export declare function checkOrSetAlreadyCaught(exception: unknown): boolean;
export {};
//# sourceMappingURL=misc.d.ts.map{"version":3,"file":"misc.d.ts","sourceRoot":"","sources":["../../src/misc.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAa,SAAS,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAaxE;;;;GAIG;AACH,wBAAgB,KAAK,IAAI,MAAM,CAoC9B;AAED;;;;;;GAMG;AACH,wBAAgB,QAAQ,CAAC,GAAG,EAAE,MAAM,GAAG;IACrC,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,QAAQ,CAAC,EAAE,MAAM,CAAC;CACnB,CAoBA;AAMD;;;GAGG;AACH,wBAAgB,mBAAmB,CAAC,KAAK,EAAE,KAAK,GAAG,MAAM,CAcxD;AAED;;;;;;GAMG;AACH,wBAAgB,qBAAqB,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE,MAAM,EAAE,IAAI,CAAC,EAAE,MAAM,GAAG,IAAI,CAUvF;AAED;;;;;;GAMG;AACH,wBAAgB,qBAAqB,CAAC,KAAK,EAAE,KAAK,EAAE,YAAY,CAAC,EAAE,OAAO,CAAC,SAAS,CAAC,GAAG,IAAI,CAc3F;AAMD;;GAEG;AACH,UAAU,MAAM;IACd,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,aAAa,CAAC,EAAE,MAAM,CAAC;CACxB;AAED;;;GAGG;AACH,wBAAgB,WAAW,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,CAYjD;AAED;;;;;;GAMG;AACH,wBAAgB,iBAAiB,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,KAAK,EAAE,UAAU,EAAE,cAAc,GAAE,MAAU,GAAG,IAAI,CActG;AAED;;;;;GAKG;AACH,wBAAgB,wBAAwB,CAAC,OAAO,EAAE,MAAM,GAAG,MAAM,CAGhE;AAED;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,wBAAgB,uBAAuB,CAAC,SAAS,EAAE,OAAO,GAAG,OAAO,CAenE"}/**
 * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
 * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
 */
/**
 * Checks whether we're in the Node.js or Browser environment
 *
 * @returns Answer to given question
 */
export declare function isNodeEnv(): boolean;
/**
 * Requires a module which is protected against bundler minification.
 *
 * @param request The module path to resolve
 */
export declare function dynamicRequire(mod: any, request: string): any;
/**
 * Helper for dynamically loading module that should work with linked dependencies.
 * The problem is that we _should_ be using `require(require.resolve(moduleName, { paths: [cwd()] }))`
 * However it's _not possible_ to do that with Webpack, as it has to know all the dependencies during
 * build time. `require.resolve` is also not available in any other way, so we cannot create,
 * a fake helper like we do with `dynamicRequire`.
 *
 * We always prefer to use local package, thus the value is not returned early from each `try/catch` block.
 * That is to mimic the behavior of `require.resolve` exactly.
 *
 * @param moduleName module name to require
 * @returns possibly required module
 */
export declare function loadModule<T>(moduleName: string): T | undefined;
//# sourceMappingURL=node.d.ts.map{"version":3,"file":"node.d.ts","sourceRoot":"","sources":["../../src/node.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAIH;;;;GAIG;AACH,wBAAgB,SAAS,IAAI,OAAO,CAOnC;AAED;;;;GAIG;AAEH,wBAAgB,cAAc,CAAC,GAAG,EAAE,GAAG,EAAE,OAAO,EAAE,MAAM,GAAG,GAAG,CAG7D;AAED;;;;;;;;;;;;GAYG;AACH,wBAAgB,UAAU,CAAC,CAAC,EAAE,UAAU,EAAE,MAAM,GAAG,CAAC,GAAG,SAAS,CAiB/D"}import { Primitive } from '@sentry/types';
import { MemoFunc } from './memo';
declare type ObjOrArray<T> = {
    [key: string]: T;
};
/**
 * Recursively normalizes the given object.
 *
 * - Creates a copy to prevent original input mutation
 * - Skips non-enumerable properties
 * - When stringifying, calls `toJSON` if implemented
 * - Removes circular references
 * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format
 * - Translates known global objects/classes to a string representations
 * - Takes care of `Error` object serialization
 * - Optionally limits depth of final output
 * - Optionally limits number of properties/elements included in any single object/array
 *
 * @param input The object to be normalized.
 * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)
 * @param maxProperties The max number of elements or properties to be included in any single array or
 * object in the normallized output..
 * @returns A normalized version of the object, or `"**non-serializable**"` if any errors are thrown during normalization.
 */
export declare function normalize(input: unknown, depth?: number, maxProperties?: number): any;
/** JSDoc */
export declare function normalizeToSize<T>(object: {
    [key: string]: any;
}, depth?: number, maxSize?: number): T;
/**
 * Visits a node to perform normalization on it
 *
 * @param key The key corresponding to the given node
 * @param value The node to be visited
 * @param depth Optional number indicating the maximum recursion depth
 * @param maxProperties Optional maximum number of properties/elements included in any single object/array
 * @param memo Optional Memo class handling decycling
 */
declare function visit(key: string, value: unknown, depth?: number, maxProperties?: number, memo?: MemoFunc): Primitive | ObjOrArray<unknown>;
export { visit as walk };
//# sourceMappingURL=normalize.d.ts.map{"version":3,"file":"normalize.d.ts","sourceRoot":"","sources":["../../src/normalize.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAG1C,OAAO,EAAe,QAAQ,EAAE,MAAM,QAAQ,CAAC;AAS/C,aAAK,UAAU,CAAC,CAAC,IAAI;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,CAAC,CAAA;CAAE,CAAC;AAE1C;;;;;;;;;;;;;;;;;;GAkBG;AACH,wBAAgB,SAAS,CAAC,KAAK,EAAE,OAAO,EAAE,KAAK,GAAE,MAAkB,EAAE,aAAa,GAAE,MAAkB,GAAG,GAAG,CAO3G;AAED,YAAY;AACZ,wBAAgB,eAAe,CAAC,CAAC,EAC/B,MAAM,EAAE;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;CAAE,EAE9B,KAAK,GAAE,MAAU,EAEjB,OAAO,GAAE,MAAmB,GAC3B,CAAC,CAQH;AAED;;;;;;;;GAQG;AACH,iBAAS,KAAK,CACZ,GAAG,EAAE,MAAM,EACX,KAAK,EAAE,OAAO,EACd,KAAK,GAAE,MAAkB,EACzB,aAAa,GAAE,MAAkB,EACjC,IAAI,GAAE,QAAwB,GAC7B,SAAS,GAAG,UAAU,CAAC,OAAO,CAAC,CAsEjC;AAGD,OAAO,EAAE,KAAK,IAAI,IAAI,EAAE,CAAC"}import { WrappedFunction } from '@sentry/types';
/**
 * Replace a method in an object with a wrapped version of itself.
 *
 * @param source An object that contains a method to be wrapped.
 * @param name The name of the method to be wrapped.
 * @param replacementFactory A higher-order function that takes the original version of the given method and returns a
 * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to
 * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other
 * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.
 * @returns void
 */
export declare function fill(source: {
    [key: string]: any;
}, name: string, replacementFactory: (...args: any[]) => any): void;
/**
 * Defines a non-enumerable property on the given object.
 *
 * @param obj The object on which to set the property
 * @param name The name of the property to be set
 * @param value The value to which to set the property
 */
export declare function addNonEnumerableProperty(obj: {
    [key: string]: unknown;
}, name: string, value: unknown): void;
/**
 * Remembers the original function on the wrapped function and
 * patches up the prototype.
 *
 * @param wrapped the wrapper function
 * @param original the original function that gets wrapped
 */
export declare function markFunctionWrapped(wrapped: WrappedFunction, original: WrappedFunction): void;
/**
 * This extracts the original function if available.  See
 * `markFunctionWrapped` for more information.
 *
 * @param func the function to unwrap
 * @returns the unwrapped version of the function if available.
 */
export declare function getOriginalFunction(func: WrappedFunction): WrappedFunction | undefined;
/**
 * Encodes given object into url-friendly format
 *
 * @param object An object that contains serializable values
 * @returns string Encoded
 */
export declare function urlEncode(object: {
    [key: string]: any;
}): string;
/**
 * Transforms any object into an object literal with all its attributes
 * attached to it.
 *
 * @param value Initial source that we have to transform in order for it to be usable by the serializer
 */
export declare function convertToPlainObject(value: unknown): {
    [key: string]: unknown;
};
/**
 * Given any captured exception, extract its keys and create a sorted
 * and truncated list that will be used inside the event message.
 * eg. `Non-error exception captured with keys: foo, bar, baz`
 */
export declare function extractExceptionKeysForMessage(exception: any, maxLength?: number): string;
/**
 * Given any object, return the new object with removed keys that value was `undefined`.
 * Works recursively on objects and arrays.
 */
export declare function dropUndefinedKeys<T>(val: T): T;
/**
 * Ensure that something is an object.
 *
 * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper
 * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.
 *
 * @param wat The subject of the objectification
 * @returns A version of `wat` which can safely be used with `Object` class methods
 */
export declare function objectify(wat: unknown): typeof Object;
//# sourceMappingURL=object.d.ts.map{"version":3,"file":"object.d.ts","sourceRoot":"","sources":["../../src/object.ts"],"names":[],"mappings":"AAEA,OAAO,EAAiB,eAAe,EAAE,MAAM,eAAe,CAAC;AAM/D;;;;;;;;;;GAUG;AACH,wBAAgB,IAAI,CAAC,MAAM,EAAE;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;CAAE,EAAE,IAAI,EAAE,MAAM,EAAE,kBAAkB,EAAE,CAAC,GAAG,IAAI,EAAE,GAAG,EAAE,KAAK,GAAG,GAAG,IAAI,CAoBpH;AAED;;;;;;GAMG;AACH,wBAAgB,wBAAwB,CAAC,GAAG,EAAE;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAAA;CAAE,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,OAAO,GAAG,IAAI,CAO5G;AAED;;;;;;GAMG;AACH,wBAAgB,mBAAmB,CAAC,OAAO,EAAE,eAAe,EAAE,QAAQ,EAAE,eAAe,GAAG,IAAI,CAI7F;AAED;;;;;;GAMG;AACH,wBAAgB,mBAAmB,CAAC,IAAI,EAAE,eAAe,GAAG,eAAe,GAAG,SAAS,CAEtF;AAED;;;;;GAKG;AACH,wBAAgB,SAAS,CAAC,MAAM,EAAE;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;CAAE,GAAG,MAAM,CAIhE;AAED;;;;;GAKG;AACH,wBAAgB,oBAAoB,CAAC,KAAK,EAAE,OAAO,GAAG;IACpD,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAAC;CACxB,CAqCA;AAsBD;;;;GAIG;AAEH,wBAAgB,8BAA8B,CAAC,SAAS,EAAE,GAAG,EAAE,SAAS,GAAE,MAAW,GAAG,MAAM,CAwB7F;AAED;;;GAGG;AACH,wBAAgB,iBAAiB,CAAC,CAAC,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,CAgB9C;AAED;;;;;;;;GAQG;AACH,wBAAgB,SAAS,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,MAAM,CA0BrD"}/** JSDoc */
export declare function resolve(...args: string[]): string;
/** JSDoc */
export declare function relative(from: string, to: string): string;
/** JSDoc */
export declare function normalizePath(path: string): string;
/** JSDoc */
export declare function isAbsolute(path: string): boolean;
/** JSDoc */
export declare function join(...args: string[]): string;
/** JSDoc */
export declare function dirname(path: string): string;
/** JSDoc */
export declare function basename(path: string, ext?: string): string;
//# sourceMappingURL=path.d.ts.map{"version":3,"file":"path.d.ts","sourceRoot":"","sources":["../../src/path.ts"],"names":[],"mappings":"AA4CA,YAAY;AACZ,wBAAgB,OAAO,CAAC,GAAG,IAAI,EAAE,MAAM,EAAE,GAAG,MAAM,CA0BjD;AA0BD,YAAY;AACZ,wBAAgB,QAAQ,CAAC,IAAI,EAAE,MAAM,EAAE,EAAE,EAAE,MAAM,GAAG,MAAM,CA0BzD;AAID,YAAY;AACZ,wBAAgB,aAAa,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,CAkBlD;AAGD,YAAY;AACZ,wBAAgB,UAAU,CAAC,IAAI,EAAE,MAAM,GAAG,OAAO,CAEhD;AAGD,YAAY;AACZ,wBAAgB,IAAI,CAAC,GAAG,IAAI,EAAE,MAAM,EAAE,GAAG,MAAM,CAE9C;AAED,YAAY;AACZ,wBAAgB,OAAO,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,CAgB5C;AAED,YAAY;AACZ,wBAAgB,QAAQ,CAAC,IAAI,EAAE,MAAM,EAAE,GAAG,CAAC,EAAE,MAAM,GAAG,MAAM,CAM3D"}export declare const setPrototypeOf: (o: any, proto: object | null) => any;
//# sourceMappingURL=polyfill.d.ts.map{"version":3,"file":"polyfill.d.ts","sourceRoot":"","sources":["../../src/polyfill.ts"],"names":[],"mappings":"AAAA,eAAO,MAAM,cAAc,uCACmE,CAAC"}export interface PromiseBuffer<T> {
    $: Array<PromiseLike<T>>;
    add(taskProducer: () => PromiseLike<T>): PromiseLike<T>;
    drain(timeout?: number): PromiseLike<boolean>;
}
/**
 * Creates an new PromiseBuffer object with the specified limit
 * @param limit max number of promises that can be stored in the buffer
 */
export declare function makePromiseBuffer<T>(limit?: number): PromiseBuffer<T>;
//# sourceMappingURL=promisebuffer.d.ts.map{"version":3,"file":"promisebuffer.d.ts","sourceRoot":"","sources":["../../src/promisebuffer.ts"],"names":[],"mappings":"AAGA,MAAM,WAAW,aAAa,CAAC,CAAC;IAG9B,CAAC,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;IACzB,GAAG,CAAC,YAAY,EAAE,MAAM,WAAW,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;IACxD,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC;CAC/C;AAED;;;GAGG;AACH,wBAAgB,iBAAiB,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE,MAAM,GAAG,aAAa,CAAC,CAAC,CAAC,CA4FrE"}export declare type RateLimits = Record<string, number>;
export declare const DEFAULT_RETRY_AFTER: number;
/**
 * Extracts Retry-After value from the request header or returns default value
 * @param header string representation of 'Retry-After' header
 * @param now current unix timestamp
 *
 */
export declare function parseRetryAfterHeader(header: string, now?: number): number;
/**
 * Gets the time that given category is disabled until for rate limiting
 */
export declare function disabledUntil(limits: RateLimits, category: string): number;
/**
 * Checks if a category is rate limited
 */
export declare function isRateLimited(limits: RateLimits, category: string, now?: number): boolean;
/**
 * Update ratelimits from incoming headers.
 * Returns true if headers contains a non-empty rate limiting header.
 */
export declare function updateRateLimits(limits: RateLimits, headers: Record<string, string | null | undefined>, now?: number): RateLimits;
//# sourceMappingURL=ratelimit.d.ts.map{"version":3,"file":"ratelimit.d.ts","sourceRoot":"","sources":["../../src/ratelimit.ts"],"names":[],"mappings":"AACA,oBAAY,UAAU,GAAG,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;AAEhD,eAAO,MAAM,mBAAmB,QAAY,CAAC;AAE7C;;;;;GAKG;AACH,wBAAgB,qBAAqB,CAAC,MAAM,EAAE,MAAM,EAAE,GAAG,GAAE,MAAmB,GAAG,MAAM,CAYtF;AAED;;GAEG;AACH,wBAAgB,aAAa,CAAC,MAAM,EAAE,UAAU,EAAE,QAAQ,EAAE,MAAM,GAAG,MAAM,CAE1E;AAED;;GAEG;AACH,wBAAgB,aAAa,CAAC,MAAM,EAAE,UAAU,EAAE,QAAQ,EAAE,MAAM,EAAE,GAAG,GAAE,MAAmB,GAAG,OAAO,CAErG;AAED;;;GAGG;AACH,wBAAgB,gBAAgB,CAC9B,MAAM,EAAE,UAAU,EAClB,OAAO,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,GAAG,IAAI,GAAG,SAAS,CAAC,EAClD,GAAG,GAAE,MAAmB,GACvB,UAAU,CAwCZ"}import { Severity } from '@sentry/types';
import { SeverityLevel } from './enums';
/**
 * Converts a string-based level into a {@link Severity}.
 *
 * @param level string representation of Severity
 * @returns Severity
 */
export declare function severityFromString(level: SeverityLevel | string): Severity;
//# sourceMappingURL=severity.d.ts.map{"version":3,"file":"severity.d.ts","sourceRoot":"","sources":["../../src/severity.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,eAAe,CAAC;AAEzC,OAAO,EAAE,aAAa,EAAkB,MAAM,SAAS,CAAC;AAKxD;;;;;GAKG;AACH,wBAAgB,kBAAkB,CAAC,KAAK,EAAE,aAAa,GAAG,MAAM,GAAG,QAAQ,CAM1E"}import { StackFrame } from '@sentry/types';
export declare type StackParser = (stack: string, skipFirst?: number) => StackFrame[];
export declare type StackLineParserFn = (line: string) => StackFrame | undefined;
export declare type StackLineParser = [number, StackLineParserFn];
/**
 * Creates a stack parser with the supplied line parsers
 *
 * StackFrames are returned in the correct order for Sentry Exception
 * frames and with Sentry SDK internal frames removed from the top and bottom
 *
 */
export declare function createStackParser(...parsers: StackLineParser[]): StackParser;
/**
 * @hidden
 */
export declare function stripSentryFramesAndReverse(stack: StackFrame[]): StackFrame[];
/**
 * Safely extract function name from itself
 */
export declare function getFunctionName(fn: unknown): string;
//# sourceMappingURL=stacktrace.d.ts.map{"version":3,"file":"stacktrace.d.ts","sourceRoot":"","sources":["../../src/stacktrace.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAI3C,oBAAY,WAAW,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,SAAS,CAAC,EAAE,MAAM,KAAK,UAAU,EAAE,CAAC;AAC9E,oBAAY,iBAAiB,GAAG,CAAC,IAAI,EAAE,MAAM,KAAK,UAAU,GAAG,SAAS,CAAC;AACzE,oBAAY,eAAe,GAAG,CAAC,MAAM,EAAE,iBAAiB,CAAC,CAAC;AAE1D;;;;;;GAMG;AACH,wBAAgB,iBAAiB,CAAC,GAAG,OAAO,EAAE,eAAe,EAAE,GAAG,WAAW,CAmB5E;AAED;;GAEG;AACH,wBAAgB,2BAA2B,CAAC,KAAK,EAAE,UAAU,EAAE,GAAG,UAAU,EAAE,CA6B7E;AAID;;GAEG;AACH,wBAAgB,eAAe,CAAC,EAAE,EAAE,OAAO,GAAG,MAAM,CAWnD"}import { EventStatus } from '@sentry/types';
/**
 * Converts an HTTP status code to sentry status {@link EventStatus}.
 *
 * @param code number HTTP status code
 * @returns EventStatus
 */
export declare function eventStatusFromHttpCode(code: number): EventStatus;
//# sourceMappingURL=status.d.ts.map{"version":3,"file":"status.d.ts","sourceRoot":"","sources":["../../src/status.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C;;;;;GAKG;AACH,wBAAgB,uBAAuB,CAAC,IAAI,EAAE,MAAM,GAAG,WAAW,CAkBjE"}/**
 * Truncates given string to the maximum characters count
 *
 * @param str An object that contains serializable values
 * @param max Maximum number of characters in truncated string (0 = unlimited)
 * @returns string Encoded
 */
export declare function truncate(str: string, max?: number): string;
/**
 * This is basically just `trim_line` from
 * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67
 *
 * @param str An object that contains serializable values
 * @param max Maximum number of characters in truncated string
 * @returns string Encoded
 */
export declare function snipLine(line: string, colno: number): string;
/**
 * Join values in array
 * @param input array of values to be joined together
 * @param delimiter string to be placed in-between values
 * @returns Joined values
 */
export declare function safeJoin(input: any[], delimiter?: string): string;
/**
 * Checks if the value matches a regex or includes the string
 * @param value The string value to be checked against
 * @param pattern Either a regex or a string that must be contained in value
 */
export declare function isMatchingPattern(value: string, pattern: RegExp | string): boolean;
/**
 * Given a string, escape characters which have meaning in the regex grammar, such that the result is safe to feed to
 * `new RegExp()`.
 *
 * Based on https://github.com/sindresorhus/escape-string-regexp. Vendored to a) reduce the size by skipping the runtime
 * type-checking, and b) ensure it gets down-compiled for old versions of Node (the published package only supports Node
 * 12+).
 *
 * @param regexString The string to escape
 * @returns An version of the string with all special regex characters escaped
 */
export declare function escapeStringForRegex(regexString: string): string;
//# sourceMappingURL=string.d.ts.map{"version":3,"file":"string.d.ts","sourceRoot":"","sources":["../../src/string.ts"],"names":[],"mappings":"AAEA;;;;;;GAMG;AACH,wBAAgB,QAAQ,CAAC,GAAG,EAAE,MAAM,EAAE,GAAG,GAAE,MAAU,GAAG,MAAM,CAK7D;AAED;;;;;;;GAOG;AACH,wBAAgB,QAAQ,CAAC,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,GAAG,MAAM,CAiC5D;AAED;;;;;GAKG;AAEH,wBAAgB,QAAQ,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE,SAAS,CAAC,EAAE,MAAM,GAAG,MAAM,CAiBjE;AAED;;;;GAIG;AACH,wBAAgB,iBAAiB,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,GAAG,MAAM,GAAG,OAAO,CAYlF;AAED;;;;;;;;;;GAUG;AACH,wBAAgB,oBAAoB,CAAC,WAAW,EAAE,MAAM,GAAG,MAAM,CAIhE"}/**
 * Tells whether current environment supports ErrorEvent objects
 * {@link supportsErrorEvent}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsErrorEvent(): boolean;
/**
 * Tells whether current environment supports DOMError objects
 * {@link supportsDOMError}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsDOMError(): boolean;
/**
 * Tells whether current environment supports DOMException objects
 * {@link supportsDOMException}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsDOMException(): boolean;
/**
 * Tells whether current environment supports Fetch API
 * {@link supportsFetch}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsFetch(): boolean;
/**
 * isNativeFetch checks if the given function is a native implementation of fetch()
 */
export declare function isNativeFetch(func: Function): boolean;
/**
 * Tells whether current environment supports Fetch API natively
 * {@link supportsNativeFetch}.
 *
 * @returns true if `window.fetch` is natively implemented, false otherwise
 */
export declare function supportsNativeFetch(): boolean;
/**
 * Tells whether current environment supports ReportingObserver API
 * {@link supportsReportingObserver}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsReportingObserver(): boolean;
/**
 * Tells whether current environment supports Referrer Policy API
 * {@link supportsReferrerPolicy}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsReferrerPolicy(): boolean;
/**
 * Tells whether current environment supports History API
 * {@link supportsHistory}.
 *
 * @returns Answer to the given question.
 */
export declare function supportsHistory(): boolean;
//# sourceMappingURL=supports.d.ts.map{"version":3,"file":"supports.d.ts","sourceRoot":"","sources":["../../src/supports.ts"],"names":[],"mappings":"AAIA;;;;;GAKG;AACH,wBAAgB,kBAAkB,IAAI,OAAO,CAO5C;AAED;;;;;GAKG;AACH,wBAAgB,gBAAgB,IAAI,OAAO,CAU1C;AAED;;;;;GAKG;AACH,wBAAgB,oBAAoB,IAAI,OAAO,CAO9C;AAED;;;;;GAKG;AACH,wBAAgB,aAAa,IAAI,OAAO,CAavC;AACD;;GAEG;AAEH,wBAAgB,aAAa,CAAC,IAAI,EAAE,QAAQ,GAAG,OAAO,CAErD;AAED;;;;;GAKG;AACH,wBAAgB,mBAAmB,IAAI,OAAO,CAmC7C;AAED;;;;;GAKG;AACH,wBAAgB,yBAAyB,IAAI,OAAO,CAEnD;AAED;;;;;GAKG;AACH,wBAAgB,sBAAsB,IAAI,OAAO,CAkBhD;AAED;;;;;GAKG;AACH,wBAAgB,eAAe,IAAI,OAAO,CAazC"}/**
 * Creates a resolved sync promise.
 *
 * @param value the value to resolve the promise with
 * @returns the resolved sync promise
 */
export declare function resolvedSyncPromise<T>(value: T | PromiseLike<T>): PromiseLike<T>;
/**
 * Creates a rejected sync promise.
 *
 * @param value the value to reject the promise with
 * @returns the rejected sync promise
 */
export declare function rejectedSyncPromise<T = never>(reason?: any): PromiseLike<T>;
/**
 * Thenable class that behaves like a Promise and follows it's interface
 * but is not async internally
 */
declare class SyncPromise<T> implements PromiseLike<T> {
    private _state;
    private _handlers;
    private _value;
    constructor(executor: (resolve: (value?: T | PromiseLike<T> | null) => void, reject: (reason?: any) => void) => void);
    /** JSDoc */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null): PromiseLike<TResult1 | TResult2>;
    /** JSDoc */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null): PromiseLike<T | TResult>;
    /** JSDoc */
    finally<TResult>(onfinally?: (() => void) | null): PromiseLike<TResult>;
    /** JSDoc */
    private readonly _resolve;
    /** JSDoc */
    private readonly _reject;
    /** JSDoc */
    private readonly _setResult;
    /** JSDoc */
    private readonly _executeHandlers;
}
export { SyncPromise };
//# sourceMappingURL=syncpromise.d.ts.map{"version":3,"file":"syncpromise.d.ts","sourceRoot":"","sources":["../../src/syncpromise.ts"],"names":[],"mappings":"AAgBA;;;;;GAKG;AACH,wBAAgB,mBAAmB,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAIhF;AAED;;;;;GAKG;AACH,wBAAgB,mBAAmB,CAAC,CAAC,GAAG,KAAK,EAAE,MAAM,CAAC,EAAE,GAAG,GAAG,WAAW,CAAC,CAAC,CAAC,CAI3E;AAED;;;GAGG;AACH,cAAM,WAAW,CAAC,CAAC,CAAE,YAAW,WAAW,CAAC,CAAC,CAAC;IAC5C,OAAO,CAAC,MAAM,CAA0B;IACxC,OAAO,CAAC,SAAS,CAAkE;IACnF,OAAO,CAAC,MAAM,CAAM;gBAGlB,QAAQ,EAAE,CAAC,OAAO,EAAE,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,GAAG,IAAI,KAAK,IAAI,EAAE,MAAM,EAAE,CAAC,MAAM,CAAC,EAAE,GAAG,KAAK,IAAI,KAAK,IAAI;IAS1G,YAAY;IACL,IAAI,CAAC,QAAQ,GAAG,CAAC,EAAE,QAAQ,GAAG,KAAK,EACxC,WAAW,CAAC,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,KAAK,QAAQ,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,EACrE,UAAU,CAAC,EAAE,CAAC,CAAC,MAAM,EAAE,GAAG,KAAK,QAAQ,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,GACtE,WAAW,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAiCnC,YAAY;IACL,KAAK,CAAC,OAAO,GAAG,KAAK,EAC1B,UAAU,CAAC,EAAE,CAAC,CAAC,MAAM,EAAE,GAAG,KAAK,OAAO,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC,GAAG,IAAI,GACpE,WAAW,CAAC,CAAC,GAAG,OAAO,CAAC;IAI3B,YAAY;IACL,OAAO,CAAC,OAAO,EAAE,SAAS,CAAC,EAAE,CAAC,MAAM,IAAI,CAAC,GAAG,IAAI,GAAG,WAAW,CAAC,OAAO,CAAC;IA+B9E,YAAY;IACZ,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAEvB;IAEF,YAAY;IACZ,OAAO,CAAC,QAAQ,CAAC,OAAO,CAEtB;IAEF,YAAY;IACZ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAczB;IAEF,YAAY;IACZ,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAwB/B;CACH;AAED,OAAO,EAAE,WAAW,EAAE,CAAC"}/**
 * Returns a timestamp in seconds since the UNIX epoch using the Date API.
 */
export declare const dateTimestampInSeconds: () => number;
/**
 * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the
 * availability of the Performance API.
 *
 * See `usingPerformanceAPI` to test whether the Performance API is used.
 *
 * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is
 * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The
 * skew can grow to arbitrary amounts like days, weeks or months.
 * See https://github.com/getsentry/sentry-javascript/issues/2590.
 */
export declare const timestampInSeconds: () => number;
export declare const timestampWithMs: () => number;
/**
 * A boolean that is true when timestampInSeconds uses the Performance API to produce monotonic timestamps.
 */
export declare const usingPerformanceAPI: boolean;
/**
 * Internal helper to store what is the source of browserPerformanceTimeOrigin below. For debugging only.
 */
export declare let _browserPerformanceTimeOriginMode: string;
/**
 * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the
 * performance API is available.
 */
export declare const browserPerformanceTimeOrigin: number | undefined;
//# sourceMappingURL=time.d.ts.map{"version":3,"file":"time.d.ts","sourceRoot":"","sources":["../../src/time.ts"],"names":[],"mappings":"AAsGA;;GAEG;AACH,eAAO,MAAM,sBAAsB,EAAE,MAAM,MAAiE,CAAC;AAE7G;;;;;;;;;;GAUG;AACH,eAAO,MAAM,kBAAkB,EAAE,MAAM,MAAyD,CAAC;AAGjG,eAAO,MAAM,eAAe,cAAqB,CAAC;AAElD;;GAEG;AACH,eAAO,MAAM,mBAAmB,SAAoC,CAAC;AAErE;;GAEG;AACH,eAAO,IAAI,iCAAiC,EAAE,MAAM,CAAC;AAErD;;;GAGG;AACH,eAAO,MAAM,4BAA4B,oBA+CrC,CAAC"}import { TraceparentData } from '@sentry/types';
export declare const TRACEPARENT_REGEXP: RegExp;
/**
 * Extract transaction context data from a `sentry-trace` header.
 *
 * @param traceparent Traceparent string
 *
 * @returns Object containing data from the header, or undefined if traceparent string is malformed
 */
export declare function extractTraceparentData(traceparent: string): TraceparentData | undefined;
//# sourceMappingURL=tracing.d.ts.map{"version":3,"file":"tracing.d.ts","sourceRoot":"","sources":["../../src/tracing.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,eAAe,EAAE,MAAM,eAAe,CAAC;AAEhD,eAAO,MAAM,kBAAkB,QAM9B,CAAC;AAEF;;;;;;GAMG;AACH,wBAAgB,sBAAsB,CAAC,WAAW,EAAE,MAAM,GAAG,eAAe,GAAG,SAAS,CAgBvF"}/**
 * An events map is an interface that maps event names to their value, which
 * represents the type of the `on` listener.
 */
export interface EventsMap {
    [event: string]: any;
}

/**
 * The default events map, used if no EventsMap is given. Using this EventsMap
 * is equivalent to accepting all event names, and any data.
 */
export interface DefaultEventsMap {
    [event: string]: (...args: any[]) => void;
}

/**
 * Returns a union type containing all the keys of an event map.
 */
export type EventNames<Map extends EventsMap> = keyof Map & (string | symbol);

/** The tuple type representing the parameters of an event listener */
export type EventParams<
    Map extends EventsMap,
    Ev extends EventNames<Map>
    > = Parameters<Map[Ev]>;

/**
 * The event names that are either in ReservedEvents or in UserEvents
 */
export type ReservedOrUserEventNames<
    ReservedEventsMap extends EventsMap,
    UserEvents extends EventsMap
    > = EventNames<ReservedEventsMap> | EventNames<UserEvents>;

/**
 * Type of a listener of a user event or a reserved event. If `Ev` is in
 * `ReservedEvents`, the reserved event listener is returned.
 */
export type ReservedOrUserListener<
    ReservedEvents extends EventsMap,
    UserEvents extends EventsMap,
    Ev extends ReservedOrUserEventNames<ReservedEvents, UserEvents>
    > = FallbackToUntypedListener<
    Ev extends EventNames<ReservedEvents>
        ? ReservedEvents[Ev]
        : Ev extends EventNames<UserEvents>
        ? UserEvents[Ev]
        : never
    >;

/**
 * Returns an untyped listener type if `T` is `never`; otherwise, returns `T`.
 *
 * This is a hack to mitigate https://github.com/socketio/socket.io/issues/3833.
 * Needed because of https://github.com/microsoft/TypeScript/issues/41778
 */
type FallbackToUntypedListener<T> = [T] extends [never]
    ? (...args: any[]) => void | Promise<void>
    : T;

/**
 * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type
 * parameters for mappings of event names to event data types, and strictly
 * types method calls to the `EventEmitter` according to these event maps.
 *
 * @typeParam ListenEvents - `EventsMap` of user-defined events that can be
 * listened to with `on` or `once`
 * @typeParam EmitEvents - `EventsMap` of user-defined events that can be
 * emitted with `emit`
 * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be
 * emitted by socket.io with `emitReserved`, and can be listened to with
 * `listen`.
 */
export class Emitter<
    ListenEvents extends EventsMap,
    EmitEvents extends EventsMap,
    ReservedEvents extends EventsMap = {}
    > {
    /**
     * Adds the `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */
    on<Ev extends ReservedOrUserEventNames<ReservedEvents, ListenEvents>>(
        ev: Ev,
        listener: ReservedOrUserListener<ReservedEvents, ListenEvents, Ev>
    ): this;

    /**
     * Adds a one-time `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */
    once<Ev extends ReservedOrUserEventNames<ReservedEvents, ListenEvents>>(
        ev: Ev,
        listener: ReservedOrUserListener<ReservedEvents, ListenEvents, Ev>
    ): this;

    /**
     * Removes the `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */
    off<Ev extends ReservedOrUserEventNames<ReservedEvents, ListenEvents>>(
        ev?: Ev,
        listener?: ReservedOrUserListener<ReservedEvents, ListenEvents, Ev>
    ): this;

    /**
     * Emits an event.
     *
     * @param ev Name of the event
     * @param args Values to send to listeners of this event
     */
    emit<Ev extends EventNames<EmitEvents>>(
        ev: Ev,
        ...args: EventParams<EmitEvents, Ev>
    ): this;

    /**
     * Emits a reserved event.
     *
     * This method is `protected`, so that only a class extending
     * `StrictEventEmitter` can emit its own reserved events.
     *
     * @param ev Reserved event name
     * @param args Arguments to emit along with the event
     */
    protected emitReserved<Ev extends EventNames<ReservedEvents>>(
        ev: Ev,
        ...args: EventParams<ReservedEvents, Ev>
    ): this;

    /**
     * Returns the listeners listening to an event.
     *
     * @param event Event name
     * @returns Array of listeners subscribed to `event`
     */
    listeners<Ev extends ReservedOrUserEventNames<ReservedEvents, ListenEvents>>(
        event: Ev
    ): ReservedOrUserListener<ReservedEvents, ListenEvents, Ev>[];

    /**
     * Returns true if there is a listener for this event.
     *
     * @param event Event name
     * @returns boolean
     */
    hasListeners<
        Ev extends ReservedOrUserEventNames<ReservedEvents, ListenEvents>
        >(event: Ev): boolean;

    /**
     * Removes the `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */
    removeListener<
        Ev extends ReservedOrUserEventNames<ReservedEvents, ListenEvents>
        >(
        ev?: Ev,
        listener?: ReservedOrUserListener<ReservedEvents, ListenEvents, Ev>
    ): this;

    /**
     * Removes all `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     */
    removeAllListeners<
        Ev extends ReservedOrUserEventNames<ReservedEvents, ListenEvents>
        >(ev?: Ev): this;
}

/**
 * Expose `Emitter`.
 */

exports.Emitter = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

// alias used for reserved events (protected method)
Emitter.prototype.emitReserved = Emitter.prototype.emit;

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};
{
  "name": "@socket.io/component-emitter",
  "type": "commonjs"
}
/**
 * An events map is an interface that maps event names to their value, which
 * represents the type of the `on` listener.
 */
export interface EventsMap {
    [event: string]: any;
}

/**
 * The default events map, used if no EventsMap is given. Using this EventsMap
 * is equivalent to accepting all event names, and any data.
 */
export interface DefaultEventsMap {
    [event: string]: (...args: any[]) => void;
}

/**
 * Returns a union type containing all the keys of an event map.
 */
export type EventNames<Map extends EventsMap> = keyof Map & (string | symbol);

/** The tuple type representing the parameters of an event listener */
export type EventParams<
    Map extends EventsMap,
    Ev extends EventNames<Map>
    > = Parameters<Map[Ev]>;

/**
 * The event names that are either in ReservedEvents or in UserEvents
 */
export type ReservedOrUserEventNames<
    ReservedEventsMap extends EventsMap,
    UserEvents extends EventsMap
    > = EventNames<ReservedEventsMap> | EventNames<UserEvents>;

/**
 * Type of a listener of a user event or a reserved event. If `Ev` is in
 * `ReservedEvents`, the reserved event listener is returned.
 */
export type ReservedOrUserListener<
    ReservedEvents extends EventsMap,
    UserEvents extends EventsMap,
    Ev extends ReservedOrUserEventNames<ReservedEvents, UserEvents>
    > = FallbackToUntypedListener<
    Ev extends EventNames<ReservedEvents>
        ? ReservedEvents[Ev]
        : Ev extends EventNames<UserEvents>
        ? UserEvents[Ev]
        : never
    >;

/**
 * Returns an untyped listener type if `T` is `never`; otherwise, returns `T`.
 *
 * This is a hack to mitigate https://github.com/socketio/socket.io/issues/3833.
 * Needed because of https://github.com/microsoft/TypeScript/issues/41778
 */
type FallbackToUntypedListener<T> = [T] extends [never]
    ? (...args: any[]) => void | Promise<void>
    : T;

/**
 * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type
 * parameters for mappings of event names to event data types, and strictly
 * types method calls to the `EventEmitter` according to these event maps.
 *
 * @typeParam ListenEvents - `EventsMap` of user-defined events that can be
 * listened to with `on` or `once`
 * @typeParam EmitEvents - `EventsMap` of user-defined events that can be
 * emitted with `emit`
 * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be
 * emitted by socket.io with `emitReserved`, and can be listened to with
 * `listen`.
 */
export class Emitter<
    ListenEvents extends EventsMap,
    EmitEvents extends EventsMap,
    ReservedEvents extends EventsMap = {}
    > {
    /**
     * Adds the `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */
    on<Ev extends ReservedOrUserEventNames<ReservedEvents, ListenEvents>>(
        ev: Ev,
        listener: ReservedOrUserListener<ReservedEvents, ListenEvents, Ev>
    ): this;

    /**
     * Adds a one-time `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */
    once<Ev extends ReservedOrUserEventNames<ReservedEvents, ListenEvents>>(
        ev: Ev,
        listener: ReservedOrUserListener<ReservedEvents, ListenEvents, Ev>
    ): this;

    /**
     * Removes the `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */
    off<Ev extends ReservedOrUserEventNames<ReservedEvents, ListenEvents>>(
        ev?: Ev,
        listener?: ReservedOrUserListener<ReservedEvents, ListenEvents, Ev>
    ): this;

    /**
     * Emits an event.
     *
     * @param ev Name of the event
     * @param args Values to send to listeners of this event
     */
    emit<Ev extends EventNames<EmitEvents>>(
        ev: Ev,
        ...args: EventParams<EmitEvents, Ev>
    ): this;

    /**
     * Emits a reserved event.
     *
     * This method is `protected`, so that only a class extending
     * `StrictEventEmitter` can emit its own reserved events.
     *
     * @param ev Reserved event name
     * @param args Arguments to emit along with the event
     */
    protected emitReserved<Ev extends EventNames<ReservedEvents>>(
        ev: Ev,
        ...args: EventParams<ReservedEvents, Ev>
    ): this;

    /**
     * Returns the listeners listening to an event.
     *
     * @param event Event name
     * @returns Array of listeners subscribed to `event`
     */
    listeners<Ev extends ReservedOrUserEventNames<ReservedEvents, ListenEvents>>(
        event: Ev
    ): ReservedOrUserListener<ReservedEvents, ListenEvents, Ev>[];

    /**
     * Returns true if there is a listener for this event.
     *
     * @param event Event name
     * @returns boolean
     */
    hasListeners<
        Ev extends ReservedOrUserEventNames<ReservedEvents, ListenEvents>
        >(event: Ev): boolean;

    /**
     * Removes the `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */
    removeListener<
        Ev extends ReservedOrUserEventNames<ReservedEvents, ListenEvents>
        >(
        ev?: Ev,
        listener?: ReservedOrUserListener<ReservedEvents, ListenEvents, Ev>
    ): this;

    /**
     * Removes all `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     */
    removeAllListeners<
        Ev extends ReservedOrUserEventNames<ReservedEvents, ListenEvents>
        >(ev?: Ev): this;
}
/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

export function Emitter(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

// alias used for reserved events (protected method)
Emitter.prototype.emitReserved = Emitter.prototype.emit;

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};
{
  "name": "@socket.io/component-emitter",
  "type": "module"
}
(The MIT License)

Copyright (c) 2014 Component contributors <dev@component.io>

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
{
  "name": "@socket.io/component-emitter",
  "description": "Event emitter",
  "version": "3.1.1",
  "license": "MIT",
  "devDependencies": {
    "mocha": "*",
    "should": "*"
  },
  "component": {
    "scripts": {
      "emitter/index.js": "index.js"
    }
  },
  "main": "./lib/cjs/index.js",
  "module": "./lib/esm/index.js",
  "types": "./lib/esm/index.d.ts",
  "repository": {
    "type": "git",
    "url": "https://github.com/socketio/emitter.git"
  },
  "scripts": {
    "test": "make test"
  },
  "files": [
    "lib/"
  ]
}
# `@socket.io/component-emitter`

  Event emitter component.

This project is a fork of the [`component-emitter`](https://github.com/sindresorhus/component-emitter) project, with [Socket.IO](https://socket.io/)-specific TypeScript typings.

## Installation

```
$ npm i @socket.io/component-emitter
```

## API

### Emitter(obj)

  The `Emitter` may also be used as a mixin. For example
  a "plain" object may become an emitter, or you may
  extend an existing prototype.

  As an `Emitter` instance:

```js
import { Emitter } from '@socket.io/component-emitter';

var emitter = new Emitter;
emitter.emit('something');
```

  As a mixin:

```js
import { Emitter } from '@socket.io/component-emitter';

var user = { name: 'tobi' };
Emitter(user);

user.emit('im a user');
```

  As a prototype mixin:

```js
import { Emitter } from '@socket.io/component-emitter';

Emitter(User.prototype);
```

### Emitter#on(event, fn)

  Register an `event` handler `fn`.

### Emitter#once(event, fn)

  Register a single-shot `event` handler `fn`,
  removed immediately after it is invoked the
  first time.

### Emitter#off(event, fn)

  * Pass `event` and `fn` to remove a listener.
  * Pass `event` to remove all listeners on that event.
  * Pass nothing to remove all listeners on all events.

### Emitter#emit(event, ...)

  Emit an `event` with variable option args.

### Emitter#listeners(event)

  Return an array of callbacks, or an empty array.

### Emitter#hasListeners(event)

  Check if this emitter has `event` handlers.

## License

MIT
/**
 * Read-only token
 * See https://github.com/Borewit/strtok3 for more information
 */
export interface IGetToken<Value, Array extends Uint8Array = Uint8Array> {

  /**
   * Length of encoded token in bytes
   */
  len: number;

  /**
   * Decode value from buffer at offset
   * @param array - Uint8Array to read the decoded value from
   * @param offset - Decode offset
   * @return decoded value
   */
  get(array: Array, offset: number): Value;
}

export interface IToken<Value, Array extends Uint8Array = Uint8Array> extends IGetToken<Value, Array> {
  /**
   * Encode value to buffer
   * @param array - Uint8Array to write the encoded value to
   * @param offset - Buffer write offset
   * @param value - Value to decode of type T
   * @return offset plus number of bytes written
   */
  put(array: Array, offset: number, value: Value): number
}
{
  "name": "@tokenizer/token",
  "version": "0.3.0",
  "description": "TypeScript definition for strtok3 token",
  "main": "",
  "types": "index.d.ts",
  "files": [
    "index.d.ts"
  ],
  "keywords": [
    "token",
    "interface",
    "tokenizer",
    "TypeScript"
  ],
  "author": {
    "name": "Borewit",
    "url": "https://github.com/Borewit"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/Borewit/tokenizer-token.git"
  },
  "bugs": {
    "url": "https://github.com/Borewit/tokenizer-token/issues"
  },
  "typeScriptVersion": "3.0",
  "dependencies": {},
  "devDependencies": {
    "@types/node": "^13.1.0"
  }
}
[![npm version](https://badge.fury.io/js/%40tokenizer%2Ftoken.svg)](https://www.npmjs.com/package/@tokenizer/token)
[![npm downloads](http://img.shields.io/npm/dm/@tokenizer/token.svg)](https://npmcharts.com/compare/@tokenizer/token?interval=30)

# @tokenizer/token

TypeScript definition of an [strtok3](https://github.com/Borewit/strtok3) token.

## Licence

(The MIT License)

Copyright (c) 2020 Borewit

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// package: google.protobuf
// file: any.proto

import * as jspb from "../../index";

export class Any extends jspb.Message {
  getTypeUrl(): string;
  setTypeUrl(value: string): Any;

  getValue(): Uint8Array | string;
  getValue_asU8(): Uint8Array;
  getValue_asB64(): string;
  setValue(value: Uint8Array | string): Any;

  getTypeName(): string;
  pack(serialized: Uint8Array, name: string, typeUrlPrefix?: string): void;
  unpack<T extends jspb.Message>(deserialize: (packed: Uint8Array) => T, name: string): T | null;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Any.AsObject;
  static toObject(includeInstance: boolean, msg: Any): Any.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Any, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Any;
  static deserializeBinaryFromReader(message: Any, reader: jspb.BinaryReader): Any;
}

export namespace Any {
  export type AsObject = {
    typeUrl: string,
    value: Uint8Array | string,
  }
}
// package: google.protobuf
// file: api.proto

import * as jspb from "../../index";
import * as google_protobuf_source_context_pb from "./source_context_pb";
import * as google_protobuf_type_pb from "./type_pb";

export class Api extends jspb.Message {
  getName(): string;
  setName(value: string): Api;

  clearMethodsList(): Api;
  getMethodsList(): Array<Method>;
  setMethodsList(value: Array<Method>): Api;
  addMethods(value?: Method, index?: number): Method;

  clearOptionsList(): Api;
  getOptionsList(): Array<google_protobuf_type_pb.Option>;
  setOptionsList(value: Array<google_protobuf_type_pb.Option>): Api;
  addOptions(value?: google_protobuf_type_pb.Option, index?: number): google_protobuf_type_pb.Option;

  getVersion(): string;
  setVersion(value: string): Api;

  hasSourceContext(): boolean;
  clearSourceContext(): Api;
  getSourceContext(): google_protobuf_source_context_pb.SourceContext | undefined;
  setSourceContext(value?: google_protobuf_source_context_pb.SourceContext): Api;

  clearMixinsList(): Api;
  getMixinsList(): Array<Mixin>;
  setMixinsList(value: Array<Mixin>): Api;
  addMixins(value?: Mixin, index?: number): Mixin;

  getSyntax(): google_protobuf_type_pb.Syntax;
  setSyntax(value: google_protobuf_type_pb.Syntax): Api;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Api.AsObject;
  static toObject(includeInstance: boolean, msg: Api): Api.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Api, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Api;
  static deserializeBinaryFromReader(message: Api, reader: jspb.BinaryReader): Api;
}

export namespace Api {
  export type AsObject = {
    name: string,
    methodsList: Array<Method.AsObject>,
    optionsList: Array<google_protobuf_type_pb.Option.AsObject>,
    version: string,
    sourceContext?: google_protobuf_source_context_pb.SourceContext.AsObject | undefined,
    mixinsList: Array<Mixin.AsObject>,
    syntax: google_protobuf_type_pb.Syntax,
  }
}

export class Method extends jspb.Message {
  getName(): string;
  setName(value: string): Method;

  getRequestTypeUrl(): string;
  setRequestTypeUrl(value: string): Method;

  getRequestStreaming(): boolean;
  setRequestStreaming(value: boolean): Method;

  getResponseTypeUrl(): string;
  setResponseTypeUrl(value: string): Method;

  getResponseStreaming(): boolean;
  setResponseStreaming(value: boolean): Method;

  clearOptionsList(): Method;
  getOptionsList(): Array<google_protobuf_type_pb.Option>;
  setOptionsList(value: Array<google_protobuf_type_pb.Option>): Method;
  addOptions(value?: google_protobuf_type_pb.Option, index?: number): google_protobuf_type_pb.Option;

  getSyntax(): google_protobuf_type_pb.Syntax;
  setSyntax(value: google_protobuf_type_pb.Syntax): Method;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Method.AsObject;
  static toObject(includeInstance: boolean, msg: Method): Method.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Method, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Method;
  static deserializeBinaryFromReader(message: Method, reader: jspb.BinaryReader): Method;
}

export namespace Method {
  export type AsObject = {
    name: string,
    requestTypeUrl: string,
    requestStreaming: boolean,
    responseTypeUrl: string,
    responseStreaming: boolean,
    optionsList: Array<google_protobuf_type_pb.Option.AsObject>,
    syntax: google_protobuf_type_pb.Syntax,
  }
}

export class Mixin extends jspb.Message {
  getName(): string;
  setName(value: string): Mixin;

  getRoot(): string;
  setRoot(value: string): Mixin;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Mixin.AsObject;
  static toObject(includeInstance: boolean, msg: Mixin): Mixin.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Mixin, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Mixin;
  static deserializeBinaryFromReader(message: Mixin, reader: jspb.BinaryReader): Mixin;
}

export namespace Mixin {
  export type AsObject = {
    name: string,
    root: string,
  }
}
// package: google.protobuf.compiler
// file: compiler/plugin.proto

import * as jspb from "../../../index";
import * as google_protobuf_descriptor_pb from "../descriptor_pb";

export class Version extends jspb.Message {
  hasMajor(): boolean;
  clearMajor(): Version;
  getMajor(): number | undefined;
  setMajor(value: number): Version;

  hasMinor(): boolean;
  clearMinor(): Version;
  getMinor(): number | undefined;
  setMinor(value: number): Version;

  hasPatch(): boolean;
  clearPatch(): Version;
  getPatch(): number | undefined;
  setPatch(value: number): Version;

  hasSuffix(): boolean;
  clearSuffix(): Version;
  getSuffix(): string | undefined;
  setSuffix(value: string): Version;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Version.AsObject;
  static toObject(includeInstance: boolean, msg: Version): Version.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Version, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Version;
  static deserializeBinaryFromReader(message: Version, reader: jspb.BinaryReader): Version;
}

export namespace Version {
  export type AsObject = {
    major?: number | undefined,
    minor?: number | undefined,
    patch?: number | undefined,
    suffix?: string | undefined,
  }
}

export class CodeGeneratorRequest extends jspb.Message {
  clearFileToGenerateList(): CodeGeneratorRequest;
  getFileToGenerateList(): Array<string>;
  setFileToGenerateList(value: Array<string>): CodeGeneratorRequest;
  addFileToGenerate(value: string, index?: number): string;

  hasParameter(): boolean;
  clearParameter(): CodeGeneratorRequest;
  getParameter(): string | undefined;
  setParameter(value: string): CodeGeneratorRequest;

  clearProtoFileList(): CodeGeneratorRequest;
  getProtoFileList(): Array<google_protobuf_descriptor_pb.FileDescriptorProto>;
  setProtoFileList(value: Array<google_protobuf_descriptor_pb.FileDescriptorProto>): CodeGeneratorRequest;
  addProtoFile(value?: google_protobuf_descriptor_pb.FileDescriptorProto, index?: number): google_protobuf_descriptor_pb.FileDescriptorProto;

  hasCompilerVersion(): boolean;
  clearCompilerVersion(): CodeGeneratorRequest;
  getCompilerVersion(): Version | undefined;
  setCompilerVersion(value?: Version): CodeGeneratorRequest;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): CodeGeneratorRequest.AsObject;
  static toObject(includeInstance: boolean, msg: CodeGeneratorRequest): CodeGeneratorRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: CodeGeneratorRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): CodeGeneratorRequest;
  static deserializeBinaryFromReader(message: CodeGeneratorRequest, reader: jspb.BinaryReader): CodeGeneratorRequest;
}

export namespace CodeGeneratorRequest {
  export type AsObject = {
    fileToGenerateList: Array<string>,
    parameter?: string | undefined,
    protoFileList: Array<google_protobuf_descriptor_pb.FileDescriptorProto.AsObject>,
    compilerVersion?: Version.AsObject | undefined,
  }
}

export class CodeGeneratorResponse extends jspb.Message {
  hasError(): boolean;
  clearError(): CodeGeneratorResponse;
  getError(): string | undefined;
  setError(value: string): CodeGeneratorResponse;

  hasSupportedFeatures(): boolean;
  clearSupportedFeatures(): CodeGeneratorResponse;
  getSupportedFeatures(): number | undefined;
  setSupportedFeatures(value: number): CodeGeneratorResponse;

  clearFileList(): CodeGeneratorResponse;
  getFileList(): Array<CodeGeneratorResponse.File>;
  setFileList(value: Array<CodeGeneratorResponse.File>): CodeGeneratorResponse;
  addFile(value?: CodeGeneratorResponse.File, index?: number): CodeGeneratorResponse.File;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): CodeGeneratorResponse.AsObject;
  static toObject(includeInstance: boolean, msg: CodeGeneratorResponse): CodeGeneratorResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: CodeGeneratorResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): CodeGeneratorResponse;
  static deserializeBinaryFromReader(message: CodeGeneratorResponse, reader: jspb.BinaryReader): CodeGeneratorResponse;
}

export namespace CodeGeneratorResponse {
  export type AsObject = {
    error?: string | undefined,
    supportedFeatures?: number | undefined,
    fileList: Array<File.AsObject>,
  }

  export enum Feature {
    FEATURE_NONE = 0,
    FEATURE_PROTO3_OPTIONAL = 1,
  }

  export class File extends jspb.Message {
    hasName(): boolean;
    clearName(): File;
    getName(): string | undefined;
    setName(value: string): File;

    hasInsertionPoint(): boolean;
    clearInsertionPoint(): File;
    getInsertionPoint(): string | undefined;
    setInsertionPoint(value: string): File;

    hasContent(): boolean;
    clearContent(): File;
    getContent(): string | undefined;
    setContent(value: string): File;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): File.AsObject;
    static toObject(includeInstance: boolean, msg: File): File.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: File, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): File;
    static deserializeBinaryFromReader(message: File, reader: jspb.BinaryReader): File;
  }

  export namespace File {
    export type AsObject = {
      name?: string | undefined,
      insertionPoint?: string | undefined,
      content?: string | undefined,
    }
  }
}
// package: google.protobuf
// file: descriptor.proto

import * as jspb from "../../index";

export class FileDescriptorSet extends jspb.Message {
  clearFileList(): FileDescriptorSet;
  getFileList(): Array<FileDescriptorProto>;
  setFileList(value: Array<FileDescriptorProto>): FileDescriptorSet;
  addFile(value?: FileDescriptorProto, index?: number): FileDescriptorProto;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FileDescriptorSet.AsObject;
  static toObject(includeInstance: boolean, msg: FileDescriptorSet): FileDescriptorSet.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FileDescriptorSet, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FileDescriptorSet;
  static deserializeBinaryFromReader(message: FileDescriptorSet, reader: jspb.BinaryReader): FileDescriptorSet;
}

export namespace FileDescriptorSet {
  export type AsObject = {
    fileList: Array<FileDescriptorProto.AsObject>,
  }
}

export class FileDescriptorProto extends jspb.Message {
  hasName(): boolean;
  clearName(): FileDescriptorProto;
  getName(): string | undefined;
  setName(value: string): FileDescriptorProto;

  hasPackage(): boolean;
  clearPackage(): FileDescriptorProto;
  getPackage(): string | undefined;
  setPackage(value: string): FileDescriptorProto;

  clearDependencyList(): FileDescriptorProto;
  getDependencyList(): Array<string>;
  setDependencyList(value: Array<string>): FileDescriptorProto;
  addDependency(value: string, index?: number): string;

  clearPublicDependencyList(): FileDescriptorProto;
  getPublicDependencyList(): Array<number>;
  setPublicDependencyList(value: Array<number>): FileDescriptorProto;
  addPublicDependency(value: number, index?: number): number;

  clearWeakDependencyList(): FileDescriptorProto;
  getWeakDependencyList(): Array<number>;
  setWeakDependencyList(value: Array<number>): FileDescriptorProto;
  addWeakDependency(value: number, index?: number): number;

  clearMessageTypeList(): FileDescriptorProto;
  getMessageTypeList(): Array<DescriptorProto>;
  setMessageTypeList(value: Array<DescriptorProto>): FileDescriptorProto;
  addMessageType(value?: DescriptorProto, index?: number): DescriptorProto;

  clearEnumTypeList(): FileDescriptorProto;
  getEnumTypeList(): Array<EnumDescriptorProto>;
  setEnumTypeList(value: Array<EnumDescriptorProto>): FileDescriptorProto;
  addEnumType(value?: EnumDescriptorProto, index?: number): EnumDescriptorProto;

  clearServiceList(): FileDescriptorProto;
  getServiceList(): Array<ServiceDescriptorProto>;
  setServiceList(value: Array<ServiceDescriptorProto>): FileDescriptorProto;
  addService(value?: ServiceDescriptorProto, index?: number): ServiceDescriptorProto;

  clearExtensionList(): FileDescriptorProto;
  getExtensionList(): Array<FieldDescriptorProto>;
  setExtensionList(value: Array<FieldDescriptorProto>): FileDescriptorProto;
  addExtension(value?: FieldDescriptorProto, index?: number): FieldDescriptorProto;

  hasOptions(): boolean;
  clearOptions(): FileDescriptorProto;
  getOptions(): FileOptions | undefined;
  setOptions(value?: FileOptions): FileDescriptorProto;

  hasSourceCodeInfo(): boolean;
  clearSourceCodeInfo(): FileDescriptorProto;
  getSourceCodeInfo(): SourceCodeInfo | undefined;
  setSourceCodeInfo(value?: SourceCodeInfo): FileDescriptorProto;

  hasSyntax(): boolean;
  clearSyntax(): FileDescriptorProto;
  getSyntax(): string | undefined;
  setSyntax(value: string): FileDescriptorProto;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FileDescriptorProto.AsObject;
  static toObject(includeInstance: boolean, msg: FileDescriptorProto): FileDescriptorProto.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FileDescriptorProto, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FileDescriptorProto;
  static deserializeBinaryFromReader(message: FileDescriptorProto, reader: jspb.BinaryReader): FileDescriptorProto;
}

export namespace FileDescriptorProto {
  export type AsObject = {
    name?: string | undefined,
    pb_package?: string | undefined,
    dependencyList: Array<string>,
    publicDependencyList: Array<number>,
    weakDependencyList: Array<number>,
    messageTypeList: Array<DescriptorProto.AsObject>,
    enumTypeList: Array<EnumDescriptorProto.AsObject>,
    serviceList: Array<ServiceDescriptorProto.AsObject>,
    extensionList: Array<FieldDescriptorProto.AsObject>,
    options?: FileOptions.AsObject | undefined,
    sourceCodeInfo?: SourceCodeInfo.AsObject | undefined,
    syntax?: string | undefined,
  }
}

export class DescriptorProto extends jspb.Message {
  hasName(): boolean;
  clearName(): DescriptorProto;
  getName(): string | undefined;
  setName(value: string): DescriptorProto;

  clearFieldList(): DescriptorProto;
  getFieldList(): Array<FieldDescriptorProto>;
  setFieldList(value: Array<FieldDescriptorProto>): DescriptorProto;
  addField(value?: FieldDescriptorProto, index?: number): FieldDescriptorProto;

  clearExtensionList(): DescriptorProto;
  getExtensionList(): Array<FieldDescriptorProto>;
  setExtensionList(value: Array<FieldDescriptorProto>): DescriptorProto;
  addExtension(value?: FieldDescriptorProto, index?: number): FieldDescriptorProto;

  clearNestedTypeList(): DescriptorProto;
  getNestedTypeList(): Array<DescriptorProto>;
  setNestedTypeList(value: Array<DescriptorProto>): DescriptorProto;
  addNestedType(value?: DescriptorProto, index?: number): DescriptorProto;

  clearEnumTypeList(): DescriptorProto;
  getEnumTypeList(): Array<EnumDescriptorProto>;
  setEnumTypeList(value: Array<EnumDescriptorProto>): DescriptorProto;
  addEnumType(value?: EnumDescriptorProto, index?: number): EnumDescriptorProto;

  clearExtensionRangeList(): DescriptorProto;
  getExtensionRangeList(): Array<DescriptorProto.ExtensionRange>;
  setExtensionRangeList(value: Array<DescriptorProto.ExtensionRange>): DescriptorProto;
  addExtensionRange(value?: DescriptorProto.ExtensionRange, index?: number): DescriptorProto.ExtensionRange;

  clearOneofDeclList(): DescriptorProto;
  getOneofDeclList(): Array<OneofDescriptorProto>;
  setOneofDeclList(value: Array<OneofDescriptorProto>): DescriptorProto;
  addOneofDecl(value?: OneofDescriptorProto, index?: number): OneofDescriptorProto;

  hasOptions(): boolean;
  clearOptions(): DescriptorProto;
  getOptions(): MessageOptions | undefined;
  setOptions(value?: MessageOptions): DescriptorProto;

  clearReservedRangeList(): DescriptorProto;
  getReservedRangeList(): Array<DescriptorProto.ReservedRange>;
  setReservedRangeList(value: Array<DescriptorProto.ReservedRange>): DescriptorProto;
  addReservedRange(value?: DescriptorProto.ReservedRange, index?: number): DescriptorProto.ReservedRange;

  clearReservedNameList(): DescriptorProto;
  getReservedNameList(): Array<string>;
  setReservedNameList(value: Array<string>): DescriptorProto;
  addReservedName(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DescriptorProto.AsObject;
  static toObject(includeInstance: boolean, msg: DescriptorProto): DescriptorProto.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DescriptorProto, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DescriptorProto;
  static deserializeBinaryFromReader(message: DescriptorProto, reader: jspb.BinaryReader): DescriptorProto;
}

export namespace DescriptorProto {
  export type AsObject = {
    name?: string | undefined,
    fieldList: Array<FieldDescriptorProto.AsObject>,
    extensionList: Array<FieldDescriptorProto.AsObject>,
    nestedTypeList: Array<AsObject>,
    enumTypeList: Array<EnumDescriptorProto.AsObject>,
    extensionRangeList: Array<ExtensionRange.AsObject>,
    oneofDeclList: Array<OneofDescriptorProto.AsObject>,
    options?: MessageOptions.AsObject | undefined,
    reservedRangeList: Array<ReservedRange.AsObject>,
    reservedNameList: Array<string>,
  }

  export class ExtensionRange extends jspb.Message {
    hasStart(): boolean;
    clearStart(): ExtensionRange;
    getStart(): number | undefined;
    setStart(value: number): ExtensionRange;

    hasEnd(): boolean;
    clearEnd(): ExtensionRange;
    getEnd(): number | undefined;
    setEnd(value: number): ExtensionRange;

    hasOptions(): boolean;
    clearOptions(): ExtensionRange;
    getOptions(): ExtensionRangeOptions | undefined;
    setOptions(value?: ExtensionRangeOptions): ExtensionRange;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ExtensionRange.AsObject;
    static toObject(includeInstance: boolean, msg: ExtensionRange): ExtensionRange.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: ExtensionRange, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ExtensionRange;
    static deserializeBinaryFromReader(message: ExtensionRange, reader: jspb.BinaryReader): ExtensionRange;
  }

  export namespace ExtensionRange {
    export type AsObject = {
      start?: number | undefined,
      end?: number | undefined,
      options?: ExtensionRangeOptions.AsObject | undefined,
    }
  }

  export class ReservedRange extends jspb.Message {
    hasStart(): boolean;
    clearStart(): ReservedRange;
    getStart(): number | undefined;
    setStart(value: number): ReservedRange;

    hasEnd(): boolean;
    clearEnd(): ReservedRange;
    getEnd(): number | undefined;
    setEnd(value: number): ReservedRange;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ReservedRange.AsObject;
    static toObject(includeInstance: boolean, msg: ReservedRange): ReservedRange.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: ReservedRange, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ReservedRange;
    static deserializeBinaryFromReader(message: ReservedRange, reader: jspb.BinaryReader): ReservedRange;
  }

  export namespace ReservedRange {
    export type AsObject = {
      start?: number | undefined,
      end?: number | undefined,
    }
  }
}

export class ExtensionRangeOptions extends jspb.Message {
  clearUninterpretedOptionList(): ExtensionRangeOptions;
  getUninterpretedOptionList(): Array<UninterpretedOption>;
  setUninterpretedOptionList(value: Array<UninterpretedOption>): ExtensionRangeOptions;
  addUninterpretedOption(value?: UninterpretedOption, index?: number): UninterpretedOption;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ExtensionRangeOptions.AsObject;
  static toObject(includeInstance: boolean, msg: ExtensionRangeOptions): ExtensionRangeOptions.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ExtensionRangeOptions, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ExtensionRangeOptions;
  static deserializeBinaryFromReader(message: ExtensionRangeOptions, reader: jspb.BinaryReader): ExtensionRangeOptions;
}

export namespace ExtensionRangeOptions {
  export type AsObject = {
    uninterpretedOptionList: Array<UninterpretedOption.AsObject>,
  }
}

export class FieldDescriptorProto extends jspb.Message {
  hasName(): boolean;
  clearName(): FieldDescriptorProto;
  getName(): string | undefined;
  setName(value: string): FieldDescriptorProto;

  hasNumber(): boolean;
  clearNumber(): FieldDescriptorProto;
  getNumber(): number | undefined;
  setNumber(value: number): FieldDescriptorProto;

  hasLabel(): boolean;
  clearLabel(): FieldDescriptorProto;
  getLabel(): FieldDescriptorProto.Label | undefined;
  setLabel(value: FieldDescriptorProto.Label): FieldDescriptorProto;

  hasType(): boolean;
  clearType(): FieldDescriptorProto;
  getType(): FieldDescriptorProto.Type | undefined;
  setType(value: FieldDescriptorProto.Type): FieldDescriptorProto;

  hasTypeName(): boolean;
  clearTypeName(): FieldDescriptorProto;
  getTypeName(): string | undefined;
  setTypeName(value: string): FieldDescriptorProto;

  hasExtendee(): boolean;
  clearExtendee(): FieldDescriptorProto;
  getExtendee(): string | undefined;
  setExtendee(value: string): FieldDescriptorProto;

  hasDefaultValue(): boolean;
  clearDefaultValue(): FieldDescriptorProto;
  getDefaultValue(): string | undefined;
  setDefaultValue(value: string): FieldDescriptorProto;

  hasOneofIndex(): boolean;
  clearOneofIndex(): FieldDescriptorProto;
  getOneofIndex(): number | undefined;
  setOneofIndex(value: number): FieldDescriptorProto;

  hasJsonName(): boolean;
  clearJsonName(): FieldDescriptorProto;
  getJsonName(): string | undefined;
  setJsonName(value: string): FieldDescriptorProto;

  hasOptions(): boolean;
  clearOptions(): FieldDescriptorProto;
  getOptions(): FieldOptions | undefined;
  setOptions(value?: FieldOptions): FieldDescriptorProto;

  hasProto3Optional(): boolean;
  clearProto3Optional(): FieldDescriptorProto;
  getProto3Optional(): boolean | undefined;
  setProto3Optional(value: boolean): FieldDescriptorProto;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FieldDescriptorProto.AsObject;
  static toObject(includeInstance: boolean, msg: FieldDescriptorProto): FieldDescriptorProto.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FieldDescriptorProto, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FieldDescriptorProto;
  static deserializeBinaryFromReader(message: FieldDescriptorProto, reader: jspb.BinaryReader): FieldDescriptorProto;
}

export namespace FieldDescriptorProto {
  export type AsObject = {
    name?: string | undefined,
    number?: number | undefined,
    label?: Label | undefined,
    type?: Type | undefined,
    typeName?: string | undefined,
    extendee?: string | undefined,
    defaultValue?: string | undefined,
    oneofIndex?: number | undefined,
    jsonName?: string | undefined,
    options?: FieldOptions.AsObject | undefined,
    proto3Optional?: boolean | undefined,
  }

  export enum Type {
    TYPE_DOUBLE = 1,
    TYPE_FLOAT = 2,
    TYPE_INT64 = 3,
    TYPE_UINT64 = 4,
    TYPE_INT32 = 5,
    TYPE_FIXED64 = 6,
    TYPE_FIXED32 = 7,
    TYPE_BOOL = 8,
    TYPE_STRING = 9,
    TYPE_GROUP = 10,
    TYPE_MESSAGE = 11,
    TYPE_BYTES = 12,
    TYPE_UINT32 = 13,
    TYPE_ENUM = 14,
    TYPE_SFIXED32 = 15,
    TYPE_SFIXED64 = 16,
    TYPE_SINT32 = 17,
    TYPE_SINT64 = 18,
  }

  export enum Label {
    LABEL_OPTIONAL = 1,
    LABEL_REQUIRED = 2,
    LABEL_REPEATED = 3,
  }
}

export class OneofDescriptorProto extends jspb.Message {
  hasName(): boolean;
  clearName(): OneofDescriptorProto;
  getName(): string | undefined;
  setName(value: string): OneofDescriptorProto;

  hasOptions(): boolean;
  clearOptions(): OneofDescriptorProto;
  getOptions(): OneofOptions | undefined;
  setOptions(value?: OneofOptions): OneofDescriptorProto;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): OneofDescriptorProto.AsObject;
  static toObject(includeInstance: boolean, msg: OneofDescriptorProto): OneofDescriptorProto.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: OneofDescriptorProto, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): OneofDescriptorProto;
  static deserializeBinaryFromReader(message: OneofDescriptorProto, reader: jspb.BinaryReader): OneofDescriptorProto;
}

export namespace OneofDescriptorProto {
  export type AsObject = {
    name?: string | undefined,
    options?: OneofOptions.AsObject | undefined,
  }
}

export class EnumDescriptorProto extends jspb.Message {
  hasName(): boolean;
  clearName(): EnumDescriptorProto;
  getName(): string | undefined;
  setName(value: string): EnumDescriptorProto;

  clearValueList(): EnumDescriptorProto;
  getValueList(): Array<EnumValueDescriptorProto>;
  setValueList(value: Array<EnumValueDescriptorProto>): EnumDescriptorProto;
  addValue(value?: EnumValueDescriptorProto, index?: number): EnumValueDescriptorProto;

  hasOptions(): boolean;
  clearOptions(): EnumDescriptorProto;
  getOptions(): EnumOptions | undefined;
  setOptions(value?: EnumOptions): EnumDescriptorProto;

  clearReservedRangeList(): EnumDescriptorProto;
  getReservedRangeList(): Array<EnumDescriptorProto.EnumReservedRange>;
  setReservedRangeList(value: Array<EnumDescriptorProto.EnumReservedRange>): EnumDescriptorProto;
  addReservedRange(value?: EnumDescriptorProto.EnumReservedRange, index?: number): EnumDescriptorProto.EnumReservedRange;

  clearReservedNameList(): EnumDescriptorProto;
  getReservedNameList(): Array<string>;
  setReservedNameList(value: Array<string>): EnumDescriptorProto;
  addReservedName(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EnumDescriptorProto.AsObject;
  static toObject(includeInstance: boolean, msg: EnumDescriptorProto): EnumDescriptorProto.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EnumDescriptorProto, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EnumDescriptorProto;
  static deserializeBinaryFromReader(message: EnumDescriptorProto, reader: jspb.BinaryReader): EnumDescriptorProto;
}

export namespace EnumDescriptorProto {
  export type AsObject = {
    name?: string | undefined,
    valueList: Array<EnumValueDescriptorProto.AsObject>,
    options?: EnumOptions.AsObject | undefined,
    reservedRangeList: Array<EnumReservedRange.AsObject>,
    reservedNameList: Array<string>,
  }

  export class EnumReservedRange extends jspb.Message {
    hasStart(): boolean;
    clearStart(): EnumReservedRange;
    getStart(): number | undefined;
    setStart(value: number): EnumReservedRange;

    hasEnd(): boolean;
    clearEnd(): EnumReservedRange;
    getEnd(): number | undefined;
    setEnd(value: number): EnumReservedRange;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): EnumReservedRange.AsObject;
    static toObject(includeInstance: boolean, msg: EnumReservedRange): EnumReservedRange.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: EnumReservedRange, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): EnumReservedRange;
    static deserializeBinaryFromReader(message: EnumReservedRange, reader: jspb.BinaryReader): EnumReservedRange;
  }

  export namespace EnumReservedRange {
    export type AsObject = {
      start?: number | undefined,
      end?: number | undefined,
    }
  }
}

export class EnumValueDescriptorProto extends jspb.Message {
  hasName(): boolean;
  clearName(): EnumValueDescriptorProto;
  getName(): string | undefined;
  setName(value: string): EnumValueDescriptorProto;

  hasNumber(): boolean;
  clearNumber(): EnumValueDescriptorProto;
  getNumber(): number | undefined;
  setNumber(value: number): EnumValueDescriptorProto;

  hasOptions(): boolean;
  clearOptions(): EnumValueDescriptorProto;
  getOptions(): EnumValueOptions | undefined;
  setOptions(value?: EnumValueOptions): EnumValueDescriptorProto;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EnumValueDescriptorProto.AsObject;
  static toObject(includeInstance: boolean, msg: EnumValueDescriptorProto): EnumValueDescriptorProto.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EnumValueDescriptorProto, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EnumValueDescriptorProto;
  static deserializeBinaryFromReader(message: EnumValueDescriptorProto, reader: jspb.BinaryReader): EnumValueDescriptorProto;
}

export namespace EnumValueDescriptorProto {
  export type AsObject = {
    name?: string | undefined,
    number?: number | undefined,
    options?: EnumValueOptions.AsObject | undefined,
  }
}

export class ServiceDescriptorProto extends jspb.Message {
  hasName(): boolean;
  clearName(): ServiceDescriptorProto;
  getName(): string | undefined;
  setName(value: string): ServiceDescriptorProto;

  clearMethodList(): ServiceDescriptorProto;
  getMethodList(): Array<MethodDescriptorProto>;
  setMethodList(value: Array<MethodDescriptorProto>): ServiceDescriptorProto;
  addMethod(value?: MethodDescriptorProto, index?: number): MethodDescriptorProto;

  hasOptions(): boolean;
  clearOptions(): ServiceDescriptorProto;
  getOptions(): ServiceOptions | undefined;
  setOptions(value?: ServiceOptions): ServiceDescriptorProto;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ServiceDescriptorProto.AsObject;
  static toObject(includeInstance: boolean, msg: ServiceDescriptorProto): ServiceDescriptorProto.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ServiceDescriptorProto, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ServiceDescriptorProto;
  static deserializeBinaryFromReader(message: ServiceDescriptorProto, reader: jspb.BinaryReader): ServiceDescriptorProto;
}

export namespace ServiceDescriptorProto {
  export type AsObject = {
    name?: string | undefined,
    methodList: Array<MethodDescriptorProto.AsObject>,
    options?: ServiceOptions.AsObject | undefined,
  }
}

export class MethodDescriptorProto extends jspb.Message {
  hasName(): boolean;
  clearName(): MethodDescriptorProto;
  getName(): string | undefined;
  setName(value: string): MethodDescriptorProto;

  hasInputType(): boolean;
  clearInputType(): MethodDescriptorProto;
  getInputType(): string | undefined;
  setInputType(value: string): MethodDescriptorProto;

  hasOutputType(): boolean;
  clearOutputType(): MethodDescriptorProto;
  getOutputType(): string | undefined;
  setOutputType(value: string): MethodDescriptorProto;

  hasOptions(): boolean;
  clearOptions(): MethodDescriptorProto;
  getOptions(): MethodOptions | undefined;
  setOptions(value?: MethodOptions): MethodDescriptorProto;

  hasClientStreaming(): boolean;
  clearClientStreaming(): MethodDescriptorProto;
  getClientStreaming(): boolean | undefined;
  setClientStreaming(value: boolean): MethodDescriptorProto;

  hasServerStreaming(): boolean;
  clearServerStreaming(): MethodDescriptorProto;
  getServerStreaming(): boolean | undefined;
  setServerStreaming(value: boolean): MethodDescriptorProto;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MethodDescriptorProto.AsObject;
  static toObject(includeInstance: boolean, msg: MethodDescriptorProto): MethodDescriptorProto.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MethodDescriptorProto, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MethodDescriptorProto;
  static deserializeBinaryFromReader(message: MethodDescriptorProto, reader: jspb.BinaryReader): MethodDescriptorProto;
}

export namespace MethodDescriptorProto {
  export type AsObject = {
    name?: string | undefined,
    inputType?: string | undefined,
    outputType?: string | undefined,
    options?: MethodOptions.AsObject | undefined,
    clientStreaming?: boolean | undefined,
    serverStreaming?: boolean | undefined,
  }
}

export class FileOptions extends jspb.Message {
  hasJavaPackage(): boolean;
  clearJavaPackage(): FileOptions;
  getJavaPackage(): string | undefined;
  setJavaPackage(value: string): FileOptions;

  hasJavaOuterClassname(): boolean;
  clearJavaOuterClassname(): FileOptions;
  getJavaOuterClassname(): string | undefined;
  setJavaOuterClassname(value: string): FileOptions;

  hasJavaMultipleFiles(): boolean;
  clearJavaMultipleFiles(): FileOptions;
  getJavaMultipleFiles(): boolean | undefined;
  setJavaMultipleFiles(value: boolean): FileOptions;

  hasJavaGenerateEqualsAndHash(): boolean;
  clearJavaGenerateEqualsAndHash(): FileOptions;
  getJavaGenerateEqualsAndHash(): boolean | undefined;
  setJavaGenerateEqualsAndHash(value: boolean): FileOptions;

  hasJavaStringCheckUtf8(): boolean;
  clearJavaStringCheckUtf8(): FileOptions;
  getJavaStringCheckUtf8(): boolean | undefined;
  setJavaStringCheckUtf8(value: boolean): FileOptions;

  hasOptimizeFor(): boolean;
  clearOptimizeFor(): FileOptions;
  getOptimizeFor(): FileOptions.OptimizeMode | undefined;
  setOptimizeFor(value: FileOptions.OptimizeMode): FileOptions;

  hasGoPackage(): boolean;
  clearGoPackage(): FileOptions;
  getGoPackage(): string | undefined;
  setGoPackage(value: string): FileOptions;

  hasCcGenericServices(): boolean;
  clearCcGenericServices(): FileOptions;
  getCcGenericServices(): boolean | undefined;
  setCcGenericServices(value: boolean): FileOptions;

  hasJavaGenericServices(): boolean;
  clearJavaGenericServices(): FileOptions;
  getJavaGenericServices(): boolean | undefined;
  setJavaGenericServices(value: boolean): FileOptions;

  hasPyGenericServices(): boolean;
  clearPyGenericServices(): FileOptions;
  getPyGenericServices(): boolean | undefined;
  setPyGenericServices(value: boolean): FileOptions;

  hasPhpGenericServices(): boolean;
  clearPhpGenericServices(): FileOptions;
  getPhpGenericServices(): boolean | undefined;
  setPhpGenericServices(value: boolean): FileOptions;

  hasDeprecated(): boolean;
  clearDeprecated(): FileOptions;
  getDeprecated(): boolean | undefined;
  setDeprecated(value: boolean): FileOptions;

  hasCcEnableArenas(): boolean;
  clearCcEnableArenas(): FileOptions;
  getCcEnableArenas(): boolean | undefined;
  setCcEnableArenas(value: boolean): FileOptions;

  hasObjcClassPrefix(): boolean;
  clearObjcClassPrefix(): FileOptions;
  getObjcClassPrefix(): string | undefined;
  setObjcClassPrefix(value: string): FileOptions;

  hasCsharpNamespace(): boolean;
  clearCsharpNamespace(): FileOptions;
  getCsharpNamespace(): string | undefined;
  setCsharpNamespace(value: string): FileOptions;

  hasSwiftPrefix(): boolean;
  clearSwiftPrefix(): FileOptions;
  getSwiftPrefix(): string | undefined;
  setSwiftPrefix(value: string): FileOptions;

  hasPhpClassPrefix(): boolean;
  clearPhpClassPrefix(): FileOptions;
  getPhpClassPrefix(): string | undefined;
  setPhpClassPrefix(value: string): FileOptions;

  hasPhpNamespace(): boolean;
  clearPhpNamespace(): FileOptions;
  getPhpNamespace(): string | undefined;
  setPhpNamespace(value: string): FileOptions;

  hasPhpMetadataNamespace(): boolean;
  clearPhpMetadataNamespace(): FileOptions;
  getPhpMetadataNamespace(): string | undefined;
  setPhpMetadataNamespace(value: string): FileOptions;

  hasRubyPackage(): boolean;
  clearRubyPackage(): FileOptions;
  getRubyPackage(): string | undefined;
  setRubyPackage(value: string): FileOptions;

  clearUninterpretedOptionList(): FileOptions;
  getUninterpretedOptionList(): Array<UninterpretedOption>;
  setUninterpretedOptionList(value: Array<UninterpretedOption>): FileOptions;
  addUninterpretedOption(value?: UninterpretedOption, index?: number): UninterpretedOption;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FileOptions.AsObject;
  static toObject(includeInstance: boolean, msg: FileOptions): FileOptions.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FileOptions, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FileOptions;
  static deserializeBinaryFromReader(message: FileOptions, reader: jspb.BinaryReader): FileOptions;
}

export namespace FileOptions {
  export type AsObject = {
    javaPackage?: string | undefined,
    javaOuterClassname?: string | undefined,
    javaMultipleFiles?: boolean | undefined,
    javaGenerateEqualsAndHash?: boolean | undefined,
    javaStringCheckUtf8?: boolean | undefined,
    optimizeFor?: OptimizeMode | undefined,
    goPackage?: string | undefined,
    ccGenericServices?: boolean | undefined,
    javaGenericServices?: boolean | undefined,
    pyGenericServices?: boolean | undefined,
    phpGenericServices?: boolean | undefined,
    deprecated?: boolean | undefined,
    ccEnableArenas?: boolean | undefined,
    objcClassPrefix?: string | undefined,
    csharpNamespace?: string | undefined,
    swiftPrefix?: string | undefined,
    phpClassPrefix?: string | undefined,
    phpNamespace?: string | undefined,
    phpMetadataNamespace?: string | undefined,
    rubyPackage?: string | undefined,
    uninterpretedOptionList: Array<UninterpretedOption.AsObject>,
  }

  export enum OptimizeMode {
    SPEED = 1,
    CODE_SIZE = 2,
    LITE_RUNTIME = 3,
  }
}

export class MessageOptions extends jspb.Message {
  hasMessageSetWireFormat(): boolean;
  clearMessageSetWireFormat(): MessageOptions;
  getMessageSetWireFormat(): boolean | undefined;
  setMessageSetWireFormat(value: boolean): MessageOptions;

  hasNoStandardDescriptorAccessor(): boolean;
  clearNoStandardDescriptorAccessor(): MessageOptions;
  getNoStandardDescriptorAccessor(): boolean | undefined;
  setNoStandardDescriptorAccessor(value: boolean): MessageOptions;

  hasDeprecated(): boolean;
  clearDeprecated(): MessageOptions;
  getDeprecated(): boolean | undefined;
  setDeprecated(value: boolean): MessageOptions;

  hasMapEntry(): boolean;
  clearMapEntry(): MessageOptions;
  getMapEntry(): boolean | undefined;
  setMapEntry(value: boolean): MessageOptions;

  clearUninterpretedOptionList(): MessageOptions;
  getUninterpretedOptionList(): Array<UninterpretedOption>;
  setUninterpretedOptionList(value: Array<UninterpretedOption>): MessageOptions;
  addUninterpretedOption(value?: UninterpretedOption, index?: number): UninterpretedOption;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MessageOptions.AsObject;
  static toObject(includeInstance: boolean, msg: MessageOptions): MessageOptions.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MessageOptions, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MessageOptions;
  static deserializeBinaryFromReader(message: MessageOptions, reader: jspb.BinaryReader): MessageOptions;
}

export namespace MessageOptions {
  export type AsObject = {
    messageSetWireFormat?: boolean | undefined,
    noStandardDescriptorAccessor?: boolean | undefined,
    deprecated?: boolean | undefined,
    mapEntry?: boolean | undefined,
    uninterpretedOptionList: Array<UninterpretedOption.AsObject>,
  }
}

export class FieldOptions extends jspb.Message {
  hasCtype(): boolean;
  clearCtype(): FieldOptions;
  getCtype(): FieldOptions.CType | undefined;
  setCtype(value: FieldOptions.CType): FieldOptions;

  hasPacked(): boolean;
  clearPacked(): FieldOptions;
  getPacked(): boolean | undefined;
  setPacked(value: boolean): FieldOptions;

  hasJstype(): boolean;
  clearJstype(): FieldOptions;
  getJstype(): FieldOptions.JSType | undefined;
  setJstype(value: FieldOptions.JSType): FieldOptions;

  hasLazy(): boolean;
  clearLazy(): FieldOptions;
  getLazy(): boolean | undefined;
  setLazy(value: boolean): FieldOptions;

  hasDeprecated(): boolean;
  clearDeprecated(): FieldOptions;
  getDeprecated(): boolean | undefined;
  setDeprecated(value: boolean): FieldOptions;

  hasWeak(): boolean;
  clearWeak(): FieldOptions;
  getWeak(): boolean | undefined;
  setWeak(value: boolean): FieldOptions;

  clearUninterpretedOptionList(): FieldOptions;
  getUninterpretedOptionList(): Array<UninterpretedOption>;
  setUninterpretedOptionList(value: Array<UninterpretedOption>): FieldOptions;
  addUninterpretedOption(value?: UninterpretedOption, index?: number): UninterpretedOption;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FieldOptions.AsObject;
  static toObject(includeInstance: boolean, msg: FieldOptions): FieldOptions.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FieldOptions, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FieldOptions;
  static deserializeBinaryFromReader(message: FieldOptions, reader: jspb.BinaryReader): FieldOptions;
}

export namespace FieldOptions {
  export type AsObject = {
    ctype?: CType | undefined,
    packed?: boolean | undefined,
    jstype?: JSType | undefined,
    lazy?: boolean | undefined,
    deprecated?: boolean | undefined,
    weak?: boolean | undefined,
    uninterpretedOptionList: Array<UninterpretedOption.AsObject>,
  }

  export enum CType {
    STRING = 0,
    CORD = 1,
    STRING_PIECE = 2,
  }

  export enum JSType {
    JS_NORMAL = 0,
    JS_STRING = 1,
    JS_NUMBER = 2,
  }
}

export class OneofOptions extends jspb.Message {
  clearUninterpretedOptionList(): OneofOptions;
  getUninterpretedOptionList(): Array<UninterpretedOption>;
  setUninterpretedOptionList(value: Array<UninterpretedOption>): OneofOptions;
  addUninterpretedOption(value?: UninterpretedOption, index?: number): UninterpretedOption;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): OneofOptions.AsObject;
  static toObject(includeInstance: boolean, msg: OneofOptions): OneofOptions.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: OneofOptions, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): OneofOptions;
  static deserializeBinaryFromReader(message: OneofOptions, reader: jspb.BinaryReader): OneofOptions;
}

export namespace OneofOptions {
  export type AsObject = {
    uninterpretedOptionList: Array<UninterpretedOption.AsObject>,
  }
}

export class EnumOptions extends jspb.Message {
  hasAllowAlias(): boolean;
  clearAllowAlias(): EnumOptions;
  getAllowAlias(): boolean | undefined;
  setAllowAlias(value: boolean): EnumOptions;

  hasDeprecated(): boolean;
  clearDeprecated(): EnumOptions;
  getDeprecated(): boolean | undefined;
  setDeprecated(value: boolean): EnumOptions;

  clearUninterpretedOptionList(): EnumOptions;
  getUninterpretedOptionList(): Array<UninterpretedOption>;
  setUninterpretedOptionList(value: Array<UninterpretedOption>): EnumOptions;
  addUninterpretedOption(value?: UninterpretedOption, index?: number): UninterpretedOption;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EnumOptions.AsObject;
  static toObject(includeInstance: boolean, msg: EnumOptions): EnumOptions.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EnumOptions, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EnumOptions;
  static deserializeBinaryFromReader(message: EnumOptions, reader: jspb.BinaryReader): EnumOptions;
}

export namespace EnumOptions {
  export type AsObject = {
    allowAlias?: boolean | undefined,
    deprecated?: boolean | undefined,
    uninterpretedOptionList: Array<UninterpretedOption.AsObject>,
  }
}

export class EnumValueOptions extends jspb.Message {
  hasDeprecated(): boolean;
  clearDeprecated(): EnumValueOptions;
  getDeprecated(): boolean | undefined;
  setDeprecated(value: boolean): EnumValueOptions;

  clearUninterpretedOptionList(): EnumValueOptions;
  getUninterpretedOptionList(): Array<UninterpretedOption>;
  setUninterpretedOptionList(value: Array<UninterpretedOption>): EnumValueOptions;
  addUninterpretedOption(value?: UninterpretedOption, index?: number): UninterpretedOption;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EnumValueOptions.AsObject;
  static toObject(includeInstance: boolean, msg: EnumValueOptions): EnumValueOptions.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EnumValueOptions, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EnumValueOptions;
  static deserializeBinaryFromReader(message: EnumValueOptions, reader: jspb.BinaryReader): EnumValueOptions;
}

export namespace EnumValueOptions {
  export type AsObject = {
    deprecated?: boolean | undefined,
    uninterpretedOptionList: Array<UninterpretedOption.AsObject>,
  }
}

export class ServiceOptions extends jspb.Message {
  hasDeprecated(): boolean;
  clearDeprecated(): ServiceOptions;
  getDeprecated(): boolean | undefined;
  setDeprecated(value: boolean): ServiceOptions;

  clearUninterpretedOptionList(): ServiceOptions;
  getUninterpretedOptionList(): Array<UninterpretedOption>;
  setUninterpretedOptionList(value: Array<UninterpretedOption>): ServiceOptions;
  addUninterpretedOption(value?: UninterpretedOption, index?: number): UninterpretedOption;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ServiceOptions.AsObject;
  static toObject(includeInstance: boolean, msg: ServiceOptions): ServiceOptions.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ServiceOptions, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ServiceOptions;
  static deserializeBinaryFromReader(message: ServiceOptions, reader: jspb.BinaryReader): ServiceOptions;
}

export namespace ServiceOptions {
  export type AsObject = {
    deprecated?: boolean | undefined,
    uninterpretedOptionList: Array<UninterpretedOption.AsObject>,
  }
}

export class MethodOptions extends jspb.Message {
  hasDeprecated(): boolean;
  clearDeprecated(): MethodOptions;
  getDeprecated(): boolean | undefined;
  setDeprecated(value: boolean): MethodOptions;

  hasIdempotencyLevel(): boolean;
  clearIdempotencyLevel(): MethodOptions;
  getIdempotencyLevel(): MethodOptions.IdempotencyLevel | undefined;
  setIdempotencyLevel(value: MethodOptions.IdempotencyLevel): MethodOptions;

  clearUninterpretedOptionList(): MethodOptions;
  getUninterpretedOptionList(): Array<UninterpretedOption>;
  setUninterpretedOptionList(value: Array<UninterpretedOption>): MethodOptions;
  addUninterpretedOption(value?: UninterpretedOption, index?: number): UninterpretedOption;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MethodOptions.AsObject;
  static toObject(includeInstance: boolean, msg: MethodOptions): MethodOptions.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MethodOptions, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MethodOptions;
  static deserializeBinaryFromReader(message: MethodOptions, reader: jspb.BinaryReader): MethodOptions;
}

export namespace MethodOptions {
  export type AsObject = {
    deprecated?: boolean | undefined,
    idempotencyLevel?: IdempotencyLevel | undefined,
    uninterpretedOptionList: Array<UninterpretedOption.AsObject>,
  }

  export enum IdempotencyLevel {
    IDEMPOTENCY_UNKNOWN = 0,
    NO_SIDE_EFFECTS = 1,
    IDEMPOTENT = 2,
  }
}

export class UninterpretedOption extends jspb.Message {
  clearNameList(): UninterpretedOption;
  getNameList(): Array<UninterpretedOption.NamePart>;
  setNameList(value: Array<UninterpretedOption.NamePart>): UninterpretedOption;
  addName(value?: UninterpretedOption.NamePart, index?: number): UninterpretedOption.NamePart;

  hasIdentifierValue(): boolean;
  clearIdentifierValue(): UninterpretedOption;
  getIdentifierValue(): string | undefined;
  setIdentifierValue(value: string): UninterpretedOption;

  hasPositiveIntValue(): boolean;
  clearPositiveIntValue(): UninterpretedOption;
  getPositiveIntValue(): number | undefined;
  setPositiveIntValue(value: number): UninterpretedOption;

  hasNegativeIntValue(): boolean;
  clearNegativeIntValue(): UninterpretedOption;
  getNegativeIntValue(): number | undefined;
  setNegativeIntValue(value: number): UninterpretedOption;

  hasDoubleValue(): boolean;
  clearDoubleValue(): UninterpretedOption;
  getDoubleValue(): number | undefined;
  setDoubleValue(value: number): UninterpretedOption;

  hasStringValue(): boolean;
  clearStringValue(): UninterpretedOption;
  getStringValue(): Uint8Array | string;
  getStringValue_asU8(): Uint8Array;
  getStringValue_asB64(): string;
  setStringValue(value: Uint8Array | string): UninterpretedOption;

  hasAggregateValue(): boolean;
  clearAggregateValue(): UninterpretedOption;
  getAggregateValue(): string | undefined;
  setAggregateValue(value: string): UninterpretedOption;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): UninterpretedOption.AsObject;
  static toObject(includeInstance: boolean, msg: UninterpretedOption): UninterpretedOption.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: UninterpretedOption, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): UninterpretedOption;
  static deserializeBinaryFromReader(message: UninterpretedOption, reader: jspb.BinaryReader): UninterpretedOption;
}

export namespace UninterpretedOption {
  export type AsObject = {
    nameList: Array<NamePart.AsObject>,
    identifierValue?: string | undefined,
    positiveIntValue?: number | undefined,
    negativeIntValue?: number | undefined,
    doubleValue?: number | undefined,
    stringValue: Uint8Array | string,
    aggregateValue?: string | undefined,
  }

  export class NamePart extends jspb.Message {
    hasNamePart(): boolean;
    clearNamePart(): NamePart;
    getNamePart(): string | undefined;
    setNamePart(value: string): NamePart;

    hasIsExtension(): boolean;
    clearIsExtension(): NamePart;
    getIsExtension(): boolean | undefined;
    setIsExtension(value: boolean): NamePart;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): NamePart.AsObject;
    static toObject(includeInstance: boolean, msg: NamePart): NamePart.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: NamePart, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): NamePart;
    static deserializeBinaryFromReader(message: NamePart, reader: jspb.BinaryReader): NamePart;
  }

  export namespace NamePart {
    export type AsObject = {
      namePart?: string | undefined,
      isExtension?: boolean | undefined,
    }
  }
}

export class SourceCodeInfo extends jspb.Message {
  clearLocationList(): SourceCodeInfo;
  getLocationList(): Array<SourceCodeInfo.Location>;
  setLocationList(value: Array<SourceCodeInfo.Location>): SourceCodeInfo;
  addLocation(value?: SourceCodeInfo.Location, index?: number): SourceCodeInfo.Location;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SourceCodeInfo.AsObject;
  static toObject(includeInstance: boolean, msg: SourceCodeInfo): SourceCodeInfo.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SourceCodeInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SourceCodeInfo;
  static deserializeBinaryFromReader(message: SourceCodeInfo, reader: jspb.BinaryReader): SourceCodeInfo;
}

export namespace SourceCodeInfo {
  export type AsObject = {
    locationList: Array<Location.AsObject>,
  }

  export class Location extends jspb.Message {
    clearPathList(): Location;
    getPathList(): Array<number>;
    setPathList(value: Array<number>): Location;
    addPath(value: number, index?: number): number;

    clearSpanList(): Location;
    getSpanList(): Array<number>;
    setSpanList(value: Array<number>): Location;
    addSpan(value: number, index?: number): number;

    hasLeadingComments(): boolean;
    clearLeadingComments(): Location;
    getLeadingComments(): string | undefined;
    setLeadingComments(value: string): Location;

    hasTrailingComments(): boolean;
    clearTrailingComments(): Location;
    getTrailingComments(): string | undefined;
    setTrailingComments(value: string): Location;

    clearLeadingDetachedCommentsList(): Location;
    getLeadingDetachedCommentsList(): Array<string>;
    setLeadingDetachedCommentsList(value: Array<string>): Location;
    addLeadingDetachedComments(value: string, index?: number): string;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Location.AsObject;
    static toObject(includeInstance: boolean, msg: Location): Location.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: Location, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Location;
    static deserializeBinaryFromReader(message: Location, reader: jspb.BinaryReader): Location;
  }

  export namespace Location {
    export type AsObject = {
      pathList: Array<number>,
      spanList: Array<number>,
      leadingComments?: string | undefined,
      trailingComments?: string | undefined,
      leadingDetachedCommentsList: Array<string>,
    }
  }
}

export class GeneratedCodeInfo extends jspb.Message {
  clearAnnotationList(): GeneratedCodeInfo;
  getAnnotationList(): Array<GeneratedCodeInfo.Annotation>;
  setAnnotationList(value: Array<GeneratedCodeInfo.Annotation>): GeneratedCodeInfo;
  addAnnotation(value?: GeneratedCodeInfo.Annotation, index?: number): GeneratedCodeInfo.Annotation;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GeneratedCodeInfo.AsObject;
  static toObject(includeInstance: boolean, msg: GeneratedCodeInfo): GeneratedCodeInfo.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GeneratedCodeInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GeneratedCodeInfo;
  static deserializeBinaryFromReader(message: GeneratedCodeInfo, reader: jspb.BinaryReader): GeneratedCodeInfo;
}

export namespace GeneratedCodeInfo {
  export type AsObject = {
    annotationList: Array<Annotation.AsObject>,
  }

  export class Annotation extends jspb.Message {
    clearPathList(): Annotation;
    getPathList(): Array<number>;
    setPathList(value: Array<number>): Annotation;
    addPath(value: number, index?: number): number;

    hasSourceFile(): boolean;
    clearSourceFile(): Annotation;
    getSourceFile(): string | undefined;
    setSourceFile(value: string): Annotation;

    hasBegin(): boolean;
    clearBegin(): Annotation;
    getBegin(): number | undefined;
    setBegin(value: number): Annotation;

    hasEnd(): boolean;
    clearEnd(): Annotation;
    getEnd(): number | undefined;
    setEnd(value: number): Annotation;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Annotation.AsObject;
    static toObject(includeInstance: boolean, msg: Annotation): Annotation.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: Annotation, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Annotation;
    static deserializeBinaryFromReader(message: Annotation, reader: jspb.BinaryReader): Annotation;
  }

  export namespace Annotation {
    export type AsObject = {
      pathList: Array<number>,
      sourceFile?: string | undefined,
      begin?: number | undefined,
      end?: number | undefined,
    }
  }
}
// package: google.protobuf
// file: duration.proto

import * as jspb from "../../index";

export class Duration extends jspb.Message {
  getSeconds(): number;
  setSeconds(value: number): Duration;

  getNanos(): number;
  setNanos(value: number): Duration;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Duration.AsObject;
  static toObject(includeInstance: boolean, msg: Duration): Duration.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Duration, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Duration;
  static deserializeBinaryFromReader(message: Duration, reader: jspb.BinaryReader): Duration;
}

export namespace Duration {
  export type AsObject = {
    seconds: number,
    nanos: number,
  }
}
// package: google.protobuf
// file: empty.proto

import * as jspb from "../../index";

export class Empty extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Empty.AsObject;
  static toObject(includeInstance: boolean, msg: Empty): Empty.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Empty, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Empty;
  static deserializeBinaryFromReader(message: Empty, reader: jspb.BinaryReader): Empty;
}

export namespace Empty {
  export type AsObject = {
  }
}
// package: google.protobuf
// file: field_mask.proto

import * as jspb from "../../index";

export class FieldMask extends jspb.Message {
  clearPathsList(): FieldMask;
  getPathsList(): Array<string>;
  setPathsList(value: Array<string>): FieldMask;
  addPaths(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FieldMask.AsObject;
  static toObject(includeInstance: boolean, msg: FieldMask): FieldMask.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FieldMask, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FieldMask;
  static deserializeBinaryFromReader(message: FieldMask, reader: jspb.BinaryReader): FieldMask;
}

export namespace FieldMask {
  export type AsObject = {
    pathsList: Array<string>,
  }
}
// package: google.protobuf
// file: source_context.proto

import * as jspb from "../../index";

export class SourceContext extends jspb.Message {
  getFileName(): string;
  setFileName(value: string): SourceContext;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SourceContext.AsObject;
  static toObject(includeInstance: boolean, msg: SourceContext): SourceContext.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SourceContext, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SourceContext;
  static deserializeBinaryFromReader(message: SourceContext, reader: jspb.BinaryReader): SourceContext;
}

export namespace SourceContext {
  export type AsObject = {
    fileName: string,
  }
}
// package: google.protobuf
// file: struct.proto

import * as jspb from "../../index";

export class Struct extends jspb.Message {
  getFieldsMap(): jspb.Map<string, Value>;
  clearFieldsMap(): Struct;

  toJavaScript(): {[key: string]: JavaScriptValue};
  static fromJavaScript(value: {[key: string]: JavaScriptValue}): Struct;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Struct.AsObject;
  static toObject(includeInstance: boolean, msg: Struct): Struct.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Struct, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Struct;
  static deserializeBinaryFromReader(message: Struct, reader: jspb.BinaryReader): Struct;
}

export namespace Struct {
  export type AsObject = {
    fieldsMap: Array<[string, Value.AsObject]>,
  }
}

export class Value extends jspb.Message {
  hasNullValue(): boolean;
  clearNullValue(): Value;
  getNullValue(): NullValue;
  setNullValue(value: NullValue): Value;

  hasNumberValue(): boolean;
  clearNumberValue(): Value;
  getNumberValue(): number;
  setNumberValue(value: number): Value;

  hasStringValue(): boolean;
  clearStringValue(): Value;
  getStringValue(): string;
  setStringValue(value: string): Value;

  hasBoolValue(): boolean;
  clearBoolValue(): Value;
  getBoolValue(): boolean;
  setBoolValue(value: boolean): Value;

  hasStructValue(): boolean;
  clearStructValue(): Value;
  getStructValue(): Struct | undefined;
  setStructValue(value?: Struct): Value;

  hasListValue(): boolean;
  clearListValue(): Value;
  getListValue(): ListValue | undefined;
  setListValue(value?: ListValue): Value;

  getKindCase(): Value.KindCase;

  toJavaScript(): JavaScriptValue;
  static fromJavaScript(value: JavaScriptValue): Value;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Value.AsObject;
  static toObject(includeInstance: boolean, msg: Value): Value.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Value, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Value;
  static deserializeBinaryFromReader(message: Value, reader: jspb.BinaryReader): Value;
}

export namespace Value {
  export type AsObject = {
    nullValue: NullValue,
    numberValue: number,
    stringValue: string,
    boolValue: boolean,
    structValue?: Struct.AsObject | undefined,
    listValue?: ListValue.AsObject | undefined,
  }

  export enum KindCase {
    KIND_NOT_SET = 0,
    NULL_VALUE = 1,
    NUMBER_VALUE = 2,
    STRING_VALUE = 3,
    BOOL_VALUE = 4,
    STRUCT_VALUE = 5,
    LIST_VALUE = 6,
  }
}

export class ListValue extends jspb.Message {
  clearValuesList(): ListValue;
  getValuesList(): Array<Value>;
  setValuesList(value: Array<Value>): ListValue;
  addValues(value?: Value, index?: number): Value;

  toJavaScript(): Array<JavaScriptValue>;
  static fromJavaScript(value: Array<JavaScriptValue>): ListValue;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ListValue.AsObject;
  static toObject(includeInstance: boolean, msg: ListValue): ListValue.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ListValue, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ListValue;
  static deserializeBinaryFromReader(message: ListValue, reader: jspb.BinaryReader): ListValue;
}

export namespace ListValue {
  export type AsObject = {
    valuesList: Array<Value.AsObject>,
  }
}

export enum NullValue {
  NULL_VALUE = 0,
}

export type JavaScriptValue = null | number | string | boolean | Array<any> | {};
// package: google.protobuf
// file: timestamp.proto

import * as jspb from "../../index";

export class Timestamp extends jspb.Message {
  getSeconds(): number;
  setSeconds(value: number): Timestamp;

  getNanos(): number;
  setNanos(value: number): Timestamp;

  toDate(): Date;
  fromDate(date: Date): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Timestamp.AsObject;
  static toObject(includeInstance: boolean, msg: Timestamp): Timestamp.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Timestamp, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Timestamp;
  static deserializeBinaryFromReader(message: Timestamp, reader: jspb.BinaryReader): Timestamp;
  static fromDate(date: Date): Timestamp;
}

export namespace Timestamp {
  export type AsObject = {
    seconds: number,
    nanos: number,
  }
}
// package: google.protobuf
// file: type.proto

import * as jspb from "../../index";
import * as google_protobuf_any_pb from "./any_pb";
import * as google_protobuf_source_context_pb from "./source_context_pb";

export class Type extends jspb.Message {
  getName(): string;
  setName(value: string): Type;

  clearFieldsList(): Type;
  getFieldsList(): Array<Field>;
  setFieldsList(value: Array<Field>): Type;
  addFields(value?: Field, index?: number): Field;

  clearOneofsList(): Type;
  getOneofsList(): Array<string>;
  setOneofsList(value: Array<string>): Type;
  addOneofs(value: string, index?: number): string;

  clearOptionsList(): Type;
  getOptionsList(): Array<Option>;
  setOptionsList(value: Array<Option>): Type;
  addOptions(value?: Option, index?: number): Option;

  hasSourceContext(): boolean;
  clearSourceContext(): Type;
  getSourceContext(): google_protobuf_source_context_pb.SourceContext | undefined;
  setSourceContext(value?: google_protobuf_source_context_pb.SourceContext): Type;

  getSyntax(): Syntax;
  setSyntax(value: Syntax): Type;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Type.AsObject;
  static toObject(includeInstance: boolean, msg: Type): Type.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Type, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Type;
  static deserializeBinaryFromReader(message: Type, reader: jspb.BinaryReader): Type;
}

export namespace Type {
  export type AsObject = {
    name: string,
    fieldsList: Array<Field.AsObject>,
    oneofsList: Array<string>,
    optionsList: Array<Option.AsObject>,
    sourceContext?: google_protobuf_source_context_pb.SourceContext.AsObject | undefined,
    syntax: Syntax,
  }
}

export class Field extends jspb.Message {
  getKind(): Field.Kind;
  setKind(value: Field.Kind): Field;

  getCardinality(): Field.Cardinality;
  setCardinality(value: Field.Cardinality): Field;

  getNumber(): number;
  setNumber(value: number): Field;

  getName(): string;
  setName(value: string): Field;

  getTypeUrl(): string;
  setTypeUrl(value: string): Field;

  getOneofIndex(): number;
  setOneofIndex(value: number): Field;

  getPacked(): boolean;
  setPacked(value: boolean): Field;

  clearOptionsList(): Field;
  getOptionsList(): Array<Option>;
  setOptionsList(value: Array<Option>): Field;
  addOptions(value?: Option, index?: number): Option;

  getJsonName(): string;
  setJsonName(value: string): Field;

  getDefaultValue(): string;
  setDefaultValue(value: string): Field;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Field.AsObject;
  static toObject(includeInstance: boolean, msg: Field): Field.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Field, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Field;
  static deserializeBinaryFromReader(message: Field, reader: jspb.BinaryReader): Field;
}

export namespace Field {
  export type AsObject = {
    kind: Kind,
    cardinality: Cardinality,
    number: number,
    name: string,
    typeUrl: string,
    oneofIndex: number,
    packed: boolean,
    optionsList: Array<Option.AsObject>,
    jsonName: string,
    defaultValue: string,
  }

  export enum Kind {
    TYPE_UNKNOWN = 0,
    TYPE_DOUBLE = 1,
    TYPE_FLOAT = 2,
    TYPE_INT64 = 3,
    TYPE_UINT64 = 4,
    TYPE_INT32 = 5,
    TYPE_FIXED64 = 6,
    TYPE_FIXED32 = 7,
    TYPE_BOOL = 8,
    TYPE_STRING = 9,
    TYPE_GROUP = 10,
    TYPE_MESSAGE = 11,
    TYPE_BYTES = 12,
    TYPE_UINT32 = 13,
    TYPE_ENUM = 14,
    TYPE_SFIXED32 = 15,
    TYPE_SFIXED64 = 16,
    TYPE_SINT32 = 17,
    TYPE_SINT64 = 18,
  }

  export enum Cardinality {
    CARDINALITY_UNKNOWN = 0,
    CARDINALITY_OPTIONAL = 1,
    CARDINALITY_REQUIRED = 2,
    CARDINALITY_REPEATED = 3,
  }
}

export class Enum extends jspb.Message {
  getName(): string;
  setName(value: string): Enum;

  clearEnumvalueList(): Enum;
  getEnumvalueList(): Array<EnumValue>;
  setEnumvalueList(value: Array<EnumValue>): Enum;
  addEnumvalue(value?: EnumValue, index?: number): EnumValue;

  clearOptionsList(): Enum;
  getOptionsList(): Array<Option>;
  setOptionsList(value: Array<Option>): Enum;
  addOptions(value?: Option, index?: number): Option;

  hasSourceContext(): boolean;
  clearSourceContext(): Enum;
  getSourceContext(): google_protobuf_source_context_pb.SourceContext | undefined;
  setSourceContext(value?: google_protobuf_source_context_pb.SourceContext): Enum;

  getSyntax(): Syntax;
  setSyntax(value: Syntax): Enum;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Enum.AsObject;
  static toObject(includeInstance: boolean, msg: Enum): Enum.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Enum, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Enum;
  static deserializeBinaryFromReader(message: Enum, reader: jspb.BinaryReader): Enum;
}

export namespace Enum {
  export type AsObject = {
    name: string,
    enumvalueList: Array<EnumValue.AsObject>,
    optionsList: Array<Option.AsObject>,
    sourceContext?: google_protobuf_source_context_pb.SourceContext.AsObject | undefined,
    syntax: Syntax,
  }
}

export class EnumValue extends jspb.Message {
  getName(): string;
  setName(value: string): EnumValue;

  getNumber(): number;
  setNumber(value: number): EnumValue;

  clearOptionsList(): EnumValue;
  getOptionsList(): Array<Option>;
  setOptionsList(value: Array<Option>): EnumValue;
  addOptions(value?: Option, index?: number): Option;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EnumValue.AsObject;
  static toObject(includeInstance: boolean, msg: EnumValue): EnumValue.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EnumValue, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EnumValue;
  static deserializeBinaryFromReader(message: EnumValue, reader: jspb.BinaryReader): EnumValue;
}

export namespace EnumValue {
  export type AsObject = {
    name: string,
    number: number,
    optionsList: Array<Option.AsObject>,
  }
}

export class Option extends jspb.Message {
  getName(): string;
  setName(value: string): Option;

  hasValue(): boolean;
  clearValue(): Option;
  getValue(): google_protobuf_any_pb.Any | undefined;
  setValue(value?: google_protobuf_any_pb.Any): Option;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Option.AsObject;
  static toObject(includeInstance: boolean, msg: Option): Option.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Option, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Option;
  static deserializeBinaryFromReader(message: Option, reader: jspb.BinaryReader): Option;
}

export namespace Option {
  export type AsObject = {
    name: string,
    value?: google_protobuf_any_pb.Any.AsObject | undefined,
  }
}

export enum Syntax {
  SYNTAX_PROTO2 = 0,
  SYNTAX_PROTO3 = 1,
}
// package: google.protobuf
// file: wrappers.proto

import * as jspb from "../../index";

export class DoubleValue extends jspb.Message {
  getValue(): number;
  setValue(value: number): DoubleValue;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DoubleValue.AsObject;
  static toObject(includeInstance: boolean, msg: DoubleValue): DoubleValue.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DoubleValue, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DoubleValue;
  static deserializeBinaryFromReader(message: DoubleValue, reader: jspb.BinaryReader): DoubleValue;
}

export namespace DoubleValue {
  export type AsObject = {
    value: number,
  }
}

export class FloatValue extends jspb.Message {
  getValue(): number;
  setValue(value: number): FloatValue;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FloatValue.AsObject;
  static toObject(includeInstance: boolean, msg: FloatValue): FloatValue.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FloatValue, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FloatValue;
  static deserializeBinaryFromReader(message: FloatValue, reader: jspb.BinaryReader): FloatValue;
}

export namespace FloatValue {
  export type AsObject = {
    value: number,
  }
}

export class Int64Value extends jspb.Message {
  getValue(): number;
  setValue(value: number): Int64Value;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Int64Value.AsObject;
  static toObject(includeInstance: boolean, msg: Int64Value): Int64Value.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Int64Value, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Int64Value;
  static deserializeBinaryFromReader(message: Int64Value, reader: jspb.BinaryReader): Int64Value;
}

export namespace Int64Value {
  export type AsObject = {
    value: number,
  }
}

export class UInt64Value extends jspb.Message {
  getValue(): number;
  setValue(value: number): UInt64Value;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): UInt64Value.AsObject;
  static toObject(includeInstance: boolean, msg: UInt64Value): UInt64Value.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: UInt64Value, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): UInt64Value;
  static deserializeBinaryFromReader(message: UInt64Value, reader: jspb.BinaryReader): UInt64Value;
}

export namespace UInt64Value {
  export type AsObject = {
    value: number,
  }
}

export class Int32Value extends jspb.Message {
  getValue(): number;
  setValue(value: number): Int32Value;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Int32Value.AsObject;
  static toObject(includeInstance: boolean, msg: Int32Value): Int32Value.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Int32Value, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Int32Value;
  static deserializeBinaryFromReader(message: Int32Value, reader: jspb.BinaryReader): Int32Value;
}

export namespace Int32Value {
  export type AsObject = {
    value: number,
  }
}

export class UInt32Value extends jspb.Message {
  getValue(): number;
  setValue(value: number): UInt32Value;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): UInt32Value.AsObject;
  static toObject(includeInstance: boolean, msg: UInt32Value): UInt32Value.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: UInt32Value, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): UInt32Value;
  static deserializeBinaryFromReader(message: UInt32Value, reader: jspb.BinaryReader): UInt32Value;
}

export namespace UInt32Value {
  export type AsObject = {
    value: number,
  }
}

export class BoolValue extends jspb.Message {
  getValue(): boolean;
  setValue(value: boolean): BoolValue;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BoolValue.AsObject;
  static toObject(includeInstance: boolean, msg: BoolValue): BoolValue.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BoolValue, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BoolValue;
  static deserializeBinaryFromReader(message: BoolValue, reader: jspb.BinaryReader): BoolValue;
}

export namespace BoolValue {
  export type AsObject = {
    value: boolean,
  }
}

export class StringValue extends jspb.Message {
  getValue(): string;
  setValue(value: string): StringValue;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): StringValue.AsObject;
  static toObject(includeInstance: boolean, msg: StringValue): StringValue.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: StringValue, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): StringValue;
  static deserializeBinaryFromReader(message: StringValue, reader: jspb.BinaryReader): StringValue;
}

export namespace StringValue {
  export type AsObject = {
    value: string,
  }
}

export class BytesValue extends jspb.Message {
  getValue(): Uint8Array | string;
  getValue_asU8(): Uint8Array;
  getValue_asB64(): string;
  setValue(value: Uint8Array | string): BytesValue;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BytesValue.AsObject;
  static toObject(includeInstance: boolean, msg: BytesValue): BytesValue.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BytesValue, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BytesValue;
  static deserializeBinaryFromReader(message: BytesValue, reader: jspb.BinaryReader): BytesValue;
}

export namespace BytesValue {
  export type AsObject = {
    value: Uint8Array | string,
  }
}
// Type definitions for google-protobuf 3.15
// Project: https://github.com/google/google-protobuf
// Definitions by: Marcus Longmuir <https://github.com/marcuslongmuir>
//                 Chaitanya Kamatham <https://github.com/kamthamc>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

type ByteSource = ArrayBuffer | Uint8Array | number[] | string;
type ScalarFieldType = boolean | number | string;
type RepeatedFieldType = ScalarFieldType[] | Uint8Array[];
type AnyFieldType = ScalarFieldType | RepeatedFieldType | Uint8Array;
type FieldValue = string | number | boolean | Uint8Array | FieldValueArray | undefined;
interface FieldValueArray extends Array<FieldValue> {}

export abstract class Message {
  getJsPbMessageId(): (string | undefined);
  static initialize(
    msg: Message,
    data: Message.MessageArray,
    messageId: (string | number),
    suggestedPivot: number,
    repeatedFields?: number[] | null,
    oneofFields?: number[][] | null): void;
  static toObjectList<T extends Message>(
    field: T[],
    toObjectFn: (includeInstance: boolean, data: T) => {},
    includeInstance?: boolean): Array<{}>;
  static toObjectExtension(
    msg: Message,
    obj: {},
    extensions: {[key: number]: ExtensionFieldInfo<Message>},
    getExtensionFn: (fieldInfo: ExtensionFieldInfo<Message>) => Message,
    includeInstance?: boolean): void;
  serializeBinaryExtensions(
    proto: Message,
    writer: BinaryWriter,
    extensions: { [key: number]: ExtensionFieldBinaryInfo<Message> },
    getExtensionFn: <T>(fieldInfo: ExtensionFieldInfo<T>) => T): void
  readBinaryExtension(
    proto: Message,
    reader: BinaryReader,
    extensions: {[key: number]: ExtensionFieldBinaryInfo<Message>},
    setExtensionFn: <T>(fieldInfo: ExtensionFieldInfo<T>,
    val: T) => void): void
  static getField(msg: Message, fieldNumber: number): FieldValue|null;
  static getOptionalFloatingPointField(msg: Message, fieldNumber: number): number | undefined;
  static getRepeatedFloatingPointField(msg: Message, fieldNumber: number): number[];
  static bytesAsB64(bytes: Uint8Array): string;
  static bytesAsU8(str: string): Uint8Array;
  static bytesListAsB64(bytesList: Uint8Array[]): string[];
  static bytesListAsU8(strList: string[]): Uint8Array[];
  static getFieldWithDefault<T>(msg: Message, fieldNumber: number, defaultValue: T): T;
  static getMapField(
    msg: Message,
    fieldNumber: number,
    noLazyCreate: boolean,
    valueCtor?: typeof Message): Map<any, any>;
  static setField(
    msg: Message,
    fieldNumber: number,
    value: FieldValue): void;
  static addToRepeatedField(
    msg: Message,
    fieldNumber: number,
    value: any,
    index?: number): void;
  static setOneofField(
    msg: Message,
    fieldNumber: number,
    oneof: number[],
    value: FieldValue): void;
  static computeOneofCase(msg: Message, oneof: number[]): number;
  static getWrapperField<T extends Message>(
    msg: Message,
    ctor: { new(): T },
    fieldNumber: number,
    required?: number): T;
  static getRepeatedWrapperField<T extends Message>(
    msg: Message,
    ctor: { new(): T },
    fieldNumber: number): T[];
  static setWrapperField<T extends Message>(
    msg: Message,
    fieldNumber: number,
    value?: (T|Map<any, any>)): void;
  static setOneofWrapperField(
    msg: Message,
    fieldNumber: number,
    oneof: number[],
    value: any): void;
  static setRepeatedWrapperField<T extends Message>(
    msg: Message,
    fieldNumber: number,
    value?: T[]): void;
  static addToRepeatedWrapperField<T extends Message>(
    msg: Message,
    fieldNumber: number,
    value: T | undefined,
    ctor: { new(): T },
    index?: number): T;
  static toMap(
    field: any[],
    mapKeyGetterFn: (field: any) => string,
    toObjectFn?: Message.StaticToObject,
    includeInstance?: boolean): void;
  toArray(): Message.MessageArray;
  toString(): string;
  getExtension<T>(fieldInfo: ExtensionFieldInfo<T>): T;
  setExtension<T>(fieldInfo: ExtensionFieldInfo<T>, value: T): void;
  static difference<T extends Message>(m1: T, m2: T): T;
  static equals(m1: Message, m2: Message): boolean;
  static compareExtensions(extension1: {}, extension2: {}): boolean;
  static compareFields(field1: any, field2: any): boolean;
  cloneMessage(): this;
  clone(): this;
  static clone<T extends Message>(msg: T): T;
  static cloneMessage<T extends Message>(msg: T): T;
  static copyInto(fromMessage: Message, toMessage: Message): void;
  static registerMessageType(id: number, constructor: typeof Message): void;

  abstract serializeBinary(): Uint8Array;
  abstract toObject(includeInstance?: boolean): {};

  // These are `abstract static`, but that isn't allowed. Subclasses of Message will have these methods and properties
  // and not having them on Message makes using this class for its intended purpose quite difficult.
  static deserializeBinary(bytes: Uint8Array): Message;
  static deserializeBinaryFromReader(message: Message, reader: BinaryReader): Message;
  static serializeBinaryToWriter(message: Message, writer: BinaryWriter): void;
  static toObject(includeInstance: boolean, msg: Message): {};
  static extensions: { [key: number]: ExtensionFieldInfo<Message> };
  static extensionsBinary: { [key: number]: ExtensionFieldBinaryInfo<Message> };
}

export namespace Message {
  type MessageArray = any[]; // This type needs to reference itself
  type StaticToObject = (includeInstance: boolean, msg: Message) => {};
}

export class ExtensionFieldInfo<T> {
  fieldIndex: number;
  fieldName: number;
  ctor: typeof Message;
  toObjectFn: Message.StaticToObject;
  isRepeated: number;
  constructor(
    fieldIndex: number,
    fieldName: {[key: string]: number},
    ctor: typeof Message,
    toObjectFn: Message.StaticToObject,
    isRepeated: number);
  isMessageType(): boolean;
}

export class ExtensionFieldBinaryInfo<T> {
  fieldInfo: ExtensionFieldInfo<T>;
  binaryReaderFn: BinaryRead;
  binaryWriterFn: BinaryWrite;
  opt_binaryMessageSerializeFn: (msg: Message, writer: BinaryWriter) => void;
  opt_binaryMessageDeserializeFn: (msg: Message, reader: BinaryReader) => Message;
  opt_isPacked: boolean;
  constructor(
    fieldInfo: ExtensionFieldInfo<T>,
    binaryReaderFn: BinaryRead,
    binaryWriterFn: BinaryWrite,
    opt_binaryMessageSerializeFn: (msg: Message, writer: BinaryWriter) => void,
    opt_binaryMessageDeserializeFn: (msg: Message, reader: BinaryReader) => Message,
    opt_isPacked: boolean);
}

export class Map<K, V> {
  constructor(
    arr: Array<[K, V]>,
    valueCtor?: {new(init: any): V});
  toArray(): Array<[K, V]>;
  toObject(includeInstance?: boolean): Array<[K, V]>;
  toObject<VO>(
    includeInstance: boolean,
    valueToObject: (includeInstance: boolean, valueWrapper: V) => VO): Array<[K, VO]>;
  static fromObject<TK, TV>(
    entries: Array<[TK, TV]>,
    valueCtor: any,
    valueFromObject: any): Map<TK, TV>;
  getLength(): number;
  clear(): void;
  del(key: K): boolean;
  getEntryList(): Array<[K, V]>;
  entries(): Map.Iterator<[K, V]>;
  keys(): Map.Iterator<K>;
  values(): Map.Iterator<V>;
  forEach(
    callback: (entry: V, key: K) => void,
    thisArg?: {}): void;
  set(key: K, value: V): this;
  get(key: K): (V | undefined);
  has(key: K): boolean;
  serializeBinary(
    fieldNumber: number,
    writer: BinaryWriter,
    keyWriterFn: (field: number, key: K) => void,
    valueWriterFn: (field: number, value: V, writerCallback: BinaryWriteCallback) => void,
    writeCallback?: BinaryWriteCallback
  ): void;
  static deserializeBinary<K, V>(
    map: Map<K, V>,
    reader: BinaryReader,
    keyReaderFn: (reader: BinaryReader) => K,
    valueReaderFn: (reader: BinaryReader, value: any, readerCallback: BinaryReadCallback) => V,
    readCallback?: BinaryReadCallback,
    defaultKey?: K,
    defaultValue?: V
  ): void;
}

export namespace Map {
  // This is implemented by jspb.Map.ArrayIteratorIterable_, but that class shouldn't be exported
  interface Iterator<T> {
    [Symbol.iterator](): Iterator<T>;
    next(): IteratorResult<T>;
  }
  interface IteratorResult<T> {
    done: boolean;
    value: T;
  }
}

type BinaryReadReader = (msg: any, binaryReader: BinaryReader) => void;

type BinaryRead = (msg: any, reader: BinaryReadReader) => any;

type BinaryReadCallback = (value: any, binaryReader: BinaryReader) => void;

type BinaryWriteCallback = (value: any, binaryWriter: BinaryWriter) => void;

type BinaryWrite = (fieldNumber: number, value: any, writerCallback: BinaryWriteCallback) => void;

export class BinaryReader {
  constructor(bytes?: ByteSource, start?: number, length?: number);
  static alloc(bytes?: ByteSource, start?: number, length?: number): BinaryReader;
  alloc(bytes?: ByteSource, start?: number, length?: number): BinaryReader;
  free(): void;
  getFieldCursor(): number;
  getCursor(): number;
  getBuffer(): Uint8Array;
  getFieldNumber(): number;
  getWireType(): BinaryConstants.WireType;
  isDelimited(): boolean;
  isEndGroup(): boolean;
  getError(): boolean;
  setBlock(bytes?: ByteSource, start?: number, length?: number): void;
  reset(): void;
  advance(count: number): void;
  nextField(): boolean;
  unskipHeader(): void;
  skipMatchingFields(): void;
  skipVarintField(): void;
  skipDelimitedField(): void;
  skipFixed32Field(): void;
  skipFixed64Field(): void;
  skipGroup(): void;
  skipField(): void;
  registerReadCallback(callbackName: string, callback: (binaryReader: BinaryReader) => any): void;
  runReadCallback(callbackName: string): any;
  readAny(fieldType: BinaryConstants.FieldType): AnyFieldType;
  readMessage: BinaryRead;
  readGroup(field: number, message: Message, reader: BinaryReadReader): void;
  getFieldDecoder(): BinaryDecoder;
  readInt32(): number;
  readInt32String(): string;
  readInt64(): number;
  readInt64String(): string;
  readUint32(): number;
  readUint32String(): string;
  readUint64(): number;
  readUint64String(): string;
  readSint32(): number;
  readSint64(): number;
  readSint64String(): string;
  readFixed32(): number;
  readFixed64(): number;
  readFixed64String(): string;
  readSfixed32(): number;
  readSfixed32String(): string;
  readSfixed64(): number;
  readSfixed64String(): string;
  readFloat(): number;
  readDouble(): number;
  readBool(): boolean;
  readEnum(): number;
  readString(): string;
  readBytes(): Uint8Array;
  readVarintHash64(): string;
  readFixedHash64(): string;
  readPackedInt32(): number[];
  readPackedInt32String(): string[];
  readPackedInt64(): number[];
  readPackedInt64String(): string[];
  readPackedUint32(): number[];
  readPackedUint32String(): string[];
  readPackedUint64(): number[];
  readPackedUint64String(): string[];
  readPackedSint32(): number[];
  readPackedSint64(): number[];
  readPackedSint64String(): string[];
  readPackedFixed32(): number[];
  readPackedFixed64(): number[];
  readPackedFixed64String(): string[];
  readPackedSfixed32(): number[];
  readPackedSfixed64(): number[];
  readPackedSfixed64String(): string[];
  readPackedFloat(): number[];
  readPackedDouble(): number[];
  readPackedBool(): boolean[];
  readPackedEnum(): number[];
  readPackedVarintHash64(): string[];
  readPackedFixedHash64(): string[];
}

export class BinaryWriter {
  constructor();
  writeSerializedMessage(bytes: Uint8Array, start: number, end: number): void;
  maybeWriteSerializedMessage(bytes?: Uint8Array, start?: number, end?: number): void;
  reset(): void;
  getResultBuffer(): Uint8Array;
  getResultBase64String(): string;
  beginSubMessage(field: number): void;
  endSubMessage(field: number): void;
  writeAny(fieldType: BinaryConstants.FieldType, field: number, value: AnyFieldType): void;
  writeInt32(field: number, value?: number): void;
  writeInt32String(field: number, value?: string): void;
  writeInt64(field: number, value?: number): void;
  writeInt64String(field: number, value?: string): void;
  writeUint32(field: number, value?: number): void;
  writeUint32String(field: number, value?: string): void;
  writeUint64(field: number, value?: number): void;
  writeUint64String(field: number, value?: string): void;
  writeSint32(field: number, value?: number): void;
  writeSint64(field: number, value?: number): void;
  writeSint64String(field: number, value?: string): void;
  writeFixed32(field: number, value?: number): void;
  writeFixed64(field: number, value?: number): void;
  writeFixed64String(field: number, value?: string): void;
  writeSfixed32(field: number, value?: number): void;
  writeSfixed64(field: number, value?: number): void;
  writeSfixed64String(field: number, value?: string): void;
  writeFloat(field: number, value?: number): void;
  writeDouble(field: number, value?: number): void;
  writeBool(field: number, value?: boolean): void;
  writeEnum(field: number, value?: number): void;
  writeString(field: number, value?: string): void;
  writeBytes(field: number, value?: ByteSource): void;
  writeMessage: BinaryWrite;
  writeGroup(field: number, value: any, writeCallback: BinaryWriteCallback): void;
  writeFixedHash64(field: number, value?: string): void;
  writeVarintHash64(field: number, value?: string): void;
  writeRepeatedInt32(field: number, value?: number[]): void;
  writeRepeatedInt32String(field: number, value?: string[]): void;
  writeRepeatedInt64(field: number, value?: number[]): void;
  writeRepeatedInt64String(field: number, value?: string[]): void;
  writeRepeatedUint32(field: number, value?: number[]): void;
  writeRepeatedUint32String(field: number, value?: string[]): void;
  writeRepeatedUint64(field: number, value?: number[]): void;
  writeRepeatedUint64String(field: number, value?: string[]): void;
  writeRepeatedSint32(field: number, value?: number[]): void;
  writeRepeatedSint64(field: number, value?: number[]): void;
  writeRepeatedSint64String(field: number, value?: string[]): void;
  writeRepeatedFixed32(field: number, value?: number[]): void;
  writeRepeatedFixed64(field: number, value?: number[]): void;
  writeRepeatedFixed64String(field: number, value?: string[]): void;
  writeRepeatedSfixed32(field: number, value?: number[]): void;
  writeRepeatedSfixed64(field: number, value?: number[]): void;
  writeRepeatedSfixed64String(field: number, value?: string[]): void;
  writeRepeatedFloat(field: number, value?: number[]): void;
  writeRepeatedDouble(field: number, value?: number[]): void;
  writeRepeatedBool(field: number, value?: boolean[]): void;
  writeRepeatedEnum(field: number, value?: number[]): void;
  writeRepeatedString(field: number, value?: string[]): void;
  writeRepeatedBytes(field: number, value?: ByteSource[]): void;
  writeRepeatedMessage(field: number, value: Message[],  writerCallback: BinaryWriteCallback): void;
  writeRepeatedGroup(field: number, value: Message[], writerCallback: BinaryWriteCallback): void;
  writeRepeatedFixedHash64(field: number, value?: string[]): void;
  writeRepeatedVarintHash64(field: number, value?: string[]): void;
  writePackedInt32(field: number, value?: number[]): void;
  writePackedInt32String(field: number, value?: string[]): void;
  writePackedInt64(field: number, value?: number[]): void;
  writePackedInt64String(field: number, value?: string[]): void;
  writePackedUint32(field: number, value?: number[]): void;
  writePackedUint32String(field: number, value?: string[]): void;
  writePackedUint64(field: number, value?: number[]): void;
  writePackedUint64String(field: number, value?: string[]): void;
  writePackedSint32(field: number, value?: number[]): void;
  writePackedSint64(field: number, value?: number[]): void;
  writePackedSint64String(field: number, value?: string[]): void;
  writePackedFixed32(field: number, value?: number[]): void;
  writePackedFixed64(field: number, value?: number[]): void;
  writePackedFixed64String(field: number, value?: string[]): void;
  writePackedSfixed32(field: number, value?: number[]): void;
  writePackedSfixed64(field: number, value?: number[]): void;
  writePackedSfixed64String(field: number, value?: string[]): void;
  writePackedFloat(field: number, value?: number[]): void;
  writePackedDouble(field: number, value?: number[]): void;
  writePackedBool(field: number, value?: boolean[]): void;
  writePackedEnum(field: number, value?: number[]): void;
  writePackedFixedHash64(field: number, value?: string[]): void;
  writePackedVarintHash64(field: number, value?: string[]): void;
}

export class BinaryEncoder {
  constructor();
  length(): number;
  end(): number[];
  writeSplitVarint64(lowBits: number, highBits: number): void;
  writeSplitFixed64(lowBits: number, highBits: number): void;
  writeUnsignedVarint32(value: number): void;
  writeSignedVarint32(value: number): void;
  writeUnsignedVarint64(value: number): void;
  writeSignedVarint64(value: number): void;
  writeZigzagVarint32(value: number): void;
  writeZigzagVarint64(value: number): void;
  writeZigzagVarint64String(value: string): void;
  writeUint8(value: number): void;
  writeUint16(value: number): void;
  writeUint32(value: number): void;
  writeUint64(value: number): void;
  writeInt8(value: number): void;
  writeInt16(value: number): void;
  writeInt32(value: number): void;
  writeInt64(value: number): void;
  writeInt64String(value: string): void;
  writeFloat(value: number): void;
  writeDouble(value: number): void;
  writeBool(value: boolean): void;
  writeEnum(value: number): void;
  writeBytes(bytes: Uint8Array): void;
  writeVarintHash64(hash: string): void;
  writeFixedHash64(hash: string): void;
  writeString(value: string): number;
}

export class BinaryDecoder {
  constructor(bytes?: ByteSource, start?: number, length?: number)
  static alloc(bytes?: ByteSource, start?: number, length?: number): BinaryDecoder;
  free(): void;
  clone(): BinaryDecoder;
  clear(): void;
  getBuffer(): Uint8Array;
  setBlock(data: ByteSource, start?: number, length?: number): void;
  getEnd(): number;
  setEnd(end: number): void;
  reset(): void;
  getCursor(): number;
  setCursor(cursor: number): void;
  advance(count: number): void;
  atEnd(): boolean;
  pastEnd(): boolean;
  getError(): boolean;
  skipVarint(): void;
  unskipVarint(value: number): void;
  readUnsignedVarint32(): number;
  readSignedVarint32(): number;
  readUnsignedVarint32String(): number;
  readSignedVarint32String(): number;
  readZigzagVarint32(): number;
  readUnsignedVarint64(): number;
  readUnsignedVarint64String(): number;
  readSignedVarint64(): number;
  readSignedVarint64String(): number;
  readZigzagVarint64(): number;
  readZigzagVarint64String(): number;
  readUint8(): number;
  readUint16(): number;
  readUint32(): number;
  readUint64(): number;
  readUint64String(): string;
  readInt8(): number;
  readInt16(): number;
  readInt32(): number;
  readInt64(): number;
  readInt64String(): string;
  readFloat(): number;
  readDouble(): number;
  readBool(): boolean;
  readEnum(): number;
  readString(length: number): string;
  readStringWithLength(): string;
  readBytes(length: number): Uint8Array;
  readVarintHash64(): string;
  readFixedHash64(): string;
}

export class BinaryIterator {
  constructor(
    decoder?: BinaryDecoder, next?: () => number | boolean | string | null,
    elements?: Array<number | boolean | string>)
  static alloc(
    decoder?: BinaryDecoder,
    next?: () => number | boolean | string | null,
    elements?: Array<number | boolean | string>): BinaryIterator;
  free(): void;
  clear(): void;
  get(): ScalarFieldType | null;
  atEnd(): boolean;
  next(): ScalarFieldType | null;
}

export namespace BinaryConstants {
  enum FieldType {
    INVALID = -1,
    DOUBLE = 1,
    FLOAT = 2,
    INT64 = 3,
    UINT64 = 4,
    INT32 = 5,
    FIXED64 = 6,
    FIXED32 = 7,
    BOOL = 8,
    STRING = 9,
    GROUP = 10,
    MESSAGE = 11,
    BYTES = 12,
    UINT32 = 13,
    ENUM = 14,
    SFIXED32 = 15,
    SFIXED64 = 16,
    SINT32 = 17,
    SINT64 = 18,
    FHASH64 = 30,
    VHASH64 = 31,
  }

  enum WireType {
    INVALID = -1,
    VARINT = 0,
    FIXED64 = 1,
    DELIMITED = 2,
    START_GROUP = 3,
    END_GROUP = 4,
    FIXED32 = 5,
  }

  const FieldTypeToWireType: (fieldType: FieldType) => WireType;

  const INVALID_FIELD_NUMBER: number;
  const FLOAT32_EPS: number;
  const FLOAT32_MIN: number;
  const FLOAT32_MAX: number;
  const FLOAT64_EPS: number;
  const FLOAT64_MIN: number;
  const FLOAT64_MAX: number;
  const TWO_TO_20: number;
  const TWO_TO_23: number;
  const TWO_TO_31: number;
  const TWO_TO_32: number;
  const TWO_TO_52: number;
  const TWO_TO_63: number;
  const TWO_TO_64: number;
  const ZERO_HASH: string;
}

export namespace arith {
  class UInt64 {
    lo: number;
    hi: number;
    constructor(lo: number, hi: number);
    cmp(other: UInt64): number;
    rightShift(): UInt64;
    leftShift(): UInt64;
    msb(): boolean;
    lsb(): boolean;
    zero(): boolean;
    add(other: UInt64): UInt64;
    sub(other: UInt64): UInt64;
    static mul32x32(a: number, b: number): UInt64;
    mul(a: number): UInt64;
    div(divisor: number): [UInt64, UInt64];
    toString(): string;
    static fromString(str: string): UInt64;
    clone(): UInt64;
  }

  class Int64 {
    lo: number;
    hi: number;
    constructor(lo: number, hi: number);
    add(other: Int64): Int64;
    sub(other: Int64): Int64;
    clone(): Int64;
    toString(): string;
    static fromString(str: string): Int64;
  }
}

// jspb.utils package excluded as it likely shouldn't be called by user code
    MIT License

    Copyright (c) Microsoft Corporation.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE
{
    "name": "@types/google-protobuf",
    "version": "3.15.6",
    "description": "TypeScript definitions for google-protobuf",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/google-protobuf",
    "license": "MIT",
    "contributors": [
        {
            "name": "Marcus Longmuir",
            "url": "https://github.com/marcuslongmuir",
            "githubUsername": "marcuslongmuir"
        },
        {
            "name": "Chaitanya Kamatham",
            "url": "https://github.com/kamthamc",
            "githubUsername": "kamthamc"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/google-protobuf"
    },
    "scripts": {},
    "dependencies": {},
    "typesPublisherContentHash": "52bcbdc0bcf70a9d296a1564997129b047f30feeb42083c4ea21b45150611304",
    "typeScriptVersion": "3.9"
}# Installation
> `npm install --save @types/google-protobuf`

# Summary
This package contains type definitions for google-protobuf (https://github.com/google/google-protobuf).

# Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/google-protobuf.

### Additional Details
 * Last updated: Thu, 28 Apr 2022 23:31:44 GMT
 * Dependencies: none
 * Global values: none

# Credits
These definitions were written by [Marcus Longmuir](https://github.com/marcuslongmuir), and [Chaitanya Kamatham](https://github.com/kamthamc).
// ==================================================================================================
// JSON Schema Draft 04
// ==================================================================================================

/**
 * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.1
 */
export type JSONSchema4TypeName =
    | "string" //
    | "number"
    | "integer"
    | "boolean"
    | "object"
    | "array"
    | "null"
    | "any";

/**
 * @see https://tools.ietf.org/html/draft-zyp-json-schema-04#section-3.5
 */
export type JSONSchema4Type =
    | string //
    | number
    | boolean
    | JSONSchema4Object
    | JSONSchema4Array
    | null;

// Workaround for infinite type recursion
export interface JSONSchema4Object {
    [key: string]: JSONSchema4Type;
}

// Workaround for infinite type recursion
// https://github.com/Microsoft/TypeScript/issues/3496#issuecomment-128553540
export interface JSONSchema4Array extends Array<JSONSchema4Type> {}

/**
 * Meta schema
 *
 * Recommended values:
 * - 'http://json-schema.org/schema#'
 * - 'http://json-schema.org/hyper-schema#'
 * - 'http://json-schema.org/draft-04/schema#'
 * - 'http://json-schema.org/draft-04/hyper-schema#'
 * - 'http://json-schema.org/draft-03/schema#'
 * - 'http://json-schema.org/draft-03/hyper-schema#'
 *
 * @see https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-5
 */
export type JSONSchema4Version = string;

/**
 * JSON Schema V4
 * @see https://tools.ietf.org/html/draft-zyp-json-schema-04
 */
export interface JSONSchema4 {
    id?: string | undefined;
    $ref?: string | undefined;
    $schema?: JSONSchema4Version | undefined;

    /**
     * This attribute is a string that provides a short description of the
     * instance property.
     *
     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.21
     */
    title?: string | undefined;

    /**
     * This attribute is a string that provides a full description of the of
     * purpose the instance property.
     *
     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.22
     */
    description?: string | undefined;

    default?: JSONSchema4Type | undefined;
    multipleOf?: number | undefined;
    maximum?: number | undefined;
    exclusiveMaximum?: boolean | undefined;
    minimum?: number | undefined;
    exclusiveMinimum?: boolean | undefined;
    maxLength?: number | undefined;
    minLength?: number | undefined;
    pattern?: string | undefined;

    /**
     * May only be defined when "items" is defined, and is a tuple of JSONSchemas.
     *
     * This provides a definition for additional items in an array instance
     * when tuple definitions of the items is provided.  This can be false
     * to indicate additional items in the array are not allowed, or it can
     * be a schema that defines the schema of the additional items.
     *
     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.6
     */
    additionalItems?: boolean | JSONSchema4 | undefined;

    /**
     * This attribute defines the allowed items in an instance array, and
     * MUST be a schema or an array of schemas.  The default value is an
     * empty schema which allows any value for items in the instance array.
     *
     * When this attribute value is a schema and the instance value is an
     * array, then all the items in the array MUST be valid according to the
     * schema.
     *
     * When this attribute value is an array of schemas and the instance
     * value is an array, each position in the instance array MUST conform
     * to the schema in the corresponding position for this array.  This
     * called tuple typing.  When tuple typing is used, additional items are
     * allowed, disallowed, or constrained by the "additionalItems"
     * (Section 5.6) attribute using the same rules as
     * "additionalProperties" (Section 5.4) for objects.
     *
     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.5
     */
    items?: JSONSchema4 | JSONSchema4[] | undefined;

    maxItems?: number | undefined;
    minItems?: number | undefined;
    uniqueItems?: boolean | undefined;
    maxProperties?: number | undefined;
    minProperties?: number | undefined;

    /**
     * This attribute indicates if the instance must have a value, and not
     * be undefined. This is false by default, making the instance
     * optional.
     *
     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.7
     */
    required?: boolean | string[] | undefined;

    /**
     * This attribute defines a schema for all properties that are not
     * explicitly defined in an object type definition. If specified, the
     * value MUST be a schema or a boolean. If false is provided, no
     * additional properties are allowed beyond the properties defined in
     * the schema. The default value is an empty schema which allows any
     * value for additional properties.
     *
     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.4
     */
    additionalProperties?: boolean | JSONSchema4 | undefined;

    definitions?: {
        [k: string]: JSONSchema4;
    } | undefined;

    /**
     * This attribute is an object with property definitions that define the
     * valid values of instance object property values. When the instance
     * value is an object, the property values of the instance object MUST
     * conform to the property definitions in this object. In this object,
     * each property definition's value MUST be a schema, and the property's
     * name MUST be the name of the instance property that it defines.  The
     * instance property value MUST be valid according to the schema from
     * the property definition. Properties are considered unordered, the
     * order of the instance properties MAY be in any order.
     *
     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.2
     */
    properties?: {
        [k: string]: JSONSchema4;
    } | undefined;

    /**
     * This attribute is an object that defines the schema for a set of
     * property names of an object instance. The name of each property of
     * this attribute's object is a regular expression pattern in the ECMA
     * 262/Perl 5 format, while the value is a schema. If the pattern
     * matches the name of a property on the instance object, the value of
     * the instance's property MUST be valid against the pattern name's
     * schema value.
     *
     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.3
     */
    patternProperties?: {
        [k: string]: JSONSchema4;
    } | undefined;
    dependencies?: {
        [k: string]: JSONSchema4 | string[];
    } | undefined;

    /**
     * This provides an enumeration of all possible values that are valid
     * for the instance property. This MUST be an array, and each item in
     * the array represents a possible value for the instance value. If
     * this attribute is defined, the instance value MUST be one of the
     * values in the array in order for the schema to be valid.
     *
     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.19
     */
    enum?: JSONSchema4Type[] | undefined;

    /**
     * A single type, or a union of simple types
     */
    type?: JSONSchema4TypeName | JSONSchema4TypeName[] | undefined;

    allOf?: JSONSchema4[] | undefined;
    anyOf?: JSONSchema4[] | undefined;
    oneOf?: JSONSchema4[] | undefined;
    not?: JSONSchema4 | undefined;

    /**
     * The value of this property MUST be another schema which will provide
     * a base schema which the current schema will inherit from.  The
     * inheritance rules are such that any instance that is valid according
     * to the current schema MUST be valid according to the referenced
     * schema.  This MAY also be an array, in which case, the instance MUST
     * be valid for all the schemas in the array.  A schema that extends
     * another schema MAY define additional attributes, constrain existing
     * attributes, or add other constraints.
     *
     * Conceptually, the behavior of extends can be seen as validating an
     * instance against all constraints in the extending schema as well as
     * the extended schema(s).
     *
     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.26
     */
    extends?: string | string[] | undefined;

    /**
     * @see https://tools.ietf.org/html/draft-zyp-json-schema-04#section-5.6
     */
    [k: string]: any;

    format?: string | undefined;
}

// ==================================================================================================
// JSON Schema Draft 06
// ==================================================================================================

export type JSONSchema6TypeName =
    | "string" //
    | "number"
    | "integer"
    | "boolean"
    | "object"
    | "array"
    | "null"
    | "any";

export type JSONSchema6Type =
    | string //
    | number
    | boolean
    | JSONSchema6Object
    | JSONSchema6Array
    | null;

// Workaround for infinite type recursion
export interface JSONSchema6Object {
    [key: string]: JSONSchema6Type;
}

// Workaround for infinite type recursion
// https://github.com/Microsoft/TypeScript/issues/3496#issuecomment-128553540
export interface JSONSchema6Array extends Array<JSONSchema6Type> {}

/**
 * Meta schema
 *
 * Recommended values:
 * - 'http://json-schema.org/schema#'
 * - 'http://json-schema.org/hyper-schema#'
 * - 'http://json-schema.org/draft-06/schema#'
 * - 'http://json-schema.org/draft-06/hyper-schema#'
 *
 * @see https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-5
 */
export type JSONSchema6Version = string;

/**
 * JSON Schema V6
 * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01
 */
export type JSONSchema6Definition = JSONSchema6 | boolean;
export interface JSONSchema6 {
    $id?: string | undefined;
    $ref?: string | undefined;
    $schema?: JSONSchema6Version | undefined;

    /**
     * Must be strictly greater than 0.
     * A numeric instance is valid only if division by this keyword's value results in an integer.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.1
     */
    multipleOf?: number | undefined;

    /**
     * Representing an inclusive upper limit for a numeric instance.
     * This keyword validates only if the instance is less than or exactly equal to "maximum".
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.2
     */
    maximum?: number | undefined;

    /**
     * Representing an exclusive upper limit for a numeric instance.
     * This keyword validates only if the instance is strictly less than (not equal to) to "exclusiveMaximum".
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.3
     */
    exclusiveMaximum?: number | undefined;

    /**
     * Representing an inclusive lower limit for a numeric instance.
     * This keyword validates only if the instance is greater than or exactly equal to "minimum".
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.4
     */
    minimum?: number | undefined;

    /**
     * Representing an exclusive lower limit for a numeric instance.
     * This keyword validates only if the instance is strictly greater than (not equal to) to "exclusiveMinimum".
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.5
     */
    exclusiveMinimum?: number | undefined;

    /**
     * Must be a non-negative integer.
     * A string instance is valid against this keyword if its length is less than, or equal to, the value of this keyword.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.6
     */
    maxLength?: number | undefined;

    /**
     * Must be a non-negative integer.
     * A string instance is valid against this keyword if its length is greater than, or equal to, the value of this keyword.
     * Omitting this keyword has the same behavior as a value of 0.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.7
     */
    minLength?: number | undefined;

    /**
     * Should be a valid regular expression, according to the ECMA 262 regular expression dialect.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.8
     */
    pattern?: string | undefined;

    /**
     * This keyword determines how child instances validate for arrays, and does not directly validate the immediate instance itself.
     * Omitting this keyword has the same behavior as an empty schema.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.9
     */
    items?: JSONSchema6Definition | JSONSchema6Definition[] | undefined;

    /**
     * This keyword determines how child instances validate for arrays, and does not directly validate the immediate instance itself.
     * If "items" is an array of schemas, validation succeeds if every instance element
     * at a position greater than the size of "items" validates against "additionalItems".
     * Otherwise, "additionalItems" MUST be ignored, as the "items" schema
     * (possibly the default value of an empty schema) is applied to all elements.
     * Omitting this keyword has the same behavior as an empty schema.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.10
     */
    additionalItems?: JSONSchema6Definition | undefined;

    /**
     * Must be a non-negative integer.
     * An array instance is valid against "maxItems" if its size is less than, or equal to, the value of this keyword.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.11
     */
    maxItems?: number | undefined;

    /**
     * Must be a non-negative integer.
     * An array instance is valid against "maxItems" if its size is greater than, or equal to, the value of this keyword.
     * Omitting this keyword has the same behavior as a value of 0.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.12
     */
    minItems?: number | undefined;

    /**
     * If this keyword has boolean value false, the instance validates successfully.
     * If it has boolean value true, the instance validates successfully if all of its elements are unique.
     * Omitting this keyword has the same behavior as a value of false.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.13
     */
    uniqueItems?: boolean | undefined;

    /**
     * An array instance is valid against "contains" if at least one of its elements is valid against the given schema.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.14
     */
    contains?: JSONSchema6Definition | undefined;

    /**
     * Must be a non-negative integer.
     * An object instance is valid against "maxProperties" if its number of properties is less than, or equal to, the value of this keyword.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.15
     */
    maxProperties?: number | undefined;

    /**
     * Must be a non-negative integer.
     * An object instance is valid against "maxProperties" if its number of properties is greater than,
     * or equal to, the value of this keyword.
     * Omitting this keyword has the same behavior as a value of 0.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.16
     */
    minProperties?: number | undefined;

    /**
     * Elements of this array must be unique.
     * An object instance is valid against this keyword if every item in the array is the name of a property in the instance.
     * Omitting this keyword has the same behavior as an empty array.
     *
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.17
     */
    required?: string[] | undefined;

    /**
     * This keyword determines how child instances validate for objects, and does not directly validate the immediate instance itself.
     * Validation succeeds if, for each name that appears in both the instance and as a name within this keyword's value,
     * the child instance for that name successfully validates against the corresponding schema.
     * Omitting this keyword has the same behavior as an empty object.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.18
     */
    properties?: {
        [k: string]: JSONSchema6Definition;
    } | undefined;

    /**
     * This attribute is an object that defines the schema for a set of property names of an object instance.
     * The name of each property of this attribute's object is a regular expression pattern in the ECMA 262, while the value is a schema.
     * If the pattern matches the name of a property on the instance object, the value of the instance's property
     * MUST be valid against the pattern name's schema value.
     * Omitting this keyword has the same behavior as an empty object.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.19
     */
    patternProperties?: {
        [k: string]: JSONSchema6Definition;
    } | undefined;

    /**
     * This attribute defines a schema for all properties that are not explicitly defined in an object type definition.
     * If specified, the value MUST be a schema or a boolean.
     * If false is provided, no additional properties are allowed beyond the properties defined in the schema.
     * The default value is an empty schema which allows any value for additional properties.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.20
     */
    additionalProperties?: JSONSchema6Definition | undefined;

    /**
     * This keyword specifies rules that are evaluated if the instance is an object and contains a certain property.
     * Each property specifies a dependency.
     * If the dependency value is an array, each element in the array must be unique.
     * Omitting this keyword has the same behavior as an empty object.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.21
     */
    dependencies?: {
        [k: string]: JSONSchema6Definition | string[];
    } | undefined;

    /**
     * Takes a schema which validates the names of all properties rather than their values.
     * Note the property name that the schema is testing will always be a string.
     * Omitting this keyword has the same behavior as an empty schema.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.22
     */
    propertyNames?: JSONSchema6Definition | undefined;

    /**
     * This provides an enumeration of all possible values that are valid
     * for the instance property. This MUST be an array, and each item in
     * the array represents a possible value for the instance value. If
     * this attribute is defined, the instance value MUST be one of the
     * values in the array in order for the schema to be valid.
     *
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.23
     */
    enum?: JSONSchema6Type[] | undefined;

    /**
     * More readable form of a one-element "enum"
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.24
     */
    const?: JSONSchema6Type | undefined;

    /**
     * A single type, or a union of simple types
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.25
     */
    type?: JSONSchema6TypeName | JSONSchema6TypeName[] | undefined;

    /**
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.26
     */
    allOf?: JSONSchema6Definition[] | undefined;

    /**
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.27
     */
    anyOf?: JSONSchema6Definition[] | undefined;

    /**
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.28
     */
    oneOf?: JSONSchema6Definition[] | undefined;

    /**
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.29
     */
    not?: JSONSchema6Definition | undefined;

    /**
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.1
     */
    definitions?: {
        [k: string]: JSONSchema6Definition;
    } | undefined;

    /**
     * This attribute is a string that provides a short description of the instance property.
     *
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.2
     */
    title?: string | undefined;

    /**
     * This attribute is a string that provides a full description of the of purpose the instance property.
     *
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.2
     */
    description?: string | undefined;

    /**
     * This keyword can be used to supply a default JSON value associated with a particular schema.
     * It is RECOMMENDED that a default value be valid against the associated schema.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.3
     */
    default?: JSONSchema6Type | undefined;

    /**
     * Array of examples with no validation effect the value of "default" is usable as an example without repeating it under this keyword
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.4
     */
    examples?: JSONSchema6Type[] | undefined;

    /**
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-8
     */
    format?: string | undefined;
}

// ==================================================================================================
// JSON Schema Draft 07
// ==================================================================================================
// https://tools.ietf.org/html/draft-handrews-json-schema-validation-01
// --------------------------------------------------------------------------------------------------

/**
 * Primitive type
 * @see https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-6.1.1
 */
export type JSONSchema7TypeName =
    | "string" //
    | "number"
    | "integer"
    | "boolean"
    | "object"
    | "array"
    | "null";

/**
 * Primitive type
 * @see https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-6.1.1
 */
export type JSONSchema7Type =
    | string //
    | number
    | boolean
    | JSONSchema7Object
    | JSONSchema7Array
    | null;

// Workaround for infinite type recursion
export interface JSONSchema7Object {
    [key: string]: JSONSchema7Type;
}

// Workaround for infinite type recursion
// https://github.com/Microsoft/TypeScript/issues/3496#issuecomment-128553540
export interface JSONSchema7Array extends Array<JSONSchema7Type> {}

/**
 * Meta schema
 *
 * Recommended values:
 * - 'http://json-schema.org/schema#'
 * - 'http://json-schema.org/hyper-schema#'
 * - 'http://json-schema.org/draft-07/schema#'
 * - 'http://json-schema.org/draft-07/hyper-schema#'
 *
 * @see https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-5
 */
export type JSONSchema7Version = string;

/**
 * JSON Schema v7
 * @see https://tools.ietf.org/html/draft-handrews-json-schema-validation-01
 */
export type JSONSchema7Definition = JSONSchema7 | boolean;
export interface JSONSchema7 {
    $id?: string | undefined;
    $ref?: string | undefined;
    $schema?: JSONSchema7Version | undefined;
    $comment?: string | undefined;

    /**
     * @see https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-00#section-8.2.4
     * @see https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-00#appendix-A
     */
    $defs?: {
        [key: string]: JSONSchema7Definition;
    } | undefined;

    /**
     * @see https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-6.1
     */
    type?: JSONSchema7TypeName | JSONSchema7TypeName[] | undefined;
    enum?: JSONSchema7Type[] | undefined;
    const?: JSONSchema7Type | undefined;

    /**
     * @see https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-6.2
     */
    multipleOf?: number | undefined;
    maximum?: number | undefined;
    exclusiveMaximum?: number | undefined;
    minimum?: number | undefined;
    exclusiveMinimum?: number | undefined;

    /**
     * @see https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-6.3
     */
    maxLength?: number | undefined;
    minLength?: number | undefined;
    pattern?: string | undefined;

    /**
     * @see https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-6.4
     */
    items?: JSONSchema7Definition | JSONSchema7Definition[] | undefined;
    additionalItems?: JSONSchema7Definition | undefined;
    maxItems?: number | undefined;
    minItems?: number | undefined;
    uniqueItems?: boolean | undefined;
    contains?: JSONSchema7Definition | undefined;

    /**
     * @see https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-6.5
     */
    maxProperties?: number | undefined;
    minProperties?: number | undefined;
    required?: string[] | undefined;
    properties?: {
        [key: string]: JSONSchema7Definition;
    } | undefined;
    patternProperties?: {
        [key: string]: JSONSchema7Definition;
    } | undefined;
    additionalProperties?: JSONSchema7Definition | undefined;
    dependencies?: {
        [key: string]: JSONSchema7Definition | string[];
    } | undefined;
    propertyNames?: JSONSchema7Definition | undefined;

    /**
     * @see https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-6.6
     */
    if?: JSONSchema7Definition | undefined;
    then?: JSONSchema7Definition | undefined;
    else?: JSONSchema7Definition | undefined;

    /**
     * @see https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-6.7
     */
    allOf?: JSONSchema7Definition[] | undefined;
    anyOf?: JSONSchema7Definition[] | undefined;
    oneOf?: JSONSchema7Definition[] | undefined;
    not?: JSONSchema7Definition | undefined;

    /**
     * @see https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-7
     */
    format?: string | undefined;

    /**
     * @see https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-8
     */
    contentMediaType?: string | undefined;
    contentEncoding?: string | undefined;

    /**
     * @see https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-9
     */
    definitions?: {
        [key: string]: JSONSchema7Definition;
    } | undefined;

    /**
     * @see https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-10
     */
    title?: string | undefined;
    description?: string | undefined;
    default?: JSONSchema7Type | undefined;
    readOnly?: boolean | undefined;
    writeOnly?: boolean | undefined;
    examples?: JSONSchema7Type | undefined;
}

export interface ValidationResult {
    valid: boolean;
    errors: ValidationError[];
}

export interface ValidationError {
    property: string;
    message: string;
}

/**
 * To use the validator call JSONSchema.validate with an instance object and an optional schema object.
 * If a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),
 * that schema will be used to validate and the schema parameter is not necessary (if both exist,
 * both validations will occur).
 */
export function validate(instance: {}, schema: JSONSchema4 | JSONSchema6 | JSONSchema7): ValidationResult;

/**
 * The checkPropertyChange method will check to see if an value can legally be in property with the given schema
 * This is slightly different than the validate method in that it will fail if the schema is readonly and it will
 * not check for self-validation, it is assumed that the passed in value is already internally valid.
 */
export function checkPropertyChange(
    value: any,
    schema: JSONSchema4 | JSONSchema6 | JSONSchema7,
    property: string,
): ValidationResult;

/**
 * This checks to ensure that the result is valid and will throw an appropriate error message if it is not.
 */
export function mustBeValid(result: ValidationResult): void;
    MIT License

    Copyright (c) Microsoft Corporation.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE
{
    "name": "@types/json-schema",
    "version": "7.0.15",
    "description": "TypeScript definitions for json-schema",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/json-schema",
    "license": "MIT",
    "contributors": [
        {
            "name": "Boris Cherny",
            "githubUsername": "bcherny",
            "url": "https://github.com/bcherny"
        },
        {
            "name": "Lucian Buzzo",
            "githubUsername": "lucianbuzzo",
            "url": "https://github.com/lucianbuzzo"
        },
        {
            "name": "Roland Groza",
            "githubUsername": "rolandjitsu",
            "url": "https://github.com/rolandjitsu"
        },
        {
            "name": "Jason Kwok",
            "githubUsername": "JasonHK",
            "url": "https://github.com/JasonHK"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/json-schema"
    },
    "scripts": {},
    "dependencies": {},
    "typesPublisherContentHash": "79984fd70cd25c3f7d72b84368778c763c89728ea0073832d745d4691b705257",
    "typeScriptVersion": "4.5"
}# Installation
> `npm install --save @types/json-schema`

# Summary
This package contains type definitions for json-schema (https://github.com/kriszyp/json-schema).

# Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/json-schema.

### Additional Details
 * Last updated: Tue, 07 Nov 2023 03:09:37 GMT
 * Dependencies: none

# Credits
These definitions were written by [Boris Cherny](https://github.com/bcherny), [Lucian Buzzo](https://github.com/lucianbuzzo), [Roland Groza](https://github.com/rolandjitsu), and [Jason Kwok](https://github.com/JasonHK).
// Type definitions for lodash.set 4.3
// Project: https://lodash.com
// Definitions by: Brian Zengel <https://github.com/bczengel>
//                 Ilya Mochalov <https://github.com/chrootsu>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
// TypeScript Version: 2.8

// Generated from https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/lodash/scripts/generate-modules.ts

import { set } from "lodash";
export = set;
    MIT License

    Copyright (c) Microsoft Corporation.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE
{
    "name": "@types/lodash.set",
    "version": "4.3.7",
    "description": "TypeScript definitions for lodash.set",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/lodash.set",
    "license": "MIT",
    "contributors": [
        {
            "name": "Brian Zengel",
            "url": "https://github.com/bczengel",
            "githubUsername": "bczengel"
        },
        {
            "name": "Ilya Mochalov",
            "url": "https://github.com/chrootsu",
            "githubUsername": "chrootsu"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/lodash.set"
    },
    "scripts": {},
    "dependencies": {
        "@types/lodash": "*"
    },
    "typesPublisherContentHash": "4835ab85503160fd01e68041c1479511722bbb5270c80600a04d1f55fe230e4b",
    "typeScriptVersion": "3.9"
}# Installation
> `npm install --save @types/lodash.set`

# Summary
This package contains type definitions for lodash.set (https://lodash.com).

# Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/lodash.set.
## [index.d.ts](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/lodash.set/index.d.ts)
````ts
// Type definitions for lodash.set 4.3
// Project: https://lodash.com
// Definitions by: Brian Zengel <https://github.com/bczengel>
//                 Ilya Mochalov <https://github.com/chrootsu>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
// TypeScript Version: 2.8

// Generated from https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/lodash/scripts/generate-modules.ts

import { set } from "lodash";
export = set;

````

### Additional Details
 * Last updated: Mon, 18 Apr 2022 23:03:33 GMT
 * Dependencies: [@types/lodash](https://npmjs.com/package/@types/lodash)
 * Global values: none

# Credits
These definitions were written by [Brian Zengel](https://github.com/bczengel), and [Ilya Mochalov](https://github.com/chrootsu).
import { add } from "./index";
export = add;
import { after } from "./index";
export = after;
import { ary } from "./index";
export = ary;
import { assign } from "./index";
export = assign;
import { assignIn } from "./index";
export = assignIn;
import { assignInWith } from "./index";
export = assignInWith;
import { assignWith } from "./index";
export = assignWith;
import { at } from "./index";
export = at;
import { attempt } from "./index";
export = attempt;
import { before } from "./index";
export = before;
import { bind } from "./index";
export = bind;
import { bindAll } from "./index";
export = bindAll;
import { bindKey } from "./index";
export = bindKey;
import { camelCase } from "./index";
export = camelCase;
import { capitalize } from "./index";
export = capitalize;
import { castArray } from "./index";
export = castArray;
import { ceil } from "./index";
export = ceil;
import { chain } from "./index";
export = chain;
import { chunk } from "./index";
export = chunk;
import { clamp } from "./index";
export = clamp;
import { clone } from "./index";
export = clone;
import { cloneDeep } from "./index";
export = cloneDeep;
import { cloneDeepWith } from "./index";
export = cloneDeepWith;
import { cloneWith } from "./index";
export = cloneWith;
import _ = require("../index");
declare module "../index" {
    interface LoDashStatic {
        /**
         * Creates an array of elements split into groups the length of size. If collection can’t be split evenly, the
         * final chunk will be the remaining elements.
         *
         * @param array The array to process.
         * @param size The length of each chunk.
         * @return Returns the new array containing chunks.
         */
        chunk<T>(array: List<T> | null | undefined, size?: number): T[][];
    }
    interface Collection<T> {
        /**
         * @see _.chunk
         */
        chunk(size?: number): Collection<T[]>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.chunk
         */
        chunk(size?: number): CollectionChain<T[]>;
    }
    interface LoDashStatic {
        /**
         * Creates an array with all falsey values removed. The values false, null, 0, 0n, "", undefined, and NaN are
         * falsey.
         *
         * @param array The array to compact.
         * @return Returns the new array of filtered values.
         */
        compact<T>(array: List<T | Falsey> | null | undefined): T[];
    }

    type Falsey = null | undefined | false | "" | 0 | 0n;
    type Truthy<T> = T extends Falsey ? never : T;
    interface Collection<T> {
        /**
         * @see _.compact
         */
        compact(): Collection<Truthy<T>>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.compact
         */
        compact(): CollectionChain<Truthy<T>>;
    }
    interface LoDashStatic {
        /**
         * Creates a new array concatenating `array` with any additional arrays
         * and/or values.
         *
         * @category Array
         * @param [values] The array values to concatenate.
         * @returns Returns the new concatenated array.
         * @example
         *
         * var array = [1];
         * var other = _.concat(array, 2, [3], [[4]]);
         *
         * console.log(other);
         * // => [1, 2, 3, [4]]
         *
         * console.log(array);
         * // => [1]
         */
         concat<T>(...values: Array<Many<T>>): T[];
    }
    interface Primitive<T> {
        /**
         * @see _.concat
         */
        concat(...values: Array<Many<T>>): Collection<T>;
    }
    interface Collection<T> {
        /**
         * @see _.concat
         */
        concat(...values: Array<Many<T>>): Collection<T>;
    }
    interface Object<T> {
        /**
         * @see _.concat
         */
        concat(...values: Array<Many<T>>): Collection<T>;
    }
    interface PrimitiveChain<T> {
        /**
         * @see _.concat
         */
        concat(...values: Array<Many<T>>): CollectionChain<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.concat
         */
        concat(...values: Array<Many<T>>): CollectionChain<T>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.concat
         */
        concat(...values: Array<Many<T>>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Creates an array of `array` values not included in the other provided arrays using SameValueZero for
         * equality comparisons. The order and references of result values are determined by the first array.
         *
         * @param array The array to inspect.
         * @param values The arrays of values to exclude.
         * @return Returns the new array of filtered values.
         */
        difference<T>(array: List<T> | null | undefined, ...values: Array<List<T>>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.difference
         */
        difference(...values: Array<List<T>>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.difference
         */
        difference(...values: Array<List<T>>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * This method is like _.difference except that it accepts iteratee which is invoked for each element
         * of array and values to generate the criterion by which they're compared. The order and references
         * of result values are determined by the first array. The iteratee is invoked with one argument: (value).
         *
         * @param array The array to inspect.
         * @param values The values to exclude.
         * @param iteratee The iteratee invoked per element.
         * @returns Returns the new array of filtered values.
         */
        differenceBy<T1, T2>(array: List<T1> | null | undefined, values: List<T2>, iteratee: ValueIteratee<T1 | T2>): T1[];
        /**
         * @see _.differenceBy
         */
        differenceBy<T1, T2, T3>(array: List<T1> | null | undefined, values1: List<T2>, values2: List<T3>, iteratee: ValueIteratee<T1 | T2 | T3>): T1[];
        /**
         * @see _.differenceBy
         */
        differenceBy<T1, T2, T3, T4>(array: List<T1> | null | undefined, values1: List<T2>, values2: List<T3>, values3: List<T4>, iteratee: ValueIteratee<T1 | T2 | T3 | T4>): T1[];
        /**
         * @see _.differenceBy
         */
        differenceBy<T1, T2, T3, T4, T5>(array: List<T1> | null | undefined, values1: List<T2>, values2: List<T3>, values3: List<T4>, values4: List<T5>, iteratee: ValueIteratee<T1 | T2 | T3 | T4 | T5>): T1[];
        /**
         * @see _.differenceBy
         */
        differenceBy<T1, T2, T3, T4, T5, T6>(array: List<T1> | null | undefined, values1: List<T2>, values2: List<T3>, values3: List<T4>, values4: List<T5>, values5: List<T6>, iteratee: ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6>): T1[];
        /**
         * @see _.differenceBy
         */
        differenceBy<T1, T2, T3, T4, T5, T6, T7>(array: List<T1> | null | undefined, values1: List<T2>, values2: List<T3>, values3: List<T4>, values4: List<T5>, values5: List<T6>, ...values: Array<List<T7> | ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6 | T7>>): T1[];
        /**
         * @see _.differenceBy
         */
        differenceBy<T>(array: List<T> | null | undefined, ...values: Array<List<T>>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.differenceBy
         */
        differenceBy<T2>(values1: List<T2>, iteratee?: ValueIteratee<T | T2>): Collection<T>;
        /**
         * @see _.differenceBy
         */
        differenceBy(...values: Array<List<unknown> | ValueIteratee<T>>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.differenceBy
         */
        differenceBy<T2>(values1: List<T2>, iteratee?: ValueIteratee<T | T2>): CollectionChain<T>;
        /**
         * @see _.differenceBy
         */
        differenceBy(...values: Array<List<unknown> | ValueIteratee<T>>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * This method is like _.difference except that it accepts comparator which is invoked to compare elements
         * of array to values. The order and references of result values are determined by the first array. The
         * comparator is invoked with two arguments: (arrVal, othVal).
         *
         * @category Array
         * @param [values] The arrays to inspect.
         * @param [comparator] The comparator invoked per element.
         * @returns Returns the new array of filtered values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];

         * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
         * // => [{ 'x': 2, 'y': 1 }]
         */
        differenceWith<T1, T2>(array: List<T1> | null | undefined, values: List<T2>, comparator: Comparator2<T1, T2>): T1[];
        /**
         * @see _.differenceWith
         */
        differenceWith<T1, T2, T3>(array: List<T1> | null | undefined, values1: List<T2>, values2: List<T3>, comparator: Comparator2<T1, T2 | T3>): T1[];
        /**
         * @see _.differenceWith
         */
        differenceWith<T1, T2, T3, T4>(array: List<T1> | null | undefined, values1: List<T2>, values2: List<T3>, ...values: Array<List<T4> | Comparator2<T1, T2 | T3 | T4>>): T1[];
        /**
         * @see _.differenceWith
         */
        differenceWith<T>(array: List<T> | null | undefined, ...values: Array<List<T>>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.differenceWith
         */
        differenceWith<T2>(values: List<T2>, comparator: Comparator2<T, T2>): Collection<T>;
        /**
         * @see _.differenceWith
         */
        differenceWith<T2, T3, T4>(...values: Array<List<unknown> | Comparator2<T, never>>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.differenceWith
         */
        differenceWith< T2>(values: List<T2>, comparator: Comparator2<T, T2>): CollectionChain<T>;
        /**
         * @see _.differenceWith
         */
        differenceWith< T2, T3, T4>(...values: Array<List<unknown> | Comparator2<T, never>>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Creates a slice of array with n elements dropped from the beginning.
         *
         * @param array The array to query.
         * @param n The number of elements to drop.
         * @return Returns the slice of array.
         */
        drop<T>(array: List<T> | null | undefined, n?: number): T[];
    }
    interface Collection<T> {
        /**
         * @see _.drop
         */
        drop(n?: number): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.drop
         */
        drop(n?: number): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Creates a slice of array with n elements dropped from the end.
         *
         * @param array The array to query.
         * @param n The number of elements to drop.
         * @return Returns the slice of array.
         */
        dropRight<T>(array: List<T> | null | undefined, n?: number): T[];
    }
    interface Collection<T> {
        /**
         * @see _.dropRight
         */
        dropRight(n?: number): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.dropRight
         */
        dropRight(n?: number): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Creates a slice of array excluding elements dropped from the end. Elements are dropped until predicate
         * returns falsey. The predicate is invoked with three arguments: (value, index, array).
         *
         * @param array The array to query.
         * @param predicate The function invoked per iteration.
         * @return Returns the slice of array.
         */
        dropRightWhile<T>(array: List<T> | null | undefined, predicate?: ListIteratee<T>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.dropRightWhile
         */
        dropRightWhile(predicate?: ListIteratee<T>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.dropRightWhile
         */
        dropRightWhile(predicate?: ListIteratee<T>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Creates a slice of array excluding elements dropped from the beginning. Elements are dropped until predicate
         * returns falsey. The predicate is invoked with three arguments: (value, index, array).
         *
         * @param array The array to query.
         * @param predicate The function invoked per iteration.
         * @return Returns the slice of array.
         */
        dropWhile<T>(array: List<T> | null | undefined, predicate?: ListIteratee<T>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.dropWhile
         */
        dropWhile(predicate?: ListIteratee<T>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.dropWhile
         */
        dropWhile(predicate?: ListIteratee<T>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Fills elements of array with value from start up to, but not including, end.
         *
         * Note: This method mutates array.
         *
         * @param array The array to fill.
         * @param value The value to fill array with.
         * @param start The start position.
         * @param end The end position.
         * @return Returns array.
         */
        fill<T>(array: any[] | null | undefined, value: T): T[];
        /**
         * @see _.fill
         */
        fill<T>(array: List<any> | null | undefined, value: T): List<T>;
        /**
         * @see _.fill
         */
        fill<T, U>(array: U[] | null | undefined, value: T, start?: number, end?: number): Array<T | U>;
        /**
         * @see _.fill
         */
        fill<T, U>(array: List<U> | null | undefined, value: T, start?: number, end?: number): List<T | U>;
    }
    interface Collection<T> {
        /**
         * @see _.fill
         */
        fill<U>(value: U, start?: number, end?: number): Collection<T | U>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.fill
         */
        fill<U>(value: U, start?: number, end?: number): CollectionChain<T | U>;
    }
    interface LoDashStatic {
        /**
         * This method is like _.find except that it returns the index of the first element predicate returns truthy
         * for instead of the element itself.
         *
         * @param array The array to search.
         * @param predicate The function invoked per iteration.
         * @param fromIndex The index to search from.
         * @return Returns the index of the found element, else -1.
         */
        findIndex<T>(array: List<T> | null | undefined, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): number;
    }
    interface Collection<T> {
        /**
         * @see _.findIndex
         */
        findIndex(predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): number;
    }
    interface CollectionChain<T> {
        /**
         * @see _.findIndex
         */
        findIndex(predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): PrimitiveChain<number>;
    }
    interface LoDashStatic {
        /**
         * This method is like _.findIndex except that it iterates over elements of collection from right to left.
         *
         * @param array The array to search.
         * @param predicate The function invoked per iteration.
         * @param fromIndex The index to search from.
         * @return Returns the index of the found element, else -1.
         */
        findLastIndex<T>(array: List<T> | null | undefined, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): number;
    }
    interface Collection<T> {
        /**
         * @see _.findLastIndex
         */
        findLastIndex(predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): number;
    }
    interface CollectionChain<T> {
        /**
         * @see _.findLastIndex
         */
        findLastIndex(predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): PrimitiveChain<number>;
    }
    interface LoDashStatic {
        /**
         * @see _.head
         */
        first: LoDashStatic["head"];
    }
    interface String {
        /**
         * @see _.first
         */
        first(): string | undefined;
    }
    interface StringChain {
        /**
         * @see _.first
         */
        first(): StringNullableChain;
    }
    interface StringNullableChain {
        /**
         * @see _.first
         */
        first(): StringNullableChain;
    }
    interface Collection<T> {
        /**
         * @see _.first
         */
        first(): T | undefined;
    }
    interface CollectionChain<T> {
        /**
         * @see _.first
         */
        first(): ExpChain<T | undefined>;
    }
    interface RecursiveArray<T> extends Array<T|RecursiveArray<T>> {}
    interface ListOfRecursiveArraysOrValues<T> extends List<T|RecursiveArray<T>> {}
    interface LoDashStatic {
        /**
         * Flattens `array` a single level deep.
         *
         * @param array The array to flatten.
         * @return Returns the new flattened array.
         */
        flatten<T>(array: List<Many<T>> | null | undefined): T[];
    }
    interface String {
        /**
         * @see _.flatten
         */
        flatten(): Collection<string>;
    }
    interface StringChain {
        /**
         * @see _.flatten
         */
        flatten(): CollectionChain<string>;
    }
    interface StringNullableChain {
        /**
         * @see _.flatten
         */
        flatten(): CollectionChain<string>;
    }
    interface Collection<T> {
        /**
         * @see _.flatten
         */
        flatten(): T extends Many<infer U> ? Collection<U> : Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.flatten
         */
        flatten(): T extends Many<infer U> ? CollectionChain<U> : CollectionChain<T>;
    }

    type Flat<T> = T extends string ? T : (T extends List<any> ? never : T);

    interface LoDashStatic {
        /**
         * Recursively flattens a nested array.
         *
         * @param array The array to recursively flatten.
         * @return Returns the new flattened array.
         */
        flattenDeep<T>(array: ListOfRecursiveArraysOrValues<T> | null | undefined): Array<Flat<T>>;
    }
    interface Collection<T> {
        /**
         * @see _.flattenDeep
         */
        flattenDeep(): T extends ListOfRecursiveArraysOrValues<infer U> ? Collection<Flat<U>> : Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.flattenDeep
         */
        flattenDeep(): T extends ListOfRecursiveArraysOrValues<infer U> ? CollectionChain<Flat<U>> : CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Recursively flatten array up to depth times.
         *
         * @param array The array to recursively flatten.
         * @param number The maximum recursion depth.
         * @return Returns the new flattened array.
         */
        flattenDepth<T>(array: ListOfRecursiveArraysOrValues<T> | null | undefined, depth?: number): T[];
    }
    interface Collection<T> {
        /**
         * @see _.flattenDepth
         */
        flattenDepth(depth?: number): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.flattenDepth
         */
        flattenDepth(depth?: number): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * The inverse of `_.toPairs`; this method returns an object composed
         * from key-value `pairs`.
         *
         * @category Array
         * @param pairs The key-value pairs.
         * @returns Returns the new object.
         * @example
         *
         * _.fromPairs([['fred', 30], ['barney', 40]]);
         * // => { 'fred': 30, 'barney': 40 }
         */
        fromPairs<T>(pairs: List<[PropertyName, T]> | null | undefined): Dictionary<T>;
        /**
         * @see _.fromPairs
         */
        fromPairs(pairs: List<any[]> | null | undefined): Dictionary<any>;
    }
    interface Collection<T> {
        /**
         * @see _.fromPairs
         */
        fromPairs(): Object<Dictionary<T extends [PropertyName, infer U] ? U : any>>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.fromPairs
         */
        fromPairs(): ObjectChain<Dictionary<T extends [PropertyName, infer U] ? U : any>>;
    }
    interface LoDashStatic {
        /**
         * Gets the first element of array.
         *
         * @alias _.first
         *
         * @param array The array to query.
         * @return Returns the first element of array.
         */
        head<T>(array: List<T> | null | undefined): T | undefined;
    }
    interface String {
        /**
         * @see _.head
         */
        head(): string | undefined;
    }
    interface StringChain {
        /**
         * @see _.head
         */
        head(): StringNullableChain;
    }
    interface StringNullableChain {
        /**
         * @see _.head
         */
        head(): StringNullableChain;
    }
    interface Collection<T> {
        /**
         * @see _.head
         */
        head(): T | undefined;
    }
    interface CollectionChain<T> {
        /**
         * @see _.head
         */
        head(): ExpChain<T | undefined>;
    }
    interface LoDashStatic {
        /**
         * Gets the index at which the first occurrence of `value` is found in `array`
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons. If `fromIndex` is negative, it's used as the offset
         * from the end of `array`.
         *
         * @category Array
         * @param array The array to search.
         * @param value The value to search for.
         * @param [fromIndex=0] The index to search from.
         * @returns Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.indexOf([1, 2, 1, 2], 2);
         * // => 1
         *
         * // using `fromIndex`
         * _.indexOf([1, 2, 1, 2], 2, 2);
         * // => 3
         */
        indexOf<T>(array: List<T> | null | undefined, value: T, fromIndex?: number): number;
    }
    interface Collection<T> {
        /**
         * @see _.indexOf
         */
        indexOf(value: T, fromIndex?: number): number;
    }
    interface CollectionChain<T> {
        /**
         * @see _.indexOf
         */
        indexOf(value: T, fromIndex?: number): PrimitiveChain<number>;
    }
    interface LoDashStatic {
        /**
         * Gets all but the last element of array.
         *
         * @param array The array to query.
         * @return Returns the slice of array.
         */
        initial<T>(array: List<T> | null | undefined): T[];
    }
    interface Collection<T> {
        /**
         * @see _.initial
         */
        initial(): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.initial
         */
        initial(): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Creates an array of unique values that are included in all of the provided arrays using SameValueZero for
         * equality comparisons.
         *
         * @param arrays The arrays to inspect.
         * @return Returns the new array of shared values.
         */
        intersection<T>(...arrays: Array<List<T> | null | undefined>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.intersection
         */
        intersection(...arrays: Array<List<T> | null | undefined>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.intersection
         */
        intersection(...arrays: Array<List<T> | null | undefined>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.intersection` except that it accepts `iteratee`
         * which is invoked for each element of each `arrays` to generate the criterion
         * by which uniqueness is computed. The iteratee is invoked with one argument: (value).
         *
         * @category Array
         * @param [arrays] The arrays to inspect.
         * @param [iteratee=_.identity] The iteratee invoked per element.
         * @returns Returns the new array of shared values.
         * @example
         *
         * _.intersectionBy([2.1, 1.2], [4.3, 2.4], Math.floor);
         * // => [2.1]
         *
         * // using the `_.property` iteratee shorthand
         * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }]
         */
        intersectionBy<T1, T2>(array: List<T1> | null, values: List<T2>, iteratee: ValueIteratee<T1 | T2>): T1[];
        /**
         * @see _.intersectionBy
         */
        intersectionBy<T1, T2, T3>(array: List<T1> | null, values1: List<T2>, values2: List<T3>, iteratee: ValueIteratee<T1 | T2 | T3>): T1[];
        /**
         * @see _.intersectionBy
         */
        intersectionBy<T1, T2, T3, T4>(array: List<T1> | null | undefined, values1: List<T2>, values2: List<T3>, ...values: Array<List<T4> | ValueIteratee<T1 | T2 | T3 | T4>>): T1[];
        /**
         * @see _.intersectionBy
         */
        intersectionBy<T>(array?: List<T> | null, ...values: Array<List<T>>): T[];
        /**
         * @see _.intersectionBy
         */
        intersectionBy<T>(...values: Array<List<T> | ValueIteratee<T>>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.intersectionBy
         */
        intersectionBy<T2>(values: List<T2>, iteratee: ValueIteratee<T | T2>): Collection<T>;
        /**
         * @see _.intersectionBy
         */
        intersectionBy(...values: Array<List<unknown> | ValueIteratee<T>>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.intersectionBy
         */
        intersectionBy<T2>(values: List<T2>, iteratee: ValueIteratee<T | T2>): CollectionChain<T>;
        /**
         * @see _.intersectionBy
         */
        intersectionBy(...values: Array<List<unknown> | ValueIteratee<T>>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Creates an array of unique `array` values not included in the other
         * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @category Array
         * @param [values] The arrays to inspect.
         * @param [comparator] The comparator invoked per element.
         * @returns Returns the new array of filtered values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];

         * _.intersectionWith(objects, others, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }]
         */
        intersectionWith<T1, T2>(array: List<T1> | null | undefined, values: List<T2>, comparator: Comparator2<T1, T2>): T1[];
        /**
         * @see _.intersectionWith
         */
        intersectionWith<T1, T2, T3>(array: List<T1> | null | undefined, values1: List<T2>, values2: List<T3>, comparator: Comparator2<T1, T2 | T3>): T1[];
        /**
         * @see _.intersectionWith
         */
        intersectionWith<T1, T2, T3, T4>(array: List<T1> | null | undefined, values1: List<T2>, values2: List<T3>, ...values: Array<List<T4> | Comparator2<T1, T2 | T3 | T4>>): T1[];
        /**
         * @see _.intersectionWith
         */
        intersectionWith<T>(array?: List<T> | null, ...values: Array<List<T> | Comparator2<T, never>>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.intersectionWith
         */
        intersectionWith<T2>(values: List<T2>, comparator: Comparator2<T, T2>): Collection<T>;
        /**
         * @see _.intersectionWith
         */
        intersectionWith(...values: Array<List<unknown> | Comparator2<T,  never>>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.intersectionWith
         */
        intersectionWith<T2>(values: List<T2>, comparator: Comparator2<T, T2>): CollectionChain<T>;
        /**
         * @see _.intersectionWith
         */
        intersectionWith(...values: Array<List<unknown> | Comparator2<T,  never>>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Converts all elements in `array` into a string separated by `separator`.
         *
         * @param array The array to convert.
         * @param separator The element separator.
         * @returns Returns the joined string.
         */
        join(array: List<any> | null | undefined, separator?: string): string;
    }
    interface String {
        /**
         * @see _.join
         */
        join(separator?: string): string;
    }
    interface StringChain {
        /**
         * @see _.join
         */
        join(separator?: string): StringChain;
    }
    interface StringNullableChain {
        /**
         * @see _.join
         */
        join(separator?: string): StringChain;
    }
    interface Collection<T> {
        /**
         * @see _.join
         */
        join(separator?: string): string;
    }
    interface CollectionChain<T> {
        /**
         * @see _.join
         */
        join(separator?: string): StringChain;
    }
    interface LoDashStatic {
        /**
         * Gets the last element of array.
         *
         * @param array The array to query.
         * @return Returns the last element of array.
         */
        last<T>(array: List<T> | null | undefined): T | undefined;
    }
    interface Collection<T> {
        /**
         * @see _.last
         */
        last(): T | undefined;
    }
    interface CollectionChain<T> {
        /**
         * @see _.last
         */
        last(): ExpChain<T | undefined>;
    }
    interface String {
        /**
         * @see _.last
         */
        last(): string | undefined;
    }
    interface StringChain {
        /**
         * @see _.last
         */
        last(): StringNullableChain;
    }
    interface StringNullableChain {
        /**
         * @see _.last
         */
        last(): StringNullableChain;
    }
    interface LoDashStatic {
        /**
         * This method is like _.indexOf except that it iterates over elements of array from right to left.
         *
         * @param array The array to search.
         * @param value The value to search for.
         * @param fromIndex The index to search from or true to perform a binary search on a sorted array.
         * @return Returns the index of the matched value, else -1.
         */
        lastIndexOf<T>(array: List<T> | null | undefined, value: T, fromIndex?: true|number): number;
    }
    interface Collection<T> {
        /**
         * @see _.lastIndexOf
         */
        lastIndexOf(value: T, fromIndex?: true|number): number;
    }
    interface CollectionChain<T> {
        /**
         * @see _.lastIndexOf
         */
        lastIndexOf(value: T, fromIndex?: true|number): PrimitiveChain<number>;
    }
    interface LoDashStatic {
        /**
         * Gets the element at index `n` of `array`. If `n` is negative, the nth element from the end is returned.
         *
         * @param array array The array to query.
         * @param value The index of the element to return.
         * @return Returns the nth element of `array`.
         */
        nth<T>(array: List<T> | null | undefined, n?: number): T | undefined;
    }
    interface Collection<T> {
        /**
         * @see _.nth
         */
        nth(n?: number): T | undefined;
    }
    interface CollectionChain<T> {
        /**
         * @see _.nth
         */
        nth(n?: number): ExpChain<T | undefined>;
    }
    interface LoDashStatic {
        /**
         * Removes all provided values from array using SameValueZero for equality comparisons.
         *
         * Note: Unlike _.without, this method mutates array.
         *
         * @param array The array to modify.
         * @param values The values to remove.
         * @return Returns array.
         */
        pull<T>(array: T[], ...values: T[]): T[];
        /**
         * @see _.pull
         */
        pull<T>(array: List<T>, ...values: T[]): List<T>;
    }
    interface Collection<T> {
        /**
         * @see _.pull
         */
        pull(...values: T[]): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.pull
         */
        pull(...values: T[]): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.pull` except that it accepts an array of values to remove.
         *
         * **Note:** Unlike `_.difference`, this method mutates `array`.
         *
         * @category Array
         * @param array The array to modify.
         * @param values The values to remove.
         * @returns Returns `array`.
         * @example
         *
         * var array = [1, 2, 3, 1, 2, 3];
         *
         * _.pull(array, [2, 3]);
         * console.log(array);
         * // => [1, 1]
         */
        pullAll<T>(array: T[], values?: List<T>): T[];
        /**
         * @see _.pullAll
         */
        pullAll<T>(array: List<T>, values?: List<T>): List<T>;
    }
    interface Collection<T> {
        /**
         * @see _.pullAll
         */
        pullAll(values?: List<T>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.pullAll
         */
        pullAll(values?: List<T>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.pullAll` except that it accepts `iteratee` which is
         * invoked for each element of `array` and `values` to to generate the criterion
         * by which uniqueness is computed. The iteratee is invoked with one argument: (value).
         *
         * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
         *
         * @category Array
         * @param array The array to modify.
         * @param values The values to remove.
         * @param [iteratee=_.identity] The iteratee invoked per element.
         * @returns Returns `array`.
         * @example
         *
         * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
         *
         * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
         * console.log(array);
         * // => [{ 'x': 2 }]
         */
        pullAllBy<T>(array: T[], values?: List<T>, iteratee?: ValueIteratee<T>): T[];
        /**
         * @see _.pullAllBy
         */
        pullAllBy<T>(array: List<T>, values?: List<T>, iteratee?: ValueIteratee<T>): List<T>;
        /**
         * @see _.pullAllBy
         */
        pullAllBy<T1, T2>(array: T1[], values: List<T2>, iteratee: ValueIteratee<T1 | T2>): T1[];
        /**
         * @see _.pullAllBy
         */
        pullAllBy<T1, T2>(array: List<T1>, values: List<T2>, iteratee: ValueIteratee<T1 | T2>): List<T1>;
    }
    interface Collection<T> {
        /**
         * @see _.pullAllBy
         */
        pullAllBy<T2>(values?: List<T2>, iteratee?: ValueIteratee<T | T2>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.pullAllBy
         */
        pullAllBy<T2>(values?: List<T2>, iteratee?: ValueIteratee<T | T2>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.pullAll` except that it accepts `comparator` which is
         * invoked to compare elements of array to values. The comparator is invoked with
         * two arguments: (arrVal, othVal).
         *
         * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
         *
         * @category Array
         * @param array The array to modify.
         * @param values The values to remove.
         * @param [iteratee=_.identity] The iteratee invoked per element.
         * @returns Returns `array`.
         * @example
         *
         * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
         *
         * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
         * console.log(array);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
         */
        pullAllWith<T>(array: T[], values?: List<T>, comparator?: Comparator<T>): T[];
        /**
         * @see _.pullAllWith
         */
        pullAllWith<T>(array: List<T>, values?: List<T>, comparator?: Comparator<T>): List<T>;
        /**
         * @see _.pullAllWith
         */
        pullAllWith<T1, T2>(array: T1[], values: List<T2>, comparator: Comparator2<T1, T2>): T1[];
        /**
         * @see _.pullAllWith
         */
        pullAllWith<T1, T2>(array: List<T1>, values: List<T2>, comparator: Comparator2<T1, T2>): List<T1>;
    }
    interface Collection<T> {
        /**
         * @see _.pullAllWith
         */
        pullAllWith<T2>(values?: List<T2>, comparator?: Comparator2<T, T2>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.pullAllWith
         */
        pullAllWith<T2>(values?: List<T2>, comparator?: Comparator2<T, T2>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Removes elements from array corresponding to the given indexes and returns an array of the removed elements.
         * Indexes may be specified as an array of indexes or as individual arguments.
         *
         * Note: Unlike _.at, this method mutates array.
         *
         * @param array The array to modify.
         * @param indexes The indexes of elements to remove, specified as individual indexes or arrays of indexes.
         * @return Returns the new array of removed elements.
         */
        pullAt<T>(array: T[], ...indexes: Array<Many<number>>): T[];
        /**
         * @see _.pullAt
         */
        pullAt<T>(array: List<T>, ...indexes: Array<Many<number>>): List<T>;
    }
    interface Collection<T> {
        /**
         * @see _.pullAt
         */
        pullAt(...indexes: Array<Many<number>>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.pullAt
         */
        pullAt(...indexes: Array<Many<number>>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Removes all elements from array that predicate returns truthy for and returns an array of the removed
         * elements. The predicate is invoked with three arguments: (value, index, array).
         *
         * Note: Unlike _.filter, this method mutates array.
         *
         * @param array The array to modify.
         * @param predicate The function invoked per iteration.
         * @return Returns the new array of removed elements.
         */
        remove<T>(array: List<T>, predicate?: ListIteratee<T>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.remove
         */
        remove(predicate?: ListIteratee<T>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.remove
         */
        remove(predicate?: ListIteratee<T>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Reverses `array` so that the first element becomes the last, the second
         * element becomes the second to last, and so on.
         *
         * **Note:** This method mutates `array` and is based on
         * [`Array#reverse`](https://mdn.io/Array/reverse).
         *
         * @category Array
         * @returns Returns `array`.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _.reverse(array);
         * // => [3, 2, 1]
         *
         * console.log(array);
         * // => [3, 2, 1]
         */
        reverse<TList extends List<any>>(array: TList): TList;
    }
    interface LoDashStatic {
        /**
         * Creates a slice of array from start up to, but not including, end.
         *
         * @param array The array to slice.
         * @param start The start position.
         * @param end The end position.
         * @return Returns the slice of array.
         */
        slice<T>(array: List<T> | null | undefined, start?: number, end?: number): T[];
    }
    interface Collection<T> {
        /**
         * @see _.slice
         */
        slice(start?: number, end?: number): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.slice
         */
        slice(start?: number, end?: number): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Uses a binary search to determine the lowest index at which `value` should
         * be inserted into `array` in order to maintain its sort order.
         *
         * @category Array
         * @param array The sorted array to inspect.
         * @param value The value to evaluate.
         * @returns Returns the index at which `value` should be inserted into `array`.
         * @example
         *
         * _.sortedIndex([30, 50], 40);
         * // => 1
         *
         * _.sortedIndex([4, 5], 4);
         * // => 0
         */
        sortedIndex<T>(array: List<T> | null | undefined, value: T): number;
    }
    interface Collection<T> {
        /**
         * @see _.sortedIndex
         */
        sortedIndex(value: T): number;
    }
    interface CollectionChain<T> {
        /**
         * @see _.sortedIndex
         */
        sortedIndex(value: T): PrimitiveChain<number>;
    }
    interface LoDashStatic {
        /**
         * Uses a binary search to determine the lowest index at which `value` should
         * be inserted into `array` in order to maintain its sort order.
         *
         * @category Array
         * @param array The sorted array to inspect.
         * @param value The value to evaluate.
         * @returns Returns the index at which `value` should be inserted into `array`.
         * @example
         *
         * _.sortedIndex([30, 50], 40);
         * // => 1
         *
         * _.sortedIndex([4, 5], 4);
         * // => 0
         */
        sortedIndex<T>(array: List<T> | null | undefined, value: T): number;
    }
    interface Collection<T> {
        /**
         * @see _.sortedIndex
         */
        sortedIndex(value: T): number;
    }
    interface CollectionChain<T> {
        /**
         * @see _.sortedIndex
         */
        sortedIndex(value: T): PrimitiveChain<number>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.sortedIndex` except that it accepts `iteratee`
         * which is invoked for `value` and each element of `array` to compute their
         * sort ranking. The iteratee is invoked with one argument: (value).
         *
         * @category Array
         * @param array The sorted array to inspect.
         * @param value The value to evaluate.
         * @param [iteratee=_.identity] The iteratee invoked per element.
         * @returns Returns the index at which `value` should be inserted into `array`.
         * @example
         *
         * var dict = { 'thirty': 30, 'forty': 40, 'fifty': 50 };
         *
         * _.sortedIndexBy(['thirty', 'fifty'], 'forty', _.propertyOf(dict));
         * // => 1
         *
         * // using the `_.property` iteratee shorthand
         * _.sortedIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
         * // => 0
         */
        sortedIndexBy<T>(array: List<T> | null | undefined, value: T, iteratee?: ValueIteratee<T>): number;
    }
    interface Collection<T> {
        /**
         * @see _.sortedIndexBy
         */
        sortedIndexBy(value: T, iteratee?: ValueIteratee<T>): number;
    }
    interface CollectionChain<T> {
        /**
         * @see _.sortedIndexBy
         */
        sortedIndexBy(value: T, iteratee?: ValueIteratee<T>): PrimitiveChain<number>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.indexOf` except that it performs a binary
         * search on a sorted `array`.
         *
         * @category Array
         * @param array The array to search.
         * @param value The value to search for.
         * @returns Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.sortedIndexOf([1, 1, 2, 2], 2);
         * // => 2
         */
        sortedIndexOf<T>(array: List<T> | null | undefined, value: T): number;
    }
    interface Collection<T> {
        /**
         * @see _.sortedIndexOf
         */
        sortedIndexOf(value: T): number;
    }
    interface CollectionChain<T> {
        /**
         * @see _.sortedIndexOf
         */
        sortedIndexOf(value: T): PrimitiveChain<number>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.sortedIndex` except that it returns the highest
         * index at which `value` should be inserted into `array` in order to
         * maintain its sort order.
         *
         * @category Array
         * @param array The sorted array to inspect.
         * @param value The value to evaluate.
         * @returns Returns the index at which `value` should be inserted into `array`.
         * @example
         *
         * _.sortedLastIndex([4, 5], 4);
         * // => 1
         */
        sortedLastIndex<T>(array: List<T> | null | undefined, value: T): number;
    }
    interface Collection<T> {
        /**
         * @see _.sortedLastIndex
         */
        sortedLastIndex(value: T): number;
    }
    interface CollectionChain<T> {
        /**
         * @see _.sortedLastIndex
         */
        sortedLastIndex(value: T): PrimitiveChain<number>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
         * which is invoked for `value` and each element of `array` to compute their
         * sort ranking. The iteratee is invoked with one argument: (value).
         *
         * @category Array
         * @param array The sorted array to inspect.
         * @param value The value to evaluate.
         * @param [iteratee=_.identity] The iteratee invoked per element.
         * @returns Returns the index at which `value` should be inserted into `array`.
         * @example
         *
         * // using the `_.property` iteratee shorthand
         * _.sortedLastIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
         * // => 1
         */
        sortedLastIndexBy<T>(array: List<T> | null | undefined, value: T, iteratee: ValueIteratee<T>): number;
    }
    interface Collection<T> {
        /**
         * @see _.sortedLastIndexBy
         */
        sortedLastIndexBy(value: T, iteratee: ValueIteratee<T>): number;
    }
    interface CollectionChain<T> {
        /**
         * @see _.sortedLastIndexBy
         */
        sortedLastIndexBy(value: T, iteratee: ValueIteratee<T>): PrimitiveChain<number>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.lastIndexOf` except that it performs a binary
         * search on a sorted `array`.
         *
         * @category Array
         * @param array The array to search.
         * @param value The value to search for.
         * @returns Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.sortedLastIndexOf([1, 1, 2, 2], 2);
         * // => 3
         */
        sortedLastIndexOf<T>(array: List<T> | null | undefined, value: T): number;
    }
    interface Collection<T> {
        /**
         * @see _.sortedLastIndexOf
         */
        sortedLastIndexOf(value: T): number;
    }
    interface CollectionChain<T> {
        /**
         * @see _.sortedLastIndexOf
         */
        sortedLastIndexOf(value: T): PrimitiveChain<number>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.uniq` except that it's designed and optimized
         * for sorted arrays.
         *
         * @category Array
         * @param array The array to inspect.
         * @returns Returns the new duplicate free array.
         * @example
         *
         * _.sortedUniq([1, 1, 2]);
         * // => [1, 2]
         */
        sortedUniq<T>(array: List<T> | null | undefined): T[];
    }
    interface Collection<T> {
        /**
         * @see _.sortedUniq
         */
        sortedUniq(): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.sortedUniq
         */
        sortedUniq(): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.uniqBy` except that it's designed and optimized
         * for sorted arrays.
         *
         * @category Array
         * @param array The array to inspect.
         * @param [iteratee] The iteratee invoked per element.
         * @returns Returns the new duplicate free array.
         * @example
         *
         * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
         * // => [1.1, 2.3]
         */
        sortedUniqBy<T>(array: List<T> | null | undefined, iteratee: ValueIteratee<T>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.sortedUniqBy
         */
        sortedUniqBy(iteratee: ValueIteratee<T>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.sortedUniqBy
         */
        sortedUniqBy(iteratee: ValueIteratee<T>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Gets all but the first element of array.
         *
         * @param array The array to query.
         * @return Returns the slice of array.
         */
        tail<T>(array: List<T> | null | undefined): T[];
    }
    interface Collection<T> {
        /**
         * @see _.tail
         */
        tail(): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.tail
         */
        tail(): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Creates a slice of array with n elements taken from the beginning.
         *
         * @param array The array to query.
         * @param n The number of elements to take.
         * @return Returns the slice of array.
         */
        take<T>(array: List<T> | null | undefined, n?: number): T[];
    }
    interface Collection<T> {
        /**
         * @see _.take
         */
        take(n?: number): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.take
         */
        take(n?: number): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Creates a slice of array with n elements taken from the end.
         *
         * @param array The array to query.
         * @param n The number of elements to take.
         * @return Returns the slice of array.
         */
        takeRight<T>(array: List<T> | null | undefined, n?: number): T[];
    }
    interface Collection<T> {
        /**
         * @see _.takeRight
         */
        takeRight(n?: number): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.takeRight
         */
        takeRight(n?: number): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Creates a slice of array with elements taken from the end. Elements are taken until predicate returns
         * falsey. The predicate is invoked with three arguments: (value, index, array).
         *
         * @param array The array to query.
         * @param predicate The function invoked per iteration.
         * @return Returns the slice of array.
         */
        takeRightWhile<T>(array: List<T> | null | undefined, predicate?: ListIteratee<T>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.takeRightWhile
         */
        takeRightWhile(predicate?: ListIteratee<T>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.takeRightWhile
         */
        takeRightWhile(predicate?: ListIteratee<T>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Creates a slice of array with elements taken from the beginning. Elements are taken until predicate returns
         * falsey. The predicate is invoked with three arguments: (value, index, array).
         *
         * @param array The array to query.
         * @param predicate The function invoked per iteration.
         * @return Returns the slice of array.
         */
        takeWhile<T>(array: List<T> | null | undefined, predicate?: ListIteratee<T>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.takeWhile
         */
        takeWhile(predicate?: ListIteratee<T>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.takeWhile
         */
        takeWhile(predicate?: ListIteratee<T>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Creates an array of unique values, in order, from all of the provided arrays using SameValueZero for
         * equality comparisons.
         *
         * @param arrays The arrays to inspect.
         * @return Returns the new array of combined values.
         */
        union<T>(...arrays: Array<List<T> | null | undefined>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.union
         */
        union(...arrays: Array<List<T> | null | undefined>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.union
         */
        union(...arrays: Array<List<T> | null | undefined>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.union` except that it accepts `iteratee` which is
         * invoked for each element of each `arrays` to generate the criterion by which
         * uniqueness is computed. The iteratee is invoked with one argument: (value).
         *
         * @param arrays The arrays to inspect.
         * @param iteratee The iteratee invoked per element.
         * @return Returns the new array of combined values.
         */
        unionBy<T>(arrays: List<T> | null | undefined, iteratee?: ValueIteratee<T>): T[];
        /**
         * @see _.unionBy
         */
        unionBy<T>(arrays1: List<T> | null | undefined, arrays2: List<T> | null | undefined, iteratee?: ValueIteratee<T>): T[];
        /**
         * @see _.unionBy
         */
        unionBy<T>(arrays1: List<T> | null | undefined, arrays2: List<T> | null | undefined, arrays3: List<T> | null | undefined, iteratee?: ValueIteratee<T>): T[];
        /**
         * @see _.unionBy
         */
        unionBy<T>(arrays1: List<T> | null | undefined, arrays2: List<T> | null | undefined, arrays3: List<T> | null | undefined, arrays4: List<T> | null | undefined, iteratee?: ValueIteratee<T>): T[];
        /**
         * @see _.unionBy
         */
        unionBy<T>(arrays1: List<T> | null | undefined, arrays2: List<T> | null | undefined, arrays3: List<T> | null | undefined, arrays4: List<T> | null | undefined, arrays5: List<T> | null | undefined, ...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.unionBy
         */
        unionBy(arrays2: List<T> | null | undefined, iteratee?: ValueIteratee<T>): Collection<T>;
        /**
         * @see _.unionBy
         */
        unionBy(...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.unionBy
         */
        unionBy(arrays2: List<T> | null | undefined, iteratee?: ValueIteratee<T>): CollectionChain<T>;
        /**
         * @see _.unionBy
         */
        unionBy(...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.union` except that it accepts `comparator` which
         * is invoked to compare elements of `arrays`. The comparator is invoked
         * with two arguments: (arrVal, othVal).
         *
         * @category Array
         * @param [arrays] The arrays to inspect.
         * @param [comparator] The comparator invoked per element.
         * @returns Returns the new array of combined values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.unionWith(objects, others, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
         */
        unionWith<T>(arrays: List<T> | null | undefined, comparator?: Comparator<T>): T[];
        /**
         * @see _.unionWith
         */
        unionWith<T>(arrays: List<T> | null | undefined, arrays2: List<T> | null | undefined, comparator?: Comparator<T>): T[];
        /**
         * @see _.unionWith
         */
        unionWith<T>(arrays: List<T> | null | undefined, arrays2: List<T> | null | undefined, arrays3: List<T> | null | undefined, ...comparator: Array<Comparator<T> | List<T> | null | undefined>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.unionWith
         */
        unionWith(arrays2: List<T> | null | undefined, comparator?: Comparator<T>): Collection<T>;
        /**
         * @see _.unionWith
         */
        unionWith(...comparator: Array<Comparator<T> | List<T> | null | undefined>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.unionWith
         */
        unionWith(arrays2: List<T> | null | undefined, comparator?: Comparator<T>): CollectionChain<T>;
        /**
         * @see _.unionWith
         */
        unionWith(...comparator: Array<Comparator<T> | List<T> | null | undefined>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Creates a duplicate-free version of an array, using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons, in which only the first occurrence of each element
         * is kept.
         *
         * @category Array
         * @param array The array to inspect.
         * @returns Returns the new duplicate free array.
         * @example
         *
         * _.uniq([2, 1, 2]);
         * // => [2, 1]
         */
        uniq<T>(array: List<T> | null | undefined): T[];
    }
    interface Collection<T> {
        /**
         * @see _.uniq
         */
        uniq(): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.uniq
         */
        uniq(): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.uniq` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * uniqueness is computed. The iteratee is invoked with one argument: (value).
         *
         * @category Array
         * @param array The array to inspect.
         * @param [iteratee=_.identity] The iteratee invoked per element.
         * @returns Returns the new duplicate free array.
         * @example
         *
         * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
         * // => [2.1, 1.2]
         *
         * // using the `_.property` iteratee shorthand
         * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        uniqBy<T>(array: List<T> | null | undefined, iteratee: ValueIteratee<T>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.uniqBy
         */
        uniqBy(iteratee: ValueIteratee<T>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.uniqBy
         */
        uniqBy(iteratee: ValueIteratee<T>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.uniq` except that it accepts `comparator` which
         * is invoked to compare elements of `array`. The comparator is invoked with
         * two arguments: (arrVal, othVal).
         *
         * @category Array
         * @param array The array to inspect.
         * @param [comparator] The comparator invoked per element.
         * @returns Returns the new duplicate free array.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 },  { 'x': 1, 'y': 2 }];
         *
         * _.uniqWith(objects, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
         */
        uniqWith<T>(array: List<T> | null | undefined, comparator?: Comparator<T>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.uniqWith
         */
        uniqWith(comparator?: Comparator<T>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.uniqWith
         */
        uniqWith(comparator?: Comparator<T>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * This method is like _.zip except that it accepts an array of grouped elements and creates an array
         * regrouping the elements to their pre-zip configuration.
         *
         * @param array The array of grouped elements to process.
         * @return Returns the new array of regrouped elements.
         */
        unzip<T>(array: T[][] | List<List<T>> | null | undefined): T[][];
    }
    interface Collection<T> {
        /**
         * @see _.unzip
         */
        unzip(): T extends List<infer U> ? Collection<U[]> : unknown;
    }
    interface CollectionChain<T> {
        /**
         * @see _.unzip
         */
        unzip(): T extends List<infer U> ? CollectionChain<U[]> : unknown;
    }
    interface LoDashStatic {
        /**
         * This method is like _.unzip except that it accepts an iteratee to specify how regrouped values should be
         * combined. The iteratee is invoked with four arguments: (accumulator, value, index, group).
         *
         * @param array The array of grouped elements to process.
         * @param iteratee The function to combine regrouped values.
         * @return Returns the new array of regrouped elements.
         */
        unzipWith<T, TResult>(array: List<List<T>> | null | undefined, iteratee: (...values: T[]) => TResult): TResult[];
        /**
         * @see _.unzipWith
         */
        unzipWith<T>(array: List<List<T>> | null | undefined): T[][];
    }
    interface Collection<T> {
        /**
         * @see _.unzipWith
         */
        unzipWith<TResult>(iteratee: (...values: Array<T extends List<infer U> ? U : unknown>) => TResult): Collection<TResult>;
        /**
         * @see _.unzipWith
         */
        unzipWith(): T extends List<infer U> ? Collection<U[]> : unknown;
    }
    interface CollectionChain<T> {
        /**
         * @see _.unzipWith
         */
        unzipWith<TResult>(iteratee: (...values: Array<T extends List<infer U> ? U : unknown>) => TResult): CollectionChain<TResult>;
        /**
         * @see _.unzipWith
         */
        unzipWith(): T extends List<infer U> ? CollectionChain<U[]> : unknown;
    }
    interface LoDashStatic {
        /**
         * Creates an array excluding all provided values using SameValueZero for equality comparisons.
         *
         * @param array The array to filter.
         * @param values The values to exclude.
         * @return Returns the new array of filtered values.
         */
        without<T>(array: List<T> | null | undefined, ...values: T[]): T[];
    }
    interface Collection<T> {
        /**
         * @see _.without
         */
        without(...values: T[]): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.without
         */
        without(...values: T[]): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Creates an array of unique values that is the symmetric difference of the provided arrays.
         *
         * @param arrays The arrays to inspect.
         * @return Returns the new array of values.
         */
        xor<T>(...arrays: Array<List<T> | null | undefined>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.xor
         */
        xor(...arrays: Array<List<T> | null | undefined>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.xor
         */
        xor(...arrays: Array<List<T> | null | undefined>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.xor` except that it accepts `iteratee` which is
         * invoked for each element of each `arrays` to generate the criterion by which
         * uniqueness is computed. The iteratee is invoked with one argument: (value).
         *
         * @category Array
         * @param [arrays] The arrays to inspect.
         * @param [iteratee=_.identity] The iteratee invoked per element.
         * @returns Returns the new array of values.
         * @example
         *
         * _.xorBy([2.1, 1.2], [4.3, 2.4], Math.floor);
         * // => [1.2, 4.3]
         *
         * // using the `_.property` iteratee shorthand
         * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 2 }]
         */
        xorBy<T>(arrays: List<T> | null | undefined, iteratee?: ValueIteratee<T>): T[];
        /**
         * @see _.xorBy
         */
        xorBy<T>(arrays: List<T> | null | undefined, arrays2: List<T> | null | undefined, iteratee?: ValueIteratee<T>): T[];
        /**
         * @see _.xorBy
         */
        xorBy<T>(arrays: List<T> | null | undefined, arrays2: List<T> | null | undefined, arrays3: List<T> | null | undefined, ...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.xorBy
         */
        xorBy(arrays2: List<T> | null | undefined, iteratee?: ValueIteratee<T>): Collection<T>;
        /**
         * @see _.xorBy
         */
        xorBy(...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.xorBy
         */
        xorBy(arrays2: List<T> | null | undefined, iteratee?: ValueIteratee<T>): CollectionChain<T>;
        /**
         * @see _.xorBy
         */
        xorBy(...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.xor` except that it accepts `comparator` which is
         * invoked to compare elements of `arrays`. The comparator is invoked with
         * two arguments: (arrVal, othVal).
         *
         * @category Array
         * @param [arrays] The arrays to inspect.
         * @param [comparator] The comparator invoked per element.
         * @returns Returns the new array of values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.xorWith(objects, others, _.isEqual);
         * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
         */
        xorWith<T>(arrays: List<T> | null | undefined, comparator?: Comparator<T>): T[];
        /**
         * @see _.xorWith
         */
        xorWith<T>(arrays: List<T> | null | undefined, arrays2: List<T> | null | undefined, comparator?: Comparator<T>): T[];
        /**
         * @see _.xorWith
         */
        xorWith<T>(arrays: List<T> | null | undefined, arrays2: List<T> | null | undefined, arrays3: List<T> | null | undefined, ...comparator: Array<Comparator<T> | List<T> | null | undefined>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.xorWith
         */
        xorWith(arrays2: List<T> | null | undefined, comparator?: Comparator<T>): Collection<T>;
        /**
         * @see _.xorWith
         */
        xorWith(...comparator: Array<Comparator<T> | List<T> | null | undefined>): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.xorWith
         */
        xorWith(arrays2: List<T> | null | undefined, comparator?: Comparator<T>): CollectionChain<T>;
        /**
         * @see _.xorWith
         */
        xorWith(...comparator: Array<Comparator<T> | List<T> | null | undefined>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Creates an array of grouped elements, the first of which contains the first elements of the given arrays,
         * the second of which contains the second elements of the given arrays, and so on.
         *
         * @param arrays The arrays to process.
         * @return Returns the new array of grouped elements.
         */
        zip<T1, T2>(arrays1: List<T1>, arrays2: List<T2>): Array<[T1 | undefined, T2 | undefined]>;
        /**
         * @see _.zip
         */
        zip<T1, T2, T3>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>): Array<[T1 | undefined, T2 | undefined, T3 | undefined]>;
        /**
         * @see _.zip
         */
        zip<T1, T2, T3, T4>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>, arrays4: List<T4>): Array<[T1 | undefined, T2 | undefined, T3 | undefined, T4 | undefined]>;
        /**
         * @see _.zip
         */
        zip<T1, T2, T3, T4, T5>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>, arrays4: List<T4>, arrays5: List<T5>): Array<[T1 | undefined, T2 | undefined, T3 | undefined, T4 | undefined, T5 | undefined]>;
        /**
         * @see _.zip
         */
        zip<T>(...arrays: Array<List<T> | null | undefined>): Array<Array<T | undefined>>;
    }
    interface Collection<T> {
        /**
         * @see _.zip
         */
        zip<T2>(arrays2: List<T2>): Collection<[T | undefined, T2 | undefined]>;
        /**
         * @see _.zip
         */
        zip(...arrays: Array<List<T> | null | undefined>): Collection<Array<T | undefined>>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.zip
         */
        zip<T2>(arrays2: List<T2>): CollectionChain<[T | undefined, T2 | undefined]>;
        /**
         * @see _.zip
         */
        zip(...arrays: Array<List<T> | null | undefined>): CollectionChain<Array<T | undefined>>;
    }
    interface LoDashStatic {
        /**
         * This method is like _.fromPairs except that it accepts two arrays, one of property
         * identifiers and one of corresponding values.
         *
         * @param props The property names.
         * @param values The property values.
         * @return Returns the new object.
         */
        zipObject<T>(props: List<PropertyName>, values: List<T>): Dictionary<T>;
        /**
         * @see _.zipObject
         */
        zipObject(props?: List<PropertyName>): Dictionary<undefined>;
    }
    interface Collection<T> {
        /**
         * @see _.zipObject
         */
        zipObject<U>(values: List<U>): Object<Dictionary<U>>;
        /**
         * @see _.zipObject
         */
        zipObject(): Object<Dictionary<undefined>>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.zipObject
         */
        zipObject<U>(values: List<U>): ObjectChain<Dictionary<U>>;
        /**
         * @see _.zipObject
         */
        zipObject(): ObjectChain<Dictionary<undefined>>;
    }
    interface LoDashStatic {
        /**
         * This method is like _.zipObject except that it supports property paths.
         *
         * @param paths The property names.
         * @param values The property values.
         * @return Returns the new object.
         */
        zipObjectDeep(paths?: List<PropertyPath>, values?: List<any>): object;
    }
    interface Collection<T> {
        /**
         * @see _.zipObjectDeep
         */
        zipObjectDeep(values?: List<any>): Object<object>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.zipObjectDeep
         */
        zipObjectDeep(values?: List<any>): ObjectChain<object>;
    }
    interface LoDashStatic {
        /**
         * This method is like _.zip except that it accepts an iteratee to specify how grouped values should be
         * combined. The iteratee is invoked with four arguments: (accumulator, value, index,
         * group).
         * @param arrays The arrays to process.
         * @param iteratee The function to combine grouped values.
         * @return Returns the new array of grouped elements.
         */
        zipWith<T, TResult>(arrays: List<T>, iteratee: (value1: T) => TResult): TResult[];
        /**
         * @see _.zipWith
         */
        zipWith<T1, T2, TResult>(arrays1: List<T1>, arrays2: List<T2>, iteratee: (value1: T1, value2: T2) => TResult): TResult[];
        /**
         * @see _.zipWith
         */
        zipWith<T1, T2, T3, TResult>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>, iteratee: (value1: T1, value2: T2, value3: T3) => TResult): TResult[];
        /**
         * @see _.zipWith
         */
        zipWith<T1, T2, T3, T4, TResult>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>, arrays4: List<T4>, iteratee: (value1: T1, value2: T2, value3: T3, value4: T4) => TResult): TResult[];
        /**
         * @see _.zipWith
         */
        zipWith<T1, T2, T3, T4, T5, TResult>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>, arrays4: List<T4>, arrays5: List<T5>, iteratee: (value1: T1, value2: T2, value3: T3, value4: T4, value5: T5) => TResult): TResult[];
        /**
         * @see _.zipWith
         */
        zipWith<T, TResult>(...iteratee: Array<((...group: T[]) => TResult) | List<T> | null | undefined>): TResult[];
    }
    interface Collection<T> {
        /**
         * @see _.zipWith
         */
        zipWith<T2, TResult>(arrays2: List<T2>, iteratee: (value1: T, value2: T2) => TResult): Collection<TResult>;
        /**
         * @see _.zipWith
         */
        zipWith<T2, T3, TResult>(arrays2: List<T2>, arrays3: List<T3>, iteratee: (value1: T, value2: T2, value3: T3) => TResult): Collection<TResult>;
        /**
         * @see _.zipWith
         */
        zipWith<TResult>(...iteratee: Array<((...group: T[]) => TResult) | List<T> | null | undefined>): Collection<TResult>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.zipWith
         */
        zipWith<T2, TResult>(arrays2: List<T2>, iteratee: (value1: T, value2: T2) => TResult): CollectionChain<TResult>;
        /**
         * @see _.zipWith
         */
        zipWith<T2, T3, TResult>(arrays2: List<T2>, arrays3: List<T3>, iteratee: (value1: T, value2: T2, value3: T3) => TResult): CollectionChain<TResult>;
        /**
         * @see _.zipWith
         */
        zipWith<TResult>(...iteratee: Array<((...group: T[]) => TResult) | List<T> | null | undefined>): CollectionChain<TResult>;
    }
}
import _ = require("../index");
declare module "../index" {
    interface LoDashStatic {
        /**
         * Creates an object composed of keys generated from the results of running each element of collection through
         * iteratee. The corresponding value of each key is the number of times the key was returned by iteratee. The
         * iteratee is invoked with one argument: (value).
         *
         * @param collection The collection to iterate over.
         * @param iteratee The function invoked per iteration.
         * @return Returns the composed aggregate object.
         */
        countBy<T>(collection: List<T> | null | undefined, iteratee?: ValueIteratee<T>): Dictionary<number>;
        /**
         * @see _.countBy
         */
        countBy<T extends object>(collection: T | null | undefined, iteratee?: ValueIteratee<T[keyof T]>): Dictionary<number>;
    }
    interface Object<T> {
        /**
         * @see _.countBy
         */
        countBy(iteratee?: ValueIteratee<T[keyof T]>): Object<Dictionary<number>>;
    }
    interface String {
        /**
         * @see _.countBy
         */
        countBy(iteratee?: ValueIteratee<string>): Object<Dictionary<number>>;
    }
    interface Collection<T> {
        /**
         * @see _.countBy
         */
        countBy(iteratee?: ValueIteratee<T>): Object<Dictionary<number>>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.countBy
         */
        countBy(iteratee?: ValueIteratee<T[keyof T]>): ObjectChain<Dictionary<number>>;
    }
    interface StringChain {
        /**
         * @see _.countBy
         */
        countBy(iteratee?: ValueIteratee<string>): ObjectChain<Dictionary<number>>;
    }
    interface StringNullableChain {
        /**
         * @see _.countBy
         */
        countBy(iteratee?: ValueIteratee<string>): ObjectChain<Dictionary<number>>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.countBy
         */
        countBy(iteratee?: ValueIteratee<T>): ObjectChain<Dictionary<number>>;
    }
    interface LoDashStatic {
        /**
         * @see _.forEach
         */
        each: LoDashStatic['forEach'];
    }
    interface String {
        /**
         * @see _.each
         */
        each: String['forEach'];
    }
    interface Collection<T> {
        /**
         * @see _.each
         */
        each: Collection<T>['forEach'];
    }
    interface Object<T> {
        /**
         * @see _.each
         */
        each: Object<T>['forEach'];
    }
    interface StringChain {
        /**
         * @see _.each
         */
        each: StringChain['forEach'];
    }
    interface StringNullableChain {
        /**
         * @see _.each
         */
        each: StringNullableChain['forEach'];
    }
    interface CollectionChain<T> {
        /**
         * @see _.each
         */
        each: CollectionChain<T>['forEach'];
    }
    interface ObjectChain<T> {
        /**
         * @see _.each
         */
        each: ObjectChain<T>['forEach'];
    }
    interface LoDashStatic {
        /**
         * @see _.forEachRight
         */
        eachRight: LoDashStatic["forEachRight"];
    }
    interface String {
        /**
         * @see _.eachRight
         */
        eachRight: String['forEachRight'];
    }
    interface Collection<T> {
        /**
         * @see _.eachRight
         */
        eachRight: Collection<T>['forEachRight'];
    }
    interface Object<T> {
        /**
         * @see _.eachRight
         */
        eachRight: Object<T>['forEachRight'];
    }
    interface StringChain {
        /**
         * @see _.eachRight
         */
        eachRight: StringChain['forEachRight'];
    }
    interface StringNullableChain {
        /**
         * @see _.eachRight
         */
        eachRight: StringNullableChain['forEachRight'];
    }
    interface CollectionChain<T> {
        /**
         * @see _.eachRight
         */
        eachRight: CollectionChain<T>['forEachRight'];
    }
    interface ObjectChain<T> {
        /**
         * @see _.eachRight
         */
        eachRight: ObjectChain<T>['forEachRight'];
    }
    interface LoDashStatic {
        /**
         * Checks if predicate returns truthy for all elements of collection. Iteration is stopped once predicate
         * returns falsey. The predicate is invoked with three arguments: (value, index|key, collection).
         *
         * @param collection The collection to iterate over.
         * @param predicate The function invoked per iteration.
         * @return Returns true if all elements pass the predicate check, else false.
         */
        every<T>(collection: List<T> | null | undefined, predicate?: ListIterateeCustom<T, boolean>): boolean;
        /**
         * @see _.every
         */
        every<T extends object>(collection: T | null | undefined, predicate?: ObjectIterateeCustom<T, boolean>): boolean;
    }
    interface Collection<T> {
        /**
         * @see _.every
         */
        every(predicate?: ListIterateeCustom<T, boolean>): boolean;
    }
    interface Object<T> {
        /**
         * @see _.every
         */
        every(predicate?: ObjectIterateeCustom<T, boolean>): boolean;
    }
    interface CollectionChain<T> {
        /**
         * @see _.every
         */
        every(predicate?: ListIterateeCustom<T, boolean>): PrimitiveChain<boolean>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.every
         */
        every(predicate?: ObjectIterateeCustom<T, boolean>): PrimitiveChain<boolean>;
    }
    interface LoDashStatic {
        /**
         * Iterates over elements of collection, returning an array of all elements predicate returns truthy for. The
         * predicate is invoked with three arguments: (value, index|key, collection).
         *
         * @param collection The collection to iterate over.
         * @param predicate The function invoked per iteration.
         * @return Returns the new filtered array.
         */
        filter(collection: string | null | undefined, predicate?: StringIterator<boolean>): string[];
        /**
         * @see _.filter
         */
        filter<T, S extends T>(collection: List<T> | null | undefined, predicate: ListIteratorTypeGuard<T, S>): S[];
        /**
         * @see _.filter
         */
        filter<T>(collection: List<T> | null | undefined, predicate?: ListIterateeCustom<T, boolean>): T[];
        /**
         * @see _.filter
         */
        filter<T extends object, S extends T[keyof T]>(collection: T | null | undefined, predicate: ObjectIteratorTypeGuard<T, S>): S[];
        /**
         * @see _.filter
         */
        filter<T extends object>(collection: T | null | undefined, predicate?: ObjectIterateeCustom<T, boolean>): Array<T[keyof T]>;
    }
    interface String {
        /**
         * @see _.filter
         */
        filter(predicate?: StringIterator<boolean>): Collection<string>;
    }
    interface Collection<T> {
        /**
         * @see _.filter
         */
        filter<S extends T>(predicate: ListIteratorTypeGuard<T, S>): Collection<S>;
        /**
         * @see _.filter
         */
        filter(predicate?: ListIterateeCustom<T, boolean>): Collection<T>;
    }
    interface Object<T> {
        /**
         * @see _.filter
         */
        filter<S extends T[keyof T]>(predicate: ObjectIteratorTypeGuard<T, S>): Collection<S>;
        /**
         * @see _.filter
         */
        filter(predicate?: ObjectIterateeCustom<T, boolean>): Collection<T[keyof T]>;
    }
    interface StringChain {
        /**
         * @see _.filter
         */
        filter(predicate?: StringIterator<boolean>): CollectionChain<string>;
    }
    interface StringNullableChain {
        /**
         * @see _.filter
         */
        filter(predicate?: StringIterator<boolean>): CollectionChain<string>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.filter
         */
        filter<S extends T>(predicate: ListIteratorTypeGuard<T, S>): CollectionChain<S>;
        /**
         * @see _.filter
         */
        filter(predicate?: ListIterateeCustom<T, boolean>): CollectionChain<T>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.filter
         */
        filter<S extends T[keyof T]>(predicate: ObjectIteratorTypeGuard<T, S>): CollectionChain<S>;
        /**
         * @see _.filter
         */
        filter(predicate?: ObjectIterateeCustom<T, boolean>): CollectionChain<T[keyof T]>;
    }
    interface LoDashStatic {
        /**
         * Iterates over elements of collection, returning the first element predicate returns truthy for.
         * The predicate is invoked with three arguments: (value, index|key, collection).
         *
         * @param collection The collection to search.
         * @param predicate The function invoked per iteration.
         * @param fromIndex The index to search from.
         * @return Returns the matched element, else undefined.
         */
        find<T, S extends T>(collection: List<T> | null | undefined, predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): S|undefined;
        /**
         * @see _.find
         */
        find<T>(collection: List<T> | null | undefined, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): T|undefined;
        /**
         * @see _.find
         */
        find<T extends object, S extends T[keyof T]>(collection: T | null | undefined, predicate: ObjectIteratorTypeGuard<T, S>, fromIndex?: number): S|undefined;
        /**
         * @see _.find
         */
        find<T extends object>(collection: T | null | undefined, predicate?: ObjectIterateeCustom<T, boolean>, fromIndex?: number): T[keyof T]|undefined;
    }
    interface Collection<T> {
        /**
         * @see _.find
         */
        find<S extends T>(predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): S|undefined;
        /**
         * @see _.find
         */
        find(predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): T|undefined;
    }
    interface Object<T> {
        /**
         * @see _.find
         */
        find< S extends T[keyof T]>(predicate: ObjectIteratorTypeGuard<T, S>, fromIndex?: number): S|undefined;
        /**
         * @see _.find
         */
        find(predicate?: ObjectIterateeCustom<T, boolean>, fromIndex?: number): T[keyof T]|undefined;
    }
    interface CollectionChain<T> {
        /**
         * @see _.find
         */
        find< S extends T>(predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): ExpChain<S|undefined>;
        /**
         * @see _.find
         */
        find(predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): ExpChain<T|undefined>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.find
         */
        find< S extends T[keyof T]>(predicate: ObjectIteratorTypeGuard<T, S>, fromIndex?: number): ExpChain<S|undefined>;
        /**
         * @see _.find
         */
        find(predicate?: ObjectIterateeCustom<T, boolean>, fromIndex?: number): ExpChain<T[keyof T]|undefined>;
    }
    interface LoDashStatic {
        /**
         * This method is like _.find except that it iterates over elements of a collection from
         * right to left.
         * @param collection Searches for a value in this list.
         * @param predicate The function called per iteration.
         * @param fromIndex The index to search from.
         * @return The found element, else undefined.
         */
        findLast<T, S extends T>(collection: List<T> | null | undefined, predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): S|undefined;
        /**
         * @see _.findLast
         */
        findLast<T>(collection: List<T> | null | undefined, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): T|undefined;
        /**
         * @see _.findLast
         */
        findLast<T extends object, S extends T[keyof T]>(collection: T | null | undefined, predicate: ObjectIteratorTypeGuard<T, S>, fromIndex?: number): S|undefined;
        /**
         * @see _.findLast
         */
        findLast<T extends object>(collection: T | null | undefined, predicate?: ObjectIterateeCustom<T, boolean>, fromIndex?: number): T[keyof T]|undefined;
    }
    interface Collection<T> {
        /**
         * @see _.findLast
         */
        findLast<S extends T>(predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): S|undefined;
        /**
         * @see _.findLast
         */
        findLast(predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): T|undefined;
    }
    interface Object<T> {
        /**
         * @see _.findLast
         */
        findLast< S extends T[keyof T]>(predicate: ObjectIteratorTypeGuard<T, S>, fromIndex?: number): S|undefined;
        /**
         * @see _.findLast
         */
        findLast(predicate?: ObjectIterateeCustom<T, boolean>, fromIndex?: number): T[keyof T]|undefined;
    }
    interface CollectionChain<T> {
        /**
         * @see _.findLast
         */
        findLast< S extends T>(predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): ExpChain<S|undefined>;
        /**
         * @see _.findLast
         */
        findLast(predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): ExpChain<T|undefined>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.findLast
         */
        findLast< S extends T[keyof T]>(predicate: ObjectIteratorTypeGuard<T, S>, fromIndex?: number): ExpChain<S|undefined>;
        /**
         * @see _.findLast
         */
        findLast(predicate?: ObjectIterateeCustom<T, boolean>, fromIndex?: number): ExpChain<T[keyof T]|undefined>;
    }
    interface LoDashStatic {
        /**
         * Creates an array of flattened values by running each element in collection through iteratee
         * and concating its result to the other mapped values. The iteratee is invoked with three arguments:
         * (value, index|key, collection).
         *
         * @param collection The collection to iterate over.
         * @param iteratee The function invoked per iteration.
         * @return Returns the new flattened array.
         */
        flatMap<T>(collection: Dictionary<Many<T>> | NumericDictionary<Many<T>> | null | undefined): T[];
        /**
         * @see _.flatMap
         */
        flatMap(collection: object | null | undefined): any[];
        /**
         * @see _.flatMap
         */
        flatMap<T, TResult>(collection: List<T> | null | undefined, iteratee: ListIterator<T, Many<TResult>>): TResult[];
        /**
         * @see _.flatMap
         */
        flatMap<T extends object, TResult>(collection: T | null | undefined, iteratee: ObjectIterator<T, Many<TResult>>): TResult[];
        /**
         * @see _.flatMap
         */
        flatMap(collection: object | null | undefined, iteratee: string): any[];
        /**
         * @see _.flatMap
         */
        flatMap(collection: object | null | undefined, iteratee: object): boolean[];
    }
    interface String {
        /**
         * @see _.flatMap
         */
        flatMap<TResult>(iteratee: StringIterator<Many<TResult>>): Collection<TResult>;
        /**
         * @see _.flatMap
         */
        flatMap(): Collection<string>;
    }
    interface Collection<T> {
        /**
         * @see _.flatMap
         */
        flatMap<TResult = any>(iteratee: ListIterator<T, Many<TResult>> | PropertyName): Collection<TResult>;
        /**
         * @see _.flatMap
         */
        flatMap(iteratee: [PropertyName, any] | object): Collection<boolean>;
        /**
         * @see _.flatMap
         */
        flatMap(): T extends Many<infer U> ? Collection<U> : Collection<T>;
    }
    interface Object<T> {
        /**
         * @see _.flatMap
         */
        flatMap<TResult = any>(iteratee: ObjectIterator<T, Many<TResult>> | PropertyName): Collection<TResult>;
        /**
         * @see _.flatMap
         */
        flatMap(iteratee: [PropertyName, any] | object): Collection<boolean>;
        /**
         * @see _.flatMap
         */
        flatMap(): Collection<T[keyof T]>;
    }
    interface StringChain {
        /**
         * @see _.flatMap
         */
        flatMap<TResult>(iteratee: StringIterator<Many<TResult>>): CollectionChain<TResult>;
        /**
         * @see _.flatMap
         */
        flatMap(): CollectionChain<string>;
    }
    interface StringNullableChain {
        /**
         * @see _.flatMap
         */
        flatMap<TResult>(iteratee: StringIterator<Many<TResult>>): CollectionChain<TResult>;
        /**
         * @see _.flatMap
         */
        flatMap(): CollectionChain<string>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.flatMap
         */
        flatMap<TResult = any>(iteratee: ListIterator<T, Many<TResult>> | PropertyName): CollectionChain<TResult>;
        /**
         * @see _.flatMap
         */
        flatMap(iteratee: [PropertyName, any] | object): CollectionChain<boolean>;
        /**
         * @see _.flatMap
         */
        flatMap(): T extends Many<infer U> ? CollectionChain<U> : CollectionChain<T>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.flatMap
         */
        flatMap<TResult = any>(iteratee: ObjectIterator<T, Many<TResult>> | PropertyName): CollectionChain<TResult>;
        /**
         * @see _.flatMap
         */
        flatMap(iteratee: [PropertyName, any] | object): CollectionChain<boolean>;
        /**
         * @see _.flatMap
         */
        flatMap(): CollectionChain<T[keyof T]>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.flatMap` except that it recursively flattens the
         * mapped results.
         *
         * @since 4.7.0
         * @category Collection
         * @param collection The collection to iterate over.
         * @param [iteratee=_.identity] The function invoked per iteration.
         * @returns Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [[[n, n]]];
         * }
         *
         * _.flatMapDeep([1, 2], duplicate);
         * // => [1, 1, 2, 2]
         */
        flatMapDeep<T>(collection: Dictionary<ListOfRecursiveArraysOrValues<T> | T> | NumericDictionary<ListOfRecursiveArraysOrValues<T> | T> | null | undefined): T[];
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep<T, TResult>(collection: List<T> | null | undefined, iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>): TResult[];
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep<T extends object, TResult>(collection: T | null | undefined, iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>): TResult[];
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep(collection: object | null | undefined, iteratee: string): any[];
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep(collection: object | null | undefined, iteratee: object): boolean[];
    }
    interface String {
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep<TResult>(iteratee: StringIterator<ListOfRecursiveArraysOrValues<TResult> | TResult>): Collection<TResult>;
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep(): Collection<string>;
    }
    interface Collection<T> {
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep<TResult = any>(iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult> | PropertyName): Collection<TResult>;
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep(iteratee: [PropertyName, any] | object): Collection<boolean>;
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep(): Collection<T>;
    }
    interface Object<T> {
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep<TResult = any>(iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult> | PropertyName): Collection<TResult>;
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep(iteratee: [PropertyName, any] | object): Collection<boolean>;
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep(): Collection<T[keyof T]>;
    }
    interface StringChain {
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep<TResult>(iteratee: StringIterator<ListOfRecursiveArraysOrValues<TResult> | TResult>): CollectionChain<TResult>;
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep(): CollectionChain<string>;
    }
    interface StringNullableChain {
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep<TResult>(iteratee: StringIterator<ListOfRecursiveArraysOrValues<TResult> | TResult>): CollectionChain<TResult>;
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep(): CollectionChain<string>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep<TResult = any>(iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult> | PropertyName): CollectionChain<TResult>;
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep(iteratee: [PropertyName, any] | object): CollectionChain<boolean>;
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep(): CollectionChain<T>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep<TResult = any>(iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult> | PropertyName): CollectionChain<TResult>;
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep(iteratee: [PropertyName, any] | object): CollectionChain<boolean>;
        /**
         * @see _.flatMapDeep
         */
        flatMapDeep(): CollectionChain<T[keyof T]>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.flatMap` except that it recursively flattens the
         * mapped results up to `depth` times.
         *
         * @since 4.7.0
         * @category Collection
         * @param collection The collection to iterate over.
         * @param [iteratee=_.identity] The function invoked per iteration.
         * @param [depth=1] The maximum recursion depth.
         * @returns Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [[[n, n]]];
         * }
         *
         * _.flatMapDepth([1, 2], duplicate, 2);
         * // => [[1, 1], [2, 2]]
         */
        flatMapDepth<T>(collection: Dictionary<ListOfRecursiveArraysOrValues<T> | T> | NumericDictionary<ListOfRecursiveArraysOrValues<T> | T> | null | undefined): T[];
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth<T, TResult>(collection: List<T> | null | undefined, iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>, depth?: number): TResult[];
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth<T extends object, TResult>(collection: T | null | undefined, iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>, depth?: number): TResult[];
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth(collection: object | null | undefined, iteratee: string, depth?: number): any[];
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth(collection: object | null | undefined, iteratee: object, depth?: number): boolean[];
    }
    interface String {
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth<TResult>(iteratee: StringIterator<ListOfRecursiveArraysOrValues<TResult> | TResult>, depth?: number): Collection<TResult>;
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth(depth?: number): Collection<string>;
    }
    interface Collection<T> {
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth<TResult = any>(iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult> | PropertyName, depth?: number): Collection<TResult>;
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth(iteratee: [PropertyName, any] | object, depth?: number): Collection<boolean>;
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth(depth?: number): Collection<T>;
    }
    interface Object<T> {
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth<TResult = any>(iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult> | PropertyName, depth?: number): Collection<TResult>;
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth(iteratee: [PropertyName, any] | object, depth?: number): Collection<boolean>;
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth(depth?: number): Collection<T[keyof T]>;
    }
    interface StringChain {
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth<TResult>(iteratee: StringIterator<ListOfRecursiveArraysOrValues<TResult> | TResult>, depth?: number): CollectionChain<TResult>;
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth(depth?: number): CollectionChain<string>;
    }
    interface StringNullableChain {
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth<TResult>(iteratee: StringIterator<ListOfRecursiveArraysOrValues<TResult> | TResult>, depth?: number): CollectionChain<TResult>;
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth(depth?: number): CollectionChain<string>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth<TResult = any>(iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult> | PropertyName, depth?: number): CollectionChain<TResult>;
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth(iteratee: [PropertyName, any] | object, depth?: number): CollectionChain<boolean>;
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth(depth?: number): CollectionChain<T>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth<TResult = any>(iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult> | PropertyName, depth?: number): CollectionChain<TResult>;
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth(iteratee: [PropertyName, any] | object, depth?: number): CollectionChain<boolean>;
        /**
         * @see _.flatMapDepth
         */
        flatMapDepth(depth?: number): CollectionChain<T[keyof T]>;
    }
    interface LoDashStatic {
        /**
         * Iterates over elements of collection invoking iteratee for each element. The iteratee is invoked with three arguments:
         * (value, index|key, collection). Iteratee functions may exit iteration early by explicitly returning false.
         *
         * Note: As with other "Collections" methods, objects with a "length" property are iterated like arrays. To
         * avoid this behavior _.forIn or _.forOwn may be used for object iteration.
         *
         * @alias _.each
         *
         * @param collection The collection to iterate over.
         * @param iteratee The function invoked per iteration.
         */
        forEach<T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[];
        /**
         * @see _.forEach
         */
        forEach(collection: string, iteratee?: StringIterator<any>): string;
        /**
         * @see _.forEach
         */
        forEach<T>(collection: List<T>, iteratee?: ListIterator<T, any>): List<T>;
        /**
         * @see _.forEach
         */
        forEach<T extends object>(collection: T, iteratee?: ObjectIterator<T, any>): T;
        /**
         * @see _.forEach
         */
        forEach<T, TArray extends T[] | null | undefined>(collection: TArray & (T[] | null | undefined), iteratee?: ArrayIterator<T, any>): TArray;
        /**
         * @see _.forEach
         */
        forEach<TString extends string | null | undefined>(collection: TString, iteratee?: StringIterator<any>): TString;
        /**
         * @see _.forEach
         */
        forEach<T, TList extends List<T> | null | undefined>(collection: TList & (List<T> | null | undefined), iteratee?: ListIterator<T, any>): TList;
        /**
         * @see _.forEach
         */
        forEach<T extends object>(collection: T | null | undefined, iteratee?: ObjectIterator<T, any>): T | null | undefined;
    }
    interface String {
        /**
         * @see _.forEach
         */
        forEach(iteratee?: StringIterator<any>): String;
    }
    interface Object<T> {
        /**
         * @see _.forEach
         */
        forEach(iteratee?: ObjectIterator<T, any>): Object<T>;
    }
    interface Collection<T> {
        /**
         * @see _.forEach
         */
        forEach(iteratee?: ListIterator<T, any>): Collection<T>;
    }
    interface StringChain {
        /**
         * @see _.forEach
         */
        forEach(iteratee?: StringIterator<any>): StringChain;
    }
    interface StringNullableChain {
        /**
         * @see _.forEach
         */
        forEach(iteratee?: StringIterator<any>): StringNullableChain;
    }
    interface ObjectChain<T> {
        /**
         * @see _.forEach
         */
        forEach(iteratee?: ObjectIterator<T, any>): ObjectChain<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.forEach
         */
        forEach(iteratee?: ListIterator<T, any>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * This method is like _.forEach except that it iterates over elements of collection from right to left.
         *
         * @alias _.eachRight
         *
         * @param collection The collection to iterate over.
         * @param iteratee The function called per iteration.
         */
        forEachRight<T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[];
        /**
         * @see _.forEachRight
         */
        forEachRight(collection: string, iteratee?: StringIterator<any>): string;
        /**
         * @see _.forEachRight
         */
        forEachRight<T>(collection: List<T>, iteratee?: ListIterator<T, any>): List<T>;
        /**
         * @see _.forEachRight
         */
        forEachRight<T extends object>(collection: T, iteratee?: ObjectIterator<T, any>): T;
        /**
         * @see _.forEachRight
         */
        forEachRight<T, TArray extends T[] | null | undefined>(collection: TArray & (T[] | null | undefined), iteratee?: ArrayIterator<T, any>): TArray;
        /**
         * @see _.forEachRight
         */
        forEachRight<TString extends string | null | undefined>(collection: TString, iteratee?: StringIterator<any>): TString;
        /**
         * @see _.forEachRight
         */
        forEachRight<T, TList extends List<T> | null | undefined>(collection: TList & (List<T> | null | undefined), iteratee?: ListIterator<T, any>): TList;
        /**
         * @see _.forEachRight
         */
        forEachRight<T extends object>(collection: T | null | undefined, iteratee?: ObjectIterator<T, any>): T | null | undefined;
    }
    interface String {
        /**
         * @see _.forEachRight
         */
        forEachRight(iteratee?: StringIterator<any>): String;
    }
    interface Object<T> {
        /**
         * @see _.forEachRight
         */
        forEachRight(iteratee?: ObjectIterator<T, any>): Object<T>;
    }
    interface Collection<T> {
        /**
         * @see _.forEachRight
         */
        forEachRight(iteratee?: ListIterator<T, any>): Collection<T>;
    }
    interface StringChain {
        /**
         * @see _.forEachRight
         */
        forEachRight(iteratee?: StringIterator<any>): StringChain;
    }
    interface StringNullableChain {
        /**
         * @see _.forEachRight
         */
        forEachRight(iteratee?: StringIterator<any>): StringNullableChain;
    }
    interface ObjectChain<T> {
        /**
         * @see _.forEachRight
         */
        forEachRight(iteratee?: ObjectIterator<T, any>): ObjectChain<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.forEachRight
         */
        forEachRight(iteratee?: ListIterator<T, any>): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Creates an object composed of keys generated from the results of running each element of collection through
         * iteratee. The corresponding value of each key is an array of the elements responsible for generating the
         * key. The iteratee is invoked with one argument: (value).
         *
         * @param collection The collection to iterate over.
         * @param iteratee The function invoked per iteration.
         * @return Returns the composed aggregate object.
         */
        groupBy<T>(collection: List<T> | null | undefined, iteratee?: ValueIteratee<T>): Dictionary<T[]>;
        /**
         * @see _.groupBy
         */
        groupBy<T extends object>(collection: T | null | undefined, iteratee?: ValueIteratee<T[keyof T]>): Dictionary<Array<T[keyof T]>>;
    }
    interface String {
        /**
         * @see _.groupBy
         */
        groupBy(iteratee?: ValueIteratee<string>): Object<Dictionary<string[]>>;
    }
    interface Collection<T> {
        /**
         * @see _.groupBy
         */
        groupBy(iteratee?: ValueIteratee<T>): Object<Dictionary<T[]>>;
    }
    interface Object<T> {
        /**
         * @see _.groupBy
         */
        groupBy(iteratee?: ValueIteratee<T[keyof T]>): Object<Dictionary<Array<T[keyof T]>>>;
    }
    interface StringChain {
        /**
         * @see _.groupBy
         */
        groupBy(iteratee?: ValueIteratee<string>): ObjectChain<Dictionary<string[]>>;
    }
    interface StringNullableChain {
        /**
         * @see _.groupBy
         */
        groupBy(iteratee?: ValueIteratee<string>): ObjectChain<Dictionary<string[]>>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.groupBy
         */
        groupBy(iteratee?: ValueIteratee<T>): ObjectChain<Dictionary<T[]>>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.groupBy
         */
        groupBy(iteratee?: ValueIteratee<T[keyof T]>): ObjectChain<Dictionary<Array<T[keyof T]>>>;
    }
    interface LoDashStatic {
        /**
         * Checks if target is in collection using SameValueZero for equality comparisons. If fromIndex is negative,
         * it’s used as the offset from the end of collection.
         *
         * @param collection The collection to search.
         * @param target The value to search for.
         * @param fromIndex The index to search from.
         * @return True if the target element is found, else false.
         */
        includes<T>(collection: Dictionary<T> | NumericDictionary<T> | null | undefined, target: T, fromIndex?: number): boolean;
    }
    interface Object<T> {
        /**
         * @see _.includes
         */
        includes(target: T[keyof T], fromIndex?: number): boolean;
    }
    interface Collection<T> {
        /**
         * @see _.includes
         */
        includes(target: T, fromIndex?: number): boolean;
    }
    interface String {
        /**
         * @see _.includes
         */
        includes(target: string, fromIndex?: number): boolean;
    }
    interface ObjectChain<T> {
        /**
         * @see _.includes
         */
        includes(target: T[keyof T], fromIndex?: number): PrimitiveChain<boolean>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.includes
         */
        includes(target: T, fromIndex?: number): PrimitiveChain<boolean>;
    }
    interface StringChain {
        /**
         * @see _.includes
         */
        includes(target: string, fromIndex?: number): PrimitiveChain<boolean>;
    }
    interface LoDashStatic {
        /**
        * Invokes the method named by methodName on each element in the collection returning
        * an array of the results of each invoked method. Additional arguments will be provided
        * to each invoked method. If methodName is a function it will be invoked for, and this
        * bound to, each element in the collection.
        * @param collection The collection to iterate over.
        * @param methodName The name of the method to invoke.
        * @param args Arguments to invoke the method with.
         */
        invokeMap(collection: object | null | undefined, methodName: string, ...args: any[]): any[];
        /**
         * @see _.invokeMap
         */
        invokeMap<TResult>(collection: object | null | undefined, method: (...args: any[]) => TResult, ...args: any[]): TResult[];
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.invokeMap
         */
        invokeMap(methodName: string, ...args: any[]): Collection<any>;
        /**
         * @see _.invokeMap
         */
        invokeMap<TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.invokeMap
         */
        invokeMap(methodName: string, ...args: any[]): CollectionChain<any>;
        /**
         * @see _.invokeMap
         */
        invokeMap<TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>;
    }
    interface LoDashStatic {
        /**
         * Creates an object composed of keys generated from the results of running each element of collection through
         * iteratee. The corresponding value of each key is the last element responsible for generating the key. The
         * iteratee function is invoked with one argument: (value).
         *
         * @param collection The collection to iterate over.
         * @param iteratee The function invoked per iteration.
         * @return Returns the composed aggregate object.
         */
        keyBy<T>(collection: List<T> | null | undefined, iteratee?: ValueIterateeCustom<T, PropertyName>): Dictionary<T>;
        /**
         * @see _.keyBy
         */
        keyBy<T extends object>(collection: T | null | undefined, iteratee?: ValueIterateeCustom<T[keyof T], PropertyName>): Dictionary<T[keyof T]>;
    }
    interface String {
        /**
         * @see _.keyBy
         */
        keyBy(iteratee?: ValueIterateeCustom<string, PropertyName>): Object<Dictionary<string>>;
    }
    interface Collection<T> {
        /**
         * @see _.keyBy
         */
        keyBy(iteratee?: ValueIterateeCustom<T, PropertyName>): Object<Dictionary<T>>;
    }
    interface Object<T> {
        /**
         * @see _.keyBy
         */
        keyBy(iteratee?: ValueIterateeCustom<T[keyof T], PropertyName>): Object<Dictionary<T[keyof T]>>;
    }
    interface StringChain {
        /**
         * @see _.keyBy
         */
        keyBy(iteratee?: ValueIterateeCustom<string, PropertyName>): ObjectChain<Dictionary<string>>;
    }
    interface StringNullableChain {
        /**
         * @see _.keyBy
         */
        keyBy(iteratee?: ValueIterateeCustom<string, PropertyName>): ObjectChain<Dictionary<string>>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.keyBy
         */
        keyBy(iteratee?: ValueIterateeCustom<T, PropertyName>): ObjectChain<Dictionary<T>>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.keyBy
         */
        keyBy(iteratee?: ValueIterateeCustom<T[keyof T], PropertyName>): ObjectChain<Dictionary<T[keyof T]>>;
    }
    interface LoDashStatic {
        /**
         * Creates an array of values by running each element in collection through iteratee. The iteratee is
         * invoked with three arguments: (value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like _.every, _.filter, _.map, _.mapValues,
         * _.reject, and _.some.
         *
         * The guarded methods are:
         * ary, callback, chunk, clone, create, curry, curryRight, drop, dropRight, every, fill, flatten, invert, max,
         * min, parseInt, slice, sortBy, take, takeRight, template, trim, trimLeft, trimRight, trunc, random, range,
         * sample, some, sum, uniq, and words
         *
         * @param collection The collection to iterate over.
         * @param iteratee The function invoked per iteration.
         * @return Returns the new mapped array.
         */
        map<T, TResult>(collection: T[] | null | undefined, iteratee: ArrayIterator<T, TResult>): TResult[];
        /**
         * @see _.map
         */
        map<T, TResult>(collection: List<T> | null | undefined, iteratee: ListIterator<T, TResult>): TResult[];
        /**
         * @see _.map
         */
        map<T>(collection: Dictionary<T> | NumericDictionary<T> | null | undefined): T[];
        /**
         * @see _.map
         */
        map<T extends object, TResult>(collection: T | null | undefined, iteratee: ObjectIterator<T, TResult>): TResult[];
        /**
         * @see _.map
         */
        map<T, K extends keyof T>(collection: Dictionary<T> | NumericDictionary<T> | null | undefined, iteratee: K): Array<T[K]>;
        /**
         * @see _.map
         */
        map<T>(collection: Dictionary<T> | NumericDictionary<T> | null | undefined, iteratee?: string): any[];
        /**
         * @see _.map
         */
        map<T>(collection: Dictionary<T> | NumericDictionary<T> | null | undefined, iteratee?: object): boolean[];
    }

    interface String {
        /**
         * @see _.map
         */
        map<TResult>(iteratee: StringIterator<TResult>): Collection<TResult>;
        /**
         * @see _.map
         */
        map(): Collection<string>;
    }
    interface Collection<T> {
        /**
         * @see _.map
         */
        map<K extends keyof T>(key: K): Collection<T[K]>;
        /**
         * @see _.map
         */
        map<TResult>(iteratee: ListIterator<T, TResult>): Collection<TResult>;
        /**
         * @see _.map
         */
        map(iteratee: PropertyName): Collection<any>;
        /**
         * @see _.map
         */
        map(iteratee: [PropertyName, any] | object): Collection<boolean>;
        /**
         * @see _.map
         */
        map(): Collection<T>;
    }
    interface Object<T> {
        /**
         * @see _.map
         */
        map<K extends keyof T[keyof T]>(key: K): Collection<T[keyof T][K]>;
        /**
         * @see _.map
         */
        map<TResult>(iteratee: ObjectIterator<T, TResult>): Collection<TResult>;
        /**
         * @see _.map
         */
        map(iteratee: PropertyName): Collection<any>;
        /**
         * @see _.map
         */
        map(iteratee: [PropertyName, any] | object): Collection<boolean>;
        /**
         * @see _.map
         */
        map(): Collection<T[keyof T]>;
    }
    interface StringChain {
        /**
         * @see _.map
         */
        map<TResult>(iteratee: StringIterator<TResult>): CollectionChain<TResult>;
        /**
         * @see _.map
         */
        map(): CollectionChain<string>;
    }
    interface StringNullableChain {
        /**
         * @see _.map
         */
        map<TResult>(iteratee: StringIterator<TResult>): CollectionChain<TResult>;
        /**
         * @see _.map
         */
        map(): CollectionChain<string>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.map
         */
        map<K extends keyof T>(key: K): CollectionChain<T[K]>;
        /**
         * @see _.map
         */
        map<TResult>(iteratee: ListIterator<T, TResult>): CollectionChain<TResult>;
        /**
         * @see _.map
         */
        map(iteratee: PropertyName): CollectionChain<any>;
        /**
         * @see _.map
         */
        map(iteratee: [PropertyName, any] | object): CollectionChain<boolean>;
        /**
         * @see _.map
         */
        map(): CollectionChain<T>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.map
         */
        map<K extends keyof T[keyof T]>(key: K): CollectionChain<T[keyof T][K]>;
        /**
         * @see _.map
         */
        map<TResult>(iteratee: ObjectIterator<T, TResult>): CollectionChain<TResult>;
        /**
         * @see _.map
         */
        map(iteratee: PropertyName): CollectionChain<any>;
        /**
         * @see _.map
         */
        map(iteratee: [PropertyName, any] | object): CollectionChain<boolean>;
        /**
         * @see _.map
         */
        map(): CollectionChain<T[keyof T]>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.sortBy` except that it allows specifying the sort
         * orders of the iteratees to sort by. If `orders` is unspecified, all values
         * are sorted in ascending order. Otherwise, specify an order of "desc" for
         * descending or "asc" for ascending sort order of corresponding values.
         *
         * @category Collection
         * @param collection The collection to iterate over.
         * @param [iteratees=[_.identity]] The iteratees to sort by.
         * @param [orders] The sort orders of `iteratees`.
         * @param [guard] Enables use as an iteratee for functions like `_.reduce`.
         * @returns Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 34 },
         *   { 'user': 'fred',   'age': 42 },
         *   { 'user': 'barney', 'age': 36 }
         * ];
         *
         * // sort by `user` in ascending order and by `age` in descending order
         * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
         */
        orderBy<T>(collection: List<T> | null | undefined, iteratees?: Many<ListIterator<T, NotVoid>>, orders?: Many<boolean|"asc"|"desc">): T[];
        /**
         * @see _.orderBy
         */
        orderBy<T>(collection: List<T> | null | undefined, iteratees?: Many<ListIteratee<T>>, orders?: Many<boolean|"asc"|"desc">): T[];
        /**
         * @see _.orderBy
         */
        orderBy<T extends object>(collection: T | null | undefined, iteratees?: Many<ObjectIterator<T, NotVoid>>, orders?: Many<boolean|"asc"|"desc">): Array<T[keyof T]>;
        /**
         * @see _.orderBy
         */
        orderBy<T extends object>(collection: T | null | undefined, iteratees?: Many<ObjectIteratee<T>>, orders?: Many<boolean|"asc"|"desc">): Array<T[keyof T]>;
    }
    interface Collection<T> {
        /**
         * @see _.orderBy
         */
        orderBy(iteratees?: Many<ListIterator<T, NotVoid> | PropertyName | PartialShallow<T>>, orders?: Many<boolean|"asc"|"desc">): Collection<T>;
    }
    interface Object<T> {
        /**
         * @see _.orderBy
         */
        orderBy(iteratees?: Many<ObjectIterator<T, NotVoid>>, orders?: Many<boolean|"asc"|"desc">): Collection<T[keyof T]>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.orderBy
         */
        orderBy(iteratees?: Many<ListIterator<T, NotVoid> | PropertyName | PartialShallow<T>>, orders?: Many<boolean|"asc"|"desc">): CollectionChain<T>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.orderBy
         */
        orderBy(iteratees?: Many<ObjectIterator<T, NotVoid>>, orders?: Many<boolean|"asc"|"desc">): CollectionChain<T[keyof T]>;
    }
    interface LoDashStatic {
        /**
        * Creates an array of elements split into two groups, the first of which contains elements predicate returns truthy for,
        * while the second of which contains elements predicate returns falsey for.
        * The predicate is invoked with three arguments: (value, index|key, collection).
        *
        * @param collection The collection to iterate over.
        * @param callback The function called per iteration.
        * @return Returns the array of grouped elements.
         */
        partition<T, U extends T>(collection: List<T> | null | undefined, callback: ValueIteratorTypeGuard<T, U>): [U[], Array<Exclude<T, U>>];
        /**
         * @see _.partition
         */
        partition<T>(collection: List<T> | null | undefined, callback: ValueIteratee<T>): [T[], T[]];
        /**
         * @see _.partition
         */
        partition<T extends object>(collection: T | null | undefined, callback: ValueIteratee<T[keyof T]>): [Array<T[keyof T]>, Array<T[keyof T]>];
    }
    interface String {
        /**
         * @see _.partition
         */
        partition(callback: StringIterator<NotVoid>): LoDashImplicitWrapper<[string[], string[]]>;
    }
    interface Collection<T> {
        /**
         * @see _.partition
         */
        partition<U extends T>(callback: ValueIteratorTypeGuard<T, U>): LoDashImplicitWrapper<[U[], Array<Exclude<T, U>>]>;
        /**
         * @see _.partition
         */
        partition(callback: ValueIteratee<T>): LoDashImplicitWrapper<[T[], T[]]>;
    }
    interface Object<T> {
        /**
         * @see _.partition
         */
        partition(callback: ValueIteratee<T[keyof T]>): LoDashImplicitWrapper<[Array<T[keyof T]>, Array<T[keyof T]>]>;
    }
    interface StringChain {
        /**
         * @see _.partition
         */
        partition(callback: StringIterator<NotVoid>): LoDashExplicitWrapper<[string[], string[]]>;
    }
    interface StringNullableChain {
        /**
         * @see _.partition
         */
        partition(callback: StringIterator<NotVoid>): LoDashExplicitWrapper<[string[], string[]]>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.partition
         */
        partition<U extends T>(callback: ValueIteratorTypeGuard<T, U>): LoDashExplicitWrapper<[U[], Array<Exclude<T, U>>]>;
        /**
         * @see _.partition
         */
        partition(callback: ValueIteratee<T>): LoDashExplicitWrapper<[T[], T[]]>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.partition
         */
        partition(callback: ValueIteratee<T[keyof T]>): LoDashExplicitWrapper<[Array<T[keyof T]>, Array<T[keyof T]>]>;
    }
    interface LoDashStatic {
        /**
        * Reduces a collection to a value which is the accumulated result of running each
        * element in the collection through the callback, where each successive callback execution
        * consumes the return value of the previous execution. If accumulator is not provided the
        * first element of the collection will be used as the initial accumulator value. The callback
        * is invoked with four arguments: (accumulator, value, index|key, collection).
        * @param collection The collection to iterate over.
        * @param callback The function called per iteration.
        * @param accumulator Initial value of the accumulator.
        * @return Returns the accumulated value.
         */
        reduce<T, TResult>(collection: T[] | null | undefined, callback: MemoListIterator<T, TResult, T[]>, accumulator: TResult): TResult;
        /**
         * @see _.reduce
         */
        reduce<T, TResult>(collection: List<T> | null | undefined, callback: MemoListIterator<T, TResult, List<T>>, accumulator: TResult): TResult;
        /**
         * @see _.reduce
         */
        reduce<T extends object, TResult>(collection: T | null | undefined, callback: MemoObjectIterator<T[keyof T], TResult, T>, accumulator: TResult): TResult;
        /**
         * @see _.reduce
         */
        reduce<T>(collection: T[] | null | undefined, callback: MemoListIterator<T, T, T[]>): T | undefined;
        /**
         * @see _.reduce
         */
        reduce<T>(collection: List<T> | null | undefined, callback: MemoListIterator<T, T, List<T>>): T | undefined;
        /**
         * @see _.reduce
         */
        reduce<T extends object>(collection: T | null | undefined, callback: MemoObjectIterator<T[keyof T], T[keyof T], T>): T[keyof T] | undefined;
    }
    interface Collection<T> {
        /**
         * @see _.reduce
         */
        reduce<TResult>(callback: MemoListIterator<T, TResult, List<T>>, accumulator: TResult): TResult;
        /**
         * @see _.reduce
         */
        reduce(callback: MemoListIterator<T, T, List<T>>): T | undefined;
    }
    interface Object<T> {
        /**
         * @see _.reduce
         */
        reduce<TResult>(callback: MemoObjectIterator<T[keyof T], TResult, T>, accumulator: TResult): TResult;
        /**
         * @see _.reduce
         */
        reduce(callback: MemoObjectIterator<T[keyof T], T[keyof T], T>): T[keyof T] | undefined;
    }
    interface CollectionChain<T> {
        /**
         * @see _.reduce
         */
        reduce<TResult>(callback: MemoListIterator<T, TResult, List<T>>, accumulator: TResult): ExpChain<TResult>;
        /**
         * @see _.reduce
         */
        reduce(callback: MemoListIterator<T, T, List<T>>): ExpChain<T | undefined>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.reduce
         */
        reduce<TResult>(callback: MemoObjectIterator<T[keyof T], TResult, T>, accumulator: TResult): ExpChain<TResult>;
        /**
         * @see _.reduce
         */
        reduce(callback: MemoObjectIterator<T[keyof T], T[keyof T], T>): ExpChain<T[keyof T] | undefined>;
    }
    interface LoDashStatic {
        /**
        * This method is like _.reduce except that it iterates over elements of a collection from
        * right to left.
        * @param collection The collection to iterate over.
        * @param callback The function called per iteration.
        * @param accumulator Initial value of the accumulator.
        * @return The accumulated value.
         */
        reduceRight<T, TResult>(collection: T[] | null | undefined, callback: MemoListIterator<T, TResult, T[]>, accumulator: TResult): TResult;
        /**
         * @see _.reduceRight
         */
        reduceRight<T, TResult>(collection: List<T> | null | undefined, callback: MemoListIterator<T, TResult, List<T>>, accumulator: TResult): TResult;
        /**
         * @see _.reduceRight
         */
        reduceRight<T extends object, TResult>(collection: T | null | undefined, callback: MemoObjectIterator<T[keyof T], TResult, T>, accumulator: TResult): TResult;
        /**
         * @see _.reduceRight
         */
        reduceRight<T>(collection: T[] | null | undefined, callback: MemoListIterator<T, T, T[]>): T | undefined;
        /**
         * @see _.reduceRight
         */
        reduceRight<T>(collection: List<T> | null | undefined, callback: MemoListIterator<T, T, List<T>>): T | undefined;
        /**
         * @see _.reduceRight
         */
        reduceRight<T extends object>(collection: T | null | undefined, callback: MemoObjectIterator<T[keyof T], T[keyof T], T>): T[keyof T] | undefined;
    }
    interface Collection<T> {
        /**
         * @see _.reduceRight
         */
        reduceRight<TResult>(callback: MemoListIterator<T, TResult, List<T>>, accumulator: TResult): TResult;
        /**
         * @see _.reduceRight
         */
        reduceRight(callback: MemoListIterator<T, T, List<T>>): T | undefined;
    }
    interface Object<T> {
        /**
         * @see _.reduceRight
         */
        reduceRight<TResult>(callback: MemoObjectIterator<T[keyof T], TResult, T>, accumulator: TResult): TResult;
        /**
         * @see _.reduceRight
         */
        reduceRight(callback: MemoObjectIterator<T[keyof T], T[keyof T], T>): T[keyof T] | undefined;
    }
    interface CollectionChain<T> {
        /**
         * @see _.reduceRight
         */
        reduceRight<TResult>(callback: MemoListIterator<T, TResult, List<T>>, accumulator: TResult): ExpChain<TResult>;
        /**
         * @see _.reduceRight
         */
        reduceRight(callback: MemoListIterator<T, T, List<T>>): ExpChain<T | undefined>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.reduceRight
         */
        reduceRight<TResult>(callback: MemoObjectIterator<T[keyof T], TResult, T>, accumulator: TResult): ExpChain<TResult>;
        /**
         * @see _.reduceRight
         */
        reduceRight(callback: MemoObjectIterator<T[keyof T], T[keyof T], T>): ExpChain<T[keyof T] | undefined>;
    }
    interface LoDashStatic {
        /**
         * The opposite of _.filter; this method returns the elements of collection that predicate does not return
         * truthy for.
         *
         * @param collection The collection to iterate over.
         * @param predicate The function invoked per iteration.
         * @return Returns the new filtered array.
         */
        reject(collection: string | null | undefined, predicate?: StringIterator<boolean>): string[];
        /**
         * @see _.reject
         */
        reject<T>(collection: List<T> | null | undefined, predicate?: ListIterateeCustom<T, boolean>): T[];
        /**
         * @see _.reject
         */
        reject<T extends object>(collection: T | null | undefined, predicate?: ObjectIterateeCustom<T, boolean>): Array<T[keyof T]>;
    }
    interface String {
        /**
         * @see _.reject
         */
        reject(predicate?: StringIterator<boolean>): Collection<string>;
    }
    interface Collection<T> {
        /**
         * @see _.reject
         */
        reject(predicate?: ListIterateeCustom<T, boolean>): Collection<T>;
    }
    interface Object<T> {
        /**
         * @see _.reject
         */
        reject(predicate?: ObjectIterateeCustom<T, boolean>): Collection<T[keyof T]>;
    }
    interface StringChain {
        /**
         * @see _.reject
         */
        reject(predicate?: StringIterator<boolean>): CollectionChain<string>;
    }
    interface StringNullableChain {
        /**
         * @see _.reject
         */
        reject(predicate?: StringIterator<boolean>): CollectionChain<string>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.reject
         */
        reject(predicate?: ListIterateeCustom<T, boolean>): CollectionChain<T>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.reject
         */
        reject(predicate?: ObjectIterateeCustom<T, boolean>): CollectionChain<T[keyof T]>;
    }
    interface LoDashStatic {
        /**
         * Gets a random element from collection.
         *
         * @param collection The collection to sample.
         * @return Returns the random element.
         */
        sample<T>(collection: readonly [T, ...T[]]): T;
        /**
         * @see _.sample
         */
        sample<T>(collection: Dictionary<T> | NumericDictionary<T> | null | undefined): T | undefined;
        /**
         * @see _.sample
         */
        sample<T extends object>(collection: T | null | undefined): T[keyof T] | undefined;
    }
    interface String {
        /**
         * @see _.sample
         */
        sample(): string | undefined;
    }
    interface Collection<T> {
        /**
         * @see _.sample
         */
        sample(): T | undefined;
    }
    interface Object<T> {
        /**
         * @see _.sample
         */
        sample(): T[keyof T] | undefined;
    }
    interface StringChain {
        /**
         * @see _.sample
         */
        sample(): StringNullableChain;
    }
    interface StringNullableChain {
        /**
         * @see _.sample
         */
        sample(): StringNullableChain;
    }
    interface CollectionChain<T> {
        /**
         * @see _.sample
         */
        sample(): ExpChain<T | undefined>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.sample
         */
        sample(): ExpChain<T[keyof T] | undefined>;
    }
    interface LoDashStatic {
        /**
         * Gets n random elements at unique keys from collection up to the size of collection.
         *
         * @param collection The collection to sample.
         * @param n The number of elements to sample.
         * @return Returns the random elements.
         */
        sampleSize<T>(collection: Dictionary<T> | NumericDictionary<T> | null | undefined, n?: number): T[];
        /**
         * @see _.sampleSize
         */
        sampleSize<T extends object>(collection: T | null | undefined, n?: number): Array<T[keyof T]>;
    }
    interface String {
        /**
         * @see _.sampleSize
         */
        sampleSize(n?: number): Collection<string>;
    }
    interface Collection<T> {
        /**
         * @see _.sampleSize
         */
        sampleSize(n?: number): Collection<T>;
    }
    interface Object<T> {
        /**
         * @see _.sampleSize
         */
        sampleSize(n?: number): Collection<T[keyof T]>;
    }
    interface StringChain {
        /**
         * @see _.sampleSize
         */
        sampleSize(n?: number): CollectionChain<string>;
    }
    interface StringNullableChain {
        /**
         * @see _.sampleSize
         */
        sampleSize(n?: number): CollectionChain<string>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.sampleSize
         */
        sampleSize(n?: number): CollectionChain<T>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.sampleSize
         */
        sampleSize(n?: number): CollectionChain<T[keyof T]>;
    }
    interface LoDashStatic {
        /**
         * Creates an array of shuffled values, using a version of the Fisher-Yates shuffle.
         *
         * @param collection The collection to shuffle.
         * @return Returns the new shuffled array.
         */
        shuffle<T>(collection: List<T> | null | undefined): T[];
        /**
         * @see _.shuffle
         */
        shuffle<T extends object>(collection: T | null | undefined): Array<T[keyof T]>;
    }
    interface String {
        /**
         * @see _.shuffle
         */
        shuffle(): Collection<string>;
    }
    interface Collection<T> {
        /**
         * @see _.shuffle
         */
        shuffle(): Collection<T>;
    }
    interface Object<T> {
        /**
         * @see _.shuffle
         */
        shuffle(): Collection<T[keyof T]>;
    }
    interface StringChain {
        /**
         * @see _.shuffle
         */
        shuffle(): CollectionChain<string>;
    }
    interface StringNullableChain {
        /**
         * @see _.shuffle
         */
        shuffle(): CollectionChain<string>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.shuffle
         */
        shuffle(): CollectionChain<T>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.shuffle
         */
        shuffle(): CollectionChain<T[keyof T]>;
    }
    interface LoDashStatic {
        /**
         * Gets the size of collection by returning its length for array-like values or the number of own enumerable
         * properties for objects.
         *
         * @param collection The collection to inspect.
         * @return Returns the size of collection.
         */
        size(collection: object | string | null | undefined): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.size
         */
        size(): number;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.size
         */
        size(): PrimitiveChain<number>;
    }
    interface LoDashStatic {
        /**
         * Checks if predicate returns truthy for any element of collection. Iteration is stopped once predicate
         * returns truthy. The predicate is invoked with three arguments: (value, index|key, collection).
         *
         * @param collection The collection to iterate over.
         * @param predicate The function invoked per iteration.
         * @return Returns true if any element passes the predicate check, else false.
         */
        some<T>(collection: List<T> | null | undefined, predicate?: ListIterateeCustom<T, boolean>): boolean;
        /**
         * @see _.some
         */
        some<T extends object>(collection: T | null | undefined, predicate?: ObjectIterateeCustom<T, boolean>): boolean;
    }
    interface Collection<T> {
        /**
         * @see _.some
         */
        some(predicate?: ListIterateeCustom<T, boolean>): boolean;
    }
    interface Object<T> {
        /**
         * @see _.some
         */
        some(predicate?: ObjectIterateeCustom<T, boolean>): boolean;
    }
    interface CollectionChain<T> {
        /**
         * @see _.some
         */
        some(predicate?: ListIterateeCustom<T, boolean>): PrimitiveChain<boolean>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.some
         */
        some(predicate?: ObjectIterateeCustom<T, boolean>): PrimitiveChain<boolean>;
    }
    interface LoDashStatic {
        /**
         * Creates an array of elements, sorted in ascending order by the results of
         * running each element in a collection through each iteratee. This method
         * performs a stable sort, that is, it preserves the original sort order of
         * equal elements. The iteratees are invoked with one argument: (value).
         *
         * @category Collection
         * @param collection The collection to iterate over.
         * @param [iteratees=[_.identity]]
         *  The iteratees to sort by, specified individually or in arrays.
         * @returns Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 42 },
         *   { 'user': 'barney', 'age': 34 }
         * ];
         *
         * _.sortBy(users, function(o) { return o.user; });
         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
         *
         * _.sortBy(users, ['user', 'age']);
         * // => objects for [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
         *
         * _.sortBy(users, 'user', function(o) {
         *   return Math.floor(o.age / 10);
         * });
         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
         */
        sortBy<T>(collection: List<T> | null | undefined, ...iteratees: Array<Many<ListIteratee<T>>>): T[];
        /**
         * @see _.sortBy
         */
        sortBy<T extends object>(collection: T | null | undefined, ...iteratees: Array<Many<ObjectIteratee<T>>>): Array<T[keyof T]>;
    }
    interface Collection<T> {
        /**
         * @see _.sortBy
         */
        sortBy(...iteratees: Array<Many<ListIteratee<T>>>): Collection<T>;
    }
    interface Object<T> {
        /**
         * @see _.sortBy
         */
        sortBy(...iteratees: Array<Many<ObjectIteratee<T>>>): Collection<T[keyof T]>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.sortBy
         */
        sortBy(...iteratees: Array<Many<ListIteratee<T>>>): CollectionChain<T>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.sortBy
         */
        sortBy(...iteratees: Array<Many<ObjectIteratee<T>>>): CollectionChain<T[keyof T]>;
    }
}
import _ = require("../index");
// eslint-disable-next-line @definitelytyped/strict-export-declare-modifiers
type GlobalPartial<T> = Partial<T>;
export const uniqueSymbol: unique symbol;
declare module "../index" {
    type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;
    type PartialObject<T> = GlobalPartial<T>;
    type Many<T> = T | readonly T[];
    type ImpChain<T> =
        T extends { __trapAny: any } ? Collection<any> & Function<any> & Object<any> & Primitive<any> & String :
        T extends null | undefined ? never :
        T extends string | null | undefined ? String :
        T extends (...args: any) => any ? Function<T> :
        T extends List<infer U> | null | undefined ? Collection<U> :
        T extends object | null | undefined ? Object<T> :
        Primitive<T>;
    type ExpChain<T> =
        T extends { __trapAny: any } ? CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain :
        T extends null | undefined ? never :
        T extends string ? StringChain :
        T extends string | null | undefined ? StringNullableChain :
        T extends (...args: any) => any ? FunctionChain<T> :
        T extends List<infer U> | null | undefined ? CollectionChain<U> :
        T extends object | null | undefined ? ObjectChain<T> :
        PrimitiveChain<T>;
    interface LoDashStatic {
        /**
        * Creates a lodash object which wraps value to enable implicit method chain sequences.
        * Methods that operate on and return arrays, collections, and functions can be chained together.
        * Methods that retrieve a single value or may return a primitive value will automatically end the
        * chain sequence and return the unwrapped value. Otherwise, the value must be unwrapped with value().
        *
        * Explicit chain sequences, which must be unwrapped with value(), may be enabled using _.chain.
        *
        * The execution of chained methods is lazy, that is, it's deferred until value() is
        * implicitly or explicitly called.
        *
        * Lazy evaluation allows several methods to support shortcut fusion. Shortcut fusion
        * is an optimization to merge iteratee calls; this avoids the creation of intermediate
        * arrays and can greatly reduce the number of iteratee executions. Sections of a chain
        * sequence qualify for shortcut fusion if the section is applied to an array and iteratees
        * accept only one argument. The heuristic for whether a section qualifies for shortcut
        * fusion is subject to change.
        *
        * Chaining is supported in custom builds as long as the value() method is directly or
        * indirectly included in the build.
        *
        * In addition to lodash methods, wrappers have Array and String methods.
        * The wrapper Array methods are:
        * concat, join, pop, push, shift, sort, splice, and unshift.
        * The wrapper String methods are:
        * replace and split.
        *
        * The wrapper methods that support shortcut fusion are:
        * at, compact, drop, dropRight, dropWhile, filter, find, findLast, head, initial, last,
        * map, reject, reverse, slice, tail, take, takeRight, takeRightWhile, takeWhile, and toArray
        *
        * The chainable wrapper methods are:
        * after, ary, assign, assignIn, assignInWith, assignWith, at, before, bind, bindAll, bindKey,
        * castArray, chain, chunk, commit, compact, concat, conforms, constant, countBy, create,
        * curry, debounce, defaults, defaultsDeep, defer, delay, difference, differenceBy, differenceWith,
        * drop, dropRight, dropRightWhile, dropWhile, extend, extendWith, fill, filter, flatMap,
        * flatMapDeep, flatMapDepth, flatten, flattenDeep, flattenDepth, flip, flow, flowRight,
        * fromPairs, functions, functionsIn, groupBy, initial, intersection, intersectionBy, intersectionWith,
        * invert, invertBy, invokeMap, iteratee, keyBy, keys, keysIn, map, mapKeys, mapValues,
        * matches, matchesProperty, memoize, merge, mergeWith, method, methodOf, mixin, negate,
        * nthArg, omit, omitBy, once, orderBy, over, overArgs, overEvery, overSome, partial, partialRight,
        * partition, pick, pickBy, plant, property, propertyOf, pull, pullAll, pullAllBy, pullAllWith, pullAt,
        * push, range, rangeRight, rearg, reject, remove, rest, reverse, sampleSize, set, setWith,
        * shuffle, slice, sort, sortBy, sortedUniq, sortedUniqBy, splice, spread, tail, take,
        * takeRight, takeRightWhile, takeWhile, tap, throttle, thru, toArray, toPairs, toPairsIn,
        * toPath, toPlainObject, transform, unary, union, unionBy, unionWith, uniq, uniqBy, uniqWith,
        * unset, unshift, unzip, unzipWith, update, updateWith, values, valuesIn, without, wrap,
        * xor, xorBy, xorWith, zip, zipObject, zipObjectDeep, and zipWith.
        *
        * The wrapper methods that are not chainable by default are:
        * add, attempt, camelCase, capitalize, ceil, clamp, clone, cloneDeep, cloneDeepWith, cloneWith,
        * conformsTo, deburr, defaultTo, divide, each, eachRight, endsWith, eq, escape, escapeRegExp,
        * every, find, findIndex, findKey, findLast, findLastIndex, findLastKey, first, floor, forEach,
        * forEachRight, forIn, forInRight, forOwn, forOwnRight, get, gt, gte, has, hasIn, head,
        * identity, includes, indexOf, inRange, invoke, isArguments, isArray, isArrayBuffer,
        * isArrayLike, isArrayLikeObject, isBoolean, isBuffer, isDate, isElement, isEmpty, isEqual, isEqualWith,
        * isError, isFinite, isFunction, isInteger, isLength, isMap, isMatch, isMatchWith, isNaN,
        * isNative, isNil, isNull, isNumber, isObject, isObjectLike, isPlainObject, isRegExp,
        * isSafeInteger, isSet, isString, isUndefined, isTypedArray, isWeakMap, isWeakSet, join,
        * kebabCase, last, lastIndexOf, lowerCase, lowerFirst, lt, lte, max, maxBy, mean, meanBy,
        * min, minBy, multiply, noConflict, noop, now, nth, pad, padEnd, padStart, parseInt, pop,
        * random, reduce, reduceRight, repeat, result, round, runInContext, sample, shift, size,
        * snakeCase, some, sortedIndex, sortedIndexBy, sortedLastIndex, sortedLastIndexBy, startCase,
        * startsWith, stubArray, stubFalse, stubObject, stubString, stubTrue, subtract, sum, sumBy,
        * template, times, toFinite, toInteger, toJSON, toLength, toLower, toNumber, toSafeInteger,
        * toString, toUpper, trim, trimEnd, trimStart, truncate, unescape, uniqueId, upperCase,
        * upperFirst, value, and words.
        **/
        <TrapAny extends { __trapAny: any }>(value: TrapAny): Collection<any> & Function<any> & Object<any> & Primitive<any> & String;
        <T extends null | undefined>(value: T): Primitive<T>;
        (value: string | null | undefined): String;
        <T extends (...args: any) => any>(value: T): Function<T>;
        <T = any>(value: List<T> | null | undefined): Collection<T>;
        <T extends object>(value: T | null | undefined): Object<T>;
        <T>(value: T): Primitive<T>;
        /**
        * The semantic version number.
        **/
        VERSION: string;
        /**
        * By default, the template delimiters used by Lo-Dash are similar to those in embedded Ruby
        * (ERB). Change the following template settings to use alternative delimiters.
        **/
        templateSettings: TemplateSettings;
    }
    /**
    * By default, the template delimiters used by Lo-Dash are similar to those in embedded Ruby
    * (ERB). Change the following template settings to use alternative delimiters.
    **/
    interface TemplateSettings {
        /**
        * The "escape" delimiter.
        **/
        escape?: RegExp | undefined;
        /**
        * The "evaluate" delimiter.
        **/
        evaluate?: RegExp | undefined;
        /**
        * An object to import into the template as local variables.
        */
        imports?: Dictionary<any> | undefined;
        /**
        * The "interpolate" delimiter.
        */
        interpolate?: RegExp | undefined;
        /**
        * Used to reference the data object in the template text.
        */
        variable?: string | undefined;
    }
    /**
     * Creates a cache object to store key/value pairs.
     */
    interface MapCache {
        /**
         * Removes `key` and its value from the cache.
         * @param key The key of the value to remove.
         * @return Returns `true` if the entry was removed successfully, else `false`.
         */
        delete(key: any): boolean;
        /**
         * Gets the cached value for `key`.
         * @param key The key of the value to get.
         * @return Returns the cached value.
         */
        get(key: any): any;
        /**
         * Checks if a cached value for `key` exists.
         * @param key The key of the entry to check.
         * @return Returns `true` if an entry for `key` exists, else `false`.
         */
        has(key: any): boolean;
        /**
         * Sets `value` to `key` of the cache.
         * @param key The key of the value to cache.
         * @param value The value to cache.
         * @return Returns the cache object.
         */
        set(key: any, value: any): this;
        /**
         * Removes all key-value entries from the map.
         */
        clear?: (() => void) | undefined;
    }
    interface MapCacheConstructor {
        new (): MapCache;
    }
    interface Collection<T> {
        pop(): T | undefined;
        push(...items: T[]): this;
        shift(): T | undefined;
        sort(compareFn?: (a: T, b: T) => number): this;
        splice(start: number, deleteCount?: number, ...items: T[]): this;
        unshift(...items: T[]): this;
    }
    interface CollectionChain<T> {
        pop(): ExpChain<T | undefined>;
        push(...items: T[]): this;
        shift(): ExpChain<T | undefined>;
        sort(compareFn?: (a: T, b: T) => number): this;
        splice(start: number, deleteCount?: number, ...items: T[]): this;
        unshift(...items: T[]): this;
    }
    interface Function<T extends (...args: any) => any> extends LoDashImplicitWrapper<T> {
    }
    interface String extends LoDashImplicitWrapper<string> {
    }
    interface Object<T> extends LoDashImplicitWrapper<T> {
    }
    interface Collection<T> extends LoDashImplicitWrapper<T[]> {
    }
    interface Primitive<T> extends LoDashImplicitWrapper<T> {
    }
    interface FunctionChain<T extends (...args: any) => any> extends LoDashExplicitWrapper<T> {
    }
    interface StringChain extends LoDashExplicitWrapper<string> {
    }
    interface StringNullableChain extends LoDashExplicitWrapper<string | undefined> {
    }
    interface ObjectChain<T> extends LoDashExplicitWrapper<T> {
    }
    interface CollectionChain<T> extends LoDashExplicitWrapper<T[]> {
    }
    interface PrimitiveChain<T> extends LoDashExplicitWrapper<T> {
    }
    type NotVoid = unknown;
    type IterateeShorthand<T> = PropertyName | [PropertyName, any] | PartialShallow<T>;
    type ArrayIterator<T, TResult> = (value: T, index: number, collection: T[]) => TResult;
    type ListIterator<T, TResult> = (value: T, index: number, collection: List<T>) => TResult;
    type ListIteratee<T> = ListIterator<T, NotVoid> | IterateeShorthand<T>;
    type ListIterateeCustom<T, TResult> = ListIterator<T, TResult> | IterateeShorthand<T>;
    type ListIteratorTypeGuard<T, S extends T> = (value: T, index: number, collection: List<T>) => value is S;
    // Note: key should be string, not keyof T, because the actual object may contain extra properties that were not specified in the type.
    type ObjectIterator<TObject, TResult> = (value: TObject[keyof TObject], key: string, collection: TObject) => TResult;
    type ObjectIteratee<TObject> = ObjectIterator<TObject, NotVoid> | IterateeShorthand<TObject[keyof TObject]>;
    type ObjectIterateeCustom<TObject, TResult> = ObjectIterator<TObject, TResult> | IterateeShorthand<TObject[keyof TObject]>;
    type ObjectIteratorTypeGuard<TObject, S extends TObject[keyof TObject]> = (value: TObject[keyof TObject], key: string, collection: TObject) => value is S;
    type StringIterator<TResult> = (char: string, index: number, string: string) => TResult;
    /** @deprecated Use MemoVoidArrayIterator or MemoVoidDictionaryIterator instead. */
    type MemoVoidIterator<T, TResult> = (prev: TResult, curr: T, indexOrKey: any, list: T[]) => void;
    /** @deprecated Use MemoListIterator or MemoObjectIterator instead. */
    type MemoIterator<T, TResult> = (prev: TResult, curr: T, indexOrKey: any, list: T[]) => TResult;
    type MemoListIterator<T, TResult, TList> = (prev: TResult, curr: T, index: number, list: TList) => TResult;
    type MemoObjectIterator<T, TResult, TList> = (prev: TResult, curr: T, key: string, list: TList) => TResult;
    type MemoIteratorCapped<T, TResult> = (prev: TResult, curr: T) => TResult;
    type MemoIteratorCappedRight<T, TResult> = (curr: T, prev: TResult) => TResult;
    type MemoVoidArrayIterator<T, TResult> = (acc: TResult, curr: T, index: number, arr: T[]) => void;
    type MemoVoidDictionaryIterator<T, K extends string | number | symbol, TResult> = (acc: TResult, curr: T, key: K, dict: Record<K, T>) => void;
    type MemoVoidIteratorCapped<T, TResult> = (acc: TResult, curr: T) => void;
    type ValueIteratee<T> = ((value: T) => NotVoid) | IterateeShorthand<T>;
    type ValueIterateeCustom<T, TResult> = ((value: T) => TResult) | IterateeShorthand<T>;
    type ValueIteratorTypeGuard<T, S extends T> = (value: T) => value is S;
    type ValueKeyIteratee<T> = ((value: T, key: string) => NotVoid) | IterateeShorthand<T>;
    type ValueKeyIterateeTypeGuard<T, S extends T> = (value: T, key: string) => value is S;
    type Comparator<T> = (a: T, b: T) => boolean;
    type Comparator2<T1, T2> = (a: T1, b: T2) => boolean;
    type PropertyName = string | number | symbol;
    type PropertyPath = Many<PropertyName>;
    /** Common interface between Arrays and jQuery objects */
    type List<T> = ArrayLike<T>;
    interface Dictionary<T> {
        [index: string]: T;
    }
    interface NumericDictionary<T> {
        [index: number]: T;
    }
    // Crazy typedef needed get _.omit to work properly with Dictionary and NumericDictionary
    type AnyKindOfDictionary =
        | Dictionary<unknown>
        | NumericDictionary<unknown>;
    type PartialShallow<T> = {
        [P in keyof T]?: T[P] extends object ? object : T[P]
    };
    // For backwards compatibility
    type LoDashImplicitArrayWrapper<T> = LoDashImplicitWrapper<T[]>;
    type LoDashImplicitNillableArrayWrapper<T> = LoDashImplicitWrapper<T[] | null | undefined>;
    type LoDashImplicitObjectWrapper<T> = LoDashImplicitWrapper<T>;
    type LoDashImplicitNillableObjectWrapper<T> = LoDashImplicitWrapper<T | null | undefined>;
    type LoDashImplicitNumberArrayWrapper = LoDashImplicitWrapper<number[]>;
    type LoDashImplicitStringWrapper = LoDashImplicitWrapper<string>;
    type LoDashExplicitArrayWrapper<T> = LoDashExplicitWrapper<T[]>;
    type LoDashExplicitNillableArrayWrapper<T> = LoDashExplicitWrapper<T[] | null | undefined>;
    type LoDashExplicitObjectWrapper<T> = LoDashExplicitWrapper<T>;
    type LoDashExplicitNillableObjectWrapper<T> = LoDashExplicitWrapper<T | null | undefined>;
    type LoDashExplicitNumberArrayWrapper = LoDashExplicitWrapper<number[]>;
    type LoDashExplicitStringWrapper = LoDashExplicitWrapper<string>;
    type DictionaryIterator<T, TResult> = ObjectIterator<Dictionary<T>, TResult>;
    type DictionaryIteratee<T> = ObjectIteratee<Dictionary<T>>;
    type DictionaryIteratorTypeGuard<T, S extends T> = ObjectIteratorTypeGuard<Dictionary<T>, S>;
    // NOTE: keys of objects at run time are always strings, even when a NumericDictionary is being iterated.
    type NumericDictionaryIterator<T, TResult> = (value: T, key: string, collection: NumericDictionary<T>) => TResult;
    type NumericDictionaryIteratee<T> = NumericDictionaryIterator<T, NotVoid> | IterateeShorthand<T>;
    type NumericDictionaryIterateeCustom<T, TResult> = NumericDictionaryIterator<T, TResult> | IterateeShorthand<T>;
}
import _ = require("../index");
declare module "../index" {
    interface LoDashStatic {
        /*
         * Gets the number of milliseconds that have elapsed since the Unix epoch (1 January 1970 00:00:00 UTC).
         *
         * @return The number of milliseconds.
         */
        now(): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.now
         */
        now(): number;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.now
         */
        now(): PrimitiveChain<number>;
    }
}
import _ = require("../index");
declare module "../index" {
    interface LoDashStatic {
        /**
         * The opposite of _.before; this method creates a function that invokes func once it’s called n or more times.
         *
         * @param n The number of calls before func is invoked.
         * @param func The function to restrict.
         * @return Returns the new restricted function.
         */
        after<TFunc extends (...args: any[]) => any>(n: number, func: TFunc): TFunc;
    }
    interface Primitive<T> {
        /**
         * @see _.after
         */
        after<TFunc extends (...args: any[]) => any>(func: TFunc): Function<TFunc>;
    }
    interface PrimitiveChain<T> {
        /**
         * @see _.after
         */
        after<TFunc extends (...args: any[]) => any>(func: TFunc): FunctionChain<TFunc>;
    }
    interface LoDashStatic {
        /**
         * Creates a function that accepts up to n arguments ignoring any additional arguments.
         *
         * @param func The function to cap arguments for.
         * @param n The arity cap.
         * @returns Returns the new function.
         */
        ary(func: (...args: any[]) => any, n?: number): (...args: any[]) => any;
    }
    interface Function<T extends (...args: any) => any> {
        /**
         * @see _.ary
         */
        ary(n?: number): Function<(...args: any[]) => any>;
    }
    interface FunctionChain<T extends (...args: any) => any> {
        /**
         * @see _.ary
         */
        ary(n?: number): FunctionChain<(...args: any[]) => any>;
    }
    interface LoDashStatic {
        /**
         * Creates a function that invokes func, with the this binding and arguments of the created function, while
         * it’s called less than n times. Subsequent calls to the created function return the result of the last func
         * invocation.
         *
         * @param n The number of calls at which func is no longer invoked.
         * @param func The function to restrict.
         * @return Returns the new restricted function.
         */
        before<TFunc extends (...args: any[]) => any>(n: number, func: TFunc): TFunc;
    }
    interface Primitive<T> {
        /**
         * @see _.before
         */
        before<TFunc extends (...args: any[]) => any>(func: TFunc): Function<TFunc>;
    }
    interface PrimitiveChain<T> {
        /**
         * @see _.before
         */
        before<TFunc extends (...args: any[]) => any>(func: TFunc): FunctionChain<TFunc>;
    }
    interface FunctionBind {
        /**
         * @see _.placeholder
         */
        placeholder: __;
        (func: (...args: any[]) => any, thisArg: any, ...partials: any[]): (...args: any[]) => any;
    }
    interface LoDashStatic {
        /**
         * Creates a function that invokes func with the this binding of thisArg and prepends any additional _.bind
         * arguments to those provided to the bound function.
         *
         * The _.bind.placeholder value, which defaults to _ in monolithic builds, may be used as a placeholder for
         * partially applied arguments.
         *
         * Note: Unlike native Function#bind this method does not set the "length" property of bound functions.
         *
         * @param func The function to bind.
         * @param thisArg The this binding of func.
         * @param partials The arguments to be partially applied.
         * @return Returns the new bound function.
         */
        bind: FunctionBind;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.bind
         */
        bind(thisArg: any, ...partials: any[]): Function<(...args: any[]) => any>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.bind
         */
        bind(thisArg: any, ...partials: any[]): FunctionChain<(...args: any[]) => any>;
    }
    interface FunctionBindKey {
        placeholder: __;
        (object: object, key: string, ...partials: any[]): (...args: any[]) => any;
    }
    interface LoDashStatic {
        /**
         * Creates a function that invokes the method at object[key] and prepends any additional _.bindKey arguments
         * to those provided to the bound function.
         *
         * This method differs from _.bind by allowing bound functions to reference methods that may be redefined
         * or don’t yet exist. See Peter Michaux’s article for more details.
         *
         * The _.bindKey.placeholder value, which defaults to _ in monolithic builds, may be used as a placeholder
         * for partially applied arguments.
         *
         * @param object The object the method belongs to.
         * @param key The key of the method.
         * @param partials The arguments to be partially applied.
         * @return Returns the new bound function.
         */
        bindKey: FunctionBindKey;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.bindKey
         */
        bindKey(key: string, ...partials: any[]): Function<(...args: any[]) => any>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.bindKey
         */
        bindKey(key: string, ...partials: any[]): FunctionChain<(...args: any[]) => any>;
    }
    interface Curry {
        <T1, R>(func: (t1: T1) => R, arity?: number): CurriedFunction1<T1, R>;
        <T1, T2, R>(func: (t1: T1, t2: T2) => R, arity?: number): CurriedFunction2<T1, T2, R>;
        <T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3) => R, arity?: number): CurriedFunction3<T1, T2, T3, R>;
        <T1, T2, T3, T4, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4) => R, arity?: number): CurriedFunction4<T1, T2, T3, T4, R>;
        <T1, T2, T3, T4, T5, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R, arity?: number): CurriedFunction5<T1, T2, T3, T4, T5, R>;
        (func: (...args: any[]) => any, arity?: number): (...args: any[]) => any;
        placeholder: __;
    }
    interface LoDashStatic {
        curry: Curry;
    }
    interface CurriedFunction1<T1, R> {
        (): CurriedFunction1<T1, R>;
        (t1: T1): R;
    }
    interface CurriedFunction2<T1, T2, R> {
        (): CurriedFunction2<T1, T2, R>;
        (t1: T1): CurriedFunction1<T2, R>;
        (t1: __, t2: T2): CurriedFunction1<T1, R>;
        (t1: T1, t2: T2): R;
    }
    interface CurriedFunction3<T1, T2, T3, R> {
        (): CurriedFunction3<T1, T2, T3, R>;
        (t1: T1): CurriedFunction2<T2, T3, R>;
        (t1: __, t2: T2): CurriedFunction2<T1, T3, R>;
        (t1: T1, t2: T2): CurriedFunction1<T3, R>;
        (t1: __, t2: __, t3: T3): CurriedFunction2<T1, T2, R>;
        (t1: T1, t2: __, t3: T3): CurriedFunction1<T2, R>;
        (t1: __, t2: T2, t3: T3): CurriedFunction1<T1, R>;
        (t1: T1, t2: T2, t3: T3): R;
    }
    interface CurriedFunction4<T1, T2, T3, T4, R> {
        (): CurriedFunction4<T1, T2, T3, T4, R>;
        (t1: T1): CurriedFunction3<T2, T3, T4, R>;
        (t1: __, t2: T2): CurriedFunction3<T1, T3, T4, R>;
        (t1: T1, t2: T2): CurriedFunction2<T3, T4, R>;
        (t1: __, t2: __, t3: T3): CurriedFunction3<T1, T2, T4, R>;
        (t1: __, t2: __, t3: T3): CurriedFunction2<T2, T4, R>;
        (t1: __, t2: T2, t3: T3): CurriedFunction2<T1, T4, R>;
        (t1: T1, t2: T2, t3: T3): CurriedFunction1<T4, R>;
        (t1: __, t2: __, t3: __, t4: T4): CurriedFunction3<T1, T2, T3, R>;
        (t1: T1, t2: __, t3: __, t4: T4): CurriedFunction2<T2, T3, R>;
        (t1: __, t2: T2, t3: __, t4: T4): CurriedFunction2<T1, T3, R>;
        (t1: __, t2: __, t3: T3, t4: T4): CurriedFunction2<T1, T2, R>;
        (t1: T1, t2: T2, t3: __, t4: T4): CurriedFunction1<T3, R>;
        (t1: T1, t2: __, t3: T3, t4: T4): CurriedFunction1<T2, R>;
        (t1: __, t2: T2, t3: T3, t4: T4): CurriedFunction1<T1, R>;
        (t1: T1, t2: T2, t3: T3, t4: T4): R;
    }
    interface CurriedFunction5<T1, T2, T3, T4, T5, R> {
        (): CurriedFunction5<T1, T2, T3, T4, T5, R>;
        (t1: T1): CurriedFunction4<T2, T3, T4, T5, R>;
        (t1: __, t2: T2): CurriedFunction4<T1, T3, T4, T5, R>;
        (t1: T1, t2: T2): CurriedFunction3<T3, T4, T5, R>;
        (t1: __, t2: __, t3: T3): CurriedFunction4<T1, T2, T4, T5, R>;
        (t1: T1, t2: __, t3: T3): CurriedFunction3<T2, T4, T5, R>;
        (t1: __, t2: T2, t3: T3): CurriedFunction3<T1, T4, T5, R>;
        (t1: T1, t2: T2, t3: T3): CurriedFunction2<T4, T5, R>;
        (t1: __, t2: __, t3: __, t4: T4): CurriedFunction4<T1, T2, T3, T5, R>;
        (t1: T1, t2: __, t3: __, t4: T4): CurriedFunction3<T2, T3, T5, R>;
        (t1: __, t2: T2, t3: __, t4: T4): CurriedFunction3<T1, T3, T5, R>;
        (t1: __, t2: __, t3: T3, t4: T4): CurriedFunction3<T1, T2, T5, R>;
        (t1: T1, t2: T2, t3: __, t4: T4): CurriedFunction2<T3, T5, R>;
        (t1: T1, t2: __, t3: T3, t4: T4): CurriedFunction2<T2, T5, R>;
        (t1: __, t2: T2, t3: T3, t4: T4): CurriedFunction2<T1, T5, R>;
        (t1: T1, t2: T2, t3: T3, t4: T4): CurriedFunction1<T5, R>;
        (t1: __, t2: __, t3: __, t4: __, t5: T5): CurriedFunction4<T1, T2, T3, T4, R>;
        (t1: T1, t2: __, t3: __, t4: __, t5: T5): CurriedFunction3<T2, T3, T4, R>;
        (t1: __, t2: T2, t3: __, t4: __, t5: T5): CurriedFunction3<T1, T3, T4, R>;
        (t1: __, t2: __, t3: T3, t4: __, t5: T5): CurriedFunction3<T1, T2, T4, R>;
        (t1: __, t2: __, t3: __, t4: T4, t5: T5): CurriedFunction3<T1, T2, T3, R>;
        (t1: T1, t2: T2, t3: __, t4: __, t5: T5): CurriedFunction2<T3, T4, R>;
        (t1: T1, t2: __, t3: T3, t4: __, t5: T5): CurriedFunction2<T2, T4, R>;
        (t1: T1, t2: __, t3: __, t4: T4, t5: T5): CurriedFunction2<T2, T3, R>;
        (t1: __, t2: T2, t3: T3, t4: __, t5: T5): CurriedFunction2<T1, T4, R>;
        (t1: __, t2: T2, t3: __, t4: T4, t5: T5): CurriedFunction2<T1, T3, R>;
        (t1: __, t2: __, t3: T3, t4: T4, t5: T5): CurriedFunction2<T1, T2, R>;
        (t1: T1, t2: T2, t3: T3, t4: __, t5: T5): CurriedFunction1<T4, R>;
        (t1: T1, t2: T2, t3: __, t4: T4, t5: T5): CurriedFunction1<T3, R>;
        (t1: T1, t2: __, t3: T3, t4: T4, t5: T5): CurriedFunction1<T2, R>;
        (t1: __, t2: T2, t3: T3, t4: T4, t5: T5): CurriedFunction1<T1, R>;
        (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): R;
    }
    interface RightCurriedFunction1<T1, R> {
        (): RightCurriedFunction1<T1, R>;
        (t1: T1): R;
    }
    interface RightCurriedFunction2<T1, T2, R> {
        (): RightCurriedFunction2<T1, T2, R>;
        (t2: T2): RightCurriedFunction1<T1, R>;
        (t1: T1, t2: __): RightCurriedFunction1<T2, R>;
        (t1: T1, t2: T2): R;
    }
    interface RightCurriedFunction3<T1, T2, T3, R> {
        (): RightCurriedFunction3<T1, T2, T3, R>;
        (t3: T3): RightCurriedFunction2<T1, T2, R>;
        (t2: T2, t3: __): RightCurriedFunction2<T1, T3, R>;
        (t2: T2, t3: T3): RightCurriedFunction1<T1, R>;
        (t1: T1, t2: __, t3: __): RightCurriedFunction2<T2, T3, R>;
        (t1: T1, t2: T2, t3: __): RightCurriedFunction1<T3, R>;
        (t1: T1, t2: __, t3: T3): RightCurriedFunction1<T2, R>;
        (t1: T1, t2: T2, t3: T3): R;
    }
    interface RightCurriedFunction4<T1, T2, T3, T4, R> {
        (): RightCurriedFunction4<T1, T2, T3, T4, R>;
        (t4: T4): RightCurriedFunction3<T1, T2, T3, R>;
        (t3: T3, t4: __): RightCurriedFunction3<T1, T2, T4, R>;
        (t3: T3, t4: T4): RightCurriedFunction2<T1, T2, R>;
        (t2: T2, t3: __, t4: __): RightCurriedFunction3<T1, T3, T4, R>;
        (t2: T2, t3: T3, t4: __): RightCurriedFunction2<T1, T4, R>;
        (t2: T2, t3: __, t4: T4): RightCurriedFunction2<T1, T3, R>;
        (t2: T2, t3: T3, t4: T4): RightCurriedFunction1<T1, R>;
        (t1: T1, t2: __, t3: __, t4: __): RightCurriedFunction3<T2, T3, T4, R>;
        (t1: T1, t2: T2, t3: __, t4: __): RightCurriedFunction2<T3, T4, R>;
        (t1: T1, t2: __, t3: T3, t4: __): RightCurriedFunction2<T2, T4, R>;
        (t1: T1, t2: __, t3: __, t4: T4): RightCurriedFunction2<T2, T3, R>;
        (t1: T1, t2: T2, t3: T3, t4: __): RightCurriedFunction1<T4, R>;
        (t1: T1, t2: T2, t3: __, t4: T4): RightCurriedFunction1<T3, R>;
        (t1: T1, t2: __, t3: T3, t4: T4): RightCurriedFunction1<T2, R>;
        (t1: T1, t2: T2, t3: T3, t4: T4): R;
    }
    interface RightCurriedFunction5<T1, T2, T3, T4, T5, R> {
        (): RightCurriedFunction5<T1, T2, T3, T4, T5, R>;
        (t5: T5): RightCurriedFunction4<T1, T2, T3, T4, R>;
        (t4: T4, t5: __): RightCurriedFunction4<T1, T2, T3, T5, R>;
        (t4: T4, t5: T5): RightCurriedFunction3<T1, T2, T3, R>;
        (t3: T3, t4: __, t5: __): RightCurriedFunction4<T1, T2, T4, T5, R>;
        (t3: T3, t4: T4, t5: __): RightCurriedFunction3<T1, T2, T5, R>;
        (t3: T3, t4: __, t5: T5): RightCurriedFunction3<T1, T2, T4, R>;
        (t3: T3, t4: T4, t5: T5): RightCurriedFunction2<T1, T2, R>;
        (t2: T2, t3: __, t4: __, t5: __): RightCurriedFunction4<T1, T3, T4, T5, R>;
        (t2: T2, t3: T3, t4: __, t5: __): RightCurriedFunction3<T1, T4, T5, R>;
        (t2: T2, t3: __, t4: T4, t5: __): RightCurriedFunction3<T1, T3, T5, R>;
        (t2: T2, t3: __, t4: __, t5: T5): RightCurriedFunction3<T1, T3, T4, R>;
        (t2: T2, t3: T3, t4: T4, t5: __): RightCurriedFunction2<T1, T5, R>;
        (t2: T2, t3: T3, t4: __, t5: T5): RightCurriedFunction2<T1, T4, R>;
        (t2: T2, t3: __, t4: T4, t5: T5): RightCurriedFunction2<T1, T3, R>;
        (t2: T2, t3: T3, t4: T4, t5: T5): RightCurriedFunction1<T1, R>;
        (t1: T1, t2: __, t3: __, t4: __, t5: __): RightCurriedFunction4<T2, T3, T4, T5, R>;
        (t1: T1, t2: T2, t3: __, t4: __, t5: __): RightCurriedFunction3<T3, T4, T5, R>;
        (t1: T1, t2: __, t3: T3, t4: __, t5: __): RightCurriedFunction3<T2, T4, T5, R>;
        (t1: T1, t2: __, t3: __, t4: T4, t5: __): RightCurriedFunction3<T2, T3, T5, R>;
        (t1: T1, t2: __, t3: __, t4: __, t5: T5): RightCurriedFunction3<T2, T3, T4, R>;
        (t1: T1, t2: T2, t3: T3, t4: __, t5: __): RightCurriedFunction2<T4, T5, R>;
        (t1: T1, t2: T2, t3: __, t4: T4, t5: __): RightCurriedFunction2<T3, T5, R>;
        (t1: T1, t2: T2, t3: __, t4: __, t5: T5): RightCurriedFunction2<T3, T4, R>;
        (t1: T1, t2: __, t3: T3, t4: T4, t5: __): RightCurriedFunction2<T2, T5, R>;
        (t1: T1, t2: __, t3: T3, t4: __, t5: T5): RightCurriedFunction2<T2, T4, R>;
        (t1: T1, t2: __, t3: __, t4: T4, t5: T5): RightCurriedFunction2<T2, T3, R>;
        (t1: T1, t2: T2, t3: T3, t4: T4, t5: __): RightCurriedFunction1<T5, R>;
        (t1: T1, t2: T2, t3: T3, t4: __, t5: T5): RightCurriedFunction1<T4, R>;
        (t1: T1, t2: T2, t3: __, t4: T4, t5: T5): RightCurriedFunction1<T3, R>;
        (t1: T1, t2: __, t3: T3, t4: T4, t5: T5): RightCurriedFunction1<T2, R>;
        (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): R;
    }
    interface Function<T extends (...args: any) => any> {
        /**
         * @see _.curry
         */
        curry(arity?: number):
            T extends (arg1: infer T1) => infer R ? Function<CurriedFunction1<T1, R>> :
            T extends (arg1: infer T1, arg2: infer T2) => infer R ? Function<CurriedFunction2<T1, T2, R>> :
            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3) => infer R ? Function<CurriedFunction3<T1, T2, T3, R>> :
            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3, arg4: infer T4) => infer R ? Function<CurriedFunction4<T1, T2, T3, T4, R>> :
            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3, arg4: infer T4, arg5: infer T5) => infer R ? Function<CurriedFunction5<T1, T2, T3, T4, T5, R>> :
            Function<(...args: any[]) => any>;
    }
    interface FunctionChain<T extends (...args: any) => any> {
        /**
         * @see _.curry
         */
        curry(arity?: number):
            T extends (arg1: infer T1) => infer R ? FunctionChain<CurriedFunction1<T1, R>> :
            T extends (arg1: infer T1, arg2: infer T2) => infer R ? FunctionChain<CurriedFunction2<T1, T2, R>> :
            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3) => infer R ? FunctionChain<CurriedFunction3<T1, T2, T3, R>> :
            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3, arg4: infer T4) => infer R ? FunctionChain<CurriedFunction4<T1, T2, T3, T4, R>> :
            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3, arg4: infer T4, arg5: infer T5) => infer R ? FunctionChain<CurriedFunction5<T1, T2, T3, T4, T5, R>> :
            FunctionChain<(...args: any[]) => any>;
    }
    interface CurryRight {
        <T1, R>(func: (t1: T1) => R, arity?: number): RightCurriedFunction1<T1, R>;
        <T1, T2, R>(func: (t1: T1, t2: T2) => R, arity?: number): RightCurriedFunction2<T1, T2, R>;
        <T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3) => R, arity?: number): RightCurriedFunction3<T1, T2, T3, R>;
        <T1, T2, T3, T4, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4) => R, arity?: number): RightCurriedFunction4<T1, T2, T3, T4, R>;
        <T1, T2, T3, T4, T5, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R, arity?: number): RightCurriedFunction5<T1, T2, T3, T4, T5, R>;
        (func: (...args: any[]) => any, arity?: number): (...args: any[]) => any;
        placeholder: __;
    }
    interface LoDashStatic {
        curryRight: CurryRight;
    }
    interface Function<T extends (...args: any) => any> {
        /**
         * @see _.curryRight
         */
        curryRight(arity?: number):
            T extends (arg1: infer T1) => infer R ? Function<RightCurriedFunction1<T1, R>> :
            T extends (arg1: infer T1, arg2: infer T2) => infer R ? Function<RightCurriedFunction2<T1, T2, R>> :
            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3) => infer R ? Function<RightCurriedFunction3<T1, T2, T3, R>> :
            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3, arg4: infer T4) => infer R ? Function<RightCurriedFunction4<T1, T2, T3, T4, R>> :
            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3, arg4: infer T4, arg5: infer T5) => infer R ? Function<RightCurriedFunction5<T1, T2, T3, T4, T5, R>> :
            Function<(...args: any[]) => any>;
    }
    interface FunctionChain<T extends (...args: any) => any> {
        /**
         * @see _.curryRight
         */
        curryRight(arity?: number):
            T extends (arg1: infer T1) => infer R ? FunctionChain<RightCurriedFunction1<T1, R>> :
            T extends (arg1: infer T1, arg2: infer T2) => infer R ? FunctionChain<RightCurriedFunction2<T1, T2, R>> :
            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3) => infer R ? FunctionChain<RightCurriedFunction3<T1, T2, T3, R>> :
            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3, arg4: infer T4) => infer R ? FunctionChain<RightCurriedFunction4<T1, T2, T3, T4, R>> :
            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3, arg4: infer T4, arg5: infer T5) => infer R ? FunctionChain<RightCurriedFunction5<T1, T2, T3, T4, T5, R>> :
            FunctionChain<(...args: any[]) => any>;
    }
    interface DebounceSettings {
        /**
         * @see _.leading
         */
        leading?: boolean | undefined;
        /**
         * @see _.maxWait
         */
        maxWait?: number | undefined;
        /**
         * @see _.trailing
         */
        trailing?: boolean | undefined;
    }
    interface DebounceSettingsLeading extends DebounceSettings {
        leading: true;
    }
    interface DebouncedFunc<T extends (...args: any[]) => any> {
        /**
         * Call the original function, but applying the debounce rules.
         *
         * If the debounced function can be run immediately, this calls it and returns its return
         * value.
         *
         * Otherwise, it returns the return value of the last invocation, or undefined if the debounced
         * function was not invoked yet.
         */
        (...args: Parameters<T>): ReturnType<T> | undefined;

        /**
         * Throw away any pending invocation of the debounced function.
         */
        cancel(): void;

        /**
         * If there is a pending invocation of the debounced function, invoke it immediately and return
         * its return value.
         *
         * Otherwise, return the value from the last invocation, or undefined if the debounced function
         * was never invoked.
         */
        flush(): ReturnType<T> | undefined;
    }
    interface DebouncedFuncLeading<T extends (...args: any[]) => any> extends DebouncedFunc<T> {
        (...args: Parameters<T>): ReturnType<T>;
        flush(): ReturnType<T>;
    }
    interface LoDashStatic {
        /**
         * Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since
         * the last time the debounced function was invoked. The debounced function comes with a cancel method to
         * cancel delayed invocations and a flush method to immediately invoke them. Provide an options object to
         * indicate that func should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent
         * calls to the debounced function return the result of the last func invocation.
         *
         * Note: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only
         * if the the debounced function is invoked more than once during the wait timeout.
         *
         * See David Corbacho’s article for details over the differences between _.debounce and _.throttle.
         *
         * @param func The function to debounce.
         * @param wait The number of milliseconds to delay.
         * @param options The options object.
         * @param options.leading Specify invoking on the leading edge of the timeout.
         * @param options.maxWait The maximum time func is allowed to be delayed before it’s invoked.
         * @param options.trailing Specify invoking on the trailing edge of the timeout.
         * @return Returns the new debounced function.
         */
        debounce<T extends (...args: any) => any>(func: T, wait: number | undefined, options: DebounceSettingsLeading): DebouncedFuncLeading<T>;
        debounce<T extends (...args: any) => any>(func: T, wait?: number, options?: DebounceSettings): DebouncedFunc<T>;
    }
    interface Function<T extends (...args: any) => any> {
        /**
         * @see _.debounce
         */
        debounce(
            wait: number | undefined,
            options: DebounceSettingsLeading
        ): T extends (...args: any[]) => any ? Function<DebouncedFuncLeading<T>> : never;
        debounce(
            wait?: number,
            options?: DebounceSettings
        ): T extends (...args: any[]) => any ? Function<DebouncedFunc<T>> : never;
    }
    interface FunctionChain<T extends (...args: any) => any> {
        /**
         * @see _.debounce
         */
        debounce(
            wait: number | undefined,
            options: DebounceSettingsLeading
        ): T extends (...args: any[]) => any ? FunctionChain<DebouncedFuncLeading<T>> : never;
        debounce(
            wait?: number,
            options?: DebounceSettings
        ): T extends (...args: any[]) => any ? FunctionChain<DebouncedFunc<T>> : never;
    }
    interface LoDashStatic {
        /**
         * Defers invoking the func until the current call stack has cleared. Any additional arguments are provided to
         * func when it’s invoked.
         *
         * @param func The function to defer.
         * @param args The arguments to invoke the function with.
         * @return Returns the timer id.
         */
        defer(func: (...args: any[]) => any, ...args: any[]): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.defer
         */
        defer(...args: any[]): Primitive<number>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.defer
         */
        defer(...args: any[]): PrimitiveChain<number>;
    }
    interface LoDashStatic {
        /**
         * Invokes func after wait milliseconds. Any additional arguments are provided to func when it’s invoked.
         *
         * @param func The function to delay.
         * @param wait The number of milliseconds to delay invocation.
         * @param args The arguments to invoke the function with.
         * @return Returns the timer id.
         */
        delay(func: (...args: any[]) => any, wait: number, ...args: any[]): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.delay
         */
        delay(wait: number, ...args: any[]): Primitive<number>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.delay
         */
        delay(wait: number, ...args: any[]): PrimitiveChain<number>;
    }
    interface LoDashStatic {
        /**
         * Creates a function that invokes `func` with arguments reversed.
         *
         * @category Function
         * @param func The function to flip arguments for.
         * @returns Returns the new function.
         * @example
         *
         * var flipped = _.flip(function() {
         *   return _.toArray(arguments);
         * });
         *
         * flipped('a', 'b', 'c', 'd');
         * // => ['d', 'c', 'b', 'a']
         */
        flip<T extends (...args: any) => any>(func: T): T;
    }
    interface Function<T extends (...args: any) => any> {
        /**
         * @see _.flip
         */
        flip(): this;
    }
    interface FunctionChain<T extends (...args: any) => any> {
        /**
         * @see _.flip
         */
        flip(): this;
    }
    interface MemoizedFunction {
        /**
         * @see _.cache
         */
        cache: MapCache;
    }
    interface LoDashStatic {
        /**
         * Creates a function that memoizes the result of func. If resolver is provided it determines the cache key for
         * storing the result based on the arguments provided to the memoized function. By default, the first argument
         * provided to the memoized function is coerced to a string and used as the cache key. The func is invoked with
         * the this binding of the memoized function.
         *
         * @param func The function to have its output memoized.
         * @param resolver The function to resolve the cache key.
         * @return Returns the new memoizing function.
         */
        memoize: {
            <T extends (...args: any) => any>(func: T, resolver?: (...args: Parameters<T>) => any): T & MemoizedFunction;
            Cache: MapCacheConstructor;
        };
    }
    interface Function<T extends (...args: any) => any> {
        /**
         * @see _.memoize
         */
        memoize(resolver?: (...args: any[]) => any): Function<T & MemoizedFunction>;
    }
    interface FunctionChain<T extends (...args: any) => any> {
        /**
         * @see _.memoize
         */
        memoize(resolver?: (...args: any[]) => any): FunctionChain<T & MemoizedFunction>;
    }
    interface LoDashStatic {
        /**
         * Creates a function that negates the result of the predicate func. The func predicate is invoked with
         * the this binding and arguments of the created function.
         *
         * @param predicate The predicate to negate.
         * @return Returns the new function.
         */
        negate<T extends any[]>(predicate: (...args: T) => boolean): (...args: T) => boolean;
    }
    interface Function<T extends (...args: any) => any> {
        /**
         * @see _.negate
         */
        negate(): Function<(...args: Parameters<T>) => boolean>;
    }
    interface FunctionChain<T extends (...args: any) => any> {
        /**
         * @see _.negate
         */
        negate(): FunctionChain<(...args: Parameters<T>) => boolean>;
    }
    interface LoDashStatic {
        /**
         * Creates a function that is restricted to invoking func once. Repeat calls to the function return the value
         * of the first call. The func is invoked with the this binding and arguments of the created function.
         *
         * @param func The function to restrict.
         * @return Returns the new restricted function.
         */
        once<T extends (...args: any) => any>(func: T): T;
    }
    interface Function<T extends (...args: any) => any> {
        /**
         * @see _.once
         */
        once(): Function<T>;
    }
    interface FunctionChain<T extends (...args: any) => any> {
        /**
         * @see _.once
         */
        once(): FunctionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Creates a function that runs each argument through a corresponding transform function.
         *
         * @param func The function to wrap.
         * @param transforms The functions to transform arguments, specified as individual functions or arrays
         * of functions.
         * @return Returns the new function.
         */
        overArgs(func: (...args: any[]) => any, ...transforms: Array<Many<(...args: any[]) => any>>): (...args: any[]) => any;
    }
    interface Function<T extends (...args: any) => any> {
        /**
         * @see _.overArgs
         */
        overArgs(...transforms: Array<Many<(...args: any[]) => any>>): Function<(...args: any[]) => any>;
    }
    interface FunctionChain<T extends (...args: any) => any> {
        /**
         * @see _.overArgs
         */
        overArgs(...transforms: Array<Many<(...args: any[]) => any>>): FunctionChain<(...args: any[]) => any>;
    }
    interface LoDashStatic {
        /**
        * Creates a function that, when called, invokes func with any additional partial arguments
        * prepended to those provided to the new function. This method is similar to _.bind except
        * it does not alter the this binding.
        * @param func The function to partially apply arguments to.
        * @param args Arguments to be partially applied.
        * @return The new partially applied function.
         */
        partial: Partial;
    }
    type __ = LoDashStatic;
    type Function0<R> = () => R;
    type Function1<T1, R> = (t1: T1) => R;
    type Function2<T1, T2, R> = (t1: T1, t2: T2) => R;
    type Function3<T1, T2, T3, R> = (t1: T1, t2: T2, t3: T3) => R;
    type Function4<T1, T2, T3, T4, R> = (t1: T1, t2: T2, t3: T3, t4: T4) => R;
    interface Partial {
        <T1, T2, R>(func: Function2<T1, T2, R>, plc1: __, arg2: T2): Function1<T1, R>;
        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, plc1: __, arg2: T2): Function2<T1, T3, R>;
        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, plc1: __, plc2: __, arg3: T3): Function2<T1, T2, R>;
        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, plc2: __, arg3: T3): Function1<T2, R>;
        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, plc1: __, arg2: T2, arg3: T3): Function1<T1, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: __, arg2: T2): Function3<T1, T3, T4, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: __, plc2: __, arg3: T3): Function3<T1, T2, T4, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: __, arg3: T3): Function2<T2, T4, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: __, arg2: T2, arg3: T3): Function2<T1, T4, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: __, plc2: __, plc3: __, arg4: T4): Function3<T1, T2, T3, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: __, plc3: __, arg4: T4): Function2<T2, T3, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: __, arg2: T2, plc3: __, arg4: T4): Function2<T1, T3, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, plc3: __, arg4: T4): Function1<T3, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: __, plc2: __, arg3: T3, arg4: T4): Function2<T1, T2, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: __, arg3: T3, arg4: T4): Function1<T2, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: __, arg2: T2, arg3: T3, arg4: T4): Function1<T1, R>;
        <TS extends any[], R>(func: (...ts: TS) => R): (...ts: TS) => R;
        <TS extends any[], T1, R>(func: (t1: T1, ...ts: TS) => R, arg1: T1): (...ts: TS) => R;
        <TS extends any[], T1, T2, R>(func: (t1: T1, t2: T2, ...ts: TS) => R, t1: T1, t2: T2): (...ts: TS) => R;
        <TS extends any[], T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3, ...ts: TS) => R, t1: T1, t2: T2, t3: T3): (...ts: TS) => R;
        <TS extends any[], T1, T2, T3, T4, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4, ...ts: TS) => R, t1: T1, t2: T2, t3: T3, t4: T4): (...ts: TS) => R;
        placeholder: __;
    }
    interface Function<T extends (...args: any) => any> {
        /**
         * @see _.partial
         */
        partial<T2>(plc1: __, arg2: T2): Function<
            T extends Function2<infer T1, T2, infer R> ? Function1<T1, R> :
            T extends Function3<infer T1, T2, infer T3, infer R> ? Function2<T1, T3, R> :
            T extends Function4<infer T1, T2, infer T3, infer T4, infer R> ? Function3<T1, T3, T4, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T3>(plc1: __, plc2: __, arg3: T3): Function<
            T extends Function3<infer T1, infer T2, T3, infer R> ? Function2<T1, T2, R> :
            T extends Function4<infer T1, infer T2, T3, infer T4, infer R> ? Function3<T1, T2, T4, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T1, T3>(arg1: T1, plc2: __, arg3: T3): Function<
            T extends Function3<T1, infer T2, T3, infer R> ? Function1<T2, R> :
            T extends Function4<T1, infer T2, T3, infer T4, infer R> ? Function2<T2, T4, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T2, T3>(plc1: __, arg2: T2, arg3: T3): Function<
            T extends Function3<infer T1, T2, T3, infer R> ? Function1<T1, R> :
            T extends Function4<infer T1, T2, T3, infer T4, infer R> ? Function2<T1, T4, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T3>(plc1: __, plc2: __, arg3: T3): Function<
            T extends Function4<infer T1, infer T2, T3, infer T4, infer R> ? Function3<T1, T2, T4, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T1, T4>(arg1: T1, plc2: __, plc3: __, arg4: T4): Function<
            T extends Function4<T1, infer T2, infer T3, T4, infer R> ? Function2<T2, T3, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T2, T4>(plc1: __, arg2: T2, plc3: __, arg4: T4): Function<
            T extends Function4<infer T1, T2, infer T3, T4, infer R> ? Function2<T1, T3, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T1, T2, T4>(arg1: T1, arg2: T2, plc3: __, arg4: T4): Function<
            T extends Function4<T1, T2, infer T3, T4, infer R> ? Function1<T3, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T3, T4>(plc1: __, plc2: __, arg3: T3, arg4: T4): Function<
            T extends Function4<infer T1, infer T2, T3, T4, infer R> ? Function2<T1, T2, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T1, T3, T4>(arg1: T1, plc2: __, arg3: T3, arg4: T4): Function<
            T extends Function4<T1, infer T2, T3, T4, infer R> ? Function1<T2, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T2, T3, T4>(plc1: __, arg2: T2, arg3: T3, arg4: T4): Function<
            T extends Function4<infer T1, T2, T3, T4, infer R> ? Function1<T1, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T1, T2, T3, T4>(arg1: T1, arg2: T2, arg3: T3, arg4: T4): Function<
            T extends (t1: T1, t2: T2, t3: T3, t4: T4, ...ts: infer TS) => infer R ? (...ts: TS) => R :
            any
            >;
        /**
         * @see _.partial
         */
        partial<T1, T2, T3>(arg1: T1, arg2: T2, arg3: T3): Function<
            T extends (t1: T1, t2: T2, t3: T3, ...ts: infer TS) => infer R ? (...ts: TS) => R :
            any
            >;
        /**
         * @see _.partial
         */
        partial<T1, T2>(arg1: T1, arg2: T2): Function<
            T extends (t1: T1, t2: T2, ...ts: infer TS) => infer R ? (...ts: TS) => R :
            any
            >;
        /**
         * @see _.partial
         */
        partial<T1>(arg1: T1): Function<
            T extends (t1: T1, ...ts: infer TS) => infer R ? (...ts: TS) => R :
            any
            >;
        /**
         * @see _.partial
         */
        partial(): Function<T extends (...ts: any[]) => any ? T : any>;
    }
    interface FunctionChain<T extends (...args: any) => any> {
        /**
         * @see _.partial
         */
        partial<T2>(plc1: __, arg2: T2): FunctionChain<
            T extends Function2<infer T1, T2, infer R> ? Function1<T1, R> :
            T extends Function3<infer T1, T2, infer T3, infer R> ? Function2<T1, T3, R> :
            T extends Function4<infer T1, T2, infer T3, infer T4, infer R> ? Function3<T1, T3, T4, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T3>(plc1: __, plc2: __, arg3: T3): FunctionChain<
            T extends Function3<infer T1, infer T2, T3, infer R> ? Function2<T1, T2, R> :
            T extends Function4<infer T1, infer T2, T3, infer T4, infer R> ? Function3<T1, T2, T4, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T1, T3>(arg1: T1, plc2: __, arg3: T3): FunctionChain<
            T extends Function3<T1, infer T2, T3, infer R> ? Function1<T2, R> :
            T extends Function4<T1, infer T2, T3, infer T4, infer R> ? Function2<T2, T4, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T2, T3>(plc1: __, arg2: T2, arg3: T3): FunctionChain<
            T extends Function3<infer T1, T2, T3, infer R> ? Function1<T1, R> :
            T extends Function4<infer T1, T2, T3, infer T4, infer R> ? Function2<T1, T4, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T3>(plc1: __, plc2: __, arg3: T3): FunctionChain<
            T extends Function4<infer T1, infer T2, T3, infer T4, infer R> ? Function3<T1, T2, T4, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T1, T4>(arg1: T1, plc2: __, plc3: __, arg4: T4): FunctionChain<
            T extends Function4<T1, infer T2, infer T3, T4, infer R> ? Function2<T2, T3, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T2, T4>(plc1: __, arg2: T2, plc3: __, arg4: T4): FunctionChain<
            T extends Function4<infer T1, T2, infer T3, T4, infer R> ? Function2<T1, T3, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T1, T2, T4>(arg1: T1, arg2: T2, plc3: __, arg4: T4): FunctionChain<
            T extends Function4<T1, T2, infer T3, T4, infer R> ? Function1<T3, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T3, T4>(plc1: __, plc2: __, arg3: T3, arg4: T4): FunctionChain<
            T extends Function4<infer T1, infer T2, T3, T4, infer R> ? Function2<T1, T2, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T1, T3, T4>(arg1: T1, plc2: __, arg3: T3, arg4: T4): FunctionChain<
            T extends Function4<T1, infer T2, T3, T4, infer R> ? Function1<T2, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T2, T3, T4>(plc1: __, arg2: T2, arg3: T3, arg4: T4): FunctionChain<
            T extends Function4<infer T1, T2, T3, T4, infer R> ? Function1<T1, R> :
            any
        >;
        /**
         * @see _.partial
         */
        partial<T1, T2, T3, T4>(arg1: T1, arg2: T2, arg3: T3, arg4: T4): FunctionChain<
            T extends (t1: T1, t2: T2, t3: T3, t4: T4, ...ts: infer TS) => infer R ? (...ts: TS) => R :
            any
            >;
        /**
         * @see _.partial
         */
        partial<T1, T2, T3>(arg1: T1, arg2: T2, arg3: T3): FunctionChain<
            T extends (t1: T1, t2: T2, t3: T3, ...ts: infer TS) => infer R ? (...ts: TS) => R :
            any
            >;
        /**
         * @see _.partial
         */
        partial<T1, T2>(arg1: T1, arg2: T2): FunctionChain<
            T extends (t1: T1, t2: T2, ...ts: infer TS) => infer R ? (...ts: TS) => R :
            any
            >;
        /**
         * @see _.partial
         */
        partial<T1>(arg1: T1): FunctionChain<
            T extends (t1: T1, ...ts: infer TS) => infer R ? (...ts: TS) => R :
            any
            >;
        /**
         * @see _.partial
         */
        partial(): FunctionChain<T extends (...ts: any[]) => any ? T : any>;
    }
    interface LoDashStatic {
        /**
        * This method is like _.partial except that partial arguments are appended to those provided
        * to the new function.
        * @param func The function to partially apply arguments to.
        * @param args Arguments to be partially applied.
        * @return The new partially applied function.
         */
        partialRight: PartialRight;
    }
    interface PartialRight {
        <R>(func: Function0<R>): Function0<R>;
        <T1, R>(func: Function1<T1, R>): Function1<T1, R>;
        <T1, R>(func: Function1<T1, R>, arg1: T1): Function0<R>;
        <T1, T2, R>(func: Function2<T1, T2, R>): Function2<T1, T2, R>;
        <T1, T2, R>(func: Function2<T1, T2, R>, arg1: T1, plc2: __): Function1<T2, R>;
        <T1, T2, R>(func: Function2<T1, T2, R>, arg2: T2): Function1<T1, R>;
        <T1, T2, R>(func: Function2<T1, T2, R>, arg1: T1, arg2: T2): Function0<R>;
        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>): Function3<T1, T2, T3, R>;
        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, plc2: __, plc3: __): Function2<T2, T3, R>;
        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg2: T2, plc3: __): Function2<T1, T3, R>;
        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, arg2: T2, plc3: __): Function1<T3, R>;
        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg3: T3): Function2<T1, T2, R>;
        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, plc2: __, arg3: T3): Function1<T2, R>;
        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg2: T2, arg3: T3): Function1<T1, R>;
        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): Function0<R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>): Function4<T1, T2, T3, T4, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: __, plc3: __, plc4: __): Function3<T2, T3, T4, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg2: T2, plc3: __, plc4: __): Function3<T1, T3, T4, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, plc3: __, plc4: __): Function2<T3, T4, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg3: T3, plc4: __): Function3<T1, T2, T4, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: __, arg3: T3, plc4: __): Function2<T2, T4, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg2: T2, arg3: T3, plc4: __): Function2<T1, T4, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, plc4: __): Function1<T4, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg4: T4): Function3<T1, T2, T3, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: __, plc3: __, arg4: T4): Function2<T2, T3, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg2: T2, plc3: __, arg4: T4): Function2<T1, T3, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, plc3: __, arg4: T4): Function1<T3, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg3: T3, arg4: T4): Function2<T1, T2, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: __, arg3: T3, arg4: T4): Function1<T2, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg2: T2, arg3: T3, arg4: T4): Function1<T1, R>;
        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): Function0<R>;
        (func: (...args: any[]) => any, ...args: any[]): (...args: any[]) => any;
        placeholder: __;
    }
    interface Function<T extends (...args: any) => any> {
        /**
         * @see _.partialRight
         */
        partialRight<T1>(arg1: T1, plc2: __): Function<
            T extends Function2<T1, infer T2, infer R> ? Function1<T2, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T2>(arg2: T2): Function<
            T extends Function2<infer T1, T2, infer R> ? Function1<T1, R> : any
            >;
        /**
         * @see _.partialRight
         */
        partialRight<T1>(arg1: T1, plc2: __, plc3: __): Function<
            T extends Function3<T1, infer T2, infer T3, infer R> ? Function2<T2, T3, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T2>(arg2: T2, plc3: __): Function<
            T extends Function3<infer T1, T2, infer T3, infer R> ? Function2<T1, T3, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T1, T2>(arg1: T1, arg2: T2, plc3: __): Function<
            T extends Function3<T1, T2, infer T3, infer R> ? Function1<T3, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T3>(arg3: T3): Function<
            T extends Function3<infer T1, infer T2, T3, infer R> ? Function2<T1, T2, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T1, T3>(arg1: T1, plc2: __, arg3: T3): Function<
            T extends Function3<T1, infer T2, T3, infer R> ? Function1<T2, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T2, T3>(arg2: T2, arg3: T3): Function<
            T extends Function3<infer T1, T2, T3, infer R> ? Function1<T1, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T1>(arg1: T1, plc2: __, plc3: __, plc4: __): Function<
            T extends Function4<T1, infer T2, infer T3, infer T4, infer R> ? Function3<T2, T3, T4, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T2>(arg2: T2, plc3: __, plc4: __): Function<
            T extends Function4<infer T1, T2, infer T3, infer T4, infer R> ? Function3<T1, T3, T4, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T1, T2>(arg1: T1, arg2: T2, plc3: __, plc4: __): Function<
            T extends Function4<T1, T2, infer T3, infer T4, infer R> ? Function2<T3, T4, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T3>(arg3: T3, plc4: __): Function<
            T extends Function4<infer T1, infer T2, T3, infer T4, infer R> ? Function3<T1, T2, T4, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T1, T3>(arg1: T1, plc2: __, arg3: T3, plc4: __): Function<
            T extends Function4<T1, infer T2, infer T3, infer T4, infer R> ? Function2<T2, T4, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T2, T3>(arg2: T2, arg3: T3, plc4: __): Function<
            T extends Function4<infer T1, T2, T3, infer T4, infer R> ? Function2<T1, T4, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T1, T2, T3>(arg1: T1, arg2: T2, arg3: T3, plc4: __): Function<
            T extends Function4<T1, T2, T3, infer T4, infer R> ? Function1<T4, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T4>(arg4: T4): Function<
            T extends Function4<infer T1, infer T2, infer T3, T4, infer R> ? Function3<T1, T2, T3, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T1, T4>(arg1: T1, plc2: __, plc3: __, arg4: T4): Function<
            T extends Function4<T1, infer T2, infer T3, T4, infer R> ? Function2<T2, T3, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T2, T4>(arg2: T2, plc3: __, arg4: T4): Function<
            T extends Function4<infer T1, T2, infer T3, T4, infer R> ? Function2<T1, T3, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T1, T2, T4>(arg1: T1, arg2: T2, plc3: __, arg4: T4): Function<
            T extends Function4<T1, T2, infer T3, T4, infer R> ? Function1<T3, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T3, T4>(arg3: T3, arg4: T4): Function<
            T extends Function4<infer T1, infer T2, T3, T4, infer R> ? Function2<T1, T2, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T1, T3, T4>(arg1: T1, plc2: __, arg3: T3, arg4: T4): Function<
            T extends Function4<T1, infer T2, T3, T4, infer R> ? Function1<T2, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T2, T3, T4>(arg2: T2, arg3: T3, arg4: T4): Function<
            T extends Function4<infer T1, T2, T3, T4, infer R> ? Function1<T1, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<TS extends any[]>(...ts: TS): Function<T extends (...args: TS) => infer R ? () => R : any>;
        /**
         * @see _.partialRight
         */
        partialRight(): Function<T extends (...ts: any[]) => any ? T : any>;
    }
    interface FunctionChain<T extends (...args: any) => any> {
        /**
         * @see _.partialRight
         */
        partialRight<T1>(arg1: T1, plc2: __): FunctionChain<
            T extends Function2<T1, infer T2, infer R> ? Function1<T2, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T2>(arg2: T2): FunctionChain<
            T extends Function2<infer T1, T2, infer R> ? Function1<T1, R> : any
            >;
        /**
         * @see _.partialRight
         */
        partialRight<T1>(arg1: T1, plc2: __, plc3: __): FunctionChain<
            T extends Function3<T1, infer T2, infer T3, infer R> ? Function2<T2, T3, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T2>(arg2: T2, plc3: __): FunctionChain<
            T extends Function3<infer T1, T2, infer T3, infer R> ? Function2<T1, T3, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T1, T2>(arg1: T1, arg2: T2, plc3: __): FunctionChain<
            T extends Function3<T1, T2, infer T3, infer R> ? Function1<T3, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T3>(arg3: T3): FunctionChain<
            T extends Function3<infer T1, infer T2, T3, infer R> ? Function2<T1, T2, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T1, T3>(arg1: T1, plc2: __, arg3: T3): FunctionChain<
            T extends Function3<T1, infer T2, T3, infer R> ? Function1<T2, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T2, T3>(arg2: T2, arg3: T3): FunctionChain<
            T extends Function3<infer T1, T2, T3, infer R> ? Function1<T1, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T1>(arg1: T1, plc2: __, plc3: __, plc4: __): FunctionChain<
            T extends Function4<T1, infer T2, infer T3, infer T4, infer R> ? Function3<T2, T3, T4, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T2>(arg2: T2, plc3: __, plc4: __): FunctionChain<
            T extends Function4<infer T1, T2, infer T3, infer T4, infer R> ? Function3<T1, T3, T4, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T1, T2>(arg1: T1, arg2: T2, plc3: __, plc4: __): FunctionChain<
            T extends Function4<T1, T2, infer T3, infer T4, infer R> ? Function2<T3, T4, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T3>(arg3: T3, plc4: __): FunctionChain<
            T extends Function4<infer T1, infer T2, T3, infer T4, infer R> ? Function3<T1, T2, T4, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T1, T3>(arg1: T1, plc2: __, arg3: T3, plc4: __): FunctionChain<
            T extends Function4<T1, infer T2, infer T3, infer T4, infer R> ? Function2<T2, T4, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T2, T3>(arg2: T2, arg3: T3, plc4: __): FunctionChain<
            T extends Function4<infer T1, T2, T3, infer T4, infer R> ? Function2<T1, T4, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T1, T2, T3>(arg1: T1, arg2: T2, arg3: T3, plc4: __): FunctionChain<
            T extends Function4<T1, T2, T3, infer T4, infer R> ? Function1<T4, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T4>(arg4: T4): FunctionChain<
            T extends Function4<infer T1, infer T2, infer T3, T4, infer R> ? Function3<T1, T2, T3, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T1, T4>(arg1: T1, plc2: __, plc3: __, arg4: T4): FunctionChain<
            T extends Function4<T1, infer T2, infer T3, T4, infer R> ? Function2<T2, T3, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T2, T4>(arg2: T2, plc3: __, arg4: T4): FunctionChain<
            T extends Function4<infer T1, T2, infer T3, T4, infer R> ? Function2<T1, T3, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T1, T2, T4>(arg1: T1, arg2: T2, plc3: __, arg4: T4): FunctionChain<
            T extends Function4<T1, T2, infer T3, T4, infer R> ? Function1<T3, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T3, T4>(arg3: T3, arg4: T4): FunctionChain<
            T extends Function4<infer T1, infer T2, T3, T4, infer R> ? Function2<T1, T2, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T1, T3, T4>(arg1: T1, plc2: __, arg3: T3, arg4: T4): FunctionChain<
            T extends Function4<T1, infer T2, T3, T4, infer R> ? Function1<T2, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<T2, T3, T4>(arg2: T2, arg3: T3, arg4: T4): FunctionChain<
            T extends Function4<infer T1, T2, T3, T4, infer R> ? Function1<T1, R> :
            any
        >;
        /**
         * @see _.partialRight
         */
        partialRight<TS extends any[]>(...ts: TS): FunctionChain<T extends (...args: TS) => infer R ? () => R : any>;
        /**
         * @see _.partialRight
         */
        partialRight(): FunctionChain<T extends (...ts: any[]) => any ? T : any>;
    }
    interface LoDashStatic {
        /**
         * Creates a function that invokes func with arguments arranged according to the specified indexes where the
         * argument value at the first index is provided as the first argument, the argument value at the second index
         * is provided as the second argument, and so on.
         * @param func The function to rearrange arguments for.
         * @param indexes The arranged argument indexes, specified as individual indexes or arrays of indexes.
         * @return Returns the new function.
         */
        rearg(func: (...args: any[]) => any, ...indexes: Array<Many<number>>): (...args: any[]) => any;
    }
    interface Function<T extends (...args: any) => any> {
        /**
         * @see _.rearg
         */
        rearg(...indexes: Array<Many<number>>): Function<(...args: any[]) => any>;
    }
    interface FunctionChain<T extends (...args: any) => any> {
        /**
         * @see _.rearg
         */
        rearg(...indexes: Array<Many<number>>): FunctionChain<(...args: any[]) => any>;
    }
    interface LoDashStatic {
        /**
         * Creates a function that invokes func with the this binding of the created function and arguments from start
         * and beyond provided as an array.
         *
         * Note: This method is based on the rest parameter.
         *
         * @param func The function to apply a rest parameter to.
         * @param start The start position of the rest parameter.
         * @return Returns the new function.
         */
        rest(func: (...args: any[]) => any, start?: number): (...args: any[]) => any;
    }
    interface Function<T extends (...args: any) => any> {
        /**
         * @see _.rest
         */
        rest(start?: number): Function<(...args: any[]) => any>;
    }
    interface FunctionChain<T extends (...args: any) => any> {
        /**
         * @see _.rest
         */
        rest(start?: number): FunctionChain<(...args: any[]) => any>;
    }
    interface LoDashStatic {
        /**
         * Creates a function that invokes func with the this binding of the created function and an array of arguments
         * much like Function#apply.
         *
         * Note: This method is based on the spread operator.
         *
         * @param func The function to spread arguments over.
         * @return Returns the new function.
         */
        spread<TResult>(func: (...args: any[]) => TResult, start?: number): (...args: any[]) => TResult;
    }
    interface Function<T extends (...args: any) => any> {
        /**
         * @see _.spread
         */
        spread(start?: number): Function<(...args: any[]) => ReturnType<T>>;
    }
    interface FunctionChain<T extends (...args: any) => any> {
        /**
         * @see _.spread
         */
        spread(start?: number): FunctionChain<(...args: any[]) => ReturnType<T>>;
    }
    interface ThrottleSettings {
        /**
         * @see _.leading
         */
        leading?: boolean | undefined;
        /**
         * @see _.trailing
         */
        trailing?: boolean | undefined;
    }
    type ThrottleSettingsLeading = (ThrottleSettings & { leading: true }) | Omit<ThrottleSettings, 'leading'>
    interface LoDashStatic {
        /**
         * Creates a throttled function that only invokes func at most once per every wait milliseconds. The throttled
         * function comes with a cancel method to cancel delayed invocations and a flush method to immediately invoke
         * them. Provide an options object to indicate that func should be invoked on the leading and/or trailing edge
         * of the wait timeout. Subsequent calls to the throttled function return the result of the last func call.
         *
         * Note: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only if
         * the the throttled function is invoked more than once during the wait timeout.
         *
         * @param func The function to throttle.
         * @param wait The number of milliseconds to throttle invocations to.
         * @param options The options object.
         * @param options.leading Specify invoking on the leading edge of the timeout.
         * @param options.trailing Specify invoking on the trailing edge of the timeout.
         * @return Returns the new throttled function.
         */
        throttle<T extends (...args: any) => any>(func: T, wait?: number, options?: ThrottleSettingsLeading): DebouncedFuncLeading<T>;
        throttle<T extends (...args: any) => any>(func: T, wait?: number, options?: ThrottleSettings): DebouncedFunc<T>;
    }
    interface Function<T extends (...args: any) => any> {
        /**
         * @see _.throttle
         */
        throttle(
            wait?: number,
            options?: ThrottleSettingsLeading
        ): T extends (...args: any[]) => any ? Function<DebouncedFuncLeading<T>> : never;
        throttle(
            wait?: number,
            options?: ThrottleSettings
        ): T extends (...args: any[]) => any ? Function<DebouncedFunc<T>> : never;
    }
    interface FunctionChain<T extends (...args: any) => any> {
        /**
         * @see _.throttle
         */
        throttle(
            wait?: number,
            options?: ThrottleSettingsLeading
        ): T extends (...args: any[]) => any ? FunctionChain<DebouncedFuncLeading<T>> : never;
        throttle(
            wait?: number,
            options?: ThrottleSettings
        ): T extends (...args: any[]) => any ? FunctionChain<DebouncedFunc<T>> : never;
    }
    interface LoDashStatic {
        /**
         * Creates a function that accepts up to one argument, ignoring any
         * additional arguments.
         *
         * @category Function
         * @param func The function to cap arguments for.
         * @returns Returns the new function.
         * @example
         *
         * _.map(['6', '8', '10'], _.unary(parseInt));
         * // => [6, 8, 10]
         */
        unary<T, TResult>(func: (arg1: T, ...args: any[]) => TResult): (arg1: T) => TResult;
    }
    interface Function<T extends (...args: any) => any> {
        /**
         * @see _.unary
         */
        unary(): Function<(arg1: Parameters<T>['0']) => ReturnType<T>>;
    }
    interface FunctionChain<T extends (...args: any) => any> {
        /**
         * @see _.unary
         */
        unary(): FunctionChain<(arg1: Parameters<T>['0']) => ReturnType<T>>;
    }
    interface LoDashStatic {
        /**
         * Creates a function that provides value to the wrapper function as its first argument. Any additional
         * arguments provided to the function are appended to those provided to the wrapper function. The wrapper is
         * invoked with the this binding of the created function.
         *
         * @param value The value to wrap.
         * @param wrapper The wrapper function.
         * @return Returns the new function.
         */
        wrap<T, TArgs, TResult>(value: T, wrapper: (value: T, ...args: TArgs[]) => TResult): (...args: TArgs[]) => TResult;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.wrap
         */
        wrap<TArgs, TResult>(wrapper: (value: TValue, ...args: TArgs[]) => TResult): Function<(...args: TArgs[]) => TResult>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.wrap
         */
        wrap<TArgs, TResult>(wrapper: (value: TValue, ...args: TArgs[]) => TResult): FunctionChain<(...args: TArgs[]) => TResult>;
    }
}
import _ = require("../index");
// eslint-disable-next-line @definitelytyped/strict-export-declare-modifiers
type GlobalFunction = Function;
declare module "../index" {
    type FunctionBase = GlobalFunction;
    interface LoDashStatic {
        /**
         * Casts value as an array if it’s not one.
         *
         * @param value The value to inspect.
         * @return Returns the cast array.
         */
        castArray<T>(value?: Many<T>): T[];
    }
    interface Collection<T> {
        /**
         * @see _.castArray
         */
        castArray(): Collection<T>;
    }
    interface String {
        /**
         * @see _.castArray
         */
        castArray(): Collection<string>;
    }
    interface Object<T> {
        /**
         * @see _.castArray
         */
        castArray(): Collection<T>;
    }
    interface Function<T extends (...args: any) => any> {
        /**
         * @see _.castArray
         */
        castArray(): Collection<T>;
    }
    interface Primitive<T> {
        /**
         * @see _.castArray
         */
        castArray(): Collection<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.castArray
         */
        castArray(): CollectionChain<T>;
    }
    interface StringChain {
        /**
         * @see _.castArray
         */
        castArray(): CollectionChain<string>;
    }
    interface StringNullableChain {
        /**
         * @see _.castArray
         */
        castArray(): CollectionChain<string | undefined>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.castArray
         */
        castArray(): CollectionChain<T>;
    }
    interface FunctionChain<T extends (...args: any) => any> {
        /**
         * @see _.castArray
         */
        castArray(): CollectionChain<T>;
    }
    interface PrimitiveChain<T> {
        /**
         * @see _.castArray
         */
        castArray(): CollectionChain<T>;
    }

    interface LoDashStatic {
        /**
         * Creates a shallow clone of value.
         *
         * Note: This method is loosely based on the structured clone algorithm and supports cloning arrays,
         * array buffers, booleans, date objects, maps, numbers, Object objects, regexes, sets, strings, symbols,
         * and typed arrays. The own enumerable properties of arguments objects are cloned as plain objects. An empty
         * object is returned for uncloneable values such as error objects, functions, DOM nodes, and WeakMaps.
         *
         * @param value The value to clone.
         * @return Returns the cloned value.
         */
        clone<T>(value: T): T;
    }

    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.clone
         */
        clone(): TValue;
        /**
         * @see _.cloneDeep
         */
        cloneDeep(): TValue;
        /**
         * @see _.cloneDeepWith
         */
        cloneDeepWith(customizer: CloneDeepWithCustomizer<TValue>): any;
        /**
         * @see _.cloneDeepWith
         */
        cloneDeepWith(): TValue;
        /**
         * @see _.cloneWith
         */
        cloneWith<TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<TValue, TResult>): TResult;
        /**
         * @see _.cloneWith
         */
        cloneWith<TResult>(customizer: CloneWithCustomizer<TValue, TResult | undefined>): TResult | TValue;
        /**
         * @see _.cloneWith
         */
        cloneWith(): TValue;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.clone
         */
        clone(): this;
        /**
         * @see _.cloneDeep
         */
        cloneDeep(): this;
        /**
         * @see _.cloneDeepWith
         */
        cloneDeepWith(customizer: CloneDeepWithCustomizer<TValue>): LoDashExplicitWrapper<any>;
        /**
         * @see _.cloneDeepWith
         */
        cloneDeepWith(): this;
        /**
         * @see _.cloneWith
         */
        cloneWith<TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<TValue, TResult>): ExpChain<TResult>;
        /**
         * @see _.cloneWith
         */
        cloneWith<TResult>(customizer: CloneWithCustomizer<TValue, TResult | undefined>): ExpChain<TResult | TValue>;
        /**
         * @see _.cloneWith
         */
        cloneWith(): this;
    }

    interface LoDashStatic {
        /**
         * This method is like _.clone except that it recursively clones value.
         *
         * @param value The value to recursively clone.
         * @return Returns the deep cloned value.
         */
        cloneDeep<T>(value: T): T;
    }
    type CloneDeepWithCustomizer<TObject> = (value: any, key: number | string | undefined, object: TObject | undefined, stack: any) => any;
    interface LoDashStatic {
        /**
         * This method is like _.cloneWith except that it recursively clones value.
         *
         * @param value The value to recursively clone.
         * @param customizer The function to customize cloning.
         * @return Returns the deep cloned value.
         */
        cloneDeepWith<T>(value: T, customizer: CloneDeepWithCustomizer<T>): any;
        /**
         * @see _.cloneDeepWith
         */
        cloneDeepWith<T>(value: T): T;
    }
    type CloneWithCustomizer<TValue, TResult> = (value: TValue, key: number | string | undefined, object: any, stack: any) => TResult;
    interface LoDashStatic {
        /**
         * This method is like _.clone except that it accepts customizer which is invoked to produce the cloned value.
         * If customizer returns undefined cloning is handled by the method instead.
         *
         * @param value The value to clone.
         * @param customizer The function to customize cloning.
         * @return Returns the cloned value.
         */
        cloneWith<T, TResult extends object | string | number | boolean | null>(value: T, customizer: CloneWithCustomizer<T, TResult>): TResult;
        /**
         * @see _.cloneWith
         */
        cloneWith<T, TResult>(value: T, customizer: CloneWithCustomizer<T, TResult | undefined>): TResult | T;
        /**
         * @see _.cloneWith
         */
        cloneWith<T>(value: T): T;
    }
    interface LoDashStatic {
        /**
         * Checks if object conforms to source by invoking the predicate properties of source with the
         * corresponding property values of object.
         *
         * Note: This method is equivalent to _.conforms when source is partially applied.
         */
        conformsTo<T>(object: T, source: ConformsPredicateObject<T>): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.conformsTo
         */
        conformsTo(source: ConformsPredicateObject<TValue>): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.conformsTo
         */
        conformsTo(source: ConformsPredicateObject<TValue>): PrimitiveChain<boolean>;
    }
    type CondPairNullary<R> = [() => boolean, () => R];
    type CondPairUnary<T, R> = [(val: T) => boolean, (val: T) => R];
    interface LoDashStatic {
        /**
         * Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * comparison between two values to determine if they are equivalent.
         *
         * @category Lang
         * @param value The value to compare.
         * @param other The other value to compare.
         * @returns Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'user': 'fred' };
         * var other = { 'user': 'fred' };
         *
         * _.eq(object, object);
         * // => true
         *
         * _.eq(object, other);
         * // => false
         *
         * _.eq('a', 'a');
         * // => true
         *
         * _.eq('a', Object('a'));
         * // => false
         *
         * _.eq(NaN, NaN);
         * // => true
         */
        eq(value: any, other: any): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.eq
         */
        eq(other: any): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.eq
         */
        eq(other: any): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is greater than other.
         *
         * @param value The value to compare.
         * @param other The other value to compare.
         * @return Returns true if value is greater than other, else false.
         */
        gt(value: any, other: any): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.gt
         */
        gt(other: any): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.gt
         */
        gt(other: any): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is greater than or equal to other.
         *
         * @param value The value to compare.
         * @param other The other value to compare.
         * @return Returns true if value is greater than or equal to other, else false.
         */
        gte(value: any, other: any): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.gte
         */
        gte(other: any): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.gte
         */
        gte(other: any): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is classified as an arguments object.
         *
         * @param value The value to check.
         * @return Returns true if value is correctly classified, else false.
         */
        isArguments(value?: any): value is IArguments;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isArguments
         */
        isArguments(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isArguments
         */
        isArguments(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is classified as an Array object.
         * @param value The value to check.
         *
         * @return Returns true if value is correctly classified, else false.
         */
        isArray(value?: any): value is any[];
        /**
         * @see _.isArray
         */
        isArray<T>(value?: any): value is any[];
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isArray
         */
        isArray(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isArray
         */
        isArray(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is classified as an ArrayBuffer object.
         *
         * @param value The value to check.
         * @return Returns true if value is correctly classified, else false.
         */
        isArrayBuffer(value?: any): value is ArrayBuffer;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isArrayBuffer
         */
        isArrayBuffer(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isArrayBuffer
         */
        isArrayBuffer(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if `value` is array-like. A value is considered array-like if it's
         * not a function and has a `value.length` that's an integer greater than or
         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
         *
         * @category Lang
         * @param value The value to check.
         * @returns Returns `true` if `value` is array-like, else `false`.
         * @example
         *
         * _.isArrayLike([1, 2, 3]);
         * // => true
         *
         * _.isArrayLike(document.body.children);
         * // => true
         *
         * _.isArrayLike('abc');
         * // => true
         *
         * _.isArrayLike(_.noop);
         * // => false
         */
        isArrayLike<T extends { __lodashAnyHack: any }>(t: T): boolean;
        /**
         * @see _.isArrayLike
         */
        isArrayLike(value: ((...args: any[]) => any) | null | undefined): value is never;
        /**
         * @see _.isArrayLike
         */
        isArrayLike(value: any): value is { length: number };
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isArrayLike
         */
        isArrayLike(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isArrayLike
         */
        isArrayLike(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * This method is like `_.isArrayLike` except that it also checks if `value`
         * is an object.
         *
         * @category Lang
         * @param value The value to check.
         * @returns Returns `true` if `value` is an array-like object, else `false`.
         * @example
         *
         * _.isArrayLikeObject([1, 2, 3]);
         * // => true
         *
         * _.isArrayLikeObject(document.body.children);
         * // => true
         *
         * _.isArrayLikeObject('abc');
         * // => false
         *
         * _.isArrayLikeObject(_.noop);
         * // => false
         */
        isArrayLikeObject<T extends { __lodashAnyHack: any }>(value: T): boolean;
        /**
         * @see _.isArrayLikeObject
         */
        isArrayLikeObject(value: ((...args: any[]) => any) | FunctionBase | string | boolean | number | null | undefined): value is never;
        /**
         * @see _.isArrayLikeObject
         */
        isArrayLikeObject(value: any): value is object & { length: number };
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isArrayLikeObject
         */
        isArrayLikeObject(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isArrayLikeObject
         */
        isArrayLikeObject(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is classified as a boolean primitive or object.
         *
         * @param value The value to check.
         * @return Returns true if value is correctly classified, else false.
         */
        isBoolean(value?: any): value is boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isBoolean
         */
        isBoolean(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isBoolean
         */
        isBoolean(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is a buffer.
         *
         * @param value The value to check.
         * @return Returns true if value is a buffer, else false.
         */
        isBuffer(value?: any): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isBuffer
         */
        isBuffer(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isBuffer
         */
        isBuffer(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is classified as a Date object.
         * @param value The value to check.
         *
         * @return Returns true if value is correctly classified, else false.
         */
        isDate(value?: any): value is Date;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isDate
         */
        isDate(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isDate
         */
        isDate(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is a DOM element.
         *
         * @param value The value to check.
         * @return Returns true if value is a DOM element, else false.
         */
        isElement(value?: any): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isElement
         */
        isElement(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isElement
         */
        isElement(): PrimitiveChain<boolean>;
    }

    type EmptyObject<T> = { [K in keyof T]?: never };
    type EmptyObjectOf<T> = EmptyObject<T> extends T ? EmptyObject<T> : never;
    interface LoDashStatic {
        /**
         * Checks if value is empty. A value is considered empty unless it’s an arguments object, array, string, or
         * jQuery-like collection with a length greater than 0 or an object with own enumerable properties.
         *
         * @param value The value to inspect.
         * @return Returns true if value is empty, else false.
         */
        isEmpty<T extends { __trapAny: any }>(value?: T): boolean;
        isEmpty(value: string): value is '';
        isEmpty(value: Map<any, any> | Set<any> | List<any> | null | undefined): boolean;
        isEmpty(value: object): boolean;
        isEmpty<T extends object>(value: T | null | undefined): value is EmptyObjectOf<T> | null | undefined;
        isEmpty(value?: any): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isEmpty
         */
        isEmpty(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isEmpty
         */
        isEmpty(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Performs a deep comparison between two values to determine if they are
         * equivalent.
         *
         * **Note:** This method supports comparing arrays, array buffers, booleans,
         * date objects, error objects, maps, numbers, `Object` objects, regexes,
         * sets, strings, symbols, and typed arrays. `Object` objects are compared
         * by their own, not inherited, enumerable properties. Functions and DOM
         * nodes are **not** supported.
         *
         * @category Lang
         * @param value The value to compare.
         * @param other The other value to compare.
         * @returns Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'user': 'fred' };
         * var other = { 'user': 'fred' };
         *
         * _.isEqual(object, other);
         * // => true
         *
         * object === other;
         * // => false
         */
        isEqual(value: any, other: any): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isEqual
         */
        isEqual(other: any): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isEqual
         */
        isEqual(other: any): PrimitiveChain<boolean>;
    }

    type IsEqualCustomizer = (value: any, other: any, indexOrKey: PropertyName | undefined, parent: any, otherParent: any, stack: any) => boolean | undefined;
    interface LoDashStatic {
        /**
         * This method is like `_.isEqual` except that it accepts `customizer` which is
         * invoked to compare values. If `customizer` returns `undefined` comparisons are
         * handled by the method instead. The `customizer` is invoked with up to seven arguments:
         * (objValue, othValue [, index|key, object, other, stack]).
         *
         * @category Lang
         * @param value The value to compare.
         * @param other The other value to compare.
         * @param [customizer] The function to customize comparisons.
         * @returns Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * function isGreeting(value) {
         *   return /^h(?:i|ello)$/.test(value);
         * }
         *
         * function customizer(objValue, othValue) {
         *   if (isGreeting(objValue) && isGreeting(othValue)) {
         *     return true;
         *   }
         * }
         *
         * var array = ['hello', 'goodbye'];
         * var other = ['hi', 'goodbye'];
         *
         * _.isEqualWith(array, other, customizer);
         * // => true
         */
        isEqualWith(value: any, other: any, customizer?: IsEqualCustomizer): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isEqualWith
         */
        isEqualWith(other: any, customizer?: IsEqualCustomizer): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isEqualWith
         */
        isEqualWith(other: any, customizer?: IsEqualCustomizer): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is an Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, or URIError
         * object.
         *
         * @param value The value to check.
         * @return Returns true if value is an error object, else false.
         */
        isError(value: any): value is Error;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isError
         */
        isError(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isError
         */
        isError(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is a finite primitive number.
         *
         * Note: This method is based on Number.isFinite.
         *
         * @param value The value to check.
         * @return Returns true if value is a finite number, else false.
         */
        isFinite(value?: any): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isFinite
         */
        isFinite(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isFinite
         */
        isFinite(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is a callable function.
         *
         * @param value The value to check.
         * @return Returns true if value is correctly classified, else false.
         */
        isFunction(value: any): value is (...args: any[]) => any;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isFunction
         */
        isFunction(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isFunction
         */
        isFunction(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if `value` is an integer.
         *
         * **Note:** This method is based on [`Number.isInteger`](https://mdn.io/Number/isInteger).
         *
         * @category Lang
         * @param value The value to check.
         * @returns Returns `true` if `value` is an integer, else `false`.
         * @example
         *
         * _.isInteger(3);
         * // => true
         *
         * _.isInteger(Number.MIN_VALUE);
         * // => false
         *
         * _.isInteger(Infinity);
         * // => false
         *
         * _.isInteger('3');
         * // => false
         */
        isInteger(value?: any): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isInteger
         */
        isInteger(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isInteger
         */
        isInteger(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
         *
         * @category Lang
         * @param value The value to check.
         * @returns Returns `true` if `value` is a valid length, else `false`.
         * @example
         *
         * _.isLength(3);
         * // => true
         *
         * _.isLength(Number.MIN_VALUE);
         * // => false
         *
         * _.isLength(Infinity);
         * // => false
         *
         * _.isLength('3');
         * // => false
         */
        isLength(value?: any): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isLength
         */
        isLength(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isLength
         */
        isLength(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is classified as a Map object.
         *
         * @param value The value to check.
         * @returns Returns true if value is correctly classified, else false.
         */
        isMap(value?: any): value is Map<any, any>;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isMap
         */
        isMap(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isMap
         */
        isMap(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Performs a deep comparison between `object` and `source` to determine if
         * `object` contains equivalent property values.
         *
         * **Note:** This method supports comparing the same values as `_.isEqual`.
         *
         * @category Lang
         * @param object The object to inspect.
         * @param source The object of property values to match.
         * @returns Returns `true` if `object` is a match, else `false`.
         * @example
         *
         * var object = { 'user': 'fred', 'age': 40 };
         *
         * _.isMatch(object, { 'age': 40 });
         * // => true
         *
         * _.isMatch(object, { 'age': 36 });
         * // => false
         */
        isMatch(object: object, source: object): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isMatch
         */
        isMatch(source: object): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isMatch
         */
        isMatch(source: object): PrimitiveChain<boolean>;
    }

    type isMatchWithCustomizer = (value: any, other: any, indexOrKey: PropertyName, object: object, source: object) => boolean | undefined;
    interface LoDashStatic {
        /**
         * This method is like `_.isMatch` except that it accepts `customizer` which
         * is invoked to compare values. If `customizer` returns `undefined` comparisons
         * are handled by the method instead. The `customizer` is invoked with three
         * arguments: (objValue, srcValue, index|key, object, source).
         *
         * @category Lang
         * @param object The object to inspect.
         * @param source The object of property values to match.
         * @param [customizer] The function to customize comparisons.
         * @returns Returns `true` if `object` is a match, else `false`.
         * @example
         *
         * function isGreeting(value) {
         *   return /^h(?:i|ello)$/.test(value);
         * }
         *
         * function customizer(objValue, srcValue) {
         *   if (isGreeting(objValue) && isGreeting(srcValue)) {
         *     return true;
         *   }
         * }
         *
         * var object = { 'greeting': 'hello' };
         * var source = { 'greeting': 'hi' };
         *
         * _.isMatchWith(object, source, customizer);
         * // => true
         */
        isMatchWith(object: object, source: object, customizer: isMatchWithCustomizer): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isMatchWith
         */
        isMatchWith(source: object, customizer: isMatchWithCustomizer): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isMatchWith
         */
        isMatchWith(source: object, customizer: isMatchWithCustomizer): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is NaN.
         *
         * Note: This method is not the same as isNaN which returns true for undefined and other non-numeric values.
         *
         * @param value The value to check.
         * @return Returns true if value is NaN, else false.
         */
        isNaN(value?: any): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isNaN
         */
        isNaN(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isNaN
         */
        isNaN(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is a native function.
         * @param value The value to check.
         *
         * @return Returns true if value is a native function, else false.
         */
        isNative(value: any): value is (...args: any[]) => any;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isNative
         */
        isNative(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isNative
         */
        isNative(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if `value` is `null` or `undefined`.
         *
         * @category Lang
         * @param value The value to check.
         * @returns Returns `true` if `value` is nullish, else `false`.
         * @example
         *
         * _.isNil(null);
         * // => true
         *
         * _.isNil(void 0);
         * // => true
         *
         * _.isNil(NaN);
         * // => false
         */
        isNil(value: any): value is null | undefined;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isNil
         */
        isNil(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isNil
         */
        isNil(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is null.
         *
         * @param value The value to check.
         * @return Returns true if value is null, else false.
         */
        isNull(value: any): value is null;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isNull
         */
        isNull(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isNull
         */
        isNull(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is classified as a Number primitive or object.
         *
         * Note: To exclude Infinity, -Infinity, and NaN, which are classified as numbers, use the _.isFinite method.
         *
         * @param value The value to check.
         * @return Returns true if value is correctly classified, else false.
         */
        isNumber(value?: any): value is number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isNumber
         */
        isNumber(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isNumber
         */
        isNumber(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is the language type of Object. (e.g. arrays, functions, objects, regexes, new Number(0),
         * and new String(''))
         *
         * @param value The value to check.
         * @return Returns true if value is an object, else false.
         */
        isObject(value?: any): value is object;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isObject
         */
        isObject(): this is LoDashImplicitWrapper<object>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isObject
         */
        isObject(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if `value` is object-like. A value is object-like if it's not `null`
         * and has a `typeof` result of "object".
         *
         * @category Lang
         * @param value The value to check.
         * @returns Returns `true` if `value` is object-like, else `false`.
         * @example
         *
         * _.isObjectLike({});
         * // => true
         *
         * _.isObjectLike([1, 2, 3]);
         * // => true
         *
         * _.isObjectLike(_.noop);
         * // => false
         *
         * _.isObjectLike(null);
         * // => false
         */
        isObjectLike(value?: any): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isObjectLike
         */
        isObjectLike(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isObjectLike
         */
        isObjectLike(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is a plain object, that is, an object created by the Object constructor or one with a
         * [[Prototype]] of null.
         *
         * Note: This method assumes objects created by the Object constructor have no inherited enumerable properties.
         *
         * @param value The value to check.
         * @return Returns true if value is a plain object, else false.
         */
        isPlainObject(value?: any): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isPlainObject
         */
        isPlainObject(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isPlainObject
         */
        isPlainObject(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is classified as a RegExp object.
         * @param value The value to check.
         *
         * @return Returns true if value is correctly classified, else false.
         */
        isRegExp(value?: any): value is RegExp;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isRegExp
         */
        isRegExp(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isRegExp
         */
        isRegExp(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
         * double precision number which isn't the result of a rounded unsafe integer.
         *
         * **Note:** This method is based on [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
         *
         * @category Lang
         * @param value The value to check.
         * @returns Returns `true` if `value` is a safe integer, else `false`.
         * @example
         *
         * _.isSafeInteger(3);
         * // => true
         *
         * _.isSafeInteger(Number.MIN_VALUE);
         * // => false
         *
         * _.isSafeInteger(Infinity);
         * // => false
         *
         * _.isSafeInteger('3');
         * // => false
         */
        isSafeInteger(value: any): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isSafeInteger
         */
        isSafeInteger(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isSafeInteger
         */
        isSafeInteger(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is classified as a Set object.
         *
         * @param value The value to check.
         * @returns Returns true if value is correctly classified, else false.
         */
        isSet(value?: any): value is Set<any>;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isSet
         */
        isSet(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isSet
         */
        isSet(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is classified as a String primitive or object.
         *
         * @param value The value to check.
         * @return Returns true if value is correctly classified, else false.
         */
        isString(value?: any): value is string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isString
         */
        isString(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isString
         */
        isString(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if `value` is classified as a `Symbol` primitive or object.
         *
         * @category Lang
         * @param value The value to check.
         * @returns Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isSymbol(Symbol.iterator);
         * // => true
         *
         * _.isSymbol('abc');
         * // => false
         */
        isSymbol(value: any): value is symbol;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isSymbol
         */
        isSymbol(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isSymbol
         */
        isSymbol(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is classified as a typed array.
         *
         * @param value The value to check.
         * @return Returns true if value is correctly classified, else false.
         */
        isTypedArray(value: any): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isTypedArray
         */
        isTypedArray(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isTypedArray
         */
        isTypedArray(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is undefined.
         *
         * @param value The value to check.
         * @return Returns true if value is undefined, else false.
         */
        isUndefined(value: any): value is undefined;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isUndefined
         */
        isUndefined(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isUndefined
         */
        isUndefined(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is classified as a WeakMap object.
         *
         * @param value The value to check.
         * @returns Returns true if value is correctly classified, else false.
         */
        isWeakMap(value?: any): value is WeakMap<object, any>;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isWeakMap
         */
        isWeakMap(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isWeakMap
         */
        isWeakMap(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is classified as a WeakSet object.
         *
         * @param value The value to check.
         * @returns Returns true if value is correctly classified, else false.
         */
        isWeakSet(value?: any): value is WeakSet<object>;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.isWeakSet
         */
        isWeakSet(): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.isWeakSet
         */
        isWeakSet(): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is less than other.
         *
         * @param value The value to compare.
         * @param other The other value to compare.
         * @return Returns true if value is less than other, else false.
         */
        lt(value: any, other: any): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.lt
         */
        lt(other: any): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.lt
         */
        lt(other: any): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Checks if value is less than or equal to other.
         *
         * @param value The value to compare.
         * @param other The other value to compare.
         * @return Returns true if value is less than or equal to other, else false.
         */
        lte(value: any, other: any): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.lte
         */
        lte(other: any): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.lte
         */
        lte(other: any): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Converts value to an array.
         *
         * @param value The value to convert.
         * @return Returns the converted array.
         */
        toArray<T>(value:  Dictionary<T> | NumericDictionary<T> | null | undefined): T[];
        /**
         * @see _.toArray
         */
        toArray<T>(value: T): Array<T[keyof T]>;
        /**
         * @see _.toArray
         */
        toArray(): any[];
    }
    interface String {
        /**
         * @see _.toArray
         */
        toArray(): Collection<string>;
    }
    interface Collection<T> {
        /**
         * @see _.toArray
         */
        toArray(): Collection<T>;
    }
    interface Object<T> {
        /**
         * @see _.toArray
         */
        toArray(): Collection<T[keyof T]>;
    }
    interface StringChain {
        /**
         * @see _.toArray
         */
        toArray(): CollectionChain<string>;
    }
    interface StringNullableChain {
        /**
         * @see _.toArray
         */
        toArray(): CollectionChain<string>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.toArray
         */
        toArray(): CollectionChain<T>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.toArray
         */
        toArray(): CollectionChain<T[keyof T]>;
    }

    interface LoDashStatic {
        /**
         * Converts `value` to a finite number.
         *
         * @since 4.12.0
         * @category Lang
         * @param value The value to convert.
         * @returns Returns the converted number.
         * @example
         *
         * _.toFinite(3.2);
         * // => 3.2
         *
         * _.toFinite(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toFinite(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toFinite('3.2');
         * // => 3.2
         */
        toFinite(value: any): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.toFinite
         */
        toFinite(): number;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.toFinite
         */
        toFinite(): PrimitiveChain<number>;
    }

    interface LoDashStatic {
        /**
         * Converts `value` to an integer.
         *
         * **Note:** This function is loosely based on [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
         *
         * @category Lang
         * @param value The value to convert.
         * @returns Returns the converted integer.
         * @example
         *
         * _.toInteger(3);
         * // => 3
         *
         * _.toInteger(Number.MIN_VALUE);
         * // => 0
         *
         * _.toInteger(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toInteger('3');
         * // => 3
         */
        toInteger(value: any): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.toInteger
         */
        toInteger(): number;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.toInteger
         */
        toInteger(): PrimitiveChain<number>;
    }

    interface LoDashStatic {
        /**
         * Converts `value` to an integer suitable for use as the length of an
         * array-like object.
         *
         * **Note:** This method is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
         *
         * @category Lang
         * @param value The value to convert.
         * @return Returns the converted integer.
         * @example
         *
         * _.toLength(3);
         * // => 3
         *
         * _.toLength(Number.MIN_VALUE);
         * // => 0
         *
         * _.toLength(Infinity);
         * // => 4294967295
         *
         * _.toLength('3');
         * // => 3
         */
        toLength(value: any): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.toLength
         */
        toLength(): number;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.toLength
         */
        toLength(): PrimitiveChain<number>;
    }

    interface LoDashStatic {
        /**
         * Converts `value` to a number.
         *
         * @category Lang
         * @param value The value to process.
         * @returns Returns the number.
         * @example
         *
         * _.toNumber(3);
         * // => 3
         *
         * _.toNumber(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toNumber(Infinity);
         * // => Infinity
         *
         * _.toNumber('3');
         * // => 3
         */
        toNumber(value: any): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.toNumber
         */
        toNumber(): number;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.toNumber
         */
        toNumber(): PrimitiveChain<number>;
    }

    interface LoDashStatic {
        /**
         * Converts value to a plain object flattening inherited enumerable properties of value to own properties
         * of the plain object.
         *
         * @param value The value to convert.
         * @return Returns the converted plain object.
         */
        toPlainObject(value?: any): any;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.toPlainObject
         */
        toPlainObject(): Object<any>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.toPlainObject
         */
        toPlainObject(): ObjectChain<any>;
    }

    interface LoDashStatic {
        /**
         * Converts `value` to a safe integer. A safe integer can be compared and
         * represented correctly.
         *
         * @category Lang
         * @param value The value to convert.
         * @returns Returns the converted integer.
         * @example
         *
         * _.toSafeInteger(3);
         * // => 3
         *
         * _.toSafeInteger(Number.MIN_VALUE);
         * // => 0
         *
         * _.toSafeInteger(Infinity);
         * // => 9007199254740991
         *
         * _.toSafeInteger('3');
         * // => 3
         */
        toSafeInteger(value: any): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.toSafeInteger
         */
        toSafeInteger(): number;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.toSafeInteger
         */
        toSafeInteger(): PrimitiveChain<number>;
    }

    interface LoDashStatic {
        /**
         * Converts `value` to a string if it's not one. An empty string is returned
         * for `null` and `undefined` values. The sign of `-0` is preserved.
         *
         * @category Lang
         * @param value The value to process.
         * @returns Returns the string.
         * @example
         *
         * _.toString(null);
         * // => ''
         *
         * _.toString(-0);
         * // => '-0'
         *
         * _.toString([1, 2, 3]);
         * // => '1,2,3'
         */
        toString(value: any): string;
    }
}
import _ = require("../index");
declare module "../index" {
    interface LoDashStatic {
        /**
         * Adds two numbers.
         *
         * @param augend The first number to add.
         * @param addend The second number to add.
         * @return Returns the sum.
         */
        add(augend: number, addend: number): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.add
         */
        add(addend: number): number;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.add
         */
        add(addend: number): PrimitiveChain<number>;
    }

    interface LoDashStatic {
        /**
         * Calculates n rounded up to precision.
         *
         * @param n The number to round up.
         * @param precision The precision to round up to.
         * @return Returns the rounded up number.
         */
        ceil(n: number, precision?: number): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.ceil
         */
        ceil(precision?: number): number;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.ceil
         */
        ceil(precision?: number): PrimitiveChain<number>;
    }

    interface LoDashStatic {
        /**
        * Divide two numbers.
        *
        * @param dividend The first number in a division.
        * @param divisor The second number in a division.
        * @returns Returns the quotient.
         */
        divide(dividend: number, divisor: number): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.divide
         */
        divide(divisor: number): number;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.divide
         */
        divide(divisor: number): PrimitiveChain<number>;
    }

    interface LoDashStatic {
        /**
         * Calculates n rounded down to precision.
         *
         * @param n The number to round down.
         * @param precision The precision to round down to.
         * @return Returns the rounded down number.
         */
        floor(n: number, precision?: number): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.floor
         */
        floor(precision?: number): number;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.floor
         */
        floor(precision?: number): PrimitiveChain<number>;
    }

    interface LoDashStatic {
        /**
          * Computes the maximum value of `array`. If `array` is empty or falsey
          * `undefined` is returned.
          *
          * @category Math
          * @param array The array to iterate over.
          * @returns Returns the maximum value.
         */
        max<T>(collection: List<T> | null | undefined): T | undefined;
    }
    interface Collection<T> {
        /**
         * @see _.max
         */
        max(): T | undefined;
    }
    interface CollectionChain<T> {
        /**
         * @see _.max
         */
        max(): ExpChain<T | undefined>;
    }

    interface LoDashStatic {
        /**
         * This method is like `_.max` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * the value is ranked. The iteratee is invoked with one argument: (value).
         *
         * @category Math
         * @param array The array to iterate over.
         * @param iteratee The iteratee invoked per element.
         * @returns Returns the maximum value.
         * @example
         *
         * var objects = [{ 'n': 1 }, { 'n': 2 }];
         *
         * _.maxBy(objects, function(o) { return o.n; });
         * // => { 'n': 2 }
         *
         * // using the `_.property` iteratee shorthand
         * _.maxBy(objects, 'n');
         * // => { 'n': 2 }
         */
        maxBy<T>(collection: List<T> | null | undefined, iteratee?: ValueIteratee<T>): T | undefined;
    }
    interface Collection<T> {
        /**
         * @see _.maxBy
         */
        maxBy(iteratee?: ValueIteratee<T>): T | undefined;
    }
    interface CollectionChain<T> {
        /**
         * @see _.maxBy
         */
        maxBy(iteratee?: ValueIteratee<T>): ExpChain<T | undefined>;
    }

    interface LoDashStatic {
        /**
         * Computes the mean of the values in `array`.
         *
         * @category Math
         * @param array The array to iterate over.
         * @returns Returns the mean.
         * @example
         *
         * _.mean([4, 2, 8, 6]);
         * // => 5
         */
        mean(collection: List<any> | null | undefined): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.mean
         */
        mean(): number;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.mean
         */
        mean(): PrimitiveChain<number>;
    }

    interface LoDashStatic {
        /**
         * Computes the mean of the provided properties of the objects in the `array`
         *
         * @category Math
         * @param array The array to iterate over.
         * @param iteratee The iteratee invoked per element.
         * @returns Returns the mean.
         * @example
         *
         * _.mean([{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }], 'n');
         * // => 5
         */
        meanBy<T>(collection: List<T> | null | undefined, iteratee?: ValueIteratee<T>): number;
    }
    interface Collection<T> {
        /**
         * @see _.meanBy
         */
        meanBy(iteratee?: ValueIteratee<T>): number;
    }
    interface CollectionChain<T> {
        /**
         * @see _.meanBy
         */
        meanBy(iteratee?: ValueIteratee<T>): PrimitiveChain<number>;
    }

    interface LoDashStatic {
        /**
         * Computes the minimum value of `array`. If `array` is empty or falsey
         * `undefined` is returned.
         *
         * @category Math
         * @param array The array to iterate over.
         * @returns Returns the minimum value.
         */
        min<T>(collection: List<T> | null | undefined): T | undefined;
    }
    interface Collection<T> {
        /**
         * @see _.min
         */
        min(): T | undefined;
    }
    interface CollectionChain<T> {
        /**
         * @see _.min
         */
        min(): ExpChain<T | undefined>;
    }

    interface LoDashStatic {
        /**
         * This method is like `_.min` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * the value is ranked. The iteratee is invoked with one argument: (value).
         *
         * @category Math
         * @param array The array to iterate over.
         * @param iteratee The iteratee invoked per element.
         * @returns Returns the minimum value.
         * @example
         *
         * var objects = [{ 'n': 1 }, { 'n': 2 }];
         *
         * _.minBy(objects, function(o) { return o.a; });
         * // => { 'n': 1 }
         *
         * // using the `_.property` iteratee shorthand
         * _.minBy(objects, 'n');
         * // => { 'n': 1 }
         */
        minBy<T>(collection: List<T> | null | undefined, iteratee?: ValueIteratee<T>): T | undefined;
    }
    interface Collection<T> {
        /**
         * @see _.minBy
         */
        minBy(iteratee?: ValueIteratee<T>): T | undefined;
    }
    interface CollectionChain<T> {
        /**
         * @see _.minBy
         */
        minBy(iteratee?: ValueIteratee<T>): ExpChain<T | undefined>;
    }

    interface LoDashStatic {
        /**
         * Multiply two numbers.
         * @param multiplier The first number in a multiplication.
         * @param multiplicand The second number in a multiplication.
         * @returns Returns the product.
         */
        multiply(multiplier: number, multiplicand: number): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.multiply
         */
        multiply(multiplicand: number): number;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.multiply
         */
        multiply(multiplicand: number): PrimitiveChain<number>;
    }

    interface LoDashStatic {
        /**
         * Calculates n rounded to precision.
         *
         * @param n The number to round.
         * @param precision The precision to round to.
         * @return Returns the rounded number.
         */
        round(n: number, precision?: number): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.round
         */
        round(precision?: number): number;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.round
         */
        round(precision?: number): PrimitiveChain<number>;
    }

    interface LoDashStatic {
        /**
         * Subtract two numbers.
         *
         * @category Math
         * @param minuend The first number in a subtraction.
         * @param subtrahend The second number in a subtraction.
         * @returns Returns the difference.
         * @example
         *
         * _.subtract(6, 4);
         * // => 2
         */
        subtract(minuend: number, subtrahend: number): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.subtract
         */
        subtract(subtrahend: number): number;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.subtract
         */
        subtract(subtrahend: number): PrimitiveChain<number>;
    }

    interface LoDashStatic {
        /**
         * Computes the sum of the values in `array`.
         *
         * @category Math
         * @param array The array to iterate over.
         * @returns Returns the sum.
         * @example
         *
         * _.sum([4, 2, 8, 6]);
         * // => 20
         */
        sum(collection: List<any> | null | undefined): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.sum
         */
        sum(): number;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.sum
         */
        sum(): PrimitiveChain<number>;
    }

    interface LoDashStatic {
        /**
         * This method is like `_.sum` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the value to be summed.
         * The iteratee is invoked with one argument: (value).
         *
         * @category Math
         * @param array The array to iterate over.
         * @param [iteratee=_.identity] The iteratee invoked per element.
         * @returns Returns the sum.
         * @example
         *
         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
         *
         * _.sumBy(objects, function(o) { return o.n; });
         * // => 20
         *
         * // using the `_.property` iteratee shorthand
         * _.sumBy(objects, 'n');
         * // => 20
         */
        sumBy<T>(collection: List<T> | null | undefined, iteratee?: ((value: T) => number) | string): number;
    }
    interface Collection<T> {
        /**
         * @see _.sumBy
         */
        sumBy(iteratee?: ((value: T) => number) | string): number;
    }
    interface CollectionChain<T> {
        /**
         * @see _.sumBy
         */
        sumBy(iteratee?: ((value: T) => number) | string): PrimitiveChain<number>;
    }
}
import _ = require("../index");
declare module "../index" {
    // clamp
    interface LoDashStatic {
        /**
         * Clamps `number` within the inclusive `lower` and `upper` bounds.
         *
         * @category Number
         * @param number The number to clamp.
         * @param [lower] The lower bound.
         * @param upper The upper bound.
         * @returns Returns the clamped number.
         * @example
         *
         * _.clamp(-10, -5, 5);
         * // => -5
         *
         * _.clamp(10, -5, 5);
         * // => 5
         * Clamps `number` within the inclusive `lower` and `upper` bounds.
         *
         * @category Number
         * @param number The number to clamp.
         * @param [lower] The lower bound.
         * @param upper The upper bound.
         * @returns Returns the clamped number.
         * @example
         *
         * _.clamp(-10, -5, 5);
         * // => -5
         *
         * _.clamp(10, -5, 5);
         */
        clamp(number: number, lower: number, upper: number): number;
        /**
         * @see _.clamp
         */
        clamp(number: number, upper: number): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.clamp
         */
        clamp(lower: number, upper: number): number;
        /**
         * @see _.clamp
         */
        clamp(upper: number): number;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.clamp
         */
        clamp(lower: number, upper: number): PrimitiveChain<number>;
        /**
         * @see _.clamp
         */
        clamp(upper: number): PrimitiveChain<number>;
    }
    // inRange
    interface LoDashStatic {
        /**
         * Checks if n is between start and up to but not including, end. If end is not specified it’s set to start
         * with start then set to 0.
         *
         * @param n The number to check.
         * @param start The start of the range.
         * @param end The end of the range.
         * @return Returns true if n is in the range, else false.
         */
        inRange(n: number, start: number, end?: number): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.inRange
         */
        inRange(start: number, end?: number): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.inRange
         */
        inRange(start: number, end?: number): PrimitiveChain<boolean>;
    }
    // random
    interface LoDashStatic {
        /**
         * Produces a random number between min and max (inclusive). If only one argument is provided a number between
         * 0 and the given number is returned. If floating is true, or either min or max are floats, a floating-point
         * number is returned instead of an integer.
         *
         * @param min The minimum possible value.
         * @param max The maximum possible value.
         * @param floating Specify returning a floating-point number.
         * @return Returns the random number.
         */
        random(floating?: boolean): number;
        /**
         * @see _.random
         */
        random(max: number, floating?: boolean): number;
        /**
         * @see _.random
         */
        random(min: number, max: number, floating?: boolean): number;
        /**
         * @see _.random
         */
        random(min: number, index: string | number, guard: object): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.random
         */
        random(floating?: boolean): number;
        /**
         * @see _.random
         */
        random(max: number, floating?: boolean): number;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.random
         */
        random(floating?: boolean): PrimitiveChain<number>;
        /**
         * @see _.random
         */
        random(max: number, floating?: boolean): PrimitiveChain<number>;
    }
}
import _ = require("../index");
import { uniqueSymbol } from "./common";
declare module "../index" {
    interface LoDashStatic {
        /**
         * Assigns own enumerable properties of source objects to the destination
         * object. Source objects are applied from left to right. Subsequent sources
         * overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object` and is loosely based on
         * [`Object.assign`](https://mdn.io/Object/assign).
         *
         * @category Object
         * @param object The destination object.
         * @param [sources] The source objects.
         * @returns Returns `object`.
         * @example
         *
         * function Foo() {
         *   this.c = 3;
         * }
         *
         * function Bar() {
         *   this.e = 5;
         * }
         *
         * Foo.prototype.d = 4;
         * Bar.prototype.f = 6;
         *
         * _.assign({ 'a': 1 }, new Foo, new Bar);
         * // => { 'a': 1, 'c': 3, 'e': 5 }
         */
        assign<TObject, TSource>(object: TObject, source: TSource): TObject & TSource;
        /**
         * @see _.assign
         */
        assign<TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & TSource1 & TSource2;
        /**
         * @see _.assign
         */
        assign<TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObject & TSource1 & TSource2 & TSource3;
        /**
         * @see _.assign
         */
        assign<TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): TObject & TSource1 & TSource2 & TSource3 & TSource4;
        /**
         * @see _.assign
         */
        assign<TObject>(object: TObject): TObject;
        /**
         * @see _.assign
         */
        assign(object: any, ...otherArgs: any[]): any;
    }
    interface Object<T> {
        /**
         * @see _.assign
         */
        assign<TSource>(source: TSource): Object<T & TSource>;
        /**
         * @see _.assign
         */
        assign<TSource1, TSource2>(source1: TSource1, source2: TSource2): Object<T & TSource1 & TSource2>;
        /**
         * @see _.assign
         */
        assign<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): Object<T & TSource1 & TSource2 & TSource3>;
        /**
         * @see _.assign
         */
        assign<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): Object<T & TSource1 & TSource2 & TSource3 & TSource4>;
        /**
         * @see _.assign
         */
        assign(): Object<T>;
        /**
         * @see _.assign
         */
        assign(...otherArgs: any[]): Object<any>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.assign
         */
        assign<TSource>(source: TSource): ObjectChain<T & TSource>;
        /**
         * @see _.assign
         */
        assign<TSource1, TSource2>(source1: TSource1, source2: TSource2): ObjectChain<T & TSource1 & TSource2>;
        /**
         * @see _.assign
         */
        assign<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): ObjectChain<T & TSource1 & TSource2 & TSource3>;
        /**
         * @see _.assign
         */
        assign<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): ObjectChain<T & TSource1 & TSource2 & TSource3 & TSource4>;
        /**
         * @see _.assign
         */
        assign(): ObjectChain<T>;
        /**
         * @see _.assign
         */
        assign(...otherArgs: any[]): ObjectChain<any>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.assign` except that it iterates over own and
         * inherited source properties.
         *
         * **Note:** This method mutates `object`.
         *
         * @alias extend
         * @category Object
         * @param object The destination object.
         * @param [sources] The source objects.
         * @returns Returns `object`.
         * @example
         *
         * function Foo() {
         *   this.b = 2;
         * }
         *
         * function Bar() {
         *   this.d = 4;
         * }
         *
         * Foo.prototype.c = 3;
         * Bar.prototype.e = 5;
         *
         * _.assignIn({ 'a': 1 }, new Foo, new Bar);
         * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5 }
         */
        assignIn<TObject, TSource>(object: TObject, source: TSource): TObject & TSource;
        /**
         * @see _.assignIn
         */
        assignIn<TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & TSource1 & TSource2;
        /**
         * @see _.assignIn
         */
        assignIn<TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObject & TSource1 & TSource2 & TSource3;
        /**
         * @see _.assignIn
         */
        assignIn<TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): TObject & TSource1 & TSource2 & TSource3 & TSource4;
        /**
         * @see _.assignIn
         */
        assignIn<TObject>(object: TObject): TObject;
        /**
         * @see _.assignIn
         */
        assignIn<TResult>(object: any, ...otherArgs: any[]): TResult;
    }
    interface Object<T> {
        /**
         * @see _.assignIn
         */
        assignIn<TSource>(source: TSource): Object<T & TSource>;
        /**
         * @see _.assignIn
         */
        assignIn<TSource1, TSource2>(source1: TSource1, source2: TSource2): Object<T & TSource1 & TSource2>;
        /**
         * @see _.assignIn
         */
        assignIn<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): Object<T & TSource1 & TSource2 & TSource3>;
        /**
         * @see _.assignIn
         */
        assignIn<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): Object<T & TSource1 & TSource2 & TSource3 & TSource4>;
        /**
         * @see _.assignIn
         */
        assignIn(): Object<T>;
        /**
         * @see _.assignIn
         */
        assignIn<TResult>(...otherArgs: any[]): Object<TResult>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.assignIn
         */
        assignIn<TSource>(source: TSource): ObjectChain<T & TSource>;
        /**
         * @see _.assignIn
         */
        assignIn<TSource1, TSource2>(source1: TSource1, source2: TSource2): ObjectChain<T & TSource1 & TSource2>;
        /**
         * @see _.assignIn
         */
        assignIn<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): ObjectChain<T & TSource1 & TSource2 & TSource3>;
        /**
         * @see _.assignIn
         */
        assignIn<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): ObjectChain<T & TSource1 & TSource2 & TSource3 & TSource4>;
        /**
         * @see _.assignIn
         */
        assignIn(): ObjectChain<T>;
        /**
         * @see _.assignIn
         */
        assignIn(...otherArgs: any[]): ObjectChain<any>;
    }
    type AssignCustomizer = (objectValue: any, sourceValue: any, key?: string, object?: {}, source?: {}) => any;
    interface LoDashStatic {
        /**
         * This method is like `_.assignIn` except that it accepts `customizer` which
         * is invoked to produce the assigned values. If `customizer` returns `undefined`
         * assignment is handled by the method instead. The `customizer` is invoked
         * with five arguments: (objValue, srcValue, key, object, source).
         *
         * **Note:** This method mutates `object`.
         *
         * @alias extendWith
         * @category Object
         * @param object The destination object.
         * @param sources The source objects.
         * @param [customizer] The function to customize assigned values.
         * @returns Returns `object`.
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   return _.isUndefined(objValue) ? srcValue : objValue;
         * }
         *
         * var defaults = _.partialRight(_.assignInWith, customizer);
         *
         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        assignInWith<TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): TObject & TSource;
        /**
         * @see _.assignInWith
         */
        assignInWith<TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): TObject & TSource1 & TSource2;
        /**
         * @see _.assignInWith
         */
        assignInWith<TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): TObject & TSource1 & TSource2 & TSource3;
        /**
         * @see _.assignInWith
         */
        assignInWith<TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): TObject & TSource1 & TSource2 & TSource3 & TSource4;
        /**
         * @see _.assignInWith
         */
        assignInWith<TObject>(object: TObject): TObject;
        /**
         * @see _.assignInWith
         */
        assignInWith<TResult>(object: any, ...otherArgs: any[]): TResult;
    }
    interface Object<T> {
        /**
         * @see _.assignInWith
         */
        assignInWith<TSource>(source: TSource, customizer: AssignCustomizer): Object<T & TSource>;
        /**
         * @see _.assignInWith
         */
        assignInWith<TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): Object<T & TSource1 & TSource2>;
        /**
         * @see _.assignInWith
         */
        assignInWith<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): Object<T & TSource1 & TSource2 & TSource3>;
        /**
         * @see _.assignInWith
         */
        assignInWith<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): Object<T & TSource1 & TSource2 & TSource3 & TSource4>;
        /**
         * @see _.assignInWith
         */
        assignInWith(): Object<T>;
        /**
         * @see _.assignInWith
         */
        assignInWith<TResult>(...otherArgs: any[]): Object<TResult>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.assignInWith
         */
        assignInWith<TSource>(source: TSource, customizer: AssignCustomizer): ObjectChain<T & TSource>;
        /**
         * @see _.assignInWith
         */
        assignInWith<TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): ObjectChain<T & TSource1 & TSource2>;
        /**
         * @see _.assignInWith
         */
        assignInWith<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): ObjectChain<T & TSource1 & TSource2 & TSource3>;
        /**
         * @see _.assignInWith
         */
        assignInWith<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): ObjectChain<T & TSource1 & TSource2 & TSource3 & TSource4>;
        /**
         * @see _.assignInWith
         */
        assignInWith(): ObjectChain<T>;
        /**
         * @see _.assignInWith
         */
        assignInWith(...otherArgs: any[]): ObjectChain<any>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.assign` except that it accepts `customizer` which
         * is invoked to produce the assigned values. If `customizer` returns `undefined`
         * assignment is handled by the method instead. The `customizer` is invoked
         * with five arguments: (objValue, srcValue, key, object, source).
         *
         * **Note:** This method mutates `object`.
         *
         * @category Object
         * @param object The destination object.
         * @param sources The source objects.
         * @param [customizer] The function to customize assigned values.
         * @returns Returns `object`.
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   return _.isUndefined(objValue) ? srcValue : objValue;
         * }
         *
         * var defaults = _.partialRight(_.assignWith, customizer);
         *
         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        assignWith<TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): TObject & TSource;
        /**
         * @see _.assignWith
         */
        assignWith<TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): TObject & TSource1 & TSource2;
        /**
         * @see _.assignWith
         */
        assignWith<TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): TObject & TSource1 & TSource2 & TSource3;
        /**
         * @see _.assignWith
         */
        assignWith<TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): TObject & TSource1 & TSource2 & TSource3 & TSource4;
        /**
         * @see _.assignWith
         */
        assignWith<TObject>(object: TObject): TObject;
        /**
         * @see _.assignWith
         */
        assignWith<TResult>(object: any, ...otherArgs: any[]): TResult;
    }
    interface Object<T> {
        /**
         * @see _.assignWith
         */
        assignWith<TSource>(source: TSource, customizer: AssignCustomizer): Object<T & TSource>;
        /**
         * @see _.assignWith
         */
        assignWith<TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): Object<T & TSource1 & TSource2>;
        /**
         * @see _.assignWith
         */
        assignWith<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): Object<T & TSource1 & TSource2 & TSource3>;
        /**
         * @see _.assignWith
         */
        assignWith<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): Object<T & TSource1 & TSource2 & TSource3 & TSource4>;
        /**
         * @see _.assignWith
         */
        assignWith(): Object<T>;
        /**
         * @see _.assignWith
         */
        assignWith<TResult>(...otherArgs: any[]): Object<TResult>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.assignWith
         */
        assignWith<TSource>(source: TSource, customizer: AssignCustomizer): ObjectChain<T & TSource>;
        /**
         * @see _.assignWith
         */
        assignWith<TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): ObjectChain<T & TSource1 & TSource2>;
        /**
         * @see _.assignWith
         */
        assignWith<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): ObjectChain<T & TSource1 & TSource2 & TSource3>;
        /**
         * @see _.assignWith
         */
        assignWith<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): ObjectChain<T & TSource1 & TSource2 & TSource3 & TSource4>;
        /**
         * @see _.assignWith
         */
        assignWith(): ObjectChain<T>;
        /**
         * @see _.assignWith
         */
        assignWith(...otherArgs: any[]): ObjectChain<any>;
    }
    interface LoDashStatic {
        /**
         * Creates an array of elements corresponding to the given keys, or indexes, of collection. Keys may be
         * specified as individual arguments or as arrays of keys.
         *
         * @param object The object to iterate over.
         * @param props The property names or indexes of elements to pick, specified individually or in arrays.
         * @return Returns the new array of picked elements.
         */
        at<T>(object:  Dictionary<T> | NumericDictionary<T> | null | undefined, ...props: PropertyPath[]): T[];
        /**
         * @see _.at
         */
        at<T extends object>(object: T | null | undefined, ...props: Array<Many<keyof T>>): Array<T[keyof T]>;
    }
    interface Object<T> {
        /**
         * @see _.at
         */
        at(...props: Array<Many<keyof T>>): Collection<T[keyof T]>;
    }
    interface Collection<T> {
        /**
         * @see _.at
         */
        at(...props: PropertyPath[]): Collection<T>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.at
         */
        at(...props: Array<Many<keyof T>>): CollectionChain<T[keyof T]>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.at
         */
        at(...props: PropertyPath[]): CollectionChain<T>;
    }
    interface LoDashStatic {
        /**
         * Creates an object that inherits from the given prototype object. If a properties object is provided its own
         * enumerable properties are assigned to the created object.
         *
         * @param prototype The object to inherit from.
         * @param properties The properties to assign to the object.
         * @return Returns the new object.
         */
        create<T extends object, U extends object>(prototype: T, properties?: U): T & U;
    }
    interface Object<T> {
        /**
         * @see _.create
         */
        create<U extends object>(properties?: U): Object<T & U>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.create
         */
        create<U extends object>(properties?: U): ObjectChain<T & U>;
    }
    interface LoDashStatic {
        /**
         * Assigns own enumerable properties of source object(s) to the destination object for all destination
         * properties that resolve to undefined. Once a property is set, additional values of the same property are
         * ignored.
         *
         * Note: This method mutates object.
         *
         * @param object The destination object.
         * @param sources The source objects.
         * @return The destination object.
         */
        defaults<TObject, TSource>(object: TObject, source: TSource): NonNullable<TSource & TObject>;
        /**
         * @see _.defaults
         */
        defaults<TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): NonNullable<TSource2 & TSource1 & TObject>;
        /**
         * @see _.defaults
         */
        defaults<TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): NonNullable<TSource3 & TSource2 & TSource1 & TObject>;
        /**
         * @see _.defaults
         */
        defaults<TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): NonNullable<TSource4 & TSource3 & TSource2 & TSource1 & TObject>;
        /**
         * @see _.defaults
         */
        defaults<TObject>(object: TObject): NonNullable<TObject>;
        /**
         * @see _.defaults
         */
        defaults(object: any, ...sources: any[]): any;
    }
    interface Object<T> {
        /**
         * @see _.defaults
         */
        defaults<TSource>(source: TSource): Object<NonNullable<TSource & T>>;
        /**
         * @see _.defaults
         */
        defaults<TSource1, TSource2>(source1: TSource1, source2: TSource2): Object<NonNullable<TSource2 & TSource1 & T>>;
        /**
         * @see _.defaults
         */
        defaults<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): Object<NonNullable<TSource3 & TSource2 & TSource1 & T>>;
        /**
         * @see _.defaults
         */
        defaults<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): Object<NonNullable<TSource4 & TSource3 & TSource2 & TSource1 & T>>;
        /**
         * @see _.defaults
         */
        defaults(): Object<NonNullable<T>>;
        /**
         * @see _.defaults
         */
        defaults(...sources: any[]): Object<any>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.defaults
         */
        defaults<TSource>(source: TSource): ObjectChain<NonNullable<TSource & T>>;
        /**
         * @see _.defaults
         */
        defaults<TSource1, TSource2>(source1: TSource1, source2: TSource2): ObjectChain<NonNullable<TSource2 & TSource1 & T>>;
        /**
         * @see _.defaults
         */
        defaults<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): ObjectChain<NonNullable<TSource3 & TSource2 & TSource1 & T>>;
        /**
         * @see _.defaults
         */
        defaults<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): ObjectChain<NonNullable<TSource4 & TSource3 & TSource2 & TSource1 & T>>;
        /**
         * @see _.defaults
         */
        defaults(): ObjectChain<NonNullable<T>>;
        /**
         * @see _.defaults
         */
        defaults(...sources: any[]): ObjectChain<any>;
    }
    interface LoDashStatic {
        /**
         * This method is like _.defaults except that it recursively assigns default properties.
         * @param object The destination object.
         * @param sources The source objects.
         * @return Returns object.
         */
        defaultsDeep(object: any, ...sources: any[]): any;
    }
    interface Object<T> {
        /**
         * @see _.defaultsDeep
         */
        defaultsDeep(...sources: any[]): Object<any>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.defaultsDeep
         */
        defaultsDeep(...sources: any[]): ObjectChain<any>;
    }
    interface LoDashStatic {
        /**
         * @see _.toPairs
         */
        entries<T>(object?: Dictionary<T> | NumericDictionary<T>): Array<[string, T]>;
        /**
         * @see _.entries
         */
        entries(object?: object): Array<[string, any]>;
    }
    interface Object<T> {
        /**
         * @see _.entries
         */
        entries(): Collection<[string, T[keyof T]]>;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.entries
         */
        entries(): Collection<[string, any]>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.entries
         */
        entries(): CollectionChain<[string, T[keyof T]]>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.entries
         */
        entries(): CollectionChain<[string, any]>;
    }
    interface LoDashStatic {
        /**
         * @see _.entriesIn
         */
        entriesIn<T>(object?: Dictionary<T> | NumericDictionary<T>): Array<[string, T]>;
        /**
         * @see _.entriesIn
         */
        entriesIn(object?: object): Array<[string, any]>;
    }
    interface Object<T> {
        /**
         * @see _.entriesIn
         */
        entriesIn(): Collection<[string, T[keyof T]]>;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.entriesIn
         */
        entriesIn(): Collection<[string, any]>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.entriesIn
         */
        entriesIn(): CollectionChain<[string, T[keyof T]]>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.entriesIn
         */
        entriesIn(): CollectionChain<[string, any]>;
    }
    interface LoDashStatic {
        /**
         * @see _.extend
         */
        extend<TObject, TSource>(object: TObject, source: TSource): TObject & TSource;
        /**
         * @see _.extend
         */
        extend<TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & TSource1 & TSource2;
        /**
         * @see _.extend
         */
        extend<TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObject & TSource1 & TSource2 & TSource3;
        /**
         * @see _.extend
         */
        extend<TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): TObject & TSource1 & TSource2 & TSource3 & TSource4;
        /**
         * @see _.extend
         */
        extend<TObject>(object: TObject): TObject;
        /**
         * @see _.extend
         */
        extend<TResult>(object: any, ...otherArgs: any[]): TResult;
    }
    interface Object<T> {
        /**
         * @see _.extend
         */
        extend<TSource>(source: TSource): Object<T & TSource>;
        /**
         * @see _.extend
         */
        extend<TSource1, TSource2>(source1: TSource1, source2: TSource2): Object<T & TSource1 & TSource2>;
        /**
         * @see _.extend
         */
        extend<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): Object<T & TSource1 & TSource2 & TSource3>;
        /**
         * @see _.extend
         */
        extend<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): Object<T & TSource1 & TSource2 & TSource3 & TSource4>;
        /**
         * @see _.extend
         */
        extend(): Object<T>;
        /**
         * @see _.extend
         */
        extend(...otherArgs: any[]): Object<any>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.extend
         */
        extend<TSource>(source: TSource): ObjectChain<T & TSource>;
        /**
         * @see _.extend
         */
        extend<TSource1, TSource2>(source1: TSource1, source2: TSource2): ObjectChain<T & TSource1 & TSource2>;
        /**
         * @see _.extend
         */
        extend<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): ObjectChain<T & TSource1 & TSource2 & TSource3>;
        /**
         * @see _.extend
         */
        extend<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): ObjectChain<T & TSource1 & TSource2 & TSource3 & TSource4>;
        /**
         * @see _.extend
         */
        extend(): ObjectChain<T>;
        /**
         * @see _.extend
         */
        extend(...otherArgs: any[]): ObjectChain<any>;
    }
    interface LoDashStatic {
        /**
         * @see _.extendWith
         */
        extendWith<TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): TObject & TSource;
        /**
         * @see _.extendWith
         */
        extendWith<TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): TObject & TSource1 & TSource2;
        /**
         * @see _.extendWith
         */
        extendWith<TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): TObject & TSource1 & TSource2 & TSource3;
        /**
         * @see _.extendWith
         */
        extendWith<TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): TObject & TSource1 & TSource2 & TSource3 & TSource4;
        /**
         * @see _.extendWith
         */
        extendWith<TObject>(object: TObject): TObject;
        /**
         * @see _.extendWith
         */
        extendWith<TResult>(object: any, ...otherArgs: any[]): TResult;
    }
    interface Object<T> {
        /**
         * @see _.extendWith
         */
        extendWith<TSource>(source: TSource, customizer: AssignCustomizer): Object<T & TSource>;
        /**
         * @see _.extendWith
         */
        extendWith<TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): Object<T & TSource1 & TSource2>;
        /**
         * @see _.extendWith
         */
        extendWith<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): Object<T & TSource1 & TSource2 & TSource3>;
        /**
         * @see _.extendWith
         */
        extendWith<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): Object<T & TSource1 & TSource2 & TSource3 & TSource4>;
        /**
         * @see _.extendWith
         */
        extendWith(): Object<T>;
        /**
         * @see _.extendWith
         */
        extendWith(...otherArgs: any[]): Object<any>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.extendWith
         */
        extendWith<TSource>(source: TSource, customizer: AssignCustomizer): ObjectChain<T & TSource>;
        /**
         * @see _.extendWith
         */
        extendWith<TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): ObjectChain<T & TSource1 & TSource2>;
        /**
         * @see _.extendWith
         */
        extendWith<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): ObjectChain<T & TSource1 & TSource2 & TSource3>;
        /**
         * @see _.extendWith
         */
        extendWith<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): ObjectChain<T & TSource1 & TSource2 & TSource3 & TSource4>;
        /**
         * @see _.extendWith
         */
        extendWith(): ObjectChain<T>;
        /**
         * @see _.extendWith
         */
        extendWith(...otherArgs: any[]): ObjectChain<any>;
    }
    interface LoDashStatic {
        /**
         * This method is like _.find except that it returns the key of the first element predicate returns truthy for
         * instead of the element itself.
         *
         * @param object The object to search.
         * @param predicate The function invoked per iteration.
         * @return Returns the key of the matched element, else undefined.
         */
        findKey<T>(object: T | null | undefined, predicate?: ObjectIteratee<T>): string | undefined;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.findKey
         */
        findKey(predicate?: ObjectIteratee<TValue>): string | undefined;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.findKey
         */
        findKey(predicate?: ObjectIteratee<TValue>): StringNullableChain;
    }
    interface LoDashStatic {
        /**
         * This method is like _.findKey except that it iterates over elements of a collection in the opposite order.
         *
         * @param object The object to search.
         * @param predicate The function invoked per iteration.
         * @return Returns the key of the matched element, else undefined.
         */
        findLastKey<T>(object: T | null | undefined, predicate?: ObjectIteratee<T>): string | undefined;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.findLastKey
         */
        findLastKey(predicate?: ObjectIteratee<TValue>): string | undefined;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.findLastKey
         */
        findLastKey(predicate?: ObjectIteratee<TValue>): StringNullableChain;
    }
    interface LoDashStatic {
        /**
         * Iterates over own and inherited enumerable properties of an object invoking iteratee for each property. The
         * iteratee is invoked with three arguments: (value, key, object). Iteratee functions may
         * exit iteration early by explicitly returning false.
         *
         * @param object The object to iterate over.
         * @param iteratee The function invoked per iteration.
         * @return Returns object.
         */
        forIn<T>(object: T, iteratee?: ObjectIterator<T, any>): T;
        /**
         * @see _.forIn
         */
        forIn<T>(object: T | null | undefined, iteratee?: ObjectIterator<T, any>): T | null | undefined;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.forIn
         */
        forIn(iteratee?: ObjectIterator<TValue, any>): this;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.forIn
         */
        forIn(iteratee?: ObjectIterator<TValue, any>): this;
    }
    interface LoDashStatic {
        /**
         * This method is like _.forIn except that it iterates over properties of object in the opposite order.
         *
         * @param object The object to iterate over.
         * @param iteratee The function invoked per iteration.
         * @return Returns object.
         */
        forInRight<T>(object: T, iteratee?: ObjectIterator<T, any>): T;
        /**
         * @see _.forInRight
         */
        forInRight<T>(object: T | null | undefined, iteratee?: ObjectIterator<T, any>): T | null | undefined;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.forInRight
         */
        forInRight(iteratee?: ObjectIterator<TValue, any>): this;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.forInRight
         */
        forInRight(iteratee?: ObjectIterator<TValue, any>): this;
    }
    interface LoDashStatic {
        /**
         * Iterates over own enumerable properties of an object invoking iteratee for each property. The iteratee is
         * invoked with three arguments: (value, key, object). Iteratee functions may exit
         * iteration early by explicitly returning false.
         *
         * @param object The object to iterate over.
         * @param iteratee The function invoked per iteration.
         * @return Returns object.
         */
        forOwn<T>(object: T, iteratee?: ObjectIterator<T, any>): T;
        /**
         * @see _.forOwn
         */
        forOwn<T>(object: T | null | undefined, iteratee?: ObjectIterator<T, any>): T | null | undefined;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.forOwn
         */
        forOwn(iteratee?: ObjectIterator<TValue, any>): this;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.forOwn
         */
        forOwn(iteratee?: ObjectIterator<TValue, any>): this;
    }
    interface LoDashStatic {
        /**
         * This method is like _.forOwn except that it iterates over properties of object in the opposite order.
         *
         * @param object The object to iterate over.
         * @param iteratee The function invoked per iteration.
         * @return Returns object.
         */
        forOwnRight<T>(object: T, iteratee?: ObjectIterator<T, any>): T;
        /**
         * @see _.forOwnRight
         */
        forOwnRight<T>(object: T | null | undefined, iteratee?: ObjectIterator<T, any>): T | null | undefined;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.forOwnRight
         */
        forOwnRight(iteratee?: ObjectIterator<TValue, any>): this;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.forOwnRight
         */
        forOwnRight(iteratee?: ObjectIterator<TValue, any>): this;
    }
    interface LoDashStatic {
        /**
         * Creates an array of function property names from own enumerable properties
         * of `object`.
         *
         * @category Object
         * @param object The object to inspect.
         * @returns Returns the new array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = _.constant('a');
         *   this.b = _.constant('b');
         * }
         *
         * Foo.prototype.c = _.constant('c');
         *
         * _.functions(new Foo);
         * // => ['a', 'b']
         */
        functions(object: any): string[];
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.functions
         */
        functions(): Collection<string>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.functions
         */
        functions(): CollectionChain<string>;
    }
    interface LoDashStatic {
        /**
         * Creates an array of function property names from own and inherited
         * enumerable properties of `object`.
         *
         * @category Object
         * @param object The object to inspect.
         * @returns Returns the new array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = _.constant('a');
         *   this.b = _.constant('b');
         * }
         *
         * Foo.prototype.c = _.constant('c');
         *
         * _.functionsIn(new Foo);
         * // => ['a', 'b', 'c']
         */
        functionsIn<T extends {}>(object: any): string[];
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.functionsIn
         */
        functionsIn(): Collection<string>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.functionsIn
         */
        functionsIn(): CollectionChain<string>;
    }

    type GetFieldTypeOfArrayLikeByKey<T extends unknown[], K> =
        K extends number ? T[K]
        : K extends `${infer N extends number}` ? T[N]
        : K extends keyof T ? T[K] : undefined;

    type GetFieldTypeOfStringByKey<T extends string, K> =
        K extends number ? T[K]
        : K extends `${infer N extends number}` ? T[N]
        : K extends keyof T ? T[K]
        : undefined;

    type GetFieldTypeOfNarrowedByKey<T, K> =
        T extends unknown[] ? GetFieldTypeOfArrayLikeByKey<T, K>
        : T extends string ? GetFieldTypeOfStringByKey<T, K>
        : K extends keyof T ? T[K]
        : K extends number
            ? `${K}` extends keyof T ? T[`${K}`] : undefined
        : K extends `${infer N extends number}`
            ? N extends keyof T ? T[N] : undefined
        : undefined;

    /** Internal. Assumes P is a dot-delimited path. */
    type GetFieldTypeOfNarrowedByDotPath<T, P> =
        P extends `${infer L}.${infer R}`
        ? GetFieldType<GetFieldTypeOfNarrowedByKey<T, L>, R, 'DotPath'>
        : GetFieldTypeOfNarrowedByKey<T, P>;

    /** Internal. This is a piece of GetFieldTypeOfNarrowedByLKR logic,
     *  assuming that Lc isn't to be ignored, and does not end with dot. */
    type GetFieldTypeOfNarrowedByLcKR<T, Lc, K, R> =
        '' extends R
            ? GetFieldType<GetFieldTypeOfNarrowedByDotPath<T, Lc>, K, 'Key'>
        : R extends `.${infer Rc}`
            ? GetFieldType<GetFieldType<GetFieldTypeOfNarrowedByDotPath<T, Lc>, K, 'Key'>, Rc>
            : GetFieldType<GetFieldType<GetFieldTypeOfNarrowedByDotPath<T, Lc>, K, 'Key'>, R>

    /** Internal. Assumes T has been narrowed; L is a dot-delimited path,
     *  and should be ignored if an empty string; K is a key name; and R is
     *  a dot-delimetered path, to be ignored if an empty string. Also if
     *  L has a tail dot, or R has a front dot, these dots should be discarded,
     *  however when L or R is just a dot, they should be interpreted as empty
     *  key name (rather than ignored). */
    type GetFieldTypeOfNarrowedByLKR<T, L, K, R> =
        '' extends L
        ? '' extends R
            ? GetFieldTypeOfNarrowedByKey<T, K>
            : R extends `.${infer Rc}`
                ? GetFieldType<GetFieldTypeOfNarrowedByKey<T, K>, Rc>
                : GetFieldType<GetFieldTypeOfNarrowedByKey<T, K>, R>
        : L extends `${infer Lc}.`
            ? GetFieldTypeOfNarrowedByLcKR<T, Lc, K, R>
            : GetFieldTypeOfNarrowedByLcKR<T, L, K, R>

    /** Internal. Assumes T has been narrowed. */
    type GetFieldTypeOfNarrowed<T, X, XT extends 'DotPath' | 'Key' | 'Path'> =
        XT extends 'Key' ? GetFieldTypeOfNarrowedByKey<T, X>
        : XT extends 'DotPath' ? GetFieldTypeOfNarrowedByDotPath<T, X>
        : X extends `${infer L}['${infer K}']${infer R}`
            ? GetFieldTypeOfNarrowedByLKR<T, L, K, R>
        : X extends `${infer L}["${infer K}"]${infer R}`
            ? GetFieldTypeOfNarrowedByLKR<T, L, K, R>
        : X extends `${infer L}[${infer K}]${infer R}`
            ? GetFieldTypeOfNarrowedByLKR<T, L, K, R>
        : GetFieldTypeOfNarrowedByDotPath<T, X>;

    /** Internal. Assumes T has been narrowed to an object type. */
    type GetFieldTypeOfObject<T, X, XT extends 'DotPath' | 'Key' | 'Path'> =
        Extract<T, unknown[]> extends never
        ? GetFieldTypeOfNarrowed<T, X, XT>
        : GetFieldTypeOfNarrowed<Exclude<T, unknown[]>, X, XT>
            | GetFieldTypeOfNarrowed<Extract<T, unknown[]>, X, XT>;

    /** Internal. Assumes T has been narrowed to a primitive type. */
    type GetFieldTypeOfPrimitive<T, X, XT extends 'DotPath' | 'Key' | 'Path'> =
        Extract<T, string> extends never
        ? T extends never ? never : undefined
        : (Exclude<T, string> extends never ? never : undefined)
            | GetFieldTypeOfNarrowed<Extract<T, string>, X, XT>;

    /**
     * Deduces the type of value at the path P of type T,
     * so that _.get<T, P>(t: T, p: P): GetFieldType<T, P>.
     * XT specifies the exact meaning of X:
     * - 'Path' (default) - X is a path type to be fully parsed;
     * - 'DotPath - X is a dot-delimitered path, without square (indexing) brackets;
     * - 'Key' - X is a simple key, and needs no parsing.
     */
    type GetFieldType<T, X, XT extends 'DotPath' | 'Key' | 'Path' = 'Path'> =
        Extract<T, object> extends never
        ? GetFieldTypeOfPrimitive<T, X, XT>
        : GetFieldTypeOfPrimitive<Exclude<T, object>, X, XT>
            | GetFieldTypeOfObject<Extract<T, object>, X, XT>;

    interface LoDashStatic {
        /**
         * Gets the property value at path of object. If the resolved value is undefined the defaultValue is used
         * in its place.
         *
         * @param object The object to query.
         * @param path The path of the property to get.
         * @param defaultValue The value returned if the resolved value is undefined.
         * @return Returns the resolved value.
         */
        get<TObject extends object, TKey extends keyof TObject>(object: TObject, path: TKey | [TKey]): TObject[TKey];
        /**
         * @see _.get
         */
        get<TObject extends object, TKey extends keyof TObject>(object: TObject | null | undefined, path: TKey | [TKey]): TObject[TKey] | undefined;
        /**
         * @see _.get
         */
        get<TObject extends object, TKey extends keyof TObject, TDefault>(object: TObject | null | undefined, path: TKey | [TKey], defaultValue: TDefault): Exclude<TObject[TKey], undefined> | TDefault;
        /**
         * @see _.get
         */
        get<TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(object: TObject, path: [TKey1, TKey2]): TObject[TKey1][TKey2];
        /**
         * @see _.get
         */
        get<TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof NonNullable<TObject[TKey1]>>(object: TObject | null | undefined, path: [TKey1, TKey2]): NonNullable<TObject[TKey1]>[TKey2] | undefined;
        /**
         * @see _.get
         */
        get<TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof NonNullable<TObject[TKey1]>, TDefault>(object: TObject | null | undefined, path: [TKey1, TKey2], defaultValue: TDefault): Exclude<NonNullable<TObject[TKey1]>[TKey2], undefined> | TDefault;
        /**
         * @see _.get
         */
        get<TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(object: TObject, path: [TKey1, TKey2, TKey3]): TObject[TKey1][TKey2][TKey3];
        /**
         * @see _.get
         */
        get<TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof NonNullable<TObject[TKey1]>, TKey3 extends keyof NonNullable<NonNullable<TObject[TKey1]>[TKey2]>>(object: TObject | null | undefined, path: [TKey1, TKey2, TKey3]): NonNullable<NonNullable<TObject[TKey1]>[TKey2]>[TKey3] | undefined;
        /**
         * @see _.get
         */
        get<TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof NonNullable<TObject[TKey1]>, TKey3 extends keyof NonNullable<NonNullable<TObject[TKey1]>[TKey2]>, TDefault>(object: TObject | null | undefined, path: [TKey1, TKey2, TKey3], defaultValue: TDefault): Exclude<NonNullable<NonNullable<TObject[TKey1]>[TKey2]>[TKey3], undefined> | TDefault;
        /**
         * @see _.get
         */
        get<TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(object: TObject, path: [TKey1, TKey2, TKey3, TKey4]): TObject[TKey1][TKey2][TKey3][TKey4];
        /**
         * @see _.get
         */
        get<TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof NonNullable<TObject[TKey1]>, TKey3 extends keyof NonNullable<NonNullable<TObject[TKey1]>[TKey2]>, TKey4 extends keyof NonNullable<NonNullable<NonNullable<TObject[TKey1]>[TKey2]>[TKey3]>>(object: TObject | null | undefined, path: [TKey1, TKey2, TKey3, TKey4]): NonNullable<NonNullable<NonNullable<TObject[TKey1]>[TKey2]>[TKey3]>[TKey4] | undefined;
        /**
         * @see _.get
         */
        get<TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof NonNullable<TObject[TKey1]>, TKey3 extends keyof NonNullable<NonNullable<TObject[TKey1]>[TKey2]>, TKey4 extends keyof NonNullable<NonNullable<NonNullable<TObject[TKey1]>[TKey2]>[TKey3]>, TDefault>(object: TObject | null | undefined, path: [TKey1, TKey2, TKey3, TKey4], defaultValue: TDefault): Exclude<NonNullable<NonNullable<NonNullable<TObject[TKey1]>[TKey2]>[TKey3]>[TKey4], undefined> | TDefault;
        /**
         * @see _.get
         */
        get<T>(object: NumericDictionary<T>, path: number): T;
        /**
         * @see _.get
         */
        get<T>(object: NumericDictionary<T> | null | undefined, path: number): T | undefined;
        /**
         * @see _.get
         */
        get<T, TDefault>(object: NumericDictionary<T> | null | undefined, path: number, defaultValue: TDefault): T | TDefault;
        /**
         * @see _.get
         */
        get<TDefault>(object: null | undefined, path: PropertyPath, defaultValue: TDefault): TDefault;
        /**
         * @see _.get
         */
        get(object: null | undefined, path: PropertyPath): undefined;
        /**
         * @see _.get
         */
        get<TObject, TPath extends string>(data: TObject, path: TPath): string extends TPath ? any : GetFieldType<TObject, TPath>;
        /**
         * @see _.get
         */
        get<TObject, TPath extends string, TDefault = GetFieldType<TObject, TPath>>(data: TObject, path: TPath, defaultValue: TDefault): Exclude<GetFieldType<TObject, TPath>, null | undefined> | TDefault;
         /**
         * @see _.get
         */
         get(object: any, path: PropertyPath, defaultValue?: any): any;
    }
    interface String {
        /**
         * @see _.get
         */
        get(path: number | number[]): string;
        /**
         * @see _.get
         */
        get(path: number | number[], defaultValue: string): string;
    }
    interface Object<T> {
        /**
         * @see _.get
         */
        get<TKey extends keyof T>(path: TKey | [TKey]): T[TKey];
        /**
         * @see _.get
         */
        get<TKey extends keyof T, TDefault>(path: TKey | [TKey], defaultValue: TDefault): Exclude<T[TKey], undefined> | TDefault;
        /**
         * @see _.get
         */
        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1]>(path: [TKey1, TKey2]): T[TKey1][TKey2];
        /**
         * @see _.get
         */
        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TDefault>(path: [TKey1, TKey2], defaultValue: TDefault): Exclude<T[TKey1][TKey2], undefined> | TDefault;
        /**
         * @see _.get
         */
        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TKey3 extends keyof T[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): T[TKey1][TKey2][TKey3];
        /**
         * @see _.get
         */
        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TKey3 extends keyof T[TKey1][TKey2], TDefault>(path: [TKey1, TKey2, TKey3], defaultValue: TDefault): Exclude<T[TKey1][TKey2][TKey3], undefined> | TDefault;
        /**
         * @see _.get
         */
        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TKey3 extends keyof T[TKey1][TKey2], TKey4 extends keyof T[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): T[TKey1][TKey2][TKey3][TKey4];
        /**
         * @see _.get
         */
        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TKey3 extends keyof T[TKey1][TKey2], TKey4 extends keyof T[TKey1][TKey2][TKey3], TDefault>(path: [TKey1, TKey2, TKey3, TKey4], defaultValue: TDefault): Exclude<T[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
        /**
         * @see _.get
         */
        get<TPath extends string>(path: TPath): string extends TPath ? any : GetFieldType<T, TPath>;
        /**
         * @see _.get
         */
        get<TPath extends string, TDefault = GetFieldType<T, TPath>>(path: TPath, defaultValue: TDefault): Exclude<GetFieldType<T, TPath>, null | undefined> | TDefault;
        /**
         * @see _.get
         */
        get(path: PropertyPath, defaultValue?: any): any;
    }
    interface Collection<T> {
        /**
         * @see _.get
         */
        get(path: number): T;
        /**
         * @see _.get
         */
        get<TDefault>(path: number, defaultValue: TDefault): T | TDefault;
    }
    interface StringChain {
        /**
         * @see _.get
         */
        get(path: number | number[]): StringChain;
        /**
         * @see _.get
         */
        get(path: number | number[], defaultValue: string): StringChain;
    }
    interface StringNullableChain {
        /**
         * @see _.get
         */
        get(path: number | number[]): StringNullableChain;
        /**
         * @see _.get
         */
        get(path: number | number[], defaultValue: string): StringChain;
    }
    interface ObjectChain<T> {
        /**
         * @see _.get
         */
        get<TKey extends keyof T>(path: TKey | [TKey]): ExpChain<T[TKey]>;
        /**
         * @see _.get
         */
        get<TKey extends keyof T>(path: TKey | [TKey], defaultValue: never[]): T[TKey] extends any[] ? ExpChain<Exclude<T[TKey], undefined>> : ExpChain<Exclude<T[TKey], undefined> | never[]>;
        /**
         * @see _.get
         */
        get<TKey extends keyof T, TDefault>(path: TKey | [TKey], defaultValue: TDefault): ExpChain<Exclude<T[TKey], undefined> | TDefault>;
        /**
         * @see _.get
         */
        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1]>(path: [TKey1, TKey2]): ExpChain<T[TKey1][TKey2]>;
        /**
         * @see _.get
         */
        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1]>(path: [TKey1, TKey2], defaultValue: never[]): T[TKey1][TKey2] extends any[] ? ExpChain<Exclude<T[TKey1][TKey2], undefined>> : ExpChain<Exclude<T[TKey1][TKey2], undefined> | never[]>;
        /**
         * @see _.get
         */
        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TDefault>(path: [TKey1, TKey2], defaultValue: TDefault): ExpChain<Exclude<T[TKey1][TKey2], undefined> | TDefault>;
        /**
         * @see _.get
         */
        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TKey3 extends keyof T[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): ExpChain<T[TKey1][TKey2][TKey3]>;
        /**
         * @see _.get
         */
        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TKey3 extends keyof T[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3], defaultValue: never[]): T[TKey1][TKey2][TKey3] extends any[] ? ExpChain<Exclude<T[TKey1][TKey2][TKey3], undefined>> : ExpChain<Exclude<T[TKey1][TKey2][TKey3], undefined> | never[]>;
        /**
         * @see _.get
         */
        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TKey3 extends keyof T[TKey1][TKey2], TDefault>(path: [TKey1, TKey2, TKey3], defaultValue: TDefault): ExpChain<Exclude<T[TKey1][TKey2][TKey3], undefined> | TDefault>;
        /**
         * @see _.get
         */
        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TKey3 extends keyof T[TKey1][TKey2], TKey4 extends keyof T[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): ExpChain<T[TKey1][TKey2][TKey3][TKey4]>;
        /**
         * @see _.get
         */
        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TKey3 extends keyof T[TKey1][TKey2], TKey4 extends keyof T[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4], defaultValue: never[]): T[TKey1][TKey2][TKey3][TKey4] extends any[] ? ExpChain<Exclude<T[TKey1][TKey2][TKey3][TKey4], undefined>> : ExpChain<Exclude<T[TKey1][TKey2][TKey3][TKey4], undefined> | never[]>;
        /**
         * @see _.get
         */
        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TKey3 extends keyof T[TKey1][TKey2], TKey4 extends keyof T[TKey1][TKey2][TKey3], TDefault>(path: [TKey1, TKey2, TKey3, TKey4], defaultValue: TDefault): ExpChain<Exclude<T[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault>;
        /**
         * @see _.get
         */
        get<TPath extends string>(path: TPath): string extends TPath ? LoDashExplicitWrapper<any> : ExpChain<GetFieldType<T, TPath>>;
        /**
         * @see _.get
         */
        get<TPath extends string, TDefault = GetFieldType<T, TPath>>(path: TPath, defaultValue: TDefault): ExpChain<Exclude<GetFieldType<T, TPath>, null | undefined> | TDefault>;
        /**
         * @see _.get
         */
        get(path: PropertyPath, defaultValue?: any): LoDashExplicitWrapper<any>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.get
         */
        get(path: number): ExpChain<T>;
        /**
         * @see _.get
         */
        get<TDefault>(path: number, defaultValue: TDefault): ExpChain<T | TDefault>;
    }
    interface LoDashStatic {
        /**
         * Checks if `path` is a direct property of `object`.
         *
         * @category Object
         * @param object The object to query.
         * @param path The path to check.
         * @returns Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = { 'a': { 'b': { 'c': 3 } } };
         * var other = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });
         *
         * _.has(object, 'a');
         * // => true
         *
         * _.has(object, 'a.b.c');
         * // => true
         *
         * _.has(object, ['a', 'b', 'c']);
         * // => true
         *
         * _.has(other, 'a');
         * // => false
         */
        has<T, K extends PropertyName>(object: T, path: K): object is T & { [P in K]: P extends keyof T ? T[P] : Record<string, unknown> extends T ? T[keyof T] : unknown} & {[uniqueSymbol]: unknown};
        has<T>(object: T, path: PropertyPath): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.has
         */
        has(path: PropertyPath): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.has
         */
        has(path: PropertyPath): PrimitiveChain<boolean>;
    }
    interface LoDashStatic {
        /**
         * Checks if `path` is a direct or inherited property of `object`.
         *
         * @category Object
         * @param object The object to query.
         * @param path The path to check.
         * @returns Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });
         *
         * _.hasIn(object, 'a');
         * // => true
         *
         * _.hasIn(object, 'a.b.c');
         * // => true
         *
         * _.hasIn(object, ['a', 'b', 'c']);
         * // => true
         *
         * _.hasIn(object, 'b');
         * // => false
         */
        hasIn<T>(object: T, path: PropertyPath): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.hasIn
         */
        hasIn(path: PropertyPath): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.hasIn
         */
        hasIn(path: PropertyPath): PrimitiveChain<boolean>;
    }
    interface LoDashStatic {
        /**
         * Creates an object composed of the inverted keys and values of object. If object contains duplicate values,
         * subsequent values overwrite property assignments of previous values unless multiValue is true.
         *
         * @param object The object to invert.
         * @param multiValue Allow multiple values per key.
         * @return Returns the new inverted object.
         */
        invert(object: object): Dictionary<string>;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.invert
         */
        invert(): Object<Dictionary<string>>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.invert
         */
        invert(): ObjectChain<Dictionary<string>>;
    }
    interface LoDashStatic {
        /**
         * This method is like _.invert except that the inverted object is generated from the results of running each
         * element of object through iteratee. The corresponding inverted value of each inverted key is an array of
         * keys responsible for generating the inverted value. The iteratee is invoked with one argument: (value).
         *
         * @param object The object to invert.
         * @param interatee The iteratee invoked per element.
         * @return Returns the new inverted object.
         */
        invertBy<T>(object:  Dictionary<T> | NumericDictionary<T> | null | undefined, interatee?: ValueIteratee<T>): Dictionary<string[]>;
        /**
         * @see _.invertBy
         */
        invertBy<T extends object>(object: T | null | undefined, interatee?: ValueIteratee<T[keyof T]>): Dictionary<string[]>;
    }
    interface String {
        /**
         * @see _.invertBy
         */
        invertBy(iteratee?: ValueIteratee<string>): Object<Dictionary<string[]>>;
    }
    interface Collection<T> {
        /**
         * @see _.invertBy
         */
        invertBy(iteratee?: ValueIteratee<T>): Object<Dictionary<string[]>>;
    }
    interface Object<T> {
        /**
         * @see _.invertBy
         */
        invertBy(iteratee?: ValueIteratee<T[keyof T]>): Object<Dictionary<string[]>>;
    }
    interface StringChain {
        /**
         * @see _.invertBy
         */
        invertBy(iteratee?: ValueIteratee<string>): ObjectChain<Dictionary<string[]>>;
    }
    interface StringNullableChain {
        /**
         * @see _.invertBy
         */
        invertBy(iteratee?: ValueIteratee<string>): ObjectChain<Dictionary<string[]>>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.invertBy
         */
        invertBy(iteratee?: ValueIteratee<T>): ObjectChain<Dictionary<string[]>>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.invertBy
         */
        invertBy(iteratee?: ValueIteratee<T[keyof T]>): ObjectChain<Dictionary<string[]>>;
    }
    interface LoDashStatic {
        /**
        * Invokes the method at path of object.
        * @param object The object to query.
        * @param path The path of the method to invoke.
        * @param args The arguments to invoke the method with.
         */
        invoke(object: any, path: PropertyPath, ...args: any[]): any;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.invoke
         */
        invoke(path: PropertyPath, ...args: any[]): any;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.invoke
         */
        invoke(path: PropertyPath, ...args: any[]): LoDashExplicitWrapper<any>;
    }
    interface LoDashStatic {
        /**
         * Creates an array of the own enumerable property names of object.
         *
         * Note: Non-object values are coerced to objects. See the ES spec for more details.
         *
         * @param object The object to query.
         * @return Returns the array of property names.
         */
        keys(object?: any): string[];
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.keys
         */
        keys(): Collection<string>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.keys
         */
        keys(): CollectionChain<string>;
    }
    interface LoDashStatic {
        /**
         * Creates an array of the own and inherited enumerable property names of object.
         *
         * Note: Non-object values are coerced to objects.
         *
         * @param object The object to query.
         * @return An array of property names.
         */
        keysIn(object?: any): string[];
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.keysIn
         */
        keysIn(): Collection<string>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.keysIn
         */
        keysIn(): CollectionChain<string>;
    }
    interface LoDashStatic {
        /**
         * The opposite of _.mapValues; this method creates an object with the same values as object and keys generated
         * by running each own enumerable property of object through iteratee.
         *
         * @param object The object to iterate over.
         * @param iteratee The function invoked per iteration.
         * @return Returns the new mapped object.
         */
        mapKeys<T>(object: List<T> | null | undefined, iteratee?: ListIteratee<T>): Dictionary<T>;
        /**
         * @see _.mapKeys
         */
        mapKeys<T extends object>(object: T | null | undefined, iteratee?: ObjectIteratee<T>): Dictionary<T[keyof T]>;
    }
    interface Collection<T> {
        /**
         * @see _.mapKeys
         */
        mapKeys(iteratee?: ListIteratee<T>): Object<Dictionary<T>>;
    }
    interface Object<T> {
        /**
         * @see _.mapKeys
         */
        mapKeys(iteratee?: ObjectIteratee<T>): Object<Dictionary<T[keyof T]>>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.mapKeys
         */
        mapKeys(iteratee?: ListIteratee<T>): ObjectChain<Dictionary<T>>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.mapKeys
         */
        mapKeys(iteratee?: ObjectIteratee<T>): ObjectChain<Dictionary<T[keyof T]>>;
    }
    interface LoDashStatic {
        /**
        * Creates an object with the same keys as object and values generated by running each own
        * enumerable property of object through iteratee. The iteratee function is
        * invoked with three arguments: (value, key, object).
        *
        * @param object The object to iterate over.
        * @param iteratee  The function invoked per iteration.
        * @return Returns the new mapped object.
         */
        mapValues<TResult>(obj: string | null | undefined, callback: StringIterator<TResult>): NumericDictionary<TResult>;
        /**
         * @see _.mapValues
         */
        mapValues<T, TResult>(array: T[], callback: ArrayIterator<T, TResult>): NumericDictionary<TResult>;
        /**
         * @see _.mapValues
         */
        mapValues<T extends object, TResult>(obj: T | null | undefined, callback: ObjectIterator<T, TResult>): { [P in keyof T]: TResult };
        /**
         * @see _.mapValues
         */
        mapValues<T>(obj: Dictionary<T> | NumericDictionary<T> | null | undefined, iteratee: object): Dictionary<boolean>;
        /**
         * @see _.mapValues
         */
        mapValues<T extends object>(obj: T | null | undefined, iteratee: object): { [P in keyof T]: boolean };
        /**
         * @see _.mapValues
         */
        mapValues<T, TKey extends keyof T>(obj: Dictionary<T> | NumericDictionary<T> | null | undefined, iteratee: TKey): Dictionary<T[TKey]>;
        /**
         * @see _.mapValues
         */
        mapValues<T>(obj: Dictionary<T> | NumericDictionary<T> | null | undefined, iteratee: string): Dictionary<any>;
        /**
         * @see _.mapValues
         */
        mapValues<T extends object>(obj: T | null | undefined, iteratee: string): { [P in keyof T]: any };
        /**
         * @see _.mapValues
         */
        mapValues(obj: string | null | undefined): NumericDictionary<string>;
        /**
         * @see _.mapValues
         */
        mapValues<T>(obj: Dictionary<T> | NumericDictionary<T> | null | undefined): Dictionary<T>;
        /**
         * @see _.mapValues
         */
        mapValues<T extends object>(obj: T): T;
        /**
         * @see _.mapValues
         */
        mapValues<T extends object>(obj: T | null | undefined): PartialObject<T>;
    }
    interface String {
        /**
         * @see _.mapValues
         */
        mapValues<TResult>(callback: StringIterator<TResult>): Object<NumericDictionary<TResult>>;
        /**
         * @see _.mapValues
         */
        mapValues(): Object<NumericDictionary<string>>;
    }
    interface Collection<T> {
        /**
         * @see _.mapValues
         */
        mapValues<TResult>(callback: ArrayIterator<T, TResult>): NumericDictionary<TResult>;
        /**
         * @see _.mapValues
         */
        mapValues<TKey extends keyof T>(iteratee: TKey): Object<Dictionary<T[TKey]>>;
        /**
         * @see _.mapValues
         */
        mapValues(iteratee: object): Object<Dictionary<boolean>>;
        /**
         * @see _.mapValues
         */
        mapValues(iteratee: string): Object<Dictionary<any>>;
        /**
         * @see _.mapValues
         */
        mapValues(): Object<Dictionary<T>>;
    }
    interface Object<T> {
        /**
         * @see _.mapValues
         */
        mapValues<TResult>(callback: ObjectIterator<T, TResult>): Object<{ [P in keyof T]: TResult }>;
        /**
         * @see _.mapValues
         */
        mapValues<TResult>(callback: DictionaryIterator<T[keyof T], TResult>): Object<Dictionary<TResult>>;
        /**
         * @see _.mapValues
         */
        mapValues(iteratee: object): Object<{ [P in keyof T]: boolean }>;
        /**
         * @see _.mapValues
         */
        mapValues<TKey extends keyof T[keyof T]>(iteratee: TKey): Object<Dictionary<T[keyof T][TKey]>>;
        /**
         * @see _.mapValues
         */
        mapValues(iteratee: string): Object<{ [P in keyof T]: any }>;
        /**
         * @see _.mapValues
         */
        mapValues(): Object<T>;
    }
    interface StringChain {
        /**
         * @see _.mapValues
         */
        mapValues<TResult>(callback: StringIterator<TResult>): ObjectChain<NumericDictionary<TResult>>;
        /**
         * @see _.mapValues
         */
        mapValues(): ObjectChain<NumericDictionary<string>>;
    }
    interface StringNullableChain {
        /**
         * @see _.mapValues
         */
        mapValues<TResult>(callback: StringIterator<TResult>): ObjectChain<NumericDictionary<TResult>>;
        /**
         * @see _.mapValues
         */
        mapValues(): ObjectChain<NumericDictionary<string>>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.mapValues
         */
        mapValues<TResult>(callback: ArrayIterator<T, TResult>): ObjectChain<NumericDictionary<TResult>>;
        /**
         * @see _.mapValues
         */
        mapValues<TKey extends keyof T>(iteratee: TKey): ObjectChain<Dictionary<T[TKey]>>;
        /**
         * @see _.mapValues
         */
        mapValues(iteratee: object): ObjectChain<Dictionary<boolean>>;
        /**
         * @see _.mapValues
         */
        mapValues(iteratee: string): ObjectChain<Dictionary<any>>;
        /**
         * @see _.mapValues
         */
        mapValues(): ObjectChain<Dictionary<T>>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.mapValues
         */
        mapValues<TResult>(callback: ObjectIterator<T, TResult>): ObjectChain<{ [P in keyof T]: TResult }>;
        /**
         * @see _.mapValues
         */
        mapValues<TResult>(callback: DictionaryIterator<T[keyof T], TResult>): ObjectChain<Dictionary<TResult>>;
        /**
         * @see _.mapValues
         */
        mapValues(iteratee: object): ObjectChain<{ [P in keyof T]: boolean }>;
        /**
         * @see _.mapValues
         */
        mapValues<TKey extends keyof T[keyof T]>(iteratee: TKey): ObjectChain<Dictionary<T[keyof T][TKey]>>;
        /**
         * @see _.mapValues
         */
        mapValues(iteratee: string): ObjectChain<{ [P in keyof T]: any }>;
        /**
         * @see _.mapValues
         */
        mapValues(): ObjectChain<T>;
    }
    interface LoDashStatic {
        /**
         * Recursively merges own and inherited enumerable properties of source
         * objects into the destination object, skipping source properties that resolve
         * to `undefined`. Array and plain object properties are merged recursively.
         * Other objects and value types are overridden by assignment. Source objects
         * are applied from left to right. Subsequent sources overwrite property
         * assignments of previous sources.
         *
         * **Note:** This method mutates `object`.
         *
         * @category Object
         * @param object The destination object.
         * @param [sources] The source objects.
         * @returns Returns `object`.
         * @example
         *
         * var users = {
         *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
         * };
         *
         * var ages = {
         *   'data': [{ 'age': 36 }, { 'age': 40 }]
         * };
         *
         * _.merge(users, ages);
         * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
         */
        merge<TObject, TSource>(object: TObject, source: TSource): TObject & TSource;
        /**
         * @see _.merge
         */
        merge<TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & TSource1 & TSource2;
        /**
         * @see _.merge
         */
        merge<TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObject & TSource1 & TSource2 & TSource3;
        /**
         * @see _.merge
         */
        merge<TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): TObject & TSource1 & TSource2 & TSource3 & TSource4;
        /**
         * @see _.merge
         */
        merge(object: any, ...otherArgs: any[]): any;
    }
    interface Object<T> {
        /**
         * @see _.merge
         */
        merge<TSource>(source: TSource): Object<T & TSource>;
        /**
         * @see _.merge
         */
        merge<TSource1, TSource2>(source1: TSource1, source2: TSource2): Object<T & TSource1 & TSource2>;
        /**
         * @see _.merge
         */
        merge<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): Object<T & TSource1 & TSource2 & TSource3>;
        /**
         * @see _.merge
         */
        merge<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): Object<T & TSource1 & TSource2 & TSource3 & TSource4>;
        /**
         * @see _.merge
         */
        merge(...otherArgs: any[]): Object<any>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.merge
         */
        merge<TSource>(source: TSource): ObjectChain<T & TSource>;
        /**
         * @see _.merge
         */
        merge<TSource1, TSource2>(source1: TSource1, source2: TSource2): ObjectChain<T & TSource1 & TSource2>;
        /**
         * @see _.merge
         */
        merge<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): ObjectChain<T & TSource1 & TSource2 & TSource3>;
        /**
         * @see _.merge
         */
        merge<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): ObjectChain<T & TSource1 & TSource2 & TSource3 & TSource4>;
        /**
         * @see _.merge
         */
        merge(...otherArgs: any[]): ObjectChain<any>;
    }
    type MergeWithCustomizer = { bivariantHack(value: any, srcValue: any, key: string, object: any, source: any): any; }["bivariantHack"];
    // TODO: Probably should just put all these methods on Object and forget about it.
    // oh, except for Collection<any> I GUESS
    interface LoDashStatic {
        /**
         * This method is like `_.merge` except that it accepts `customizer` which
         * is invoked to produce the merged values of the destination and source
         * properties. If `customizer` returns `undefined` merging is handled by the
         * method instead. The `customizer` is invoked with seven arguments:
         * (objValue, srcValue, key, object, source, stack).
         *
         * @category Object
         * @param object The destination object.
         * @param sources The source objects.
         * @param customizer The function to customize assigned values.
         * @returns Returns `object`.
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   if (_.isArray(objValue)) {
         *     return objValue.concat(srcValue);
         *   }
         * }
         *
         * var object = {
         *   'fruits': ['apple'],
         *   'vegetables': ['beet']
         * };
         *
         * var other = {
         *   'fruits': ['banana'],
         *   'vegetables': ['carrot']
         * };
         *
         * _.mergeWith(object, other, customizer);
         * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
         */
        mergeWith<TObject, TSource>(object: TObject, source: TSource, customizer: MergeWithCustomizer): TObject & TSource;
        /**
         * @see _.mergeWith
         */
        mergeWith<TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: MergeWithCustomizer): TObject & TSource1 & TSource2;
        /**
         * @see _.mergeWith
         */
        mergeWith<TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, customizer: MergeWithCustomizer): TObject & TSource1 & TSource2 & TSource3;
        /**
         * @see _.mergeWith
         */
        mergeWith<TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: MergeWithCustomizer): TObject & TSource1 & TSource2 & TSource3 & TSource4;
        /**
         * @see _.mergeWith
         */
        mergeWith(object: any, ...otherArgs: any[]): any;
    }
    interface Object<T> {
        /**
         * @see _.mergeWith
         */
        mergeWith<TSource>(source: TSource, customizer: MergeWithCustomizer): Object<T & TSource>;
        /**
         * @see _.mergeWith
         */
        mergeWith<TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: MergeWithCustomizer): Object<T & TSource1 & TSource2>;
        /**
         * @see _.mergeWith
         */
        mergeWith<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: MergeWithCustomizer): Object<T & TSource1 & TSource2 & TSource3>;
        /**
         * @see _.mergeWith
         */
        mergeWith<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: MergeWithCustomizer): Object<T & TSource1 & TSource2 & TSource3 & TSource4>;
        /**
         * @see _.mergeWith
         */
        mergeWith(...otherArgs: any[]): Object<any>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.mergeWith
         */
        mergeWith<TSource>(source: TSource, customizer: MergeWithCustomizer): ObjectChain<T & TSource>;
        /**
         * @see _.mergeWith
         */
        mergeWith<TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: MergeWithCustomizer): ObjectChain<T & TSource1 & TSource2>;
        /**
         * @see _.mergeWith
         */
        mergeWith<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: MergeWithCustomizer): ObjectChain<T & TSource1 & TSource2 & TSource3>;
        /**
         * @see _.mergeWith
         */
        mergeWith<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: MergeWithCustomizer): ObjectChain<T & TSource1 & TSource2 & TSource3 & TSource4>;
        /**
         * @see _.mergeWith
         */
        mergeWith(...otherArgs: any[]): ObjectChain<any>;
    }
    interface LoDashStatic {
        /**
         * The opposite of `_.pick`; this method creates an object composed of the
         * own and inherited enumerable properties of `object` that are not omitted.
         *
         * @category Object
         * @param object The source object.
         * @param [paths] The property names to omit, specified
         *  individually or in arrays..
         * @returns Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.omit(object, ['a', 'c']);
         * // => { 'b': '2' }
         */
        omit<T extends object, K extends PropertyName[]>(
            object: T | null | undefined,
            ...paths: K
        ): Pick<T, Exclude<keyof T, K[number]>>;
        /**
         * @see _.omit
         */
        omit<T extends object, K extends keyof T>(object: T | null | undefined, ...paths: Array<Many<K>>): Omit<T, K>;
        /**
         * @see _.omit
         */
        omit<T extends object>(object: T | null | undefined, ...paths: Array<Many<PropertyName>>): PartialObject<T>;
    }
    interface Collection<T> {
        /**
         * @see _.omit
         */
        omit(...paths: Array<Many<PropertyName>>): Collection<T>;
    }
    interface Object<T> {
        /**
         * @see _.omit
         */
        omit<K extends keyof T>(...paths: Array<Many<K>>): Object<Omit<T, K>>;
        /**
         * @see _.omit
         */
        omit(...paths: Array<Many<PropertyName | IterateeShorthand<T>>>): Object<PartialObject<T>>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.omit
         */
        omit(...paths: Array<Many<PropertyName>>): CollectionChain<T>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.omit
         */
        omit<K extends keyof T>(...paths: Array<Many<K>>): ObjectChain<Omit<T, K>>;
        /**
         * @see _.omit
         */
        omit(...paths: Array<Many<PropertyName>>): ObjectChain<PartialObject<T>>;
    }
    interface LoDashStatic {
        /**
         * The opposite of `_.pickBy`; this method creates an object composed of the
         * own and inherited enumerable properties of `object` that `predicate`
         * doesn't return truthy for.
         *
         * @category Object
         * @param object The source object.
         * @param [predicate=_.identity] The function invoked per property.
         * @returns Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.omitBy(object, _.isNumber);
         * // => { 'b': '2' }
         */
        omitBy<T>(object: Dictionary<T> | null | undefined, predicate?: ValueKeyIteratee<T>): Dictionary<T>;
        /**
         * @see _.omitBy
         */
        omitBy<T>(object: NumericDictionary<T> | null | undefined, predicate?: ValueKeyIteratee<T>): NumericDictionary<T>;
        /**
         * @see _.omitBy
         */
        omitBy<T extends object>(object: T | null | undefined, predicate: ValueKeyIteratee<T[keyof T]>): PartialObject<T>;
    }
    interface Collection<T> {
        /**
         * @see _.omitBy
         */
        omitBy(predicate?: ValueKeyIteratee<T>): Object<Dictionary<T>>;
    }
    interface Object<T> {
        /**
         * @see _.omitBy
         */
        omitBy(predicate: ValueKeyIteratee<T[keyof T]>): Object<PartialObject<T>>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.omitBy
         */
        omitBy(predicate?: ValueKeyIteratee<T>): ObjectChain<Dictionary<T>>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.omitBy
         */
        omitBy(predicate: ValueKeyIteratee<T[keyof T]>): ObjectChain<PartialObject<T>>;
    }
    interface LoDashStatic {
        /**
         * Creates an object composed of the picked `object` properties.
         *
         * @category Object
         * @param object The source object.
         * @param [props] The property names to pick, specified
         *  individually or in arrays.
         * @returns Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pick(object, ['a', 'c']);
         * // => { 'a': 1, 'c': 3 }
         */
        pick<T extends object, U extends keyof T>(object: T, ...props: Array<Many<U>>): Pick<T, U>;
        /**
         * @see _.pick
         */
        pick<T>(object: T | null | undefined, ...props: Array<Many<PropertyPath>>): PartialObject<T>;
    }
    interface Object<T> {
        /**
         * @see _.pick
         */
        pick<U extends keyof T>(...props: Array<Many<U>>): Object<Pick<T, U>>;
        /**
         * @see _.pick
         */
        pick(...props: Array<Many<PropertyPath>>): Object<PartialObject<T>>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.pick
         */
        pick<U extends keyof T>(...props: Array<Many<U>>): ObjectChain<Pick<T, U>>;
        /**
         * @see _.pick
         */
        pick(...props: Array<Many<PropertyPath>>): ObjectChain<PartialObject<T>>;
    }
    interface LoDashStatic {
        /**
         * Creates an object composed of the `object` properties `predicate` returns
         * truthy for. The predicate is invoked with two arguments: (value, key).
         *
         * @category Object
         * @param object The source object.
         * @param [predicate=_.identity] The function invoked per property.
         * @returns Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pickBy(object, _.isNumber);
         * // => { 'a': 1, 'c': 3 }
         */
        pickBy<T, S extends T>(object: Dictionary<T> | null | undefined, predicate: ValueKeyIterateeTypeGuard<T, S>): Dictionary<S>;
        /**
         * @see _.pickBy
         */
        pickBy<T, S extends T>(object: NumericDictionary<T> | null | undefined, predicate: ValueKeyIterateeTypeGuard<T, S>): NumericDictionary<S>;
        /**
         * @see _.pickBy
         */
        pickBy<T>(object: Dictionary<T> | null | undefined, predicate?: ValueKeyIteratee<T>): Dictionary<T>;
        /**
         * @see _.pickBy
         */
        pickBy<T>(object: NumericDictionary<T> | null | undefined, predicate?: ValueKeyIteratee<T>): NumericDictionary<T>;
        /**
         * @see _.pickBy
         */
        pickBy<T extends object>(object: T | null | undefined, predicate?: ValueKeyIteratee<T[keyof T]>): PartialObject<T>;
    }
    interface Collection<T> {
        /**
         * @see _.pickBy
         */
        pickBy<S extends T>(predicate: ValueKeyIterateeTypeGuard<T, S>): Object<Dictionary<S>>;
        /**
         * @see _.pickBy
         */
        pickBy(predicate?: ValueKeyIteratee<T>): Object<Dictionary<T>>;
    }
    interface Object<T> {
        /**
         * @see _.pickBy
         */
        pickBy<S extends T[keyof T]>(predicate: ValueKeyIterateeTypeGuard<T[keyof T], S>): Object<NumericDictionary<unknown> extends T ? NumericDictionary<S> : Dictionary<S>>;
        /**
         * @see _.pickBy
         */
        pickBy(predicate?: ValueKeyIteratee<T[keyof T]>): Object<T extends Dictionary<unknown> ? Dictionary<T[keyof T]> : T extends NumericDictionary<unknown> ? NumericDictionary<T[keyof T]> : PartialObject<T>>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.pickBy
         */
        pickBy<S extends T>(predicate: ValueKeyIterateeTypeGuard<T, S>): ObjectChain<Dictionary<S>>;
        /**
         * @see _.pickBy
         */
        pickBy(predicate?: ValueKeyIteratee<T>): ObjectChain<Dictionary<T>>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.pickBy
         */
        pickBy<S extends T[keyof T]>(predicate: ValueKeyIterateeTypeGuard<T[keyof T], S>): ObjectChain<NumericDictionary<unknown> extends T ? NumericDictionary<S> : Dictionary<S>>;
        /**
         * @see _.pickBy
         */
        pickBy(predicate?: ValueKeyIteratee<T[keyof T]>): ObjectChain<T extends Dictionary<unknown> ? Dictionary<T[keyof T]> : T extends NumericDictionary<unknown> ? NumericDictionary<T[keyof T]> : PartialObject<T>>;
    }
    interface LoDashStatic {
        /**
         * This method is like _.get except that if the resolved value is a function it’s invoked with the this binding
         * of its parent object and its result is returned.
         *
         * @param object The object to query.
         * @param path The path of the property to resolve.
         * @param defaultValue The value returned if the resolved value is undefined.
         * @return Returns the resolved value.
         */
        result<TResult>(object: any, path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)): TResult;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.result
         */
        result<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)): TResult;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.result
         */
        result<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)): ExpChain<TResult>;
    }
    interface LoDashStatic {
        /**
         * Sets the value at path of object. If a portion of path doesn’t exist it’s created. Arrays are created for
         * missing index properties while objects are created for all other missing properties. Use _.setWith to
         * customize path creation.
         *
         * @param object The object to modify.
         * @param path The path of the property to set.
         * @param value The value to set.
         * @return Returns object.
         */
        set<T extends object>(object: T, path: PropertyPath, value: any): T;
        /**
         * @see _.set
         */
        set<TResult>(object: object, path: PropertyPath, value: any): TResult;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.set
         */
        set(path: PropertyPath, value: any): this;
        /**
         * @see _.set
         */
        set<TResult>(path: PropertyPath, value: any): ImpChain<TResult>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.set
         */
        set(path: PropertyPath, value: any): this;
        /**
         * @see _.set
         */
        set<TResult>(path: PropertyPath, value: any): ExpChain<TResult>;
    }
    type SetWithCustomizer<T> = (nsValue: any, key: string, nsObject: T) => any;
    interface LoDashStatic {
        /**
         * This method is like _.set except that it accepts customizer which is invoked to produce the objects of
         * path. If customizer returns undefined path creation is handled by the method instead. The customizer is
         * invoked with three arguments: (nsValue, key, nsObject).
         *
         * @param object The object to modify.
         * @param path The path of the property to set.
         * @param value The value to set.
         * @param customizer The function to customize assigned values.
         * @return Returns object.
         */
        setWith<T extends object>(object: T, path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): T;
        /**
         * @see _.setWith
         */
        setWith<T extends object, TResult>(object: T, path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): TResult;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.setWith
         */
        setWith(path: PropertyPath, value: any, customizer?: SetWithCustomizer<TValue>): this;
        /**
         * @see _.setWith
         */
        setWith<TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<TValue>): ImpChain<TResult>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.setWith
         */
        setWith(path: PropertyPath, value: any, customizer?: SetWithCustomizer<TValue>): this;
        /**
         * @see _.setWith
         */
        setWith<TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<TValue>): ExpChain<TResult>;
    }
    interface LoDashStatic {
        /**
         * Creates an array of own enumerable key-value pairs for object.
         *
         * @param object The object to query.
         * @return Returns the new array of key-value pairs.
         */
        toPairs<T>(object?: Dictionary<T> | NumericDictionary<T>): Array<[string, T]>;
        /**
         * @see _.toPairs
         */
        toPairs(object?: object): Array<[string, any]>;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.toPairs
         */
        toPairs(): Collection<[string, TValue extends Dictionary<infer U> ? U : TValue extends NumericDictionary<infer V> ? V : any]>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.toPairs
         */
        toPairs(): CollectionChain<[string, TValue extends Dictionary<infer U> ? U : TValue extends NumericDictionary<infer V> ? V : any]>;
    }
    interface LoDashStatic {
        /**
         * Creates an array of own and inherited enumerable key-value pairs for object.
         *
         * @param object The object to query.
         * @return Returns the new array of key-value pairs.
         */
        toPairsIn<T>(object?: Dictionary<T> | NumericDictionary<T>): Array<[string, T]>;
        /**
         * @see _.toPairsIn
         */
        toPairsIn(object?: object): Array<[string, any]>;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.toPairsIn
         */
        toPairsIn(): Collection<[string, TValue extends Dictionary<infer U> ? U : TValue extends NumericDictionary<infer V> ? V : any]>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.toPairsIn
         */
        toPairsIn(): CollectionChain<[string, TValue extends Dictionary<infer U> ? U : TValue extends NumericDictionary<infer V> ? V : any]>;
    }
    interface LoDashStatic {
        /**
         * An alternative to _.reduce; this method transforms object to a new accumulator object which is the result of
         * running each of its own enumerable properties through iteratee, with each invocation potentially mutating
         * the accumulator object. The iteratee is invoked with four arguments: (accumulator,
         * value, key, object). Iteratee functions may exit iteration early by explicitly returning false.
         *
         * @param object The object to iterate over.
         * @param iteratee The function invoked per iteration.
         * @param accumulator The custom accumulator value.
         * @return Returns the accumulated value.
         */
        transform<T, TResult>(object: readonly T[], iteratee: MemoVoidArrayIterator<T, TResult>, accumulator?: TResult): TResult;
        /**
         * @see _.transform
         */
        transform<T, TResult>(object: Dictionary<T>, iteratee: MemoVoidDictionaryIterator<T, string, TResult>, accumulator?: TResult): TResult;
        /**
         * @see _.transform
         */
        transform<T extends object, TResult>(object: T, iteratee: MemoVoidDictionaryIterator<T[keyof T], keyof T, TResult>, accumulator?: TResult): TResult;
        /**
         * @see _.transform
         */
        transform(object: any[]): any[];
        /**
         * @see _.transform
         */
        transform(object: object): Dictionary<any>;
    }
    interface Collection<T> {
        /**
         * @see _.transform
         */
        transform<TResult>(iteratee: MemoVoidArrayIterator<T, TResult>, accumulator?: TResult): ImpChain<TResult>;
        /**
         * @see _.transform
         */
        transform(): Collection<any>;
    }
    interface Object<T> {
        /**
         * @see _.transform
         */
        transform<TResult>(iteratee: MemoVoidDictionaryIterator<T[keyof T], string, TResult>, accumulator?: TResult): ImpChain<TResult>;
        /**
         * @see _.transform
         */
        transform<TResult>(iteratee: MemoVoidDictionaryIterator<T[keyof T], keyof T, TResult>, accumulator?: TResult): ImpChain<TResult>;
        /**
         * @see _.transform
         */
        transform(): ImpChain<T extends Dictionary<unknown> ? Dictionary<any> : T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.transform
         */
        transform<TResult>(iteratee: MemoVoidArrayIterator<T, TResult>, accumulator?: TResult): ExpChain<TResult>;
        /**
         * @see _.transform
         */
        transform(): CollectionChain<any>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.transform
         */
        transform<TResult>(iteratee: MemoVoidDictionaryIterator<T[keyof T], string, TResult>, accumulator?: TResult): ExpChain<TResult>;
        /**
         * @see _.transform
         */
        transform<TResult>(iteratee: MemoVoidDictionaryIterator<T[keyof T], keyof T, TResult>, accumulator?: TResult): ExpChain<TResult>;
        /**
         * @see _.transform
         */
        transform(): ExpChain<T extends Dictionary<unknown> ? Dictionary<any> : T>;
    }
    interface LoDashStatic {
        /**
         * Removes the property at path of object.
         *
         * Note: This method mutates object.
         *
         * @param object The object to modify.
         * @param path The path of the property to unset.
         * @return Returns true if the property is deleted, else false.
         */
        unset(object: any, path: PropertyPath): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.unset
         */
        unset(path: PropertyPath): Primitive<boolean>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.unset
         */
        unset(path: PropertyPath): PrimitiveChain<boolean>;
    }
    interface LoDashStatic {
        /**
         * This method is like _.set except that accepts updater to produce the value to set. Use _.updateWith to
         * customize path creation. The updater is invoked with one argument: (value).
         *
         * @param object The object to modify.
         * @param path The path of the property to set.
         * @param updater The function to produce the updated value.
         * @return Returns object.
         */
        update(object: object, path: PropertyPath, updater: (value: any) => any): any;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.update
         */
        update(path: PropertyPath, updater: (value: any) => any): Object<any>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.update
         */
        update(path: PropertyPath, updater: (value: any) => any): ObjectChain<any>;
    }
    interface LoDashStatic {
        /**
         * This method is like `_.update` except that it accepts `customizer` which is
         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
         * path creation is handled by the method instead. The `customizer` is invoked
         * with three arguments: (nsValue, key, nsObject).
         *
         * **Note:** This method mutates `object`.
         *
         * @since 4.6.0
         * @category Object
         * @param object The object to modify.
         * @param path The path of the property to set.
         * @param updater The function to produce the updated value.
         * @param [customizer] The function to customize assigned values.
         * @returns Returns `object`.
         * @example
         *
         * var object = {};
         *
         * _.updateWith(object, '[0][1]', _.constant('a'), Object);
         * // => { '0': { '1': 'a' } }
         */
        updateWith<T extends object>(object: T, path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): T;
        /**
         * @see _.updateWith
         */
        updateWith<T extends object, TResult>(object: T, path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): TResult;
    }
    interface Object<T> {
        /**
         * @see _.updateWith
         */
        updateWith(path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): this;
        /**
         * @see _.updateWith
         */
        updateWith<TResult>(path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): Object<TResult>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.updateWith
         */
        updateWith(path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): this;
        /**
         * @see _.updateWith
         */
        updateWith<TResult>(path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): ObjectChain<TResult>;
    }
    interface LoDashStatic {
        /**
         * Creates an array of the own enumerable property values of object.
         *
         * @param object The object to query.
         * @return Returns an array of property values.
         */
        values<T>(object: Dictionary<T> | NumericDictionary<T> | List<T> | null | undefined): T[];
        /**
         * @see _.values
         */
        values<T extends object>(object: T | null | undefined): Array<T[keyof T]>;
        /**
         * @see _.values
         */
        values(object: any): any[];
    }
    interface String {
        /**
         * @see _.values
         */
        values(): Collection<string>;
    }
    interface Object<T> {
        /**
         * @see _.values
         */
        values(): Collection<T[keyof T]>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.values
         */
        values(): CollectionChain<T[keyof T]>;
    }
    interface StringChain {
        /**
         * @see _.values
         */
        values(): CollectionChain<string>;
    }
    interface StringNullableChain {
        /**
         * @see _.values
         */
        values(): CollectionChain<string>;
    }
    interface LoDashStatic {
        /**
         * Creates an array of the own and inherited enumerable property values of object.
         *
         * @param object The object to query.
         * @return Returns the array of property values.
         */
        valuesIn<T>(object: Dictionary<T> | NumericDictionary<T> | List<T> | null | undefined): T[];
        /**
         * @see _.valuesIn
         */
        valuesIn<T extends object>(object: T | null | undefined): Array<T[keyof T]>;
    }
    interface String {
        /**
         * @see _.valuesIn
         */
        valuesIn(): Collection<string>;
    }
    interface Object<T> {
        /**
         * @see _.valuesIn
         */
        valuesIn(): Collection<T[keyof T]>;
    }
    interface StringChain {
        /**
         * @see _.valuesIn
         */
        valuesIn(): CollectionChain<string>;
    }
    interface StringNullableChain {
        /**
         * @see _.valuesIn
         */
        valuesIn(): CollectionChain<string>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.valuesIn
         */
        valuesIn(): CollectionChain<T[keyof T]>;
    }
}
import _ = require("../index");
declare module "../index" {
    // chain
    interface LoDashStatic {
        /**
         * Creates a lodash object that wraps value with explicit method chaining enabled.
         *
         * @param value The value to wrap.
         * @return Returns the new lodash wrapper instance.
         */
        chain<TrapAny extends { __lodashAnyHack: any }>(value: TrapAny): CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain;
        /**
         * @see _.chain
         */
        chain<T extends null | undefined>(value: T): PrimitiveChain<T>;
        /**
         * @see _.chain
         */
        chain(value: string): StringChain;
        /**
         * @see _.chain
         */
        chain(value: string | null | undefined): StringNullableChain;
        /**
         * @see _.chain
         */
        chain<T extends (...args: any[]) => any>(value: T): FunctionChain<T>;
        /**
         * @see _.chain
         */
        chain<T = any>(value: List<T> | null | undefined): CollectionChain<T>;
        /**
         * @see _.chain
         */
        chain<T extends object>(value: T | null | undefined): ObjectChain<T>;
        /**
         * @see _.chain
         */
        chain<T>(value: T): PrimitiveChain<T>;
    }
    interface Collection<T> {
        /**
         * @see _.chain
         */
        chain(): CollectionChain<T>;
    }
    interface String {
        /**
         * @see _.chain
         */
        chain(): StringChain;
    }
    interface Object<T> {
        /**
         * @see _.chain
         */
        chain(): ObjectChain<T>;
    }
    interface Primitive<T> {
        /**
         * @see _.chain
         */
        chain(): PrimitiveChain<T>;
    }
    interface Function<T extends (...args: any) => any> {
        /**
         * @see _.chain
         */
        chain(): FunctionChain<T>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.chain
         */
        chain(): this;
    }
    // prototype.commit
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.commit
         */
        commit(): this;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.commit
         */
        commit(): this;
    }
    // prototype.plant
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.plant
         */
        plant(value: unknown): this;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.plant
         */
        plant(value: unknown): this;
    }
    // prototype.reverse
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.reverse
         */
        reverse(): this;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.reverse
         */
        reverse(): this;
    }
    // prototype.toJSON
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.toJSON
         */
        toJSON(): TValue;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.toJSON
         */
        toJSON(): TValue;
    }
    // prototype.toString
    interface LoDashWrapper<TValue> {
        /**
         * @see _.toString
         */
        toString(): string;
    }
    // prototype.value
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.value
         */
        value(): TValue;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.value
         */
        value(): TValue;
    }
    // prototype.valueOf
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.valueOf
         */
        valueOf(): TValue;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.valueOf
         */
        valueOf(): TValue;
    }
    // tap
    interface LoDashStatic {
        /**
         * This method invokes interceptor and returns value. The interceptor is invoked with one
         * argument; (value). The purpose of this method is to "tap into" a method chain in order to perform operations
         * on intermediate results within the chain.
         *
         * @param value The value to provide to interceptor.
         * @param interceptor The function to invoke.
         * @return Returns value.
         */
        tap<T>(value: T, interceptor: (value: T) => void): T;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.tap
         */
        tap(interceptor: (value: TValue) => void): this;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.tap
         */
        tap(interceptor: (value: TValue) => void): this;
    }
    // thru
    interface LoDashStatic {
        /**
         * This method is like _.tap except that it returns the result of interceptor.
         *
         * @param value The value to provide to interceptor.
         * @param interceptor The function to invoke.
         * @return Returns the result of interceptor.
         */
        thru<T, TResult>(value: T, interceptor: (value: T) => TResult): TResult;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.thru
         */
        thru<TResult>(interceptor: (value: TValue) => TResult): ImpChain<TResult>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.thru
         */
        thru<TResult>(interceptor: (value: TValue) => TResult): ExpChain<TResult>;
    }
}
import _ = require("../index");
declare module "../index" {
    interface LoDashStatic {
        /**
         * Converts string to camel case.
         *
         * @param string The string to convert.
         * @return Returns the camel cased string.
         */
        camelCase(string?: string): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.camelCase
         */
        camelCase(): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.camelCase
         */
        camelCase(): StringChain;
    }

    interface LoDashStatic {
        /**
         * Converts the first character of string to upper case and the remaining to lower case.
         *
         * @param string The string to capitalize.
         * @return Returns the capitalized string.
         */
        capitalize(string?: string): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.capitalize
         */
        capitalize(): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.capitalize
         */
        capitalize(): StringChain;
    }

    interface LoDashStatic {
        /**
         * Deburrs string by converting latin-1 supplementary letters to basic latin letters and removing combining
         * diacritical marks.
         *
         * @param string The string to deburr.
         * @return Returns the deburred string.
         */
        deburr(string?: string): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.deburr
         */
        deburr(): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.deburr
         */
        deburr(): StringChain;
    }

    interface LoDashStatic {
        /**
         * Checks if string ends with the given target string.
         *
         * @param string The string to search.
         * @param target The string to search for.
         * @param position The position to search from.
         * @return Returns true if string ends with target, else false.
         */
        endsWith(string?: string, target?: string, position?: number): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.endsWith
         */
        endsWith(target?: string, position?: number): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.endsWith
         */
        endsWith(target?: string, position?: number): PrimitiveChain<boolean>;
    }

    interface LoDashStatic {
        /**
         * Converts the characters "&", "<", ">", '"', "'", and "`" in string to their corresponding HTML entities.
         *
         * Note: No other characters are escaped. To escape additional characters use a third-party library like he.
         *
         * Though the ">" character is escaped for symmetry, characters like ">" and "/" don’t need escaping in HTML
         * and have no special meaning unless they're part of a tag or unquoted attribute value. See Mathias Bynens’s
         * article (under "semi-related fun fact") for more details.
         *
         * Backticks are escaped because in IE < 9, they can break out of attribute values or HTML comments. See #59,
         * #102, #108, and #133 of the HTML5 Security Cheatsheet for more details.
         *
         * When working with HTML you should always quote attribute values to reduce XSS vectors.
         *
         * @param string The string to escape.
         * @return Returns the escaped string.
         */
        escape(string?: string): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.escape
         */
        escape(): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.escape
         */
        escape(): StringChain;
    }

    interface LoDashStatic {
        /**
         * Escapes the RegExp special characters "^", "$", "\", ".", "*", "+", "?", "(", ")", "[", "]",
         * "{", "}", and "|" in string.
         *
         * @param string The string to escape.
         * @return Returns the escaped string.
         */
        escapeRegExp(string?: string): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.escapeRegExp
         */
        escapeRegExp(): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.escapeRegExp
         */
        escapeRegExp(): StringChain;
    }

    interface LoDashStatic {
        /**
         * Converts string to kebab case.
         *
         * @param string The string to convert.
         * @return Returns the kebab cased string.
         */
        kebabCase(string?: string): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.kebabCase
         */
        kebabCase(): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.kebabCase
         */
        kebabCase(): StringChain;
    }

    interface LoDashStatic {
        /**
         * Converts `string`, as space separated words, to lower case.
         *
         * @param string The string to convert.
         * @return Returns the lower cased string.
         */
        lowerCase(string?: string): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.lowerCase
         */
        lowerCase(): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.lowerCase
         */
        lowerCase(): StringChain;
    }

    interface LoDashStatic {
        /**
         * Converts the first character of `string` to lower case.
         *
         * @param string The string to convert.
         * @return Returns the converted string.
         */
        lowerFirst(string?: string): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.lowerFirst
         */
        lowerFirst(): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.lowerFirst
         */
        lowerFirst(): StringChain;
    }

    interface LoDashStatic {
        /**
         * Pads string on the left and right sides if it’s shorter than length. Padding characters are truncated if
         * they can’t be evenly divided by length.
         *
         * @param string The string to pad.
         * @param length The padding length.
         * @param chars The string used as padding.
         * @return Returns the padded string.
         */
        pad(string?: string, length?: number, chars?: string): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.pad
         */
        pad(length?: number, chars?: string): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.pad
         */
        pad(length?: number, chars?: string): StringChain;
    }

    interface LoDashStatic {
        /**
         * Pads string on the right side if it’s shorter than length. Padding characters are truncated if they exceed
         * length.
         *
         * @param string The string to pad.
         * @param length The padding length.
         * @param chars The string used as padding.
         * @return Returns the padded string.
         */
        padEnd(string?: string, length?: number, chars?: string): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.padEnd
         */
        padEnd(length?: number, chars?: string): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.padEnd
         */
        padEnd(length?: number, chars?: string): StringChain;
    }

    interface LoDashStatic {
        /**
         * Pads string on the left side if it’s shorter than length. Padding characters are truncated if they exceed
         * length.
         *
         * @param string The string to pad.
         * @param length The padding length.
         * @param chars The string used as padding.
         * @return Returns the padded string.
         */
        padStart(string?: string, length?: number, chars?: string): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.padStart
         */
        padStart(length?: number, chars?: string): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.padStart
         */
        padStart(length?: number, chars?: string): StringChain;
    }

    interface LoDashStatic {
        /**
         * Converts string to an integer of the specified radix. If radix is undefined or 0, a radix of 10 is used
         * unless value is a hexadecimal, in which case a radix of 16 is used.
         *
         * Note: This method aligns with the ES5 implementation of parseInt.
         *
         * @param string The string to convert.
         * @param radix The radix to interpret value by.
         * @return Returns the converted integer.
         */
        parseInt(string: string, radix?: number): number;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.parseInt
         */
        parseInt(radix?: number): number;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.parseInt
         */
        parseInt(radix?: number): PrimitiveChain<number>;
    }

    interface LoDashStatic {
        /**
         * Repeats the given string n times.
         *
         * @param string The string to repeat.
         * @param n The number of times to repeat the string.
         * @return Returns the repeated string.
         */
        repeat(string?: string, n?: number): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.repeat
         */
        repeat(n?: number): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.repeat
         */
        repeat(n?: number): StringChain;
    }
    type ReplaceFunction = (match: string, ...args: any[]) => string;

    interface LoDashStatic {
        /**
         * Replaces matches for pattern in string with replacement.
         *
         * Note: This method is based on String#replace.
         *
         * @return Returns the modified string.
         */
        replace(string: string, pattern: RegExp | string, replacement: ReplaceFunction | string): string;
        /**
         * @see _.replace
         */
        replace(pattern: RegExp | string, replacement: ReplaceFunction | string): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.replace
         */
        replace(pattern: RegExp | string, replacement: ReplaceFunction | string): string;
        /**
         * @see _.replace
         */
        replace(replacement: ReplaceFunction | string): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.replace
         */
        replace(pattern: RegExp | string, replacement: ReplaceFunction | string): StringChain;
        /**
         * @see _.replace
         */
        replace(replacement: ReplaceFunction | string): StringChain;
    }

    interface LoDashStatic {
        /**
         * Converts string to snake case.
         *
         * @param string The string to convert.
         * @return Returns the snake cased string.
         */
        snakeCase(string?: string): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.snakeCase
         */
        snakeCase(): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.snakeCase
         */
        snakeCase(): StringChain;
    }

    interface LoDashStatic {
        /**
         * Splits string by separator.
         *
         * Note: This method is based on String#split.
         *
         * @param string The string to split.
         * @param separator The separator pattern to split by.
         * @param limit The length to truncate results to.
         * @return Returns the new array of string segments.
         */
        split(string: string | null | undefined, separator?: RegExp | string, limit?: number): string[];
        /**
         * @see _.split
         */
        split(string: string | null | undefined, index: string | number, guard: object): string[];
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.split
         */
        split(separator?: RegExp | string, limit?: number): Collection<string>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.split
         */
        split(separator?: RegExp | string, limit?: number): CollectionChain<string>;
    }

    interface LoDashStatic {
        /**
         * Converts string to start case.
         *
         * @param string The string to convert.
         * @return Returns the start cased string.
         */
        startCase(string?: string): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.startCase
         */
        startCase(): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.startCase
         */
        startCase(): StringChain;
    }

    interface LoDashStatic {
        /**
         * Checks if string starts with the given target string.
         *
         * @param string The string to search.
         * @param target The string to search for.
         * @param position The position to search from.
         * @return Returns true if string starts with target, else false.
         */
        startsWith(string?: string, target?: string, position?: number): boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.startsWith
         */
        startsWith(target?: string, position?: number): boolean;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.startsWith
         */
        startsWith(target?: string, position?: number): PrimitiveChain<boolean>;
    }

    interface TemplateOptions extends TemplateSettings {
        /**
         * @see _.sourceURL
         */
        sourceURL?: string | undefined;
    }
    interface TemplateExecutor {
        (data?: object): string;
        /**
         * @see _.source
         */
        source: string;
    }
    interface LoDashStatic {
        /**
         * Creates a compiled template function that can interpolate data properties in "interpolate" delimiters,
         * HTML-escape interpolated data properties in "escape" delimiters, and execute JavaScript in "evaluate"
         * delimiters. Data properties may be accessed as free variables in the template. If a setting object is
         * provided it takes precedence over _.templateSettings values.
         *
         * Note: In the development build _.template utilizes
         * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl) for easier
         * debugging.
         *
         * For more information on precompiling templates see
         * [lodash's custom builds documentation](https://lodash.com/custom-builds).
         *
         * For more information on Chrome extension sandboxes see
         * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
         *
         * @param string The template string.
         * @param options The options object.
         * @param options.escape The HTML "escape" delimiter.
         * @param options.evaluate The "evaluate" delimiter.
         * @param options.imports An object to import into the template as free variables.
         * @param options.interpolate The "interpolate" delimiter.
         * @param options.sourceURL The sourceURL of the template's compiled source.
         * @param options.variable The data object variable name.
         * @return Returns the compiled template function.
         */
        template(string?: string, options?: TemplateOptions): TemplateExecutor;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.template
         */
        template(options?: TemplateOptions): TemplateExecutor;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.template
         */
        template(options?: TemplateOptions): FunctionChain<TemplateExecutor>;
    }

    interface LoDashStatic {
        /**
         * Converts `string`, as a whole, to lower case.
         *
         * @param string The string to convert.
         * @return Returns the lower cased string.
         */
        toLower(string?: string): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.toLower
         */
        toLower(): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.toLower
         */
        toLower(): StringChain;
    }

    interface LoDashStatic {
        /**
         * Converts `string`, as a whole, to upper case.
         *
         * @param string The string to convert.
         * @return Returns the upper cased string.
         */
        toUpper(string?: string): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.toUpper
         */
        toUpper(): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.toUpper
         */
        toUpper(): StringChain;
    }

    interface LoDashStatic {
        /**
         * Removes leading and trailing whitespace or specified characters from string.
         *
         * @param string The string to trim.
         * @param chars The characters to trim.
         * @return Returns the trimmed string.
         */
        trim(string?: string, chars?: string): string;
        /**
         * @see _.trim
         */
        trim(string: string, index: string | number, guard: object): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.trim
         */
        trim(chars?: string): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.trim
         */
        trim(chars?: string): StringChain;
    }

    interface LoDashStatic {
        /**
         * Removes trailing whitespace or specified characters from string.
         *
         * @param string The string to trim.
         * @param chars The characters to trim.
         * @return Returns the trimmed string.
         */
        trimEnd(string?: string, chars?: string): string;
        /**
         * @see _.trimEnd
         */
        trimEnd(string: string, index: string | number, guard: object): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.trimEnd
         */
        trimEnd(chars?: string): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.trimEnd
         */
        trimEnd(chars?: string): StringChain;
    }

    interface LoDashStatic {
        /**
         * Removes leading whitespace or specified characters from string.
         *
         * @param string The string to trim.
         * @param chars The characters to trim.
         * @return Returns the trimmed string.
         */
        trimStart(string?: string, chars?: string): string;
        /**
         * @see _.trimStart
         */
        trimStart(string: string, index: string | number, guard: object): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.trimStart
         */
        trimStart(chars?: string): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.trimStart
         */
        trimStart(chars?: string): StringChain;
    }

    interface TruncateOptions {
        /**
         * @see _.length
         */
        length?: number | undefined;
        /**
         * @see _.omission
         */
        omission?: string | undefined;
        /**
         * @see _.separator
         */
        separator?: string | RegExp | undefined;
    }
    interface LoDashStatic {
        /**
         * Truncates string if it’s longer than the given maximum string length. The last characters of the truncated
         * string are replaced with the omission string which defaults to "…".
         *
         * @param string The string to truncate.
         * @param options The options object or maximum string length.
         * @return Returns the truncated string.
         */
        truncate(string?: string, options?: TruncateOptions): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.truncate
         */
        truncate(options?: TruncateOptions): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.truncate
         */
        truncate(options?: TruncateOptions): StringChain;
    }

    interface LoDashStatic {
        /**
         * The inverse of _.escape; this method converts the HTML entities &amp;, &lt;, &gt;, &quot;, &#39;, and &#96;
         * in string to their corresponding characters.
         *
         * Note: No other HTML entities are unescaped. To unescape additional HTML entities use a third-party library
         * like he.
         *
         * @param string The string to unescape.
         * @return Returns the unescaped string.
         */
        unescape(string?: string): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.unescape
         */
        unescape(): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.unescape
         */
        unescape(): StringChain;
    }

    interface LoDashStatic {
        /**
         * Converts `string`, as space separated words, to upper case.
         *
         * @param string The string to convert.
         * @return Returns the upper cased string.
         */
        upperCase(string?: string): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.upperCase
         */
        upperCase(): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.upperCase
         */
        upperCase(): StringChain;
    }

    interface LoDashStatic {
        /**
         * Converts the first character of `string` to upper case.
         *
         * @param string The string to convert.
         * @return Returns the converted string.
         */
        upperFirst(string?: string): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.upperFirst
         */
        upperFirst(): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.upperFirst
         */
        upperFirst(): StringChain;
    }

    interface LoDashStatic {
        /**
         * Splits `string` into an array of its words.
         *
         * @param string The string to inspect.
         * @param pattern The pattern to match words.
         * @return Returns the words of `string`.
         */
        words(string?: string, pattern?: string | RegExp): string[];
        /**
         * @see _.words
         */
        words(string: string, index: string | number, guard: object): string[];
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.words
         */
        words(pattern?: string | RegExp): Collection<string>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.words
         */
        words(pattern?: string | RegExp): CollectionChain<string>;
    }
}
import _ = require("../index");
declare module "../index" {
    interface LoDashStatic {
        /**
         * Attempts to invoke func, returning either the result or the caught error object. Any additional arguments
         * are provided to func when it’s invoked.
         *
         * @param func The function to attempt.
         * @return Returns the func result or error object.
         */
        attempt<TResult>(func: (...args: any[]) => TResult, ...args: any[]): TResult | Error;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.attempt
         */
        attempt<TResult>(...args: any[]): TResult | Error;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.attempt
         */
        attempt<TResult>(...args: any[]): ExpChain<TResult | Error>;
    }

    interface LoDashStatic {
        /**
         * Binds methods of an object to the object itself, overwriting the existing method. Method names may be
         * specified as individual arguments or as arrays of method names. If no method names are provided all
         * enumerable function properties, own and inherited, of object are bound.
         *
         * Note: This method does not set the "length" property of bound functions.
         *
         * @param object The object to bind and assign the bound methods to.
         * @param methodNames The object method names to bind, specified as individual method names or arrays of
         * method names.
         * @return Returns object.
         */
        bindAll<T>(object: T, ...methodNames: Array<Many<string>>): T;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.bindAll
         */
        bindAll(...methodNames: Array<Many<string>>): this;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.bindAll
         */
        bindAll(...methodNames: Array<Many<string>>): this;
    }

    interface LoDashStatic {
        /**
         * Creates a function that iterates over `pairs` and invokes the corresponding
         * function of the first predicate to return truthy. The predicate-function
         * pairs are invoked with the `this` binding and arguments of the created
         * function.
         *
         * @since 4.0.0
         * @category Util
         * @param pairs The predicate-function pairs.
         * @returns Returns the new composite function.
         * @example
         *
         * var func = _.cond([
         *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
         *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
         *   [_.stubTrue,                      _.constant('no match')]
         * ]);
         *
         * func({ 'a': 1, 'b': 2 });
         * // => 'matches A'
         *
         * func({ 'a': 0, 'b': 1 });
         * // => 'matches B'
         *
         * func({ 'a': '1', 'b': '2' });
         * // => 'no match'
         */
        cond<R>(pairs: Array<CondPairNullary<R>>): () => R;
        cond<T, R>(pairs: Array<CondPairUnary<T, R>>): (Target: T) => R;
    }

    type ConformsPredicateObject<T> = {
        [P in keyof T]: T[P] extends (arg: infer A) => any ? A : any
    };
    interface LoDashStatic {
        /**
         * Creates a function that invokes the predicate properties of `source` with the corresponding
         * property values of a given object, returning true if all predicates return truthy, else false.
         */
        conforms<T>(source: ConformsPredicateObject<T>): (value: T) => boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.conforms
         */
        conforms(): Function<(value: ConformsPredicateObject<TValue>) => boolean>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.conforms
         */
        conforms(): FunctionChain<(value: ConformsPredicateObject<TValue>) => boolean>;
    }

    interface LoDashStatic {
        /**
         * Creates a function that returns value.
         *
         * @param value The value to return from the new function.
         * @return Returns the new function.
         */
        constant<T>(value: T): () => T;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.constant
         */
        constant(): Function<() => TValue>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.constant
         */
        constant(): FunctionChain<() => TValue>;
    }

    interface LoDashStatic {
        /**
         * Checks `value` to determine whether a default value should be returned in
         * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
         * or `undefined`.
         *
         * @param value The value to check.
         * @param defaultValue The default value.
         * @returns Returns the resolved value.
         */
        defaultTo<T>(value: T | null | undefined, defaultValue: T): T;
        /**
         * @see _.defaultTo
         */
        defaultTo<T, TDefault>(value: T | null | undefined, defaultValue: TDefault): T | TDefault;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.defaultTo
         */
        defaultTo(defaultValue: TValue): TValue;
        /**
         * @see _.defaultTo
         */
        defaultTo<TDefault>(defaultValue: TDefault): TValue extends null | undefined ? TDefault : TValue | TDefault;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.defaultTo
         */
        defaultTo(defaultValue: TValue): ExpChain<TValue>;
        /**
         * @see _.defaultTo
         */
        defaultTo<TDefault>(defaultValue: TDefault): ExpChain<TValue extends null | undefined ? TDefault : TValue | TDefault>;
    }

    interface LoDashStatic {
        /**
         * Creates a function that returns the result of invoking the provided functions with the this binding of the
         * created function, where each successive invocation is supplied the return value of the previous.
         *
         * @param funcs Functions to invoke.
         * @return Returns the new function.
         */
        flow<A extends any[], R1, R2, R3, R4, R5, R6, R7>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (...args: A) => R7;
        /**
         * @see _.flow
         */
        flow<A extends any[], R1, R2, R3, R4, R5, R6, R7>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...func: Array<Many<(a: any) => any>>): (...args: A) => any;
        /**
         * @see _.flow
         */
        flow<A extends any[], R1, R2, R3, R4, R5, R6>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): (...args: A) => R6;
        /**
         * @see _.flow
         */
        flow<A extends any[], R1, R2, R3, R4, R5>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): (...args: A) => R5;
        /**
         * @see _.flow
         */
        flow<A extends any[], R1, R2, R3, R4>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): (...args: A) => R4;
        /**
         * @see _.flow
         */
        flow<A extends any[], R1, R2, R3>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (...args: A) => R3;
        /**
         * @see _.flow
         */
        flow<A extends any[], R1, R2>(f1: (...args: A) => R1, f2: (a: R1) => R2): (...args: A) => R2;
        /**
         * @see _.flow
         */
        flow(...func: Array<Many<(...args: any[]) => any>>): (...args: any[]) => any;
    }
    interface Function<T extends (...arg: any) => any> {
        /**
         * @see _.flow
         */
        flow<R2, R3, R4, R5, R6, R7>(f2: (a: ReturnType<T>) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): Function<(...args: Parameters<T>) => R7>;
        /**
         * @see _.flow
         */
        flow<R2, R3, R4, R5, R6, R7>(f2: (a: ReturnType<T>) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...func: Array<Many<(a: any) => any>>): Function<(...args: Parameters<T>) => any>;
        /**
         * @see _.flow
         */
        flow<R2, R3, R4, R5, R6>(f2: (a: ReturnType<T>) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): Function<(...args: Parameters<T>) => R6>;
        /**
         * @see _.flow
         */
        flow<R2, R3, R4, R5>(f2: (a: ReturnType<T>) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): Function<(...args: Parameters<T>) => R5>;
        /**
         * @see _.flow
         */
        flow<R2, R3, R4>(f2: (a: ReturnType<T>) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): Function<(...args: Parameters<T>) => R4>;
        /**
         * @see _.flow
         */
        flow<R2, R3>(f2: (a: ReturnType<T>) => R2, f3: (a: R2) => R3): Function<(...args: Parameters<T>) => R3>;
        /**
         * @see _.flow
         */
        flow<R2>(f2: (a: ReturnType<T>) => R2): Function<(...args: Parameters<T>) => R2>;
        /**
         * @see _.flow
         */
        flow(...func: Array<Many<(...args: any[]) => any>>): Function<(...args: any[]) => any>;
    }
    interface FunctionChain<T> {
        /**
         * @see _.flow
         */
        flow<R2, R3, R4, R5, R6, R7>(f2: (a: ReturnType<T>) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): FunctionChain<(...args: Parameters<T>) => R7>;
        /**
         * @see _.flow
         */
        flow<R2, R3, R4, R5, R6, R7>(f2: (a: ReturnType<T>) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...func: Array<Many<(a: any) => any>>): FunctionChain<(...args: Parameters<T>) => any>;
        /**
         * @see _.flow
         */
        flow<R2, R3, R4, R5, R6>(f2: (a: ReturnType<T>) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): FunctionChain<(...args: Parameters<T>) => R6>;
        /**
         * @see _.flow
         */
        flow<R2, R3, R4, R5>(f2: (a: ReturnType<T>) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): FunctionChain<(...args: Parameters<T>) => R5>;
        /**
         * @see _.flow
         */
        flow<R2, R3, R4>(f2: (a: ReturnType<T>) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): FunctionChain<(...args: Parameters<T>) => R4>;
        /**
         * @see _.flow
         */
        flow<R2, R3>(f2: (a: ReturnType<T>) => R2, f3: (a: R2) => R3): FunctionChain<(...args: Parameters<T>) => R3>;
        /**
         * @see _.flow
         */
        flow<R2>(f2: (a: ReturnType<T>) => R2): FunctionChain<(...args: Parameters<T>) => R2>;
        /**
         * @see _.flow
         */
        flow(...func: Array<Many<(...args: any[]) => any>>): FunctionChain<(...args: any[]) => any>;
    }

    interface LoDashStatic {
        /**
         * This method is like _.flow except that it creates a function that invokes the provided functions from right
         * to left.
         *
         * @param funcs Functions to invoke.
         * @return Returns the new function.
         */
        flowRight<A extends any[], R1, R2, R3, R4, R5, R6, R7>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R7;
        /**
         * @see _.flowRight
         */
        flowRight<A extends any[], R1, R2, R3, R4, R5, R6>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R6;
        /**
         * @see _.flowRight
         */
        flowRight<A extends any[], R1, R2, R3, R4, R5>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R5;
        /**
         * @see _.flowRight
         */
        flowRight<A extends any[], R1, R2, R3, R4>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R4;
        /**
         * @see _.flowRight
         */
        flowRight<A extends any[], R1, R2, R3>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R3;
        /**
         * @see _.flowRight
         */
        flowRight<A extends any[], R1, R2>(f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R2;
        /**
         * @see _.flowRight
         */
        flowRight(...func: Array<Many<(...args: any[]) => any>>): (...args: any[]) => any;
    }
    interface Function<T> {
        /**
         * @see _.flowRight
         */
        flowRight<A extends any[], R1, R2, R3, R4, R5>(f6: (a: R5) => Parameters<T>["0"], f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): Function<(...args: A) => ReturnType<T>>;
        /**
         * @see _.flowRight
         */
        flowRight<A extends any[], R1, R2, R3, R4>(f5: (a: R4) => Parameters<T>["0"], f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): Function<(...args: A) => ReturnType<T>>;
        /**
         * @see _.flowRight
         */
        flowRight<A extends any[], R1, R2, R3>(f4: (a: R3) => Parameters<T>["0"], f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): Function<(...args: A) => ReturnType<T>>;
        /**
         * @see _.flowRight
         */
        flowRight<A extends any[], R1, R2>(f3: (a: R2) => Parameters<T>["0"], f2: (a: R1) => R2, f1: (...args: A) => R1): Function<(...args: A) => ReturnType<T>>;
        /**
         * @see _.flowRight
         */
        flowRight<A extends any[], R1>(f2: (a: R1) => Parameters<T>["0"], f1: (...args: A) => R1): Function<(...args: A) => ReturnType<T>>;
        /**
         * @see _.flowRight
         */
        flowRight<A extends any[]>(f1: (...args: A) => Parameters<T>["0"]): Function<(...args: A) => ReturnType<T>>;
        /**
         * @see _.flowRight
         */
        flowRight(...func: Array<Many<(...args: any[]) => any>>): Function<(...args: any[]) => any>;
    }
    interface FunctionChain<T> {
        /**
         * @see _.flowRight
         */
        flowRight<A extends any[], R1, R2, R3, R4, R5>(f6: (a: R5) => Parameters<T>["0"], f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): FunctionChain<(...args: A) => ReturnType<T>>;
        /**
         * @see _.flowRight
         */
        flowRight<A extends any[], R1, R2, R3, R4>(f5: (a: R4) => Parameters<T>["0"], f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): FunctionChain<(...args: A) => ReturnType<T>>;
        /**
         * @see _.flowRight
         */
        flowRight<A extends any[], R1, R2, R3>(f4: (a: R3) => Parameters<T>["0"], f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): FunctionChain<(...args: A) => ReturnType<T>>;
        /**
         * @see _.flowRight
         */
        flowRight<A extends any[], R1, R2>(f3: (a: R2) => Parameters<T>["0"], f2: (a: R1) => R2, f1: (...args: A) => R1): FunctionChain<(...args: A) => ReturnType<T>>;
        /**
         * @see _.flowRight
         */
        flowRight<A extends any[], R1>(f2: (a: R1) => Parameters<T>["0"], f1: (...args: A) => R1): FunctionChain<(...args: A) => ReturnType<T>>;
        /**
         * @see _.flowRight
         */
        flowRight<A extends any[]>(f1: (...args: A) => Parameters<T>["0"]): FunctionChain<(...args: A) => ReturnType<T>>;
        /**
         * @see _.flowRight
         */
        flowRight(...func: Array<Many<(...args: any[]) => any>>): FunctionChain<(...args: any[]) => any>;
    }

    interface LoDashStatic {
        /**
         * This method returns the first argument provided to it.
         *
         * @param value Any value.
         * @return Returns value.
         */
        identity<T>(value: T): T;
        /**
         * @see _.identity
         */
        identity(): undefined;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.identity
         */
        identity(): TValue;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.identity
         */
        identity(): this;
    }

    interface LoDashStatic {
        /**
         * Creates a function that invokes `func` with the arguments of the created
         * function. If `func` is a property name the created callback returns the
         * property value for a given element. If `func` is an object the created
         * callback returns `true` for elements that contain the equivalent object properties, otherwise it returns `false`.
         *
         * @category Util
         * @param [func=_.identity] The value to convert to a callback.
         * @returns Returns the callback.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * // create custom iteratee shorthands
         * _.iteratee = _.wrap(_.iteratee, function(callback, func) {
         *   var p = /^(\S+)\s*([<>])\s*(\S+)$/.exec(func);
         *   return !p ? callback(func) : function(object) {
         *     return (p[2] == '>' ? object[p[1]] > p[3] : object[p[1]] < p[3]);
         *   };
         * });
         *
         * _.filter(users, 'age > 36');
         * // => [{ 'user': 'fred', 'age': 40 }]
         */
        iteratee<TFunction extends (...args: any[]) => any>(func: TFunction): TFunction;
        /**
         * @see _.iteratee
         */
        iteratee(func: symbol | number | string | object): (...args: any[]) => any;
    }
    interface Function<T extends (...args: any) => any> {
        /**
         * @see _.iteratee
         */
        iteratee(): Function<T>;
    }
    interface Collection<T> {
        /**
         * @see _.iteratee
         */
        iteratee(): Function<(o: object) => boolean>;
    }
    interface Object<T> {
        /**
         * @see _.iteratee
         */
        iteratee(): Function<(o: T) => boolean>;
    }
    interface String {
        /**
         * @see _.iteratee
         */
        iteratee(): Function<(o: object) => any>;
    }
    interface FunctionChain<T extends (...args: any) => any> {
        /**
         * @see _.iteratee
         */
        iteratee(): FunctionChain<T>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.iteratee
         */
        iteratee(): FunctionChain<(o: object) => boolean>;
    }
    interface ObjectChain<T> {
        /**
         * @see _.iteratee
         */
        iteratee(): FunctionChain<(o: T) => boolean>;
    }
    interface StringChain {
        /**
         * @see _.iteratee
         */
        iteratee(): FunctionChain<(o: object) => any>;
    }
    interface StringNullableChain {
        /**
         * @see _.iteratee
         */
        iteratee(): FunctionChain<(o: object) => any>;
    }

    interface LoDashStatic {
        /**
         * Creates a function that performs a deep comparison between a given object and source, returning true if the
         * given object has equivalent property values, else false.
         *
         * Note: This method supports comparing arrays, booleans, Date objects, numbers, Object objects, regexes, and
         * strings. Objects are compared by their own, not inherited, enumerable properties. For comparing a single own
         * or inherited property value see _.matchesProperty.
         *
         * @param source The object of property values to match.
         * @return Returns the new function.
         */
        matches<T>(source: T): (value: any) => boolean;
        /**
         * @see _.matches
         */
        matches<T, V>(source: T): (value: V) => boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.matches
         */
        matches<V>(): Function<(value: V) => boolean>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.matches
         */
        matches<V>(): FunctionChain<(value: V) => boolean>;
    }

    interface LoDashStatic {
        /**
         * Creates a function that compares the property value of path on a given object to value.
         *
         * Note: This method supports comparing arrays, booleans, Date objects, numbers, Object objects, regexes, and
         * strings. Objects are compared by their own, not inherited, enumerable properties.
         *
         * @param path The path of the property to get.
         * @param srcValue The value to match.
         * @return Returns the new function.
         */
        matchesProperty<T>(path: PropertyPath, srcValue: T): (value: any) => boolean;
        /**
         * @see _.matchesProperty
         */
        matchesProperty<T, V>(path: PropertyPath, srcValue: T): (value: V) => boolean;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.matchesProperty
         */
        matchesProperty<SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>;
        /**
         * @see _.matchesProperty
         */
        matchesProperty<SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.matchesProperty
         */
        matchesProperty<SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>;
        /**
         * @see _.matchesProperty
         */
        matchesProperty<SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>;
    }

    interface LoDashStatic {
        /**
         * Creates a function that invokes the method at path on a given object. Any additional arguments are provided
         * to the invoked method.
         *
         * @param path The path of the method to invoke.
         * @param args The arguments to invoke the method with.
         * @return Returns the new function.
         */
        method(path: PropertyPath, ...args: any[]): (object: any) => any;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.method
         */
        method(...args: any[]): Function<(object: any) => any>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.method
         */
        method(...args: any[]): FunctionChain<(object: any) => any>;
    }

    interface LoDashStatic {
        /**
         * The opposite of _.method; this method creates a function that invokes the method at a given path on object.
         * Any additional arguments are provided to the invoked method.
         *
         * @param object The object to query.
         * @param args The arguments to invoke the method with.
         * @return Returns the new function.
         */
        methodOf(object: object, ...args: any[]): (path: PropertyPath) => any;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.methodOf
         */
        methodOf(...args: any[]): LoDashImplicitWrapper<(path: PropertyPath) => any>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.methodOf
         */
        methodOf(...args: any[]): LoDashExplicitWrapper<(path: PropertyPath) => any>;
    }

    interface MixinOptions {
        /**
         * @see _.chain
         */
        chain?: boolean | undefined;
    }
    interface LoDashStatic {
        /**
         * Adds all own enumerable function properties of a source object to the destination object. If object is a
         * function then methods are added to its prototype as well.
         *
         * Note: Use _.runInContext to create a pristine lodash function to avoid conflicts caused by modifying
         * the original.
         *
         * @param object The destination object.
         * @param source The object of functions to add.
         * @param options The options object.
         * @param options.chain Specify whether the functions added are chainable.
         * @return Returns object.
         */
        mixin<TObject>(object: TObject, source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): TObject;
        /**
         * @see _.mixin
         */
        mixin<TResult>(source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashStatic;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.mixin
         */
        mixin(source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): this;
        /**
         * @see _.mixin
         */
        mixin(options?: MixinOptions): LoDashImplicitWrapper<LoDashStatic>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.mixin
         */
        mixin(source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): this;
        /**
         * @see _.mixin
         */
        mixin(options?: MixinOptions): LoDashExplicitWrapper<LoDashStatic>;
    }

    interface LoDashStatic {
        /**
         * Reverts the _ variable to its previous value and returns a reference to the lodash function.
         *
         * @return Returns the lodash function.
         */
        noConflict(): typeof _;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.noConflict
         */
        noConflict(): typeof _;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.noConflict
         */
        noConflict(): LoDashExplicitWrapper<typeof _>;
    }

    interface LoDashStatic {
        /**
         * A no-operation function that returns undefined regardless of the arguments it receives.
         *
         * @return undefined
         */
        noop(...args: any[]): void;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.noop
         */
        noop(...args: any[]): void;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.noop
         */
        noop(...args: any[]): PrimitiveChain<undefined>;
    }

    interface LoDashStatic {
        /**
         * Creates a function that returns its nth argument.
         *
         * @param n The index of the argument to return.
         * @return Returns the new function.
         */
        nthArg(n?: number): (...args: any[]) => any;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.nthArg
         */
        nthArg(): Function<(...args: any[]) => any>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.nthArg
         */
        nthArg(): FunctionChain<(...args: any[]) => any>;
    }

    interface LoDashStatic {
        /**
         * Creates a function that invokes iteratees with the arguments provided to the created function and returns
         * their results.
         *
         * @param iteratees The iteratees to invoke.
         * @return Returns the new function.
         */
        over<TResult>(...iteratees: Array<Many<(...args: any[]) => TResult>>): (...args: any[]) => TResult[];
    }
    interface Collection<T> {
        /**
         * @see _.over
         */
        over<TResult>(...iteratees: Array<Many<(...args: any[]) => TResult>>): Function<(...args: any[]) => TResult[]>;
    }
    interface Function<T> {
        /**
         * @see _.over
         */
        over<TResult>(...iteratees: Array<Many<(...args: any[]) => TResult>>): Function<(...args: any[]) => Array<ReturnType<T> | TResult>>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.over
         */
        over<TResult>(...iteratees: Array<Many<(...args: any[]) => TResult>>): FunctionChain<(...args: any[]) => TResult[]>;
    }
    interface FunctionChain<T> {
        /**
         * @see _.over
         */
        over<TResult>(...iteratees: Array<Many<(...args: any[]) => TResult>>): FunctionChain<(...args: any[]) => Array<ReturnType<T> | TResult>>;
    }

    interface LoDashStatic {
        /**
         * Creates a function that checks if all of the predicates return truthy when invoked with the arguments
         * provided to the created function.
         *
         * @param predicates The predicates to check.
         * @return Returns the new function.
         */
        overEvery<T, Result1 extends T, Result2 extends T>(...predicates: [
            (arg: T) => arg is Result1,
            (arg: T) => arg is Result2
        ]): (arg: T) => arg is Result1 & Result2;
        overEvery<T>(...predicates: Array<Many<(...args: T[]) => boolean>>): (...args: T[]) => boolean;
    }
    interface Collection<T> {
        /**
         * @see _.overEvery
         */
        overEvery<TArgs>(...iteratees: Array<Many<(...args: TArgs[]) => boolean>>): Function<(...args: TArgs[]) => boolean>;
    }
    interface Function<T> {
        /**
         * @see _.overEvery
         */
        overEvery<TArgs>(...iteratees: Array<Many<(...args: TArgs[]) => boolean>>): Function<(...args: Parameters<T> | TArgs[]) => boolean>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.overEvery
         */
        overEvery<TArgs>(...iteratees: Array<Many<(...args: TArgs[]) => boolean>>): FunctionChain<(...args:  TArgs[]) => boolean>;
    }
    interface FunctionChain<T> {
        /**
         * @see _.overEvery
         */
        overEvery<TArgs>(...iteratees: Array<Many<(...args: TArgs[]) => boolean>>): FunctionChain<(...args: Parameters<T> | TArgs[]) => boolean>;
    }

    interface LoDashStatic {
        /**
         * Creates a function that checks if any of the predicates return truthy when invoked with the arguments
         * provided to the created function.
         *
         * @param predicates The predicates to check.
         * @return Returns the new function.
         */
        overSome<T, Result1 extends T, Result2 extends T>(...predicates: [
            (arg: T) => arg is Result1,
            (arg: T) => arg is Result2
        ]): (arg: T) => arg is Result1 | Result2;
        overSome<T>(...predicates: Array<Many<(...args: T[]) => boolean>>): (...args: T[]) => boolean;
    }
    interface Collection<T> {
        /**
         * @see _.overSome
         */
        overSome<TArgs>(...iteratees: Array<Many<(...args: TArgs[]) => boolean>>): Function<(...args: TArgs[]) => boolean>;
    }
    interface Function<T> {
        /**
         * @see _.overSome
         */
        overSome<TArgs>(...iteratees: Array<Many<(...args: TArgs[]) => boolean>>): Function<(...args: Parameters<T> | TArgs[]) => boolean>;
    }
    interface CollectionChain<T> {
        /**
         * @see _.overSome
         */
        overSome<TArgs>(...iteratees: Array<Many<(...args: TArgs[]) => boolean>>): FunctionChain<(...args: TArgs[]) => boolean>;
    }
    interface FunctionChain<T> {
        /**
         * @see _.overSome
         */
        overSome<TArgs>(...iteratees: Array<Many<(...args: TArgs[]) => boolean>>): FunctionChain<(...args: Parameters<T> | TArgs[]) => boolean>;
    }

    interface LoDashStatic {
        /**
         * Creates a function that returns the property value at path on a given object.
         *
         * @param path The path of the property to get.
         * @return Returns the new function.
         */
        property<TObj, TResult>(path: PropertyPath): (obj: TObj) => TResult;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.property
         */
        property<TObj, TResult>(): Function<(obj: TObj) => TResult>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.property
         */
        property<TObj, TResult>(): FunctionChain<(obj: TObj) => TResult>;
    }

    interface LoDashStatic {
        /**
         * The opposite of _.property; this method creates a function that returns the property value at a given path
         * on object.
         *
         * @param object The object to query.
         * @return Returns the new function.
         */
        propertyOf<T extends {}>(object: T): (path: PropertyPath) => any;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.propertyOf
         */
        propertyOf(): LoDashImplicitWrapper<(path: PropertyPath) => any>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.propertyOf
         */
        propertyOf(): LoDashExplicitWrapper<(path: PropertyPath) => any>;
    }

    interface LoDashStatic {
        /**
         * Creates an array of numbers (positive and/or negative) progressing from start up to, but not including, end.
         * If end is not specified it’s set to start with start then set to 0. If end is less than start a zero-length
         * range is created unless a negative step is specified.
         *
         * @param start The start of the range.
         * @param end The end of the range.
         * @param step The value to increment or decrement by.
         * @return Returns a new range array.
         */
        range(start: number, end?: number, step?: number): number[];
        /**
         * @see _.range
         */
        range(end: number, index: string | number, guard: object): number[];
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.range
         */
        range(end?: number, step?: number): Collection<number>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.range
         */
        range(end?: number, step?: number): CollectionChain<number>;
    }

    interface LoDashStatic {
        /**
         * This method is like `_.range` except that it populates values in
         * descending order.
         *
         * @category Util
         * @param start The start of the range.
         * @param end The end of the range.
         * @param step The value to increment or decrement by.
         * @returns Returns the new array of numbers.
         * @example
         *
         * _.rangeRight(4);
         * // => [3, 2, 1, 0]
         *
         * _.rangeRight(-4);
         * // => [-3, -2, -1, 0]
         *
         * _.rangeRight(1, 5);
         * // => [4, 3, 2, 1]
         *
         * _.rangeRight(0, 20, 5);
         * // => [15, 10, 5, 0]
         *
         * _.rangeRight(0, -4, -1);
         * // => [-3, -2, -1, 0]
         *
         * _.rangeRight(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.rangeRight(0);
         * // => []
         */
        rangeRight(start: number, end?: number, step?: number): number[];
        /**
         * @see _.rangeRight
         */
        rangeRight(end: number, index: string | number, guard: object): number[];
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.rangeRight
         */
        rangeRight(end?: number, step?: number): Collection<number>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.rangeRight
         */
        rangeRight(end?: number, step?: number): CollectionChain<number>;
    }

    interface LoDashStatic {
        /**
         * Create a new pristine lodash function using the given context object.
         *
         * @param context The context object.
         * @return Returns a new lodash function.
         */
        runInContext(context?: object): LoDashStatic;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.runInContext
         */
        runInContext(): LoDashStatic;
    }

    interface LoDashStatic {
        /**
         * This method returns a new empty array.
         *
         * @returns Returns the new empty array.
         */
        stubArray(): any[];
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.stubArray
         */
        stubArray(): any[];
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.stubArray
         */
        stubArray(): CollectionChain<any>;
    }

    interface LoDashStatic {
        /**
         * This method returns `false`.
         *
         * @returns Returns `false`.
         */
        stubFalse(): false;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.stubFalse
         */
        stubFalse(): false;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.stubFalse
         */
        stubFalse(): PrimitiveChain<false>;
    }

    interface LoDashStatic {
        /**
         * This method returns a new empty object.
         *
         * @returns Returns the new empty object.
         */
        stubObject(): any;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.stubObject
         */
        stubObject(): any;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.stubObject
         */
        stubObject(): LoDashExplicitWrapper<any>;
    }

    interface LoDashStatic {
        /**
         * This method returns an empty string.
         *
         * @returns Returns the empty string.
         */
        stubString(): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.stubString
         */
        stubString(): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.stubString
         */
        stubString(): StringChain;
    }

    interface LoDashStatic {
        /**
         * This method returns `true`.
         *
         * @returns Returns `true`.
         */
        stubTrue(): true;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.stubTrue
         */
        stubTrue(): true;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.stubTrue
         */
        stubTrue(): PrimitiveChain<true>;
    }

    interface LoDashStatic {
        /**
         * Invokes the iteratee function n times, returning an array of the results of each invocation. The iteratee
         * is invoked with one argument; (index).
         *
         * @param n The number of times to invoke iteratee.
         * @param iteratee The function invoked per iteration.
         * @return Returns the array of results.
         */
        times<TResult>(n: number, iteratee: (num: number) => TResult): TResult[];
        /**
         * @see _.times
         */
        times(n: number): number[];
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.times
         */
        times<TResult>(iteratee: (num: number) => TResult): TResult[];
        /**
         * @see _.times
         */
        times(): number[];
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.times
         */
        times<TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>;
        /**
         * @see _.times
         */
        times(): CollectionChain<number>;
    }

    interface LoDashStatic {
        /**
         * Converts `value` to a property path array.
         *
         * @category Util
         * @param value The value to convert.
         * @returns Returns the new property path array.
         * @example
         *
         * _.toPath('a.b.c');
         * // => ['a', 'b', 'c']
         *
         * _.toPath('a[0].b.c');
         * // => ['a', '0', 'b', 'c']
         *
         * var path = ['a', 'b', 'c'],
         *     newPath = _.toPath(path);
         *
         * console.log(newPath);
         * // => ['a', 'b', 'c']
         *
         * console.log(path === newPath);
         * // => false
         */
        toPath(value: any): string[];
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.toPath
         */
        toPath(): Collection<string>;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.toPath
         */
        toPath(): CollectionChain<string>;
    }

    interface LoDashStatic {
        /**
         * Generates a unique ID. If prefix is provided the ID is appended to it.
         *
         * @param prefix The value to prefix the ID with.
         * @return Returns the unique ID.
         */
        uniqueId(prefix?: string): string;
    }
    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.uniqueId
         */
        uniqueId(): string;
    }
    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.uniqueId
         */
        uniqueId(): StringChain;
    }

    // stubTrue

    interface LoDashStatic {
        /**
         * This method returns true.
         *
         * @return Returns true.
         */
        stubTrue(): true;
    }

    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.stubTrue
         */
        stubTrue(): true;
    }

    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.stubTrue
         */
        stubTrue(): LoDashExplicitWrapper<true>;
    }

    // stubFalse

    interface LoDashStatic {
        /**
         * This method returns false.
         *
         * @return Returns false.
         */
        stubFalse(): false;
    }

    interface LoDashImplicitWrapper<TValue> {
        /**
         * @see _.stubFalse
         */
        stubFalse(): false;
    }

    interface LoDashExplicitWrapper<TValue> {
        /**
         * @see _.stubFalse
         */
        stubFalse(): LoDashExplicitWrapper<false>;
    }
}
import { compact } from "./index";
export = compact;
import { concat } from "./index";
export = concat;
import { cond } from "./index";
export = cond;
import { conformsTo } from "./index";
export = conformsTo;
import { constant } from "./index";
export = constant;
import { countBy } from "./index";
export = countBy;
import { create } from "./index";
export = create;
import { curry } from "./index";
export = curry;
import { curryRight } from "./index";
export = curryRight;
import { debounce } from "./index";
export = debounce;
import { deburr } from "./index";
export = deburr;
import { defaults } from "./index";
export = defaults;
import { defaultsDeep } from "./index";
export = defaultsDeep;
import { defaultTo } from "./index";
export = defaultTo;
import { defer } from "./index";
export = defer;
import { delay } from "./index";
export = delay;
import { difference } from "./index";
export = difference;
import { differenceBy } from "./index";
export = differenceBy;
import { differenceWith } from "./index";
export = differenceWith;
import { divide } from "./index";
export = divide;
import { drop } from "./index";
export = drop;
import { dropRight } from "./index";
export = dropRight;
import { dropRightWhile } from "./index";
export = dropRightWhile;
import { dropWhile } from "./index";
export = dropWhile;
import { each } from "./index";
export = each;
import { eachRight } from "./index";
export = eachRight;
import { endsWith } from "./index";
export = endsWith;
import { entries } from "./index";
export = entries;
import { entriesIn } from "./index";
export = entriesIn;
import { eq } from "./index";
export = eq;
import { escape } from "./index";
export = escape;
import { escapeRegExp } from "./index";
export = escapeRegExp;
import { every } from "./index";
export = every;
import { extend } from "./index";
export = extend;
import { extendWith } from "./index";
export = extendWith;
import { fill } from "./index";
export = fill;
import { filter } from "./index";
export = filter;
import { find } from "./index";
export = find;
import { findIndex } from "./index";
export = findIndex;
import { findKey } from "./index";
export = findKey;
import { findLast } from "./index";
export = findLast;
import { findLastIndex } from "./index";
export = findLastIndex;
import { findLastKey } from "./index";
export = findLastKey;
import { first } from "./index";
export = first;
import { flatMap } from "./index";
export = flatMap;
import { flatMapDeep } from "./index";
export = flatMapDeep;
import { flatMapDepth } from "./index";
export = flatMapDepth;
import { flatten } from "./index";
export = flatten;
import { flattenDeep } from "./index";
export = flattenDeep;
import { flattenDepth } from "./index";
export = flattenDepth;
import { flip } from "./index";
export = flip;
import { floor } from "./index";
export = floor;
import { flow } from "./index";
export = flow;
import { flowRight } from "./index";
export = flowRight;
import { forEach } from "./index";
export = forEach;
import { forEachRight } from "./index";
export = forEachRight;
import { forIn } from "./index";
export = forIn;
import { forInRight } from "./index";
export = forInRight;
import { forOwn } from "./index";
export = forOwn;
import { forOwnRight } from "./index";
export = forOwnRight;
// AUTO-GENERATED: do not modify this file directly.
// If you need to make changes, modify generate-fp.ts (if necessary), then open a terminal in types/lodash/scripts, and do:
// npm install && npm run generate

import lodash = require("./index");

export = _;

declare const _: _.LoDashFp;
declare namespace _ {
    interface LodashAdd {
        (augend: number): LodashAdd1x1;
        (augend: lodash.__, addend: number): LodashAdd1x2;
        (augend: number, addend: number): number;
    }
    type LodashAdd1x1 = (addend: number) => number;
    type LodashAdd1x2 = (augend: number) => number;
    interface LodashAfter {
        <TFunc extends (...args: any[]) => any>(func: TFunc): LodashAfter1x1<TFunc>;
        (func: lodash.__, n: number): LodashAfter1x2;
        <TFunc extends (...args: any[]) => any>(func: TFunc, n: number): TFunc;
    }
    type LodashAfter1x1<TFunc extends (...args: any[]) => any> = (n: number) => TFunc;
    type LodashAfter1x2 = <TFunc extends (...args: any[]) => any>(func: TFunc) => TFunc;
    interface LodashEvery {
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>): LodashEvery1x1<T>;
        <T>(predicate: lodash.__, collection: lodash.List<T> | null | undefined): LodashEvery1x2<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, collection: lodash.List<T> | null | undefined): boolean;
        <T extends object>(predicate: lodash.__, collection: T | null | undefined): LodashEvery2x2<T>;
        <T extends object>(predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>, collection: T | null | undefined): boolean;
    }
    type LodashEvery1x1<T> = (collection: lodash.List<T> | object | null | undefined) => boolean;
    type LodashEvery1x2<T> = (predicate: lodash.ValueIterateeCustom<T, boolean>) => boolean;
    type LodashEvery2x2<T> = (predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>) => boolean;
    type LodashOverEvery = <T>(predicates: lodash.Many<(...args: T[]) => boolean>) => (...args: T[]) => boolean;
    type LodashConstant = <T>(value: T) => () => T;
    interface LodashSome {
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>): LodashSome1x1<T>;
        <T>(predicate: lodash.__, collection: lodash.List<T> | null | undefined): LodashSome1x2<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, collection: lodash.List<T> | null | undefined): boolean;
        <T extends object>(predicate: lodash.__, collection: T | null | undefined): LodashSome2x2<T>;
        <T extends object>(predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>, collection: T | null | undefined): boolean;
    }
    type LodashSome1x1<T> = (collection: lodash.List<T> | object | null | undefined) => boolean;
    type LodashSome1x2<T> = (predicate: lodash.ValueIterateeCustom<T, boolean>) => boolean;
    type LodashSome2x2<T> = (predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>) => boolean;
    type LodashOverSome = <T>(predicates: lodash.Many<(...args: T[]) => boolean>) => (...args: T[]) => boolean;
    type LodashApply = <TResult>(func: (...args: any[]) => TResult) => (...args: any[]) => TResult;
    interface LodashAry {
        (n: number): LodashAry1x1;
        (n: lodash.__, func: (...args: any[]) => any): LodashAry1x2;
        (n: number, func: (...args: any[]) => any): (...args: any[]) => any;
    }
    type LodashAry1x1 = (func: (...args: any[]) => any) => (...args: any[]) => any;
    type LodashAry1x2 = (n: number) => (...args: any[]) => any;
    interface LodashAssign {
        <TObject>(object: TObject): LodashAssign1x1<TObject>;
        <TSource>(object: lodash.__, source: TSource): LodashAssign1x2<TSource>;
        <TObject, TSource>(object: TObject, source: TSource): TObject & TSource;
    }
    type LodashAssign1x1<TObject> = <TSource>(source: TSource) => TObject & TSource;
    type LodashAssign1x2<TSource> = <TObject>(object: TObject) => TObject & TSource;
    interface LodashAssignAll {
        <TObject, TSource>(object: [TObject, TSource]): TObject & TSource;
        <TObject, TSource1, TSource2>(object: [TObject, TSource1, TSource2]): TObject & TSource1 & TSource2;
        <TObject, TSource1, TSource2, TSource3>(object: [TObject, TSource1, TSource2, TSource3]): TObject & TSource1 & TSource2 & TSource3;
        <TObject, TSource1, TSource2, TSource3, TSource4>(object: [TObject, TSource1, TSource2, TSource3, TSource4]): TObject & TSource1 & TSource2 & TSource3 & TSource4;
        <TObject>(object: [TObject]): TObject;
        (object: readonly any[]): any;
    }
    interface LodashAssignAllWith {
        (customizer: lodash.AssignCustomizer): LodashAssignAllWith1x1;
        (customizer: lodash.__, args: readonly any[]): LodashAssignAllWith1x2;
        (customizer: lodash.AssignCustomizer, args: readonly any[]): any;
    }
    type LodashAssignAllWith1x1 = (args: readonly any[]) => any;
    type LodashAssignAllWith1x2 = (customizer: lodash.AssignCustomizer) => any;
    interface LodashAssignIn {
        <TObject>(object: TObject): LodashAssignIn1x1<TObject>;
        <TSource>(object: lodash.__, source: TSource): LodashAssignIn1x2<TSource>;
        <TObject, TSource>(object: TObject, source: TSource): TObject & TSource;
    }
    type LodashAssignIn1x1<TObject> = <TSource>(source: TSource) => TObject & TSource;
    type LodashAssignIn1x2<TSource> = <TObject>(object: TObject) => TObject & TSource;
    interface LodashAssignInAll {
        <TObject, TSource>(object: [TObject, TSource]): TObject & TSource;
        <TObject, TSource1, TSource2>(object: [TObject, TSource1, TSource2]): TObject & TSource1 & TSource2;
        <TObject, TSource1, TSource2, TSource3>(object: [TObject, TSource1, TSource2, TSource3]): TObject & TSource1 & TSource2 & TSource3;
        <TObject, TSource1, TSource2, TSource3, TSource4>(object: [TObject, TSource1, TSource2, TSource3, TSource4]): TObject & TSource1 & TSource2 & TSource3 & TSource4;
        <TObject>(object: [TObject]): TObject;
        <TResult>(object: readonly any[]): TResult;
    }
    interface LodashAssignInAllWith {
        (customizer: lodash.AssignCustomizer): LodashAssignInAllWith1x1;
        (customizer: lodash.__, args: readonly any[]): LodashAssignInAllWith1x2;
        (customizer: lodash.AssignCustomizer, args: readonly any[]): any;
    }
    type LodashAssignInAllWith1x1 = (args: readonly any[]) => any;
    type LodashAssignInAllWith1x2 = (customizer: lodash.AssignCustomizer) => any;
    interface LodashAssignInWith {
        (customizer: lodash.AssignCustomizer): LodashAssignInWith1x1;
        <TObject>(customizer: lodash.__, object: TObject): LodashAssignInWith1x2<TObject>;
        <TObject>(customizer: lodash.AssignCustomizer, object: TObject): LodashAssignInWith1x3<TObject>;
        <TSource>(customizer: lodash.__, object: lodash.__, source: TSource): LodashAssignInWith1x4<TSource>;
        <TSource>(customizer: lodash.AssignCustomizer, object: lodash.__, source: TSource): LodashAssignInWith1x5<TSource>;
        <TObject, TSource>(customizer: lodash.__, object: TObject, source: TSource): LodashAssignInWith1x6<TObject, TSource>;
        <TObject, TSource>(customizer: lodash.AssignCustomizer, object: TObject, source: TSource): TObject & TSource;
    }
    interface LodashAssignInWith1x1 {
        <TObject>(object: TObject): LodashAssignInWith1x3<TObject>;
        <TSource>(object: lodash.__, source: TSource): LodashAssignInWith1x5<TSource>;
        <TObject, TSource>(object: TObject, source: TSource): TObject & TSource;
    }
    interface LodashAssignInWith1x2<TObject> {
        (customizer: lodash.AssignCustomizer): LodashAssignInWith1x3<TObject>;
        <TSource>(customizer: lodash.__, source: TSource): LodashAssignInWith1x6<TObject, TSource>;
        <TSource>(customizer: lodash.AssignCustomizer, source: TSource): TObject & TSource;
    }
    type LodashAssignInWith1x3<TObject> = <TSource>(source: TSource) => TObject & TSource;
    interface LodashAssignInWith1x4<TSource> {
        (customizer: lodash.AssignCustomizer): LodashAssignInWith1x5<TSource>;
        <TObject>(customizer: lodash.__, object: TObject): LodashAssignInWith1x6<TObject, TSource>;
        <TObject>(customizer: lodash.AssignCustomizer, object: TObject): TObject & TSource;
    }
    type LodashAssignInWith1x5<TSource> = <TObject>(object: TObject) => TObject & TSource;
    type LodashAssignInWith1x6<TObject, TSource> = (customizer: lodash.AssignCustomizer) => TObject & TSource;
    interface LodashAssignWith {
        (customizer: lodash.AssignCustomizer): LodashAssignWith1x1;
        <TObject>(customizer: lodash.__, object: TObject): LodashAssignWith1x2<TObject>;
        <TObject>(customizer: lodash.AssignCustomizer, object: TObject): LodashAssignWith1x3<TObject>;
        <TSource>(customizer: lodash.__, object: lodash.__, source: TSource): LodashAssignWith1x4<TSource>;
        <TSource>(customizer: lodash.AssignCustomizer, object: lodash.__, source: TSource): LodashAssignWith1x5<TSource>;
        <TObject, TSource>(customizer: lodash.__, object: TObject, source: TSource): LodashAssignWith1x6<TObject, TSource>;
        <TObject, TSource>(customizer: lodash.AssignCustomizer, object: TObject, source: TSource): TObject & TSource;
    }
    interface LodashAssignWith1x1 {
        <TObject>(object: TObject): LodashAssignWith1x3<TObject>;
        <TSource>(object: lodash.__, source: TSource): LodashAssignWith1x5<TSource>;
        <TObject, TSource>(object: TObject, source: TSource): TObject & TSource;
    }
    interface LodashAssignWith1x2<TObject> {
        (customizer: lodash.AssignCustomizer): LodashAssignWith1x3<TObject>;
        <TSource>(customizer: lodash.__, source: TSource): LodashAssignWith1x6<TObject, TSource>;
        <TSource>(customizer: lodash.AssignCustomizer, source: TSource): TObject & TSource;
    }
    type LodashAssignWith1x3<TObject> = <TSource>(source: TSource) => TObject & TSource;
    interface LodashAssignWith1x4<TSource> {
        (customizer: lodash.AssignCustomizer): LodashAssignWith1x5<TSource>;
        <TObject>(customizer: lodash.__, object: TObject): LodashAssignWith1x6<TObject, TSource>;
        <TObject>(customizer: lodash.AssignCustomizer, object: TObject): TObject & TSource;
    }
    type LodashAssignWith1x5<TSource> = <TObject>(object: TObject) => TObject & TSource;
    type LodashAssignWith1x6<TObject, TSource> = (customizer: lodash.AssignCustomizer) => TObject & TSource;
    interface LodashSet {
        (path: lodash.PropertyPath): LodashSet1x1;
        (path: lodash.__, value: any): LodashSet1x2;
        (path: lodash.PropertyPath, value: any): LodashSet1x3;
        <T extends object>(path: lodash.__, value: lodash.__, object: T): LodashSet1x4<T>;
        <T extends object>(path: lodash.PropertyPath, value: lodash.__, object: T): LodashSet1x5<T>;
        <T extends object>(path: lodash.__, value: any, object: T): LodashSet1x6<T>;
        <T extends object>(path: lodash.PropertyPath, value: any, object: T): T;
        (path: lodash.__, value: lodash.__, object: object): LodashSet2x4;
        (path: lodash.PropertyPath, value: lodash.__, object: object): LodashSet2x5;
        (path: lodash.__, value: any, object: object): LodashSet2x6;
        <TResult>(path: lodash.PropertyPath, value: any, object: object): TResult;
    }
    interface LodashSet1x1 {
        (value: any): LodashSet1x3;
        <T extends object>(value: lodash.__, object: T): LodashSet1x5<T>;
        <T extends object>(value: any, object: T): T;
        (value: lodash.__, object: object): LodashSet2x5;
        <TResult>(value: any, object: object): TResult;
    }
    interface LodashSet1x2 {
        (path: lodash.PropertyPath): LodashSet1x3;
        <T extends object>(path: lodash.__, object: T): LodashSet1x6<T>;
        <T extends object>(path: lodash.PropertyPath, object: T): T;
        (path: lodash.__, object: object): LodashSet2x6;
        <TResult>(path: lodash.PropertyPath, object: object): TResult;
    }
    interface LodashSet1x3 {
        <T extends object>(object: T): T;
        <TResult>(object: object): TResult;
    }
    interface LodashSet1x4<T> {
        (path: lodash.PropertyPath): LodashSet1x5<T>;
        (path: lodash.__, value: any): LodashSet1x6<T>;
        (path: lodash.PropertyPath, value: any): T;
    }
    type LodashSet1x5<T> = (value: any) => T;
    type LodashSet1x6<T> = (path: lodash.PropertyPath) => T;
    interface LodashSet2x4 {
        (path: lodash.PropertyPath): LodashSet2x5;
        (path: lodash.__, value: any): LodashSet2x6;
        <TResult>(path: lodash.PropertyPath, value: any): TResult;
    }
    type LodashSet2x5 = <TResult>(value: any) => TResult;
    type LodashSet2x6 = <TResult>(path: lodash.PropertyPath) => TResult;
    interface LodashAt {
        (props: lodash.PropertyPath): LodashAt1x1;
        <T>(props: lodash.__, object:  lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): LodashAt1x2<T>;
        <T>(props: lodash.PropertyPath, object:  lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): T[];
        <T extends object>(props: lodash.Many<keyof T>): LodashAt2x1<T>;
        <T extends object>(props: lodash.__, object: T | null | undefined): LodashAt2x2<T>;
        <T extends object>(props: lodash.Many<keyof T>, object: T | null | undefined): Array<T[keyof T]>;
    }
    type LodashAt1x1 = <T>(object:  lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined) => T[];
    type LodashAt1x2<T> = (props: lodash.PropertyPath) => T[];
    type LodashAt2x1<T> = (object: T | null | undefined) => Array<T[keyof T]>;
    type LodashAt2x2<T> = (props: lodash.Many<keyof T>) => Array<T[keyof T]>;
    type LodashAttempt = <TResult>(func: (...args: any[]) => TResult) => TResult | Error;
    interface LodashBefore {
        <TFunc extends (...args: any[]) => any>(func: TFunc): LodashBefore1x1<TFunc>;
        (func: lodash.__, n: number): LodashBefore1x2;
        <TFunc extends (...args: any[]) => any>(func: TFunc, n: number): TFunc;
    }
    type LodashBefore1x1<TFunc extends (...args: any[]) => any> = (n: number) => TFunc;
    type LodashBefore1x2 = <TFunc extends (...args: any[]) => any>(func: TFunc) => TFunc;
    interface LodashBind {
        (func: (...args: any[]) => any): LodashBind1x1;
        (func: lodash.__, thisArg: any): LodashBind1x2;
        (func: (...args: any[]) => any, thisArg: any): (...args: any[]) => any;
        placeholder: lodash.__;
    }
    type LodashBind1x1 = (thisArg: any) => (...args: any[]) => any;
    type LodashBind1x2 = (func: (...args: any[]) => any) => (...args: any[]) => any;
    interface LodashBindAll {
        (methodNames: lodash.Many<string>): LodashBindAll1x1;
        <T>(methodNames: lodash.__, object: T): LodashBindAll1x2<T>;
        <T>(methodNames: lodash.Many<string>, object: T): T;
    }
    type LodashBindAll1x1 = <T>(object: T) => T;
    type LodashBindAll1x2<T> = (methodNames: lodash.Many<string>) => T;
    interface LodashBindKey {
        (object: object): LodashBindKey1x1;
        (object: lodash.__, key: string): LodashBindKey1x2;
        (object: object, key: string): (...args: any[]) => any;
        placeholder: lodash.__;
    }
    type LodashBindKey1x1 = (key: string) => (...args: any[]) => any;
    type LodashBindKey1x2 = (object: object) => (...args: any[]) => any;
    type LodashCamelCase = (string: string) => string;
    type LodashCapitalize = (string: string) => string;
    type LodashCastArray = <T>(value: lodash.Many<T>) => T[];
    type LodashCeil = (n: number) => number;
    interface LodashChunk {
        (size: number): LodashChunk1x1;
        <T>(size: lodash.__, array: lodash.List<T> | null | undefined): LodashChunk1x2<T>;
        <T>(size: number, array: lodash.List<T> | null | undefined): T[][];
    }
    type LodashChunk1x1 = <T>(array: lodash.List<T> | null | undefined) => T[][];
    type LodashChunk1x2<T> = (size: number) => T[][];
    interface LodashClamp {
        (lower: number): LodashClamp1x1;
        (lower: lodash.__, upper: number): LodashClamp1x2;
        (lower: number, upper: number): LodashClamp1x3;
        (lower: lodash.__, upper: lodash.__, number: number): LodashClamp1x4;
        (lower: number, upper: lodash.__, number: number): LodashClamp1x5;
        (lower: lodash.__, upper: number, number: number): LodashClamp1x6;
        (lower: number, upper: number, number: number): number;
    }
    interface LodashClamp1x1 {
        (upper: number): LodashClamp1x3;
        (upper: lodash.__, number: number): LodashClamp1x5;
        (upper: number, number: number): number;
    }
    interface LodashClamp1x2 {
        (lower: number): LodashClamp1x3;
        (lower: lodash.__, number: number): LodashClamp1x6;
        (lower: number, number: number): number;
    }
    type LodashClamp1x3 = (number: number) => number;
    interface LodashClamp1x4 {
        (lower: number): LodashClamp1x5;
        (lower: lodash.__, upper: number): LodashClamp1x6;
        (lower: number, upper: number): number;
    }
    type LodashClamp1x5 = (upper: number) => number;
    type LodashClamp1x6 = (lower: number) => number;
    type LodashClone = <T>(value: T) => T;
    type LodashCloneDeep = <T>(value: T) => T;
    interface LodashCloneDeepWith {
        <T>(customizer: lodash.CloneDeepWithCustomizer<T>): LodashCloneDeepWith1x1<T>;
        <T>(customizer: lodash.__, value: T): LodashCloneDeepWith1x2<T>;
        <T>(customizer: lodash.CloneDeepWithCustomizer<T>, value: T): any;
    }
    type LodashCloneDeepWith1x1<T> = (value: T) => any;
    type LodashCloneDeepWith1x2<T> = (customizer: lodash.CloneDeepWithCustomizer<T>) => any;
    interface LodashCloneWith {
        <T, TResult extends object | string | number | boolean | null>(customizer: lodash.CloneWithCustomizer<T, TResult>): LodashCloneWith1x1<T, TResult>;
        <T>(customizer: lodash.__, value: T): LodashCloneWith1x2<T>;
        <T, TResult extends object | string | number | boolean | null>(customizer: lodash.CloneWithCustomizer<T, TResult>, value: T): TResult;
        <T, TResult>(customizer: lodash.CloneWithCustomizer<T, TResult | undefined>): LodashCloneWith2x1<T, TResult>;
        <T, TResult>(customizer: lodash.CloneWithCustomizer<T, TResult | undefined>, value: T): TResult | T;
    }
    type LodashCloneWith1x1<T, TResult> = (value: T) => TResult;
    interface LodashCloneWith1x2<T> {
        <TResult extends object | string | number | boolean | null>(customizer: lodash.CloneWithCustomizer<T, TResult>): TResult;
        <TResult>(customizer: lodash.CloneWithCustomizer<T, TResult | undefined>): TResult | T;
    }
    type LodashCloneWith2x1<T, TResult> = (value: T) => TResult | T;
    type LodashCompact = <T>(array: lodash.List<T> | null | undefined) => Array<Exclude<T, lodash.Falsey>>;
    type LodashNegate = <T extends any[]>(predicate: (...args: T) => any) => (...args: T) => boolean;
    interface LodashFlowRight {
        <A extends any[], R1, R2, R3, R4, R5, R6, R7>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R7;
        <A extends any[], R1, R2, R3, R4, R5, R6>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R6;
        <A extends any[], R1, R2, R3, R4, R5>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R5;
        <A extends any[], R1, R2, R3, R4>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R4;
        <A extends any[], R1, R2, R3>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R3;
        <A extends any[], R1, R2>(f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R2;
        (...func: Array<lodash.Many<(...args: any[]) => any>>): (...args: any[]) => any;
    }
    interface LodashConcat {
        <T>(array: lodash.Many<T>): LodashConcat1x1<T>;
        <T>(array: lodash.__, values: lodash.Many<T>): LodashConcat1x2<T>;
        <T>(array: lodash.Many<T>, values: lodash.Many<T>): T[];
    }
    type LodashConcat1x1<T> = (values: lodash.Many<T>) => T[];
    type LodashConcat1x2<T> = (array: lodash.Many<T>) => T[];
    interface LodashCond {
        <R>(pairs: Array<lodash.CondPairNullary<R>>): () => R;
        <T, R>(pairs: Array<lodash.CondPairUnary<T, R>>): (Target: T) => R;
    }
    interface LodashConformsTo {
        <T>(source: lodash.ConformsPredicateObject<T>): LodashConformsTo1x1<T>;
        <T>(source: lodash.__, object: T): LodashConformsTo1x2<T>;
        <T>(source: lodash.ConformsPredicateObject<T>, object: T): boolean;
    }
    type LodashConformsTo1x1<T> = (object: T) => boolean;
    type LodashConformsTo1x2<T> = (source: lodash.ConformsPredicateObject<T>) => boolean;
    interface LodashContains {
        <T>(target: T): LodashContains1x1<T>;
        <T>(target: lodash.__, collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): LodashContains1x2<T>;
        <T>(target: T, collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): boolean;
    }
    type LodashContains1x1<T> = (collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined) => boolean;
    type LodashContains1x2<T> = (target: T) => boolean;
    interface LodashCountBy {
        <T>(iteratee: lodash.ValueIteratee<T>): LodashCountBy1x1<T>;
        <T>(iteratee: lodash.__, collection: lodash.List<T> | null | undefined): LodashCountBy1x2<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, collection: lodash.List<T> | null | undefined): lodash.Dictionary<number>;
        <T extends object>(iteratee: lodash.__, collection: T | null | undefined): LodashCountBy2x2<T>;
        <T extends object>(iteratee: lodash.ValueIteratee<T[keyof T]>, collection: T | null | undefined): lodash.Dictionary<number>;
    }
    type LodashCountBy1x1<T> = (collection: lodash.List<T> | object | null | undefined) => lodash.Dictionary<number>;
    type LodashCountBy1x2<T> = (iteratee: lodash.ValueIteratee<T>) => lodash.Dictionary<number>;
    type LodashCountBy2x2<T> = (iteratee: lodash.ValueIteratee<T[keyof T]>) => lodash.Dictionary<number>;
    type LodashCreate = <T extends object, U extends object>(prototype: T) => T & U;
    interface LodashCurry {
        <T1, R>(func: (t1: T1) => R): lodash.CurriedFunction1<T1, R>;
        <T1, T2, R>(func: (t1: T1, t2: T2) => R): lodash.CurriedFunction2<T1, T2, R>;
        <T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3) => R): lodash.CurriedFunction3<T1, T2, T3, R>;
        <T1, T2, T3, T4, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4) => R): lodash.CurriedFunction4<T1, T2, T3, T4, R>;
        <T1, T2, T3, T4, T5, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R): lodash.CurriedFunction5<T1, T2, T3, T4, T5, R>;
        (func: (...args: any[]) => any): (...args: any[]) => any;
        placeholder: lodash.__;
    }
    interface LodashCurryN {
        (arity: number): LodashCurryN1x1;
        <T1, R>(arity: lodash.__, func: (t1: T1) => R): LodashCurryN1x2<T1, R>;
        <T1, R>(arity: number, func: (t1: T1) => R): lodash.CurriedFunction1<T1, R>;
        <T1, T2, R>(arity: lodash.__, func: (t1: T1, t2: T2) => R): LodashCurryN2x2<T1, T2, R>;
        <T1, T2, R>(arity: number, func: (t1: T1, t2: T2) => R): lodash.CurriedFunction2<T1, T2, R>;
        <T1, T2, T3, R>(arity: lodash.__, func: (t1: T1, t2: T2, t3: T3) => R): LodashCurryN3x2<T1, T2, T3, R>;
        <T1, T2, T3, R>(arity: number, func: (t1: T1, t2: T2, t3: T3) => R): lodash.CurriedFunction3<T1, T2, T3, R>;
        <T1, T2, T3, T4, R>(arity: lodash.__, func: (t1: T1, t2: T2, t3: T3, t4: T4) => R): LodashCurryN4x2<T1, T2, T3, T4, R>;
        <T1, T2, T3, T4, R>(arity: number, func: (t1: T1, t2: T2, t3: T3, t4: T4) => R): lodash.CurriedFunction4<T1, T2, T3, T4, R>;
        <T1, T2, T3, T4, T5, R>(arity: lodash.__, func: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R): LodashCurryN5x2<T1, T2, T3, T4, T5, R>;
        <T1, T2, T3, T4, T5, R>(arity: number, func: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R): lodash.CurriedFunction5<T1, T2, T3, T4, T5, R>;
        (arity: lodash.__, func: (...args: any[]) => any): LodashCurryN6x2;
        (arity: number, func: (...args: any[]) => any): (...args: any[]) => any;
        placeholder: lodash.__;
    }
    interface LodashCurryN1x1 {
        <T1, R>(func: (t1: T1) => R): lodash.CurriedFunction1<T1, R>;
        <T1, T2, R>(func: (t1: T1, t2: T2) => R): lodash.CurriedFunction2<T1, T2, R>;
        <T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3) => R): lodash.CurriedFunction3<T1, T2, T3, R>;
        <T1, T2, T3, T4, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4) => R): lodash.CurriedFunction4<T1, T2, T3, T4, R>;
        <T1, T2, T3, T4, T5, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R): lodash.CurriedFunction5<T1, T2, T3, T4, T5, R>;
        (func: (...args: any[]) => any): (...args: any[]) => any;
    }
    type LodashCurryN1x2<T1, R> = (arity: number) => lodash.CurriedFunction1<T1, R>;
    type LodashCurryN2x2<T1, T2, R> = (arity: number) => lodash.CurriedFunction2<T1, T2, R>;
    type LodashCurryN3x2<T1, T2, T3, R> = (arity: number) => lodash.CurriedFunction3<T1, T2, T3, R>;
    type LodashCurryN4x2<T1, T2, T3, T4, R> = (arity: number) => lodash.CurriedFunction4<T1, T2, T3, T4, R>;
    type LodashCurryN5x2<T1, T2, T3, T4, T5, R> = (arity: number) => lodash.CurriedFunction5<T1, T2, T3, T4, T5, R>;
    type LodashCurryN6x2 = (arity: number) => (...args: any[]) => any;
    interface LodashCurryRight {
        <T1, R>(func: (t1: T1) => R): lodash.RightCurriedFunction1<T1, R>;
        <T1, T2, R>(func: (t1: T1, t2: T2) => R): lodash.RightCurriedFunction2<T1, T2, R>;
        <T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3) => R): lodash.RightCurriedFunction3<T1, T2, T3, R>;
        <T1, T2, T3, T4, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4) => R): lodash.RightCurriedFunction4<T1, T2, T3, T4, R>;
        <T1, T2, T3, T4, T5, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R): lodash.RightCurriedFunction5<T1, T2, T3, T4, T5, R>;
        (func: (...args: any[]) => any): (...args: any[]) => any;
        placeholder: lodash.__;
    }
    interface LodashCurryRightN {
        (arity: number): LodashCurryRightN1x1;
        <T1, R>(arity: lodash.__, func: (t1: T1) => R): LodashCurryRightN1x2<T1, R>;
        <T1, R>(arity: number, func: (t1: T1) => R): lodash.RightCurriedFunction1<T1, R>;
        <T1, T2, R>(arity: lodash.__, func: (t1: T1, t2: T2) => R): LodashCurryRightN2x2<T1, T2, R>;
        <T1, T2, R>(arity: number, func: (t1: T1, t2: T2) => R): lodash.RightCurriedFunction2<T1, T2, R>;
        <T1, T2, T3, R>(arity: lodash.__, func: (t1: T1, t2: T2, t3: T3) => R): LodashCurryRightN3x2<T1, T2, T3, R>;
        <T1, T2, T3, R>(arity: number, func: (t1: T1, t2: T2, t3: T3) => R): lodash.RightCurriedFunction3<T1, T2, T3, R>;
        <T1, T2, T3, T4, R>(arity: lodash.__, func: (t1: T1, t2: T2, t3: T3, t4: T4) => R): LodashCurryRightN4x2<T1, T2, T3, T4, R>;
        <T1, T2, T3, T4, R>(arity: number, func: (t1: T1, t2: T2, t3: T3, t4: T4) => R): lodash.RightCurriedFunction4<T1, T2, T3, T4, R>;
        <T1, T2, T3, T4, T5, R>(arity: lodash.__, func: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R): LodashCurryRightN5x2<T1, T2, T3, T4, T5, R>;
        <T1, T2, T3, T4, T5, R>(arity: number, func: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R): lodash.RightCurriedFunction5<T1, T2, T3, T4, T5, R>;
        (arity: lodash.__, func: (...args: any[]) => any): LodashCurryRightN6x2;
        (arity: number, func: (...args: any[]) => any): (...args: any[]) => any;
        placeholder: lodash.__;
    }
    interface LodashCurryRightN1x1 {
        <T1, R>(func: (t1: T1) => R): lodash.RightCurriedFunction1<T1, R>;
        <T1, T2, R>(func: (t1: T1, t2: T2) => R): lodash.RightCurriedFunction2<T1, T2, R>;
        <T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3) => R): lodash.RightCurriedFunction3<T1, T2, T3, R>;
        <T1, T2, T3, T4, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4) => R): lodash.RightCurriedFunction4<T1, T2, T3, T4, R>;
        <T1, T2, T3, T4, T5, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R): lodash.RightCurriedFunction5<T1, T2, T3, T4, T5, R>;
        (func: (...args: any[]) => any): (...args: any[]) => any;
    }
    type LodashCurryRightN1x2<T1, R> = (arity: number) => lodash.RightCurriedFunction1<T1, R>;
    type LodashCurryRightN2x2<T1, T2, R> = (arity: number) => lodash.RightCurriedFunction2<T1, T2, R>;
    type LodashCurryRightN3x2<T1, T2, T3, R> = (arity: number) => lodash.RightCurriedFunction3<T1, T2, T3, R>;
    type LodashCurryRightN4x2<T1, T2, T3, T4, R> = (arity: number) => lodash.RightCurriedFunction4<T1, T2, T3, T4, R>;
    type LodashCurryRightN5x2<T1, T2, T3, T4, T5, R> = (arity: number) => lodash.RightCurriedFunction5<T1, T2, T3, T4, T5, R>;
    type LodashCurryRightN6x2 = (arity: number) => (...args: any[]) => any;
    interface LodashDebounce {
        (wait: number): LodashDebounce1x1;
        <T extends (...args: any) => any>(wait: lodash.__, func: T): LodashDebounce1x2<T>;
        <T extends (...args: any) => any>(wait: number, func: T): lodash.DebouncedFunc<T>;
    }
    type LodashDebounce1x1 = <T extends (...args: any) => any>(func: T) => lodash.DebouncedFunc<T>;
    type LodashDebounce1x2<T extends (...args: any) => any> = (wait: number) => lodash.DebouncedFunc<T>;
    type LodashDeburr = (string: string) => string;
    interface LodashDefaults {
        <TSource>(source: TSource): LodashDefaults1x1<TSource>;
        <TObject>(source: lodash.__, object: TObject): LodashDefaults1x2<TObject>;
        <TObject, TSource>(source: TSource, object: TObject): TSource & TObject;
    }
    type LodashDefaults1x1<TSource> = <TObject>(object: TObject) => TSource & TObject;
    type LodashDefaults1x2<TObject> = <TSource>(source: TSource) => TSource & TObject;
    interface LodashDefaultsAll {
        <TObject, TSource>(object: [TObject, TSource]): TSource & TObject;
        <TObject, TSource1, TSource2>(object: [TObject, TSource1, TSource2]): TSource2 & TSource1 & TObject;
        <TObject, TSource1, TSource2, TSource3>(object: [TObject, TSource1, TSource2, TSource3]): TSource3 & TSource2 & TSource1 & TObject;
        <TObject, TSource1, TSource2, TSource3, TSource4>(object: [TObject, TSource1, TSource2, TSource3, TSource4]): TSource4 & TSource3 & TSource2 & TSource1 & TObject;
        <TObject>(object: [TObject]): TObject;
        (object: readonly any[]): any;
    }
    interface LodashDefaultsDeep {
        (sources: any): LodashDefaultsDeep1x1;
        (sources: lodash.__, object: any): LodashDefaultsDeep1x2;
        (sources: any, object: any): any;
    }
    type LodashDefaultsDeep1x1 = (object: any) => any;
    type LodashDefaultsDeep1x2 = (sources: any) => any;
    type LodashDefaultsDeepAll = (object: readonly any[]) => any;
    interface LodashDefaultTo {
        <T>(defaultValue: T): LodashDefaultTo1x1<T>;
        <T>(defaultValue: lodash.__, value: T | null | undefined): LodashDefaultTo1x2<T>;
        <T>(defaultValue: T, value: T | null | undefined): T;
        <TDefault>(defaultValue: TDefault): LodashDefaultTo2x1<TDefault>;
        <T, TDefault>(defaultValue: TDefault, value: T | null | undefined): T | TDefault;
    }
    type LodashDefaultTo1x1<T> = (value: T | null | undefined) => T;
    interface LodashDefaultTo1x2<T> {
        (defaultValue: T): T;
        <TDefault>(defaultValue: TDefault): T | TDefault;
    }
    type LodashDefaultTo2x1<TDefault> = <T>(value: T | null | undefined) => T | TDefault;
    type LodashDefer = (func: (...args: any[]) => any, ...args: any[]) => number;
    interface LodashDelay {
        (wait: number): LodashDelay1x1;
        (wait: lodash.__, func: (...args: any[]) => any): LodashDelay1x2;
        (wait: number, func: (...args: any[]) => any): number;
    }
    type LodashDelay1x1 = (func: (...args: any[]) => any) => number;
    type LodashDelay1x2 = (wait: number) => number;
    interface LodashDifference {
        <T>(array: lodash.List<T> | null | undefined): LodashDifference1x1<T>;
        <T>(array: lodash.__, values: lodash.List<T>): LodashDifference1x2<T>;
        <T>(array: lodash.List<T> | null | undefined, values: lodash.List<T>): T[];
    }
    type LodashDifference1x1<T> = (values: lodash.List<T>) => T[];
    type LodashDifference1x2<T> = (array: lodash.List<T> | null | undefined) => T[];
    interface LodashDifferenceBy {
        <T1, T2>(iteratee: lodash.ValueIteratee<T1 | T2>): LodashDifferenceBy1x1<T1, T2>;
        <T1>(iteratee: lodash.__, array: lodash.List<T1> | null | undefined): LodashDifferenceBy1x2<T1>;
        <T1, T2>(iteratee: lodash.ValueIteratee<T1 | T2>, array: lodash.List<T1> | null | undefined): LodashDifferenceBy1x3<T1, T2>;
        <T2>(iteratee: lodash.__, array: lodash.__, values: lodash.List<T2>): LodashDifferenceBy1x4<T2>;
        <T1, T2>(iteratee: lodash.ValueIteratee<T1 | T2>, array: lodash.__, values: lodash.List<T2>): LodashDifferenceBy1x5<T1>;
        <T1, T2>(iteratee: lodash.__, array: lodash.List<T1> | null | undefined, values: lodash.List<T2>): LodashDifferenceBy1x6<T1, T2>;
        <T1, T2>(iteratee: lodash.ValueIteratee<T1 | T2>, array: lodash.List<T1> | null | undefined, values: lodash.List<T2>): T1[];
    }
    interface LodashDifferenceBy1x1<T1, T2> {
        (array: lodash.List<T1> | null | undefined): LodashDifferenceBy1x3<T1, T2>;
        (array: lodash.__, values: lodash.List<T2>): LodashDifferenceBy1x5<T1>;
        (array: lodash.List<T1> | null | undefined, values: lodash.List<T2>): T1[];
    }
    interface LodashDifferenceBy1x2<T1> {
        <T2>(iteratee: lodash.ValueIteratee<T1 | T2>): LodashDifferenceBy1x3<T1, T2>;
        <T2>(iteratee: lodash.__, values: lodash.List<T2>): LodashDifferenceBy1x6<T1, T2>;
        <T2>(iteratee: lodash.ValueIteratee<T1 | T2>, values: lodash.List<T2>): T1[];
    }
    type LodashDifferenceBy1x3<T1, T2> = (values: lodash.List<T2>) => T1[];
    interface LodashDifferenceBy1x4<T2> {
        <T1>(iteratee: lodash.ValueIteratee<T1 | T2>): LodashDifferenceBy1x5<T1>;
        <T1>(iteratee: lodash.__, array: lodash.List<T1> | null | undefined): LodashDifferenceBy1x6<T1, T2>;
        <T1>(iteratee: lodash.ValueIteratee<T1 | T2>, array: lodash.List<T1> | null | undefined): T1[];
    }
    type LodashDifferenceBy1x5<T1> = (array: lodash.List<T1> | null | undefined) => T1[];
    type LodashDifferenceBy1x6<T1, T2> = (iteratee: lodash.ValueIteratee<T1 | T2>) => T1[];
    interface LodashDifferenceWith {
        <T1, T2>(comparator: lodash.Comparator2<T1, T2>): LodashDifferenceWith1x1<T1, T2>;
        <T1>(comparator: lodash.__, array: lodash.List<T1> | null | undefined): LodashDifferenceWith1x2<T1>;
        <T1, T2>(comparator: lodash.Comparator2<T1, T2>, array: lodash.List<T1> | null | undefined): LodashDifferenceWith1x3<T1, T2>;
        <T2>(comparator: lodash.__, array: lodash.__, values: lodash.List<T2>): LodashDifferenceWith1x4<T2>;
        <T1, T2>(comparator: lodash.Comparator2<T1, T2>, array: lodash.__, values: lodash.List<T2>): LodashDifferenceWith1x5<T1>;
        <T1, T2>(comparator: lodash.__, array: lodash.List<T1> | null | undefined, values: lodash.List<T2>): LodashDifferenceWith1x6<T1, T2>;
        <T1, T2>(comparator: lodash.Comparator2<T1, T2>, array: lodash.List<T1> | null | undefined, values: lodash.List<T2>): T1[];
    }
    interface LodashDifferenceWith1x1<T1, T2> {
        (array: lodash.List<T1> | null | undefined): LodashDifferenceWith1x3<T1, T2>;
        (array: lodash.__, values: lodash.List<T2>): LodashDifferenceWith1x5<T1>;
        (array: lodash.List<T1> | null | undefined, values: lodash.List<T2>): T1[];
    }
    interface LodashDifferenceWith1x2<T1> {
        <T2>(comparator: lodash.Comparator2<T1, T2>): LodashDifferenceWith1x3<T1, T2>;
        <T2>(comparator: lodash.__, values: lodash.List<T2>): LodashDifferenceWith1x6<T1, T2>;
        <T2>(comparator: lodash.Comparator2<T1, T2>, values: lodash.List<T2>): T1[];
    }
    type LodashDifferenceWith1x3<T1, T2> = (values: lodash.List<T2>) => T1[];
    interface LodashDifferenceWith1x4<T2> {
        <T1>(comparator: lodash.Comparator2<T1, T2>): LodashDifferenceWith1x5<T1>;
        <T1>(comparator: lodash.__, array: lodash.List<T1> | null | undefined): LodashDifferenceWith1x6<T1, T2>;
        <T1>(comparator: lodash.Comparator2<T1, T2>, array: lodash.List<T1> | null | undefined): T1[];
    }
    type LodashDifferenceWith1x5<T1> = (array: lodash.List<T1> | null | undefined) => T1[];
    type LodashDifferenceWith1x6<T1, T2> = (comparator: lodash.Comparator2<T1, T2>) => T1[];
    interface LodashUnset {
        (path: lodash.PropertyPath): LodashUnset1x1;
        <T>(path: lodash.__, object: T): LodashUnset1x2<T>;
        <T>(path: lodash.PropertyPath, object: T): T;
    }
    type LodashUnset1x1 = <T>(object: T) => T;
    type LodashUnset1x2<T> = (path: lodash.PropertyPath) => T;
    interface LodashDivide {
        (dividend: number): LodashDivide1x1;
        (dividend: lodash.__, divisor: number): LodashDivide1x2;
        (dividend: number, divisor: number): number;
    }
    type LodashDivide1x1 = (divisor: number) => number;
    type LodashDivide1x2 = (dividend: number) => number;
    interface LodashDrop {
        (n: number): LodashDrop1x1;
        <T>(n: lodash.__, array: lodash.List<T> | null | undefined): LodashDrop1x2<T>;
        <T>(n: number, array: lodash.List<T> | null | undefined): T[];
    }
    type LodashDrop1x1 = <T>(array: lodash.List<T> | null | undefined) => T[];
    type LodashDrop1x2<T> = (n: number) => T[];
    interface LodashDropRight {
        (n: number): LodashDropRight1x1;
        <T>(n: lodash.__, array: lodash.List<T> | null | undefined): LodashDropRight1x2<T>;
        <T>(n: number, array: lodash.List<T> | null | undefined): T[];
    }
    type LodashDropRight1x1 = <T>(array: lodash.List<T> | null | undefined) => T[];
    type LodashDropRight1x2<T> = (n: number) => T[];
    interface LodashDropRightWhile {
        <T>(predicate: lodash.ValueIteratee<T>): LodashDropRightWhile1x1<T>;
        <T>(predicate: lodash.__, array: lodash.List<T> | null | undefined): LodashDropRightWhile1x2<T>;
        <T>(predicate: lodash.ValueIteratee<T>, array: lodash.List<T> | null | undefined): T[];
    }
    type LodashDropRightWhile1x1<T> = (array: lodash.List<T> | null | undefined) => T[];
    type LodashDropRightWhile1x2<T> = (predicate: lodash.ValueIteratee<T>) => T[];
    interface LodashDropWhile {
        <T>(predicate: lodash.ValueIteratee<T>): LodashDropWhile1x1<T>;
        <T>(predicate: lodash.__, array: lodash.List<T> | null | undefined): LodashDropWhile1x2<T>;
        <T>(predicate: lodash.ValueIteratee<T>, array: lodash.List<T> | null | undefined): T[];
    }
    type LodashDropWhile1x1<T> = (array: lodash.List<T> | null | undefined) => T[];
    type LodashDropWhile1x2<T> = (predicate: lodash.ValueIteratee<T>) => T[];
    interface LodashForEach {
        <T>(iteratee: (value: T) => any): LodashForEach1x1<T>;
        <T>(iteratee: lodash.__, collection: readonly T[]): LodashForEach1x2<T>;
        <T>(iteratee: (value: T) => any, collection: readonly T[]): T[];
        <T>(iteratee: lodash.__, collection: lodash.List<T>): LodashForEach2x2<T>;
        <T>(iteratee: (value: T) => any, collection: lodash.List<T>): lodash.List<T>;
        <T extends object>(iteratee: lodash.__, collection: T): LodashForEach3x2<T>;
        <T extends object>(iteratee: (value: T[keyof T]) => any, collection: T): T;
        <T, TArray extends T[] | null | undefined>(iteratee: lodash.__, collection: TArray & (T[] | null | undefined)): LodashForEach4x2<T, TArray>;
        <T, TArray extends T[] | null | undefined>(iteratee: (value: T) => any, collection: TArray & (T[] | null | undefined)): TArray;
        <T, TList extends lodash.List<T> | null | undefined>(iteratee: lodash.__, collection: TList & (lodash.List<T> | null | undefined)): LodashForEach5x2<T, TList>;
        <T, TList extends lodash.List<T> | null | undefined>(iteratee: (value: T) => any, collection: TList & (lodash.List<T> | null | undefined)): TList;
        <T extends object>(iteratee: lodash.__, collection: T | null | undefined): LodashForEach6x2<T>;
        <T extends object>(iteratee: (value: T[keyof T]) => any, collection: T | null | undefined): T | null | undefined;
    }
    interface LodashForEach1x1<T> {
        (collection: readonly T[]): T[];
        (collection: lodash.List<T>): lodash.List<T>;
        <T1 extends object>(collection: T1): T1;
        <TArray extends T[] | null | undefined>(collection: TArray & (T[] | null | undefined)): TArray;
        <TList extends lodash.List<T> | null | undefined>(collection: TList & (lodash.List<T> | null | undefined)): TList;
        <T1 extends object>(collection: T1 | null | undefined): T1 | null | undefined;
    }
    type LodashForEach1x2<T> = (iteratee: (value: T) => any) => T[];
    type LodashForEach2x2<T> = (iteratee: (value: T) => any) => lodash.List<T>;
    type LodashForEach3x2<T> = (iteratee: (value: T[keyof T]) => any) => T;
    type LodashForEach4x2<T, TArray> = (iteratee: (value: T) => any) => TArray;
    type LodashForEach5x2<T, TList> = (iteratee: (value: T) => any) => TList;
    type LodashForEach6x2<T> = (iteratee: (value: T[keyof T]) => any) => T | null | undefined;
    interface LodashForEachRight {
        <T>(iteratee: (value: T) => any): LodashForEachRight1x1<T>;
        <T>(iteratee: lodash.__, collection: readonly T[]): LodashForEachRight1x2<T>;
        <T>(iteratee: (value: T) => any, collection: readonly T[]): T[];
        <T>(iteratee: lodash.__, collection: lodash.List<T>): LodashForEachRight2x2<T>;
        <T>(iteratee: (value: T) => any, collection: lodash.List<T>): lodash.List<T>;
        <T extends object>(iteratee: lodash.__, collection: T): LodashForEachRight3x2<T>;
        <T extends object>(iteratee: (value: T[keyof T]) => any, collection: T): T;
        <T, TArray extends T[] | null | undefined>(iteratee: lodash.__, collection: TArray & (T[] | null | undefined)): LodashForEachRight4x2<T, TArray>;
        <T, TArray extends T[] | null | undefined>(iteratee: (value: T) => any, collection: TArray & (T[] | null | undefined)): TArray;
        <T, TList extends lodash.List<T> | null | undefined>(iteratee: lodash.__, collection: TList & (lodash.List<T> | null | undefined)): LodashForEachRight5x2<T, TList>;
        <T, TList extends lodash.List<T> | null | undefined>(iteratee: (value: T) => any, collection: TList & (lodash.List<T> | null | undefined)): TList;
        <T extends object>(iteratee: lodash.__, collection: T | null | undefined): LodashForEachRight6x2<T>;
        <T extends object>(iteratee: (value: T[keyof T]) => any, collection: T | null | undefined): T | null | undefined;
    }
    interface LodashForEachRight1x1<T> {
        (collection: readonly T[]): T[];
        (collection: lodash.List<T>): lodash.List<T>;
        <T1 extends object>(collection: T1): T1;
        <TArray extends T[] | null | undefined>(collection: TArray & (T[] | null | undefined)): TArray;
        <TList extends lodash.List<T> | null | undefined>(collection: TList & (lodash.List<T> | null | undefined)): TList;
        <T1 extends object>(collection: T1 | null | undefined): T1 | null | undefined;
    }
    type LodashForEachRight1x2<T> = (iteratee: (value: T) => any) => T[];
    type LodashForEachRight2x2<T> = (iteratee: (value: T) => any) => lodash.List<T>;
    type LodashForEachRight3x2<T> = (iteratee: (value: T[keyof T]) => any) => T;
    type LodashForEachRight4x2<T, TArray> = (iteratee: (value: T) => any) => TArray;
    type LodashForEachRight5x2<T, TList> = (iteratee: (value: T) => any) => TList;
    type LodashForEachRight6x2<T> = (iteratee: (value: T[keyof T]) => any) => T | null | undefined;
    interface LodashEndsWith {
        (target: string): LodashEndsWith1x1;
        (target: lodash.__, string: string): LodashEndsWith1x2;
        (target: string, string: string): boolean;
    }
    type LodashEndsWith1x1 = (string: string) => boolean;
    type LodashEndsWith1x2 = (target: string) => boolean;
    interface LodashToPairs {
        <T>(object: lodash.Dictionary<T> | lodash.NumericDictionary<T>): Array<[string, T]>;
        (object: object): Array<[string, any]>;
    }
    interface LodashToPairsIn {
        <T>(object: lodash.Dictionary<T> | lodash.NumericDictionary<T>): Array<[string, T]>;
        (object: object): Array<[string, any]>;
    }
    interface LodashEq {
        (value: any): LodashEq1x1;
        (value: lodash.__, other: any): LodashEq1x2;
        (value: any, other: any): boolean;
    }
    type LodashEq1x1 = (other: any) => boolean;
    type LodashEq1x2 = (value: any) => boolean;
    interface LodashIsEqual {
        (value: any): LodashIsEqual1x1;
        (value: lodash.__, other: any): LodashIsEqual1x2;
        (value: any, other: any): boolean;
    }
    type LodashIsEqual1x1 = (other: any) => boolean;
    type LodashIsEqual1x2 = (value: any) => boolean;
    type LodashEscape = (string: string) => string;
    type LodashEscapeRegExp = (string: string) => string;
    interface LodashExtend {
        <TObject>(object: TObject): LodashExtend1x1<TObject>;
        <TSource>(object: lodash.__, source: TSource): LodashExtend1x2<TSource>;
        <TObject, TSource>(object: TObject, source: TSource): TObject & TSource;
    }
    type LodashExtend1x1<TObject> = <TSource>(source: TSource) => TObject & TSource;
    type LodashExtend1x2<TSource> = <TObject>(object: TObject) => TObject & TSource;
    interface LodashExtendAll {
        <TObject, TSource>(object: [TObject, TSource]): TObject & TSource;
        <TObject, TSource1, TSource2>(object: [TObject, TSource1, TSource2]): TObject & TSource1 & TSource2;
        <TObject, TSource1, TSource2, TSource3>(object: [TObject, TSource1, TSource2, TSource3]): TObject & TSource1 & TSource2 & TSource3;
        <TObject, TSource1, TSource2, TSource3, TSource4>(object: [TObject, TSource1, TSource2, TSource3, TSource4]): TObject & TSource1 & TSource2 & TSource3 & TSource4;
        <TObject>(object: [TObject]): TObject;
        <TResult>(object: readonly any[]): TResult;
    }
    interface LodashExtendAllWith {
        (customizer: lodash.AssignCustomizer): LodashExtendAllWith1x1;
        (customizer: lodash.__, args: readonly any[]): LodashExtendAllWith1x2;
        (customizer: lodash.AssignCustomizer, args: readonly any[]): any;
    }
    type LodashExtendAllWith1x1 = (args: readonly any[]) => any;
    type LodashExtendAllWith1x2 = (customizer: lodash.AssignCustomizer) => any;
    interface LodashExtendWith {
        (customizer: lodash.AssignCustomizer): LodashExtendWith1x1;
        <TObject>(customizer: lodash.__, object: TObject): LodashExtendWith1x2<TObject>;
        <TObject>(customizer: lodash.AssignCustomizer, object: TObject): LodashExtendWith1x3<TObject>;
        <TSource>(customizer: lodash.__, object: lodash.__, source: TSource): LodashExtendWith1x4<TSource>;
        <TSource>(customizer: lodash.AssignCustomizer, object: lodash.__, source: TSource): LodashExtendWith1x5<TSource>;
        <TObject, TSource>(customizer: lodash.__, object: TObject, source: TSource): LodashExtendWith1x6<TObject, TSource>;
        <TObject, TSource>(customizer: lodash.AssignCustomizer, object: TObject, source: TSource): TObject & TSource;
    }
    interface LodashExtendWith1x1 {
        <TObject>(object: TObject): LodashExtendWith1x3<TObject>;
        <TSource>(object: lodash.__, source: TSource): LodashExtendWith1x5<TSource>;
        <TObject, TSource>(object: TObject, source: TSource): TObject & TSource;
    }
    interface LodashExtendWith1x2<TObject> {
        (customizer: lodash.AssignCustomizer): LodashExtendWith1x3<TObject>;
        <TSource>(customizer: lodash.__, source: TSource): LodashExtendWith1x6<TObject, TSource>;
        <TSource>(customizer: lodash.AssignCustomizer, source: TSource): TObject & TSource;
    }
    type LodashExtendWith1x3<TObject> = <TSource>(source: TSource) => TObject & TSource;
    interface LodashExtendWith1x4<TSource> {
        (customizer: lodash.AssignCustomizer): LodashExtendWith1x5<TSource>;
        <TObject>(customizer: lodash.__, object: TObject): LodashExtendWith1x6<TObject, TSource>;
        <TObject>(customizer: lodash.AssignCustomizer, object: TObject): TObject & TSource;
    }
    type LodashExtendWith1x5<TSource> = <TObject>(object: TObject) => TObject & TSource;
    type LodashExtendWith1x6<TObject, TSource> = (customizer: lodash.AssignCustomizer) => TObject & TSource;
    type LodashStubFalse = () => false;
    interface LodashFill {
        (start: number): LodashFill1x1;
        (start: lodash.__, end: number): LodashFill1x2;
        (start: number, end: number): LodashFill1x3;
        <T>(start: lodash.__, end: lodash.__, value: T): LodashFill1x4<T>;
        <T>(start: number, end: lodash.__, value: T): LodashFill1x5<T>;
        <T>(start: lodash.__, end: number, value: T): LodashFill1x6<T>;
        <T>(start: number, end: number, value: T): LodashFill1x7<T>;
        <U>(start: lodash.__, end: lodash.__, value: lodash.__, array: U[] | null | undefined): LodashFill1x8<U>;
        <U>(start: number, end: lodash.__, value: lodash.__, array: U[] | null | undefined): LodashFill1x9<U>;
        <U>(start: lodash.__, end: number, value: lodash.__, array: U[] | null | undefined): LodashFill1x10<U>;
        <U>(start: number, end: number, value: lodash.__, array: U[] | null | undefined): LodashFill1x11<U>;
        <T, U>(start: lodash.__, end: lodash.__, value: T, array: U[] | null | undefined): LodashFill1x12<T, U>;
        <T, U>(start: number, end: lodash.__, value: T, array: U[] | null | undefined): LodashFill1x13<T, U>;
        <T, U>(start: lodash.__, end: number, value: T, array: U[] | null | undefined): LodashFill1x14<T, U>;
        <T, U>(start: number, end: number, value: T, array: U[] | null | undefined): Array<T | U>;
        <U>(start: lodash.__, end: lodash.__, value: lodash.__, array: lodash.List<U> | null | undefined): LodashFill2x8<U>;
        <U>(start: number, end: lodash.__, value: lodash.__, array: lodash.List<U> | null | undefined): LodashFill2x9<U>;
        <U>(start: lodash.__, end: number, value: lodash.__, array: lodash.List<U> | null | undefined): LodashFill2x10<U>;
        <U>(start: number, end: number, value: lodash.__, array: lodash.List<U> | null | undefined): LodashFill2x11<U>;
        <T, U>(start: lodash.__, end: lodash.__, value: T, array: lodash.List<U> | null | undefined): LodashFill2x12<T, U>;
        <T, U>(start: number, end: lodash.__, value: T, array: lodash.List<U> | null | undefined): LodashFill2x13<T, U>;
        <T, U>(start: lodash.__, end: number, value: T, array: lodash.List<U> | null | undefined): LodashFill2x14<T, U>;
        <T, U>(start: number, end: number, value: T, array: lodash.List<U> | null | undefined): lodash.List<T | U>;
    }
    interface LodashFill1x1 {
        (end: number): LodashFill1x3;
        <T>(end: lodash.__, value: T): LodashFill1x5<T>;
        <T>(end: number, value: T): LodashFill1x7<T>;
        <U>(end: lodash.__, value: lodash.__, array: U[] | null | undefined): LodashFill1x9<U>;
        <U>(end: number, value: lodash.__, array: U[] | null | undefined): LodashFill1x11<U>;
        <T, U>(end: lodash.__, value: T, array: U[] | null | undefined): LodashFill1x13<T, U>;
        <T, U>(end: number, value: T, array: U[] | null | undefined): Array<T | U>;
        <U>(end: lodash.__, value: lodash.__, array: lodash.List<U> | null | undefined): LodashFill2x9<U>;
        <U>(end: number, value: lodash.__, array: lodash.List<U> | null | undefined): LodashFill2x11<U>;
        <T, U>(end: lodash.__, value: T, array: lodash.List<U> | null | undefined): LodashFill2x13<T, U>;
        <T, U>(end: number, value: T, array: lodash.List<U> | null | undefined): lodash.List<T | U>;
    }
    interface LodashFill1x2 {
        (start: number): LodashFill1x3;
        <T>(start: lodash.__, value: T): LodashFill1x6<T>;
        <T>(start: number, value: T): LodashFill1x7<T>;
        <U>(start: lodash.__, value: lodash.__, array: U[] | null | undefined): LodashFill1x10<U>;
        <U>(start: number, value: lodash.__, array: U[] | null | undefined): LodashFill1x11<U>;
        <T, U>(start: lodash.__, value: T, array: U[] | null | undefined): LodashFill1x14<T, U>;
        <T, U>(start: number, value: T, array: U[] | null | undefined): Array<T | U>;
        <U>(start: lodash.__, value: lodash.__, array: lodash.List<U> | null | undefined): LodashFill2x10<U>;
        <U>(start: number, value: lodash.__, array: lodash.List<U> | null | undefined): LodashFill2x11<U>;
        <T, U>(start: lodash.__, value: T, array: lodash.List<U> | null | undefined): LodashFill2x14<T, U>;
        <T, U>(start: number, value: T, array: lodash.List<U> | null | undefined): lodash.List<T | U>;
    }
    interface LodashFill1x3 {
        <T>(value: T): LodashFill1x7<T>;
        <U>(value: lodash.__, array: U[] | null | undefined): LodashFill1x11<U>;
        <T, U>(value: T, array: U[] | null | undefined): Array<T | U>;
        <U>(value: lodash.__, array: lodash.List<U> | null | undefined): LodashFill2x11<U>;
        <T, U>(value: T, array: lodash.List<U> | null | undefined): lodash.List<T | U>;
    }
    interface LodashFill1x4<T> {
        (start: number): LodashFill1x5<T>;
        (start: lodash.__, end: number): LodashFill1x6<T>;
        (start: number, end: number): LodashFill1x7<T>;
        <U>(start: lodash.__, end: lodash.__, array: U[] | null | undefined): LodashFill1x12<T, U>;
        <U>(start: number, end: lodash.__, array: U[] | null | undefined): LodashFill1x13<T, U>;
        <U>(start: lodash.__, end: number, array: U[] | null | undefined): LodashFill1x14<T, U>;
        <U>(start: number, end: number, array: U[] | null | undefined): Array<T | U>;
        <U>(start: lodash.__, end: lodash.__, array: lodash.List<U> | null | undefined): LodashFill2x12<T, U>;
        <U>(start: number, end: lodash.__, array: lodash.List<U> | null | undefined): LodashFill2x13<T, U>;
        <U>(start: lodash.__, end: number, array: lodash.List<U> | null | undefined): LodashFill2x14<T, U>;
        <U>(start: number, end: number, array: lodash.List<U> | null | undefined): lodash.List<T | U>;
    }
    interface LodashFill1x5<T> {
        (end: number): LodashFill1x7<T>;
        <U>(end: lodash.__, array: U[] | null | undefined): LodashFill1x13<T, U>;
        <U>(end: number, array: U[] | null | undefined): Array<T | U>;
        <U>(end: lodash.__, array: lodash.List<U> | null | undefined): LodashFill2x13<T, U>;
        <U>(end: number, array: lodash.List<U> | null | undefined): lodash.List<T | U>;
    }
    interface LodashFill1x6<T> {
        (start: number): LodashFill1x7<T>;
        <U>(start: lodash.__, array: U[] | null | undefined): LodashFill1x14<T, U>;
        <U>(start: number, array: U[] | null | undefined): Array<T | U>;
        <U>(start: lodash.__, array: lodash.List<U> | null | undefined): LodashFill2x14<T, U>;
        <U>(start: number, array: lodash.List<U> | null | undefined): lodash.List<T | U>;
    }
    interface LodashFill1x7<T> {
        <U>(array: U[] | null | undefined): Array<T | U>;
        <U>(array: lodash.List<U> | null | undefined): lodash.List<T | U>;
    }
    interface LodashFill1x8<U> {
        (start: number): LodashFill1x9<U>;
        (start: lodash.__, end: number): LodashFill1x10<U>;
        (start: number, end: number): LodashFill1x11<U>;
        <T>(start: lodash.__, end: lodash.__, value: T): LodashFill1x12<T, U>;
        <T>(start: number, end: lodash.__, value: T): LodashFill1x13<T, U>;
        <T>(start: lodash.__, end: number, value: T): LodashFill1x14<T, U>;
        <T>(start: number, end: number, value: T): Array<T | U>;
    }
    interface LodashFill1x9<U> {
        (end: number): LodashFill1x11<U>;
        <T>(end: lodash.__, value: T): LodashFill1x13<T, U>;
        <T>(end: number, value: T): Array<T | U>;
    }
    interface LodashFill1x10<U> {
        (start: number): LodashFill1x11<U>;
        <T>(start: lodash.__, value: T): LodashFill1x14<T, U>;
        <T>(start: number, value: T): Array<T | U>;
    }
    type LodashFill1x11<U> = <T>(value: T) => Array<T | U>;
    interface LodashFill1x12<T, U> {
        (start: number): LodashFill1x13<T, U>;
        (start: lodash.__, end: number): LodashFill1x14<T, U>;
        (start: number, end: number): Array<T | U>;
    }
    type LodashFill1x13<T, U> = (end: number) => Array<T | U>;
    type LodashFill1x14<T, U> = (start: number) => Array<T | U>;
    interface LodashFill2x8<U> {
        (start: number): LodashFill2x9<U>;
        (start: lodash.__, end: number): LodashFill2x10<U>;
        (start: number, end: number): LodashFill2x11<U>;
        <T>(start: lodash.__, end: lodash.__, value: T): LodashFill2x12<T, U>;
        <T>(start: number, end: lodash.__, value: T): LodashFill2x13<T, U>;
        <T>(start: lodash.__, end: number, value: T): LodashFill2x14<T, U>;
        <T>(start: number, end: number, value: T): lodash.List<T | U>;
    }
    interface LodashFill2x9<U> {
        (end: number): LodashFill2x11<U>;
        <T>(end: lodash.__, value: T): LodashFill2x13<T, U>;
        <T>(end: number, value: T): lodash.List<T | U>;
    }
    interface LodashFill2x10<U> {
        (start: number): LodashFill2x11<U>;
        <T>(start: lodash.__, value: T): LodashFill2x14<T, U>;
        <T>(start: number, value: T): lodash.List<T | U>;
    }
    type LodashFill2x11<U> = <T>(value: T) => lodash.List<T | U>;
    interface LodashFill2x12<T, U> {
        (start: number): LodashFill2x13<T, U>;
        (start: lodash.__, end: number): LodashFill2x14<T, U>;
        (start: number, end: number): lodash.List<T | U>;
    }
    type LodashFill2x13<T, U> = (end: number) => lodash.List<T | U>;
    type LodashFill2x14<T, U> = (start: number) => lodash.List<T | U>;
    interface LodashFilter {
        <T, S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>): LodashFilter1x1<T, S>;
        <T>(predicate: lodash.__, collection: lodash.List<T> | null | undefined): LodashFilter1x2<T>;
        <T, S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>, collection: lodash.List<T> | null | undefined): S[];
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>): LodashFilter2x1<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, collection: lodash.List<T> | null | undefined): T[];
        <T extends object, S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>): LodashFilter3x1<T, S>;
        <T extends object>(predicate: lodash.__, collection: T | null | undefined): LodashFilter3x2<T>;
        <T extends object, S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>, collection: T | null | undefined): S[];
        <T extends object>(predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>, collection: T | null | undefined): Array<T[keyof T]>;
    }
    type LodashFilter1x1<T, S> = (collection: lodash.List<T> | null | undefined) => S[];
    interface LodashFilter1x2<T> {
        <S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>): S[];
        (predicate: lodash.ValueIterateeCustom<T, boolean>): T[];
    }
    type LodashFilter2x1<T> = (collection: lodash.List<T> | object | null | undefined) => T[];
    type LodashFilter3x1<T, S> = (collection: T | null | undefined) => S[];
    interface LodashFilter3x2<T> {
        <S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>): S[];
        (predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>): Array<T[keyof T]>;
    }
    interface LodashFind {
        <T, S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>): LodashFind1x1<T, S>;
        <T>(predicate: lodash.__, collection: lodash.List<T> | null | undefined): LodashFind1x2<T>;
        <T, S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>, collection: lodash.List<T> | null | undefined): S|undefined;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>): LodashFind2x1<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, collection: lodash.List<T> | null | undefined): T|undefined;
        <T extends object, S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>): LodashFind3x1<T, S>;
        <T extends object>(predicate: lodash.__, collection: T | null | undefined): LodashFind3x2<T>;
        <T extends object, S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>, collection: T | null | undefined): S|undefined;
        <T extends object>(predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>, collection: T | null | undefined): T[keyof T]|undefined;
    }
    type LodashFind1x1<T, S> = (collection: lodash.List<T> | null | undefined) => S|undefined;
    interface LodashFind1x2<T> {
        <S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>): S|undefined;
        (predicate: lodash.ValueIterateeCustom<T, boolean>): T|undefined;
    }
    type LodashFind2x1<T> = (collection: lodash.List<T> | object | null | undefined) => T|undefined;
    type LodashFind3x1<T, S> = (collection: T | null | undefined) => S|undefined;
    interface LodashFind3x2<T> {
        <S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>): S|undefined;
        (predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>): T[keyof T]|undefined;
    }
    interface LodashFindFrom {
        <T, S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>): LodashFindFrom1x1<T, S>;
        (predicate: lodash.__, fromIndex: number): LodashFindFrom1x2;
        <T, S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>, fromIndex: number): LodashFindFrom1x3<T, S>;
        <T>(predicate: lodash.__, fromIndex: lodash.__, collection: lodash.List<T> | null | undefined): LodashFindFrom1x4<T>;
        <T, S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>, fromIndex: lodash.__, collection: lodash.List<T> | null | undefined): LodashFindFrom1x5<S>;
        <T>(predicate: lodash.__, fromIndex: number, collection: lodash.List<T> | null | undefined): LodashFindFrom1x6<T>;
        <T, S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>, fromIndex: number, collection: lodash.List<T> | null | undefined): S|undefined;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>): LodashFindFrom2x1<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, fromIndex: number): LodashFindFrom2x3<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, fromIndex: lodash.__, collection: lodash.List<T> | null | undefined): LodashFindFrom2x5<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, fromIndex: number, collection: lodash.List<T> | null | undefined): T|undefined;
        <T extends object, S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>): LodashFindFrom3x1<T, S>;
        <T extends object, S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>, fromIndex: number): LodashFindFrom3x3<T, S>;
        <T extends object>(predicate: lodash.__, fromIndex: lodash.__, collection: T | null | undefined): LodashFindFrom3x4<T>;
        <T extends object, S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>, fromIndex: lodash.__, collection: T | null | undefined): LodashFindFrom3x5<S>;
        <T extends object>(predicate: lodash.__, fromIndex: number, collection: T | null | undefined): LodashFindFrom3x6<T>;
        <T extends object, S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>, fromIndex: number, collection: T | null | undefined): S|undefined;
        <T extends object>(predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>, fromIndex: lodash.__, collection: T | null | undefined): LodashFindFrom4x5<T>;
        <T extends object>(predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>, fromIndex: number, collection: T | null | undefined): T[keyof T]|undefined;
    }
    interface LodashFindFrom1x1<T, S> {
        (fromIndex: number): LodashFindFrom1x3<T, S>;
        (fromIndex: lodash.__, collection: lodash.List<T> | null | undefined): LodashFindFrom1x5<S>;
        (fromIndex: number, collection: lodash.List<T> | null | undefined): S|undefined;
    }
    interface LodashFindFrom1x2 {
        <T, S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>): LodashFindFrom1x3<T, S>;
        <T>(predicate: lodash.__, collection: lodash.List<T> | null | undefined): LodashFindFrom1x6<T>;
        <T, S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>, collection: lodash.List<T> | null | undefined): S|undefined;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>): LodashFindFrom2x3<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, collection: lodash.List<T> | null | undefined): T|undefined;
        <T extends object, S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>): LodashFindFrom3x3<T, S>;
        <T extends object>(predicate: lodash.__, collection: T | null | undefined): LodashFindFrom3x6<T>;
        <T extends object, S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>, collection: T | null | undefined): S|undefined;
        <T extends object>(predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>, collection: T | null | undefined): T[keyof T]|undefined;
    }
    type LodashFindFrom1x3<T, S> = (collection: lodash.List<T> | null | undefined) => S|undefined;
    interface LodashFindFrom1x4<T> {
        <S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>): LodashFindFrom1x5<S>;
        (predicate: lodash.__, fromIndex: number): LodashFindFrom1x6<T>;
        <S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>, fromIndex: number): S|undefined;
        (predicate: lodash.ValueIterateeCustom<T, boolean>): LodashFindFrom2x5<T>;
        (predicate: lodash.ValueIterateeCustom<T, boolean>, fromIndex: number): T|undefined;
    }
    type LodashFindFrom1x5<S> = (fromIndex: number) => S|undefined;
    interface LodashFindFrom1x6<T> {
        <S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>): S|undefined;
        (predicate: lodash.ValueIterateeCustom<T, boolean>): T|undefined;
    }
    interface LodashFindFrom2x1<T> {
        (fromIndex: number): LodashFindFrom2x3<T>;
        (fromIndex: lodash.__, collection: lodash.List<T> | null | undefined): LodashFindFrom2x5<T>;
        (fromIndex: number, collection: lodash.List<T> | object | null | undefined): T|undefined;
        <T1 extends object>(fromIndex: lodash.__, collection: T1 | null | undefined): LodashFindFrom4x5<T>;
    }
    interface LodashFindFrom2x3<T> {
        (collection: lodash.List<T> | null | undefined): T|undefined;
        (collection: object | null | undefined): object|undefined;
    }
    type LodashFindFrom2x5<T> = (fromIndex: number) => T|undefined;
    interface LodashFindFrom3x1<T, S> {
        (fromIndex: number): LodashFindFrom3x3<T, S>;
        (fromIndex: lodash.__, collection: T | null | undefined): LodashFindFrom3x5<S>;
        (fromIndex: number, collection: T | null | undefined): S|undefined;
    }
    type LodashFindFrom3x3<T, S> = (collection: T | null | undefined) => S|undefined;
    interface LodashFindFrom3x4<T> {
        <S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>): LodashFindFrom3x5<S>;
        (predicate: lodash.__, fromIndex: number): LodashFindFrom3x6<T>;
        <S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>, fromIndex: number): S|undefined;
        (predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>): LodashFindFrom4x5<T>;
        (predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>, fromIndex: number): T[keyof T]|undefined;
    }
    type LodashFindFrom3x5<S> = (fromIndex: number) => S|undefined;
    interface LodashFindFrom3x6<T> {
        <S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>): S|undefined;
        (predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>): T[keyof T]|undefined;
    }
    type LodashFindFrom4x5<T> = (fromIndex: number) => T[keyof T]|undefined;
    interface LodashFindIndex {
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>): LodashFindIndex1x1<T>;
        <T>(predicate: lodash.__, array: lodash.List<T> | null | undefined): LodashFindIndex1x2<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, array: lodash.List<T> | null | undefined): number;
    }
    type LodashFindIndex1x1<T> = (array: lodash.List<T> | null | undefined) => number;
    type LodashFindIndex1x2<T> = (predicate: lodash.ValueIterateeCustom<T, boolean>) => number;
    interface LodashFindIndexFrom {
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>): LodashFindIndexFrom1x1<T>;
        (predicate: lodash.__, fromIndex: number): LodashFindIndexFrom1x2;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, fromIndex: number): LodashFindIndexFrom1x3<T>;
        <T>(predicate: lodash.__, fromIndex: lodash.__, array: lodash.List<T> | null | undefined): LodashFindIndexFrom1x4<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, fromIndex: lodash.__, array: lodash.List<T> | null | undefined): LodashFindIndexFrom1x5;
        <T>(predicate: lodash.__, fromIndex: number, array: lodash.List<T> | null | undefined): LodashFindIndexFrom1x6<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, fromIndex: number, array: lodash.List<T> | null | undefined): number;
    }
    interface LodashFindIndexFrom1x1<T> {
        (fromIndex: number): LodashFindIndexFrom1x3<T>;
        (fromIndex: lodash.__, array: lodash.List<T> | null | undefined): LodashFindIndexFrom1x5;
        (fromIndex: number, array: lodash.List<T> | null | undefined): number;
    }
    interface LodashFindIndexFrom1x2 {
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>): LodashFindIndexFrom1x3<T>;
        <T>(predicate: lodash.__, array: lodash.List<T> | null | undefined): LodashFindIndexFrom1x6<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, array: lodash.List<T> | null | undefined): number;
    }
    type LodashFindIndexFrom1x3<T> = (array: lodash.List<T> | null | undefined) => number;
    interface LodashFindIndexFrom1x4<T> {
        (predicate: lodash.ValueIterateeCustom<T, boolean>): LodashFindIndexFrom1x5;
        (predicate: lodash.__, fromIndex: number): LodashFindIndexFrom1x6<T>;
        (predicate: lodash.ValueIterateeCustom<T, boolean>, fromIndex: number): number;
    }
    type LodashFindIndexFrom1x5 = (fromIndex: number) => number;
    type LodashFindIndexFrom1x6<T> = (predicate: lodash.ValueIterateeCustom<T, boolean>) => number;
    interface LodashFindKey {
        <T>(predicate: lodash.ValueIteratee<T>): LodashFindKey1x1<T>;
        <T>(predicate: lodash.__, object: T | null | undefined): LodashFindKey1x2<T>;
        <T>(predicate: lodash.ValueIteratee<T[keyof T]>, object: T | null | undefined): string | undefined;
    }
    type LodashFindKey1x1<T> = (object: object | null | undefined) => string | undefined;
    type LodashFindKey1x2<T> = (predicate: lodash.ValueIteratee<T[keyof T]>) => string | undefined;
    interface LodashFindLast {
        <T, S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>): LodashFindLast1x1<T, S>;
        <T>(predicate: lodash.__, collection: lodash.List<T> | null | undefined): LodashFindLast1x2<T>;
        <T, S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>, collection: lodash.List<T> | null | undefined): S|undefined;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>): LodashFindLast2x1<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, collection: lodash.List<T> | null | undefined): T|undefined;
        <T extends object, S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>): LodashFindLast3x1<T, S>;
        <T extends object>(predicate: lodash.__, collection: T | null | undefined): LodashFindLast3x2<T>;
        <T extends object, S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>, collection: T | null | undefined): S|undefined;
        <T extends object>(predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>, collection: T | null | undefined): T[keyof T]|undefined;
    }
    type LodashFindLast1x1<T, S> = (collection: lodash.List<T> | null | undefined) => S|undefined;
    interface LodashFindLast1x2<T> {
        <S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>): S|undefined;
        (predicate: lodash.ValueIterateeCustom<T, boolean>): T|undefined;
    }
    type LodashFindLast2x1<T> = (collection: lodash.List<T> | object | null | undefined) => T|undefined;
    type LodashFindLast3x1<T, S> = (collection: T | null | undefined) => S|undefined;
    interface LodashFindLast3x2<T> {
        <S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>): S|undefined;
        (predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>): T[keyof T]|undefined;
    }
    interface LodashFindLastFrom {
        <T, S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>): LodashFindLastFrom1x1<T, S>;
        (predicate: lodash.__, fromIndex: number): LodashFindLastFrom1x2;
        <T, S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>, fromIndex: number): LodashFindLastFrom1x3<T, S>;
        <T>(predicate: lodash.__, fromIndex: lodash.__, collection: lodash.List<T> | null | undefined): LodashFindLastFrom1x4<T>;
        <T, S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>, fromIndex: lodash.__, collection: lodash.List<T> | null | undefined): LodashFindLastFrom1x5<S>;
        <T>(predicate: lodash.__, fromIndex: number, collection: lodash.List<T> | null | undefined): LodashFindLastFrom1x6<T>;
        <T, S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>, fromIndex: number, collection: lodash.List<T> | null | undefined): S|undefined;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>): LodashFindLastFrom2x1<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, fromIndex: number): LodashFindLastFrom2x3<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, fromIndex: lodash.__, collection: lodash.List<T> | null | undefined): LodashFindLastFrom2x5<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, fromIndex: number, collection: lodash.List<T> | null | undefined): T|undefined;
        <T extends object, S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>): LodashFindLastFrom3x1<T, S>;
        <T extends object, S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>, fromIndex: number): LodashFindLastFrom3x3<T, S>;
        <T extends object>(predicate: lodash.__, fromIndex: lodash.__, collection: T | null | undefined): LodashFindLastFrom3x4<T>;
        <T extends object, S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>, fromIndex: lodash.__, collection: T | null | undefined): LodashFindLastFrom3x5<S>;
        <T extends object>(predicate: lodash.__, fromIndex: number, collection: T | null | undefined): LodashFindLastFrom3x6<T>;
        <T extends object, S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>, fromIndex: number, collection: T | null | undefined): S|undefined;
        <T extends object>(predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>, fromIndex: lodash.__, collection: T | null | undefined): LodashFindLastFrom4x5<T>;
        <T extends object>(predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>, fromIndex: number, collection: T | null | undefined): T[keyof T]|undefined;
    }
    interface LodashFindLastFrom1x1<T, S> {
        (fromIndex: number): LodashFindLastFrom1x3<T, S>;
        (fromIndex: lodash.__, collection: lodash.List<T> | null | undefined): LodashFindLastFrom1x5<S>;
        (fromIndex: number, collection: lodash.List<T> | null | undefined): S|undefined;
    }
    interface LodashFindLastFrom1x2 {
        <T, S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>): LodashFindLastFrom1x3<T, S>;
        <T>(predicate: lodash.__, collection: lodash.List<T> | null | undefined): LodashFindLastFrom1x6<T>;
        <T, S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>, collection: lodash.List<T> | null | undefined): S|undefined;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>): LodashFindLastFrom2x3<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, collection: lodash.List<T> | null | undefined): T|undefined;
        <T extends object, S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>): LodashFindLastFrom3x3<T, S>;
        <T extends object>(predicate: lodash.__, collection: T | null | undefined): LodashFindLastFrom3x6<T>;
        <T extends object, S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>, collection: T | null | undefined): S|undefined;
        <T extends object>(predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>, collection: T | null | undefined): T[keyof T]|undefined;
    }
    type LodashFindLastFrom1x3<T, S> = (collection: lodash.List<T> | null | undefined) => S|undefined;
    interface LodashFindLastFrom1x4<T> {
        <S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>): LodashFindLastFrom1x5<S>;
        (predicate: lodash.__, fromIndex: number): LodashFindLastFrom1x6<T>;
        <S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>, fromIndex: number): S|undefined;
        (predicate: lodash.ValueIterateeCustom<T, boolean>): LodashFindLastFrom2x5<T>;
        (predicate: lodash.ValueIterateeCustom<T, boolean>, fromIndex: number): T|undefined;
    }
    type LodashFindLastFrom1x5<S> = (fromIndex: number) => S|undefined;
    interface LodashFindLastFrom1x6<T> {
        <S extends T>(predicate: lodash.ValueIteratorTypeGuard<T, S>): S|undefined;
        (predicate: lodash.ValueIterateeCustom<T, boolean>): T|undefined;
    }
    interface LodashFindLastFrom2x1<T> {
        (fromIndex: number): LodashFindLastFrom2x3<T>;
        (fromIndex: lodash.__, collection: lodash.List<T> | null | undefined): LodashFindLastFrom2x5<T>;
        (fromIndex: number, collection: lodash.List<T> | object | null | undefined): T|undefined;
        <T1 extends object>(fromIndex: lodash.__, collection: T1 | null | undefined): LodashFindLastFrom4x5<T>;
    }
    interface LodashFindLastFrom2x3<T> {
        (collection: lodash.List<T> | null | undefined): T|undefined;
        (collection: object | null | undefined): object|undefined;
    }
    type LodashFindLastFrom2x5<T> = (fromIndex: number) => T|undefined;
    interface LodashFindLastFrom3x1<T, S> {
        (fromIndex: number): LodashFindLastFrom3x3<T, S>;
        (fromIndex: lodash.__, collection: T | null | undefined): LodashFindLastFrom3x5<S>;
        (fromIndex: number, collection: T | null | undefined): S|undefined;
    }
    type LodashFindLastFrom3x3<T, S> = (collection: T | null | undefined) => S|undefined;
    interface LodashFindLastFrom3x4<T> {
        <S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>): LodashFindLastFrom3x5<S>;
        (predicate: lodash.__, fromIndex: number): LodashFindLastFrom3x6<T>;
        <S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>, fromIndex: number): S|undefined;
        (predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>): LodashFindLastFrom4x5<T>;
        (predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>, fromIndex: number): T[keyof T]|undefined;
    }
    type LodashFindLastFrom3x5<S> = (fromIndex: number) => S|undefined;
    interface LodashFindLastFrom3x6<T> {
        <S extends T[keyof T]>(predicate: lodash.ValueIteratorTypeGuard<T[keyof T], S>): S|undefined;
        (predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>): T[keyof T]|undefined;
    }
    type LodashFindLastFrom4x5<T> = (fromIndex: number) => T[keyof T]|undefined;
    interface LodashFindLastIndex {
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>): LodashFindLastIndex1x1<T>;
        <T>(predicate: lodash.__, array: lodash.List<T> | null | undefined): LodashFindLastIndex1x2<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, array: lodash.List<T> | null | undefined): number;
    }
    type LodashFindLastIndex1x1<T> = (array: lodash.List<T> | null | undefined) => number;
    type LodashFindLastIndex1x2<T> = (predicate: lodash.ValueIterateeCustom<T, boolean>) => number;
    interface LodashFindLastIndexFrom {
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>): LodashFindLastIndexFrom1x1<T>;
        (predicate: lodash.__, fromIndex: number): LodashFindLastIndexFrom1x2;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, fromIndex: number): LodashFindLastIndexFrom1x3<T>;
        <T>(predicate: lodash.__, fromIndex: lodash.__, array: lodash.List<T> | null | undefined): LodashFindLastIndexFrom1x4<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, fromIndex: lodash.__, array: lodash.List<T> | null | undefined): LodashFindLastIndexFrom1x5;
        <T>(predicate: lodash.__, fromIndex: number, array: lodash.List<T> | null | undefined): LodashFindLastIndexFrom1x6<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, fromIndex: number, array: lodash.List<T> | null | undefined): number;
    }
    interface LodashFindLastIndexFrom1x1<T> {
        (fromIndex: number): LodashFindLastIndexFrom1x3<T>;
        (fromIndex: lodash.__, array: lodash.List<T> | null | undefined): LodashFindLastIndexFrom1x5;
        (fromIndex: number, array: lodash.List<T> | null | undefined): number;
    }
    interface LodashFindLastIndexFrom1x2 {
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>): LodashFindLastIndexFrom1x3<T>;
        <T>(predicate: lodash.__, array: lodash.List<T> | null | undefined): LodashFindLastIndexFrom1x6<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, array: lodash.List<T> | null | undefined): number;
    }
    type LodashFindLastIndexFrom1x3<T> = (array: lodash.List<T> | null | undefined) => number;
    interface LodashFindLastIndexFrom1x4<T> {
        (predicate: lodash.ValueIterateeCustom<T, boolean>): LodashFindLastIndexFrom1x5;
        (predicate: lodash.__, fromIndex: number): LodashFindLastIndexFrom1x6<T>;
        (predicate: lodash.ValueIterateeCustom<T, boolean>, fromIndex: number): number;
    }
    type LodashFindLastIndexFrom1x5 = (fromIndex: number) => number;
    type LodashFindLastIndexFrom1x6<T> = (predicate: lodash.ValueIterateeCustom<T, boolean>) => number;
    interface LodashFindLastKey {
        <T>(predicate: lodash.ValueIteratee<T>): LodashFindLastKey1x1<T>;
        <T>(predicate: lodash.__, object: T | null | undefined): LodashFindLastKey1x2<T>;
        <T>(predicate: lodash.ValueIteratee<T[keyof T]>, object: T | null | undefined): string | undefined;
    }
    type LodashFindLastKey1x1<T> = (object: object | null | undefined) => string | undefined;
    type LodashFindLastKey1x2<T> = (predicate: lodash.ValueIteratee<T[keyof T]>) => string | undefined;
    type LodashHead = <T>(array: lodash.List<T> | null | undefined) => T | undefined;
    interface LodashFlatMap {
        <T, TResult>(iteratee: (value: T) => lodash.Many<TResult>): LodashFlatMap1x1<T, TResult>;
        <T>(iteratee: lodash.__, collection: lodash.List<T> | null | undefined): LodashFlatMap1x2<T>;
        <T, TResult>(iteratee: (value: T) => lodash.Many<TResult>, collection: lodash.List<T> | null | undefined): TResult[];
        <T extends object, TResult>(iteratee: (value: T[keyof T]) => lodash.Many<TResult>): LodashFlatMap2x1<T, TResult>;
        <T extends object>(iteratee: lodash.__, collection: T | null | undefined): LodashFlatMap2x2<T>;
        <T extends object, TResult>(iteratee: (value: T[keyof T]) => lodash.Many<TResult>, collection: T | null | undefined): TResult[];
        (iteratee: string): LodashFlatMap3x1;
        (iteratee: lodash.__, collection: object | null | undefined): LodashFlatMap3x2;
        (iteratee: string, collection: object | null | undefined): any[];
        (iteratee: object): LodashFlatMap4x1;
        (iteratee: object, collection: object | null | undefined): boolean[];
    }
    type LodashFlatMap1x1<T, TResult> = (collection: lodash.List<T> | null | undefined) => TResult[];
    type LodashFlatMap1x2<T> = <TResult>(iteratee: (value: T) => lodash.Many<TResult>) => TResult[];
    type LodashFlatMap2x1<T, TResult> = (collection: T | null | undefined) => TResult[];
    type LodashFlatMap2x2<T> = <TResult>(iteratee: (value: T[keyof T]) => lodash.Many<TResult>) => TResult[];
    type LodashFlatMap3x1 = (collection: object | null | undefined) => any[];
    interface LodashFlatMap3x2 {
        (iteratee: string): any[];
        (iteratee: object): boolean[];
    }
    type LodashFlatMap4x1 = (collection: object | null | undefined) => boolean[];
    interface LodashFlatMapDeep {
        <T, TResult>(iteratee: (value: T) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult): LodashFlatMapDeep1x1<T, TResult>;
        <T>(iteratee: lodash.__, collection: lodash.List<T> | null | undefined): LodashFlatMapDeep1x2<T>;
        <T, TResult>(iteratee: (value: T) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult, collection: lodash.List<T> | null | undefined): TResult[];
        <T extends object, TResult>(iteratee: (value: T[keyof T]) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult): LodashFlatMapDeep2x1<T, TResult>;
        <T extends object>(iteratee: lodash.__, collection: T | null | undefined): LodashFlatMapDeep2x2<T>;
        <T extends object, TResult>(iteratee: (value: T[keyof T]) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult, collection: T | null | undefined): TResult[];
        (iteratee: string): LodashFlatMapDeep3x1;
        (iteratee: lodash.__, collection: object | null | undefined): LodashFlatMapDeep3x2;
        (iteratee: string, collection: object | null | undefined): any[];
        (iteratee: object): LodashFlatMapDeep4x1;
        (iteratee: object, collection: object | null | undefined): boolean[];
    }
    type LodashFlatMapDeep1x1<T, TResult> = (collection: lodash.List<T> | null | undefined) => TResult[];
    type LodashFlatMapDeep1x2<T> = <TResult>(iteratee: (value: T) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult) => TResult[];
    type LodashFlatMapDeep2x1<T, TResult> = (collection: T | null | undefined) => TResult[];
    type LodashFlatMapDeep2x2<T> = <TResult>(iteratee: (value: T[keyof T]) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult) => TResult[];
    type LodashFlatMapDeep3x1 = (collection: object | null | undefined) => any[];
    interface LodashFlatMapDeep3x2 {
        (iteratee: string): any[];
        (iteratee: object): boolean[];
    }
    type LodashFlatMapDeep4x1 = (collection: object | null | undefined) => boolean[];
    interface LodashFlatMapDepth {
        <T, TResult>(iteratee: (value: T) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult): LodashFlatMapDepth1x1<T, TResult>;
        (iteratee: lodash.__, depth: number): LodashFlatMapDepth1x2;
        <T, TResult>(iteratee: (value: T) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult, depth: number): LodashFlatMapDepth1x3<T, TResult>;
        <T>(iteratee: lodash.__, depth: lodash.__, collection: lodash.List<T> | null | undefined): LodashFlatMapDepth1x4<T>;
        <T, TResult>(iteratee: (value: T) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult, depth: lodash.__, collection: lodash.List<T> | null | undefined): LodashFlatMapDepth1x5<TResult>;
        <T>(iteratee: lodash.__, depth: number, collection: lodash.List<T> | null | undefined): LodashFlatMapDepth1x6<T>;
        <T, TResult>(iteratee: (value: T) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult, depth: number, collection: lodash.List<T> | null | undefined): TResult[];
        <T extends object, TResult>(iteratee: (value: T[keyof T]) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult): LodashFlatMapDepth2x1<T, TResult>;
        <T extends object, TResult>(iteratee: (value: T[keyof T]) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult, depth: number): LodashFlatMapDepth2x3<T, TResult>;
        <T extends object>(iteratee: lodash.__, depth: lodash.__, collection: T | null | undefined): LodashFlatMapDepth2x4<T>;
        <T extends object, TResult>(iteratee: (value: T[keyof T]) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult, depth: lodash.__, collection: T | null | undefined): LodashFlatMapDepth2x5<TResult>;
        <T extends object>(iteratee: lodash.__, depth: number, collection: T | null | undefined): LodashFlatMapDepth2x6<T>;
        <T extends object, TResult>(iteratee: (value: T[keyof T]) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult, depth: number, collection: T | null | undefined): TResult[];
        (iteratee: string): LodashFlatMapDepth3x1;
        (iteratee: string, depth: number): LodashFlatMapDepth3x3;
        (iteratee: lodash.__, depth: lodash.__, collection: object | null | undefined): LodashFlatMapDepth3x4;
        (iteratee: string, depth: lodash.__, collection: object | null | undefined): LodashFlatMapDepth3x5;
        (iteratee: lodash.__, depth: number, collection: object | null | undefined): LodashFlatMapDepth3x6;
        (iteratee: string, depth: number, collection: object | null | undefined): any[];
        (iteratee: object): LodashFlatMapDepth4x1;
        (iteratee: object, depth: number): LodashFlatMapDepth4x3;
        (iteratee: object, depth: lodash.__, collection: object | null | undefined): LodashFlatMapDepth4x5;
        (iteratee: object, depth: number, collection: object | null | undefined): boolean[];
    }
    interface LodashFlatMapDepth1x1<T, TResult> {
        (depth: number): LodashFlatMapDepth1x3<T, TResult>;
        (depth: lodash.__, collection: lodash.List<T> | null | undefined): LodashFlatMapDepth1x5<TResult>;
        (depth: number, collection: lodash.List<T> | null | undefined): TResult[];
    }
    interface LodashFlatMapDepth1x2 {
        <T, TResult>(iteratee: (value: T) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult): LodashFlatMapDepth1x3<T, TResult>;
        <T>(iteratee: lodash.__, collection: lodash.List<T> | null | undefined): LodashFlatMapDepth1x6<T>;
        <T, TResult>(iteratee: (value: T) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult, collection: lodash.List<T> | null | undefined): TResult[];
        <T extends object, TResult>(iteratee: (value: T[keyof T]) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult): LodashFlatMapDepth2x3<T, TResult>;
        <T extends object>(iteratee: lodash.__, collection: T | null | undefined): LodashFlatMapDepth2x6<T>;
        <T extends object, TResult>(iteratee: (value: T[keyof T]) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult, collection: T | null | undefined): TResult[];
        (iteratee: string): LodashFlatMapDepth3x3;
        (iteratee: lodash.__, collection: object | null | undefined): LodashFlatMapDepth3x6;
        (iteratee: string, collection: object | null | undefined): any[];
        (iteratee: object): LodashFlatMapDepth4x3;
        (iteratee: object, collection: object | null | undefined): boolean[];
    }
    type LodashFlatMapDepth1x3<T, TResult> = (collection: lodash.List<T> | null | undefined) => TResult[];
    interface LodashFlatMapDepth1x4<T> {
        <TResult>(iteratee: (value: T) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult): LodashFlatMapDepth1x5<TResult>;
        (iteratee: lodash.__, depth: number): LodashFlatMapDepth1x6<T>;
        <TResult>(iteratee: (value: T) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult, depth: number): TResult[];
    }
    type LodashFlatMapDepth1x5<TResult> = (depth: number) => TResult[];
    type LodashFlatMapDepth1x6<T> = <TResult>(iteratee: (value: T) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult) => TResult[];
    interface LodashFlatMapDepth2x1<T, TResult> {
        (depth: number): LodashFlatMapDepth2x3<T, TResult>;
        (depth: lodash.__, collection: T | null | undefined): LodashFlatMapDepth2x5<TResult>;
        (depth: number, collection: T | null | undefined): TResult[];
    }
    type LodashFlatMapDepth2x3<T, TResult> = (collection: T | null | undefined) => TResult[];
    interface LodashFlatMapDepth2x4<T> {
        <TResult>(iteratee: (value: T[keyof T]) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult): LodashFlatMapDepth2x5<TResult>;
        (iteratee: lodash.__, depth: number): LodashFlatMapDepth2x6<T>;
        <TResult>(iteratee: (value: T[keyof T]) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult, depth: number): TResult[];
    }
    type LodashFlatMapDepth2x5<TResult> = (depth: number) => TResult[];
    type LodashFlatMapDepth2x6<T> = <TResult>(iteratee: (value: T[keyof T]) => lodash.ListOfRecursiveArraysOrValues<TResult> | TResult) => TResult[];
    interface LodashFlatMapDepth3x1 {
        (depth: number): LodashFlatMapDepth3x3;
        (depth: lodash.__, collection: object | null | undefined): LodashFlatMapDepth3x5;
        (depth: number, collection: object | null | undefined): any[];
    }
    type LodashFlatMapDepth3x3 = (collection: object | null | undefined) => any[];
    interface LodashFlatMapDepth3x4 {
        (iteratee: string): LodashFlatMapDepth3x5;
        (iteratee: lodash.__, depth: number): LodashFlatMapDepth3x6;
        (iteratee: string, depth: number): any[];
        (iteratee: object): LodashFlatMapDepth4x5;
        (iteratee: object, depth: number): boolean[];
    }
    type LodashFlatMapDepth3x5 = (depth: number) => any[];
    interface LodashFlatMapDepth3x6 {
        (iteratee: string): any[];
        (iteratee: object): boolean[];
    }
    interface LodashFlatMapDepth4x1 {
        (depth: number): LodashFlatMapDepth4x3;
        (depth: lodash.__, collection: object | null | undefined): LodashFlatMapDepth4x5;
        (depth: number, collection: object | null | undefined): boolean[];
    }
    type LodashFlatMapDepth4x3 = (collection: object | null | undefined) => boolean[];
    type LodashFlatMapDepth4x5 = (depth: number) => boolean[];
    type LodashFlatten = <T>(array: lodash.List<lodash.Many<T>> | null | undefined) => T[];
    type LodashFlattenDeep = <T>(array: lodash.ListOfRecursiveArraysOrValues<T> | null | undefined) => T[];
    interface LodashFlattenDepth {
        (depth: number): LodashFlattenDepth1x1;
        <T>(depth: lodash.__, array: lodash.ListOfRecursiveArraysOrValues<T> | null | undefined): LodashFlattenDepth1x2<T>;
        <T>(depth: number, array: lodash.ListOfRecursiveArraysOrValues<T> | null | undefined): T[];
    }
    type LodashFlattenDepth1x1 = <T>(array: lodash.ListOfRecursiveArraysOrValues<T> | null | undefined) => T[];
    type LodashFlattenDepth1x2<T> = (depth: number) => T[];
    type LodashFlip = <T extends (...args: any) => any>(func: T) => T;
    type LodashFloor = (n: number) => number;
    interface LodashFlow {
        <A extends any[], R1, R2, R3, R4, R5, R6, R7>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (...args: A) => R7;
        <A extends any[], R1, R2, R3, R4, R5, R6, R7>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...func: Array<lodash.Many<(a: any) => any>>): (...args: A) => any;
        <A extends any[], R1, R2, R3, R4, R5, R6>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): (...args: A) => R6;
        <A extends any[], R1, R2, R3, R4, R5>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): (...args: A) => R5;
        <A extends any[], R1, R2, R3, R4>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): (...args: A) => R4;
        <A extends any[], R1, R2, R3>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (...args: A) => R3;
        <A extends any[], R1, R2>(f1: (...args: A) => R1, f2: (a: R1) => R2): (...args: A) => R2;
        (...func: Array<lodash.Many<(...args: any[]) => any>>): (...args: any[]) => any;
    }
    interface LodashForIn {
        <T>(iteratee: (value: T) => any): LodashForIn1x1<T>;
        <T>(iteratee: lodash.__, object: T): LodashForIn1x2<T>;
        <T>(iteratee: (value: T[keyof T]) => any, object: T): T;
        <T>(iteratee: lodash.__, object: T | null | undefined): LodashForIn2x2<T>;
        <T>(iteratee: (value: T[keyof T]) => any, object: T | null | undefined): T | null | undefined;
    }
    interface LodashForIn1x1<T> {
        <T1 extends object>(object: T1): T1;
        <T1 extends object>(object: T1 | null | undefined): T1 | null | undefined;
    }
    type LodashForIn1x2<T> = (iteratee: (value: T[keyof T]) => any) => T;
    type LodashForIn2x2<T> = (iteratee: (value: T[keyof T]) => any) => T | null | undefined;
    interface LodashForInRight {
        <T>(iteratee: (value: T) => any): LodashForInRight1x1<T>;
        <T>(iteratee: lodash.__, object: T): LodashForInRight1x2<T>;
        <T>(iteratee: (value: T[keyof T]) => any, object: T): T;
        <T>(iteratee: lodash.__, object: T | null | undefined): LodashForInRight2x2<T>;
        <T>(iteratee: (value: T[keyof T]) => any, object: T | null | undefined): T | null | undefined;
    }
    interface LodashForInRight1x1<T> {
        <T1 extends object>(object: T1): T1;
        <T1 extends object>(object: T1 | null | undefined): T1 | null | undefined;
    }
    type LodashForInRight1x2<T> = (iteratee: (value: T[keyof T]) => any) => T;
    type LodashForInRight2x2<T> = (iteratee: (value: T[keyof T]) => any) => T | null | undefined;
    interface LodashForOwn {
        <T>(iteratee: (value: T) => any): LodashForOwn1x1<T>;
        <T>(iteratee: lodash.__, object: T): LodashForOwn1x2<T>;
        <T>(iteratee: (value: T[keyof T]) => any, object: T): T;
        <T>(iteratee: lodash.__, object: T | null | undefined): LodashForOwn2x2<T>;
        <T>(iteratee: (value: T[keyof T]) => any, object: T | null | undefined): T | null | undefined;
    }
    interface LodashForOwn1x1<T> {
        <T1 extends object>(object: T1): T1;
        <T1 extends object>(object: T1 | null | undefined): T1 | null | undefined;
    }
    type LodashForOwn1x2<T> = (iteratee: (value: T[keyof T]) => any) => T;
    type LodashForOwn2x2<T> = (iteratee: (value: T[keyof T]) => any) => T | null | undefined;
    interface LodashForOwnRight {
        <T>(iteratee: (value: T) => any): LodashForOwnRight1x1<T>;
        <T>(iteratee: lodash.__, object: T): LodashForOwnRight1x2<T>;
        <T>(iteratee: (value: T[keyof T]) => any, object: T): T;
        <T>(iteratee: lodash.__, object: T | null | undefined): LodashForOwnRight2x2<T>;
        <T>(iteratee: (value: T[keyof T]) => any, object: T | null | undefined): T | null | undefined;
    }
    interface LodashForOwnRight1x1<T> {
        <T1 extends object>(object: T1): T1;
        <T1 extends object>(object: T1 | null | undefined): T1 | null | undefined;
    }
    type LodashForOwnRight1x2<T> = (iteratee: (value: T[keyof T]) => any) => T;
    type LodashForOwnRight2x2<T> = (iteratee: (value: T[keyof T]) => any) => T | null | undefined;
    interface LodashFromPairs {
        <T>(pairs: lodash.List<[lodash.PropertyName, T]> | null | undefined): lodash.Dictionary<T>;
        (pairs: lodash.List<any[]> | null | undefined): lodash.Dictionary<any>;
    }
    type LodashFunctions = (object: any) => string[];
    type LodashFunctionsIn = (object: any) => string[];
    interface LodashGet {
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey]): LodashGet1x1<TObject, TKey>;
        <TObject extends object>(path: lodash.__, object: TObject): LodashGet1x2<TObject>;
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey], object: TObject): TObject[TKey];
        <TObject extends object>(path: lodash.__, object: TObject | null | undefined): LodashGet2x2<TObject>;
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey], object: TObject | null | undefined): TObject[TKey] | undefined;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): LodashGet3x1<TObject, TKey1, TKey2>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2], object: TObject): TObject[TKey1][TKey2];
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2], object: TObject | null | undefined): TObject[TKey1][TKey2] | undefined;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): LodashGet5x1<TObject, TKey1, TKey2, TKey3>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3], object: TObject): TObject[TKey1][TKey2][TKey3];
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3], object: TObject | null | undefined): TObject[TKey1][TKey2][TKey3] | undefined;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): LodashGet7x1<TObject, TKey1, TKey2, TKey3, TKey4>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4], object: TObject): TObject[TKey1][TKey2][TKey3][TKey4];
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4], object: TObject | null | undefined): TObject[TKey1][TKey2][TKey3][TKey4] | undefined;
        (path: number): LodashGet9x1;
        <T>(path: lodash.__, object: lodash.NumericDictionary<T>): LodashGet9x2<T>;
        <T>(path: number, object: lodash.NumericDictionary<T>): T;
        <T>(path: lodash.__, object: lodash.NumericDictionary<T> | null | undefined): LodashGet10x2<T>;
        <T>(path: number, object: lodash.NumericDictionary<T> | null | undefined): T | undefined;
        (path: lodash.PropertyPath): LodashGet11x1;
        (path: lodash.__, object: null | undefined): LodashGet11x2;
        (path: lodash.PropertyPath, object: null | undefined): undefined;
        (path: lodash.__, object: any): LodashGet12x2;
        (path: lodash.PropertyPath, object: any): any;
    }
    interface LodashGet1x1<TObject, TKey extends keyof TObject> {
        (object: TObject): TObject[TKey];
        (object: TObject | null | undefined): TObject[TKey] | undefined;
    }
    interface LodashGet1x2<TObject> {
        <TKey extends keyof TObject>(path: TKey | [TKey]): TObject[TKey];
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): TObject[TKey1][TKey2];
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): TObject[TKey1][TKey2][TKey3];
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): TObject[TKey1][TKey2][TKey3][TKey4];
    }
    interface LodashGet2x2<TObject> {
        <TKey extends keyof TObject>(path: TKey | [TKey]): TObject[TKey] | undefined;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): TObject[TKey1][TKey2] | undefined;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): TObject[TKey1][TKey2][TKey3] | undefined;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): TObject[TKey1][TKey2][TKey3][TKey4] | undefined;
    }
    interface LodashGet3x1<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]> {
        (object: TObject): TObject[TKey1][TKey2];
        (object: TObject | null | undefined): TObject[TKey1][TKey2] | undefined;
    }
    interface LodashGet5x1<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]> {
        (object: TObject): TObject[TKey1][TKey2][TKey3];
        (object: TObject | null | undefined): TObject[TKey1][TKey2][TKey3] | undefined;
    }
    interface LodashGet7x1<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]> {
        (object: TObject): TObject[TKey1][TKey2][TKey3][TKey4];
        (object: TObject | null | undefined): TObject[TKey1][TKey2][TKey3][TKey4] | undefined;
    }
    interface LodashGet9x1 {
        <T>(object: lodash.NumericDictionary<T>): T;
        <T>(object: lodash.NumericDictionary<T> | null | undefined): T | undefined;
    }
    type LodashGet9x2<T> = (path: number) => T;
    type LodashGet10x2<T> = (path: number) => T | undefined;
    interface LodashGet11x1 {
        (object: null | undefined): undefined;
        (object: any): any;
    }
    type LodashGet11x2 = (path: lodash.PropertyPath) => undefined;
    type LodashGet12x2 = (path: lodash.PropertyPath) => any;
    interface LodashGetOr {
        <TDefault>(defaultValue: TDefault): LodashGetOr1x1<TDefault>;
        <TObject extends object, TKey extends keyof TObject>(defaultValue: lodash.__, path: TKey | [TKey]): LodashGetOr1x2<TObject, TKey>;
        <TObject extends object, TKey extends keyof TObject, TDefault>(defaultValue: TDefault, path: TKey | [TKey]): LodashGetOr1x3<TObject, TKey, TDefault>;
        <TObject extends object>(defaultValue: lodash.__, path: lodash.__, object: TObject | null | undefined): LodashGetOr1x4<TObject>;
        <TObject extends object, TDefault>(defaultValue: TDefault, path: lodash.__, object: TObject | null | undefined): LodashGetOr1x5<TObject, TDefault>;
        <TObject extends object, TKey extends keyof TObject>(defaultValue: lodash.__, path: TKey | [TKey], object: TObject | null | undefined): LodashGetOr1x6<TObject, TKey>;
        <TObject extends object, TKey extends keyof TObject, TDefault>(defaultValue: TDefault, path: TKey | [TKey], object: TObject | null | undefined): Exclude<TObject[TKey], undefined> | TDefault;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(defaultValue: lodash.__, path: [TKey1, TKey2]): LodashGetOr2x2<TObject, TKey1, TKey2>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2]): LodashGetOr2x3<TObject, TKey1, TKey2, TDefault>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(defaultValue: lodash.__, path: [TKey1, TKey2], object: TObject | null | undefined): LodashGetOr2x6<TObject, TKey1, TKey2>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2], object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(defaultValue: lodash.__, path: [TKey1, TKey2, TKey3]): LodashGetOr3x2<TObject, TKey1, TKey2, TKey3>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2, TKey3]): LodashGetOr3x3<TObject, TKey1, TKey2, TKey3, TDefault>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(defaultValue: lodash.__, path: [TKey1, TKey2, TKey3], object: TObject | null | undefined): LodashGetOr3x6<TObject, TKey1, TKey2, TKey3>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2, TKey3], object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(defaultValue: lodash.__, path: [TKey1, TKey2, TKey3, TKey4]): LodashGetOr4x2<TObject, TKey1, TKey2, TKey3, TKey4>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2, TKey3, TKey4]): LodashGetOr4x3<TObject, TKey1, TKey2, TKey3, TKey4, TDefault>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(defaultValue: lodash.__, path: [TKey1, TKey2, TKey3, TKey4], object: TObject | null | undefined): LodashGetOr4x6<TObject, TKey1, TKey2, TKey3, TKey4>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2, TKey3, TKey4], object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
        (defaultValue: lodash.__, path: number): LodashGetOr5x2;
        <TDefault>(defaultValue: TDefault, path: number): LodashGetOr5x3<TDefault>;
        <T>(defaultValue: lodash.__, path: lodash.__, object: lodash.NumericDictionary<T> | null | undefined): LodashGetOr5x4<T>;
        <T, TDefault>(defaultValue: TDefault, path: lodash.__, object: lodash.NumericDictionary<T> | null | undefined): LodashGetOr5x5<T, TDefault>;
        <T>(defaultValue: lodash.__, path: number, object: lodash.NumericDictionary<T> | null | undefined): LodashGetOr5x6<T>;
        <T, TDefault>(defaultValue: TDefault, path: number, object: lodash.NumericDictionary<T> | null | undefined): T | TDefault;
        (defaultValue: lodash.__, path: lodash.PropertyPath): LodashGetOr6x2;
        <TDefault>(defaultValue: TDefault, path: lodash.PropertyPath): LodashGetOr6x3<TDefault>;
        (defaultValue: lodash.__, path: lodash.__, object: null | undefined): LodashGetOr6x4;
        <TDefault>(defaultValue: TDefault, path: lodash.__, object: null | undefined): LodashGetOr6x5<TDefault>;
        (defaultValue: lodash.__, path: lodash.PropertyPath, object: null | undefined): LodashGetOr6x6;
        <TDefault>(defaultValue: TDefault, path: lodash.PropertyPath, object: null | undefined): TDefault;
        (defaultValue: any): LodashGetOr7x1;
        (defaultValue: any, path: lodash.PropertyPath): LodashGetOr7x3;
        (defaultValue: lodash.__, path: lodash.__, object: any): LodashGetOr7x4;
        (defaultValue: any, path: lodash.__, object: any): LodashGetOr7x5;
        (defaultValue: lodash.__, path: lodash.PropertyPath, object: any): LodashGetOr7x6;
        (defaultValue: any, path: lodash.PropertyPath, object: any): any;
    }
    interface LodashGetOr1x1<TDefault> {
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey]): LodashGetOr1x3<TObject, TKey, TDefault>;
        <TObject extends object>(path: lodash.__, object: TObject | null | undefined): LodashGetOr1x5<TObject, TDefault>;
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey], object: TObject | null | undefined): Exclude<TObject[TKey], undefined> | TDefault;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): LodashGetOr2x3<TObject, TKey1, TKey2, TDefault>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2], object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): LodashGetOr3x3<TObject, TKey1, TKey2, TKey3, TDefault>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3], object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): LodashGetOr4x3<TObject, TKey1, TKey2, TKey3, TKey4, TDefault>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4], object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
        (path: number): LodashGetOr5x3<TDefault>;
        <T>(path: lodash.__, object: lodash.NumericDictionary<T> | null | undefined): LodashGetOr5x5<T, TDefault>;
        <T>(path: number, object: lodash.NumericDictionary<T> | null | undefined): T | TDefault;
        (path: lodash.PropertyPath): LodashGetOr6x3<TDefault>;
        (path: lodash.__, object: null | undefined): LodashGetOr6x5<TDefault>;
        (path: lodash.PropertyPath, object: null | undefined): TDefault;
    }
    interface LodashGetOr1x2<TObject, TKey extends keyof TObject> {
        <TDefault>(defaultValue: TDefault): LodashGetOr1x3<TObject, TKey, TDefault>;
        (defaultValue: lodash.__, object: TObject | null | undefined): LodashGetOr1x6<TObject, TKey>;
        <TDefault>(defaultValue: TDefault, object: TObject | null | undefined): Exclude<TObject[TKey], undefined> | TDefault;
    }
    type LodashGetOr1x3<TObject, TKey extends keyof TObject, TDefault> = (object: TObject | null | undefined) => Exclude<TObject[TKey], undefined> | TDefault;
    interface LodashGetOr1x4<TObject> {
        <TDefault>(defaultValue: TDefault): LodashGetOr1x5<TObject, TDefault>;
        <TKey extends keyof TObject>(defaultValue: lodash.__, path: TKey | [TKey]): LodashGetOr1x6<TObject, TKey>;
        <TKey extends keyof TObject, TDefault>(defaultValue: TDefault, path: TKey | [TKey]): Exclude<TObject[TKey], undefined> | TDefault;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(defaultValue: lodash.__, path: [TKey1, TKey2]): LodashGetOr2x6<TObject, TKey1, TKey2>;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2]): Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(defaultValue: lodash.__, path: [TKey1, TKey2, TKey3]): LodashGetOr3x6<TObject, TKey1, TKey2, TKey3>;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2, TKey3]): Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(defaultValue: lodash.__, path: [TKey1, TKey2, TKey3, TKey4]): LodashGetOr4x6<TObject, TKey1, TKey2, TKey3, TKey4>;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2, TKey3, TKey4]): Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
    }
    interface LodashGetOr1x5<TObject, TDefault> {
        <TKey extends keyof TObject>(path: TKey | [TKey]): Exclude<TObject[TKey], undefined> | TDefault;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
    }
    type LodashGetOr1x6<TObject, TKey extends keyof TObject> = <TDefault>(defaultValue: TDefault) => Exclude<TObject[TKey], undefined> | TDefault;
    interface LodashGetOr2x2<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]> {
        <TDefault>(defaultValue: TDefault): LodashGetOr2x3<TObject, TKey1, TKey2, TDefault>;
        (defaultValue: lodash.__, object: TObject | null | undefined): LodashGetOr2x6<TObject, TKey1, TKey2>;
        <TDefault>(defaultValue: TDefault, object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
    }
    type LodashGetOr2x3<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TDefault> = (object: TObject | null | undefined) => Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
    type LodashGetOr2x6<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]> = <TDefault>(defaultValue: TDefault) => Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
    interface LodashGetOr3x2<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]> {
        <TDefault>(defaultValue: TDefault): LodashGetOr3x3<TObject, TKey1, TKey2, TKey3, TDefault>;
        (defaultValue: lodash.__, object: TObject | null | undefined): LodashGetOr3x6<TObject, TKey1, TKey2, TKey3>;
        <TDefault>(defaultValue: TDefault, object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
    }
    type LodashGetOr3x3<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TDefault> = (object: TObject | null | undefined) => Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
    type LodashGetOr3x6<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]> = <TDefault>(defaultValue: TDefault) => Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
    interface LodashGetOr4x2<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]> {
        <TDefault>(defaultValue: TDefault): LodashGetOr4x3<TObject, TKey1, TKey2, TKey3, TKey4, TDefault>;
        (defaultValue: lodash.__, object: TObject | null | undefined): LodashGetOr4x6<TObject, TKey1, TKey2, TKey3, TKey4>;
        <TDefault>(defaultValue: TDefault, object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
    }
    type LodashGetOr4x3<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3], TDefault> = (object: TObject | null | undefined) => Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
    type LodashGetOr4x6<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]> = <TDefault>(defaultValue: TDefault) => Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
    interface LodashGetOr5x2 {
        <TDefault>(defaultValue: TDefault): LodashGetOr5x3<TDefault>;
        <T>(defaultValue: lodash.__, object: lodash.NumericDictionary<T> | null | undefined): LodashGetOr5x6<T>;
        <T, TDefault>(defaultValue: TDefault, object: lodash.NumericDictionary<T> | null | undefined): T | TDefault;
    }
    type LodashGetOr5x3<TDefault> = <T>(object: lodash.NumericDictionary<T> | null | undefined) => T | TDefault;
    interface LodashGetOr5x4<T> {
        <TDefault>(defaultValue: TDefault): LodashGetOr5x5<T, TDefault>;
        (defaultValue: lodash.__, path: number): LodashGetOr5x6<T>;
        <TDefault>(defaultValue: TDefault, path: number): T | TDefault;
    }
    type LodashGetOr5x5<T, TDefault> = (path: number) => T | TDefault;
    type LodashGetOr5x6<T> = <TDefault>(defaultValue: TDefault) => T | TDefault;
    interface LodashGetOr6x2 {
        <TDefault>(defaultValue: TDefault): LodashGetOr6x3<TDefault>;
        (defaultValue: lodash.__, object: null | undefined): LodashGetOr6x6;
        <TDefault>(defaultValue: TDefault, object: null | undefined): TDefault;
        (defaultValue: any): LodashGetOr7x3;
        (defaultValue: lodash.__, object: any): LodashGetOr7x6;
        (defaultValue: any, object: any): any;
    }
    type LodashGetOr6x3<TDefault> = (object: null | undefined) => TDefault;
    interface LodashGetOr6x4 {
        <TDefault>(defaultValue: TDefault): LodashGetOr6x5<TDefault>;
        (defaultValue: lodash.__, path: lodash.PropertyPath): LodashGetOr6x6;
        <TDefault>(defaultValue: TDefault, path: lodash.PropertyPath): TDefault;
    }
    type LodashGetOr6x5<TDefault> = (path: lodash.PropertyPath) => TDefault;
    type LodashGetOr6x6 = <TDefault>(defaultValue: TDefault) => TDefault;
    interface LodashGetOr7x1 {
        (path: lodash.PropertyPath): LodashGetOr7x3;
        (path: lodash.__, object: any): LodashGetOr7x5;
        (path: lodash.PropertyPath, object: any): any;
    }
    type LodashGetOr7x3 = (object: any) => any;
    interface LodashGetOr7x4 {
        (defaultValue: any): LodashGetOr7x5;
        (defaultValue: lodash.__, path: lodash.PropertyPath): LodashGetOr7x6;
        (defaultValue: any, path: lodash.PropertyPath): any;
    }
    type LodashGetOr7x5 = (path: lodash.PropertyPath) => any;
    type LodashGetOr7x6 = (defaultValue: any) => any;
    interface LodashGroupBy {
        <T>(iteratee: lodash.ValueIteratee<T>): LodashGroupBy1x1<T>;
        <T>(iteratee: lodash.__, collection: lodash.List<T> | null | undefined): LodashGroupBy1x2<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, collection: lodash.List<T> | null | undefined): lodash.Dictionary<T[]>;
        <T extends object>(iteratee: lodash.__, collection: T | null | undefined): LodashGroupBy2x2<T>;
        <T extends object>(iteratee: lodash.ValueIteratee<T[keyof T]>, collection: T | null | undefined): lodash.Dictionary<Array<T[keyof T]>>;
    }
    type LodashGroupBy1x1<T> = (collection: lodash.List<T> | object | null | undefined) => lodash.Dictionary<T[]>;
    type LodashGroupBy1x2<T> = (iteratee: lodash.ValueIteratee<T>) => lodash.Dictionary<T[]>;
    type LodashGroupBy2x2<T> = (iteratee: lodash.ValueIteratee<T[keyof T]>) => lodash.Dictionary<Array<T[keyof T]>>;
    interface LodashGt {
        (value: any): LodashGt1x1;
        (value: lodash.__, other: any): LodashGt1x2;
        (value: any, other: any): boolean;
    }
    type LodashGt1x1 = (other: any) => boolean;
    type LodashGt1x2 = (value: any) => boolean;
    interface LodashGte {
        (value: any): LodashGte1x1;
        (value: lodash.__, other: any): LodashGte1x2;
        (value: any, other: any): boolean;
    }
    type LodashGte1x1 = (other: any) => boolean;
    type LodashGte1x2 = (value: any) => boolean;
    interface LodashHas {
        (path: lodash.PropertyPath): LodashHas1x1;
        <T>(path: lodash.__, object: T): LodashHas1x2;
        <T>(path: lodash.PropertyPath, object: T): boolean;
    }
    type LodashHas1x1 = <T>(object: T) => boolean;
    type LodashHas1x2 = (path: lodash.PropertyPath) => boolean;
    interface LodashHasIn {
        (path: lodash.PropertyPath): LodashHasIn1x1;
        <T>(path: lodash.__, object: T): LodashHasIn1x2;
        <T>(path: lodash.PropertyPath, object: T): boolean;
    }
    type LodashHasIn1x1 = <T>(object: T) => boolean;
    type LodashHasIn1x2 = (path: lodash.PropertyPath) => boolean;
    interface LodashIdentity {
        <T>(value: T): T;
        (): undefined;
    }
    interface LodashIncludes {
        <T>(target: T): LodashIncludes1x1<T>;
        <T>(target: lodash.__, collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): LodashIncludes1x2<T>;
        <T>(target: T, collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): boolean;
    }
    type LodashIncludes1x1<T> = (collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined) => boolean;
    type LodashIncludes1x2<T> = (target: T) => boolean;
    interface LodashIncludesFrom {
        <T>(target: T): LodashIncludesFrom1x1<T>;
        (target: lodash.__, fromIndex: number): LodashIncludesFrom1x2;
        <T>(target: T, fromIndex: number): LodashIncludesFrom1x3<T>;
        <T>(target: lodash.__, fromIndex: lodash.__, collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): LodashIncludesFrom1x4<T>;
        <T>(target: T, fromIndex: lodash.__, collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): LodashIncludesFrom1x5;
        <T>(target: lodash.__, fromIndex: number, collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): LodashIncludesFrom1x6<T>;
        <T>(target: T, fromIndex: number, collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): boolean;
    }
    interface LodashIncludesFrom1x1<T> {
        (fromIndex: number): LodashIncludesFrom1x3<T>;
        (fromIndex: lodash.__, collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): LodashIncludesFrom1x5;
        (fromIndex: number, collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): boolean;
    }
    interface LodashIncludesFrom1x2 {
        <T>(target: T): LodashIncludesFrom1x3<T>;
        <T>(target: lodash.__, collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): LodashIncludesFrom1x6<T>;
        <T>(target: T, collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): boolean;
    }
    type LodashIncludesFrom1x3<T> = (collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined) => boolean;
    interface LodashIncludesFrom1x4<T> {
        (target: T): LodashIncludesFrom1x5;
        (target: lodash.__, fromIndex: number): LodashIncludesFrom1x6<T>;
        (target: T, fromIndex: number): boolean;
    }
    type LodashIncludesFrom1x5 = (fromIndex: number) => boolean;
    type LodashIncludesFrom1x6<T> = (target: T) => boolean;
    interface LodashKeyBy {
        <T>(iteratee: lodash.ValueIterateeCustom<T, lodash.PropertyName>): LodashKeyBy1x1<T>;
        <T>(iteratee: lodash.__, collection: lodash.List<T> | null | undefined): LodashKeyBy1x2<T>;
        <T>(iteratee: lodash.ValueIterateeCustom<T, lodash.PropertyName>, collection: lodash.List<T> | null | undefined): lodash.Dictionary<T>;
        <T extends object>(iteratee: lodash.__, collection: T | null | undefined): LodashKeyBy2x2<T>;
        <T extends object>(iteratee: lodash.ValueIterateeCustom<T[keyof T], lodash.PropertyName>, collection: T | null | undefined): lodash.Dictionary<T[keyof T]>;
    }
    type LodashKeyBy1x1<T> = (collection: lodash.List<T> | object | null | undefined) => lodash.Dictionary<T>;
    type LodashKeyBy1x2<T> = (iteratee: lodash.ValueIterateeCustom<T, lodash.PropertyName>) => lodash.Dictionary<T>;
    type LodashKeyBy2x2<T> = (iteratee: lodash.ValueIterateeCustom<T[keyof T], lodash.PropertyName>) => lodash.Dictionary<T[keyof T]>;
    interface LodashIndexOf {
        <T>(value: T): LodashIndexOf1x1<T>;
        <T>(value: lodash.__, array: lodash.List<T> | null | undefined): LodashIndexOf1x2<T>;
        <T>(value: T, array: lodash.List<T> | null | undefined): number;
    }
    type LodashIndexOf1x1<T> = (array: lodash.List<T> | null | undefined) => number;
    type LodashIndexOf1x2<T> = (value: T) => number;
    interface LodashIndexOfFrom {
        <T>(value: T): LodashIndexOfFrom1x1<T>;
        (value: lodash.__, fromIndex: number): LodashIndexOfFrom1x2;
        <T>(value: T, fromIndex: number): LodashIndexOfFrom1x3<T>;
        <T>(value: lodash.__, fromIndex: lodash.__, array: lodash.List<T> | null | undefined): LodashIndexOfFrom1x4<T>;
        <T>(value: T, fromIndex: lodash.__, array: lodash.List<T> | null | undefined): LodashIndexOfFrom1x5;
        <T>(value: lodash.__, fromIndex: number, array: lodash.List<T> | null | undefined): LodashIndexOfFrom1x6<T>;
        <T>(value: T, fromIndex: number, array: lodash.List<T> | null | undefined): number;
    }
    interface LodashIndexOfFrom1x1<T> {
        (fromIndex: number): LodashIndexOfFrom1x3<T>;
        (fromIndex: lodash.__, array: lodash.List<T> | null | undefined): LodashIndexOfFrom1x5;
        (fromIndex: number, array: lodash.List<T> | null | undefined): number;
    }
    interface LodashIndexOfFrom1x2 {
        <T>(value: T): LodashIndexOfFrom1x3<T>;
        <T>(value: lodash.__, array: lodash.List<T> | null | undefined): LodashIndexOfFrom1x6<T>;
        <T>(value: T, array: lodash.List<T> | null | undefined): number;
    }
    type LodashIndexOfFrom1x3<T> = (array: lodash.List<T> | null | undefined) => number;
    interface LodashIndexOfFrom1x4<T> {
        (value: T): LodashIndexOfFrom1x5;
        (value: lodash.__, fromIndex: number): LodashIndexOfFrom1x6<T>;
        (value: T, fromIndex: number): number;
    }
    type LodashIndexOfFrom1x5 = (fromIndex: number) => number;
    type LodashIndexOfFrom1x6<T> = (value: T) => number;
    type LodashInitial = <T>(array: lodash.List<T> | null | undefined) => T[];
    interface LodashInRange {
        (start: number): LodashInRange1x1;
        (start: lodash.__, end: number): LodashInRange1x2;
        (start: number, end: number): LodashInRange1x3;
        (start: lodash.__, end: lodash.__, n: number): LodashInRange1x4;
        (start: number, end: lodash.__, n: number): LodashInRange1x5;
        (start: lodash.__, end: number, n: number): LodashInRange1x6;
        (start: number, end: number, n: number): boolean;
    }
    interface LodashInRange1x1 {
        (end: number): LodashInRange1x3;
        (end: lodash.__, n: number): LodashInRange1x5;
        (end: number, n: number): boolean;
    }
    interface LodashInRange1x2 {
        (start: number): LodashInRange1x3;
        (start: lodash.__, n: number): LodashInRange1x6;
        (start: number, n: number): boolean;
    }
    type LodashInRange1x3 = (n: number) => boolean;
    interface LodashInRange1x4 {
        (start: number): LodashInRange1x5;
        (start: lodash.__, end: number): LodashInRange1x6;
        (start: number, end: number): boolean;
    }
    type LodashInRange1x5 = (end: number) => boolean;
    type LodashInRange1x6 = (start: number) => boolean;
    interface LodashIntersection {
        <T>(arrays2: lodash.List<T> | null | undefined): LodashIntersection1x1<T>;
        <T>(arrays2: lodash.__, arrays: lodash.List<T> | null | undefined): LodashIntersection1x2<T>;
        <T>(arrays2: lodash.List<T> | null | undefined, arrays: lodash.List<T> | null | undefined): T[];
    }
    type LodashIntersection1x1<T> = (arrays: lodash.List<T> | null | undefined) => T[];
    type LodashIntersection1x2<T> = (arrays2: lodash.List<T> | null | undefined) => T[];
    interface LodashIntersectionBy {
        <T1, T2>(iteratee: lodash.ValueIteratee<T1 | T2>): LodashIntersectionBy1x1<T1, T2>;
        <T1>(iteratee: lodash.__, array: lodash.List<T1> | null): LodashIntersectionBy1x2<T1>;
        <T1, T2>(iteratee: lodash.ValueIteratee<T1 | T2>, array: lodash.List<T1> | null): LodashIntersectionBy1x3<T1, T2>;
        <T2>(iteratee: lodash.__, array: lodash.__, values: lodash.List<T2>): LodashIntersectionBy1x4<T2>;
        <T1, T2>(iteratee: lodash.ValueIteratee<T1 | T2>, array: lodash.__, values: lodash.List<T2>): LodashIntersectionBy1x5<T1>;
        <T1, T2>(iteratee: lodash.__, array: lodash.List<T1> | null, values: lodash.List<T2>): LodashIntersectionBy1x6<T1, T2>;
        <T1, T2>(iteratee: lodash.ValueIteratee<T1 | T2>, array: lodash.List<T1> | null, values: lodash.List<T2>): T1[];
    }
    interface LodashIntersectionBy1x1<T1, T2> {
        (array: lodash.List<T1> | null): LodashIntersectionBy1x3<T1, T2>;
        (array: lodash.__, values: lodash.List<T2>): LodashIntersectionBy1x5<T1>;
        (array: lodash.List<T1> | null, values: lodash.List<T2>): T1[];
    }
    interface LodashIntersectionBy1x2<T1> {
        <T2>(iteratee: lodash.ValueIteratee<T1 | T2>): LodashIntersectionBy1x3<T1, T2>;
        <T2>(iteratee: lodash.__, values: lodash.List<T2>): LodashIntersectionBy1x6<T1, T2>;
        <T2>(iteratee: lodash.ValueIteratee<T1 | T2>, values: lodash.List<T2>): T1[];
    }
    type LodashIntersectionBy1x3<T1, T2> = (values: lodash.List<T2>) => T1[];
    interface LodashIntersectionBy1x4<T2> {
        <T1>(iteratee: lodash.ValueIteratee<T1 | T2>): LodashIntersectionBy1x5<T1>;
        <T1>(iteratee: lodash.__, array: lodash.List<T1> | null): LodashIntersectionBy1x6<T1, T2>;
        <T1>(iteratee: lodash.ValueIteratee<T1 | T2>, array: lodash.List<T1> | null): T1[];
    }
    type LodashIntersectionBy1x5<T1> = (array: lodash.List<T1> | null) => T1[];
    type LodashIntersectionBy1x6<T1, T2> = (iteratee: lodash.ValueIteratee<T1 | T2>) => T1[];
    interface LodashIntersectionWith {
        <T1, T2>(comparator: lodash.Comparator2<T1, T2>): LodashIntersectionWith1x1<T1, T2>;
        <T1>(comparator: lodash.__, array: lodash.List<T1> | null | undefined): LodashIntersectionWith1x2<T1>;
        <T1, T2>(comparator: lodash.Comparator2<T1, T2>, array: lodash.List<T1> | null | undefined): LodashIntersectionWith1x3<T1, T2>;
        <T2>(comparator: lodash.__, array: lodash.__, values: lodash.List<T2>): LodashIntersectionWith1x4<T2>;
        <T1, T2>(comparator: lodash.Comparator2<T1, T2>, array: lodash.__, values: lodash.List<T2>): LodashIntersectionWith1x5<T1>;
        <T1, T2>(comparator: lodash.__, array: lodash.List<T1> | null | undefined, values: lodash.List<T2>): LodashIntersectionWith1x6<T1, T2>;
        <T1, T2>(comparator: lodash.Comparator2<T1, T2>, array: lodash.List<T1> | null | undefined, values: lodash.List<T2>): T1[];
    }
    interface LodashIntersectionWith1x1<T1, T2> {
        (array: lodash.List<T1> | null | undefined): LodashIntersectionWith1x3<T1, T2>;
        (array: lodash.__, values: lodash.List<T2>): LodashIntersectionWith1x5<T1>;
        (array: lodash.List<T1> | null | undefined, values: lodash.List<T2>): T1[];
    }
    interface LodashIntersectionWith1x2<T1> {
        <T2>(comparator: lodash.Comparator2<T1, T2>): LodashIntersectionWith1x3<T1, T2>;
        <T2>(comparator: lodash.__, values: lodash.List<T2>): LodashIntersectionWith1x6<T1, T2>;
        <T2>(comparator: lodash.Comparator2<T1, T2>, values: lodash.List<T2>): T1[];
    }
    type LodashIntersectionWith1x3<T1, T2> = (values: lodash.List<T2>) => T1[];
    interface LodashIntersectionWith1x4<T2> {
        <T1>(comparator: lodash.Comparator2<T1, T2>): LodashIntersectionWith1x5<T1>;
        <T1>(comparator: lodash.__, array: lodash.List<T1> | null | undefined): LodashIntersectionWith1x6<T1, T2>;
        <T1>(comparator: lodash.Comparator2<T1, T2>, array: lodash.List<T1> | null | undefined): T1[];
    }
    type LodashIntersectionWith1x5<T1> = (array: lodash.List<T1> | null | undefined) => T1[];
    type LodashIntersectionWith1x6<T1, T2> = (comparator: lodash.Comparator2<T1, T2>) => T1[];
    type LodashInvert = (object: object) => lodash.Dictionary<string>;
    interface LodashInvertBy {
        <T>(interatee: lodash.ValueIteratee<T>): LodashInvertBy1x1<T>;
        <T>(interatee: lodash.__, object:  lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): LodashInvertBy1x2<T>;
        <T>(interatee: lodash.ValueIteratee<T>, object:  lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): lodash.Dictionary<string[]>;
        <T extends object>(interatee: lodash.__, object: T | null | undefined): LodashInvertBy2x2<T>;
        <T extends object>(interatee: lodash.ValueIteratee<T[keyof T]>, object: T | null | undefined): lodash.Dictionary<string[]>;
    }
    type LodashInvertBy1x1<T> = (object: lodash.Dictionary<T> | lodash.NumericDictionary<T> | object | null | undefined) => lodash.Dictionary<string[]>;
    type LodashInvertBy1x2<T> = (interatee: lodash.ValueIteratee<T>) => lodash.Dictionary<string[]>;
    type LodashInvertBy2x2<T> = (interatee: lodash.ValueIteratee<T[keyof T]>) => lodash.Dictionary<string[]>;
    interface LodashInvoke {
        (path: lodash.PropertyPath): LodashInvoke1x1;
        (path: lodash.__, object: any): LodashInvoke1x2;
        (path: lodash.PropertyPath, object: any): any;
    }
    type LodashInvoke1x1 = (object: any) => any;
    type LodashInvoke1x2 = (path: lodash.PropertyPath) => any;
    interface LodashInvokeArgs {
        (path: lodash.PropertyPath): LodashInvokeArgs1x1;
        (path: lodash.__, args: readonly any[]): LodashInvokeArgs1x2;
        (path: lodash.PropertyPath, args: readonly any[]): LodashInvokeArgs1x3;
        (path: lodash.__, args: lodash.__, object: any): LodashInvokeArgs1x4;
        (path: lodash.PropertyPath, args: lodash.__, object: any): LodashInvokeArgs1x5;
        (path: lodash.__, args: readonly any[], object: any): LodashInvokeArgs1x6;
        (path: lodash.PropertyPath, args: readonly any[], object: any): any;
    }
    interface LodashInvokeArgs1x1 {
        (args: readonly any[]): LodashInvokeArgs1x3;
        (args: lodash.__, object: any): LodashInvokeArgs1x5;
        (args: readonly any[], object: any): any;
    }
    interface LodashInvokeArgs1x2 {
        (path: lodash.PropertyPath): LodashInvokeArgs1x3;
        (path: lodash.__, object: any): LodashInvokeArgs1x6;
        (path: lodash.PropertyPath, object: any): any;
    }
    type LodashInvokeArgs1x3 = (object: any) => any;
    interface LodashInvokeArgs1x4 {
        (path: lodash.PropertyPath): LodashInvokeArgs1x5;
        (path: lodash.__, args: readonly any[]): LodashInvokeArgs1x6;
        (path: lodash.PropertyPath, args: readonly any[]): any;
    }
    type LodashInvokeArgs1x5 = (args: readonly any[]) => any;
    type LodashInvokeArgs1x6 = (path: lodash.PropertyPath) => any;
    interface LodashInvokeArgsMap {
        (methodName: string): LodashInvokeArgsMap1x1;
        (methodNameOrMethod: lodash.__, args: readonly any[]): LodashInvokeArgsMap1x2;
        (methodName: string, args: readonly any[]): LodashInvokeArgsMap1x3;
        (methodNameOrMethod: lodash.__, args: lodash.__, collection: object | null | undefined): LodashInvokeArgsMap1x4;
        (methodName: string, args: lodash.__, collection: object | null | undefined): LodashInvokeArgsMap1x5;
        (methodNameOrMethod: lodash.__, args: readonly any[], collection: object | null | undefined): LodashInvokeArgsMap1x6;
        (methodName: string, args: readonly any[], collection: object | null | undefined): any[];
        <TResult>(method: (...args: any[]) => TResult): LodashInvokeArgsMap2x1<TResult>;
        <TResult>(method: (...args: any[]) => TResult, args: readonly any[]): LodashInvokeArgsMap2x3<TResult>;
        <TResult>(method: (...args: any[]) => TResult, args: lodash.__, collection: object | null | undefined): LodashInvokeArgsMap2x5<TResult>;
        <TResult>(method: (...args: any[]) => TResult, args: readonly any[], collection: object | null | undefined): TResult[];
    }
    interface LodashInvokeArgsMap1x1 {
        (args: readonly any[]): LodashInvokeArgsMap1x3;
        (args: lodash.__, collection: object | null | undefined): LodashInvokeArgsMap1x5;
        (args: readonly any[], collection: object | null | undefined): any[];
    }
    interface LodashInvokeArgsMap1x2 {
        (methodName: string): LodashInvokeArgsMap1x3;
        (methodNameOrMethod: lodash.__, collection: object | null | undefined): LodashInvokeArgsMap1x6;
        (methodName: string, collection: object | null | undefined): any[];
        <TResult>(method: (...args: any[]) => TResult): LodashInvokeArgsMap2x3<TResult>;
        <TResult>(method: (...args: any[]) => TResult, collection: object | null | undefined): TResult[];
    }
    type LodashInvokeArgsMap1x3 = (collection: object | null | undefined) => any[];
    interface LodashInvokeArgsMap1x4 {
        (methodName: string): LodashInvokeArgsMap1x5;
        (methodNameOrMethod: lodash.__, args: readonly any[]): LodashInvokeArgsMap1x6;
        (methodName: string, args: readonly any[]): any[];
        <TResult>(method: (...args: any[]) => TResult): LodashInvokeArgsMap2x5<TResult>;
        <TResult>(method: (...args: any[]) => TResult, args: readonly any[]): TResult[];
    }
    type LodashInvokeArgsMap1x5 = (args: readonly any[]) => any[];
    interface LodashInvokeArgsMap1x6 {
        (methodName: string): any[];
        <TResult>(method: (...args: any[]) => TResult): TResult[];
    }
    interface LodashInvokeArgsMap2x1<TResult> {
        (args: readonly any[]): LodashInvokeArgsMap2x3<TResult>;
        (args: lodash.__, collection: object | null | undefined): LodashInvokeArgsMap2x5<TResult>;
        (args: readonly any[], collection: object | null | undefined): TResult[];
    }
    type LodashInvokeArgsMap2x3<TResult> = (collection: object | null | undefined) => TResult[];
    type LodashInvokeArgsMap2x5<TResult> = (args: readonly any[]) => TResult[];
    interface LodashInvokeMap {
        (methodName: string): LodashInvokeMap1x1;
        (methodNameOrMethod: lodash.__, collection: object | null | undefined): LodashInvokeMap1x2;
        (methodName: string, collection: object | null | undefined): any[];
        <TResult>(method: (...args: any[]) => TResult): LodashInvokeMap2x1<TResult>;
        <TResult>(method: (...args: any[]) => TResult, collection: object | null | undefined): TResult[];
    }
    type LodashInvokeMap1x1 = (collection: object | null | undefined) => any[];
    interface LodashInvokeMap1x2 {
        (methodName: string): any[];
        <TResult>(method: (...args: any[]) => TResult): TResult[];
    }
    type LodashInvokeMap2x1<TResult> = (collection: object | null | undefined) => TResult[];
    type LodashIsArguments = (value: any) => value is IArguments;
    type LodashIsArray = (value: any) => value is any[];
    type LodashIsArrayBuffer = (value: any) => value is ArrayBuffer;
    interface LodashIsArrayLike {
        <T extends { __lodashAnyHack: any }>(t: T): boolean;
        (value: ((...args: any[]) => any) | null | undefined): value is never;
        (value: any): value is { length: number };
    }
    interface LodashIsArrayLikeObject {
        <T extends { __lodashAnyHack: any }>(value: T): boolean;
        (value: ((...args: any[]) => any) | lodash.FunctionBase | string | boolean | number | null | undefined): value is never;
        (value: any): value is object & { length: number };
    }
    type LodashIsBoolean = (value: any) => value is boolean;
    type LodashIsBuffer = (value: any) => boolean;
    type LodashIsDate = (value: any) => value is Date;
    type LodashIsElement = (value: any) => boolean;
    interface LodashIsEmpty {
        <T extends { __trapAny: any }>(value: T): boolean;
        (value: string | null | undefined): value is '' | null | undefined;
        (value: any[] | null | undefined): boolean;
        (value: readonly any[] | null | undefined): value is Readonly<[]> | null | undefined;
        (value: Map<any, any> | Set<any> | lodash.List<any> | null | undefined): boolean;
        <T extends object>(value: T | null | undefined): value is lodash.EmptyObjectOf<T> | null | undefined;
        (value?: any): boolean;
    }
    interface LodashIsEqualWith {
        (customizer: lodash.IsEqualCustomizer): LodashIsEqualWith1x1;
        (customizer: lodash.__, value: any): LodashIsEqualWith1x2;
        (customizer: lodash.IsEqualCustomizer, value: any): LodashIsEqualWith1x3;
        (customizer: lodash.__, value: lodash.__, other: any): LodashIsEqualWith1x4;
        (customizer: lodash.IsEqualCustomizer, value: lodash.__, other: any): LodashIsEqualWith1x5;
        (customizer: lodash.__, value: any, other: any): LodashIsEqualWith1x6;
        (customizer: lodash.IsEqualCustomizer, value: any, other: any): boolean;
    }
    interface LodashIsEqualWith1x1 {
        (value: any): LodashIsEqualWith1x3;
        (value: lodash.__, other: any): LodashIsEqualWith1x5;
        (value: any, other: any): boolean;
    }
    interface LodashIsEqualWith1x2 {
        (customizer: lodash.IsEqualCustomizer): LodashIsEqualWith1x3;
        (customizer: lodash.__, other: any): LodashIsEqualWith1x6;
        (customizer: lodash.IsEqualCustomizer, other: any): boolean;
    }
    type LodashIsEqualWith1x3 = (other: any) => boolean;
    interface LodashIsEqualWith1x4 {
        (customizer: lodash.IsEqualCustomizer): LodashIsEqualWith1x5;
        (customizer: lodash.__, value: any): LodashIsEqualWith1x6;
        (customizer: lodash.IsEqualCustomizer, value: any): boolean;
    }
    type LodashIsEqualWith1x5 = (value: any) => boolean;
    type LodashIsEqualWith1x6 = (customizer: lodash.IsEqualCustomizer) => boolean;
    type LodashIsError = (value: any) => value is Error;
    type LodashIsFinite = (value: any) => boolean;
    type LodashIsFunction = (value: any) => value is (...args: any[]) => any;
    type LodashIsInteger = (value: any) => boolean;
    type LodashIsLength = (value: any) => boolean;
    type LodashIsMap = (value: any) => value is Map<any, any>;
    interface LodashIsMatch {
        (source: object): LodashIsMatch1x1;
        (source: lodash.__, object: object): LodashIsMatch1x2;
        (source: object, object: object): boolean;
    }
    type LodashIsMatch1x1 = (object: object) => boolean;
    type LodashIsMatch1x2 = (source: object) => boolean;
    interface LodashIsMatchWith {
        (customizer: lodash.isMatchWithCustomizer): LodashIsMatchWith1x1;
        (customizer: lodash.__, source: object): LodashIsMatchWith1x2;
        (customizer: lodash.isMatchWithCustomizer, source: object): LodashIsMatchWith1x3;
        (customizer: lodash.__, source: lodash.__, object: object): LodashIsMatchWith1x4;
        (customizer: lodash.isMatchWithCustomizer, source: lodash.__, object: object): LodashIsMatchWith1x5;
        (customizer: lodash.__, source: object, object: object): LodashIsMatchWith1x6;
        (customizer: lodash.isMatchWithCustomizer, source: object, object: object): boolean;
    }
    interface LodashIsMatchWith1x1 {
        (source: object): LodashIsMatchWith1x3;
        (source: lodash.__, object: object): LodashIsMatchWith1x5;
        (source: object, object: object): boolean;
    }
    interface LodashIsMatchWith1x2 {
        (customizer: lodash.isMatchWithCustomizer): LodashIsMatchWith1x3;
        (customizer: lodash.__, object: object): LodashIsMatchWith1x6;
        (customizer: lodash.isMatchWithCustomizer, object: object): boolean;
    }
    type LodashIsMatchWith1x3 = (object: object) => boolean;
    interface LodashIsMatchWith1x4 {
        (customizer: lodash.isMatchWithCustomizer): LodashIsMatchWith1x5;
        (customizer: lodash.__, source: object): LodashIsMatchWith1x6;
        (customizer: lodash.isMatchWithCustomizer, source: object): boolean;
    }
    type LodashIsMatchWith1x5 = (source: object) => boolean;
    type LodashIsMatchWith1x6 = (customizer: lodash.isMatchWithCustomizer) => boolean;
    type LodashIsNaN = (value: any) => boolean;
    type LodashIsNative = (value: any) => value is (...args: any[]) => any;
    type LodashIsNil = (value: any) => value is null | undefined;
    type LodashIsNull = (value: any) => value is null;
    type LodashIsNumber = (value: any) => value is number;
    type LodashIsObject = (value: any) => value is object;
    type LodashIsObjectLike = (value: any) => boolean;
    type LodashIsPlainObject = (value: any) => boolean;
    type LodashIsRegExp = (value: any) => value is RegExp;
    type LodashIsSafeInteger = (value: any) => boolean;
    type LodashIsSet = (value: any) => value is Set<any>;
    type LodashIsString = (value: any) => value is string;
    type LodashIsSymbol = (value: any) => value is symbol;
    type LodashIsTypedArray = (value: any) => boolean;
    type LodashIsUndefined = (value: any) => value is undefined;
    type LodashIsWeakMap = (value: any) => value is WeakMap<object, any>;
    type LodashIsWeakSet = (value: any) => value is WeakSet<object>;
    interface LodashIteratee {
        <TFunction extends (...args: any[]) => any>(func: TFunction): TFunction;
        (func: string | object): (...args: any[]) => any;
    }
    interface LodashJoin {
        (separator: string): LodashJoin1x1;
        (separator: lodash.__, array: lodash.List<any> | null | undefined): LodashJoin1x2;
        (separator: string, array: lodash.List<any> | null | undefined): string;
    }
    type LodashJoin1x1 = (array: lodash.List<any> | null | undefined) => string;
    type LodashJoin1x2 = (separator: string) => string;
    type LodashOver = <TResult>(iteratees: lodash.Many<(...args: any[]) => TResult>) => (...args: any[]) => TResult[];
    type LodashKebabCase = (string: string) => string;
    type LodashKeys = (object: any) => string[];
    type LodashKeysIn = (object: any) => string[];
    type LodashLast = <T>(array: lodash.List<T> | null | undefined) => T | undefined;
    interface LodashLastIndexOf {
        <T>(value: T): LodashLastIndexOf1x1<T>;
        <T>(value: lodash.__, array: lodash.List<T> | null | undefined): LodashLastIndexOf1x2<T>;
        <T>(value: T, array: lodash.List<T> | null | undefined): number;
    }
    type LodashLastIndexOf1x1<T> = (array: lodash.List<T> | null | undefined) => number;
    type LodashLastIndexOf1x2<T> = (value: T) => number;
    interface LodashLastIndexOfFrom {
        <T>(value: T): LodashLastIndexOfFrom1x1<T>;
        (value: lodash.__, fromIndex: true|number): LodashLastIndexOfFrom1x2;
        <T>(value: T, fromIndex: true|number): LodashLastIndexOfFrom1x3<T>;
        <T>(value: lodash.__, fromIndex: lodash.__, array: lodash.List<T> | null | undefined): LodashLastIndexOfFrom1x4<T>;
        <T>(value: T, fromIndex: lodash.__, array: lodash.List<T> | null | undefined): LodashLastIndexOfFrom1x5;
        <T>(value: lodash.__, fromIndex: true|number, array: lodash.List<T> | null | undefined): LodashLastIndexOfFrom1x6<T>;
        <T>(value: T, fromIndex: true|number, array: lodash.List<T> | null | undefined): number;
    }
    interface LodashLastIndexOfFrom1x1<T> {
        (fromIndex: true|number): LodashLastIndexOfFrom1x3<T>;
        (fromIndex: lodash.__, array: lodash.List<T> | null | undefined): LodashLastIndexOfFrom1x5;
        (fromIndex: true|number, array: lodash.List<T> | null | undefined): number;
    }
    interface LodashLastIndexOfFrom1x2 {
        <T>(value: T): LodashLastIndexOfFrom1x3<T>;
        <T>(value: lodash.__, array: lodash.List<T> | null | undefined): LodashLastIndexOfFrom1x6<T>;
        <T>(value: T, array: lodash.List<T> | null | undefined): number;
    }
    type LodashLastIndexOfFrom1x3<T> = (array: lodash.List<T> | null | undefined) => number;
    interface LodashLastIndexOfFrom1x4<T> {
        (value: T): LodashLastIndexOfFrom1x5;
        (value: lodash.__, fromIndex: true|number): LodashLastIndexOfFrom1x6<T>;
        (value: T, fromIndex: true|number): number;
    }
    type LodashLastIndexOfFrom1x5 = (fromIndex: true|number) => number;
    type LodashLastIndexOfFrom1x6<T> = (value: T) => number;
    type LodashLowerCase = (string: string) => string;
    type LodashLowerFirst = (string: string) => string;
    interface LodashLt {
        (value: any): LodashLt1x1;
        (value: lodash.__, other: any): LodashLt1x2;
        (value: any, other: any): boolean;
    }
    type LodashLt1x1 = (other: any) => boolean;
    type LodashLt1x2 = (value: any) => boolean;
    interface LodashLte {
        (value: any): LodashLte1x1;
        (value: lodash.__, other: any): LodashLte1x2;
        (value: any, other: any): boolean;
    }
    type LodashLte1x1 = (other: any) => boolean;
    type LodashLte1x2 = (value: any) => boolean;
    interface LodashMap {
        <T, TResult>(iteratee: (value: T) => TResult): LodashMap1x1<T, TResult>;
        <T>(iteratee: lodash.__, collection: T[] | null | undefined): LodashMap1x2<T>;
        <T, TResult>(iteratee: (value: T) => TResult, collection: T[] | lodash.List<T> | null | undefined): TResult[];
        <T>(iteratee: lodash.__, collection: lodash.List<T> | null | undefined): LodashMap2x2<T>;
        <T extends object, TResult>(iteratee: (value: T[keyof T]) => TResult): LodashMap3x1<T, TResult>;
        <T extends object>(iteratee: lodash.__, collection: T | null | undefined): LodashMap3x2<T>;
        <T extends object, TResult>(iteratee: (value: T[keyof T]) => TResult, collection: T | null | undefined): TResult[];
        <T, K extends keyof T>(iteratee: K): LodashMap4x1<T, K>;
        <T>(iteratee: lodash.__, collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): LodashMap4x2<T>;
        <T, K extends keyof T>(iteratee: K, collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): Array<T[K]>;
        (iteratee: string): LodashMap5x1;
        <T>(iteratee: string, collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): any[];
        (iteratee: object): LodashMap6x1;
        <T>(iteratee: object, collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): boolean[];
    }
    type LodashMap1x1<T, TResult> = (collection: T[] | lodash.List<T> | null | undefined) => TResult[];
    type LodashMap1x2<T> = <TResult>(iteratee: (value: T) => TResult) => TResult[];
    type LodashMap2x2<T> = <TResult>(iteratee: (value: T) => TResult) => TResult[];
    type LodashMap3x1<T, TResult> = (collection: T | null | undefined) => TResult[];
    type LodashMap3x2<T> = <TResult>(iteratee: (value: T[keyof T]) => TResult) => TResult[];
    type LodashMap4x1<T, K extends keyof T> = (collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined) => Array<T[K]>;
    interface LodashMap4x2<T> {
        <K extends keyof T>(iteratee: K): Array<T[K]>;
        (iteratee: string): any[];
        (iteratee: object): boolean[];
    }
    type LodashMap5x1 = <T>(collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined) => any[];
    type LodashMap6x1 = <T>(collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined) => boolean[];
    interface LodashMapKeys {
        (iteratee: lodash.ValueIteratee<number>): LodashMapKeys1x1;
        <T>(iteratee: lodash.__, object: lodash.List<T> | null | undefined): LodashMapKeys1x2<T>;
        <T>(iteratee: lodash.ValueIteratee<number>, object: lodash.List<T> | null | undefined): lodash.Dictionary<T>;
        (iteratee: lodash.ValueIteratee<string>): LodashMapKeys2x1;
        <T extends object>(iteratee: lodash.__, object: T | null | undefined): LodashMapKeys2x2<T>;
        <T extends object>(iteratee: lodash.ValueIteratee<string>, object: T | null | undefined): lodash.Dictionary<T[keyof T]>;
    }
    type LodashMapKeys1x1 = <T>(object: lodash.List<T> | null | undefined) => lodash.Dictionary<T>;
    type LodashMapKeys1x2<T> = (iteratee: lodash.ValueIteratee<number>) => lodash.Dictionary<T>;
    type LodashMapKeys2x1 = <T extends object>(object: T | null | undefined) => lodash.Dictionary<T[keyof T]>;
    type LodashMapKeys2x2<T> = (iteratee: lodash.ValueIteratee<string>) => lodash.Dictionary<T[keyof T]>;
    interface LodashMapValues {
        <T, TResult>(callback: (value: T) => TResult): LodashMapValues1x1<T, TResult>;
        <T>(callbackOrIterateeOrIterateeOrIteratee: lodash.__, obj: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): LodashMapValues1x2<T>;
        <T, TResult>(callback: (value: T) => TResult, obj: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): lodash.Dictionary<TResult>;
        <T extends object, TResult>(callback: (value: T[keyof T]) => TResult): LodashMapValues2x1<T, TResult>;
        <T extends object>(callbackOrIterateeOrIteratee: lodash.__, obj: T | null | undefined): LodashMapValues2x2<T>;
        <T extends object, TResult>(callback: (value: T[keyof T]) => TResult, obj: T | null | undefined): { [P in keyof T]: TResult };
        (iteratee: object): LodashMapValues3x1;
        <T>(iteratee: object, obj: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): lodash.Dictionary<boolean>;
        <T extends object>(iteratee: object, obj: T | null | undefined): { [P in keyof T]: boolean };
        <T, TKey extends keyof T>(iteratee: TKey): LodashMapValues5x1<T, TKey>;
        <T, TKey extends keyof T>(iteratee: TKey, obj: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): lodash.Dictionary<T[TKey]>;
        (iteratee: string): LodashMapValues6x1;
        <T>(iteratee: string, obj: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): lodash.Dictionary<any>;
        <T extends object>(iteratee: string, obj: T | null | undefined): { [P in keyof T]: any };
    }
    type LodashMapValues1x1<T, TResult> = (obj: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined) => lodash.Dictionary<TResult>;
    interface LodashMapValues1x2<T> {
        <TResult>(callback: (value: T) => TResult): lodash.Dictionary<TResult>;
        (iteratee: object): lodash.Dictionary<boolean>;
        <TKey extends keyof T>(iteratee: TKey): lodash.Dictionary<T[TKey]>;
        (iteratee: string): lodash.Dictionary<any>;
    }
    type LodashMapValues2x1<T, TResult> = (obj: T | null | undefined) => { [P in keyof T]: TResult };
    interface LodashMapValues2x2<T> {
        <TResult>(callback: (value: T[keyof T]) => TResult): { [P in keyof T]: TResult };
        (iteratee: object): { [P in keyof T]: boolean };
        (iteratee: string): { [P in keyof T]: any };
    }
    interface LodashMapValues3x1 {
        <T>(obj: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): lodash.Dictionary<boolean>;
        <T extends object>(obj: T | null | undefined): { [P in keyof T]: boolean };
    }
    type LodashMapValues5x1<T, TKey extends keyof T> = (obj: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined) => lodash.Dictionary<T[TKey]>;
    interface LodashMapValues6x1 {
        <T>(obj: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): lodash.Dictionary<any>;
        <T extends object>(obj: T | null | undefined): { [P in keyof T]: any };
    }
    interface LodashMatchesProperty {
        (path: lodash.PropertyPath): LodashMatchesProperty1x1;
        <T>(path: lodash.__, srcValue: T): LodashMatchesProperty1x2;
        <T>(path: lodash.PropertyPath, srcValue: T): (value: any) => boolean;
    }
    type LodashMatchesProperty1x1 = <T>(srcValue: T) => (value: any) => boolean;
    type LodashMatchesProperty1x2 = (path: lodash.PropertyPath) => (value: any) => boolean;
    type LodashMax = <T>(collection: lodash.List<T> | null | undefined) => T | undefined;
    interface LodashMaxBy {
        <T>(iteratee: lodash.ValueIteratee<T>): LodashMaxBy1x1<T>;
        <T>(iteratee: lodash.__, collection: lodash.List<T> | null | undefined): LodashMaxBy1x2<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, collection: lodash.List<T> | null | undefined): T | undefined;
    }
    type LodashMaxBy1x1<T> = (collection: lodash.List<T> | null | undefined) => T | undefined;
    type LodashMaxBy1x2<T> = (iteratee: lodash.ValueIteratee<T>) => T | undefined;
    type LodashMean = (collection: lodash.List<any> | null | undefined) => number;
    interface LodashMeanBy {
        <T>(iteratee: lodash.ValueIteratee<T>): LodashMeanBy1x1<T>;
        <T>(iteratee: lodash.__, collection: lodash.List<T> | null | undefined): LodashMeanBy1x2<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, collection: lodash.List<T> | null | undefined): number;
    }
    type LodashMeanBy1x1<T> = (collection: lodash.List<T> | null | undefined) => number;
    type LodashMeanBy1x2<T> = (iteratee: lodash.ValueIteratee<T>) => number;
    type LodashMemoize = <T extends (...args: any) => any>(func: T) => T & lodash.MemoizedFunction;
    interface LodashMerge {
        <TObject>(object: TObject): LodashMerge1x1<TObject>;
        <TSource>(object: lodash.__, source: TSource): LodashMerge1x2<TSource>;
        <TObject, TSource>(object: TObject, source: TSource): TObject & TSource;
    }
    type LodashMerge1x1<TObject> = <TSource>(source: TSource) => TObject & TSource;
    type LodashMerge1x2<TSource> = <TObject>(object: TObject) => TObject & TSource;
    interface LodashMergeAll {
        <TObject, TSource>(object: [TObject, TSource]): TObject & TSource;
        <TObject, TSource1, TSource2>(object: [TObject, TSource1, TSource2]): TObject & TSource1 & TSource2;
        <TObject, TSource1, TSource2, TSource3>(object: [TObject, TSource1, TSource2, TSource3]): TObject & TSource1 & TSource2 & TSource3;
        <TObject, TSource1, TSource2, TSource3, TSource4>(object: [TObject, TSource1, TSource2, TSource3, TSource4]): TObject & TSource1 & TSource2 & TSource3 & TSource4;
        (object: readonly any[]): any;
    }
    interface LodashMergeAllWith {
        (customizer: lodash.MergeWithCustomizer): LodashMergeAllWith1x1;
        (customizer: lodash.__, args: readonly any[]): LodashMergeAllWith1x2;
        (customizer: lodash.MergeWithCustomizer, args: readonly any[]): any;
    }
    type LodashMergeAllWith1x1 = (args: readonly any[]) => any;
    type LodashMergeAllWith1x2 = (customizer: lodash.MergeWithCustomizer) => any;
    interface LodashMergeWith {
        (customizer: lodash.MergeWithCustomizer): LodashMergeWith1x1;
        <TObject>(customizer: lodash.__, object: TObject): LodashMergeWith1x2<TObject>;
        <TObject>(customizer: lodash.MergeWithCustomizer, object: TObject): LodashMergeWith1x3<TObject>;
        <TSource>(customizer: lodash.__, object: lodash.__, source: TSource): LodashMergeWith1x4<TSource>;
        <TSource>(customizer: lodash.MergeWithCustomizer, object: lodash.__, source: TSource): LodashMergeWith1x5<TSource>;
        <TObject, TSource>(customizer: lodash.__, object: TObject, source: TSource): LodashMergeWith1x6<TObject, TSource>;
        <TObject, TSource>(customizer: lodash.MergeWithCustomizer, object: TObject, source: TSource): TObject & TSource;
    }
    interface LodashMergeWith1x1 {
        <TObject>(object: TObject): LodashMergeWith1x3<TObject>;
        <TSource>(object: lodash.__, source: TSource): LodashMergeWith1x5<TSource>;
        <TObject, TSource>(object: TObject, source: TSource): TObject & TSource;
    }
    interface LodashMergeWith1x2<TObject> {
        (customizer: lodash.MergeWithCustomizer): LodashMergeWith1x3<TObject>;
        <TSource>(customizer: lodash.__, source: TSource): LodashMergeWith1x6<TObject, TSource>;
        <TSource>(customizer: lodash.MergeWithCustomizer, source: TSource): TObject & TSource;
    }
    type LodashMergeWith1x3<TObject> = <TSource>(source: TSource) => TObject & TSource;
    interface LodashMergeWith1x4<TSource> {
        (customizer: lodash.MergeWithCustomizer): LodashMergeWith1x5<TSource>;
        <TObject>(customizer: lodash.__, object: TObject): LodashMergeWith1x6<TObject, TSource>;
        <TObject>(customizer: lodash.MergeWithCustomizer, object: TObject): TObject & TSource;
    }
    type LodashMergeWith1x5<TSource> = <TObject>(object: TObject) => TObject & TSource;
    type LodashMergeWith1x6<TObject, TSource> = (customizer: lodash.MergeWithCustomizer) => TObject & TSource;
    type LodashMethod = (path: lodash.PropertyPath) => (object: any) => any;
    type LodashMethodOf = (object: object) => (path: lodash.PropertyPath) => any;
    type LodashMin = <T>(collection: lodash.List<T> | null | undefined) => T | undefined;
    interface LodashMinBy {
        <T>(iteratee: lodash.ValueIteratee<T>): LodashMinBy1x1<T>;
        <T>(iteratee: lodash.__, collection: lodash.List<T> | null | undefined): LodashMinBy1x2<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, collection: lodash.List<T> | null | undefined): T | undefined;
    }
    type LodashMinBy1x1<T> = (collection: lodash.List<T> | null | undefined) => T | undefined;
    type LodashMinBy1x2<T> = (iteratee: lodash.ValueIteratee<T>) => T | undefined;
    interface LodashMultiply {
        (multiplier: number): LodashMultiply1x1;
        (multiplier: lodash.__, multiplicand: number): LodashMultiply1x2;
        (multiplier: number, multiplicand: number): number;
    }
    type LodashMultiply1x1 = (multiplicand: number) => number;
    type LodashMultiply1x2 = (multiplier: number) => number;
    type LodashNoConflict = () => typeof _;
    type LodashNoop = (...args: any[]) => void;
    type LodashNow = () => number;
    interface LodashNth {
        (n: number): LodashNth1x1;
        <T>(n: lodash.__, array: lodash.List<T> | null | undefined): LodashNth1x2<T>;
        <T>(n: number, array: lodash.List<T> | null | undefined): T | undefined;
    }
    type LodashNth1x1 = <T>(array: lodash.List<T> | null | undefined) => T | undefined;
    type LodashNth1x2<T> = (n: number) => T | undefined;
    type LodashNthArg = (n: number) => (...args: any[]) => any;
    interface LodashOmit {
        <T extends object, K extends keyof T>(paths: lodash.Many<K>): LodashOmit1x1<T, K>;
        <T extends object>(paths: lodash.__, object: T | null | undefined): LodashOmit1x2<T>;
        <T extends object, K extends keyof T>(paths: lodash.Many<K>, object: T | null | undefined): lodash.Omit<T, K>;
        (paths: lodash.Many<lodash.PropertyName>): LodashOmit2x1;
        <T extends object>(paths: lodash.Many<lodash.PropertyName>, object: T | null | undefined): lodash.PartialObject<T>;
    }
    type LodashOmit1x1<T, K extends keyof T> = (object: T | null | undefined) => lodash.Omit<T, K>;
    interface LodashOmit1x2<T> {
        <K extends keyof T>(paths: lodash.Many<K>): lodash.Omit<T, K>;
        (paths: lodash.Many<lodash.PropertyName>): lodash.PartialObject<T>;
    }
    type LodashOmit2x1 = <T extends object>(object: T | null | undefined) => lodash.PartialObject<T>;
    interface LodashOmitBy {
        <T>(predicate: lodash.ValueKeyIteratee<T>): LodashOmitBy1x1<T>;
        <T>(predicate: lodash.__, object: lodash.Dictionary<T> | null | undefined): LodashOmitBy1x2<T>;
        <T>(predicate: lodash.ValueKeyIteratee<T>, object: lodash.Dictionary<T> | null | undefined): lodash.Dictionary<T>;
        <T>(predicate: lodash.__, object: lodash.NumericDictionary<T> | null | undefined): LodashOmitBy2x2<T>;
        <T>(predicate: lodash.ValueKeyIteratee<T>, object: lodash.NumericDictionary<T> | null | undefined): lodash.NumericDictionary<T>;
        <T extends object>(predicate: lodash.__, object: T | null | undefined): LodashOmitBy3x2<T>;
        <T extends object>(predicate: lodash.ValueKeyIteratee<T[keyof T]>, object: T | null | undefined): lodash.PartialObject<T>;
    }
    interface LodashOmitBy1x1<T> {
        (object: lodash.Dictionary<T> | null | undefined): lodash.Dictionary<T>;
        (object: lodash.NumericDictionary<T> | null | undefined): lodash.NumericDictionary<T>;
        <T1 extends object>(object: T1 | null | undefined): lodash.PartialObject<T1>;
    }
    type LodashOmitBy1x2<T> = (predicate: lodash.ValueKeyIteratee<T>) => lodash.Dictionary<T>;
    type LodashOmitBy2x2<T> = (predicate: lodash.ValueKeyIteratee<T>) => lodash.NumericDictionary<T>;
    type LodashOmitBy3x2<T> = (predicate: lodash.ValueKeyIteratee<T[keyof T]>) => lodash.PartialObject<T>;
    type LodashOnce = <T extends (...args: any) => any>(func: T) => T;
    interface LodashOrderBy {
        <T>(iteratees: lodash.Many<(value: T) => lodash.NotVoid>): LodashOrderBy1x1<T>;
        (iteratees: lodash.__, orders: lodash.Many<boolean|"asc"|"desc">): LodashOrderBy1x2;
        <T>(iteratees: lodash.Many<(value: T) => lodash.NotVoid>, orders: lodash.Many<boolean|"asc"|"desc">): LodashOrderBy1x3<T>;
        <T>(iteratees: lodash.__, orders: lodash.__, collection: lodash.List<T> | null | undefined): LodashOrderBy1x4<T>;
        <T>(iteratees: lodash.Many<(value: T) => lodash.NotVoid>, orders: lodash.__, collection: lodash.List<T> | null | undefined): LodashOrderBy1x5<T>;
        <T>(iteratees: lodash.__, orders: lodash.Many<boolean|"asc"|"desc">, collection: lodash.List<T> | null | undefined): LodashOrderBy1x6<T>;
        <T>(iteratees: lodash.Many<(value: T) => lodash.NotVoid> | lodash.Many<lodash.ValueIteratee<T>>, orders: lodash.Many<boolean | "asc" | "desc">, collection: lodash.List<T> | null | undefined): T[];
        <T>(iteratees: lodash.Many<lodash.ValueIteratee<T>>): LodashOrderBy2x1<T>;
        <T>(iteratees: lodash.Many<lodash.ValueIteratee<T>>, orders: lodash.Many<boolean|"asc"|"desc">): LodashOrderBy2x3<T>;
        <T>(iteratees: lodash.Many<lodash.ValueIteratee<T>>, orders: lodash.__, collection: lodash.List<T> | null | undefined): LodashOrderBy2x5<T>;
        <T extends object>(iteratees: lodash.__, orders: lodash.__, collection: T | null | undefined): LodashOrderBy3x4<T>;
        <T extends object>(iteratees: lodash.Many<(value: T[keyof T]) => lodash.NotVoid>, orders: lodash.__, collection: T | null | undefined): LodashOrderBy3x5<T>;
        <T extends object>(iteratees: lodash.__, orders: lodash.Many<boolean|"asc"|"desc">, collection: T | null | undefined): LodashOrderBy3x6<T>;
        <T extends object>(iteratees: lodash.Many<(value: T[keyof T]) => lodash.NotVoid> | lodash.Many<lodash.ValueIteratee<T[keyof T]>>, orders: lodash.Many<boolean | "asc" | "desc">, collection: T | null | undefined): Array<T[keyof T]>;
        <T extends object>(iteratees: lodash.Many<lodash.ValueIteratee<T[keyof T]>>, orders: lodash.__, collection: T | null | undefined): LodashOrderBy4x5<T>;
    }
    interface LodashOrderBy1x1<T> {
        (orders: lodash.Many<boolean | "asc" | "desc">): LodashOrderBy1x3<T>;
        (orders: lodash.__, collection: lodash.List<T> | null | undefined): LodashOrderBy1x5<T>;
        (orders: lodash.Many<boolean | "asc" | "desc">, collection: lodash.List<T> | object | null | undefined): T[];
        <T1 extends object>(orders: lodash.__, collection: T1 | null | undefined): LodashOrderBy3x5<T>;
    }
    interface LodashOrderBy1x2 {
        <T>(iteratees: lodash.Many<(value: T) => lodash.NotVoid>): LodashOrderBy1x3<T>;
        <T>(iteratees: lodash.__, collection: lodash.List<T> | null | undefined): LodashOrderBy1x6<T>;
        <T>(iteratees: lodash.Many<(value: T) => lodash.NotVoid> | lodash.Many<lodash.ValueIteratee<T>>, collection: lodash.List<T> | null | undefined): T[];
        <T>(iteratees: lodash.Many<lodash.ValueIteratee<T>>): LodashOrderBy2x3<T>;
        <T extends object>(iteratees: lodash.__, collection: T | null | undefined): LodashOrderBy3x6<T>;
        <T extends object>(iteratees: lodash.Many<(value: T[keyof T]) => lodash.NotVoid> | lodash.Many<lodash.ValueIteratee<T[keyof T]>>, collection: T | null | undefined): Array<T[keyof T]>;
    }
    interface LodashOrderBy1x3<T> {
        (collection: lodash.List<T> | null | undefined): T[];
        (collection: object | null | undefined): object[];
    }
    interface LodashOrderBy1x4<T> {
        (iteratees: lodash.Many<(value: T) => lodash.NotVoid>): LodashOrderBy1x5<T>;
        (iteratees: lodash.__, orders: lodash.Many<boolean | "asc" | "desc">): LodashOrderBy1x6<T>;
        (iteratees: lodash.Many<(value: T) => lodash.NotVoid> | lodash.Many<lodash.ValueIteratee<T>>, orders: lodash.Many<boolean | "asc" | "desc">): T[];
        (iteratees: lodash.Many<lodash.ValueIteratee<T>>): LodashOrderBy2x5<T>;
    }
    type LodashOrderBy1x5<T> = (orders: lodash.Many<boolean|"asc"|"desc">) => T[];
    type LodashOrderBy1x6<T> = (iteratees: lodash.Many<(value: T) => lodash.NotVoid> | lodash.Many<lodash.ValueIteratee<T>>) => T[];
    interface LodashOrderBy2x1<T> {
        (orders: lodash.Many<boolean | "asc" | "desc">): LodashOrderBy2x3<T>;
        (orders: lodash.__, collection: lodash.List<T> | null | undefined): LodashOrderBy2x5<T>;
        (orders: lodash.Many<boolean | "asc" | "desc">, collection: lodash.List<T> | object | null | undefined): T[];
        <T1 extends object>(orders: lodash.__, collection: T1 | null | undefined): LodashOrderBy4x5<T>;
    }
    interface LodashOrderBy2x3<T> {
        (collection: lodash.List<T> | null | undefined): T[];
        (collection: object | null | undefined): object[];
    }
    type LodashOrderBy2x5<T> = (orders: lodash.Many<boolean|"asc"|"desc">) => T[];
    interface LodashOrderBy3x4<T> {
        (iteratees: lodash.Many<(value: T[keyof T]) => lodash.NotVoid>): LodashOrderBy3x5<T>;
        (iteratees: lodash.__, orders: lodash.Many<boolean | "asc" | "desc">): LodashOrderBy3x6<T>;
        (iteratees: lodash.Many<(value: T[keyof T]) => lodash.NotVoid> | lodash.Many<lodash.ValueIteratee<T[keyof T]>>, orders: lodash.Many<boolean | "asc" | "desc">): Array<T[keyof T]>;
        (iteratees: lodash.Many<lodash.ValueIteratee<T[keyof T]>>): LodashOrderBy4x5<T>;
    }
    type LodashOrderBy3x5<T> = (orders: lodash.Many<boolean|"asc"|"desc">) => Array<T[keyof T]>;
    type LodashOrderBy3x6<T> = (iteratees: lodash.Many<(value: T[keyof T]) => lodash.NotVoid> | lodash.Many<lodash.ValueIteratee<T[keyof T]>>) => Array<T[keyof T]>;
    type LodashOrderBy4x5<T> = (orders: lodash.Many<boolean|"asc"|"desc">) => Array<T[keyof T]>;
    interface LodashOverArgs {
        (func: (...args: any[]) => any): LodashOverArgs1x1;
        (func: lodash.__, transforms: lodash.Many<(...args: any[]) => any>): LodashOverArgs1x2;
        (func: (...args: any[]) => any, transforms: lodash.Many<(...args: any[]) => any>): (...args: any[]) => any;
    }
    type LodashOverArgs1x1 = (transforms: lodash.Many<(...args: any[]) => any>) => (...args: any[]) => any;
    type LodashOverArgs1x2 = (func: (...args: any[]) => any) => (...args: any[]) => any;
    interface LodashPad {
        (length: number): LodashPad1x1;
        (length: lodash.__, string: string): LodashPad1x2;
        (length: number, string: string): string;
    }
    type LodashPad1x1 = (string: string) => string;
    type LodashPad1x2 = (length: number) => string;
    interface LodashPadChars {
        (chars: string): LodashPadChars1x1;
        (chars: lodash.__, length: number): LodashPadChars1x2;
        (chars: string, length: number): LodashPadChars1x3;
        (chars: lodash.__, length: lodash.__, string: string): LodashPadChars1x4;
        (chars: string, length: lodash.__, string: string): LodashPadChars1x5;
        (chars: lodash.__, length: number, string: string): LodashPadChars1x6;
        (chars: string, length: number, string: string): string;
    }
    interface LodashPadChars1x1 {
        (length: number): LodashPadChars1x3;
        (length: lodash.__, string: string): LodashPadChars1x5;
        (length: number, string: string): string;
    }
    interface LodashPadChars1x2 {
        (chars: string): LodashPadChars1x3;
        (chars: lodash.__, string: string): LodashPadChars1x6;
        (chars: string, string: string): string;
    }
    type LodashPadChars1x3 = (string: string) => string;
    interface LodashPadChars1x4 {
        (chars: string): LodashPadChars1x5;
        (chars: lodash.__, length: number): LodashPadChars1x6;
        (chars: string, length: number): string;
    }
    type LodashPadChars1x5 = (length: number) => string;
    type LodashPadChars1x6 = (chars: string) => string;
    interface LodashPadCharsEnd {
        (chars: string): LodashPadCharsEnd1x1;
        (chars: lodash.__, length: number): LodashPadCharsEnd1x2;
        (chars: string, length: number): LodashPadCharsEnd1x3;
        (chars: lodash.__, length: lodash.__, string: string): LodashPadCharsEnd1x4;
        (chars: string, length: lodash.__, string: string): LodashPadCharsEnd1x5;
        (chars: lodash.__, length: number, string: string): LodashPadCharsEnd1x6;
        (chars: string, length: number, string: string): string;
    }
    interface LodashPadCharsEnd1x1 {
        (length: number): LodashPadCharsEnd1x3;
        (length: lodash.__, string: string): LodashPadCharsEnd1x5;
        (length: number, string: string): string;
    }
    interface LodashPadCharsEnd1x2 {
        (chars: string): LodashPadCharsEnd1x3;
        (chars: lodash.__, string: string): LodashPadCharsEnd1x6;
        (chars: string, string: string): string;
    }
    type LodashPadCharsEnd1x3 = (string: string) => string;
    interface LodashPadCharsEnd1x4 {
        (chars: string): LodashPadCharsEnd1x5;
        (chars: lodash.__, length: number): LodashPadCharsEnd1x6;
        (chars: string, length: number): string;
    }
    type LodashPadCharsEnd1x5 = (length: number) => string;
    type LodashPadCharsEnd1x6 = (chars: string) => string;
    interface LodashPadCharsStart {
        (chars: string): LodashPadCharsStart1x1;
        (chars: lodash.__, length: number): LodashPadCharsStart1x2;
        (chars: string, length: number): LodashPadCharsStart1x3;
        (chars: lodash.__, length: lodash.__, string: string): LodashPadCharsStart1x4;
        (chars: string, length: lodash.__, string: string): LodashPadCharsStart1x5;
        (chars: lodash.__, length: number, string: string): LodashPadCharsStart1x6;
        (chars: string, length: number, string: string): string;
    }
    interface LodashPadCharsStart1x1 {
        (length: number): LodashPadCharsStart1x3;
        (length: lodash.__, string: string): LodashPadCharsStart1x5;
        (length: number, string: string): string;
    }
    interface LodashPadCharsStart1x2 {
        (chars: string): LodashPadCharsStart1x3;
        (chars: lodash.__, string: string): LodashPadCharsStart1x6;
        (chars: string, string: string): string;
    }
    type LodashPadCharsStart1x3 = (string: string) => string;
    interface LodashPadCharsStart1x4 {
        (chars: string): LodashPadCharsStart1x5;
        (chars: lodash.__, length: number): LodashPadCharsStart1x6;
        (chars: string, length: number): string;
    }
    type LodashPadCharsStart1x5 = (length: number) => string;
    type LodashPadCharsStart1x6 = (chars: string) => string;
    interface LodashPadEnd {
        (length: number): LodashPadEnd1x1;
        (length: lodash.__, string: string): LodashPadEnd1x2;
        (length: number, string: string): string;
    }
    type LodashPadEnd1x1 = (string: string) => string;
    type LodashPadEnd1x2 = (length: number) => string;
    interface LodashPadStart {
        (length: number): LodashPadStart1x1;
        (length: lodash.__, string: string): LodashPadStart1x2;
        (length: number, string: string): string;
    }
    type LodashPadStart1x1 = (string: string) => string;
    type LodashPadStart1x2 = (length: number) => string;
    interface LodashParseInt {
        (radix: number): LodashParseInt1x1;
        (radix: lodash.__, string: string): LodashParseInt1x2;
        (radix: number, string: string): number;
    }
    type LodashParseInt1x1 = (string: string) => number;
    type LodashParseInt1x2 = (radix: number) => number;
    interface LodashPartial {
        <T1, T2, R>(func: lodash.Function2<T1, T2, R>): LodashPartial1x1<T1, T2, R>;
        <T2>(func: lodash.__, plc1: [lodash.__, T2]): LodashPartial1x2<T2>;
        <T1, T2, R>(func: lodash.Function2<T1, T2, R>, plc1: [lodash.__, T2]): lodash.Function1<T1, R>;
        <T1, T2, T3, R>(func: lodash.Function3<T1, T2, T3, R>): LodashPartial2x1<T1, T2, T3, R>;
        <T1, T2, T3, R>(func: lodash.Function3<T1, T2, T3, R>, plc1: [lodash.__, T2]): lodash.Function2<T1, T3, R>;
        <T3>(func: lodash.__, plc1: [lodash.__, lodash.__, T3]): LodashPartial3x2<T3>;
        <T1, T2, T3, R>(func: lodash.Function3<T1, T2, T3, R>, plc1: [lodash.__, lodash.__, T3]): lodash.Function2<T1, T2, R>;
        <T1, T3>(func: lodash.__, arg1: [T1, lodash.__, T3]): LodashPartial4x2<T1, T3>;
        <T1, T2, T3, R>(func: lodash.Function3<T1, T2, T3, R>, arg1: [T1, lodash.__, T3]): lodash.Function1<T2, R>;
        <T2, T3>(func: lodash.__, plc1: [lodash.__, T2, T3]): LodashPartial5x2<T2, T3>;
        <T1, T2, T3, R>(func: lodash.Function3<T1, T2, T3, R>, plc1: [lodash.__, T2, T3]): lodash.Function1<T1, R>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>): LodashPartial6x1<T1, T2, T3, T4, R>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, plc1: [lodash.__, T2]): lodash.Function3<T1, T3, T4, R>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, plc1: [lodash.__, lodash.__, T3]): lodash.Function3<T1, T2, T4, R>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, arg1: [T1, lodash.__, T3]): lodash.Function2<T2, T4, R>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, plc1: [lodash.__, T2, T3]): lodash.Function2<T1, T4, R>;
        <T1, T2, T3>(func: lodash.__, arg1OrT1: [T1, T2, T3]): LodashPartial10x2<T1, T2, T3>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, arg1: [T1, T2, T3]): lodash.Function1<T4, R>;
        <T4>(func: lodash.__, plc1: [lodash.__, lodash.__, lodash.__, T4]): LodashPartial11x2<T4>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, plc1: [lodash.__, lodash.__, lodash.__, T4]): lodash.Function3<T1, T2, T3, R>;
        <T1, T4>(func: lodash.__, arg1: [T1, lodash.__, lodash.__, T4]): LodashPartial12x2<T1, T4>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, arg1: [T1, lodash.__, lodash.__, T4]): lodash.Function2<T2, T3, R>;
        <T2, T4>(func: lodash.__, plc1: [lodash.__, T2, lodash.__, T4]): LodashPartial13x2<T2, T4>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, plc1: [lodash.__, T2, lodash.__, T4]): lodash.Function2<T1, T3, R>;
        <T1, T2, T4>(func: lodash.__, arg1: [T1, T2, lodash.__, T4]): LodashPartial14x2<T1, T2, T4>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, arg1: [T1, T2, lodash.__, T4]): lodash.Function1<T3, R>;
        <T3, T4>(func: lodash.__, plc1: [lodash.__, lodash.__, T3, T4]): LodashPartial15x2<T3, T4>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, plc1: [lodash.__, lodash.__, T3, T4]): lodash.Function2<T1, T2, R>;
        <T1, T3, T4>(func: lodash.__, arg1: [T1, lodash.__, T3, T4]): LodashPartial16x2<T1, T3, T4>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, arg1: [T1, lodash.__, T3, T4]): lodash.Function1<T2, R>;
        <T2, T3, T4>(func: lodash.__, plc1: [lodash.__, T2, T3, T4]): LodashPartial17x2<T2, T3, T4>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, plc1: [lodash.__, T2, T3, T4]): lodash.Function1<T1, R>;
        <TS extends any[], T1, R>(func: (t1: T1, ...ts: TS) => R): LodashPartial18x1<TS, T1, R>;
        <T1>(func: lodash.__, arg1: [T1]): LodashPartial18x2<T1>;
        <TS extends any[], T1, R>(func: (t1: T1, ...ts: TS) => R, arg1: [T1]): (...ts: TS) => R;
        <TS extends any[], T1, T2, R>(func: (t1: T1, t2: T2, ...ts: TS) => R): LodashPartial19x1<TS, T1, T2, R>;
        <T1, T2>(func: lodash.__, t1: [T1, T2]): LodashPartial19x2<T1, T2>;
        <TS extends any[], T1, T2, R>(func: (t1: T1, t2: T2, ...ts: TS) => R, t1: [T1, T2]): (...ts: TS) => R;
        <TS extends any[], T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3, ...ts: TS) => R): LodashPartial20x1<TS, T1, T2, T3, R>;
        <TS extends any[], T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3, ...ts: TS) => R, t1: [T1, T2, T3]): (...ts: TS) => R;
        <TS extends any[], T1, T2, T3, T4, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4, ...ts: TS) => R): LodashPartial21x1<TS, T1, T2, T3, T4, R>;
        <T1, T2, T3, T4>(func: lodash.__, t1: [T1, T2, T3, T4]): LodashPartial21x2<T1, T2, T3, T4>;
        <TS extends any[], T1, T2, T3, T4, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4, ...ts: TS) => R, t1: [T1, T2, T3, T4]): (...ts: TS) => R;
        placeholder: lodash.__;
    }
    type LodashPartial1x1<T1, T2, R> = (plc1: [lodash.__, T2]) => lodash.Function1<T1, R>;
    interface LodashPartial1x2<T2> {
        <T1, R>(func: lodash.Function2<T1, T2, R>): lodash.Function1<T1, R>;
        <T1, T3, R>(func: lodash.Function3<T1, T2, T3, R>): lodash.Function2<T1, T3, R>;
        <T1, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>): lodash.Function3<T1, T3, T4, R>;
    }
    interface LodashPartial2x1<T1, T2, T3, R> {
        (plc1: [lodash.__, T2]): lodash.Function2<T1, T3, R>;
        (plc1: [lodash.__, lodash.__, T3]): lodash.Function2<T1, T2, R>;
        (arg1: [T1, lodash.__, T3]): lodash.Function1<T2, R>;
        (plc1: [lodash.__, T2, T3]): lodash.Function1<T1, R>;
    }
    interface LodashPartial3x2<T3> {
        <T1, T2, R>(func: lodash.Function3<T1, T2, T3, R>): lodash.Function2<T1, T2, R>;
        <T1, T2, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>): lodash.Function3<T1, T2, T4, R>;
    }
    interface LodashPartial4x2<T1, T3> {
        <T2, R>(func: lodash.Function3<T1, T2, T3, R>): lodash.Function1<T2, R>;
        <T2, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>): lodash.Function2<T2, T4, R>;
    }
    interface LodashPartial5x2<T2, T3> {
        <T1, R>(func: lodash.Function3<T1, T2, T3, R>): lodash.Function1<T1, R>;
        <T1, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>): lodash.Function2<T1, T4, R>;
    }
    interface LodashPartial6x1<T1, T2, T3, T4, R> {
        (plc1: [lodash.__, T2]): lodash.Function3<T1, T3, T4, R>;
        (plc1: [lodash.__, lodash.__, T3]): lodash.Function3<T1, T2, T4, R>;
        (arg1: [T1, lodash.__, T3]): lodash.Function2<T2, T4, R>;
        (plc1: [lodash.__, T2, T3]): lodash.Function2<T1, T4, R>;
        (arg1: [T1, T2, T3]): lodash.Function1<T4, R>;
        (plc1: [lodash.__, lodash.__, lodash.__, T4]): lodash.Function3<T1, T2, T3, R>;
        (arg1: [T1, lodash.__, lodash.__, T4]): lodash.Function2<T2, T3, R>;
        (plc1: [lodash.__, T2, lodash.__, T4]): lodash.Function2<T1, T3, R>;
        (arg1: [T1, T2, lodash.__, T4]): lodash.Function1<T3, R>;
        (plc1: [lodash.__, lodash.__, T3, T4]): lodash.Function2<T1, T2, R>;
        (arg1: [T1, lodash.__, T3, T4]): lodash.Function1<T2, R>;
        (plc1: [lodash.__, T2, T3, T4]): lodash.Function1<T1, R>;
    }
    interface LodashPartial10x2<T1, T2, T3> {
        <T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>): lodash.Function1<T4, R>;
        <TS extends any[], R>(func: (t1: T1, t2: T2, t3: T3, ...ts: TS) => R): (...ts: TS) => R;
    }
    type LodashPartial11x2<T4> = <T1, T2, T3, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function3<T1, T2, T3, R>;
    type LodashPartial12x2<T1, T4> = <T2, T3, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function2<T2, T3, R>;
    type LodashPartial13x2<T2, T4> = <T1, T3, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function2<T1, T3, R>;
    type LodashPartial14x2<T1, T2, T4> = <T3, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function1<T3, R>;
    type LodashPartial15x2<T3, T4> = <T1, T2, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function2<T1, T2, R>;
    type LodashPartial16x2<T1, T3, T4> = <T2, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function1<T2, R>;
    type LodashPartial17x2<T2, T3, T4> = <T1, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function1<T1, R>;
    type LodashPartial18x1<TS extends any[], T1, R> = (arg1: [T1]) => (...ts: TS) => R;
    type LodashPartial18x2<T1> = <TS extends any[], R>(func: (t1: T1, ...ts: TS) => R) => (...ts: TS) => R;
    type LodashPartial19x1<TS extends any[], T1, T2, R> = (t1: [T1, T2]) => (...ts: TS) => R;
    type LodashPartial19x2<T1, T2> = <TS extends any[], R>(func: (t1: T1, t2: T2, ...ts: TS) => R) => (...ts: TS) => R;
    type LodashPartial20x1<TS extends any[], T1, T2, T3, R> = (t1: [T1, T2, T3]) => (...ts: TS) => R;
    type LodashPartial21x1<TS extends any[], T1, T2, T3, T4, R> = (t1: [T1, T2, T3, T4]) => (...ts: TS) => R;
    type LodashPartial21x2<T1, T2, T3, T4> = <TS extends any[], R>(func: (t1: T1, t2: T2, t3: T3, t4: T4, ...ts: TS) => R) => (...ts: TS) => R;
    interface LodashPartialRight {
        <T1, R>(func: lodash.Function1<T1, R>): LodashPartialRight1x1<T1, R>;
        <T1>(func: lodash.__, arg1: [T1]): LodashPartialRight1x2<T1>;
        <T1, R>(func: lodash.Function1<T1, R>, arg1: [T1]): lodash.Function0<R>;
        <T1, T2, R>(func: lodash.Function2<T1, T2, R>): LodashPartialRight2x1<T1, T2, R>;
        <T1>(func: lodash.__, arg1: [T1, lodash.__]): LodashPartialRight2x2<T1>;
        <T1, T2, R>(func: lodash.Function2<T1, T2, R>, arg1: [T1, lodash.__]): lodash.Function1<T2, R>;
        <T2>(func: lodash.__, arg2: [T2]): LodashPartialRight3x2<T2>;
        <T1, T2, R>(func: lodash.Function2<T1, T2, R>, arg2: [T2]): lodash.Function1<T1, R>;
        <T1, T2>(func: lodash.__, arg1: [T1, T2]): LodashPartialRight4x2<T1, T2>;
        <T1, T2, R>(func: lodash.Function2<T1, T2, R>, arg1: [T1, T2]): lodash.Function0<R>;
        <T1, T2, T3, R>(func: lodash.Function3<T1, T2, T3, R>): LodashPartialRight5x1<T1, T2, T3, R>;
        <T1>(func: lodash.__, arg1: [T1, lodash.__, lodash.__]): LodashPartialRight5x2<T1>;
        <T1, T2, T3, R>(func: lodash.Function3<T1, T2, T3, R>, arg1: [T1, lodash.__, lodash.__]): lodash.Function2<T2, T3, R>;
        <T2>(func: lodash.__, arg2: [T2, lodash.__]): LodashPartialRight6x2<T2>;
        <T1, T2, T3, R>(func: lodash.Function3<T1, T2, T3, R>, arg2: [T2, lodash.__]): lodash.Function2<T1, T3, R>;
        <T1, T2>(func: lodash.__, arg1: [T1, T2, lodash.__]): LodashPartialRight7x2<T1, T2>;
        <T1, T2, T3, R>(func: lodash.Function3<T1, T2, T3, R>, arg1: [T1, T2, lodash.__]): lodash.Function1<T3, R>;
        <T3>(func: lodash.__, arg3: [T3]): LodashPartialRight8x2<T3>;
        <T1, T2, T3, R>(func: lodash.Function3<T1, T2, T3, R>, arg3: [T3]): lodash.Function2<T1, T2, R>;
        <T1, T3>(func: lodash.__, arg1: [T1, lodash.__, T3]): LodashPartialRight9x2<T1, T3>;
        <T1, T2, T3, R>(func: lodash.Function3<T1, T2, T3, R>, arg1: [T1, lodash.__, T3]): lodash.Function1<T2, R>;
        <T2, T3>(func: lodash.__, arg2: [T2, T3]): LodashPartialRight10x2<T2, T3>;
        <T1, T2, T3, R>(func: lodash.Function3<T1, T2, T3, R>, arg2: [T2, T3]): lodash.Function1<T1, R>;
        <T1, T2, T3>(func: lodash.__, arg1: [T1, T2, T3]): LodashPartialRight11x2<T1, T2, T3>;
        <T1, T2, T3, R>(func: lodash.Function3<T1, T2, T3, R>, arg1: [T1, T2, T3]): lodash.Function0<R>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>): LodashPartialRight12x1<T1, T2, T3, T4, R>;
        <T1>(func: lodash.__, arg1: [T1, lodash.__, lodash.__, lodash.__]): LodashPartialRight12x2<T1>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, arg1: [T1, lodash.__, lodash.__, lodash.__]): lodash.Function3<T2, T3, T4, R>;
        <T2>(func: lodash.__, arg2: [T2, lodash.__, lodash.__]): LodashPartialRight13x2<T2>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, arg2: [T2, lodash.__, lodash.__]): lodash.Function3<T1, T3, T4, R>;
        <T1, T2>(func: lodash.__, arg1: [T1, T2, lodash.__, lodash.__]): LodashPartialRight14x2<T1, T2>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, arg1: [T1, T2, lodash.__, lodash.__]): lodash.Function2<T3, T4, R>;
        <T3>(func: lodash.__, arg3: [T3, lodash.__]): LodashPartialRight15x2<T3>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, arg3: [T3, lodash.__]): lodash.Function3<T1, T2, T4, R>;
        <T1, T3>(func: lodash.__, arg1: [T1, lodash.__, T3, lodash.__]): LodashPartialRight16x2<T1, T3>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, arg1: [T1, lodash.__, T3, lodash.__]): lodash.Function2<T2, T4, R>;
        <T2, T3>(func: lodash.__, arg2: [T2, T3, lodash.__]): LodashPartialRight17x2<T2, T3>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, arg2: [T2, T3, lodash.__]): lodash.Function2<T1, T4, R>;
        <T1, T2, T3>(func: lodash.__, arg1: [T1, T2, T3, lodash.__]): LodashPartialRight18x2<T1, T2, T3>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, arg1: [T1, T2, T3, lodash.__]): lodash.Function1<T4, R>;
        <T4>(func: lodash.__, arg4: [T4]): LodashPartialRight19x2<T4>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, arg4: [T4]): lodash.Function3<T1, T2, T3, R>;
        <T1, T4>(func: lodash.__, arg1: [T1, lodash.__, lodash.__, T4]): LodashPartialRight20x2<T1, T4>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, arg1: [T1, lodash.__, lodash.__, T4]): lodash.Function2<T2, T3, R>;
        <T2, T4>(func: lodash.__, arg2: [T2, lodash.__, T4]): LodashPartialRight21x2<T2, T4>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, arg2: [T2, lodash.__, T4]): lodash.Function2<T1, T3, R>;
        <T1, T2, T4>(func: lodash.__, arg1: [T1, T2, lodash.__, T4]): LodashPartialRight22x2<T1, T2, T4>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, arg1: [T1, T2, lodash.__, T4]): lodash.Function1<T3, R>;
        <T3, T4>(func: lodash.__, arg3: [T3, T4]): LodashPartialRight23x2<T3, T4>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, arg3: [T3, T4]): lodash.Function2<T1, T2, R>;
        <T1, T3, T4>(func: lodash.__, arg1: [T1, lodash.__, T3, T4]): LodashPartialRight24x2<T1, T3, T4>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, arg1: [T1, lodash.__, T3, T4]): lodash.Function1<T2, R>;
        <T2, T3, T4>(func: lodash.__, arg2: [T2, T3, T4]): LodashPartialRight25x2<T2, T3, T4>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, arg2: [T2, T3, T4]): lodash.Function1<T1, R>;
        <T1, T2, T3, T4>(func: lodash.__, arg1: [T1, T2, T3, T4]): LodashPartialRight26x2<T1, T2, T3, T4>;
        <T1, T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>, arg1: [T1, T2, T3, T4]): lodash.Function0<R>;
        (func: (...args: any[]) => any): LodashPartialRight27x1;
        (func: lodash.__, args: readonly any[]): LodashPartialRight27x2;
        (func: (...args: any[]) => any, args: readonly any[]): (...args: any[]) => any;
        placeholder: lodash.__;
    }
    type LodashPartialRight1x1<T1, R> = (arg1: [T1]) => lodash.Function0<R>;
    type LodashPartialRight1x2<T1> = <R>(func: lodash.Function1<T1, R>) => lodash.Function0<R>;
    interface LodashPartialRight2x1<T1, T2, R> {
        (arg1: [T1, lodash.__]): lodash.Function1<T2, R>;
        (arg2: [T2]): lodash.Function1<T1, R>;
        (arg1: [T1, T2]): lodash.Function0<R>;
    }
    type LodashPartialRight2x2<T1> = <T2, R>(func: lodash.Function2<T1, T2, R>) => lodash.Function1<T2, R>;
    type LodashPartialRight3x2<T2> = <T1, R>(func: lodash.Function2<T1, T2, R>) => lodash.Function1<T1, R>;
    type LodashPartialRight4x2<T1, T2> = <R>(func: lodash.Function2<T1, T2, R>) => lodash.Function0<R>;
    interface LodashPartialRight5x1<T1, T2, T3, R> {
        (arg1: [T1, lodash.__, lodash.__]): lodash.Function2<T2, T3, R>;
        (arg2: [T2, lodash.__]): lodash.Function2<T1, T3, R>;
        (arg1: [T1, T2, lodash.__]): lodash.Function1<T3, R>;
        (arg3: [T3]): lodash.Function2<T1, T2, R>;
        (arg1: [T1, lodash.__, T3]): lodash.Function1<T2, R>;
        (arg2: [T2, T3]): lodash.Function1<T1, R>;
        (arg1: [T1, T2, T3]): lodash.Function0<R>;
    }
    type LodashPartialRight5x2<T1> = <T2, T3, R>(func: lodash.Function3<T1, T2, T3, R>) => lodash.Function2<T2, T3, R>;
    type LodashPartialRight6x2<T2> = <T1, T3, R>(func: lodash.Function3<T1, T2, T3, R>) => lodash.Function2<T1, T3, R>;
    type LodashPartialRight7x2<T1, T2> = <T3, R>(func: lodash.Function3<T1, T2, T3, R>) => lodash.Function1<T3, R>;
    type LodashPartialRight8x2<T3> = <T1, T2, R>(func: lodash.Function3<T1, T2, T3, R>) => lodash.Function2<T1, T2, R>;
    type LodashPartialRight9x2<T1, T3> = <T2, R>(func: lodash.Function3<T1, T2, T3, R>) => lodash.Function1<T2, R>;
    type LodashPartialRight10x2<T2, T3> = <T1, R>(func: lodash.Function3<T1, T2, T3, R>) => lodash.Function1<T1, R>;
    type LodashPartialRight11x2<T1, T2, T3> = <R>(func: lodash.Function3<T1, T2, T3, R>) => lodash.Function0<R>;
    interface LodashPartialRight12x1<T1, T2, T3, T4, R> {
        (arg1: [T1, lodash.__, lodash.__, lodash.__]): lodash.Function3<T2, T3, T4, R>;
        (arg2: [T2, lodash.__, lodash.__]): lodash.Function3<T1, T3, T4, R>;
        (arg1: [T1, T2, lodash.__, lodash.__]): lodash.Function2<T3, T4, R>;
        (arg3: [T3, lodash.__]): lodash.Function3<T1, T2, T4, R>;
        (arg1: [T1, lodash.__, T3, lodash.__]): lodash.Function2<T2, T4, R>;
        (arg2: [T2, T3, lodash.__]): lodash.Function2<T1, T4, R>;
        (arg1: [T1, T2, T3, lodash.__]): lodash.Function1<T4, R>;
        (arg4: [T4]): lodash.Function3<T1, T2, T3, R>;
        (arg1: [T1, lodash.__, lodash.__, T4]): lodash.Function2<T2, T3, R>;
        (arg2: [T2, lodash.__, T4]): lodash.Function2<T1, T3, R>;
        (arg1: [T1, T2, lodash.__, T4]): lodash.Function1<T3, R>;
        (arg3: [T3, T4]): lodash.Function2<T1, T2, R>;
        (arg1: [T1, lodash.__, T3, T4]): lodash.Function1<T2, R>;
        (arg2: [T2, T3, T4]): lodash.Function1<T1, R>;
        (arg1: [T1, T2, T3, T4]): lodash.Function0<R>;
    }
    type LodashPartialRight12x2<T1> = <T2, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function3<T2, T3, T4, R>;
    type LodashPartialRight13x2<T2> = <T1, T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function3<T1, T3, T4, R>;
    type LodashPartialRight14x2<T1, T2> = <T3, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function2<T3, T4, R>;
    type LodashPartialRight15x2<T3> = <T1, T2, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function3<T1, T2, T4, R>;
    type LodashPartialRight16x2<T1, T3> = <T2, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function2<T2, T4, R>;
    type LodashPartialRight17x2<T2, T3> = <T1, T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function2<T1, T4, R>;
    type LodashPartialRight18x2<T1, T2, T3> = <T4, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function1<T4, R>;
    type LodashPartialRight19x2<T4> = <T1, T2, T3, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function3<T1, T2, T3, R>;
    type LodashPartialRight20x2<T1, T4> = <T2, T3, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function2<T2, T3, R>;
    type LodashPartialRight21x2<T2, T4> = <T1, T3, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function2<T1, T3, R>;
    type LodashPartialRight22x2<T1, T2, T4> = <T3, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function1<T3, R>;
    type LodashPartialRight23x2<T3, T4> = <T1, T2, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function2<T1, T2, R>;
    type LodashPartialRight24x2<T1, T3, T4> = <T2, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function1<T2, R>;
    type LodashPartialRight25x2<T2, T3, T4> = <T1, R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function1<T1, R>;
    type LodashPartialRight26x2<T1, T2, T3, T4> = <R>(func: lodash.Function4<T1, T2, T3, T4, R>) => lodash.Function0<R>;
    type LodashPartialRight27x1 = (args: readonly any[]) => (...args: any[]) => any;
    type LodashPartialRight27x2 = (func: (...args: any[]) => any) => (...args: any[]) => any;
    interface LodashPartition {
        <T, U extends T>(callback: lodash.ValueIteratorTypeGuard<T, U>): LodashPartition1x1<T, U>;
        <T>(callback: lodash.__, collection: lodash.List<T> | null | undefined): LodashPartition1x2<T>;
        <T, U extends T>(callback: lodash.ValueIteratorTypeGuard<T, U>, collection: lodash.List<T> | null | undefined): [U[], Array<Exclude<T, U>>];
        <T>(callback: lodash.ValueIteratee<T>): LodashPartition2x1<T>;
        <T>(callback: lodash.ValueIteratee<T>, collection: lodash.List<T> | null | undefined): [T[], T[]];
        <T extends object>(callback: lodash.__, collection: T | null | undefined): LodashPartition3x2<T>;
        <T extends object>(callback: lodash.ValueIteratee<T[keyof T]>, collection: T | null | undefined): [Array<T[keyof T]>, Array<T[keyof T]>];
    }
    type LodashPartition1x1<T, U> = (collection: lodash.List<T> | null | undefined) => [U[], Array<Exclude<T, U>>];
    interface LodashPartition1x2<T> {
        <U extends T>(callback: lodash.ValueIteratorTypeGuard<T, U>): [U[], Array<Exclude<T, U>>];
        (callback: lodash.ValueIteratee<T>): [T[], T[]];
    }
    type LodashPartition2x1<T> = (collection: lodash.List<T> | object | null | undefined) => [T[], T[]];
    type LodashPartition3x2<T> = (callback: lodash.ValueIteratee<T[keyof T]>) => [Array<T[keyof T]>, Array<T[keyof T]>];
    interface LodashPath {
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey]): LodashPath1x1<TObject, TKey>;
        <TObject extends object>(path: lodash.__, object: TObject): LodashPath1x2<TObject>;
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey], object: TObject): TObject[TKey];
        <TObject extends object>(path: lodash.__, object: TObject | null | undefined): LodashPath2x2<TObject>;
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey], object: TObject | null | undefined): TObject[TKey] | undefined;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): LodashPath3x1<TObject, TKey1, TKey2>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2], object: TObject): TObject[TKey1][TKey2];
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2], object: TObject | null | undefined): TObject[TKey1][TKey2] | undefined;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): LodashPath5x1<TObject, TKey1, TKey2, TKey3>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3], object: TObject): TObject[TKey1][TKey2][TKey3];
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3], object: TObject | null | undefined): TObject[TKey1][TKey2][TKey3] | undefined;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): LodashPath7x1<TObject, TKey1, TKey2, TKey3, TKey4>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4], object: TObject): TObject[TKey1][TKey2][TKey3][TKey4];
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4], object: TObject | null | undefined): TObject[TKey1][TKey2][TKey3][TKey4] | undefined;
        (path: number): LodashPath9x1;
        <T>(path: lodash.__, object: lodash.NumericDictionary<T>): LodashPath9x2<T>;
        <T>(path: number, object: lodash.NumericDictionary<T>): T;
        <T>(path: lodash.__, object: lodash.NumericDictionary<T> | null | undefined): LodashPath10x2<T>;
        <T>(path: number, object: lodash.NumericDictionary<T> | null | undefined): T | undefined;
        (path: lodash.PropertyPath): LodashPath11x1;
        (path: lodash.__, object: null | undefined): LodashPath11x2;
        (path: lodash.PropertyPath, object: null | undefined): undefined;
        (path: lodash.__, object: any): LodashPath12x2;
        (path: lodash.PropertyPath, object: any): any;
    }
    interface LodashPath1x1<TObject, TKey extends keyof TObject> {
        (object: TObject): TObject[TKey];
        (object: TObject | null | undefined): TObject[TKey] | undefined;
    }
    interface LodashPath1x2<TObject> {
        <TKey extends keyof TObject>(path: TKey | [TKey]): TObject[TKey];
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): TObject[TKey1][TKey2];
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): TObject[TKey1][TKey2][TKey3];
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): TObject[TKey1][TKey2][TKey3][TKey4];
    }
    interface LodashPath2x2<TObject> {
        <TKey extends keyof TObject>(path: TKey | [TKey]): TObject[TKey] | undefined;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): TObject[TKey1][TKey2] | undefined;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): TObject[TKey1][TKey2][TKey3] | undefined;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): TObject[TKey1][TKey2][TKey3][TKey4] | undefined;
    }
    interface LodashPath3x1<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]> {
        (object: TObject): TObject[TKey1][TKey2];
        (object: TObject | null | undefined): TObject[TKey1][TKey2] | undefined;
    }
    interface LodashPath5x1<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]> {
        (object: TObject): TObject[TKey1][TKey2][TKey3];
        (object: TObject | null | undefined): TObject[TKey1][TKey2][TKey3] | undefined;
    }
    interface LodashPath7x1<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]> {
        (object: TObject): TObject[TKey1][TKey2][TKey3][TKey4];
        (object: TObject | null | undefined): TObject[TKey1][TKey2][TKey3][TKey4] | undefined;
    }
    interface LodashPath9x1 {
        <T>(object: lodash.NumericDictionary<T>): T;
        <T>(object: lodash.NumericDictionary<T> | null | undefined): T | undefined;
    }
    type LodashPath9x2<T> = (path: number) => T;
    type LodashPath10x2<T> = (path: number) => T | undefined;
    interface LodashPath11x1 {
        (object: null | undefined): undefined;
        (object: any): any;
    }
    type LodashPath11x2 = (path: lodash.PropertyPath) => undefined;
    type LodashPath12x2 = (path: lodash.PropertyPath) => any;
    interface LodashPathOr {
        <TDefault>(defaultValue: TDefault): LodashPathOr1x1<TDefault>;
        <TObject extends object, TKey extends keyof TObject>(defaultValue: lodash.__, path: TKey | [TKey]): LodashPathOr1x2<TObject, TKey>;
        <TObject extends object, TKey extends keyof TObject, TDefault>(defaultValue: TDefault, path: TKey | [TKey]): LodashPathOr1x3<TObject, TKey, TDefault>;
        <TObject extends object>(defaultValue: lodash.__, path: lodash.__, object: TObject | null | undefined): LodashPathOr1x4<TObject>;
        <TObject extends object, TDefault>(defaultValue: TDefault, path: lodash.__, object: TObject | null | undefined): LodashPathOr1x5<TObject, TDefault>;
        <TObject extends object, TKey extends keyof TObject>(defaultValue: lodash.__, path: TKey | [TKey], object: TObject | null | undefined): LodashPathOr1x6<TObject, TKey>;
        <TObject extends object, TKey extends keyof TObject, TDefault>(defaultValue: TDefault, path: TKey | [TKey], object: TObject | null | undefined): Exclude<TObject[TKey], undefined> | TDefault;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(defaultValue: lodash.__, path: [TKey1, TKey2]): LodashPathOr2x2<TObject, TKey1, TKey2>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2]): LodashPathOr2x3<TObject, TKey1, TKey2, TDefault>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(defaultValue: lodash.__, path: [TKey1, TKey2], object: TObject | null | undefined): LodashPathOr2x6<TObject, TKey1, TKey2>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2], object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(defaultValue: lodash.__, path: [TKey1, TKey2, TKey3]): LodashPathOr3x2<TObject, TKey1, TKey2, TKey3>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2, TKey3]): LodashPathOr3x3<TObject, TKey1, TKey2, TKey3, TDefault>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(defaultValue: lodash.__, path: [TKey1, TKey2, TKey3], object: TObject | null | undefined): LodashPathOr3x6<TObject, TKey1, TKey2, TKey3>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2, TKey3], object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(defaultValue: lodash.__, path: [TKey1, TKey2, TKey3, TKey4]): LodashPathOr4x2<TObject, TKey1, TKey2, TKey3, TKey4>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2, TKey3, TKey4]): LodashPathOr4x3<TObject, TKey1, TKey2, TKey3, TKey4, TDefault>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(defaultValue: lodash.__, path: [TKey1, TKey2, TKey3, TKey4], object: TObject | null | undefined): LodashPathOr4x6<TObject, TKey1, TKey2, TKey3, TKey4>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2, TKey3, TKey4], object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
        (defaultValue: lodash.__, path: number): LodashPathOr5x2;
        <TDefault>(defaultValue: TDefault, path: number): LodashPathOr5x3<TDefault>;
        <T>(defaultValue: lodash.__, path: lodash.__, object: lodash.NumericDictionary<T> | null | undefined): LodashPathOr5x4<T>;
        <T, TDefault>(defaultValue: TDefault, path: lodash.__, object: lodash.NumericDictionary<T> | null | undefined): LodashPathOr5x5<T, TDefault>;
        <T>(defaultValue: lodash.__, path: number, object: lodash.NumericDictionary<T> | null | undefined): LodashPathOr5x6<T>;
        <T, TDefault>(defaultValue: TDefault, path: number, object: lodash.NumericDictionary<T> | null | undefined): T | TDefault;
        (defaultValue: lodash.__, path: lodash.PropertyPath): LodashPathOr6x2;
        <TDefault>(defaultValue: TDefault, path: lodash.PropertyPath): LodashPathOr6x3<TDefault>;
        (defaultValue: lodash.__, path: lodash.__, object: null | undefined): LodashPathOr6x4;
        <TDefault>(defaultValue: TDefault, path: lodash.__, object: null | undefined): LodashPathOr6x5<TDefault>;
        (defaultValue: lodash.__, path: lodash.PropertyPath, object: null | undefined): LodashPathOr6x6;
        <TDefault>(defaultValue: TDefault, path: lodash.PropertyPath, object: null | undefined): TDefault;
        (defaultValue: any): LodashPathOr7x1;
        (defaultValue: any, path: lodash.PropertyPath): LodashPathOr7x3;
        (defaultValue: lodash.__, path: lodash.__, object: any): LodashPathOr7x4;
        (defaultValue: any, path: lodash.__, object: any): LodashPathOr7x5;
        (defaultValue: lodash.__, path: lodash.PropertyPath, object: any): LodashPathOr7x6;
        (defaultValue: any, path: lodash.PropertyPath, object: any): any;
    }
    interface LodashPathOr1x1<TDefault> {
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey]): LodashPathOr1x3<TObject, TKey, TDefault>;
        <TObject extends object>(path: lodash.__, object: TObject | null | undefined): LodashPathOr1x5<TObject, TDefault>;
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey], object: TObject | null | undefined): Exclude<TObject[TKey], undefined> | TDefault;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): LodashPathOr2x3<TObject, TKey1, TKey2, TDefault>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2], object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): LodashPathOr3x3<TObject, TKey1, TKey2, TKey3, TDefault>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3], object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): LodashPathOr4x3<TObject, TKey1, TKey2, TKey3, TKey4, TDefault>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4], object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
        (path: number): LodashPathOr5x3<TDefault>;
        <T>(path: lodash.__, object: lodash.NumericDictionary<T> | null | undefined): LodashPathOr5x5<T, TDefault>;
        <T>(path: number, object: lodash.NumericDictionary<T> | null | undefined): T | TDefault;
        (path: lodash.PropertyPath): LodashPathOr6x3<TDefault>;
        (path: lodash.__, object: null | undefined): LodashPathOr6x5<TDefault>;
        (path: lodash.PropertyPath, object: null | undefined): TDefault;
    }
    interface LodashPathOr1x2<TObject, TKey extends keyof TObject> {
        <TDefault>(defaultValue: TDefault): LodashPathOr1x3<TObject, TKey, TDefault>;
        (defaultValue: lodash.__, object: TObject | null | undefined): LodashPathOr1x6<TObject, TKey>;
        <TDefault>(defaultValue: TDefault, object: TObject | null | undefined): Exclude<TObject[TKey], undefined> | TDefault;
    }
    type LodashPathOr1x3<TObject, TKey extends keyof TObject, TDefault> = (object: TObject | null | undefined) => Exclude<TObject[TKey], undefined> | TDefault;
    interface LodashPathOr1x4<TObject> {
        <TDefault>(defaultValue: TDefault): LodashPathOr1x5<TObject, TDefault>;
        <TKey extends keyof TObject>(defaultValue: lodash.__, path: TKey | [TKey]): LodashPathOr1x6<TObject, TKey>;
        <TKey extends keyof TObject, TDefault>(defaultValue: TDefault, path: TKey | [TKey]): Exclude<TObject[TKey], undefined> | TDefault;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(defaultValue: lodash.__, path: [TKey1, TKey2]): LodashPathOr2x6<TObject, TKey1, TKey2>;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2]): Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(defaultValue: lodash.__, path: [TKey1, TKey2, TKey3]): LodashPathOr3x6<TObject, TKey1, TKey2, TKey3>;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2, TKey3]): Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(defaultValue: lodash.__, path: [TKey1, TKey2, TKey3, TKey4]): LodashPathOr4x6<TObject, TKey1, TKey2, TKey3, TKey4>;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2, TKey3, TKey4]): Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
    }
    interface LodashPathOr1x5<TObject, TDefault> {
        <TKey extends keyof TObject>(path: TKey | [TKey]): Exclude<TObject[TKey], undefined> | TDefault;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
    }
    type LodashPathOr1x6<TObject, TKey extends keyof TObject> = <TDefault>(defaultValue: TDefault) => Exclude<TObject[TKey], undefined> | TDefault;
    interface LodashPathOr2x2<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]> {
        <TDefault>(defaultValue: TDefault): LodashPathOr2x3<TObject, TKey1, TKey2, TDefault>;
        (defaultValue: lodash.__, object: TObject | null | undefined): LodashPathOr2x6<TObject, TKey1, TKey2>;
        <TDefault>(defaultValue: TDefault, object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
    }
    type LodashPathOr2x3<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TDefault> = (object: TObject | null | undefined) => Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
    type LodashPathOr2x6<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]> = <TDefault>(defaultValue: TDefault) => Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
    interface LodashPathOr3x2<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]> {
        <TDefault>(defaultValue: TDefault): LodashPathOr3x3<TObject, TKey1, TKey2, TKey3, TDefault>;
        (defaultValue: lodash.__, object: TObject | null | undefined): LodashPathOr3x6<TObject, TKey1, TKey2, TKey3>;
        <TDefault>(defaultValue: TDefault, object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
    }
    type LodashPathOr3x3<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TDefault> = (object: TObject | null | undefined) => Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
    type LodashPathOr3x6<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]> = <TDefault>(defaultValue: TDefault) => Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
    interface LodashPathOr4x2<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]> {
        <TDefault>(defaultValue: TDefault): LodashPathOr4x3<TObject, TKey1, TKey2, TKey3, TKey4, TDefault>;
        (defaultValue: lodash.__, object: TObject | null | undefined): LodashPathOr4x6<TObject, TKey1, TKey2, TKey3, TKey4>;
        <TDefault>(defaultValue: TDefault, object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
    }
    type LodashPathOr4x3<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3], TDefault> = (object: TObject | null | undefined) => Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
    type LodashPathOr4x6<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]> = <TDefault>(defaultValue: TDefault) => Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
    interface LodashPathOr5x2 {
        <TDefault>(defaultValue: TDefault): LodashPathOr5x3<TDefault>;
        <T>(defaultValue: lodash.__, object: lodash.NumericDictionary<T> | null | undefined): LodashPathOr5x6<T>;
        <T, TDefault>(defaultValue: TDefault, object: lodash.NumericDictionary<T> | null | undefined): T | TDefault;
    }
    type LodashPathOr5x3<TDefault> = <T>(object: lodash.NumericDictionary<T> | null | undefined) => T | TDefault;
    interface LodashPathOr5x4<T> {
        <TDefault>(defaultValue: TDefault): LodashPathOr5x5<T, TDefault>;
        (defaultValue: lodash.__, path: number): LodashPathOr5x6<T>;
        <TDefault>(defaultValue: TDefault, path: number): T | TDefault;
    }
    type LodashPathOr5x5<T, TDefault> = (path: number) => T | TDefault;
    type LodashPathOr5x6<T> = <TDefault>(defaultValue: TDefault) => T | TDefault;
    interface LodashPathOr6x2 {
        <TDefault>(defaultValue: TDefault): LodashPathOr6x3<TDefault>;
        (defaultValue: lodash.__, object: null | undefined): LodashPathOr6x6;
        <TDefault>(defaultValue: TDefault, object: null | undefined): TDefault;
        (defaultValue: any): LodashPathOr7x3;
        (defaultValue: lodash.__, object: any): LodashPathOr7x6;
        (defaultValue: any, object: any): any;
    }
    type LodashPathOr6x3<TDefault> = (object: null | undefined) => TDefault;
    interface LodashPathOr6x4 {
        <TDefault>(defaultValue: TDefault): LodashPathOr6x5<TDefault>;
        (defaultValue: lodash.__, path: lodash.PropertyPath): LodashPathOr6x6;
        <TDefault>(defaultValue: TDefault, path: lodash.PropertyPath): TDefault;
    }
    type LodashPathOr6x5<TDefault> = (path: lodash.PropertyPath) => TDefault;
    type LodashPathOr6x6 = <TDefault>(defaultValue: TDefault) => TDefault;
    interface LodashPathOr7x1 {
        (path: lodash.PropertyPath): LodashPathOr7x3;
        (path: lodash.__, object: any): LodashPathOr7x5;
        (path: lodash.PropertyPath, object: any): any;
    }
    type LodashPathOr7x3 = (object: any) => any;
    interface LodashPathOr7x4 {
        (defaultValue: any): LodashPathOr7x5;
        (defaultValue: lodash.__, path: lodash.PropertyPath): LodashPathOr7x6;
        (defaultValue: any, path: lodash.PropertyPath): any;
    }
    type LodashPathOr7x5 = (path: lodash.PropertyPath) => any;
    type LodashPathOr7x6 = (defaultValue: any) => any;
    interface LodashPick {
        <T extends object, U extends keyof T>(props: lodash.Many<U>): LodashPick1x1<T, U>;
        <T extends object>(props: lodash.__, object: T): LodashPick1x2<T>;
        <T extends object, U extends keyof T>(props: lodash.Many<U>, object: T): Pick<T, U>;
        (props: lodash.PropertyPath): LodashPick2x1;
        <T>(props: lodash.__, object: T | null | undefined): LodashPick2x2<T>;
        <T>(props: lodash.PropertyPath, object: T | null | undefined): lodash.PartialObject<T>;
    }
    type LodashPick1x1<T, U extends keyof T> = (object: T) => Pick<T, U>;
    type LodashPick1x2<T> = <U extends keyof T>(props: lodash.Many<U>) => Pick<T, U>;
    type LodashPick2x1 = <T>(object: T | null | undefined) => lodash.PartialObject<T>;
    type LodashPick2x2<T> = (props: lodash.PropertyPath) => lodash.PartialObject<T>;
    interface LodashPickBy {
        <T, S extends T>(predicate: lodash.ValueKeyIterateeTypeGuard<T, S>): LodashPickBy1x1<T, S>;
        <T>(predicate: lodash.__, object: lodash.Dictionary<T> | null | undefined): LodashPickBy1x2<T>;
        <T, S extends T>(predicate: lodash.ValueKeyIterateeTypeGuard<T, S>, object: lodash.Dictionary<T> | null | undefined): lodash.Dictionary<S>;
        <T>(predicate: lodash.__, object: lodash.NumericDictionary<T> | null | undefined): LodashPickBy2x2<T>;
        <T, S extends T>(predicate: lodash.ValueKeyIterateeTypeGuard<T, S>, object: lodash.NumericDictionary<T> | null | undefined): lodash.NumericDictionary<S>;
        <T>(predicate: lodash.ValueKeyIteratee<T>): LodashPickBy3x1<T>;
        <T>(predicate: lodash.ValueKeyIteratee<T>, object: lodash.Dictionary<T> | null | undefined): lodash.Dictionary<T>;
        <T>(predicate: lodash.ValueKeyIteratee<T>, object: lodash.NumericDictionary<T> | null | undefined): lodash.NumericDictionary<T>;
        <T extends object>(predicate: lodash.__, object: T | null | undefined): LodashPickBy5x2<T>;
        <T extends object>(predicate: lodash.ValueKeyIteratee<T[keyof T]>, object: T | null | undefined): lodash.PartialObject<T>;
    }
    interface LodashPickBy1x1<T, S> {
        (object: lodash.Dictionary<T> | null | undefined): lodash.Dictionary<S>;
        (object: lodash.NumericDictionary<T> | null | undefined): lodash.NumericDictionary<S>;
    }
    interface LodashPickBy1x2<T> {
        <S extends T>(predicate: lodash.ValueKeyIterateeTypeGuard<T, S>): lodash.Dictionary<S>;
        (predicate: lodash.ValueKeyIteratee<T>): lodash.Dictionary<T>;
    }
    interface LodashPickBy2x2<T> {
        <S extends T>(predicate: lodash.ValueKeyIterateeTypeGuard<T, S>): lodash.NumericDictionary<S>;
        (predicate: lodash.ValueKeyIteratee<T>): lodash.NumericDictionary<T>;
    }
    interface LodashPickBy3x1<T> {
        (object: lodash.Dictionary<T> | null | undefined): lodash.Dictionary<T>;
        (object: lodash.NumericDictionary<T> | null | undefined): lodash.NumericDictionary<T>;
        <T1 extends object>(object: T1 | null | undefined): lodash.PartialObject<T1>;
    }
    type LodashPickBy5x2<T> = (predicate: lodash.ValueKeyIteratee<T[keyof T]>) => lodash.PartialObject<T>;
    interface LodashProp {
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey]): LodashProp1x1<TObject, TKey>;
        <TObject extends object>(path: lodash.__, object: TObject): LodashProp1x2<TObject>;
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey], object: TObject): TObject[TKey];
        <TObject extends object>(path: lodash.__, object: TObject | null | undefined): LodashProp2x2<TObject>;
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey], object: TObject | null | undefined): TObject[TKey] | undefined;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): LodashProp3x1<TObject, TKey1, TKey2>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2], object: TObject): TObject[TKey1][TKey2];
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2], object: TObject | null | undefined): TObject[TKey1][TKey2] | undefined;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): LodashProp5x1<TObject, TKey1, TKey2, TKey3>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3], object: TObject): TObject[TKey1][TKey2][TKey3];
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3], object: TObject | null | undefined): TObject[TKey1][TKey2][TKey3] | undefined;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): LodashProp7x1<TObject, TKey1, TKey2, TKey3, TKey4>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4], object: TObject): TObject[TKey1][TKey2][TKey3][TKey4];
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4], object: TObject | null | undefined): TObject[TKey1][TKey2][TKey3][TKey4] | undefined;
        (path: number): LodashProp9x1;
        <T>(path: lodash.__, object: lodash.NumericDictionary<T>): LodashProp9x2<T>;
        <T>(path: number, object: lodash.NumericDictionary<T>): T;
        <T>(path: lodash.__, object: lodash.NumericDictionary<T> | null | undefined): LodashProp10x2<T>;
        <T>(path: number, object: lodash.NumericDictionary<T> | null | undefined): T | undefined;
        (path: lodash.PropertyPath): LodashProp11x1;
        (path: lodash.__, object: null | undefined): LodashProp11x2;
        (path: lodash.PropertyPath, object: null | undefined): undefined;
        (path: lodash.__, object: any): LodashProp12x2;
        (path: lodash.PropertyPath, object: any): any;
    }
    interface LodashProp1x1<TObject, TKey extends keyof TObject> {
        (object: TObject): TObject[TKey];
        (object: TObject | null | undefined): TObject[TKey] | undefined;
    }
    interface LodashProp1x2<TObject> {
        <TKey extends keyof TObject>(path: TKey | [TKey]): TObject[TKey];
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): TObject[TKey1][TKey2];
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): TObject[TKey1][TKey2][TKey3];
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): TObject[TKey1][TKey2][TKey3][TKey4];
    }
    interface LodashProp2x2<TObject> {
        <TKey extends keyof TObject>(path: TKey | [TKey]): TObject[TKey] | undefined;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): TObject[TKey1][TKey2] | undefined;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): TObject[TKey1][TKey2][TKey3] | undefined;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): TObject[TKey1][TKey2][TKey3][TKey4] | undefined;
    }
    interface LodashProp3x1<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]> {
        (object: TObject): TObject[TKey1][TKey2];
        (object: TObject | null | undefined): TObject[TKey1][TKey2] | undefined;
    }
    interface LodashProp5x1<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]> {
        (object: TObject): TObject[TKey1][TKey2][TKey3];
        (object: TObject | null | undefined): TObject[TKey1][TKey2][TKey3] | undefined;
    }
    interface LodashProp7x1<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]> {
        (object: TObject): TObject[TKey1][TKey2][TKey3][TKey4];
        (object: TObject | null | undefined): TObject[TKey1][TKey2][TKey3][TKey4] | undefined;
    }
    interface LodashProp9x1 {
        <T>(object: lodash.NumericDictionary<T>): T;
        <T>(object: lodash.NumericDictionary<T> | null | undefined): T | undefined;
    }
    type LodashProp9x2<T> = (path: number) => T;
    type LodashProp10x2<T> = (path: number) => T | undefined;
    interface LodashProp11x1 {
        (object: null | undefined): undefined;
        (object: any): any;
    }
    type LodashProp11x2 = (path: lodash.PropertyPath) => undefined;
    type LodashProp12x2 = (path: lodash.PropertyPath) => any;
    interface LodashProperty {
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey]): LodashProperty1x1<TObject, TKey>;
        <TObject extends object>(path: lodash.__, object: TObject): LodashProperty1x2<TObject>;
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey], object: TObject): TObject[TKey];
        <TObject extends object>(path: lodash.__, object: TObject | null | undefined): LodashProperty2x2<TObject>;
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey], object: TObject | null | undefined): TObject[TKey] | undefined;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): LodashProperty3x1<TObject, TKey1, TKey2>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2], object: TObject): TObject[TKey1][TKey2];
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2], object: TObject | null | undefined): TObject[TKey1][TKey2] | undefined;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): LodashProperty5x1<TObject, TKey1, TKey2, TKey3>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3], object: TObject): TObject[TKey1][TKey2][TKey3];
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3], object: TObject | null | undefined): TObject[TKey1][TKey2][TKey3] | undefined;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): LodashProperty7x1<TObject, TKey1, TKey2, TKey3, TKey4>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4], object: TObject): TObject[TKey1][TKey2][TKey3][TKey4];
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4], object: TObject | null | undefined): TObject[TKey1][TKey2][TKey3][TKey4] | undefined;
        (path: number): LodashProperty9x1;
        <T>(path: lodash.__, object: lodash.NumericDictionary<T>): LodashProperty9x2<T>;
        <T>(path: number, object: lodash.NumericDictionary<T>): T;
        <T>(path: lodash.__, object: lodash.NumericDictionary<T> | null | undefined): LodashProperty10x2<T>;
        <T>(path: number, object: lodash.NumericDictionary<T> | null | undefined): T | undefined;
        (path: lodash.PropertyPath): LodashProperty11x1;
        (path: lodash.__, object: null | undefined): LodashProperty11x2;
        (path: lodash.PropertyPath, object: null | undefined): undefined;
        (path: lodash.__, object: any): LodashProperty12x2;
        (path: lodash.PropertyPath, object: any): any;
    }
    interface LodashProperty1x1<TObject, TKey extends keyof TObject> {
        (object: TObject): TObject[TKey];
        (object: TObject | null | undefined): TObject[TKey] | undefined;
    }
    interface LodashProperty1x2<TObject> {
        <TKey extends keyof TObject>(path: TKey | [TKey]): TObject[TKey];
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): TObject[TKey1][TKey2];
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): TObject[TKey1][TKey2][TKey3];
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): TObject[TKey1][TKey2][TKey3][TKey4];
    }
    interface LodashProperty2x2<TObject> {
        <TKey extends keyof TObject>(path: TKey | [TKey]): TObject[TKey] | undefined;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): TObject[TKey1][TKey2] | undefined;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): TObject[TKey1][TKey2][TKey3] | undefined;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): TObject[TKey1][TKey2][TKey3][TKey4] | undefined;
    }
    interface LodashProperty3x1<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]> {
        (object: TObject): TObject[TKey1][TKey2];
        (object: TObject | null | undefined): TObject[TKey1][TKey2] | undefined;
    }
    interface LodashProperty5x1<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]> {
        (object: TObject): TObject[TKey1][TKey2][TKey3];
        (object: TObject | null | undefined): TObject[TKey1][TKey2][TKey3] | undefined;
    }
    interface LodashProperty7x1<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]> {
        (object: TObject): TObject[TKey1][TKey2][TKey3][TKey4];
        (object: TObject | null | undefined): TObject[TKey1][TKey2][TKey3][TKey4] | undefined;
    }
    interface LodashProperty9x1 {
        <T>(object: lodash.NumericDictionary<T>): T;
        <T>(object: lodash.NumericDictionary<T> | null | undefined): T | undefined;
    }
    type LodashProperty9x2<T> = (path: number) => T;
    type LodashProperty10x2<T> = (path: number) => T | undefined;
    interface LodashProperty11x1 {
        (object: null | undefined): undefined;
        (object: any): any;
    }
    type LodashProperty11x2 = (path: lodash.PropertyPath) => undefined;
    type LodashProperty12x2 = (path: lodash.PropertyPath) => any;
    interface LodashPropertyOf {
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey]): LodashPropertyOf1x1<TObject, TKey>;
        <TObject extends object>(path: lodash.__, object: TObject): LodashPropertyOf1x2<TObject>;
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey], object: TObject): TObject[TKey];
        <TObject extends object>(path: lodash.__, object: TObject | null | undefined): LodashPropertyOf2x2<TObject>;
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey], object: TObject | null | undefined): TObject[TKey] | undefined;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): LodashPropertyOf3x1<TObject, TKey1, TKey2>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2], object: TObject): TObject[TKey1][TKey2];
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2], object: TObject | null | undefined): TObject[TKey1][TKey2] | undefined;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): LodashPropertyOf5x1<TObject, TKey1, TKey2, TKey3>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3], object: TObject): TObject[TKey1][TKey2][TKey3];
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3], object: TObject | null | undefined): TObject[TKey1][TKey2][TKey3] | undefined;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): LodashPropertyOf7x1<TObject, TKey1, TKey2, TKey3, TKey4>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4], object: TObject): TObject[TKey1][TKey2][TKey3][TKey4];
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4], object: TObject | null | undefined): TObject[TKey1][TKey2][TKey3][TKey4] | undefined;
        (path: number): LodashPropertyOf9x1;
        <T>(path: lodash.__, object: lodash.NumericDictionary<T>): LodashPropertyOf9x2<T>;
        <T>(path: number, object: lodash.NumericDictionary<T>): T;
        <T>(path: lodash.__, object: lodash.NumericDictionary<T> | null | undefined): LodashPropertyOf10x2<T>;
        <T>(path: number, object: lodash.NumericDictionary<T> | null | undefined): T | undefined;
        (path: lodash.PropertyPath): LodashPropertyOf11x1;
        (path: lodash.__, object: null | undefined): LodashPropertyOf11x2;
        (path: lodash.PropertyPath, object: null | undefined): undefined;
        (path: lodash.__, object: any): LodashPropertyOf12x2;
        (path: lodash.PropertyPath, object: any): any;
    }
    interface LodashPropertyOf1x1<TObject, TKey extends keyof TObject> {
        (object: TObject): TObject[TKey];
        (object: TObject | null | undefined): TObject[TKey] | undefined;
    }
    interface LodashPropertyOf1x2<TObject> {
        <TKey extends keyof TObject>(path: TKey | [TKey]): TObject[TKey];
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): TObject[TKey1][TKey2];
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): TObject[TKey1][TKey2][TKey3];
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): TObject[TKey1][TKey2][TKey3][TKey4];
    }
    interface LodashPropertyOf2x2<TObject> {
        <TKey extends keyof TObject>(path: TKey | [TKey]): TObject[TKey] | undefined;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): TObject[TKey1][TKey2] | undefined;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): TObject[TKey1][TKey2][TKey3] | undefined;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): TObject[TKey1][TKey2][TKey3][TKey4] | undefined;
    }
    interface LodashPropertyOf3x1<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]> {
        (object: TObject): TObject[TKey1][TKey2];
        (object: TObject | null | undefined): TObject[TKey1][TKey2] | undefined;
    }
    interface LodashPropertyOf5x1<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]> {
        (object: TObject): TObject[TKey1][TKey2][TKey3];
        (object: TObject | null | undefined): TObject[TKey1][TKey2][TKey3] | undefined;
    }
    interface LodashPropertyOf7x1<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]> {
        (object: TObject): TObject[TKey1][TKey2][TKey3][TKey4];
        (object: TObject | null | undefined): TObject[TKey1][TKey2][TKey3][TKey4] | undefined;
    }
    interface LodashPropertyOf9x1 {
        <T>(object: lodash.NumericDictionary<T>): T;
        <T>(object: lodash.NumericDictionary<T> | null | undefined): T | undefined;
    }
    type LodashPropertyOf9x2<T> = (path: number) => T;
    type LodashPropertyOf10x2<T> = (path: number) => T | undefined;
    interface LodashPropertyOf11x1 {
        (object: null | undefined): undefined;
        (object: any): any;
    }
    type LodashPropertyOf11x2 = (path: lodash.PropertyPath) => undefined;
    type LodashPropertyOf12x2 = (path: lodash.PropertyPath) => any;
    interface LodashPropOr {
        <TDefault>(defaultValue: TDefault): LodashPropOr1x1<TDefault>;
        <TObject extends object, TKey extends keyof TObject>(defaultValue: lodash.__, path: TKey | [TKey]): LodashPropOr1x2<TObject, TKey>;
        <TObject extends object, TKey extends keyof TObject, TDefault>(defaultValue: TDefault, path: TKey | [TKey]): LodashPropOr1x3<TObject, TKey, TDefault>;
        <TObject extends object>(defaultValue: lodash.__, path: lodash.__, object: TObject | null | undefined): LodashPropOr1x4<TObject>;
        <TObject extends object, TDefault>(defaultValue: TDefault, path: lodash.__, object: TObject | null | undefined): LodashPropOr1x5<TObject, TDefault>;
        <TObject extends object, TKey extends keyof TObject>(defaultValue: lodash.__, path: TKey | [TKey], object: TObject | null | undefined): LodashPropOr1x6<TObject, TKey>;
        <TObject extends object, TKey extends keyof TObject, TDefault>(defaultValue: TDefault, path: TKey | [TKey], object: TObject | null | undefined): Exclude<TObject[TKey], undefined> | TDefault;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(defaultValue: lodash.__, path: [TKey1, TKey2]): LodashPropOr2x2<TObject, TKey1, TKey2>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2]): LodashPropOr2x3<TObject, TKey1, TKey2, TDefault>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(defaultValue: lodash.__, path: [TKey1, TKey2], object: TObject | null | undefined): LodashPropOr2x6<TObject, TKey1, TKey2>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2], object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(defaultValue: lodash.__, path: [TKey1, TKey2, TKey3]): LodashPropOr3x2<TObject, TKey1, TKey2, TKey3>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2, TKey3]): LodashPropOr3x3<TObject, TKey1, TKey2, TKey3, TDefault>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(defaultValue: lodash.__, path: [TKey1, TKey2, TKey3], object: TObject | null | undefined): LodashPropOr3x6<TObject, TKey1, TKey2, TKey3>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2, TKey3], object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(defaultValue: lodash.__, path: [TKey1, TKey2, TKey3, TKey4]): LodashPropOr4x2<TObject, TKey1, TKey2, TKey3, TKey4>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2, TKey3, TKey4]): LodashPropOr4x3<TObject, TKey1, TKey2, TKey3, TKey4, TDefault>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(defaultValue: lodash.__, path: [TKey1, TKey2, TKey3, TKey4], object: TObject | null | undefined): LodashPropOr4x6<TObject, TKey1, TKey2, TKey3, TKey4>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2, TKey3, TKey4], object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
        (defaultValue: lodash.__, path: number): LodashPropOr5x2;
        <TDefault>(defaultValue: TDefault, path: number): LodashPropOr5x3<TDefault>;
        <T>(defaultValue: lodash.__, path: lodash.__, object: lodash.NumericDictionary<T> | null | undefined): LodashPropOr5x4<T>;
        <T, TDefault>(defaultValue: TDefault, path: lodash.__, object: lodash.NumericDictionary<T> | null | undefined): LodashPropOr5x5<T, TDefault>;
        <T>(defaultValue: lodash.__, path: number, object: lodash.NumericDictionary<T> | null | undefined): LodashPropOr5x6<T>;
        <T, TDefault>(defaultValue: TDefault, path: number, object: lodash.NumericDictionary<T> | null | undefined): T | TDefault;
        (defaultValue: lodash.__, path: lodash.PropertyPath): LodashPropOr6x2;
        <TDefault>(defaultValue: TDefault, path: lodash.PropertyPath): LodashPropOr6x3<TDefault>;
        (defaultValue: lodash.__, path: lodash.__, object: null | undefined): LodashPropOr6x4;
        <TDefault>(defaultValue: TDefault, path: lodash.__, object: null | undefined): LodashPropOr6x5<TDefault>;
        (defaultValue: lodash.__, path: lodash.PropertyPath, object: null | undefined): LodashPropOr6x6;
        <TDefault>(defaultValue: TDefault, path: lodash.PropertyPath, object: null | undefined): TDefault;
        (defaultValue: any): LodashPropOr7x1;
        (defaultValue: any, path: lodash.PropertyPath): LodashPropOr7x3;
        (defaultValue: lodash.__, path: lodash.__, object: any): LodashPropOr7x4;
        (defaultValue: any, path: lodash.__, object: any): LodashPropOr7x5;
        (defaultValue: lodash.__, path: lodash.PropertyPath, object: any): LodashPropOr7x6;
        (defaultValue: any, path: lodash.PropertyPath, object: any): any;
    }
    interface LodashPropOr1x1<TDefault> {
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey]): LodashPropOr1x3<TObject, TKey, TDefault>;
        <TObject extends object>(path: lodash.__, object: TObject | null | undefined): LodashPropOr1x5<TObject, TDefault>;
        <TObject extends object, TKey extends keyof TObject>(path: TKey | [TKey], object: TObject | null | undefined): Exclude<TObject[TKey], undefined> | TDefault;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): LodashPropOr2x3<TObject, TKey1, TKey2, TDefault>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2], object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): LodashPropOr3x3<TObject, TKey1, TKey2, TKey3, TDefault>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3], object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): LodashPropOr4x3<TObject, TKey1, TKey2, TKey3, TKey4, TDefault>;
        <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4], object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
        (path: number): LodashPropOr5x3<TDefault>;
        <T>(path: lodash.__, object: lodash.NumericDictionary<T> | null | undefined): LodashPropOr5x5<T, TDefault>;
        <T>(path: number, object: lodash.NumericDictionary<T> | null | undefined): T | TDefault;
        (path: lodash.PropertyPath): LodashPropOr6x3<TDefault>;
        (path: lodash.__, object: null | undefined): LodashPropOr6x5<TDefault>;
        (path: lodash.PropertyPath, object: null | undefined): TDefault;
    }
    interface LodashPropOr1x2<TObject, TKey extends keyof TObject> {
        <TDefault>(defaultValue: TDefault): LodashPropOr1x3<TObject, TKey, TDefault>;
        (defaultValue: lodash.__, object: TObject | null | undefined): LodashPropOr1x6<TObject, TKey>;
        <TDefault>(defaultValue: TDefault, object: TObject | null | undefined): Exclude<TObject[TKey], undefined> | TDefault;
    }
    type LodashPropOr1x3<TObject, TKey extends keyof TObject, TDefault> = (object: TObject | null | undefined) => Exclude<TObject[TKey], undefined> | TDefault;
    interface LodashPropOr1x4<TObject> {
        <TDefault>(defaultValue: TDefault): LodashPropOr1x5<TObject, TDefault>;
        <TKey extends keyof TObject>(defaultValue: lodash.__, path: TKey | [TKey]): LodashPropOr1x6<TObject, TKey>;
        <TKey extends keyof TObject, TDefault>(defaultValue: TDefault, path: TKey | [TKey]): Exclude<TObject[TKey], undefined> | TDefault;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(defaultValue: lodash.__, path: [TKey1, TKey2]): LodashPropOr2x6<TObject, TKey1, TKey2>;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2]): Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(defaultValue: lodash.__, path: [TKey1, TKey2, TKey3]): LodashPropOr3x6<TObject, TKey1, TKey2, TKey3>;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2, TKey3]): Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(defaultValue: lodash.__, path: [TKey1, TKey2, TKey3, TKey4]): LodashPropOr4x6<TObject, TKey1, TKey2, TKey3, TKey4>;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3], TDefault>(defaultValue: TDefault, path: [TKey1, TKey2, TKey3, TKey4]): Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
    }
    interface LodashPropOr1x5<TObject, TDefault> {
        <TKey extends keyof TObject>(path: TKey | [TKey]): Exclude<TObject[TKey], undefined> | TDefault;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(path: [TKey1, TKey2]): Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
        <TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
    }
    type LodashPropOr1x6<TObject, TKey extends keyof TObject> = <TDefault>(defaultValue: TDefault) => Exclude<TObject[TKey], undefined> | TDefault;
    interface LodashPropOr2x2<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]> {
        <TDefault>(defaultValue: TDefault): LodashPropOr2x3<TObject, TKey1, TKey2, TDefault>;
        (defaultValue: lodash.__, object: TObject | null | undefined): LodashPropOr2x6<TObject, TKey1, TKey2>;
        <TDefault>(defaultValue: TDefault, object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
    }
    type LodashPropOr2x3<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TDefault> = (object: TObject | null | undefined) => Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
    type LodashPropOr2x6<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]> = <TDefault>(defaultValue: TDefault) => Exclude<TObject[TKey1][TKey2], undefined> | TDefault;
    interface LodashPropOr3x2<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]> {
        <TDefault>(defaultValue: TDefault): LodashPropOr3x3<TObject, TKey1, TKey2, TKey3, TDefault>;
        (defaultValue: lodash.__, object: TObject | null | undefined): LodashPropOr3x6<TObject, TKey1, TKey2, TKey3>;
        <TDefault>(defaultValue: TDefault, object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
    }
    type LodashPropOr3x3<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TDefault> = (object: TObject | null | undefined) => Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
    type LodashPropOr3x6<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]> = <TDefault>(defaultValue: TDefault) => Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;
    interface LodashPropOr4x2<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]> {
        <TDefault>(defaultValue: TDefault): LodashPropOr4x3<TObject, TKey1, TKey2, TKey3, TKey4, TDefault>;
        (defaultValue: lodash.__, object: TObject | null | undefined): LodashPropOr4x6<TObject, TKey1, TKey2, TKey3, TKey4>;
        <TDefault>(defaultValue: TDefault, object: TObject | null | undefined): Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
    }
    type LodashPropOr4x3<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3], TDefault> = (object: TObject | null | undefined) => Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
    type LodashPropOr4x6<TObject, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]> = <TDefault>(defaultValue: TDefault) => Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;
    interface LodashPropOr5x2 {
        <TDefault>(defaultValue: TDefault): LodashPropOr5x3<TDefault>;
        <T>(defaultValue: lodash.__, object: lodash.NumericDictionary<T> | null | undefined): LodashPropOr5x6<T>;
        <T, TDefault>(defaultValue: TDefault, object: lodash.NumericDictionary<T> | null | undefined): T | TDefault;
    }
    type LodashPropOr5x3<TDefault> = <T>(object: lodash.NumericDictionary<T> | null | undefined) => T | TDefault;
    interface LodashPropOr5x4<T> {
        <TDefault>(defaultValue: TDefault): LodashPropOr5x5<T, TDefault>;
        (defaultValue: lodash.__, path: number): LodashPropOr5x6<T>;
        <TDefault>(defaultValue: TDefault, path: number): T | TDefault;
    }
    type LodashPropOr5x5<T, TDefault> = (path: number) => T | TDefault;
    type LodashPropOr5x6<T> = <TDefault>(defaultValue: TDefault) => T | TDefault;
    interface LodashPropOr6x2 {
        <TDefault>(defaultValue: TDefault): LodashPropOr6x3<TDefault>;
        (defaultValue: lodash.__, object: null | undefined): LodashPropOr6x6;
        <TDefault>(defaultValue: TDefault, object: null | undefined): TDefault;
        (defaultValue: any): LodashPropOr7x3;
        (defaultValue: lodash.__, object: any): LodashPropOr7x6;
        (defaultValue: any, object: any): any;
    }
    type LodashPropOr6x3<TDefault> = (object: null | undefined) => TDefault;
    interface LodashPropOr6x4 {
        <TDefault>(defaultValue: TDefault): LodashPropOr6x5<TDefault>;
        (defaultValue: lodash.__, path: lodash.PropertyPath): LodashPropOr6x6;
        <TDefault>(defaultValue: TDefault, path: lodash.PropertyPath): TDefault;
    }
    type LodashPropOr6x5<TDefault> = (path: lodash.PropertyPath) => TDefault;
    type LodashPropOr6x6 = <TDefault>(defaultValue: TDefault) => TDefault;
    interface LodashPropOr7x1 {
        (path: lodash.PropertyPath): LodashPropOr7x3;
        (path: lodash.__, object: any): LodashPropOr7x5;
        (path: lodash.PropertyPath, object: any): any;
    }
    type LodashPropOr7x3 = (object: any) => any;
    interface LodashPropOr7x4 {
        (defaultValue: any): LodashPropOr7x5;
        (defaultValue: lodash.__, path: lodash.PropertyPath): LodashPropOr7x6;
        (defaultValue: any, path: lodash.PropertyPath): any;
    }
    type LodashPropOr7x5 = (path: lodash.PropertyPath) => any;
    type LodashPropOr7x6 = (defaultValue: any) => any;
    interface LodashPull {
        <T>(values: T): LodashPull1x1<T>;
        <T>(values: lodash.__, array: readonly T[]): LodashPull1x2<T>;
        <T>(values: T, array: readonly T[]): T[];
        <T>(values: lodash.__, array: lodash.List<T>): LodashPull2x2<T>;
        <T>(values: T, array: lodash.List<T>): lodash.List<T>;
    }
    interface LodashPull1x1<T> {
        (array: readonly T[]): T[];
        (array: lodash.List<T>): lodash.List<T>;
    }
    type LodashPull1x2<T> = (values: T) => T[];
    type LodashPull2x2<T> = (values: T) => lodash.List<T>;
    interface LodashPullAll {
        <T>(values: lodash.List<T>): LodashPullAll1x1<T>;
        <T>(values: lodash.__, array: readonly T[]): LodashPullAll1x2<T>;
        <T>(values: lodash.List<T>, array: readonly T[]): T[];
        <T>(values: lodash.__, array: lodash.List<T>): LodashPullAll2x2<T>;
        <T>(values: lodash.List<T>, array: lodash.List<T>): lodash.List<T>;
    }
    interface LodashPullAll1x1<T> {
        (array: readonly T[]): T[];
        (array: lodash.List<T>): lodash.List<T>;
    }
    type LodashPullAll1x2<T> = (values: lodash.List<T>) => T[];
    type LodashPullAll2x2<T> = (values: lodash.List<T>) => lodash.List<T>;
    interface LodashPullAllBy {
        <T>(iteratee: lodash.ValueIteratee<T>): LodashPullAllBy1x1<T>;
        <T>(iteratee: lodash.__, values: lodash.List<T>): LodashPullAllBy1x2<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, values: lodash.List<T>): LodashPullAllBy1x3<T>;
        <T>(iteratee: lodash.__, values: lodash.__, array: readonly T[]): LodashPullAllBy1x4<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, values: lodash.__, array: readonly T[]): LodashPullAllBy1x5<T>;
        <T>(iteratee: lodash.__, values: lodash.List<T>, array: readonly T[]): LodashPullAllBy1x6<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, values: lodash.List<T>, array: readonly T[]): T[];
        <T>(iteratee: lodash.__, values: lodash.__, array: lodash.List<T>): LodashPullAllBy2x4<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, values: lodash.__, array: lodash.List<T>): LodashPullAllBy2x5<T>;
        <T>(iteratee: lodash.__, values: lodash.List<T>, array: lodash.List<T>): LodashPullAllBy2x6<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, values: lodash.List<T>, array: lodash.List<T>): lodash.List<T>;
        <T1, T2>(iteratee: lodash.ValueIteratee<T1 | T2>): LodashPullAllBy3x1<T1, T2>;
        <T2>(iteratee: lodash.__, values: lodash.List<T2>): LodashPullAllBy3x2<T2>;
        <T1, T2>(iteratee: lodash.ValueIteratee<T1 | T2>, values: lodash.List<T2>): LodashPullAllBy3x3<T1>;
        <T1>(iteratee: lodash.__, values: lodash.__, array: readonly T1[]): LodashPullAllBy3x4<T1>;
        <T1, T2>(iteratee: lodash.ValueIteratee<T1 | T2>, values: lodash.__, array: readonly T1[]): LodashPullAllBy3x5<T1, T2>;
        <T1, T2>(iteratee: lodash.__, values: lodash.List<T2>, array: readonly T1[]): LodashPullAllBy3x6<T1, T2>;
        <T1, T2>(iteratee: lodash.ValueIteratee<T1 | T2>, values: lodash.List<T2>, array: readonly T1[]): T1[];
        <T1>(iteratee: lodash.__, values: lodash.__, array: lodash.List<T1>): LodashPullAllBy4x4<T1>;
        <T1, T2>(iteratee: lodash.ValueIteratee<T1 | T2>, values: lodash.__, array: lodash.List<T1>): LodashPullAllBy4x5<T1, T2>;
        <T1, T2>(iteratee: lodash.__, values: lodash.List<T2>, array: lodash.List<T1>): LodashPullAllBy4x6<T1, T2>;
        <T1, T2>(iteratee: lodash.ValueIteratee<T1 | T2>, values: lodash.List<T2>, array: lodash.List<T1>): lodash.List<T1>;
    }
    interface LodashPullAllBy1x1<T> {
        (values: lodash.List<T>): LodashPullAllBy1x3<T>;
        (values: lodash.__, array: readonly T[]): LodashPullAllBy1x5<T>;
        (values: lodash.List<T>, array: readonly T[]): T[];
        (values: lodash.__, array: lodash.List<T>): LodashPullAllBy2x5<T>;
        (values: lodash.List<T>, array: lodash.List<T>): lodash.List<T>;
    }
    interface LodashPullAllBy1x2<T> {
        (iteratee: lodash.ValueIteratee<T>): LodashPullAllBy1x3<T>;
        (iteratee: lodash.__, array: readonly T[]): LodashPullAllBy1x6<T>;
        (iteratee: lodash.ValueIteratee<T>, array: readonly T[]): T[];
        (iteratee: lodash.__, array: lodash.List<T>): LodashPullAllBy2x6<T>;
        (iteratee: lodash.ValueIteratee<T>, array: lodash.List<T>): lodash.List<T>;
    }
    interface LodashPullAllBy1x3<T> {
        (array: readonly T[]): T[];
        (array: lodash.List<T>): lodash.List<T>;
    }
    interface LodashPullAllBy1x4<T> {
        (iteratee: lodash.ValueIteratee<T>): LodashPullAllBy1x5<T>;
        (iteratee: lodash.__, values: lodash.List<T>): LodashPullAllBy1x6<T>;
        (iteratee: lodash.ValueIteratee<T>, values: lodash.List<T>): T[];
    }
    type LodashPullAllBy1x5<T> = (values: lodash.List<T>) => T[];
    type LodashPullAllBy1x6<T> = (iteratee: lodash.ValueIteratee<T>) => T[];
    interface LodashPullAllBy2x4<T> {
        (iteratee: lodash.ValueIteratee<T>): LodashPullAllBy2x5<T>;
        (iteratee: lodash.__, values: lodash.List<T>): LodashPullAllBy2x6<T>;
        (iteratee: lodash.ValueIteratee<T>, values: lodash.List<T>): lodash.List<T>;
    }
    type LodashPullAllBy2x5<T> = (values: lodash.List<T>) => lodash.List<T>;
    type LodashPullAllBy2x6<T> = (iteratee: lodash.ValueIteratee<T>) => lodash.List<T>;
    interface LodashPullAllBy3x1<T1, T2> {
        (values: lodash.List<T2>): LodashPullAllBy3x3<T1>;
        (values: lodash.__, array: readonly T1[]): LodashPullAllBy3x5<T1, T2>;
        (values: lodash.List<T2>, array: readonly T1[]): T1[];
        (values: lodash.__, array: lodash.List<T1>): LodashPullAllBy4x5<T1, T2>;
        (values: lodash.List<T2>, array: lodash.List<T1>): lodash.List<T1>;
    }
    interface LodashPullAllBy3x2<T2> {
        <T1>(iteratee: lodash.ValueIteratee<T1 | T2>): LodashPullAllBy3x3<T1>;
        <T1>(iteratee: lodash.__, array: readonly T1[]): LodashPullAllBy3x6<T1, T2>;
        <T1>(iteratee: lodash.ValueIteratee<T1 | T2>, array: readonly T1[]): T1[];
        <T1>(iteratee: lodash.__, array: lodash.List<T1>): LodashPullAllBy4x6<T1, T2>;
        <T1>(iteratee: lodash.ValueIteratee<T1 | T2>, array: lodash.List<T1>): lodash.List<T1>;
    }
    interface LodashPullAllBy3x3<T1> {
        (array: readonly T1[]): T1[];
        (array: lodash.List<T1>): lodash.List<T1>;
    }
    interface LodashPullAllBy3x4<T1> {
        <T2>(iteratee: lodash.ValueIteratee<T1 | T2>): LodashPullAllBy3x5<T1, T2>;
        <T2>(iteratee: lodash.__, values: lodash.List<T2>): LodashPullAllBy3x6<T1, T2>;
        <T2>(iteratee: lodash.ValueIteratee<T1 | T2>, values: lodash.List<T2>): T1[];
    }
    type LodashPullAllBy3x5<T1, T2> = (values: lodash.List<T2>) => T1[];
    type LodashPullAllBy3x6<T1, T2> = (iteratee: lodash.ValueIteratee<T1 | T2>) => T1[];
    interface LodashPullAllBy4x4<T1> {
        <T2>(iteratee: lodash.ValueIteratee<T1 | T2>): LodashPullAllBy4x5<T1, T2>;
        <T2>(iteratee: lodash.__, values: lodash.List<T2>): LodashPullAllBy4x6<T1, T2>;
        <T2>(iteratee: lodash.ValueIteratee<T1 | T2>, values: lodash.List<T2>): lodash.List<T1>;
    }
    type LodashPullAllBy4x5<T1, T2> = (values: lodash.List<T2>) => lodash.List<T1>;
    type LodashPullAllBy4x6<T1, T2> = (iteratee: lodash.ValueIteratee<T1 | T2>) => lodash.List<T1>;
    interface LodashPullAllWith {
        <T>(comparator: lodash.Comparator<T>): LodashPullAllWith1x1<T>;
        <T>(comparator: lodash.__, values: lodash.List<T>): LodashPullAllWith1x2<T>;
        <T>(comparator: lodash.Comparator<T>, values: lodash.List<T>): LodashPullAllWith1x3<T>;
        <T>(comparator: lodash.__, values: lodash.__, array: readonly T[]): LodashPullAllWith1x4<T>;
        <T>(comparator: lodash.Comparator<T>, values: lodash.__, array: readonly T[]): LodashPullAllWith1x5<T>;
        <T>(comparator: lodash.__, values: lodash.List<T>, array: readonly T[]): LodashPullAllWith1x6<T>;
        <T>(comparator: lodash.Comparator<T>, values: lodash.List<T>, array: readonly T[]): T[];
        <T>(comparator: lodash.__, values: lodash.__, array: lodash.List<T>): LodashPullAllWith2x4<T>;
        <T>(comparator: lodash.Comparator<T>, values: lodash.__, array: lodash.List<T>): LodashPullAllWith2x5<T>;
        <T>(comparator: lodash.__, values: lodash.List<T>, array: lodash.List<T>): LodashPullAllWith2x6<T>;
        <T>(comparator: lodash.Comparator<T>, values: lodash.List<T>, array: lodash.List<T>): lodash.List<T>;
        <T1, T2>(comparator: lodash.Comparator2<T1, T2>): LodashPullAllWith3x1<T1, T2>;
        <T2>(comparator: lodash.__, values: lodash.List<T2>): LodashPullAllWith3x2<T2>;
        <T1, T2>(comparator: lodash.Comparator2<T1, T2>, values: lodash.List<T2>): LodashPullAllWith3x3<T1>;
        <T1>(comparator: lodash.__, values: lodash.__, array: readonly T1[]): LodashPullAllWith3x4<T1>;
        <T1, T2>(comparator: lodash.Comparator2<T1, T2>, values: lodash.__, array: readonly T1[]): LodashPullAllWith3x5<T1, T2>;
        <T1, T2>(comparator: lodash.__, values: lodash.List<T2>, array: readonly T1[]): LodashPullAllWith3x6<T1, T2>;
        <T1, T2>(comparator: lodash.Comparator2<T1, T2>, values: lodash.List<T2>, array: readonly T1[]): T1[];
        <T1>(comparator: lodash.__, values: lodash.__, array: lodash.List<T1>): LodashPullAllWith4x4<T1>;
        <T1, T2>(comparator: lodash.Comparator2<T1, T2>, values: lodash.__, array: lodash.List<T1>): LodashPullAllWith4x5<T1, T2>;
        <T1, T2>(comparator: lodash.__, values: lodash.List<T2>, array: lodash.List<T1>): LodashPullAllWith4x6<T1, T2>;
        <T1, T2>(comparator: lodash.Comparator2<T1, T2>, values: lodash.List<T2>, array: lodash.List<T1>): lodash.List<T1>;
    }
    interface LodashPullAllWith1x1<T> {
        (values: lodash.List<T>): LodashPullAllWith1x3<T>;
        (values: lodash.__, array: readonly T[]): LodashPullAllWith1x5<T>;
        (values: lodash.List<T>, array: readonly T[]): T[];
        (values: lodash.__, array: lodash.List<T>): LodashPullAllWith2x5<T>;
        (values: lodash.List<T>, array: lodash.List<T>): lodash.List<T>;
    }
    interface LodashPullAllWith1x2<T> {
        (comparator: lodash.Comparator<T>): LodashPullAllWith1x3<T>;
        (comparator: lodash.__, array: readonly T[]): LodashPullAllWith1x6<T>;
        (comparator: lodash.Comparator<T>, array: readonly T[]): T[];
        (comparator: lodash.__, array: lodash.List<T>): LodashPullAllWith2x6<T>;
        (comparator: lodash.Comparator<T>, array: lodash.List<T>): lodash.List<T>;
    }
    interface LodashPullAllWith1x3<T> {
        (array: readonly T[]): T[];
        (array: lodash.List<T>): lodash.List<T>;
    }
    interface LodashPullAllWith1x4<T> {
        (comparator: lodash.Comparator<T>): LodashPullAllWith1x5<T>;
        (comparator: lodash.__, values: lodash.List<T>): LodashPullAllWith1x6<T>;
        (comparator: lodash.Comparator<T>, values: lodash.List<T>): T[];
    }
    type LodashPullAllWith1x5<T> = (values: lodash.List<T>) => T[];
    type LodashPullAllWith1x6<T> = (comparator: lodash.Comparator<T>) => T[];
    interface LodashPullAllWith2x4<T> {
        (comparator: lodash.Comparator<T>): LodashPullAllWith2x5<T>;
        (comparator: lodash.__, values: lodash.List<T>): LodashPullAllWith2x6<T>;
        (comparator: lodash.Comparator<T>, values: lodash.List<T>): lodash.List<T>;
    }
    type LodashPullAllWith2x5<T> = (values: lodash.List<T>) => lodash.List<T>;
    type LodashPullAllWith2x6<T> = (comparator: lodash.Comparator<T>) => lodash.List<T>;
    interface LodashPullAllWith3x1<T1, T2> {
        (values: lodash.List<T2>): LodashPullAllWith3x3<T1>;
        (values: lodash.__, array: readonly T1[]): LodashPullAllWith3x5<T1, T2>;
        (values: lodash.List<T2>, array: readonly T1[]): T1[];
        (values: lodash.__, array: lodash.List<T1>): LodashPullAllWith4x5<T1, T2>;
        (values: lodash.List<T2>, array: lodash.List<T1>): lodash.List<T1>;
    }
    interface LodashPullAllWith3x2<T2> {
        <T1>(comparator: lodash.Comparator2<T1, T2>): LodashPullAllWith3x3<T1>;
        <T1>(comparator: lodash.__, array: readonly T1[]): LodashPullAllWith3x6<T1, T2>;
        <T1>(comparator: lodash.Comparator2<T1, T2>, array: readonly T1[]): T1[];
        <T1>(comparator: lodash.__, array: lodash.List<T1>): LodashPullAllWith4x6<T1, T2>;
        <T1>(comparator: lodash.Comparator2<T1, T2>, array: lodash.List<T1>): lodash.List<T1>;
    }
    interface LodashPullAllWith3x3<T1> {
        (array: readonly T1[]): T1[];
        (array: lodash.List<T1>): lodash.List<T1>;
    }
    interface LodashPullAllWith3x4<T1> {
        <T2>(comparator: lodash.Comparator2<T1, T2>): LodashPullAllWith3x5<T1, T2>;
        <T2>(comparator: lodash.__, values: lodash.List<T2>): LodashPullAllWith3x6<T1, T2>;
        <T2>(comparator: lodash.Comparator2<T1, T2>, values: lodash.List<T2>): T1[];
    }
    type LodashPullAllWith3x5<T1, T2> = (values: lodash.List<T2>) => T1[];
    type LodashPullAllWith3x6<T1, T2> = (comparator: lodash.Comparator2<T1, T2>) => T1[];
    interface LodashPullAllWith4x4<T1> {
        <T2>(comparator: lodash.Comparator2<T1, T2>): LodashPullAllWith4x5<T1, T2>;
        <T2>(comparator: lodash.__, values: lodash.List<T2>): LodashPullAllWith4x6<T1, T2>;
        <T2>(comparator: lodash.Comparator2<T1, T2>, values: lodash.List<T2>): lodash.List<T1>;
    }
    type LodashPullAllWith4x5<T1, T2> = (values: lodash.List<T2>) => lodash.List<T1>;
    type LodashPullAllWith4x6<T1, T2> = (comparator: lodash.Comparator2<T1, T2>) => lodash.List<T1>;
    interface LodashPullAt {
        (indexes: lodash.Many<number>): LodashPullAt1x1;
        <T>(indexes: lodash.__, array: readonly T[]): LodashPullAt1x2<T>;
        <T>(indexes: lodash.Many<number>, array: readonly T[]): T[];
        <T>(indexes: lodash.__, array: lodash.List<T>): LodashPullAt2x2<T>;
        <T>(indexes: lodash.Many<number>, array: lodash.List<T>): lodash.List<T>;
    }
    interface LodashPullAt1x1 {
        <T>(array: readonly T[]): T[];
        <T>(array: lodash.List<T>): lodash.List<T>;
    }
    type LodashPullAt1x2<T> = (indexes: lodash.Many<number>) => T[];
    type LodashPullAt2x2<T> = (indexes: lodash.Many<number>) => lodash.List<T>;
    interface LodashRandom {
        (maxOrMin: number): LodashRandom1x1;
        (max: lodash.__, floating: boolean): LodashRandom1x2;
        (maxOrMin: number, floatingOrMax: boolean | number): number;
        (min: lodash.__, max: number): LodashRandom2x2;
    }
    type LodashRandom1x1 = (floatingOrMax: boolean | number) => number;
    type LodashRandom1x2 = (max: number) => number;
    type LodashRandom2x2 = (min: number) => number;
    interface LodashRange {
        (start: number): LodashRange1x1;
        (start: lodash.__, end: number): LodashRange1x2;
        (start: number, end: number): number[];
    }
    type LodashRange1x1 = (end: number) => number[];
    type LodashRange1x2 = (start: number) => number[];
    interface LodashRangeRight {
        (start: number): LodashRangeRight1x1;
        (start: lodash.__, end: number): LodashRangeRight1x2;
        (start: number, end: number): number[];
    }
    type LodashRangeRight1x1 = (end: number) => number[];
    type LodashRangeRight1x2 = (start: number) => number[];
    interface LodashRangeStep {
        (start: number): LodashRangeStep1x1;
        (start: lodash.__, end: number): LodashRangeStep1x2;
        (start: number, end: number): LodashRangeStep1x3;
        (start: lodash.__, end: lodash.__, step: number): LodashRangeStep1x4;
        (start: number, end: lodash.__, step: number): LodashRangeStep1x5;
        (start: lodash.__, end: number, step: number): LodashRangeStep1x6;
        (start: number, end: number, step: number): number[];
    }
    interface LodashRangeStep1x1 {
        (end: number): LodashRangeStep1x3;
        (end: lodash.__, step: number): LodashRangeStep1x5;
        (end: number, step: number): number[];
    }
    interface LodashRangeStep1x2 {
        (start: number): LodashRangeStep1x3;
        (start: lodash.__, step: number): LodashRangeStep1x6;
        (start: number, step: number): number[];
    }
    type LodashRangeStep1x3 = (step: number) => number[];
    interface LodashRangeStep1x4 {
        (start: number): LodashRangeStep1x5;
        (start: lodash.__, end: number): LodashRangeStep1x6;
        (start: number, end: number): number[];
    }
    type LodashRangeStep1x5 = (end: number) => number[];
    type LodashRangeStep1x6 = (start: number) => number[];
    interface LodashRangeStepRight {
        (start: number): LodashRangeStepRight1x1;
        (start: lodash.__, end: number): LodashRangeStepRight1x2;
        (start: number, end: number): LodashRangeStepRight1x3;
        (start: lodash.__, end: lodash.__, step: number): LodashRangeStepRight1x4;
        (start: number, end: lodash.__, step: number): LodashRangeStepRight1x5;
        (start: lodash.__, end: number, step: number): LodashRangeStepRight1x6;
        (start: number, end: number, step: number): number[];
    }
    interface LodashRangeStepRight1x1 {
        (end: number): LodashRangeStepRight1x3;
        (end: lodash.__, step: number): LodashRangeStepRight1x5;
        (end: number, step: number): number[];
    }
    interface LodashRangeStepRight1x2 {
        (start: number): LodashRangeStepRight1x3;
        (start: lodash.__, step: number): LodashRangeStepRight1x6;
        (start: number, step: number): number[];
    }
    type LodashRangeStepRight1x3 = (step: number) => number[];
    interface LodashRangeStepRight1x4 {
        (start: number): LodashRangeStepRight1x5;
        (start: lodash.__, end: number): LodashRangeStepRight1x6;
        (start: number, end: number): number[];
    }
    type LodashRangeStepRight1x5 = (end: number) => number[];
    type LodashRangeStepRight1x6 = (start: number) => number[];
    interface LodashRearg {
        (indexes: lodash.Many<number>): LodashRearg1x1;
        (indexes: lodash.__, func: (...args: any[]) => any): LodashRearg1x2;
        (indexes: lodash.Many<number>, func: (...args: any[]) => any): (...args: any[]) => any;
    }
    type LodashRearg1x1 = (func: (...args: any[]) => any) => (...args: any[]) => any;
    type LodashRearg1x2 = (indexes: lodash.Many<number>) => (...args: any[]) => any;
    interface LodashReduce {
        <T, TResult>(callback: lodash.MemoIteratorCapped<T, TResult>): LodashReduce1x1<T, TResult>;
        <TResult>(callback: lodash.__, accumulator: TResult): LodashReduce1x2<TResult>;
        <T, TResult>(callback: lodash.MemoIteratorCapped<T, TResult>, accumulator: TResult): LodashReduce1x3<T, TResult>;
        <T>(callback: lodash.__, accumulator: lodash.__, collection: T[] | null | undefined): LodashReduce1x4<T>;
        <T, TResult>(callback: lodash.MemoIteratorCapped<T, TResult>, accumulator: lodash.__, collection: T[] | null | undefined): LodashReduce1x5<TResult>;
        <T, TResult>(callback: lodash.__, accumulator: TResult, collection: T[] | null | undefined): LodashReduce1x6<T, TResult>;
        <T, TResult>(callback: lodash.MemoIteratorCapped<T, TResult>, accumulator: TResult, collection: T[] | lodash.List<T> | null | undefined): TResult;
        <T>(callback: lodash.__, accumulator: lodash.__, collection: lodash.List<T> | null | undefined): LodashReduce2x4<T>;
        <T, TResult>(callback: lodash.MemoIteratorCapped<T, TResult>, accumulator: lodash.__, collection: lodash.List<T> | null | undefined): LodashReduce2x5<TResult>;
        <T, TResult>(callback: lodash.__, accumulator: TResult, collection: lodash.List<T> | null | undefined): LodashReduce2x6<T, TResult>;
        <T extends object, TResult>(callback: lodash.MemoIteratorCapped<T[keyof T], TResult>): LodashReduce3x1<T, TResult>;
        <T extends object, TResult>(callback: lodash.MemoIteratorCapped<T[keyof T], TResult>, accumulator: TResult): LodashReduce3x3<T, TResult>;
        <T extends object>(callback: lodash.__, accumulator: lodash.__, collection: T | null | undefined): LodashReduce3x4<T>;
        <T extends object, TResult>(callback: lodash.MemoIteratorCapped<T[keyof T], TResult>, accumulator: lodash.__, collection: T | null | undefined): LodashReduce3x5<TResult>;
        <T extends object, TResult>(callback: lodash.__, accumulator: TResult, collection: T | null | undefined): LodashReduce3x6<T, TResult>;
        <T extends object, TResult>(callback: lodash.MemoIteratorCapped<T[keyof T], TResult>, accumulator: TResult, collection: T | null | undefined): TResult;
    }
    interface LodashReduce1x1<T, TResult> {
        (accumulator: TResult): LodashReduce1x3<T, TResult>;
        (accumulator: lodash.__, collection: T[] | null | undefined): LodashReduce1x5<TResult>;
        (accumulator: TResult, collection: T[] | lodash.List<T> | null | undefined): TResult;
        (accumulator: lodash.__, collection: lodash.List<T> | null | undefined): LodashReduce2x5<TResult>;
    }
    interface LodashReduce1x2<TResult> {
        <T>(callback: lodash.MemoIteratorCapped<T, TResult>): LodashReduce1x3<T, TResult>;
        <T>(callback: lodash.__, collection: T[] | null | undefined): LodashReduce1x6<T, TResult>;
        <T>(callback: lodash.MemoIteratorCapped<T, TResult>, collection: T[] | lodash.List<T> | null | undefined): TResult;
        <T>(callback: lodash.__, collection: lodash.List<T> | null | undefined): LodashReduce2x6<T, TResult>;
        <T extends object>(callback: lodash.MemoIteratorCapped<T[keyof T], TResult>): LodashReduce3x3<T, TResult>;
        <T extends object>(callback: lodash.__, collection: T | null | undefined): LodashReduce3x6<T, TResult>;
        <T extends object>(callback: lodash.MemoIteratorCapped<T[keyof T], TResult>, collection: T | null | undefined): TResult;
    }
    type LodashReduce1x3<T, TResult> = (collection: T[] | lodash.List<T> | null | undefined) => TResult;
    interface LodashReduce1x4<T> {
        <TResult>(callback: lodash.MemoIteratorCapped<T, TResult>): LodashReduce1x5<TResult>;
        <TResult>(callback: lodash.__, accumulator: TResult): LodashReduce1x6<T, TResult>;
        <TResult>(callback: lodash.MemoIteratorCapped<T, TResult>, accumulator: TResult): TResult;
    }
    type LodashReduce1x5<TResult> = (accumulator: TResult) => TResult;
    type LodashReduce1x6<T, TResult> = (callback: lodash.MemoIteratorCapped<T, TResult>) => TResult;
    interface LodashReduce2x4<T> {
        <TResult>(callback: lodash.MemoIteratorCapped<T, TResult>): LodashReduce2x5<TResult>;
        <TResult>(callback: lodash.__, accumulator: TResult): LodashReduce2x6<T, TResult>;
        <TResult>(callback: lodash.MemoIteratorCapped<T, TResult>, accumulator: TResult): TResult;
    }
    type LodashReduce2x5<TResult> = (accumulator: TResult) => TResult;
    type LodashReduce2x6<T, TResult> = (callback: lodash.MemoIteratorCapped<T, TResult>) => TResult;
    interface LodashReduce3x1<T, TResult> {
        (accumulator: TResult): LodashReduce3x3<T, TResult>;
        (accumulator: lodash.__, collection: T | null | undefined): LodashReduce3x5<TResult>;
        (accumulator: TResult, collection: T | null | undefined): TResult;
    }
    type LodashReduce3x3<T, TResult> = (collection: T | null | undefined) => TResult;
    interface LodashReduce3x4<T> {
        <TResult>(callback: lodash.MemoIteratorCapped<T[keyof T], TResult>): LodashReduce3x5<TResult>;
        <TResult>(callback: lodash.__, accumulator: TResult): LodashReduce3x6<T, TResult>;
        <TResult>(callback: lodash.MemoIteratorCapped<T[keyof T], TResult>, accumulator: TResult): TResult;
    }
    type LodashReduce3x5<TResult> = (accumulator: TResult) => TResult;
    type LodashReduce3x6<T, TResult> = (callback: lodash.MemoIteratorCapped<T[keyof T], TResult>) => TResult;
    interface LodashReduceRight {
        <T, TResult>(callback: lodash.MemoIteratorCappedRight<T, TResult>): LodashReduceRight1x1<T, TResult>;
        <TResult>(callback: lodash.__, accumulator: TResult): LodashReduceRight1x2<TResult>;
        <T, TResult>(callback: lodash.MemoIteratorCappedRight<T, TResult>, accumulator: TResult): LodashReduceRight1x3<T, TResult>;
        <T>(callback: lodash.__, accumulator: lodash.__, collection: T[] | null | undefined): LodashReduceRight1x4<T>;
        <T, TResult>(callback: lodash.MemoIteratorCappedRight<T, TResult>, accumulator: lodash.__, collection: T[] | null | undefined): LodashReduceRight1x5<TResult>;
        <T, TResult>(callback: lodash.__, accumulator: TResult, collection: T[] | null | undefined): LodashReduceRight1x6<T, TResult>;
        <T, TResult>(callback: lodash.MemoIteratorCappedRight<T, TResult>, accumulator: TResult, collection: T[] | lodash.List<T> | null | undefined): TResult;
        <T>(callback: lodash.__, accumulator: lodash.__, collection: lodash.List<T> | null | undefined): LodashReduceRight2x4<T>;
        <T, TResult>(callback: lodash.MemoIteratorCappedRight<T, TResult>, accumulator: lodash.__, collection: lodash.List<T> | null | undefined): LodashReduceRight2x5<TResult>;
        <T, TResult>(callback: lodash.__, accumulator: TResult, collection: lodash.List<T> | null | undefined): LodashReduceRight2x6<T, TResult>;
        <T extends object, TResult>(callback: lodash.MemoIteratorCappedRight<T[keyof T], TResult>): LodashReduceRight3x1<T, TResult>;
        <T extends object, TResult>(callback: lodash.MemoIteratorCappedRight<T[keyof T], TResult>, accumulator: TResult): LodashReduceRight3x3<T, TResult>;
        <T extends object>(callback: lodash.__, accumulator: lodash.__, collection: T | null | undefined): LodashReduceRight3x4<T>;
        <T extends object, TResult>(callback: lodash.MemoIteratorCappedRight<T[keyof T], TResult>, accumulator: lodash.__, collection: T | null | undefined): LodashReduceRight3x5<TResult>;
        <T extends object, TResult>(callback: lodash.__, accumulator: TResult, collection: T | null | undefined): LodashReduceRight3x6<T, TResult>;
        <T extends object, TResult>(callback: lodash.MemoIteratorCappedRight<T[keyof T], TResult>, accumulator: TResult, collection: T | null | undefined): TResult;
    }
    interface LodashReduceRight1x1<T, TResult> {
        (accumulator: TResult): LodashReduceRight1x3<T, TResult>;
        (accumulator: lodash.__, collection: T[] | null | undefined): LodashReduceRight1x5<TResult>;
        (accumulator: TResult, collection: T[] | lodash.List<T> | null | undefined): TResult;
        (accumulator: lodash.__, collection: lodash.List<T> | null | undefined): LodashReduceRight2x5<TResult>;
    }
    interface LodashReduceRight1x2<TResult> {
        <T>(callback: lodash.MemoIteratorCappedRight<T, TResult>): LodashReduceRight1x3<T, TResult>;
        <T>(callback: lodash.__, collection: T[] | null | undefined): LodashReduceRight1x6<T, TResult>;
        <T>(callback: lodash.MemoIteratorCappedRight<T, TResult>, collection: T[] | lodash.List<T> | null | undefined): TResult;
        <T>(callback: lodash.__, collection: lodash.List<T> | null | undefined): LodashReduceRight2x6<T, TResult>;
        <T extends object>(callback: lodash.MemoIteratorCappedRight<T[keyof T], TResult>): LodashReduceRight3x3<T, TResult>;
        <T extends object>(callback: lodash.__, collection: T | null | undefined): LodashReduceRight3x6<T, TResult>;
        <T extends object>(callback: lodash.MemoIteratorCappedRight<T[keyof T], TResult>, collection: T | null | undefined): TResult;
    }
    type LodashReduceRight1x3<T, TResult> = (collection: T[] | lodash.List<T> | null | undefined) => TResult;
    interface LodashReduceRight1x4<T> {
        <TResult>(callback: lodash.MemoIteratorCappedRight<T, TResult>): LodashReduceRight1x5<TResult>;
        <TResult>(callback: lodash.__, accumulator: TResult): LodashReduceRight1x6<T, TResult>;
        <TResult>(callback: lodash.MemoIteratorCappedRight<T, TResult>, accumulator: TResult): TResult;
    }
    type LodashReduceRight1x5<TResult> = (accumulator: TResult) => TResult;
    type LodashReduceRight1x6<T, TResult> = (callback: lodash.MemoIteratorCappedRight<T, TResult>) => TResult;
    interface LodashReduceRight2x4<T> {
        <TResult>(callback: lodash.MemoIteratorCappedRight<T, TResult>): LodashReduceRight2x5<TResult>;
        <TResult>(callback: lodash.__, accumulator: TResult): LodashReduceRight2x6<T, TResult>;
        <TResult>(callback: lodash.MemoIteratorCappedRight<T, TResult>, accumulator: TResult): TResult;
    }
    type LodashReduceRight2x5<TResult> = (accumulator: TResult) => TResult;
    type LodashReduceRight2x6<T, TResult> = (callback: lodash.MemoIteratorCappedRight<T, TResult>) => TResult;
    interface LodashReduceRight3x1<T, TResult> {
        (accumulator: TResult): LodashReduceRight3x3<T, TResult>;
        (accumulator: lodash.__, collection: T | null | undefined): LodashReduceRight3x5<TResult>;
        (accumulator: TResult, collection: T | null | undefined): TResult;
    }
    type LodashReduceRight3x3<T, TResult> = (collection: T | null | undefined) => TResult;
    interface LodashReduceRight3x4<T> {
        <TResult>(callback: lodash.MemoIteratorCappedRight<T[keyof T], TResult>): LodashReduceRight3x5<TResult>;
        <TResult>(callback: lodash.__, accumulator: TResult): LodashReduceRight3x6<T, TResult>;
        <TResult>(callback: lodash.MemoIteratorCappedRight<T[keyof T], TResult>, accumulator: TResult): TResult;
    }
    type LodashReduceRight3x5<TResult> = (accumulator: TResult) => TResult;
    type LodashReduceRight3x6<T, TResult> = (callback: lodash.MemoIteratorCappedRight<T[keyof T], TResult>) => TResult;
    interface LodashReject {
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>): LodashReject1x1<T>;
        <T>(predicate: lodash.__, collection: lodash.List<T> | null | undefined): LodashReject1x2<T>;
        <T>(predicate: lodash.ValueIterateeCustom<T, boolean>, collection: lodash.List<T> | null | undefined): T[];
        <T extends object>(predicate: lodash.__, collection: T | null | undefined): LodashReject2x2<T>;
        <T extends object>(predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>, collection: T | null | undefined): Array<T[keyof T]>;
    }
    type LodashReject1x1<T> = (collection: lodash.List<T> | object | null | undefined) => T[];
    type LodashReject1x2<T> = (predicate: lodash.ValueIterateeCustom<T, boolean>) => T[];
    type LodashReject2x2<T> = (predicate: lodash.ValueIterateeCustom<T[keyof T], boolean>) => Array<T[keyof T]>;
    interface LodashRemove {
        <T>(predicate: lodash.ValueIteratee<T>): LodashRemove1x1<T>;
        <T>(predicate: lodash.__, array: lodash.List<T>): LodashRemove1x2<T>;
        <T>(predicate: lodash.ValueIteratee<T>, array: lodash.List<T>): T[];
    }
    type LodashRemove1x1<T> = (array: lodash.List<T>) => T[];
    type LodashRemove1x2<T> = (predicate: lodash.ValueIteratee<T>) => T[];
    interface LodashRepeat {
        (n: number): LodashRepeat1x1;
        (n: lodash.__, string: string): LodashRepeat1x2;
        (n: number, string: string): string;
    }
    type LodashRepeat1x1 = (string: string) => string;
    type LodashRepeat1x2 = (n: number) => string;
    interface LodashReplace {
        (pattern: RegExp | string): LodashReplace1x1;
        (pattern: lodash.__, replacement: lodash.ReplaceFunction | string): LodashReplace1x2;
        (pattern: RegExp | string, replacement: lodash.ReplaceFunction | string): LodashReplace1x3;
        (pattern: lodash.__, replacement: lodash.__, string: string): LodashReplace1x4;
        (pattern: RegExp | string, replacement: lodash.__, string: string): LodashReplace1x5;
        (pattern: lodash.__, replacement: lodash.ReplaceFunction | string, string: string): LodashReplace1x6;
        (pattern: RegExp | string, replacement: lodash.ReplaceFunction | string, string: string): string;
    }
    interface LodashReplace1x1 {
        (replacement: lodash.ReplaceFunction | string): LodashReplace1x3;
        (replacement: lodash.__, string: string): LodashReplace1x5;
        (replacement: lodash.ReplaceFunction | string, string: string): string;
    }
    interface LodashReplace1x2 {
        (pattern: RegExp | string): LodashReplace1x3;
        (pattern: lodash.__, string: string): LodashReplace1x6;
        (pattern: RegExp | string, string: string): string;
    }
    type LodashReplace1x3 = (string: string) => string;
    interface LodashReplace1x4 {
        (pattern: RegExp | string): LodashReplace1x5;
        (pattern: lodash.__, replacement: lodash.ReplaceFunction | string): LodashReplace1x6;
        (pattern: RegExp | string, replacement: lodash.ReplaceFunction | string): string;
    }
    type LodashReplace1x5 = (replacement: lodash.ReplaceFunction | string) => string;
    type LodashReplace1x6 = (pattern: RegExp | string) => string;
    type LodashRest = (func: (...args: any[]) => any) => (...args: any[]) => any;
    interface LodashRestFrom {
        (start: number): LodashRestFrom1x1;
        (start: lodash.__, func: (...args: any[]) => any): LodashRestFrom1x2;
        (start: number, func: (...args: any[]) => any): (...args: any[]) => any;
    }
    type LodashRestFrom1x1 = (func: (...args: any[]) => any) => (...args: any[]) => any;
    type LodashRestFrom1x2 = (start: number) => (...args: any[]) => any;
    interface LodashResult {
        (path: lodash.PropertyPath): LodashResult1x1;
        (path: lodash.__, object: any): LodashResult1x2;
        <TResult>(path: lodash.PropertyPath, object: any): TResult;
    }
    type LodashResult1x1 = <TResult>(object: any) => TResult;
    type LodashResult1x2 = <TResult>(path: lodash.PropertyPath) => TResult;
    type LodashReverse = <TList extends lodash.List<any>>(array: TList) => TList;
    type LodashRound = (n: number) => number;
    type LodashRunInContext = (context: object) => lodash.LoDashStatic;
    interface LodashSample {
        <T>(collection: readonly [T, ...T[]]): T;
        <T>(collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): T | undefined;
        <T extends object>(collection: T | null | undefined): T[keyof T] | undefined;
    }
    interface LodashSampleSize {
        (n: number): LodashSampleSize1x1;
        <T>(n: lodash.__, collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): LodashSampleSize1x2<T>;
        <T>(n: number, collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): T[];
        <T extends object>(n: lodash.__, collection: T | null | undefined): LodashSampleSize2x2<T>;
        <T extends object>(n: number, collection: T | null | undefined): Array<T[keyof T]>;
    }
    interface LodashSampleSize1x1 {
        <T>(collection: lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): T[];
        <T extends object>(collection: T | null | undefined): Array<T[keyof T]>;
    }
    type LodashSampleSize1x2<T> = (n: number) => T[];
    type LodashSampleSize2x2<T> = (n: number) => Array<T[keyof T]>;
    interface LodashSetWith {
        <T extends object>(customizer: lodash.SetWithCustomizer<T>): LodashSetWith1x1<T>;
        (customizer: lodash.__, path: lodash.PropertyPath): LodashSetWith1x2;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, path: lodash.PropertyPath): LodashSetWith1x3<T>;
        (customizer: lodash.__, path: lodash.__, value: any): LodashSetWith1x4;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, path: lodash.__, value: any): LodashSetWith1x5<T>;
        (customizer: lodash.__, path: lodash.PropertyPath, value: any): LodashSetWith1x6;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, path: lodash.PropertyPath, value: any): LodashSetWith1x7<T>;
        <T extends object>(customizer: lodash.__, path: lodash.__, value: lodash.__, object: T): LodashSetWith1x8<T>;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, path: lodash.__, value: lodash.__, object: T): LodashSetWith1x9<T>;
        <T extends object>(customizer: lodash.__, path: lodash.PropertyPath, value: lodash.__, object: T): LodashSetWith1x10<T>;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, path: lodash.PropertyPath, value: lodash.__, object: T): LodashSetWith1x11<T>;
        <T extends object>(customizer: lodash.__, path: lodash.__, value: any, object: T): LodashSetWith1x12<T>;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, path: lodash.__, value: any, object: T): LodashSetWith1x13<T>;
        <T extends object>(customizer: lodash.__, path: lodash.PropertyPath, value: any, object: T): LodashSetWith1x14<T>;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, path: lodash.PropertyPath, value: any, object: T): T;
    }
    interface LodashSetWith1x1<T> {
        (path: lodash.PropertyPath): LodashSetWith1x3<T>;
        (path: lodash.__, value: any): LodashSetWith1x5<T>;
        (path: lodash.PropertyPath, value: any): LodashSetWith1x7<T>;
        (path: lodash.__, value: lodash.__, object: T): LodashSetWith1x9<T>;
        (path: lodash.PropertyPath, value: lodash.__, object: T): LodashSetWith1x11<T>;
        (path: lodash.__, value: any, object: T): LodashSetWith1x13<T>;
        (path: lodash.PropertyPath, value: any, object: T): T;
    }
    interface LodashSetWith1x2 {
        <T extends object>(customizer: lodash.SetWithCustomizer<T>): LodashSetWith1x3<T>;
        (customizer: lodash.__, value: any): LodashSetWith1x6;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, value: any): LodashSetWith1x7<T>;
        <T extends object>(customizer: lodash.__, value: lodash.__, object: T): LodashSetWith1x10<T>;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, value: lodash.__, object: T): LodashSetWith1x11<T>;
        <T extends object>(customizer: lodash.__, value: any, object: T): LodashSetWith1x14<T>;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, value: any, object: T): T;
    }
    interface LodashSetWith1x3<T> {
        (value: any): LodashSetWith1x7<T>;
        (value: lodash.__, object: T): LodashSetWith1x11<T>;
        (value: any, object: T): T;
    }
    interface LodashSetWith1x4 {
        <T extends object>(customizer: lodash.SetWithCustomizer<T>): LodashSetWith1x5<T>;
        (customizer: lodash.__, path: lodash.PropertyPath): LodashSetWith1x6;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, path: lodash.PropertyPath): LodashSetWith1x7<T>;
        <T extends object>(customizer: lodash.__, path: lodash.__, object: T): LodashSetWith1x12<T>;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, path: lodash.__, object: T): LodashSetWith1x13<T>;
        <T extends object>(customizer: lodash.__, path: lodash.PropertyPath, object: T): LodashSetWith1x14<T>;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, path: lodash.PropertyPath, object: T): T;
    }
    interface LodashSetWith1x5<T> {
        (path: lodash.PropertyPath): LodashSetWith1x7<T>;
        (path: lodash.__, object: T): LodashSetWith1x13<T>;
        (path: lodash.PropertyPath, object: T): T;
    }
    interface LodashSetWith1x6 {
        <T extends object>(customizer: lodash.SetWithCustomizer<T>): LodashSetWith1x7<T>;
        <T extends object>(customizer: lodash.__, object: T): LodashSetWith1x14<T>;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, object: T): T;
    }
    type LodashSetWith1x7<T> = (object: T) => T;
    interface LodashSetWith1x8<T> {
        (customizer: lodash.SetWithCustomizer<T>): LodashSetWith1x9<T>;
        (customizer: lodash.__, path: lodash.PropertyPath): LodashSetWith1x10<T>;
        (customizer: lodash.SetWithCustomizer<T>, path: lodash.PropertyPath): LodashSetWith1x11<T>;
        (customizer: lodash.__, path: lodash.__, value: any): LodashSetWith1x12<T>;
        (customizer: lodash.SetWithCustomizer<T>, path: lodash.__, value: any): LodashSetWith1x13<T>;
        (customizer: lodash.__, path: lodash.PropertyPath, value: any): LodashSetWith1x14<T>;
        (customizer: lodash.SetWithCustomizer<T>, path: lodash.PropertyPath, value: any): T;
    }
    interface LodashSetWith1x9<T> {
        (path: lodash.PropertyPath): LodashSetWith1x11<T>;
        (path: lodash.__, value: any): LodashSetWith1x13<T>;
        (path: lodash.PropertyPath, value: any): T;
    }
    interface LodashSetWith1x10<T> {
        (customizer: lodash.SetWithCustomizer<T>): LodashSetWith1x11<T>;
        (customizer: lodash.__, value: any): LodashSetWith1x14<T>;
        (customizer: lodash.SetWithCustomizer<T>, value: any): T;
    }
    type LodashSetWith1x11<T> = (value: any) => T;
    interface LodashSetWith1x12<T> {
        (customizer: lodash.SetWithCustomizer<T>): LodashSetWith1x13<T>;
        (customizer: lodash.__, path: lodash.PropertyPath): LodashSetWith1x14<T>;
        (customizer: lodash.SetWithCustomizer<T>, path: lodash.PropertyPath): T;
    }
    type LodashSetWith1x13<T> = (path: lodash.PropertyPath) => T;
    type LodashSetWith1x14<T> = (customizer: lodash.SetWithCustomizer<T>) => T;
    interface LodashShuffle {
        <T>(collection: lodash.List<T> | null | undefined): T[];
        <T extends object>(collection: T | null | undefined): Array<T[keyof T]>;
    }
    type LodashSize = (collection: object | string | null | undefined) => number;
    interface LodashSlice {
        (start: number): LodashSlice1x1;
        (start: lodash.__, end: number): LodashSlice1x2;
        (start: number, end: number): LodashSlice1x3;
        <T>(start: lodash.__, end: lodash.__, array: lodash.List<T> | null | undefined): LodashSlice1x4<T>;
        <T>(start: number, end: lodash.__, array: lodash.List<T> | null | undefined): LodashSlice1x5<T>;
        <T>(start: lodash.__, end: number, array: lodash.List<T> | null | undefined): LodashSlice1x6<T>;
        <T>(start: number, end: number, array: lodash.List<T> | null | undefined): T[];
    }
    interface LodashSlice1x1 {
        (end: number): LodashSlice1x3;
        <T>(end: lodash.__, array: lodash.List<T> | null | undefined): LodashSlice1x5<T>;
        <T>(end: number, array: lodash.List<T> | null | undefined): T[];
    }
    interface LodashSlice1x2 {
        (start: number): LodashSlice1x3;
        <T>(start: lodash.__, array: lodash.List<T> | null | undefined): LodashSlice1x6<T>;
        <T>(start: number, array: lodash.List<T> | null | undefined): T[];
    }
    type LodashSlice1x3 = <T>(array: lodash.List<T> | null | undefined) => T[];
    interface LodashSlice1x4<T> {
        (start: number): LodashSlice1x5<T>;
        (start: lodash.__, end: number): LodashSlice1x6<T>;
        (start: number, end: number): T[];
    }
    type LodashSlice1x5<T> = (end: number) => T[];
    type LodashSlice1x6<T> = (start: number) => T[];
    type LodashSnakeCase = (string: string) => string;
    interface LodashSortBy {
        <T>(iteratees: lodash.Many<lodash.ValueIteratee<T>>): LodashSortBy1x1<T>;
        <T>(iteratees: lodash.__, collection: lodash.List<T> | null | undefined): LodashSortBy1x2<T>;
        <T>(iteratees: lodash.Many<lodash.ValueIteratee<T>>, collection: lodash.List<T> | null | undefined): T[];
        <T extends object>(iteratees: lodash.__, collection: T | null | undefined): LodashSortBy2x2<T>;
        <T extends object>(iteratees: lodash.Many<lodash.ValueIteratee<T[keyof T]>>, collection: T | null | undefined): Array<T[keyof T]>;
    }
    type LodashSortBy1x1<T> = (collection: lodash.List<T> | object | null | undefined) => T[];
    type LodashSortBy1x2<T> = (iteratees: lodash.Many<lodash.ValueIteratee<T>>) => T[];
    type LodashSortBy2x2<T> = (iteratees: lodash.Many<lodash.ValueIteratee<T[keyof T]>>) => Array<T[keyof T]>;
    interface LodashSortedIndex {
        <T>(value: T): LodashSortedIndex1x1<T>;
        <T>(value: lodash.__, array: lodash.List<T> | null | undefined): LodashSortedIndex1x2<T>;
        <T>(value: T, array: lodash.List<T> | null | undefined): number;
    }
    type LodashSortedIndex1x1<T> = (array: lodash.List<T> | null | undefined) => number;
    type LodashSortedIndex1x2<T> = (value: T) => number;
    interface LodashSortedIndexBy {
        <T>(iteratee: lodash.ValueIteratee<T>): LodashSortedIndexBy1x1<T>;
        <T>(iteratee: lodash.__, value: T): LodashSortedIndexBy1x2<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, value: T): LodashSortedIndexBy1x3<T>;
        <T>(iteratee: lodash.__, value: lodash.__, array: lodash.List<T> | null | undefined): LodashSortedIndexBy1x4<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, value: lodash.__, array: lodash.List<T> | null | undefined): LodashSortedIndexBy1x5<T>;
        <T>(iteratee: lodash.__, value: T, array: lodash.List<T> | null | undefined): LodashSortedIndexBy1x6<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, value: T, array: lodash.List<T> | null | undefined): number;
    }
    interface LodashSortedIndexBy1x1<T> {
        (value: T): LodashSortedIndexBy1x3<T>;
        (value: lodash.__, array: lodash.List<T> | null | undefined): LodashSortedIndexBy1x5<T>;
        (value: T, array: lodash.List<T> | null | undefined): number;
    }
    interface LodashSortedIndexBy1x2<T> {
        (iteratee: lodash.ValueIteratee<T>): LodashSortedIndexBy1x3<T>;
        (iteratee: lodash.__, array: lodash.List<T> | null | undefined): LodashSortedIndexBy1x6<T>;
        (iteratee: lodash.ValueIteratee<T>, array: lodash.List<T> | null | undefined): number;
    }
    type LodashSortedIndexBy1x3<T> = (array: lodash.List<T> | null | undefined) => number;
    interface LodashSortedIndexBy1x4<T> {
        (iteratee: lodash.ValueIteratee<T>): LodashSortedIndexBy1x5<T>;
        (iteratee: lodash.__, value: T): LodashSortedIndexBy1x6<T>;
        (iteratee: lodash.ValueIteratee<T>, value: T): number;
    }
    type LodashSortedIndexBy1x5<T> = (value: T) => number;
    type LodashSortedIndexBy1x6<T> = (iteratee: lodash.ValueIteratee<T>) => number;
    interface LodashSortedIndexOf {
        <T>(value: T): LodashSortedIndexOf1x1<T>;
        <T>(value: lodash.__, array: lodash.List<T> | null | undefined): LodashSortedIndexOf1x2<T>;
        <T>(value: T, array: lodash.List<T> | null | undefined): number;
    }
    type LodashSortedIndexOf1x1<T> = (array: lodash.List<T> | null | undefined) => number;
    type LodashSortedIndexOf1x2<T> = (value: T) => number;
    interface LodashSortedLastIndex {
        <T>(value: T): LodashSortedLastIndex1x1<T>;
        <T>(value: lodash.__, array: lodash.List<T> | null | undefined): LodashSortedLastIndex1x2<T>;
        <T>(value: T, array: lodash.List<T> | null | undefined): number;
    }
    type LodashSortedLastIndex1x1<T> = (array: lodash.List<T> | null | undefined) => number;
    type LodashSortedLastIndex1x2<T> = (value: T) => number;
    interface LodashSortedLastIndexBy {
        <T>(iteratee: lodash.ValueIteratee<T>): LodashSortedLastIndexBy1x1<T>;
        <T>(iteratee: lodash.__, value: T): LodashSortedLastIndexBy1x2<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, value: T): LodashSortedLastIndexBy1x3<T>;
        <T>(iteratee: lodash.__, value: lodash.__, array: lodash.List<T> | null | undefined): LodashSortedLastIndexBy1x4<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, value: lodash.__, array: lodash.List<T> | null | undefined): LodashSortedLastIndexBy1x5<T>;
        <T>(iteratee: lodash.__, value: T, array: lodash.List<T> | null | undefined): LodashSortedLastIndexBy1x6<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, value: T, array: lodash.List<T> | null | undefined): number;
    }
    interface LodashSortedLastIndexBy1x1<T> {
        (value: T): LodashSortedLastIndexBy1x3<T>;
        (value: lodash.__, array: lodash.List<T> | null | undefined): LodashSortedLastIndexBy1x5<T>;
        (value: T, array: lodash.List<T> | null | undefined): number;
    }
    interface LodashSortedLastIndexBy1x2<T> {
        (iteratee: lodash.ValueIteratee<T>): LodashSortedLastIndexBy1x3<T>;
        (iteratee: lodash.__, array: lodash.List<T> | null | undefined): LodashSortedLastIndexBy1x6<T>;
        (iteratee: lodash.ValueIteratee<T>, array: lodash.List<T> | null | undefined): number;
    }
    type LodashSortedLastIndexBy1x3<T> = (array: lodash.List<T> | null | undefined) => number;
    interface LodashSortedLastIndexBy1x4<T> {
        (iteratee: lodash.ValueIteratee<T>): LodashSortedLastIndexBy1x5<T>;
        (iteratee: lodash.__, value: T): LodashSortedLastIndexBy1x6<T>;
        (iteratee: lodash.ValueIteratee<T>, value: T): number;
    }
    type LodashSortedLastIndexBy1x5<T> = (value: T) => number;
    type LodashSortedLastIndexBy1x6<T> = (iteratee: lodash.ValueIteratee<T>) => number;
    interface LodashSortedLastIndexOf {
        <T>(value: T): LodashSortedLastIndexOf1x1<T>;
        <T>(value: lodash.__, array: lodash.List<T> | null | undefined): LodashSortedLastIndexOf1x2<T>;
        <T>(value: T, array: lodash.List<T> | null | undefined): number;
    }
    type LodashSortedLastIndexOf1x1<T> = (array: lodash.List<T> | null | undefined) => number;
    type LodashSortedLastIndexOf1x2<T> = (value: T) => number;
    type LodashSortedUniq = <T>(array: lodash.List<T> | null | undefined) => T[];
    interface LodashSortedUniqBy {
        <T>(iteratee: lodash.ValueIteratee<T>): LodashSortedUniqBy1x1<T>;
        <T>(iteratee: lodash.__, array: lodash.List<T> | null | undefined): LodashSortedUniqBy1x2<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, array: lodash.List<T> | null | undefined): T[];
    }
    type LodashSortedUniqBy1x1<T> = (array: lodash.List<T> | null | undefined) => T[];
    type LodashSortedUniqBy1x2<T> = (iteratee: lodash.ValueIteratee<T>) => T[];
    interface LodashSplit {
        (separator: RegExp | string): LodashSplit1x1;
        (separator: lodash.__, string: string | null | undefined): LodashSplit1x2;
        (separator: RegExp | string, string: string | null | undefined): string[];
    }
    type LodashSplit1x1 = (string: string | null | undefined) => string[];
    type LodashSplit1x2 = (separator: RegExp | string) => string[];
    type LodashSpread = <TResult>(func: (...args: any[]) => TResult) => (...args: any[]) => TResult;
    interface LodashSpreadFrom {
        (start: number): LodashSpreadFrom1x1;
        <TResult>(start: lodash.__, func: (...args: any[]) => TResult): LodashSpreadFrom1x2<TResult>;
        <TResult>(start: number, func: (...args: any[]) => TResult): (...args: any[]) => TResult;
    }
    type LodashSpreadFrom1x1 = <TResult>(func: (...args: any[]) => TResult) => (...args: any[]) => TResult;
    type LodashSpreadFrom1x2<TResult> = (start: number) => (...args: any[]) => TResult;
    type LodashStartCase = (string: string) => string;
    interface LodashStartsWith {
        (target: string): LodashStartsWith1x1;
        (target: lodash.__, string: string): LodashStartsWith1x2;
        (target: string, string: string): boolean;
    }
    type LodashStartsWith1x1 = (string: string) => boolean;
    type LodashStartsWith1x2 = (target: string) => boolean;
    type LodashStubArray = () => any[];
    type LodashStubObject = () => any;
    type LodashStubString = () => string;
    type LodashStubTrue = () => true;
    interface LodashSubtract {
        (minuend: number): LodashSubtract1x1;
        (minuend: lodash.__, subtrahend: number): LodashSubtract1x2;
        (minuend: number, subtrahend: number): number;
    }
    type LodashSubtract1x1 = (subtrahend: number) => number;
    type LodashSubtract1x2 = (minuend: number) => number;
    type LodashSum = (collection: lodash.List<any> | null | undefined) => number;
    interface LodashSumBy {
        <T>(iteratee: ((value: T) => number) | string): LodashSumBy1x1<T>;
        <T>(iteratee: lodash.__, collection: lodash.List<T> | null | undefined): LodashSumBy1x2<T>;
        <T>(iteratee: ((value: T) => number) | string, collection: lodash.List<T> | null | undefined): number;
    }
    type LodashSumBy1x1<T> = (collection: lodash.List<T> | null | undefined) => number;
    type LodashSumBy1x2<T> = (iteratee: ((value: T) => number) | string) => number;
    interface LodashXor {
        <T>(arrays2: lodash.List<T> | null | undefined): LodashXor1x1<T>;
        <T>(arrays2: lodash.__, arrays: lodash.List<T> | null | undefined): LodashXor1x2<T>;
        <T>(arrays2: lodash.List<T> | null | undefined, arrays: lodash.List<T> | null | undefined): T[];
    }
    type LodashXor1x1<T> = (arrays: lodash.List<T> | null | undefined) => T[];
    type LodashXor1x2<T> = (arrays2: lodash.List<T> | null | undefined) => T[];
    interface LodashXorBy {
        <T>(iteratee: lodash.ValueIteratee<T>): LodashXorBy1x1<T>;
        <T>(iteratee: lodash.__, arrays: lodash.List<T> | null | undefined): LodashXorBy1x2<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, arrays: lodash.List<T> | null | undefined): LodashXorBy1x3<T>;
        <T>(iteratee: lodash.__, arrays: lodash.__, arrays2: lodash.List<T> | null | undefined): LodashXorBy1x4<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, arrays: lodash.__, arrays2: lodash.List<T> | null | undefined): LodashXorBy1x5<T>;
        <T>(iteratee: lodash.__, arrays: lodash.List<T> | null | undefined, arrays2: lodash.List<T> | null | undefined): LodashXorBy1x6<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, arrays: lodash.List<T> | null | undefined, arrays2: lodash.List<T> | null | undefined): T[];
    }
    interface LodashXorBy1x1<T> {
        (arrays: lodash.List<T> | null | undefined): LodashXorBy1x3<T>;
        (arrays: lodash.__, arrays2: lodash.List<T> | null | undefined): LodashXorBy1x5<T>;
        (arrays: lodash.List<T> | null | undefined, arrays2: lodash.List<T> | null | undefined): T[];
    }
    interface LodashXorBy1x2<T> {
        (iteratee: lodash.ValueIteratee<T>): LodashXorBy1x3<T>;
        (iteratee: lodash.__, arrays2: lodash.List<T> | null | undefined): LodashXorBy1x6<T>;
        (iteratee: lodash.ValueIteratee<T>, arrays2: lodash.List<T> | null | undefined): T[];
    }
    type LodashXorBy1x3<T> = (arrays2: lodash.List<T> | null | undefined) => T[];
    interface LodashXorBy1x4<T> {
        (iteratee: lodash.ValueIteratee<T>): LodashXorBy1x5<T>;
        (iteratee: lodash.__, arrays: lodash.List<T> | null | undefined): LodashXorBy1x6<T>;
        (iteratee: lodash.ValueIteratee<T>, arrays: lodash.List<T> | null | undefined): T[];
    }
    type LodashXorBy1x5<T> = (arrays: lodash.List<T> | null | undefined) => T[];
    type LodashXorBy1x6<T> = (iteratee: lodash.ValueIteratee<T>) => T[];
    interface LodashXorWith {
        <T>(comparator: lodash.Comparator<T>): LodashXorWith1x1<T>;
        <T>(comparator: lodash.__, arrays: lodash.List<T> | null | undefined): LodashXorWith1x2<T>;
        <T>(comparator: lodash.Comparator<T>, arrays: lodash.List<T> | null | undefined): LodashXorWith1x3<T>;
        <T>(comparator: lodash.__, arrays: lodash.__, arrays2: lodash.List<T> | null | undefined): LodashXorWith1x4<T>;
        <T>(comparator: lodash.Comparator<T>, arrays: lodash.__, arrays2: lodash.List<T> | null | undefined): LodashXorWith1x5<T>;
        <T>(comparator: lodash.__, arrays: lodash.List<T> | null | undefined, arrays2: lodash.List<T> | null | undefined): LodashXorWith1x6<T>;
        <T>(comparator: lodash.Comparator<T>, arrays: lodash.List<T> | null | undefined, arrays2: lodash.List<T> | null | undefined): T[];
    }
    interface LodashXorWith1x1<T> {
        (arrays: lodash.List<T> | null | undefined): LodashXorWith1x3<T>;
        (arrays: lodash.__, arrays2: lodash.List<T> | null | undefined): LodashXorWith1x5<T>;
        (arrays: lodash.List<T> | null | undefined, arrays2: lodash.List<T> | null | undefined): T[];
    }
    interface LodashXorWith1x2<T> {
        (comparator: lodash.Comparator<T>): LodashXorWith1x3<T>;
        (comparator: lodash.__, arrays2: lodash.List<T> | null | undefined): LodashXorWith1x6<T>;
        (comparator: lodash.Comparator<T>, arrays2: lodash.List<T> | null | undefined): T[];
    }
    type LodashXorWith1x3<T> = (arrays2: lodash.List<T> | null | undefined) => T[];
    interface LodashXorWith1x4<T> {
        (comparator: lodash.Comparator<T>): LodashXorWith1x5<T>;
        (comparator: lodash.__, arrays: lodash.List<T> | null | undefined): LodashXorWith1x6<T>;
        (comparator: lodash.Comparator<T>, arrays: lodash.List<T> | null | undefined): T[];
    }
    type LodashXorWith1x5<T> = (arrays: lodash.List<T> | null | undefined) => T[];
    type LodashXorWith1x6<T> = (comparator: lodash.Comparator<T>) => T[];
    type LodashTail = <T>(array: lodash.List<T> | null | undefined) => T[];
    interface LodashTake {
        (n: number): LodashTake1x1;
        <T>(n: lodash.__, array: lodash.List<T> | null | undefined): LodashTake1x2<T>;
        <T>(n: number, array: lodash.List<T> | null | undefined): T[];
    }
    type LodashTake1x1 = <T>(array: lodash.List<T> | null | undefined) => T[];
    type LodashTake1x2<T> = (n: number) => T[];
    interface LodashTakeRight {
        (n: number): LodashTakeRight1x1;
        <T>(n: lodash.__, array: lodash.List<T> | null | undefined): LodashTakeRight1x2<T>;
        <T>(n: number, array: lodash.List<T> | null | undefined): T[];
    }
    type LodashTakeRight1x1 = <T>(array: lodash.List<T> | null | undefined) => T[];
    type LodashTakeRight1x2<T> = (n: number) => T[];
    interface LodashTakeRightWhile {
        <T>(predicate: lodash.ValueIteratee<T>): LodashTakeRightWhile1x1<T>;
        <T>(predicate: lodash.__, array: lodash.List<T> | null | undefined): LodashTakeRightWhile1x2<T>;
        <T>(predicate: lodash.ValueIteratee<T>, array: lodash.List<T> | null | undefined): T[];
    }
    type LodashTakeRightWhile1x1<T> = (array: lodash.List<T> | null | undefined) => T[];
    type LodashTakeRightWhile1x2<T> = (predicate: lodash.ValueIteratee<T>) => T[];
    interface LodashTakeWhile {
        <T>(predicate: lodash.ValueIteratee<T>): LodashTakeWhile1x1<T>;
        <T>(predicate: lodash.__, array: lodash.List<T> | null | undefined): LodashTakeWhile1x2<T>;
        <T>(predicate: lodash.ValueIteratee<T>, array: lodash.List<T> | null | undefined): T[];
    }
    type LodashTakeWhile1x1<T> = (array: lodash.List<T> | null | undefined) => T[];
    type LodashTakeWhile1x2<T> = (predicate: lodash.ValueIteratee<T>) => T[];
    interface LodashTap {
        <T>(interceptor: (value: T) => void): LodashTap1x1<T>;
        <T>(interceptor: lodash.__, value: T): LodashTap1x2<T>;
        <T>(interceptor: (value: T) => void, value: T): T;
    }
    type LodashTap1x1<T> = (value: T) => T;
    type LodashTap1x2<T> = (interceptor: (value: T) => void) => T;
    type LodashTemplate = (string: string) => lodash.TemplateExecutor;
    interface LodashThrottle {
        (wait: number): LodashThrottle1x1;
        <T extends (...args: any) => any>(wait: lodash.__, func: T): LodashThrottle1x2<T>;
        <T extends (...args: any) => any>(wait: number, func: T): lodash.DebouncedFuncLeading<T>;
    }
    type LodashThrottle1x1 = <T extends (...args: any) => any>(func: T) => lodash.DebouncedFuncLeading<T>;
    type LodashThrottle1x2<T extends (...args: any) => any> = (wait: number) => lodash.DebouncedFuncLeading<T>;
    interface LodashThru {
        <T, TResult>(interceptor: (value: T) => TResult): LodashThru1x1<T, TResult>;
        <T>(interceptor: lodash.__, value: T): LodashThru1x2<T>;
        <T, TResult>(interceptor: (value: T) => TResult, value: T): TResult;
    }
    type LodashThru1x1<T, TResult> = (value: T) => TResult;
    type LodashThru1x2<T> = <TResult>(interceptor: (value: T) => TResult) => TResult;
    interface LodashTimes {
        <TResult>(iteratee: (num: number) => TResult): LodashTimes1x1<TResult>;
        (iteratee: lodash.__, n: number): LodashTimes1x2;
        <TResult>(iteratee: (num: number) => TResult, n: number): TResult[];
    }
    type LodashTimes1x1<TResult> = (n: number) => TResult[];
    type LodashTimes1x2 = <TResult>(iteratee: (num: number) => TResult) => TResult[];
    interface LodashToArray {
        <T>(value:  lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): T[];
        <T>(value: T): Array<T[keyof T]>;
        (): any[];
    }
    type LodashToFinite = (value: any) => number;
    type LodashToInteger = (value: any) => number;
    type LodashToLength = (value: any) => number;
    type LodashToLower = (string: string) => string;
    type LodashToNumber = (value: any) => number;
    type LodashToPath = (value: any) => string[];
    type LodashToPlainObject = (value: any) => any;
    type LodashToSafeInteger = (value: any) => number;
    type LodashToString = (value: any) => string;
    type LodashToUpper = (string: string) => string;
    interface LodashTransform {
        <T, TResult>(iteratee: lodash.MemoVoidIteratorCapped<T, TResult>): LodashTransform1x1<T, TResult>;
        <TResult>(iteratee: lodash.__, accumulator: TResult): LodashTransform1x2<TResult>;
        <T, TResult>(iteratee: lodash.MemoVoidIteratorCapped<T, TResult>, accumulator: TResult): LodashTransform1x3<T, TResult>;
        <T>(iteratee: lodash.__, accumulator: lodash.__, object: readonly T[]): LodashTransform1x4<T>;
        <T, TResult>(iteratee: lodash.MemoVoidIteratorCapped<T, TResult>, accumulator: lodash.__, object: readonly T[]): LodashTransform1x5<TResult>;
        <T, TResult>(iteratee: lodash.__, accumulator: TResult, object: readonly T[]): LodashTransform1x6<T, TResult>;
        <T, TResult>(iteratee: lodash.MemoVoidIteratorCapped<T, TResult>, accumulator: TResult, object: readonly T[] | lodash.Dictionary<T>): TResult;
        <T>(iteratee: lodash.__, accumulator: lodash.__, object: lodash.Dictionary<T>): LodashTransform2x4<T>;
        <T, TResult>(iteratee: lodash.MemoVoidIteratorCapped<T, TResult>, accumulator: lodash.__, object: lodash.Dictionary<T>): LodashTransform2x5<TResult>;
        <T, TResult>(iteratee: lodash.__, accumulator: TResult, object: lodash.Dictionary<T>): LodashTransform2x6<T, TResult>;
    }
    interface LodashTransform1x1<T, TResult> {
        (accumulator: TResult): LodashTransform1x3<T, TResult>;
        (accumulator: lodash.__, object: readonly T[]): LodashTransform1x5<TResult>;
        (accumulator: TResult, object: readonly T[] | lodash.Dictionary<T>): TResult;
        (accumulator: lodash.__, object: lodash.Dictionary<T>): LodashTransform2x5<TResult>;
    }
    interface LodashTransform1x2<TResult> {
        <T>(iteratee: lodash.MemoVoidIteratorCapped<T, TResult>): LodashTransform1x3<T, TResult>;
        <T>(iteratee: lodash.__, object: readonly T[]): LodashTransform1x6<T, TResult>;
        <T>(iteratee: lodash.MemoVoidIteratorCapped<T, TResult>, object: readonly T[] | lodash.Dictionary<T>): TResult;
        <T>(iteratee: lodash.__, object: lodash.Dictionary<T>): LodashTransform2x6<T, TResult>;
    }
    type LodashTransform1x3<T, TResult> = (object: readonly T[] | lodash.Dictionary<T>) => TResult;
    interface LodashTransform1x4<T> {
        <TResult>(iteratee: lodash.MemoVoidIteratorCapped<T, TResult>): LodashTransform1x5<TResult>;
        <TResult>(iteratee: lodash.__, accumulator: TResult): LodashTransform1x6<T, TResult>;
        <TResult>(iteratee: lodash.MemoVoidIteratorCapped<T, TResult>, accumulator: TResult): TResult;
    }
    type LodashTransform1x5<TResult> = (accumulator: TResult) => TResult;
    type LodashTransform1x6<T, TResult> = (iteratee: lodash.MemoVoidIteratorCapped<T, TResult>) => TResult;
    interface LodashTransform2x4<T> {
        <TResult>(iteratee: lodash.MemoVoidIteratorCapped<T, TResult>): LodashTransform2x5<TResult>;
        <TResult>(iteratee: lodash.__, accumulator: TResult): LodashTransform2x6<T, TResult>;
        <TResult>(iteratee: lodash.MemoVoidIteratorCapped<T, TResult>, accumulator: TResult): TResult;
    }
    type LodashTransform2x5<TResult> = (accumulator: TResult) => TResult;
    type LodashTransform2x6<T, TResult> = (iteratee: lodash.MemoVoidIteratorCapped<T, TResult>) => TResult;
    type LodashTrim = (string: string) => string;
    interface LodashTrimChars {
        (chars: string): LodashTrimChars1x1;
        (chars: lodash.__, string: string): LodashTrimChars1x2;
        (chars: string, string: string): string;
    }
    type LodashTrimChars1x1 = (string: string) => string;
    type LodashTrimChars1x2 = (chars: string) => string;
    interface LodashTrimCharsEnd {
        (chars: string): LodashTrimCharsEnd1x1;
        (chars: lodash.__, string: string): LodashTrimCharsEnd1x2;
        (chars: string, string: string): string;
    }
    type LodashTrimCharsEnd1x1 = (string: string) => string;
    type LodashTrimCharsEnd1x2 = (chars: string) => string;
    interface LodashTrimCharsStart {
        (chars: string): LodashTrimCharsStart1x1;
        (chars: lodash.__, string: string): LodashTrimCharsStart1x2;
        (chars: string, string: string): string;
    }
    type LodashTrimCharsStart1x1 = (string: string) => string;
    type LodashTrimCharsStart1x2 = (chars: string) => string;
    type LodashTrimEnd = (string: string) => string;
    type LodashTrimStart = (string: string) => string;
    interface LodashTruncate {
        (options: lodash.TruncateOptions): LodashTruncate1x1;
        (options: lodash.__, string: string): LodashTruncate1x2;
        (options: lodash.TruncateOptions, string: string): string;
    }
    type LodashTruncate1x1 = (string: string) => string;
    type LodashTruncate1x2 = (options: lodash.TruncateOptions) => string;
    type LodashUnapply = (func: (...args: any[]) => any) => (...args: any[]) => any;
    type LodashUnary = <T, TResult>(func: (arg1: T, ...args: any[]) => TResult) => (arg1: T) => TResult;
    type LodashUnescape = (string: string) => string;
    interface LodashUnion {
        <T>(arrays2: lodash.List<T> | null | undefined): LodashUnion1x1<T>;
        <T>(arrays2: lodash.__, arrays: lodash.List<T> | null | undefined): LodashUnion1x2<T>;
        <T>(arrays2: lodash.List<T> | null | undefined, arrays: lodash.List<T> | null | undefined): T[];
    }
    type LodashUnion1x1<T> = (arrays: lodash.List<T> | null | undefined) => T[];
    type LodashUnion1x2<T> = (arrays2: lodash.List<T> | null | undefined) => T[];
    interface LodashUnionBy {
        <T>(iteratee: lodash.ValueIteratee<T>): LodashUnionBy1x1<T>;
        <T>(iteratee: lodash.__, arrays1: lodash.List<T> | null | undefined): LodashUnionBy1x2<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, arrays1: lodash.List<T> | null | undefined): LodashUnionBy1x3<T>;
        <T>(iteratee: lodash.__, arrays1: lodash.__, arrays2: lodash.List<T> | null | undefined): LodashUnionBy1x4<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, arrays1: lodash.__, arrays2: lodash.List<T> | null | undefined): LodashUnionBy1x5<T>;
        <T>(iteratee: lodash.__, arrays1: lodash.List<T> | null | undefined, arrays2: lodash.List<T> | null | undefined): LodashUnionBy1x6<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, arrays1: lodash.List<T> | null | undefined, arrays2: lodash.List<T> | null | undefined): T[];
    }
    interface LodashUnionBy1x1<T> {
        (arrays1: lodash.List<T> | null | undefined): LodashUnionBy1x3<T>;
        (arrays1: lodash.__, arrays2: lodash.List<T> | null | undefined): LodashUnionBy1x5<T>;
        (arrays1: lodash.List<T> | null | undefined, arrays2: lodash.List<T> | null | undefined): T[];
    }
    interface LodashUnionBy1x2<T> {
        (iteratee: lodash.ValueIteratee<T>): LodashUnionBy1x3<T>;
        (iteratee: lodash.__, arrays2: lodash.List<T> | null | undefined): LodashUnionBy1x6<T>;
        (iteratee: lodash.ValueIteratee<T>, arrays2: lodash.List<T> | null | undefined): T[];
    }
    type LodashUnionBy1x3<T> = (arrays2: lodash.List<T> | null | undefined) => T[];
    interface LodashUnionBy1x4<T> {
        (iteratee: lodash.ValueIteratee<T>): LodashUnionBy1x5<T>;
        (iteratee: lodash.__, arrays1: lodash.List<T> | null | undefined): LodashUnionBy1x6<T>;
        (iteratee: lodash.ValueIteratee<T>, arrays1: lodash.List<T> | null | undefined): T[];
    }
    type LodashUnionBy1x5<T> = (arrays1: lodash.List<T> | null | undefined) => T[];
    type LodashUnionBy1x6<T> = (iteratee: lodash.ValueIteratee<T>) => T[];
    interface LodashUnionWith {
        <T>(comparator: lodash.Comparator<T>): LodashUnionWith1x1<T>;
        <T>(comparator: lodash.__, arrays: lodash.List<T> | null | undefined): LodashUnionWith1x2<T>;
        <T>(comparator: lodash.Comparator<T>, arrays: lodash.List<T> | null | undefined): LodashUnionWith1x3<T>;
        <T>(comparator: lodash.__, arrays: lodash.__, arrays2: lodash.List<T> | null | undefined): LodashUnionWith1x4<T>;
        <T>(comparator: lodash.Comparator<T>, arrays: lodash.__, arrays2: lodash.List<T> | null | undefined): LodashUnionWith1x5<T>;
        <T>(comparator: lodash.__, arrays: lodash.List<T> | null | undefined, arrays2: lodash.List<T> | null | undefined): LodashUnionWith1x6<T>;
        <T>(comparator: lodash.Comparator<T>, arrays: lodash.List<T> | null | undefined, arrays2: lodash.List<T> | null | undefined): T[];
    }
    interface LodashUnionWith1x1<T> {
        (arrays: lodash.List<T> | null | undefined): LodashUnionWith1x3<T>;
        (arrays: lodash.__, arrays2: lodash.List<T> | null | undefined): LodashUnionWith1x5<T>;
        (arrays: lodash.List<T> | null | undefined, arrays2: lodash.List<T> | null | undefined): T[];
    }
    interface LodashUnionWith1x2<T> {
        (comparator: lodash.Comparator<T>): LodashUnionWith1x3<T>;
        (comparator: lodash.__, arrays2: lodash.List<T> | null | undefined): LodashUnionWith1x6<T>;
        (comparator: lodash.Comparator<T>, arrays2: lodash.List<T> | null | undefined): T[];
    }
    type LodashUnionWith1x3<T> = (arrays2: lodash.List<T> | null | undefined) => T[];
    interface LodashUnionWith1x4<T> {
        (comparator: lodash.Comparator<T>): LodashUnionWith1x5<T>;
        (comparator: lodash.__, arrays: lodash.List<T> | null | undefined): LodashUnionWith1x6<T>;
        (comparator: lodash.Comparator<T>, arrays: lodash.List<T> | null | undefined): T[];
    }
    type LodashUnionWith1x5<T> = (arrays: lodash.List<T> | null | undefined) => T[];
    type LodashUnionWith1x6<T> = (comparator: lodash.Comparator<T>) => T[];
    type LodashUniq = <T>(array: lodash.List<T> | null | undefined) => T[];
    interface LodashUniqBy {
        <T>(iteratee: lodash.ValueIteratee<T>): LodashUniqBy1x1<T>;
        <T>(iteratee: lodash.__, array: lodash.List<T> | null | undefined): LodashUniqBy1x2<T>;
        <T>(iteratee: lodash.ValueIteratee<T>, array: lodash.List<T> | null | undefined): T[];
    }
    type LodashUniqBy1x1<T> = (array: lodash.List<T> | null | undefined) => T[];
    type LodashUniqBy1x2<T> = (iteratee: lodash.ValueIteratee<T>) => T[];
    type LodashUniqueId = (prefix: string) => string;
    interface LodashUniqWith {
        <T>(comparator: lodash.Comparator<T>): LodashUniqWith1x1<T>;
        <T>(comparator: lodash.__, array: lodash.List<T> | null | undefined): LodashUniqWith1x2<T>;
        <T>(comparator: lodash.Comparator<T>, array: lodash.List<T> | null | undefined): T[];
    }
    type LodashUniqWith1x1<T> = (array: lodash.List<T> | null | undefined) => T[];
    type LodashUniqWith1x2<T> = (comparator: lodash.Comparator<T>) => T[];
    type LodashUnzip = <T>(array: T[][] | lodash.List<lodash.List<T>> | null | undefined) => T[][];
    interface LodashUnzipWith {
        <T, TResult>(iteratee: (...values: T[]) => TResult): LodashUnzipWith1x1<T, TResult>;
        <T>(iteratee: lodash.__, array: lodash.List<lodash.List<T>> | null | undefined): LodashUnzipWith1x2<T>;
        <T, TResult>(iteratee: (...values: T[]) => TResult, array: lodash.List<lodash.List<T>> | null | undefined): TResult[];
    }
    type LodashUnzipWith1x1<T, TResult> = (array: lodash.List<lodash.List<T>> | null | undefined) => TResult[];
    type LodashUnzipWith1x2<T> = <TResult>(iteratee: (...values: T[]) => TResult) => TResult[];
    interface LodashUpdate {
        (path: lodash.PropertyPath): LodashUpdate1x1;
        (path: lodash.__, updater: (value: any) => any): LodashUpdate1x2;
        (path: lodash.PropertyPath, updater: (value: any) => any): LodashUpdate1x3;
        (path: lodash.__, updater: lodash.__, object: object): LodashUpdate1x4;
        (path: lodash.PropertyPath, updater: lodash.__, object: object): LodashUpdate1x5;
        (path: lodash.__, updater: (value: any) => any, object: object): LodashUpdate1x6;
        (path: lodash.PropertyPath, updater: (value: any) => any, object: object): any;
    }
    interface LodashUpdate1x1 {
        (updater: (value: any) => any): LodashUpdate1x3;
        (updater: lodash.__, object: object): LodashUpdate1x5;
        (updater: (value: any) => any, object: object): any;
    }
    interface LodashUpdate1x2 {
        (path: lodash.PropertyPath): LodashUpdate1x3;
        (path: lodash.__, object: object): LodashUpdate1x6;
        (path: lodash.PropertyPath, object: object): any;
    }
    type LodashUpdate1x3 = (object: object) => any;
    interface LodashUpdate1x4 {
        (path: lodash.PropertyPath): LodashUpdate1x5;
        (path: lodash.__, updater: (value: any) => any): LodashUpdate1x6;
        (path: lodash.PropertyPath, updater: (value: any) => any): any;
    }
    type LodashUpdate1x5 = (updater: (value: any) => any) => any;
    type LodashUpdate1x6 = (path: lodash.PropertyPath) => any;
    interface LodashUpdateWith {
        <T extends object>(customizer: lodash.SetWithCustomizer<T>): LodashUpdateWith1x1<T>;
        (customizer: lodash.__, path: lodash.PropertyPath): LodashUpdateWith1x2;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, path: lodash.PropertyPath): LodashUpdateWith1x3<T>;
        (customizer: lodash.__, path: lodash.__, updater: (oldValue: any) => any): LodashUpdateWith1x4;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, path: lodash.__, updater: (oldValue: any) => any): LodashUpdateWith1x5<T>;
        (customizer: lodash.__, path: lodash.PropertyPath, updater: (oldValue: any) => any): LodashUpdateWith1x6;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, path: lodash.PropertyPath, updater: (oldValue: any) => any): LodashUpdateWith1x7<T>;
        <T extends object>(customizer: lodash.__, path: lodash.__, updater: lodash.__, object: T): LodashUpdateWith1x8<T>;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, path: lodash.__, updater: lodash.__, object: T): LodashUpdateWith1x9<T>;
        <T extends object>(customizer: lodash.__, path: lodash.PropertyPath, updater: lodash.__, object: T): LodashUpdateWith1x10<T>;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, path: lodash.PropertyPath, updater: lodash.__, object: T): LodashUpdateWith1x11<T>;
        <T extends object>(customizer: lodash.__, path: lodash.__, updater: (oldValue: any) => any, object: T): LodashUpdateWith1x12<T>;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, path: lodash.__, updater: (oldValue: any) => any, object: T): LodashUpdateWith1x13<T>;
        <T extends object>(customizer: lodash.__, path: lodash.PropertyPath, updater: (oldValue: any) => any, object: T): LodashUpdateWith1x14<T>;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, path: lodash.PropertyPath, updater: (oldValue: any) => any, object: T): T;
    }
    interface LodashUpdateWith1x1<T> {
        (path: lodash.PropertyPath): LodashUpdateWith1x3<T>;
        (path: lodash.__, updater: (oldValue: any) => any): LodashUpdateWith1x5<T>;
        (path: lodash.PropertyPath, updater: (oldValue: any) => any): LodashUpdateWith1x7<T>;
        (path: lodash.__, updater: lodash.__, object: T): LodashUpdateWith1x9<T>;
        (path: lodash.PropertyPath, updater: lodash.__, object: T): LodashUpdateWith1x11<T>;
        (path: lodash.__, updater: (oldValue: any) => any, object: T): LodashUpdateWith1x13<T>;
        (path: lodash.PropertyPath, updater: (oldValue: any) => any, object: T): T;
    }
    interface LodashUpdateWith1x2 {
        <T extends object>(customizer: lodash.SetWithCustomizer<T>): LodashUpdateWith1x3<T>;
        (customizer: lodash.__, updater: (oldValue: any) => any): LodashUpdateWith1x6;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, updater: (oldValue: any) => any): LodashUpdateWith1x7<T>;
        <T extends object>(customizer: lodash.__, updater: lodash.__, object: T): LodashUpdateWith1x10<T>;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, updater: lodash.__, object: T): LodashUpdateWith1x11<T>;
        <T extends object>(customizer: lodash.__, updater: (oldValue: any) => any, object: T): LodashUpdateWith1x14<T>;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, updater: (oldValue: any) => any, object: T): T;
    }
    interface LodashUpdateWith1x3<T> {
        (updater: (oldValue: any) => any): LodashUpdateWith1x7<T>;
        (updater: lodash.__, object: T): LodashUpdateWith1x11<T>;
        (updater: (oldValue: any) => any, object: T): T;
    }
    interface LodashUpdateWith1x4 {
        <T extends object>(customizer: lodash.SetWithCustomizer<T>): LodashUpdateWith1x5<T>;
        (customizer: lodash.__, path: lodash.PropertyPath): LodashUpdateWith1x6;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, path: lodash.PropertyPath): LodashUpdateWith1x7<T>;
        <T extends object>(customizer: lodash.__, path: lodash.__, object: T): LodashUpdateWith1x12<T>;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, path: lodash.__, object: T): LodashUpdateWith1x13<T>;
        <T extends object>(customizer: lodash.__, path: lodash.PropertyPath, object: T): LodashUpdateWith1x14<T>;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, path: lodash.PropertyPath, object: T): T;
    }
    interface LodashUpdateWith1x5<T> {
        (path: lodash.PropertyPath): LodashUpdateWith1x7<T>;
        (path: lodash.__, object: T): LodashUpdateWith1x13<T>;
        (path: lodash.PropertyPath, object: T): T;
    }
    interface LodashUpdateWith1x6 {
        <T extends object>(customizer: lodash.SetWithCustomizer<T>): LodashUpdateWith1x7<T>;
        <T extends object>(customizer: lodash.__, object: T): LodashUpdateWith1x14<T>;
        <T extends object>(customizer: lodash.SetWithCustomizer<T>, object: T): T;
    }
    type LodashUpdateWith1x7<T> = (object: T) => T;
    interface LodashUpdateWith1x8<T> {
        (customizer: lodash.SetWithCustomizer<T>): LodashUpdateWith1x9<T>;
        (customizer: lodash.__, path: lodash.PropertyPath): LodashUpdateWith1x10<T>;
        (customizer: lodash.SetWithCustomizer<T>, path: lodash.PropertyPath): LodashUpdateWith1x11<T>;
        (customizer: lodash.__, path: lodash.__, updater: (oldValue: any) => any): LodashUpdateWith1x12<T>;
        (customizer: lodash.SetWithCustomizer<T>, path: lodash.__, updater: (oldValue: any) => any): LodashUpdateWith1x13<T>;
        (customizer: lodash.__, path: lodash.PropertyPath, updater: (oldValue: any) => any): LodashUpdateWith1x14<T>;
        (customizer: lodash.SetWithCustomizer<T>, path: lodash.PropertyPath, updater: (oldValue: any) => any): T;
    }
    interface LodashUpdateWith1x9<T> {
        (path: lodash.PropertyPath): LodashUpdateWith1x11<T>;
        (path: lodash.__, updater: (oldValue: any) => any): LodashUpdateWith1x13<T>;
        (path: lodash.PropertyPath, updater: (oldValue: any) => any): T;
    }
    interface LodashUpdateWith1x10<T> {
        (customizer: lodash.SetWithCustomizer<T>): LodashUpdateWith1x11<T>;
        (customizer: lodash.__, updater: (oldValue: any) => any): LodashUpdateWith1x14<T>;
        (customizer: lodash.SetWithCustomizer<T>, updater: (oldValue: any) => any): T;
    }
    type LodashUpdateWith1x11<T> = (updater: (oldValue: any) => any) => T;
    interface LodashUpdateWith1x12<T> {
        (customizer: lodash.SetWithCustomizer<T>): LodashUpdateWith1x13<T>;
        (customizer: lodash.__, path: lodash.PropertyPath): LodashUpdateWith1x14<T>;
        (customizer: lodash.SetWithCustomizer<T>, path: lodash.PropertyPath): T;
    }
    type LodashUpdateWith1x13<T> = (path: lodash.PropertyPath) => T;
    type LodashUpdateWith1x14<T> = (customizer: lodash.SetWithCustomizer<T>) => T;
    type LodashUpperCase = (string: string) => string;
    type LodashUpperFirst = (string: string) => string;
    interface LodashValues {
        <T>(object: lodash.Dictionary<T> | lodash.NumericDictionary<T> | lodash.List<T> | null | undefined): T[];
        <T extends object>(object: T | null | undefined): Array<T[keyof T]>;
        (object: any): any[];
    }
    interface LodashValuesIn {
        <T>(object: lodash.Dictionary<T> | lodash.NumericDictionary<T> | lodash.List<T> | null | undefined): T[];
        <T extends object>(object: T | null | undefined): Array<T[keyof T]>;
    }
    interface LodashWithout {
        <T>(values: readonly T[]): LodashWithout1x1<T>;
        <T>(values: lodash.__, array: lodash.List<T> | null | undefined): LodashWithout1x2<T>;
        <T>(values: readonly T[], array: lodash.List<T> | null | undefined): T[];
    }
    type LodashWithout1x1<T> = (array: lodash.List<T> | null | undefined) => T[];
    type LodashWithout1x2<T> = (values: readonly T[]) => T[];
    type LodashWords = (string: string) => string[];
    interface LodashWrap {
        <T, TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult): LodashWrap1x1<T, TArgs, TResult>;
        <T>(wrapper: lodash.__, value: T): LodashWrap1x2<T>;
        <T, TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult, value: T): (...args: TArgs[]) => TResult;
    }
    type LodashWrap1x1<T, TArgs, TResult> = (value: T) => (...args: TArgs[]) => TResult;
    type LodashWrap1x2<T> = <TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => (...args: TArgs[]) => TResult;
    interface LodashZip {
        <T1>(arrays1: lodash.List<T1>): LodashZip1x1<T1>;
        <T2>(arrays1: lodash.__, arrays2: lodash.List<T2>): LodashZip1x2<T2>;
        <T1, T2>(arrays1: lodash.List<T1>, arrays2: lodash.List<T2>): Array<[T1 | undefined, T2 | undefined]>;
    }
    type LodashZip1x1<T1> = <T2>(arrays2: lodash.List<T2>) => Array<[T1 | undefined, T2 | undefined]>;
    type LodashZip1x2<T2> = <T1>(arrays1: lodash.List<T1>) => Array<[T1 | undefined, T2 | undefined]>;
    interface LodashZipAll {
        <T1, T2>(arrays1: [lodash.List<T1>, lodash.List<T2>]): Array<[T1 | undefined, T2 | undefined]>;
        <T1, T2, T3>(arrays1: [lodash.List<T1>, lodash.List<T2>, lodash.List<T3>]): Array<[T1 | undefined, T2 | undefined, T3 | undefined]>;
        <T1, T2, T3, T4>(arrays1: [lodash.List<T1>, lodash.List<T2>, lodash.List<T3>, lodash.List<T4>]): Array<[T1 | undefined, T2 | undefined, T3 | undefined, T4 | undefined]>;
        <T1, T2, T3, T4, T5>(arrays1: [lodash.List<T1>, lodash.List<T2>, lodash.List<T3>, lodash.List<T4>, lodash.List<T5>]): Array<[T1 | undefined, T2 | undefined, T3 | undefined, T4 | undefined, T5 | undefined]>;
        <T>(arrays: ReadonlyArray<lodash.List<T> | null | undefined>): Array<Array<T | undefined>>;
    }
    interface LodashZipObject {
        (props: lodash.List<lodash.PropertyName>): LodashZipObject1x1;
        <T>(props: lodash.__, values: lodash.List<T>): LodashZipObject1x2<T>;
        <T>(props: lodash.List<lodash.PropertyName>, values: lodash.List<T>): lodash.Dictionary<T>;
    }
    type LodashZipObject1x1 = <T>(values: lodash.List<T>) => lodash.Dictionary<T>;
    type LodashZipObject1x2<T> = (props: lodash.List<lodash.PropertyName>) => lodash.Dictionary<T>;
    interface LodashZipObjectDeep {
        (paths: lodash.List<lodash.PropertyPath>): LodashZipObjectDeep1x1;
        (paths: lodash.__, values: lodash.List<any>): LodashZipObjectDeep1x2;
        (paths: lodash.List<lodash.PropertyPath>, values: lodash.List<any>): object;
    }
    type LodashZipObjectDeep1x1 = (values: lodash.List<any>) => object;
    type LodashZipObjectDeep1x2 = (paths: lodash.List<lodash.PropertyPath>) => object;
    interface LodashZipWith {
        <T1, T2, TResult>(iteratee: (value1: T1, value2: T2) => TResult): LodashZipWith1x1<T1, T2, TResult>;
        <T1>(iteratee: lodash.__, arrays1: lodash.List<T1>): LodashZipWith1x2<T1>;
        <T1, T2, TResult>(iteratee: (value1: T1, value2: T2) => TResult, arrays1: lodash.List<T1>): LodashZipWith1x3<T2, TResult>;
        <T2>(iteratee: lodash.__, arrays1: lodash.__, arrays2: lodash.List<T2>): LodashZipWith1x4<T2>;
        <T1, T2, TResult>(iteratee: (value1: T1, value2: T2) => TResult, arrays1: lodash.__, arrays2: lodash.List<T2>): LodashZipWith1x5<T1, TResult>;
        <T1, T2>(iteratee: lodash.__, arrays1: lodash.List<T1>, arrays2: lodash.List<T2>): LodashZipWith1x6<T1, T2>;
        <T1, T2, TResult>(iteratee: (value1: T1, value2: T2) => TResult, arrays1: lodash.List<T1>, arrays2: lodash.List<T2>): TResult[];
    }
    interface LodashZipWith1x1<T1, T2, TResult> {
        (arrays1: lodash.List<T1>): LodashZipWith1x3<T2, TResult>;
        (arrays1: lodash.__, arrays2: lodash.List<T2>): LodashZipWith1x5<T1, TResult>;
        (arrays1: lodash.List<T1>, arrays2: lodash.List<T2>): TResult[];
    }
    interface LodashZipWith1x2<T1> {
        <T2, TResult>(iteratee: (value1: T1, value2: T2) => TResult): LodashZipWith1x3<T2, TResult>;
        <T2>(iteratee: lodash.__, arrays2: lodash.List<T2>): LodashZipWith1x6<T1, T2>;
        <T2, TResult>(iteratee: (value1: T1, value2: T2) => TResult, arrays2: lodash.List<T2>): TResult[];
    }
    type LodashZipWith1x3<T2, TResult> = (arrays2: lodash.List<T2>) => TResult[];
    interface LodashZipWith1x4<T2> {
        <T1, TResult>(iteratee: (value1: T1, value2: T2) => TResult): LodashZipWith1x5<T1, TResult>;
        <T1>(iteratee: lodash.__, arrays1: lodash.List<T1>): LodashZipWith1x6<T1, T2>;
        <T1, TResult>(iteratee: (value1: T1, value2: T2) => TResult, arrays1: lodash.List<T1>): TResult[];
    }
    type LodashZipWith1x5<T1, TResult> = (arrays1: lodash.List<T1>) => TResult[];
    type LodashZipWith1x6<T1, T2> = <TResult>(iteratee: (value1: T1, value2: T2) => TResult) => TResult[];

    interface LoDashFp {
        add: LodashAdd;
        after: LodashAfter;
        all: LodashEvery;
        allPass: LodashOverEvery;
        always: LodashConstant;
        any: LodashSome;
        anyPass: LodashOverSome;
        apply: LodashApply;
        ary: LodashAry;
        assign: LodashAssign;
        assignAll: LodashAssignAll;
        assignAllWith: LodashAssignAllWith;
        assignIn: LodashAssignIn;
        assignInAll: LodashAssignInAll;
        assignInAllWith: LodashAssignInAllWith;
        assignInWith: LodashAssignInWith;
        assignWith: LodashAssignWith;
        assoc: LodashSet;
        assocPath: LodashSet;
        at: LodashAt;
        attempt: LodashAttempt;
        before: LodashBefore;
        bind: LodashBind;
        bindAll: LodashBindAll;
        bindKey: LodashBindKey;
        camelCase: LodashCamelCase;
        capitalize: LodashCapitalize;
        castArray: LodashCastArray;
        ceil: LodashCeil;
        chunk: LodashChunk;
        clamp: LodashClamp;
        clone: LodashClone;
        cloneDeep: LodashCloneDeep;
        cloneDeepWith: LodashCloneDeepWith;
        cloneWith: LodashCloneWith;
        compact: LodashCompact;
        complement: LodashNegate;
        compose: LodashFlowRight;
        concat: LodashConcat;
        cond: LodashCond;
        conforms: LodashConformsTo;
        conformsTo: LodashConformsTo;
        constant: LodashConstant;
        contains: LodashContains;
        countBy: LodashCountBy;
        create: LodashCreate;
        curry: LodashCurry;
        curryN: LodashCurryN;
        curryRight: LodashCurryRight;
        curryRightN: LodashCurryRightN;
        debounce: LodashDebounce;
        deburr: LodashDeburr;
        defaults: LodashDefaults;
        defaultsAll: LodashDefaultsAll;
        defaultsDeep: LodashDefaultsDeep;
        defaultsDeepAll: LodashDefaultsDeepAll;
        defaultTo: LodashDefaultTo;
        defer: LodashDefer;
        delay: LodashDelay;
        difference: LodashDifference;
        differenceBy: LodashDifferenceBy;
        differenceWith: LodashDifferenceWith;
        dissoc: LodashUnset;
        dissocPath: LodashUnset;
        divide: LodashDivide;
        drop: LodashDrop;
        dropLast: LodashDropRight;
        dropLastWhile: LodashDropRightWhile;
        dropRight: LodashDropRight;
        dropRightWhile: LodashDropRightWhile;
        dropWhile: LodashDropWhile;
        each: LodashForEach;
        eachRight: LodashForEachRight;
        endsWith: LodashEndsWith;
        entries: LodashToPairs;
        entriesIn: LodashToPairsIn;
        eq: LodashEq;
        equals: LodashIsEqual;
        escape: LodashEscape;
        escapeRegExp: LodashEscapeRegExp;
        every: LodashEvery;
        extend: LodashExtend;
        extendAll: LodashExtendAll;
        extendAllWith: LodashExtendAllWith;
        extendWith: LodashExtendWith;
        F: LodashStubFalse;
        fill: LodashFill;
        filter: LodashFilter;
        find: LodashFind;
        findFrom: LodashFindFrom;
        findIndex: LodashFindIndex;
        findIndexFrom: LodashFindIndexFrom;
        findKey: LodashFindKey;
        findLast: LodashFindLast;
        findLastFrom: LodashFindLastFrom;
        findLastIndex: LodashFindLastIndex;
        findLastIndexFrom: LodashFindLastIndexFrom;
        findLastKey: LodashFindLastKey;
        first: LodashHead;
        flatMap: LodashFlatMap;
        flatMapDeep: LodashFlatMapDeep;
        flatMapDepth: LodashFlatMapDepth;
        flatten: LodashFlatten;
        flattenDeep: LodashFlattenDeep;
        flattenDepth: LodashFlattenDepth;
        flip: LodashFlip;
        floor: LodashFloor;
        flow: LodashFlow;
        flowRight: LodashFlowRight;
        forEach: LodashForEach;
        forEachRight: LodashForEachRight;
        forIn: LodashForIn;
        forInRight: LodashForInRight;
        forOwn: LodashForOwn;
        forOwnRight: LodashForOwnRight;
        fromPairs: LodashFromPairs;
        functions: LodashFunctions;
        functionsIn: LodashFunctionsIn;
        get: LodashGet;
        getOr: LodashGetOr;
        groupBy: LodashGroupBy;
        gt: LodashGt;
        gte: LodashGte;
        has: LodashHas;
        hasIn: LodashHasIn;
        head: LodashHead;
        identical: LodashEq;
        identity: LodashIdentity;
        includes: LodashIncludes;
        includesFrom: LodashIncludesFrom;
        indexBy: LodashKeyBy;
        indexOf: LodashIndexOf;
        indexOfFrom: LodashIndexOfFrom;
        init: LodashInitial;
        initial: LodashInitial;
        inRange: LodashInRange;
        intersection: LodashIntersection;
        intersectionBy: LodashIntersectionBy;
        intersectionWith: LodashIntersectionWith;
        invert: LodashInvert;
        invertBy: LodashInvertBy;
        invertObj: LodashInvert;
        invoke: LodashInvoke;
        invokeArgs: LodashInvokeArgs;
        invokeArgsMap: LodashInvokeArgsMap;
        invokeMap: LodashInvokeMap;
        isArguments: LodashIsArguments;
        isArray: LodashIsArray;
        isArrayBuffer: LodashIsArrayBuffer;
        isArrayLike: LodashIsArrayLike;
        isArrayLikeObject: LodashIsArrayLikeObject;
        isBoolean: LodashIsBoolean;
        isBuffer: LodashIsBuffer;
        isDate: LodashIsDate;
        isElement: LodashIsElement;
        isEmpty: LodashIsEmpty;
        isEqual: LodashIsEqual;
        isEqualWith: LodashIsEqualWith;
        isError: LodashIsError;
        isFinite: LodashIsFinite;
        isFunction: LodashIsFunction;
        isInteger: LodashIsInteger;
        isLength: LodashIsLength;
        isMap: LodashIsMap;
        isMatch: LodashIsMatch;
        isMatchWith: LodashIsMatchWith;
        isNaN: LodashIsNaN;
        isNative: LodashIsNative;
        isNil: LodashIsNil;
        isNull: LodashIsNull;
        isNumber: LodashIsNumber;
        isObject: LodashIsObject;
        isObjectLike: LodashIsObjectLike;
        isPlainObject: LodashIsPlainObject;
        isRegExp: LodashIsRegExp;
        isSafeInteger: LodashIsSafeInteger;
        isSet: LodashIsSet;
        isString: LodashIsString;
        isSymbol: LodashIsSymbol;
        isTypedArray: LodashIsTypedArray;
        isUndefined: LodashIsUndefined;
        isWeakMap: LodashIsWeakMap;
        isWeakSet: LodashIsWeakSet;
        iteratee: LodashIteratee;
        join: LodashJoin;
        juxt: LodashOver;
        kebabCase: LodashKebabCase;
        keyBy: LodashKeyBy;
        keys: LodashKeys;
        keysIn: LodashKeysIn;
        last: LodashLast;
        lastIndexOf: LodashLastIndexOf;
        lastIndexOfFrom: LodashLastIndexOfFrom;
        lowerCase: LodashLowerCase;
        lowerFirst: LodashLowerFirst;
        lt: LodashLt;
        lte: LodashLte;
        map: LodashMap;
        mapKeys: LodashMapKeys;
        mapValues: LodashMapValues;
        matches: LodashIsMatch;
        matchesProperty: LodashMatchesProperty;
        max: LodashMax;
        maxBy: LodashMaxBy;
        mean: LodashMean;
        meanBy: LodashMeanBy;
        memoize: LodashMemoize;
        merge: LodashMerge;
        mergeAll: LodashMergeAll;
        mergeAllWith: LodashMergeAllWith;
        mergeWith: LodashMergeWith;
        method: LodashMethod;
        methodOf: LodashMethodOf;
        min: LodashMin;
        minBy: LodashMinBy;
        multiply: LodashMultiply;
        nAry: LodashAry;
        negate: LodashNegate;
        noConflict: LodashNoConflict;
        noop: LodashNoop;
        now: LodashNow;
        nth: LodashNth;
        nthArg: LodashNthArg;
        omit: LodashOmit;
        omitAll: LodashOmit;
        omitBy: LodashOmitBy;
        once: LodashOnce;
        orderBy: LodashOrderBy;
        over: LodashOver;
        overArgs: LodashOverArgs;
        overEvery: LodashOverEvery;
        overSome: LodashOverSome;
        pad: LodashPad;
        padChars: LodashPadChars;
        padCharsEnd: LodashPadCharsEnd;
        padCharsStart: LodashPadCharsStart;
        padEnd: LodashPadEnd;
        padStart: LodashPadStart;
        parseInt: LodashParseInt;
        partial: LodashPartial;
        partialRight: LodashPartialRight;
        partition: LodashPartition;
        path: LodashPath;
        pathEq: LodashMatchesProperty;
        pathOr: LodashPathOr;
        paths: LodashAt;
        pick: LodashPick;
        pickAll: LodashPick;
        pickBy: LodashPickBy;
        pipe: LodashFlow;
        pluck: LodashMap;
        prop: LodashProp;
        propEq: LodashMatchesProperty;
        property: LodashProperty;
        propertyOf: LodashPropertyOf;
        propOr: LodashPropOr;
        props: LodashAt;
        pull: LodashPull;
        pullAll: LodashPullAll;
        pullAllBy: LodashPullAllBy;
        pullAllWith: LodashPullAllWith;
        pullAt: LodashPullAt;
        random: LodashRandom;
        range: LodashRange;
        rangeRight: LodashRangeRight;
        rangeStep: LodashRangeStep;
        rangeStepRight: LodashRangeStepRight;
        rearg: LodashRearg;
        reduce: LodashReduce;
        reduceRight: LodashReduceRight;
        reject: LodashReject;
        remove: LodashRemove;
        repeat: LodashRepeat;
        replace: LodashReplace;
        rest: LodashRest;
        restFrom: LodashRestFrom;
        result: LodashResult;
        reverse: LodashReverse;
        round: LodashRound;
        runInContext: LodashRunInContext;
        sample: LodashSample;
        sampleSize: LodashSampleSize;
        set: LodashSet;
        setWith: LodashSetWith;
        shuffle: LodashShuffle;
        size: LodashSize;
        slice: LodashSlice;
        snakeCase: LodashSnakeCase;
        some: LodashSome;
        sortBy: LodashSortBy;
        sortedIndex: LodashSortedIndex;
        sortedIndexBy: LodashSortedIndexBy;
        sortedIndexOf: LodashSortedIndexOf;
        sortedLastIndex: LodashSortedLastIndex;
        sortedLastIndexBy: LodashSortedLastIndexBy;
        sortedLastIndexOf: LodashSortedLastIndexOf;
        sortedUniq: LodashSortedUniq;
        sortedUniqBy: LodashSortedUniqBy;
        split: LodashSplit;
        spread: LodashSpread;
        spreadFrom: LodashSpreadFrom;
        startCase: LodashStartCase;
        startsWith: LodashStartsWith;
        stubArray: LodashStubArray;
        stubFalse: LodashStubFalse;
        stubObject: LodashStubObject;
        stubString: LodashStubString;
        stubTrue: LodashStubTrue;
        subtract: LodashSubtract;
        sum: LodashSum;
        sumBy: LodashSumBy;
        symmetricDifference: LodashXor;
        symmetricDifferenceBy: LodashXorBy;
        symmetricDifferenceWith: LodashXorWith;
        T: LodashStubTrue;
        tail: LodashTail;
        take: LodashTake;
        takeLast: LodashTakeRight;
        takeLastWhile: LodashTakeRightWhile;
        takeRight: LodashTakeRight;
        takeRightWhile: LodashTakeRightWhile;
        takeWhile: LodashTakeWhile;
        tap: LodashTap;
        template: LodashTemplate;
        throttle: LodashThrottle;
        thru: LodashThru;
        times: LodashTimes;
        toArray: LodashToArray;
        toFinite: LodashToFinite;
        toInteger: LodashToInteger;
        toLength: LodashToLength;
        toLower: LodashToLower;
        toNumber: LodashToNumber;
        toPairs: LodashToPairs;
        toPairsIn: LodashToPairsIn;
        toPath: LodashToPath;
        toPlainObject: LodashToPlainObject;
        toSafeInteger: LodashToSafeInteger;
        toString: LodashToString;
        toUpper: LodashToUpper;
        transform: LodashTransform;
        trim: LodashTrim;
        trimChars: LodashTrimChars;
        trimCharsEnd: LodashTrimCharsEnd;
        trimCharsStart: LodashTrimCharsStart;
        trimEnd: LodashTrimEnd;
        trimStart: LodashTrimStart;
        truncate: LodashTruncate;
        unapply: LodashUnapply;
        unary: LodashUnary;
        unescape: LodashUnescape;
        union: LodashUnion;
        unionBy: LodashUnionBy;
        unionWith: LodashUnionWith;
        uniq: LodashUniq;
        uniqBy: LodashUniqBy;
        uniqueId: LodashUniqueId;
        uniqWith: LodashUniqWith;
        unnest: LodashFlatten;
        unset: LodashUnset;
        unzip: LodashUnzip;
        unzipWith: LodashUnzipWith;
        update: LodashUpdate;
        updateWith: LodashUpdateWith;
        upperCase: LodashUpperCase;
        upperFirst: LodashUpperFirst;
        useWith: LodashOverArgs;
        values: LodashValues;
        valuesIn: LodashValuesIn;
        where: LodashConformsTo;
        whereEq: LodashIsMatch;
        without: LodashWithout;
        words: LodashWords;
        wrap: LodashWrap;
        xor: LodashXor;
        xorBy: LodashXorBy;
        xorWith: LodashXorWith;
        zip: LodashZip;
        zipAll: LodashZipAll;
        zipObj: LodashZipObject;
        zipObject: LodashZipObject;
        zipObjectDeep: LodashZipObjectDeep;
        zipWith: LodashZipWith;
        __: lodash.__;
        placeholder: lodash.__;
    }
}
import _ = require("../index");
declare const __: _.__;
export = __;
import { add } from "../fp";
export = add;
import { after } from "../fp";
export = after;
import { all } from "../fp";
export = all;
import { allPass } from "../fp";
export = allPass;
import { always } from "../fp";
export = always;
import { any } from "../fp";
export = any;
import { anyPass } from "../fp";
export = anyPass;
import { apply } from "../fp";
export = apply;
import { ary } from "../fp";
export = ary;
import { assign } from "../fp";
export = assign;
import { assignAll } from "../fp";
export = assignAll;
import { assignAllWith } from "../fp";
export = assignAllWith;
import { assignIn } from "../fp";
export = assignIn;
import { assignInAll } from "../fp";
export = assignInAll;
import { assignInAllWith } from "../fp";
export = assignInAllWith;
import { assignInWith } from "../fp";
export = assignInWith;
import { assignWith } from "../fp";
export = assignWith;
import { assoc } from "../fp";
export = assoc;
import { assocPath } from "../fp";
export = assocPath;
import { at } from "../fp";
export = at;
import { attempt } from "../fp";
export = attempt;
import { before } from "../fp";
export = before;
import { bind } from "../fp";
export = bind;
import { bindAll } from "../fp";
export = bindAll;
import { bindKey } from "../fp";
export = bindKey;
import { camelCase } from "../fp";
export = camelCase;
import { capitalize } from "../fp";
export = capitalize;
import { castArray } from "../fp";
export = castArray;
import { ceil } from "../fp";
export = ceil;
import { chunk } from "../fp";
export = chunk;
import { clamp } from "../fp";
export = clamp;
import { clone } from "../fp";
export = clone;
import { cloneDeep } from "../fp";
export = cloneDeep;
import { cloneDeepWith } from "../fp";
export = cloneDeepWith;
import { cloneWith } from "../fp";
export = cloneWith;
import { compact } from "../fp";
export = compact;
import { complement } from "../fp";
export = complement;
import { compose } from "../fp";
export = compose;
import { concat } from "../fp";
export = concat;
import { cond } from "../fp";
export = cond;
import { conforms } from "../fp";
export = conforms;
import { conformsTo } from "../fp";
export = conformsTo;
import { constant } from "../fp";
export = constant;
import { contains } from "../fp";
export = contains;
interface ConvertOptions {
    cap?: boolean;
    curry?: boolean;
    fixed?: boolean;
    immutable?: boolean;
    rearg?: boolean;
}

interface Convert {
    (func: object, options?: ConvertOptions): any;
    (name: string, func: (...args: any[]) => any, options?: ConvertOptions): any;
}

declare const convert: Convert;
export = convert;
import { countBy } from "../fp";
export = countBy;
import { create } from "../fp";
export = create;
import { curry } from "../fp";
export = curry;
import { curryN } from "../fp";
export = curryN;
import { curryRight } from "../fp";
export = curryRight;
import { curryRightN } from "../fp";
export = curryRightN;
import { debounce } from "../fp";
export = debounce;
import { deburr } from "../fp";
export = deburr;
import { defaults } from "../fp";
export = defaults;
import { defaultsAll } from "../fp";
export = defaultsAll;
import { defaultsDeep } from "../fp";
export = defaultsDeep;
import { defaultsDeepAll } from "../fp";
export = defaultsDeepAll;
import { defaultTo } from "../fp";
export = defaultTo;
import { defer } from "../fp";
export = defer;
import { delay } from "../fp";
export = delay;
import { difference } from "../fp";
export = difference;
import { differenceBy } from "../fp";
export = differenceBy;
import { differenceWith } from "../fp";
export = differenceWith;
import { dissoc } from "../fp";
export = dissoc;
import { dissocPath } from "../fp";
export = dissocPath;
import { divide } from "../fp";
export = divide;
import { drop } from "../fp";
export = drop;
import { dropLast } from "../fp";
export = dropLast;
import { dropLastWhile } from "../fp";
export = dropLastWhile;
import { dropRight } from "../fp";
export = dropRight;
import { dropRightWhile } from "../fp";
export = dropRightWhile;
import { dropWhile } from "../fp";
export = dropWhile;
import { each } from "../fp";
export = each;
import { eachRight } from "../fp";
export = eachRight;
import { endsWith } from "../fp";
export = endsWith;
import { entries } from "../fp";
export = entries;
import { entriesIn } from "../fp";
export = entriesIn;
import { eq } from "../fp";
export = eq;
import { equals } from "../fp";
export = equals;
import { escape } from "../fp";
export = escape;
import { escapeRegExp } from "../fp";
export = escapeRegExp;
import { every } from "../fp";
export = every;
import { extend } from "../fp";
export = extend;
import { extendAll } from "../fp";
export = extendAll;
import { extendAllWith } from "../fp";
export = extendAllWith;
import { extendWith } from "../fp";
export = extendWith;
import { F } from "../fp";
export = F;
import { fill } from "../fp";
export = fill;
import { filter } from "../fp";
export = filter;
import { find } from "../fp";
export = find;
import { findFrom } from "../fp";
export = findFrom;
import { findIndex } from "../fp";
export = findIndex;
import { findIndexFrom } from "../fp";
export = findIndexFrom;
import { findKey } from "../fp";
export = findKey;
import { findLast } from "../fp";
export = findLast;
import { findLastFrom } from "../fp";
export = findLastFrom;
import { findLastIndex } from "../fp";
export = findLastIndex;
import { findLastIndexFrom } from "../fp";
export = findLastIndexFrom;
import { findLastKey } from "../fp";
export = findLastKey;
import { first } from "../fp";
export = first;
import { flatMap } from "../fp";
export = flatMap;
import { flatMapDeep } from "../fp";
export = flatMapDeep;
import { flatMapDepth } from "../fp";
export = flatMapDepth;
import { flatten } from "../fp";
export = flatten;
import { flattenDeep } from "../fp";
export = flattenDeep;
import { flattenDepth } from "../fp";
export = flattenDepth;
import { flip } from "../fp";
export = flip;
import { floor } from "../fp";
export = floor;
import { flow } from "../fp";
export = flow;
import { flowRight } from "../fp";
export = flowRight;
import { forEach } from "../fp";
export = forEach;
import { forEachRight } from "../fp";
export = forEachRight;
import { forIn } from "../fp";
export = forIn;
import { forInRight } from "../fp";
export = forInRight;
import { forOwn } from "../fp";
export = forOwn;
import { forOwnRight } from "../fp";
export = forOwnRight;
import { fromPairs } from "../fp";
export = fromPairs;
import { functions } from "../fp";
export = functions;
import { functionsIn } from "../fp";
export = functionsIn;
import { get } from "../fp";
export = get;
import { getOr } from "../fp";
export = getOr;
import { groupBy } from "../fp";
export = groupBy;
import { gt } from "../fp";
export = gt;
import { gte } from "../fp";
export = gte;
import { has } from "../fp";
export = has;
import { hasIn } from "../fp";
export = hasIn;
import { head } from "../fp";
export = head;
import { identical } from "../fp";
export = identical;
import { identity } from "../fp";
export = identity;
import { includes } from "../fp";
export = includes;
import { includesFrom } from "../fp";
export = includesFrom;
import { indexBy } from "../fp";
export = indexBy;
import { indexOf } from "../fp";
export = indexOf;
import { indexOfFrom } from "../fp";
export = indexOfFrom;
import { init } from "../fp";
export = init;
import { initial } from "../fp";
export = initial;
import { inRange } from "../fp";
export = inRange;
import { intersection } from "../fp";
export = intersection;
import { intersectionBy } from "../fp";
export = intersectionBy;
import { intersectionWith } from "../fp";
export = intersectionWith;
import { invert } from "../fp";
export = invert;
import { invertBy } from "../fp";
export = invertBy;
import { invertObj } from "../fp";
export = invertObj;
import { invoke } from "../fp";
export = invoke;
import { invokeArgs } from "../fp";
export = invokeArgs;
import { invokeArgsMap } from "../fp";
export = invokeArgsMap;
import { invokeMap } from "../fp";
export = invokeMap;
import { isArguments } from "../fp";
export = isArguments;
import { isArray } from "../fp";
export = isArray;
import { isArrayBuffer } from "../fp";
export = isArrayBuffer;
import { isArrayLike } from "../fp";
export = isArrayLike;
import { isArrayLikeObject } from "../fp";
export = isArrayLikeObject;
import { isBoolean } from "../fp";
export = isBoolean;
import { isBuffer } from "../fp";
export = isBuffer;
import { isDate } from "../fp";
export = isDate;
import { isElement } from "../fp";
export = isElement;
import { isEmpty } from "../fp";
export = isEmpty;
import { isEqual } from "../fp";
export = isEqual;
import { isEqualWith } from "../fp";
export = isEqualWith;
import { isError } from "../fp";
export = isError;
import { isFinite } from "../fp";
export = isFinite;
import { isFunction } from "../fp";
export = isFunction;
import { isInteger } from "../fp";
export = isInteger;
import { isLength } from "../fp";
export = isLength;
import { isMap } from "../fp";
export = isMap;
import { isMatch } from "../fp";
export = isMatch;
import { isMatchWith } from "../fp";
export = isMatchWith;
import { isNaN } from "../fp";
export = isNaN;
import { isNative } from "../fp";
export = isNative;
import { isNil } from "../fp";
export = isNil;
import { isNull } from "../fp";
export = isNull;
import { isNumber } from "../fp";
export = isNumber;
import { isObject } from "../fp";
export = isObject;
import { isObjectLike } from "../fp";
export = isObjectLike;
import { isPlainObject } from "../fp";
export = isPlainObject;
import { isRegExp } from "../fp";
export = isRegExp;
import { isSafeInteger } from "../fp";
export = isSafeInteger;
import { isSet } from "../fp";
export = isSet;
import { isString } from "../fp";
export = isString;
import { isSymbol } from "../fp";
export = isSymbol;
import { isTypedArray } from "../fp";
export = isTypedArray;
import { isUndefined } from "../fp";
export = isUndefined;
import { isWeakMap } from "../fp";
export = isWeakMap;
import { isWeakSet } from "../fp";
export = isWeakSet;
import { iteratee } from "../fp";
export = iteratee;
import { join } from "../fp";
export = join;
import { juxt } from "../fp";
export = juxt;
import { kebabCase } from "../fp";
export = kebabCase;
import { keyBy } from "../fp";
export = keyBy;
import { keys } from "../fp";
export = keys;
import { keysIn } from "../fp";
export = keysIn;
import { last } from "../fp";
export = last;
import { lastIndexOf } from "../fp";
export = lastIndexOf;
import { lastIndexOfFrom } from "../fp";
export = lastIndexOfFrom;
import { lowerCase } from "../fp";
export = lowerCase;
import { lowerFirst } from "../fp";
export = lowerFirst;
import { lt } from "../fp";
export = lt;
import { lte } from "../fp";
export = lte;
import { map } from "../fp";
export = map;
import { mapKeys } from "../fp";
export = mapKeys;
import { mapValues } from "../fp";
export = mapValues;
import { matches } from "../fp";
export = matches;
import { matchesProperty } from "../fp";
export = matchesProperty;
import { max } from "../fp";
export = max;
import { maxBy } from "../fp";
export = maxBy;
import { mean } from "../fp";
export = mean;
import { meanBy } from "../fp";
export = meanBy;
import { memoize } from "../fp";
export = memoize;
import { merge } from "../fp";
export = merge;
import { mergeAll } from "../fp";
export = mergeAll;
import { mergeAllWith } from "../fp";
export = mergeAllWith;
import { mergeWith } from "../fp";
export = mergeWith;
import { method } from "../fp";
export = method;
import { methodOf } from "../fp";
export = methodOf;
import { min } from "../fp";
export = min;
import { minBy } from "../fp";
export = minBy;
import { multiply } from "../fp";
export = multiply;
import { nAry } from "../fp";
export = nAry;
import { negate } from "../fp";
export = negate;
import { noConflict } from "../fp";
export = noConflict;
import { noop } from "../fp";
export = noop;
import { now } from "../fp";
export = now;
import { nth } from "../fp";
export = nth;
import { nthArg } from "../fp";
export = nthArg;
import { omit } from "../fp";
export = omit;
import { omitAll } from "../fp";
export = omitAll;
import { omitBy } from "../fp";
export = omitBy;
import { once } from "../fp";
export = once;
import { orderBy } from "../fp";
export = orderBy;
import { over } from "../fp";
export = over;
import { overArgs } from "../fp";
export = overArgs;
import { overEvery } from "../fp";
export = overEvery;
import { overSome } from "../fp";
export = overSome;
import { pad } from "../fp";
export = pad;
import { padChars } from "../fp";
export = padChars;
import { padCharsEnd } from "../fp";
export = padCharsEnd;
import { padCharsStart } from "../fp";
export = padCharsStart;
import { padEnd } from "../fp";
export = padEnd;
import { padStart } from "../fp";
export = padStart;
import { parseInt } from "../fp";
export = parseInt;
import { partial } from "../fp";
export = partial;
import { partialRight } from "../fp";
export = partialRight;
import { partition } from "../fp";
export = partition;
import { path } from "../fp";
export = path;
import { pathEq } from "../fp";
export = pathEq;
import { pathOr } from "../fp";
export = pathOr;
import { paths } from "../fp";
export = paths;
import { pick } from "../fp";
export = pick;
import { pickAll } from "../fp";
export = pickAll;
import { pickBy } from "../fp";
export = pickBy;
import { pipe } from "../fp";
export = pipe;
import _ = require("../index");
declare const placeholder: _.__;
export = placeholder;
import { pluck } from "../fp";
export = pluck;
import { prop } from "../fp";
export = prop;
import { propEq } from "../fp";
export = propEq;
import { property } from "../fp";
export = property;
import { propertyOf } from "../fp";
export = propertyOf;
import { propOr } from "../fp";
export = propOr;
import { props } from "../fp";
export = props;
import { pull } from "../fp";
export = pull;
import { pullAll } from "../fp";
export = pullAll;
import { pullAllBy } from "../fp";
export = pullAllBy;
import { pullAllWith } from "../fp";
export = pullAllWith;
import { pullAt } from "../fp";
export = pullAt;
import { random } from "../fp";
export = random;
import { range } from "../fp";
export = range;
import { rangeRight } from "../fp";
export = rangeRight;
import { rangeStep } from "../fp";
export = rangeStep;
import { rangeStepRight } from "../fp";
export = rangeStepRight;
import { rearg } from "../fp";
export = rearg;
import { reduce } from "../fp";
export = reduce;
import { reduceRight } from "../fp";
export = reduceRight;
import { reject } from "../fp";
export = reject;
import { remove } from "../fp";
export = remove;
import { repeat } from "../fp";
export = repeat;
import { replace } from "../fp";
export = replace;
import { rest } from "../fp";
export = rest;
import { restFrom } from "../fp";
export = restFrom;
import { result } from "../fp";
export = result;
import { reverse } from "../fp";
export = reverse;
import { round } from "../fp";
export = round;
import { runInContext } from "../fp";
export = runInContext;
import { sample } from "../fp";
export = sample;
import { sampleSize } from "../fp";
export = sampleSize;
import { set } from "../fp";
export = set;
import { setWith } from "../fp";
export = setWith;
import { shuffle } from "../fp";
export = shuffle;
import { size } from "../fp";
export = size;
import { slice } from "../fp";
export = slice;
import { snakeCase } from "../fp";
export = snakeCase;
import { some } from "../fp";
export = some;
import { sortBy } from "../fp";
export = sortBy;
import { sortedIndex } from "../fp";
export = sortedIndex;
import { sortedIndexBy } from "../fp";
export = sortedIndexBy;
import { sortedIndexOf } from "../fp";
export = sortedIndexOf;
import { sortedLastIndex } from "../fp";
export = sortedLastIndex;
import { sortedLastIndexBy } from "../fp";
export = sortedLastIndexBy;
import { sortedLastIndexOf } from "../fp";
export = sortedLastIndexOf;
import { sortedUniq } from "../fp";
export = sortedUniq;
import { sortedUniqBy } from "../fp";
export = sortedUniqBy;
import { split } from "../fp";
export = split;
import { spread } from "../fp";
export = spread;
import { spreadFrom } from "../fp";
export = spreadFrom;
import { startCase } from "../fp";
export = startCase;
import { startsWith } from "../fp";
export = startsWith;
import { stubArray } from "../fp";
export = stubArray;
import { stubFalse } from "../fp";
export = stubFalse;
import { stubObject } from "../fp";
export = stubObject;
import { stubString } from "../fp";
export = stubString;
import { stubTrue } from "../fp";
export = stubTrue;
import { subtract } from "../fp";
export = subtract;
import { sum } from "../fp";
export = sum;
import { sumBy } from "../fp";
export = sumBy;
import { symmetricDifference } from "../fp";
export = symmetricDifference;
import { symmetricDifferenceBy } from "../fp";
export = symmetricDifferenceBy;
import { symmetricDifferenceWith } from "../fp";
export = symmetricDifferenceWith;
import { T } from "../fp";
export = T;
import { tail } from "../fp";
export = tail;
import { take } from "../fp";
export = take;
import { takeLast } from "../fp";
export = takeLast;
import { takeLastWhile } from "../fp";
export = takeLastWhile;
import { takeRight } from "../fp";
export = takeRight;
import { takeRightWhile } from "../fp";
export = takeRightWhile;
import { takeWhile } from "../fp";
export = takeWhile;
import { tap } from "../fp";
export = tap;
import { template } from "../fp";
export = template;
import { throttle } from "../fp";
export = throttle;
import { thru } from "../fp";
export = thru;
import { times } from "../fp";
export = times;
import { toArray } from "../fp";
export = toArray;
import { toFinite } from "../fp";
export = toFinite;
import { toInteger } from "../fp";
export = toInteger;
import { toLength } from "../fp";
export = toLength;
import { toLower } from "../fp";
export = toLower;
import { toNumber } from "../fp";
export = toNumber;
import { toPairs } from "../fp";
export = toPairs;
import { toPairsIn } from "../fp";
export = toPairsIn;
import { toPath } from "../fp";
export = toPath;
import { toPlainObject } from "../fp";
export = toPlainObject;
import { toSafeInteger } from "../fp";
export = toSafeInteger;
import { toString } from "../fp";
export = toString;
import { toUpper } from "../fp";
export = toUpper;
import { transform } from "../fp";
export = transform;
import { trim } from "../fp";
export = trim;
import { trimChars } from "../fp";
export = trimChars;
import { trimCharsEnd } from "../fp";
export = trimCharsEnd;
import { trimCharsStart } from "../fp";
export = trimCharsStart;
import { trimEnd } from "../fp";
export = trimEnd;
import { trimStart } from "../fp";
export = trimStart;
import { truncate } from "../fp";
export = truncate;
import { unapply } from "../fp";
export = unapply;
import { unary } from "../fp";
export = unary;
import { unescape } from "../fp";
export = unescape;
import { union } from "../fp";
export = union;
import { unionBy } from "../fp";
export = unionBy;
import { unionWith } from "../fp";
export = unionWith;
import { uniq } from "../fp";
export = uniq;
import { uniqBy } from "../fp";
export = uniqBy;
import { uniqueId } from "../fp";
export = uniqueId;
import { uniqWith } from "../fp";
export = uniqWith;
import { unnest } from "../fp";
export = unnest;
import { unset } from "../fp";
export = unset;
import { unzip } from "../fp";
export = unzip;
import { unzipWith } from "../fp";
export = unzipWith;
import { update } from "../fp";
export = update;
import { updateWith } from "../fp";
export = updateWith;
import { upperCase } from "../fp";
export = upperCase;
import { upperFirst } from "../fp";
export = upperFirst;
import { useWith } from "../fp";
export = useWith;
import { values } from "../fp";
export = values;
import { valuesIn } from "../fp";
export = valuesIn;
import { where } from "../fp";
export = where;
import { whereEq } from "../fp";
export = whereEq;
import { without } from "../fp";
export = without;
import { words } from "../fp";
export = words;
import { wrap } from "../fp";
export = wrap;
import { xor } from "../fp";
export = xor;
import { xorBy } from "../fp";
export = xorBy;
import { xorWith } from "../fp";
export = xorWith;
import { zip } from "../fp";
export = zip;
import { zipAll } from "../fp";
export = zipAll;
import { zipObj } from "../fp";
export = zipObj;
import { zipObject } from "../fp";
export = zipObject;
import { zipObjectDeep } from "../fp";
export = zipObjectDeep;
import { zipWith } from "../fp";
export = zipWith;
import { fromPairs } from "./index";
export = fromPairs;
import { functions } from "./index";
export = functions;
import { functionsIn } from "./index";
export = functionsIn;
import { get } from "./index";
export = get;
import { groupBy } from "./index";
export = groupBy;
import { gt } from "./index";
export = gt;
import { gte } from "./index";
export = gte;
import { has } from "./index";
export = has;
import { hasIn } from "./index";
export = hasIn;
import { head } from "./index";
export = head;
import { identity } from "./index";
export = identity;
import { includes } from "./index";
export = includes;
/// <reference path="./common/common.d.ts" />
/// <reference path="./common/array.d.ts" />
/// <reference path="./common/collection.d.ts" />
/// <reference path="./common/date.d.ts" />
/// <reference path="./common/function.d.ts" />
/// <reference path="./common/lang.d.ts" />
/// <reference path="./common/math.d.ts" />
/// <reference path="./common/number.d.ts" />
/// <reference path="./common/object.d.ts" />
/// <reference path="./common/seq.d.ts" />
/// <reference path="./common/string.d.ts" />
/// <reference path="./common/util.d.ts" />

export = _;
export as namespace _;

declare const _: _.LoDashStatic;
declare namespace _ {
    // eslint-disable-next-line @typescript-eslint/no-empty-interface -- (This will be augmented)
    interface LoDashStatic {}
}
import { indexOf } from "./index";
export = indexOf;
import { initial } from "./index";
export = initial;
import { inRange } from "./index";
export = inRange;
import { intersection } from "./index";
export = intersection;
import { intersectionBy } from "./index";
export = intersectionBy;
import { intersectionWith } from "./index";
export = intersectionWith;
import { invert } from "./index";
export = invert;
import { invertBy } from "./index";
export = invertBy;
import { invoke } from "./index";
export = invoke;
import { invokeMap } from "./index";
export = invokeMap;
import { isArguments } from "./index";
export = isArguments;
import { isArray } from "./index";
export = isArray;
import { isArrayBuffer } from "./index";
export = isArrayBuffer;
import { isArrayLike } from "./index";
export = isArrayLike;
import { isArrayLikeObject } from "./index";
export = isArrayLikeObject;
import { isBoolean } from "./index";
export = isBoolean;
import { isBuffer } from "./index";
export = isBuffer;
import { isDate } from "./index";
export = isDate;
import { isElement } from "./index";
export = isElement;
import { isEmpty } from "./index";
export = isEmpty;
import { isEqual } from "./index";
export = isEqual;
import { isEqualWith } from "./index";
export = isEqualWith;
import { isError } from "./index";
export = isError;
import { isFinite } from "./index";
export = isFinite;
import { isFunction } from "./index";
export = isFunction;
import { isInteger } from "./index";
export = isInteger;
import { isLength } from "./index";
export = isLength;
import { isMap } from "./index";
export = isMap;
import { isMatch } from "./index";
export = isMatch;
import { isMatchWith } from "./index";
export = isMatchWith;
import { isNaN } from "./index";
export = isNaN;
import { isNative } from "./index";
export = isNative;
import { isNil } from "./index";
export = isNil;
import { isNull } from "./index";
export = isNull;
import { isNumber } from "./index";
export = isNumber;
import { isObject } from "./index";
export = isObject;
import { isObjectLike } from "./index";
export = isObjectLike;
import { isPlainObject } from "./index";
export = isPlainObject;
import { isRegExp } from "./index";
export = isRegExp;
import { isSafeInteger } from "./index";
export = isSafeInteger;
import { isSet } from "./index";
export = isSet;
import { isString } from "./index";
export = isString;
import { isSymbol } from "./index";
export = isSymbol;
import { isTypedArray } from "./index";
export = isTypedArray;
import { isUndefined } from "./index";
export = isUndefined;
import { isWeakMap } from "./index";
export = isWeakMap;
import { isWeakSet } from "./index";
export = isWeakSet;
import { iteratee } from "./index";
export = iteratee;
import { join } from "./index";
export = join;
import { kebabCase } from "./index";
export = kebabCase;
import { keyBy } from "./index";
export = keyBy;
import { keys } from "./index";
export = keys;
import { keysIn } from "./index";
export = keysIn;
import { last } from "./index";
export = last;
import { lastIndexOf } from "./index";
export = lastIndexOf;
    MIT License

    Copyright (c) Microsoft Corporation.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE
import { lowerCase } from "./index";
export = lowerCase;
import { lowerFirst } from "./index";
export = lowerFirst;
import { lt } from "./index";
export = lt;
import { lte } from "./index";
export = lte;
import { map } from "./index";
export = map;
import { mapKeys } from "./index";
export = mapKeys;
import { mapValues } from "./index";
export = mapValues;
import { matches } from "./index";
export = matches;
import { matchesProperty } from "./index";
export = matchesProperty;
import { max } from "./index";
export = max;
import { maxBy } from "./index";
export = maxBy;
import { mean } from "./index";
export = mean;
import { meanBy } from "./index";
export = meanBy;
import { memoize } from "./index";
export = memoize;
import { merge } from "./index";
export = merge;
import { mergeWith } from "./index";
export = mergeWith;
import { method } from "./index";
export = method;
import { methodOf } from "./index";
export = methodOf;
import { min } from "./index";
export = min;
import { minBy } from "./index";
export = minBy;
import { mixin } from "./index";
export = mixin;
import { multiply } from './index';
export = multiply;
import { negate } from "./index";
export = negate;
import { noConflict } from "./index";
export = noConflict;
import { noop } from "./index";
export = noop;
import { now } from "./index";
export = now;
import { nth } from "./index";
export = nth;
import { nthArg } from "./index";
export = nthArg;
import { omit } from "./index";
export = omit;
import { omitBy } from "./index";
export = omitBy;
import { once } from "./index";
export = once;
import { orderBy } from "./index";
export = orderBy;
import { over } from "./index";
export = over;
import { overArgs } from "./index";
export = overArgs;
import { overEvery } from "./index";
export = overEvery;
import { overSome } from "./index";
export = overSome;
{
    "name": "@types/lodash",
    "version": "4.17.7",
    "description": "TypeScript definitions for lodash",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/lodash",
    "license": "MIT",
    "contributors": [
        {
            "name": "Brian Zengel",
            "githubUsername": "bczengel",
            "url": "https://github.com/bczengel"
        },
        {
            "name": "Ilya Mochalov",
            "githubUsername": "chrootsu",
            "url": "https://github.com/chrootsu"
        },
        {
            "name": "AJ Richardson",
            "githubUsername": "aj-r",
            "url": "https://github.com/aj-r"
        },
        {
            "name": "e-cloud",
            "githubUsername": "e-cloud",
            "url": "https://github.com/e-cloud"
        },
        {
            "name": "Georgii Dolzhykov",
            "githubUsername": "thorn0",
            "url": "https://github.com/thorn0"
        },
        {
            "name": "Jack Moore",
            "githubUsername": "jtmthf",
            "url": "https://github.com/jtmthf"
        },
        {
            "name": "Dominique Rau",
            "githubUsername": "DomiR",
            "url": "https://github.com/DomiR"
        },
        {
            "name": "William Chelman",
            "githubUsername": "WilliamChelman",
            "url": "https://github.com/WilliamChelman"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/lodash"
    },
    "scripts": {},
    "dependencies": {},
    "typesPublisherContentHash": "bfe2463828cc30244e31ef7b2555c36d16c840d293fe58f7533b2804c9fd409d",
    "typeScriptVersion": "4.8"
}import { pad } from "./index";
export = pad;
import { padEnd } from "./index";
export = padEnd;
import { padStart } from "./index";
export = padStart;
import { parseInt } from "./index";
export = parseInt;
import { partial } from "./index";
export = partial;
import { partialRight } from "./index";
export = partialRight;
import { partition } from "./index";
export = partition;
import { pick } from "./index";
export = pick;
import { pickBy } from "./index";
export = pickBy;
import { property } from "./index";
export = property;
import { propertyOf } from "./index";
export = propertyOf;
import { pull } from "./index";
export = pull;
import { pullAll } from "./index";
export = pullAll;
import { pullAllBy } from "./index";
export = pullAllBy;
import { pullAllWith } from "./index";
export = pullAllWith;
import { pullAt } from "./index";
export = pullAt;
import { random } from "./index";
export = random;
import { range } from "./index";
export = range;
import { rangeRight } from "./index";
export = rangeRight;
# Installation
> `npm install --save @types/lodash`

# Summary
This package contains type definitions for lodash (https://lodash.com).

# Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/lodash.

### Additional Details
 * Last updated: Tue, 16 Jul 2024 02:21:33 GMT
 * Dependencies: none

# Credits
These definitions were written by [Brian Zengel](https://github.com/bczengel), [Ilya Mochalov](https://github.com/chrootsu), [AJ Richardson](https://github.com/aj-r), [e-cloud](https://github.com/e-cloud), [Georgii Dolzhykov](https://github.com/thorn0), [Jack Moore](https://github.com/jtmthf), [Dominique Rau](https://github.com/DomiR), and [William Chelman](https://github.com/WilliamChelman).
import { rearg } from "./index";
export = rearg;
import { reduce } from "./index";
export = reduce;
import { reduceRight } from "./index";
export = reduceRight;
import { reject } from "./index";
export = reject;
import { remove } from "./index";
export = remove;
import { repeat } from "./index";
export = repeat;
import { replace } from "./index";
export = replace;
import { rest } from "./index";
export = rest;
import { result } from "./index";
export = result;
import { reverse } from "./index";
export = reverse;
import { round } from "./index";
export = round;
import { runInContext } from "./index";
export = runInContext;
import { sample } from "./index";
export = sample;
import { sampleSize } from "./index";
export = sampleSize;
import { set } from "./index";
export = set;
import { setWith } from "./index";
export = setWith;
import { shuffle } from "./index";
export = shuffle;
import { size } from "./index";
export = size;
import { slice } from "./index";
export = slice;
import { snakeCase } from "./index";
export = snakeCase;
import { some } from "./index";
export = some;
import { sortBy } from "./index";
export = sortBy;
import { sortedIndex } from "./index";
export = sortedIndex;
import { sortedIndexBy } from "./index";
export = sortedIndexBy;
import { sortedIndexOf } from "./index";
export = sortedIndexOf;
import { sortedLastIndex } from "./index";
export = sortedLastIndex;
import { sortedLastIndexBy } from "./index";
export = sortedLastIndexBy;
import { sortedLastIndexOf } from "./index";
export = sortedLastIndexOf;
import { sortedUniq } from "./index";
export = sortedUniq;
import { sortedUniqBy } from "./index";
export = sortedUniqBy;
import { split } from "./index";
export = split;
import { spread } from "./index";
export = spread;
import { startCase } from "./index";
export = startCase;
import { startsWith } from "./index";
export = startsWith;
import { stubFalse } from "./index";
export = stubFalse;
import { stubTrue } from "./index";
export = stubTrue;
import { subtract } from "./index";
export = subtract;
import { sum } from "./index";
export = sum;
import { sumBy } from "./index";
export = sumBy;
import { tail } from "./index";
export = tail;
import { take } from "./index";
export = take;
import { takeRight } from "./index";
export = takeRight;
import { takeRightWhile } from "./index";
export = takeRightWhile;
import { takeWhile } from "./index";
export = takeWhile;
import { tap } from "./index";
export = tap;
import { template } from "./index";
export = template;
import { throttle } from "./index";
export = throttle;
import { thru } from "./index";
export = thru;
import { times } from "./index";
export = times;
import { toArray } from "./index";
export = toArray;
import { toFinite } from "./index";
export = toFinite;
import { toInteger } from "./index";
export = toInteger;
import { toLength } from "./index";
export = toLength;
import { toLower } from "./index";
export = toLower;
import { toNumber } from "./index";
export = toNumber;
import { toPairs } from "./index";
export = toPairs;
import { toPairsIn } from "./index";
export = toPairsIn;
import { toPath } from "./index";
export = toPath;
import { toPlainObject } from "./index";
export = toPlainObject;
import { toSafeInteger } from "./index";
export = toSafeInteger;
import { toString } from "./index";
export = toString;
import { toUpper } from "./index";
export = toUpper;
import { transform } from "./index";
export = transform;
import { trim } from "./index";
export = trim;
import { trimEnd } from "./index";
export = trimEnd;
import { trimStart } from "./index";
export = trimStart;
import { truncate } from "./index";
export = truncate;
import { unary } from "./index";
export = unary;
import { unescape } from "./index";
export = unescape;
import { union } from "./index";
export = union;
import { unionBy } from "./index";
export = unionBy;
import { unionWith } from "./index";
export = unionWith;
import { uniq } from "./index";
export = uniq;
import { uniqBy } from "./index";
export = uniqBy;
import { uniqueId } from "./index";
export = uniqueId;
import { uniqWith } from "./index";
export = uniqWith;
import { unset } from "./index";
export = unset;
import { unzip } from "./index";
export = unzip;
import { unzipWith } from "./index";
export = unzipWith;
import { update } from "./index";
export = update;
import { updateWith } from "./index";
export = updateWith;
import { upperCase } from "./index";
export = upperCase;
import { upperFirst } from "./index";
export = upperFirst;
import { values } from "./index";
export = values;
import { valuesIn } from "./index";
export = valuesIn;
import { without } from "./index";
export = without;
import { words } from "./index";
export = words;
import { wrap } from "./index";
export = wrap;
import { xor } from "./index";
export = xor;
import { xorBy } from "./index";
export = xorBy;
import { xorWith } from "./index";
export = xorWith;
import { zip } from "./index";
export = zip;
import { zipObject } from "./index";
export = zipObject;
import { zipObjectDeep } from "./index";
export = zipObjectDeep;
import { zipWith } from "./index";
export = zipWith;
/**
 * The `node:assert` module provides a set of assertion functions for verifying
 * invariants.
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/assert.js)
 */
declare module "assert" {
    /**
     * An alias of {@link ok}.
     * @since v0.5.9
     * @param value The input that is checked for being truthy.
     */
    function assert(value: unknown, message?: string | Error): asserts value;
    namespace assert {
        /**
         * Indicates the failure of an assertion. All errors thrown by the `node:assert` module will be instances of the `AssertionError` class.
         */
        class AssertionError extends Error {
            /**
             * Set to the `actual` argument for methods such as {@link assert.strictEqual()}.
             */
            actual: unknown;
            /**
             * Set to the `expected` argument for methods such as {@link assert.strictEqual()}.
             */
            expected: unknown;
            /**
             * Set to the passed in operator value.
             */
            operator: string;
            /**
             * Indicates if the message was auto-generated (`true`) or not.
             */
            generatedMessage: boolean;
            /**
             * Value is always `ERR_ASSERTION` to show that the error is an assertion error.
             */
            code: "ERR_ASSERTION";
            constructor(options?: {
                /** If provided, the error message is set to this value. */
                message?: string | undefined;
                /** The `actual` property on the error instance. */
                actual?: unknown | undefined;
                /** The `expected` property on the error instance. */
                expected?: unknown | undefined;
                /** The `operator` property on the error instance. */
                operator?: string | undefined;
                /** If provided, the generated stack trace omits frames before this function. */
                // eslint-disable-next-line @typescript-eslint/ban-types
                stackStartFn?: Function | undefined;
            });
        }
        /**
         * This feature is deprecated and will be removed in a future version.
         * Please consider using alternatives such as the `mock` helper function.
         * @since v14.2.0, v12.19.0
         * @deprecated Deprecated
         */
        class CallTracker {
            /**
             * The wrapper function is expected to be called exactly `exact` times. If the
             * function has not been called exactly `exact` times when `tracker.verify()` is called, then `tracker.verify()` will throw an
             * error.
             *
             * ```js
             * import assert from 'node:assert';
             *
             * // Creates call tracker.
             * const tracker = new assert.CallTracker();
             *
             * function func() {}
             *
             * // Returns a function that wraps func() that must be called exact times
             * // before tracker.verify().
             * const callsfunc = tracker.calls(func);
             * ```
             * @since v14.2.0, v12.19.0
             * @param [fn='A no-op function']
             * @param [exact=1]
             * @return A function that wraps `fn`.
             */
            calls(exact?: number): () => void;
            calls<Func extends (...args: any[]) => any>(fn?: Func, exact?: number): Func;
            /**
             * Example:
             *
             * ```js
             * import assert from 'node:assert';
             *
             * const tracker = new assert.CallTracker();
             *
             * function func() {}
             * const callsfunc = tracker.calls(func);
             * callsfunc(1, 2, 3);
             *
             * assert.deepStrictEqual(tracker.getCalls(callsfunc),
             *                        [{ thisArg: undefined, arguments: [1, 2, 3] }]);
             * ```
             * @since v18.8.0, v16.18.0
             * @return An array with all the calls to a tracked function.
             */
            getCalls(fn: Function): CallTrackerCall[];
            /**
             * The arrays contains information about the expected and actual number of calls of
             * the functions that have not been called the expected number of times.
             *
             * ```js
             * import assert from 'node:assert';
             *
             * // Creates call tracker.
             * const tracker = new assert.CallTracker();
             *
             * function func() {}
             *
             * // Returns a function that wraps func() that must be called exact times
             * // before tracker.verify().
             * const callsfunc = tracker.calls(func, 2);
             *
             * // Returns an array containing information on callsfunc()
             * console.log(tracker.report());
             * // [
             * //  {
             * //    message: 'Expected the func function to be executed 2 time(s) but was
             * //    executed 0 time(s).',
             * //    actual: 0,
             * //    expected: 2,
             * //    operator: 'func',
             * //    stack: stack trace
             * //  }
             * // ]
             * ```
             * @since v14.2.0, v12.19.0
             * @return An array of objects containing information about the wrapper functions returned by {@link tracker.calls()}.
             */
            report(): CallTrackerReportInformation[];
            /**
             * Reset calls of the call tracker. If a tracked function is passed as an argument, the calls will be reset for it.
             * If no arguments are passed, all tracked functions will be reset.
             *
             * ```js
             * import assert from 'node:assert';
             *
             * const tracker = new assert.CallTracker();
             *
             * function func() {}
             * const callsfunc = tracker.calls(func);
             *
             * callsfunc();
             * // Tracker was called once
             * assert.strictEqual(tracker.getCalls(callsfunc).length, 1);
             *
             * tracker.reset(callsfunc);
             * assert.strictEqual(tracker.getCalls(callsfunc).length, 0);
             * ```
             * @since v18.8.0, v16.18.0
             * @param fn a tracked function to reset.
             */
            reset(fn?: Function): void;
            /**
             * Iterates through the list of functions passed to {@link tracker.calls()} and will throw an error for functions that
             * have not been called the expected number of times.
             *
             * ```js
             * import assert from 'node:assert';
             *
             * // Creates call tracker.
             * const tracker = new assert.CallTracker();
             *
             * function func() {}
             *
             * // Returns a function that wraps func() that must be called exact times
             * // before tracker.verify().
             * const callsfunc = tracker.calls(func, 2);
             *
             * callsfunc();
             *
             * // Will throw an error since callsfunc() was only called once.
             * tracker.verify();
             * ```
             * @since v14.2.0, v12.19.0
             */
            verify(): void;
        }
        interface CallTrackerCall {
            thisArg: object;
            arguments: unknown[];
        }
        interface CallTrackerReportInformation {
            message: string;
            /** The actual number of times the function was called. */
            actual: number;
            /** The number of times the function was expected to be called. */
            expected: number;
            /** The name of the function that is wrapped. */
            operator: string;
            /** A stack trace of the function. */
            stack: object;
        }
        type AssertPredicate = RegExp | (new() => object) | ((thrown: unknown) => boolean) | object | Error;
        /**
         * Throws an `AssertionError` with the provided error message or a default
         * error message. If the `message` parameter is an instance of an `Error` then
         * it will be thrown instead of the `AssertionError`.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.fail();
         * // AssertionError [ERR_ASSERTION]: Failed
         *
         * assert.fail('boom');
         * // AssertionError [ERR_ASSERTION]: boom
         *
         * assert.fail(new TypeError('need array'));
         * // TypeError: need array
         * ```
         *
         * Using `assert.fail()` with more than two arguments is possible but deprecated.
         * See below for further details.
         * @since v0.1.21
         * @param [message='Failed']
         */
        function fail(message?: string | Error): never;
        /** @deprecated since v10.0.0 - use fail([message]) or other assert functions instead. */
        function fail(
            actual: unknown,
            expected: unknown,
            message?: string | Error,
            operator?: string,
            // eslint-disable-next-line @typescript-eslint/ban-types
            stackStartFn?: Function,
        ): never;
        /**
         * Tests if `value` is truthy. It is equivalent to `assert.equal(!!value, true, message)`.
         *
         * If `value` is not truthy, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is `undefined`, a default
         * error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.
         * If no arguments are passed in at all `message` will be set to the string:`` 'No value argument passed to `assert.ok()`' ``.
         *
         * Be aware that in the `repl` the error message will be different to the one
         * thrown in a file! See below for further details.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.ok(true);
         * // OK
         * assert.ok(1);
         * // OK
         *
         * assert.ok();
         * // AssertionError: No value argument passed to `assert.ok()`
         *
         * assert.ok(false, 'it\'s false');
         * // AssertionError: it's false
         *
         * // In the repl:
         * assert.ok(typeof 123 === 'string');
         * // AssertionError: false == true
         *
         * // In a file (e.g. test.js):
         * assert.ok(typeof 123 === 'string');
         * // AssertionError: The expression evaluated to a falsy value:
         * //
         * //   assert.ok(typeof 123 === 'string')
         *
         * assert.ok(false);
         * // AssertionError: The expression evaluated to a falsy value:
         * //
         * //   assert.ok(false)
         *
         * assert.ok(0);
         * // AssertionError: The expression evaluated to a falsy value:
         * //
         * //   assert.ok(0)
         * ```
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * // Using `assert()` works the same:
         * assert(0);
         * // AssertionError: The expression evaluated to a falsy value:
         * //
         * //   assert(0)
         * ```
         * @since v0.1.21
         */
        function ok(value: unknown, message?: string | Error): asserts value;
        /**
         * **Strict assertion mode**
         *
         * An alias of {@link strictEqual}.
         *
         * **Legacy assertion mode**
         *
         * > Stability: 3 - Legacy: Use {@link strictEqual} instead.
         *
         * Tests shallow, coercive equality between the `actual` and `expected` parameters
         * using the [`==` operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality). `NaN` is specially handled
         * and treated as being identical if both sides are `NaN`.
         *
         * ```js
         * import assert from 'node:assert';
         *
         * assert.equal(1, 1);
         * // OK, 1 == 1
         * assert.equal(1, '1');
         * // OK, 1 == '1'
         * assert.equal(NaN, NaN);
         * // OK
         *
         * assert.equal(1, 2);
         * // AssertionError: 1 == 2
         * assert.equal({ a: { b: 1 } }, { a: { b: 1 } });
         * // AssertionError: { a: { b: 1 } } == { a: { b: 1 } }
         * ```
         *
         * If the values are not equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default
         * error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.
         * @since v0.1.21
         */
        function equal(actual: unknown, expected: unknown, message?: string | Error): void;
        /**
         * **Strict assertion mode**
         *
         * An alias of {@link notStrictEqual}.
         *
         * **Legacy assertion mode**
         *
         * > Stability: 3 - Legacy: Use {@link notStrictEqual} instead.
         *
         * Tests shallow, coercive inequality with the [`!=` operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Inequality). `NaN` is
         * specially handled and treated as being identical if both sides are `NaN`.
         *
         * ```js
         * import assert from 'node:assert';
         *
         * assert.notEqual(1, 2);
         * // OK
         *
         * assert.notEqual(1, 1);
         * // AssertionError: 1 != 1
         *
         * assert.notEqual(1, '1');
         * // AssertionError: 1 != '1'
         * ```
         *
         * If the values are equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default error
         * message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.
         * @since v0.1.21
         */
        function notEqual(actual: unknown, expected: unknown, message?: string | Error): void;
        /**
         * **Strict assertion mode**
         *
         * An alias of {@link deepStrictEqual}.
         *
         * **Legacy assertion mode**
         *
         * > Stability: 3 - Legacy: Use {@link deepStrictEqual} instead.
         *
         * Tests for deep equality between the `actual` and `expected` parameters. Consider
         * using {@link deepStrictEqual} instead. {@link deepEqual} can have
         * surprising results.
         *
         * _Deep equality_ means that the enumerable "own" properties of child objects
         * are also recursively evaluated by the following rules.
         * @since v0.1.21
         */
        function deepEqual(actual: unknown, expected: unknown, message?: string | Error): void;
        /**
         * **Strict assertion mode**
         *
         * An alias of {@link notDeepStrictEqual}.
         *
         * **Legacy assertion mode**
         *
         * > Stability: 3 - Legacy: Use {@link notDeepStrictEqual} instead.
         *
         * Tests for any deep inequality. Opposite of {@link deepEqual}.
         *
         * ```js
         * import assert from 'node:assert';
         *
         * const obj1 = {
         *   a: {
         *     b: 1,
         *   },
         * };
         * const obj2 = {
         *   a: {
         *     b: 2,
         *   },
         * };
         * const obj3 = {
         *   a: {
         *     b: 1,
         *   },
         * };
         * const obj4 = { __proto__: obj1 };
         *
         * assert.notDeepEqual(obj1, obj1);
         * // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }
         *
         * assert.notDeepEqual(obj1, obj2);
         * // OK
         *
         * assert.notDeepEqual(obj1, obj3);
         * // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }
         *
         * assert.notDeepEqual(obj1, obj4);
         * // OK
         * ```
         *
         * If the values are deeply equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default
         * error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown
         * instead of the `AssertionError`.
         * @since v0.1.21
         */
        function notDeepEqual(actual: unknown, expected: unknown, message?: string | Error): void;
        /**
         * Tests strict equality between the `actual` and `expected` parameters as
         * determined by [`Object.is()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.strictEqual(1, 2);
         * // AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal:
         * //
         * // 1 !== 2
         *
         * assert.strictEqual(1, 1);
         * // OK
         *
         * assert.strictEqual('Hello foobar', 'Hello World!');
         * // AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal:
         * // + actual - expected
         * //
         * // + 'Hello foobar'
         * // - 'Hello World!'
         * //          ^
         *
         * const apples = 1;
         * const oranges = 2;
         * assert.strictEqual(apples, oranges, `apples ${apples} !== oranges ${oranges}`);
         * // AssertionError [ERR_ASSERTION]: apples 1 !== oranges 2
         *
         * assert.strictEqual(1, '1', new TypeError('Inputs are not identical'));
         * // TypeError: Inputs are not identical
         * ```
         *
         * If the values are not strictly equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a
         * default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown
         * instead of the `AssertionError`.
         * @since v0.1.21
         */
        function strictEqual<T>(actual: unknown, expected: T, message?: string | Error): asserts actual is T;
        /**
         * Tests strict inequality between the `actual` and `expected` parameters as
         * determined by [`Object.is()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.notStrictEqual(1, 2);
         * // OK
         *
         * assert.notStrictEqual(1, 1);
         * // AssertionError [ERR_ASSERTION]: Expected "actual" to be strictly unequal to:
         * //
         * // 1
         *
         * assert.notStrictEqual(1, '1');
         * // OK
         * ```
         *
         * If the values are strictly equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a
         * default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown
         * instead of the `AssertionError`.
         * @since v0.1.21
         */
        function notStrictEqual(actual: unknown, expected: unknown, message?: string | Error): void;
        /**
         * Tests for deep equality between the `actual` and `expected` parameters.
         * "Deep" equality means that the enumerable "own" properties of child objects
         * are recursively evaluated also by the following rules.
         * @since v1.2.0
         */
        function deepStrictEqual<T>(actual: unknown, expected: T, message?: string | Error): asserts actual is T;
        /**
         * Tests for deep strict inequality. Opposite of {@link deepStrictEqual}.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.notDeepStrictEqual({ a: 1 }, { a: '1' });
         * // OK
         * ```
         *
         * If the values are deeply and strictly equal, an `AssertionError` is thrown
         * with a `message` property set equal to the value of the `message` parameter. If
         * the `message` parameter is undefined, a default error message is assigned. If
         * the `message` parameter is an instance of an `Error` then it will be thrown
         * instead of the `AssertionError`.
         * @since v1.2.0
         */
        function notDeepStrictEqual(actual: unknown, expected: unknown, message?: string | Error): void;
        /**
         * Expects the function `fn` to throw an error.
         *
         * If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes),
         * [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), a validation function,
         * a validation object where each property will be tested for strict deep equality,
         * or an instance of error where each property will be tested for strict deep
         * equality including the non-enumerable `message` and `name` properties. When
         * using an object, it is also possible to use a regular expression, when
         * validating against a string property. See below for examples.
         *
         * If specified, `message` will be appended to the message provided by the `AssertionError` if the `fn` call fails to throw or in case the error validation
         * fails.
         *
         * Custom validation object/error instance:
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * const err = new TypeError('Wrong value');
         * err.code = 404;
         * err.foo = 'bar';
         * err.info = {
         *   nested: true,
         *   baz: 'text',
         * };
         * err.reg = /abc/i;
         *
         * assert.throws(
         *   () => {
         *     throw err;
         *   },
         *   {
         *     name: 'TypeError',
         *     message: 'Wrong value',
         *     info: {
         *       nested: true,
         *       baz: 'text',
         *     },
         *     // Only properties on the validation object will be tested for.
         *     // Using nested objects requires all properties to be present. Otherwise
         *     // the validation is going to fail.
         *   },
         * );
         *
         * // Using regular expressions to validate error properties:
         * assert.throws(
         *   () => {
         *     throw err;
         *   },
         *   {
         *     // The `name` and `message` properties are strings and using regular
         *     // expressions on those will match against the string. If they fail, an
         *     // error is thrown.
         *     name: /^TypeError$/,
         *     message: /Wrong/,
         *     foo: 'bar',
         *     info: {
         *       nested: true,
         *       // It is not possible to use regular expressions for nested properties!
         *       baz: 'text',
         *     },
         *     // The `reg` property contains a regular expression and only if the
         *     // validation object contains an identical regular expression, it is going
         *     // to pass.
         *     reg: /abc/i,
         *   },
         * );
         *
         * // Fails due to the different `message` and `name` properties:
         * assert.throws(
         *   () => {
         *     const otherErr = new Error('Not found');
         *     // Copy all enumerable properties from `err` to `otherErr`.
         *     for (const [key, value] of Object.entries(err)) {
         *       otherErr[key] = value;
         *     }
         *     throw otherErr;
         *   },
         *   // The error's `message` and `name` properties will also be checked when using
         *   // an error as validation object.
         *   err,
         * );
         * ```
         *
         * Validate instanceof using constructor:
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.throws(
         *   () => {
         *     throw new Error('Wrong value');
         *   },
         *   Error,
         * );
         * ```
         *
         * Validate error message using [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions):
         *
         * Using a regular expression runs `.toString` on the error object, and will
         * therefore also include the error name.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.throws(
         *   () => {
         *     throw new Error('Wrong value');
         *   },
         *   /^Error: Wrong value$/,
         * );
         * ```
         *
         * Custom error validation:
         *
         * The function must return `true` to indicate all internal validations passed.
         * It will otherwise fail with an `AssertionError`.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.throws(
         *   () => {
         *     throw new Error('Wrong value');
         *   },
         *   (err) => {
         *     assert(err instanceof Error);
         *     assert(/value/.test(err));
         *     // Avoid returning anything from validation functions besides `true`.
         *     // Otherwise, it's not clear what part of the validation failed. Instead,
         *     // throw an error about the specific validation that failed (as done in this
         *     // example) and add as much helpful debugging information to that error as
         *     // possible.
         *     return true;
         *   },
         *   'unexpected error',
         * );
         * ```
         *
         * `error` cannot be a string. If a string is provided as the second
         * argument, then `error` is assumed to be omitted and the string will be used for `message` instead. This can lead to easy-to-miss mistakes. Using the same
         * message as the thrown error message is going to result in an `ERR_AMBIGUOUS_ARGUMENT` error. Please read the example below carefully if using
         * a string as the second argument gets considered:
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * function throwingFirst() {
         *   throw new Error('First');
         * }
         *
         * function throwingSecond() {
         *   throw new Error('Second');
         * }
         *
         * function notThrowing() {}
         *
         * // The second argument is a string and the input function threw an Error.
         * // The first case will not throw as it does not match for the error message
         * // thrown by the input function!
         * assert.throws(throwingFirst, 'Second');
         * // In the next example the message has no benefit over the message from the
         * // error and since it is not clear if the user intended to actually match
         * // against the error message, Node.js throws an `ERR_AMBIGUOUS_ARGUMENT` error.
         * assert.throws(throwingSecond, 'Second');
         * // TypeError [ERR_AMBIGUOUS_ARGUMENT]
         *
         * // The string is only used (as message) in case the function does not throw:
         * assert.throws(notThrowing, 'Second');
         * // AssertionError [ERR_ASSERTION]: Missing expected exception: Second
         *
         * // If it was intended to match for the error message do this instead:
         * // It does not throw because the error messages match.
         * assert.throws(throwingSecond, /Second$/);
         *
         * // If the error message does not match, an AssertionError is thrown.
         * assert.throws(throwingFirst, /Second$/);
         * // AssertionError [ERR_ASSERTION]
         * ```
         *
         * Due to the confusing error-prone notation, avoid a string as the second
         * argument.
         * @since v0.1.21
         */
        function throws(block: () => unknown, message?: string | Error): void;
        function throws(block: () => unknown, error: AssertPredicate, message?: string | Error): void;
        /**
         * Asserts that the function `fn` does not throw an error.
         *
         * Using `assert.doesNotThrow()` is actually not useful because there
         * is no benefit in catching an error and then rethrowing it. Instead, consider
         * adding a comment next to the specific code path that should not throw and keep
         * error messages as expressive as possible.
         *
         * When `assert.doesNotThrow()` is called, it will immediately call the `fn` function.
         *
         * If an error is thrown and it is the same type as that specified by the `error` parameter, then an `AssertionError` is thrown. If the error is of a
         * different type, or if the `error` parameter is undefined, the error is
         * propagated back to the caller.
         *
         * If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes),
         * [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), or a validation
         * function. See {@link throws} for more details.
         *
         * The following, for instance, will throw the `TypeError` because there is no
         * matching error type in the assertion:
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.doesNotThrow(
         *   () => {
         *     throw new TypeError('Wrong value');
         *   },
         *   SyntaxError,
         * );
         * ```
         *
         * However, the following will result in an `AssertionError` with the message
         * 'Got unwanted exception...':
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.doesNotThrow(
         *   () => {
         *     throw new TypeError('Wrong value');
         *   },
         *   TypeError,
         * );
         * ```
         *
         * If an `AssertionError` is thrown and a value is provided for the `message` parameter, the value of `message` will be appended to the `AssertionError` message:
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.doesNotThrow(
         *   () => {
         *     throw new TypeError('Wrong value');
         *   },
         *   /Wrong value/,
         *   'Whoops',
         * );
         * // Throws: AssertionError: Got unwanted exception: Whoops
         * ```
         * @since v0.1.21
         */
        function doesNotThrow(block: () => unknown, message?: string | Error): void;
        function doesNotThrow(block: () => unknown, error: AssertPredicate, message?: string | Error): void;
        /**
         * Throws `value` if `value` is not `undefined` or `null`. This is useful when
         * testing the `error` argument in callbacks. The stack trace contains all frames
         * from the error passed to `ifError()` including the potential new frames for `ifError()` itself.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.ifError(null);
         * // OK
         * assert.ifError(0);
         * // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 0
         * assert.ifError('error');
         * // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 'error'
         * assert.ifError(new Error());
         * // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: Error
         *
         * // Create some random error frames.
         * let err;
         * (function errorFrame() {
         *   err = new Error('test error');
         * })();
         *
         * (function ifErrorFrame() {
         *   assert.ifError(err);
         * })();
         * // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: test error
         * //     at ifErrorFrame
         * //     at errorFrame
         * ```
         * @since v0.1.97
         */
        function ifError(value: unknown): asserts value is null | undefined;
        /**
         * Awaits the `asyncFn` promise or, if `asyncFn` is a function, immediately
         * calls the function and awaits the returned promise to complete. It will then
         * check that the promise is rejected.
         *
         * If `asyncFn` is a function and it throws an error synchronously, `assert.rejects()` will return a rejected `Promise` with that error. If the
         * function does not return a promise, `assert.rejects()` will return a rejected `Promise` with an [ERR_INVALID_RETURN_VALUE](https://nodejs.org/docs/latest-v22.x/api/errors.html#err_invalid_return_value)
         * error. In both cases the error handler is skipped.
         *
         * Besides the async nature to await the completion behaves identically to {@link throws}.
         *
         * If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes),
         * [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), a validation function,
         * an object where each property will be tested for, or an instance of error where
         * each property will be tested for including the non-enumerable `message` and `name` properties.
         *
         * If specified, `message` will be the message provided by the `{@link AssertionError}` if the `asyncFn` fails to reject.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * await assert.rejects(
         *   async () => {
         *     throw new TypeError('Wrong value');
         *   },
         *   {
         *     name: 'TypeError',
         *     message: 'Wrong value',
         *   },
         * );
         * ```
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * await assert.rejects(
         *   async () => {
         *     throw new TypeError('Wrong value');
         *   },
         *   (err) => {
         *     assert.strictEqual(err.name, 'TypeError');
         *     assert.strictEqual(err.message, 'Wrong value');
         *     return true;
         *   },
         * );
         * ```
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.rejects(
         *   Promise.reject(new Error('Wrong value')),
         *   Error,
         * ).then(() => {
         *   // ...
         * });
         * ```
         *
         * `error` cannot be a string. If a string is provided as the second argument, then `error` is assumed to
         * be omitted and the string will be used for `message` instead. This can lead to easy-to-miss mistakes. Please read the
         * example in {@link throws} carefully if using a string as the second argument gets considered.
         * @since v10.0.0
         */
        function rejects(block: (() => Promise<unknown>) | Promise<unknown>, message?: string | Error): Promise<void>;
        function rejects(
            block: (() => Promise<unknown>) | Promise<unknown>,
            error: AssertPredicate,
            message?: string | Error,
        ): Promise<void>;
        /**
         * Awaits the `asyncFn` promise or, if `asyncFn` is a function, immediately
         * calls the function and awaits the returned promise to complete. It will then
         * check that the promise is not rejected.
         *
         * If `asyncFn` is a function and it throws an error synchronously, `assert.doesNotReject()` will return a rejected `Promise` with that error. If
         * the function does not return a promise, `assert.doesNotReject()` will return a
         * rejected `Promise` with an [ERR_INVALID_RETURN_VALUE](https://nodejs.org/docs/latest-v22.x/api/errors.html#err_invalid_return_value) error. In both cases
         * the error handler is skipped.
         *
         * Using `assert.doesNotReject()` is actually not useful because there is little
         * benefit in catching a rejection and then rejecting it again. Instead, consider
         * adding a comment next to the specific code path that should not reject and keep
         * error messages as expressive as possible.
         *
         * If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes),
         * [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), or a validation
         * function. See {@link throws} for more details.
         *
         * Besides the async nature to await the completion behaves identically to {@link doesNotThrow}.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * await assert.doesNotReject(
         *   async () => {
         *     throw new TypeError('Wrong value');
         *   },
         *   SyntaxError,
         * );
         * ```
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.doesNotReject(Promise.reject(new TypeError('Wrong value')))
         *   .then(() => {
         *     // ...
         *   });
         * ```
         * @since v10.0.0
         */
        function doesNotReject(
            block: (() => Promise<unknown>) | Promise<unknown>,
            message?: string | Error,
        ): Promise<void>;
        function doesNotReject(
            block: (() => Promise<unknown>) | Promise<unknown>,
            error: AssertPredicate,
            message?: string | Error,
        ): Promise<void>;
        /**
         * Expects the `string` input to match the regular expression.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.match('I will fail', /pass/);
         * // AssertionError [ERR_ASSERTION]: The input did not match the regular ...
         *
         * assert.match(123, /pass/);
         * // AssertionError [ERR_ASSERTION]: The "string" argument must be of type string.
         *
         * assert.match('I will pass', /pass/);
         * // OK
         * ```
         *
         * If the values do not match, or if the `string` argument is of another type than `string`, an `{@link AssertionError}` is thrown with a `message` property set equal
         * to the value of the `message` parameter. If the `message` parameter is
         * undefined, a default error message is assigned. If the `message` parameter is an
         * instance of an [Error](https://nodejs.org/docs/latest-v22.x/api/errors.html#class-error) then it will be thrown instead of the `{@link AssertionError}`.
         * @since v13.6.0, v12.16.0
         */
        function match(value: string, regExp: RegExp, message?: string | Error): void;
        /**
         * Expects the `string` input not to match the regular expression.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.doesNotMatch('I will fail', /fail/);
         * // AssertionError [ERR_ASSERTION]: The input was expected to not match the ...
         *
         * assert.doesNotMatch(123, /pass/);
         * // AssertionError [ERR_ASSERTION]: The "string" argument must be of type string.
         *
         * assert.doesNotMatch('I will pass', /different/);
         * // OK
         * ```
         *
         * If the values do match, or if the `string` argument is of another type than `string`, an `{@link AssertionError}` is thrown with a `message` property set equal
         * to the value of the `message` parameter. If the `message` parameter is
         * undefined, a default error message is assigned. If the `message` parameter is an
         * instance of an [Error](https://nodejs.org/docs/latest-v22.x/api/errors.html#class-error) then it will be thrown instead of the `{@link AssertionError}`.
         * @since v13.6.0, v12.16.0
         */
        function doesNotMatch(value: string, regExp: RegExp, message?: string | Error): void;
        /**
         * In strict assertion mode, non-strict methods behave like their corresponding strict methods. For example,
         * {@link deepEqual} will behave like {@link deepStrictEqual}.
         *
         * In strict assertion mode, error messages for objects display a diff. In legacy assertion mode, error
         * messages for objects display the objects, often truncated.
         *
         * To use strict assertion mode:
         *
         * ```js
         * import { strict as assert } from 'node:assert';COPY
         * import assert from 'node:assert/strict';
         * ```
         *
         * Example error diff:
         *
         * ```js
         * import { strict as assert } from 'node:assert';
         *
         * assert.deepEqual([[[1, 2, 3]], 4, 5], [[[1, 2, '3']], 4, 5]);
         * // AssertionError: Expected inputs to be strictly deep-equal:
         * // + actual - expected ... Lines skipped
         * //
         * //   [
         * //     [
         * // ...
         * //       2,
         * // +     3
         * // -     '3'
         * //     ],
         * // ...
         * //     5
         * //   ]
         * ```
         *
         * To deactivate the colors, use the `NO_COLOR` or `NODE_DISABLE_COLORS` environment variables. This will also
         * deactivate the colors in the REPL. For more on color support in terminal environments, read the tty
         * `getColorDepth()` documentation.
         *
         * @since v15.0.0, v13.9.0, v12.16.2, v9.9.0
         */
        namespace strict {
            type AssertionError = assert.AssertionError;
            type AssertPredicate = assert.AssertPredicate;
            type CallTrackerCall = assert.CallTrackerCall;
            type CallTrackerReportInformation = assert.CallTrackerReportInformation;
        }
        const strict:
            & Omit<
                typeof assert,
                | "equal"
                | "notEqual"
                | "deepEqual"
                | "notDeepEqual"
                | "ok"
                | "strictEqual"
                | "deepStrictEqual"
                | "ifError"
                | "strict"
            >
            & {
                (value: unknown, message?: string | Error): asserts value;
                equal: typeof strictEqual;
                notEqual: typeof notStrictEqual;
                deepEqual: typeof deepStrictEqual;
                notDeepEqual: typeof notDeepStrictEqual;
                // Mapped types and assertion functions are incompatible?
                // TS2775: Assertions require every name in the call target
                // to be declared with an explicit type annotation.
                ok: typeof ok;
                strictEqual: typeof strictEqual;
                deepStrictEqual: typeof deepStrictEqual;
                ifError: typeof ifError;
                strict: typeof strict;
            };
    }
    export = assert;
}
declare module "node:assert" {
    import assert = require("assert");
    export = assert;
}
declare module "assert/strict" {
    import { strict } from "node:assert";
    export = strict;
}
declare module "node:assert/strict" {
    import { strict } from "node:assert";
    export = strict;
}
/**
 * We strongly discourage the use of the `async_hooks` API.
 * Other APIs that can cover most of its use cases include:
 *
 * * [`AsyncLocalStorage`](https://nodejs.org/docs/latest-v22.x/api/async_context.html#class-asynclocalstorage) tracks async context
 * * [`process.getActiveResourcesInfo()`](https://nodejs.org/docs/latest-v22.x/api/process.html#processgetactiveresourcesinfo) tracks active resources
 *
 * The `node:async_hooks` module provides an API to track asynchronous resources.
 * It can be accessed using:
 *
 * ```js
 * import async_hooks from 'node:async_hooks';
 * ```
 * @experimental
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/async_hooks.js)
 */
declare module "async_hooks" {
    /**
     * ```js
     * import { executionAsyncId } from 'node:async_hooks';
     * import fs from 'node:fs';
     *
     * console.log(executionAsyncId());  // 1 - bootstrap
     * const path = '.';
     * fs.open(path, 'r', (err, fd) => {
     *   console.log(executionAsyncId());  // 6 - open()
     * });
     * ```
     *
     * The ID returned from `executionAsyncId()` is related to execution timing, not
     * causality (which is covered by `triggerAsyncId()`):
     *
     * ```js
     * const server = net.createServer((conn) => {
     *   // Returns the ID of the server, not of the new connection, because the
     *   // callback runs in the execution scope of the server's MakeCallback().
     *   async_hooks.executionAsyncId();
     *
     * }).listen(port, () => {
     *   // Returns the ID of a TickObject (process.nextTick()) because all
     *   // callbacks passed to .listen() are wrapped in a nextTick().
     *   async_hooks.executionAsyncId();
     * });
     * ```
     *
     * Promise contexts may not get precise `executionAsyncIds` by default.
     * See the section on [promise execution tracking](https://nodejs.org/docs/latest-v22.x/api/async_hooks.html#promise-execution-tracking).
     * @since v8.1.0
     * @return The `asyncId` of the current execution context. Useful to track when something calls.
     */
    function executionAsyncId(): number;
    /**
     * Resource objects returned by `executionAsyncResource()` are most often internal
     * Node.js handle objects with undocumented APIs. Using any functions or properties
     * on the object is likely to crash your application and should be avoided.
     *
     * Using `executionAsyncResource()` in the top-level execution context will
     * return an empty object as there is no handle or request object to use,
     * but having an object representing the top-level can be helpful.
     *
     * ```js
     * import { open } from 'node:fs';
     * import { executionAsyncId, executionAsyncResource } from 'node:async_hooks';
     *
     * console.log(executionAsyncId(), executionAsyncResource());  // 1 {}
     * open(new URL(import.meta.url), 'r', (err, fd) => {
     *   console.log(executionAsyncId(), executionAsyncResource());  // 7 FSReqWrap
     * });
     * ```
     *
     * This can be used to implement continuation local storage without the
     * use of a tracking `Map` to store the metadata:
     *
     * ```js
     * import { createServer } from 'node:http';
     * import {
     *   executionAsyncId,
     *   executionAsyncResource,
     *   createHook,
     * } from 'async_hooks';
     * const sym = Symbol('state'); // Private symbol to avoid pollution
     *
     * createHook({
     *   init(asyncId, type, triggerAsyncId, resource) {
     *     const cr = executionAsyncResource();
     *     if (cr) {
     *       resource[sym] = cr[sym];
     *     }
     *   },
     * }).enable();
     *
     * const server = createServer((req, res) => {
     *   executionAsyncResource()[sym] = { state: req.url };
     *   setTimeout(function() {
     *     res.end(JSON.stringify(executionAsyncResource()[sym]));
     *   }, 100);
     * }).listen(3000);
     * ```
     * @since v13.9.0, v12.17.0
     * @return The resource representing the current execution. Useful to store data within the resource.
     */
    function executionAsyncResource(): object;
    /**
     * ```js
     * const server = net.createServer((conn) => {
     *   // The resource that caused (or triggered) this callback to be called
     *   // was that of the new connection. Thus the return value of triggerAsyncId()
     *   // is the asyncId of "conn".
     *   async_hooks.triggerAsyncId();
     *
     * }).listen(port, () => {
     *   // Even though all callbacks passed to .listen() are wrapped in a nextTick()
     *   // the callback itself exists because the call to the server's .listen()
     *   // was made. So the return value would be the ID of the server.
     *   async_hooks.triggerAsyncId();
     * });
     * ```
     *
     * Promise contexts may not get valid `triggerAsyncId`s by default. See
     * the section on [promise execution tracking](https://nodejs.org/docs/latest-v22.x/api/async_hooks.html#promise-execution-tracking).
     * @return The ID of the resource responsible for calling the callback that is currently being executed.
     */
    function triggerAsyncId(): number;
    interface HookCallbacks {
        /**
         * Called when a class is constructed that has the possibility to emit an asynchronous event.
         * @param asyncId A unique ID for the async resource
         * @param type The type of the async resource
         * @param triggerAsyncId The unique ID of the async resource in whose execution context this async resource was created
         * @param resource Reference to the resource representing the async operation, needs to be released during destroy
         */
        init?(asyncId: number, type: string, triggerAsyncId: number, resource: object): void;
        /**
         * When an asynchronous operation is initiated or completes a callback is called to notify the user.
         * The before callback is called just before said callback is executed.
         * @param asyncId the unique identifier assigned to the resource about to execute the callback.
         */
        before?(asyncId: number): void;
        /**
         * Called immediately after the callback specified in `before` is completed.
         *
         * If an uncaught exception occurs during execution of the callback, then `after` will run after the `'uncaughtException'` event is emitted or a `domain`'s handler runs.
         * @param asyncId the unique identifier assigned to the resource which has executed the callback.
         */
        after?(asyncId: number): void;
        /**
         * Called when a promise has resolve() called. This may not be in the same execution id
         * as the promise itself.
         * @param asyncId the unique id for the promise that was resolve()d.
         */
        promiseResolve?(asyncId: number): void;
        /**
         * Called after the resource corresponding to asyncId is destroyed
         * @param asyncId a unique ID for the async resource
         */
        destroy?(asyncId: number): void;
    }
    interface AsyncHook {
        /**
         * Enable the callbacks for a given AsyncHook instance. If no callbacks are provided enabling is a noop.
         */
        enable(): this;
        /**
         * Disable the callbacks for a given AsyncHook instance from the global pool of AsyncHook callbacks to be executed. Once a hook has been disabled it will not be called again until enabled.
         */
        disable(): this;
    }
    /**
     * Registers functions to be called for different lifetime events of each async
     * operation.
     *
     * The callbacks `init()`/`before()`/`after()`/`destroy()` are called for the
     * respective asynchronous event during a resource's lifetime.
     *
     * All callbacks are optional. For example, if only resource cleanup needs to
     * be tracked, then only the `destroy` callback needs to be passed. The
     * specifics of all functions that can be passed to `callbacks` is in the `Hook Callbacks` section.
     *
     * ```js
     * import { createHook } from 'node:async_hooks';
     *
     * const asyncHook = createHook({
     *   init(asyncId, type, triggerAsyncId, resource) { },
     *   destroy(asyncId) { },
     * });
     * ```
     *
     * The callbacks will be inherited via the prototype chain:
     *
     * ```js
     * class MyAsyncCallbacks {
     *   init(asyncId, type, triggerAsyncId, resource) { }
     *   destroy(asyncId) {}
     * }
     *
     * class MyAddedCallbacks extends MyAsyncCallbacks {
     *   before(asyncId) { }
     *   after(asyncId) { }
     * }
     *
     * const asyncHook = async_hooks.createHook(new MyAddedCallbacks());
     * ```
     *
     * Because promises are asynchronous resources whose lifecycle is tracked
     * via the async hooks mechanism, the `init()`, `before()`, `after()`, and`destroy()` callbacks _must not_ be async functions that return promises.
     * @since v8.1.0
     * @param callbacks The `Hook Callbacks` to register
     * @return Instance used for disabling and enabling hooks
     */
    function createHook(callbacks: HookCallbacks): AsyncHook;
    interface AsyncResourceOptions {
        /**
         * The ID of the execution context that created this async event.
         * @default executionAsyncId()
         */
        triggerAsyncId?: number | undefined;
        /**
         * Disables automatic `emitDestroy` when the object is garbage collected.
         * This usually does not need to be set (even if `emitDestroy` is called
         * manually), unless the resource's `asyncId` is retrieved and the
         * sensitive API's `emitDestroy` is called with it.
         * @default false
         */
        requireManualDestroy?: boolean | undefined;
    }
    /**
     * The class `AsyncResource` is designed to be extended by the embedder's async
     * resources. Using this, users can easily trigger the lifetime events of their
     * own resources.
     *
     * The `init` hook will trigger when an `AsyncResource` is instantiated.
     *
     * The following is an overview of the `AsyncResource` API.
     *
     * ```js
     * import { AsyncResource, executionAsyncId } from 'node:async_hooks';
     *
     * // AsyncResource() is meant to be extended. Instantiating a
     * // new AsyncResource() also triggers init. If triggerAsyncId is omitted then
     * // async_hook.executionAsyncId() is used.
     * const asyncResource = new AsyncResource(
     *   type, { triggerAsyncId: executionAsyncId(), requireManualDestroy: false },
     * );
     *
     * // Run a function in the execution context of the resource. This will
     * // * establish the context of the resource
     * // * trigger the AsyncHooks before callbacks
     * // * call the provided function `fn` with the supplied arguments
     * // * trigger the AsyncHooks after callbacks
     * // * restore the original execution context
     * asyncResource.runInAsyncScope(fn, thisArg, ...args);
     *
     * // Call AsyncHooks destroy callbacks.
     * asyncResource.emitDestroy();
     *
     * // Return the unique ID assigned to the AsyncResource instance.
     * asyncResource.asyncId();
     *
     * // Return the trigger ID for the AsyncResource instance.
     * asyncResource.triggerAsyncId();
     * ```
     */
    class AsyncResource {
        /**
         * AsyncResource() is meant to be extended. Instantiating a
         * new AsyncResource() also triggers init. If triggerAsyncId is omitted then
         * async_hook.executionAsyncId() is used.
         * @param type The type of async event.
         * @param triggerAsyncId The ID of the execution context that created
         *   this async event (default: `executionAsyncId()`), or an
         *   AsyncResourceOptions object (since v9.3.0)
         */
        constructor(type: string, triggerAsyncId?: number | AsyncResourceOptions);
        /**
         * Binds the given function to the current execution context.
         * @since v14.8.0, v12.19.0
         * @param fn The function to bind to the current execution context.
         * @param type An optional name to associate with the underlying `AsyncResource`.
         */
        static bind<Func extends (this: ThisArg, ...args: any[]) => any, ThisArg>(
            fn: Func,
            type?: string,
            thisArg?: ThisArg,
        ): Func;
        /**
         * Binds the given function to execute to this `AsyncResource`'s scope.
         * @since v14.8.0, v12.19.0
         * @param fn The function to bind to the current `AsyncResource`.
         */
        bind<Func extends (...args: any[]) => any>(fn: Func): Func;
        /**
         * Call the provided function with the provided arguments in the execution context
         * of the async resource. This will establish the context, trigger the AsyncHooks
         * before callbacks, call the function, trigger the AsyncHooks after callbacks, and
         * then restore the original execution context.
         * @since v9.6.0
         * @param fn The function to call in the execution context of this async resource.
         * @param thisArg The receiver to be used for the function call.
         * @param args Optional arguments to pass to the function.
         */
        runInAsyncScope<This, Result>(
            fn: (this: This, ...args: any[]) => Result,
            thisArg?: This,
            ...args: any[]
        ): Result;
        /**
         * Call all `destroy` hooks. This should only ever be called once. An error will
         * be thrown if it is called more than once. This **must** be manually called. If
         * the resource is left to be collected by the GC then the `destroy` hooks will
         * never be called.
         * @return A reference to `asyncResource`.
         */
        emitDestroy(): this;
        /**
         * @return The unique `asyncId` assigned to the resource.
         */
        asyncId(): number;
        /**
         * @return The same `triggerAsyncId` that is passed to the `AsyncResource` constructor.
         */
        triggerAsyncId(): number;
    }
    /**
     * This class creates stores that stay coherent through asynchronous operations.
     *
     * While you can create your own implementation on top of the `node:async_hooks` module, `AsyncLocalStorage` should be preferred as it is a performant and memory
     * safe implementation that involves significant optimizations that are non-obvious
     * to implement.
     *
     * The following example uses `AsyncLocalStorage` to build a simple logger
     * that assigns IDs to incoming HTTP requests and includes them in messages
     * logged within each request.
     *
     * ```js
     * import http from 'node:http';
     * import { AsyncLocalStorage } from 'node:async_hooks';
     *
     * const asyncLocalStorage = new AsyncLocalStorage();
     *
     * function logWithId(msg) {
     *   const id = asyncLocalStorage.getStore();
     *   console.log(`${id !== undefined ? id : '-'}:`, msg);
     * }
     *
     * let idSeq = 0;
     * http.createServer((req, res) => {
     *   asyncLocalStorage.run(idSeq++, () => {
     *     logWithId('start');
     *     // Imagine any chain of async operations here
     *     setImmediate(() => {
     *       logWithId('finish');
     *       res.end();
     *     });
     *   });
     * }).listen(8080);
     *
     * http.get('http://localhost:8080');
     * http.get('http://localhost:8080');
     * // Prints:
     * //   0: start
     * //   1: start
     * //   0: finish
     * //   1: finish
     * ```
     *
     * Each instance of `AsyncLocalStorage` maintains an independent storage context.
     * Multiple instances can safely exist simultaneously without risk of interfering
     * with each other's data.
     * @since v13.10.0, v12.17.0
     */
    class AsyncLocalStorage<T> {
        /**
         * Binds the given function to the current execution context.
         * @since v19.8.0
         * @experimental
         * @param fn The function to bind to the current execution context.
         * @return A new function that calls `fn` within the captured execution context.
         */
        static bind<Func extends (...args: any[]) => any>(fn: Func): Func;
        /**
         * Captures the current execution context and returns a function that accepts a
         * function as an argument. Whenever the returned function is called, it
         * calls the function passed to it within the captured context.
         *
         * ```js
         * const asyncLocalStorage = new AsyncLocalStorage();
         * const runInAsyncScope = asyncLocalStorage.run(123, () => AsyncLocalStorage.snapshot());
         * const result = asyncLocalStorage.run(321, () => runInAsyncScope(() => asyncLocalStorage.getStore()));
         * console.log(result);  // returns 123
         * ```
         *
         * AsyncLocalStorage.snapshot() can replace the use of AsyncResource for simple
         * async context tracking purposes, for example:
         *
         * ```js
         * class Foo {
         *   #runInAsyncScope = AsyncLocalStorage.snapshot();
         *
         *   get() { return this.#runInAsyncScope(() => asyncLocalStorage.getStore()); }
         * }
         *
         * const foo = asyncLocalStorage.run(123, () => new Foo());
         * console.log(asyncLocalStorage.run(321, () => foo.get())); // returns 123
         * ```
         * @since v19.8.0
         * @experimental
         * @return A new function with the signature `(fn: (...args) : R, ...args) : R`.
         */
        static snapshot(): <R, TArgs extends any[]>(fn: (...args: TArgs) => R, ...args: TArgs) => R;
        /**
         * Disables the instance of `AsyncLocalStorage`. All subsequent calls
         * to `asyncLocalStorage.getStore()` will return `undefined` until `asyncLocalStorage.run()` or `asyncLocalStorage.enterWith()` is called again.
         *
         * When calling `asyncLocalStorage.disable()`, all current contexts linked to the
         * instance will be exited.
         *
         * Calling `asyncLocalStorage.disable()` is required before the `asyncLocalStorage` can be garbage collected. This does not apply to stores
         * provided by the `asyncLocalStorage`, as those objects are garbage collected
         * along with the corresponding async resources.
         *
         * Use this method when the `asyncLocalStorage` is not in use anymore
         * in the current process.
         * @since v13.10.0, v12.17.0
         * @experimental
         */
        disable(): void;
        /**
         * Returns the current store.
         * If called outside of an asynchronous context initialized by
         * calling `asyncLocalStorage.run()` or `asyncLocalStorage.enterWith()`, it
         * returns `undefined`.
         * @since v13.10.0, v12.17.0
         */
        getStore(): T | undefined;
        /**
         * Runs a function synchronously within a context and returns its
         * return value. The store is not accessible outside of the callback function.
         * The store is accessible to any asynchronous operations created within the
         * callback.
         *
         * The optional `args` are passed to the callback function.
         *
         * If the callback function throws an error, the error is thrown by `run()` too.
         * The stacktrace is not impacted by this call and the context is exited.
         *
         * Example:
         *
         * ```js
         * const store = { id: 2 };
         * try {
         *   asyncLocalStorage.run(store, () => {
         *     asyncLocalStorage.getStore(); // Returns the store object
         *     setTimeout(() => {
         *       asyncLocalStorage.getStore(); // Returns the store object
         *     }, 200);
         *     throw new Error();
         *   });
         * } catch (e) {
         *   asyncLocalStorage.getStore(); // Returns undefined
         *   // The error will be caught here
         * }
         * ```
         * @since v13.10.0, v12.17.0
         */
        run<R>(store: T, callback: () => R): R;
        run<R, TArgs extends any[]>(store: T, callback: (...args: TArgs) => R, ...args: TArgs): R;
        /**
         * Runs a function synchronously outside of a context and returns its
         * return value. The store is not accessible within the callback function or
         * the asynchronous operations created within the callback. Any `getStore()` call done within the callback function will always return `undefined`.
         *
         * The optional `args` are passed to the callback function.
         *
         * If the callback function throws an error, the error is thrown by `exit()` too.
         * The stacktrace is not impacted by this call and the context is re-entered.
         *
         * Example:
         *
         * ```js
         * // Within a call to run
         * try {
         *   asyncLocalStorage.getStore(); // Returns the store object or value
         *   asyncLocalStorage.exit(() => {
         *     asyncLocalStorage.getStore(); // Returns undefined
         *     throw new Error();
         *   });
         * } catch (e) {
         *   asyncLocalStorage.getStore(); // Returns the same object or value
         *   // The error will be caught here
         * }
         * ```
         * @since v13.10.0, v12.17.0
         * @experimental
         */
        exit<R, TArgs extends any[]>(callback: (...args: TArgs) => R, ...args: TArgs): R;
        /**
         * Transitions into the context for the remainder of the current
         * synchronous execution and then persists the store through any following
         * asynchronous calls.
         *
         * Example:
         *
         * ```js
         * const store = { id: 1 };
         * // Replaces previous store with the given store object
         * asyncLocalStorage.enterWith(store);
         * asyncLocalStorage.getStore(); // Returns the store object
         * someAsyncOperation(() => {
         *   asyncLocalStorage.getStore(); // Returns the same object
         * });
         * ```
         *
         * This transition will continue for the _entire_ synchronous execution.
         * This means that if, for example, the context is entered within an event
         * handler subsequent event handlers will also run within that context unless
         * specifically bound to another context with an `AsyncResource`. That is why `run()` should be preferred over `enterWith()` unless there are strong reasons
         * to use the latter method.
         *
         * ```js
         * const store = { id: 1 };
         *
         * emitter.on('my-event', () => {
         *   asyncLocalStorage.enterWith(store);
         * });
         * emitter.on('my-event', () => {
         *   asyncLocalStorage.getStore(); // Returns the same object
         * });
         *
         * asyncLocalStorage.getStore(); // Returns undefined
         * emitter.emit('my-event');
         * asyncLocalStorage.getStore(); // Returns the same object
         * ```
         * @since v13.11.0, v12.17.0
         * @experimental
         */
        enterWith(store: T): void;
    }
}
declare module "node:async_hooks" {
    export * from "async_hooks";
}
// If lib.dom.d.ts or lib.webworker.d.ts is loaded, then use the global types.
// Otherwise, use the types from node.
type _Blob = typeof globalThis extends { onmessage: any; Blob: any } ? {} : import("buffer").Blob;
type _File = typeof globalThis extends { onmessage: any; File: any } ? {} : import("buffer").File;

/**
 * `Buffer` objects are used to represent a fixed-length sequence of bytes. Many
 * Node.js APIs support `Buffer`s.
 *
 * The `Buffer` class is a subclass of JavaScript's [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) class and
 * extends it with methods that cover additional use cases. Node.js APIs accept
 * plain [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) s wherever `Buffer`s are supported as well.
 *
 * While the `Buffer` class is available within the global scope, it is still
 * recommended to explicitly reference it via an import or require statement.
 *
 * ```js
 * import { Buffer } from 'node:buffer';
 *
 * // Creates a zero-filled Buffer of length 10.
 * const buf1 = Buffer.alloc(10);
 *
 * // Creates a Buffer of length 10,
 * // filled with bytes which all have the value `1`.
 * const buf2 = Buffer.alloc(10, 1);
 *
 * // Creates an uninitialized buffer of length 10.
 * // This is faster than calling Buffer.alloc() but the returned
 * // Buffer instance might contain old data that needs to be
 * // overwritten using fill(), write(), or other functions that fill the Buffer's
 * // contents.
 * const buf3 = Buffer.allocUnsafe(10);
 *
 * // Creates a Buffer containing the bytes [1, 2, 3].
 * const buf4 = Buffer.from([1, 2, 3]);
 *
 * // Creates a Buffer containing the bytes [1, 1, 1, 1] – the entries
 * // are all truncated using `(value &#x26; 255)` to fit into the range 0–255.
 * const buf5 = Buffer.from([257, 257.5, -255, '1']);
 *
 * // Creates a Buffer containing the UTF-8-encoded bytes for the string 'tést':
 * // [0x74, 0xc3, 0xa9, 0x73, 0x74] (in hexadecimal notation)
 * // [116, 195, 169, 115, 116] (in decimal notation)
 * const buf6 = Buffer.from('tést');
 *
 * // Creates a Buffer containing the Latin-1 bytes [0x74, 0xe9, 0x73, 0x74].
 * const buf7 = Buffer.from('tést', 'latin1');
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/buffer.js)
 */
declare module "buffer" {
    import { BinaryLike } from "node:crypto";
    import { ReadableStream as WebReadableStream } from "node:stream/web";
    /**
     * This function returns `true` if `input` contains only valid UTF-8-encoded data,
     * including the case in which `input` is empty.
     *
     * Throws if the `input` is a detached array buffer.
     * @since v19.4.0, v18.14.0
     * @param input The input to validate.
     */
    export function isUtf8(input: Buffer | ArrayBuffer | NodeJS.TypedArray): boolean;
    /**
     * This function returns `true` if `input` contains only valid ASCII-encoded data,
     * including the case in which `input` is empty.
     *
     * Throws if the `input` is a detached array buffer.
     * @since v19.6.0, v18.15.0
     * @param input The input to validate.
     */
    export function isAscii(input: Buffer | ArrayBuffer | NodeJS.TypedArray): boolean;
    export const INSPECT_MAX_BYTES: number;
    export const kMaxLength: number;
    export const kStringMaxLength: number;
    export const constants: {
        MAX_LENGTH: number;
        MAX_STRING_LENGTH: number;
    };
    export type TranscodeEncoding =
        | "ascii"
        | "utf8"
        | "utf-8"
        | "utf16le"
        | "utf-16le"
        | "ucs2"
        | "ucs-2"
        | "latin1"
        | "binary";
    /**
     * Re-encodes the given `Buffer` or `Uint8Array` instance from one character
     * encoding to another. Returns a new `Buffer` instance.
     *
     * Throws if the `fromEnc` or `toEnc` specify invalid character encodings or if
     * conversion from `fromEnc` to `toEnc` is not permitted.
     *
     * Encodings supported by `buffer.transcode()` are: `'ascii'`, `'utf8'`, `'utf16le'`, `'ucs2'`, `'latin1'`, and `'binary'`.
     *
     * The transcoding process will use substitution characters if a given byte
     * sequence cannot be adequately represented in the target encoding. For instance:
     *
     * ```js
     * import { Buffer, transcode } from 'node:buffer';
     *
     * const newBuf = transcode(Buffer.from('€'), 'utf8', 'ascii');
     * console.log(newBuf.toString('ascii'));
     * // Prints: '?'
     * ```
     *
     * Because the Euro (`€`) sign is not representable in US-ASCII, it is replaced
     * with `?` in the transcoded `Buffer`.
     * @since v7.1.0
     * @param source A `Buffer` or `Uint8Array` instance.
     * @param fromEnc The current encoding.
     * @param toEnc To target encoding.
     */
    export function transcode(source: Uint8Array, fromEnc: TranscodeEncoding, toEnc: TranscodeEncoding): Buffer;
    export const SlowBuffer: {
        /** @deprecated since v6.0.0, use `Buffer.allocUnsafeSlow()` */
        new(size: number): Buffer;
        prototype: Buffer;
    };
    /**
     * Resolves a `'blob:nodedata:...'` an associated `Blob` object registered using
     * a prior call to `URL.createObjectURL()`.
     * @since v16.7.0
     * @experimental
     * @param id A `'blob:nodedata:...` URL string returned by a prior call to `URL.createObjectURL()`.
     */
    export function resolveObjectURL(id: string): Blob | undefined;
    export { Buffer };
    /**
     * @experimental
     */
    export interface BlobOptions {
        /**
         * One of either `'transparent'` or `'native'`. When set to `'native'`, line endings in string source parts
         * will be converted to the platform native line-ending as specified by `require('node:os').EOL`.
         */
        endings?: "transparent" | "native";
        /**
         * The Blob content-type. The intent is for `type` to convey
         * the MIME media type of the data, however no validation of the type format
         * is performed.
         */
        type?: string | undefined;
    }
    /**
     * A [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) encapsulates immutable, raw data that can be safely shared across
     * multiple worker threads.
     * @since v15.7.0, v14.18.0
     */
    export class Blob {
        /**
         * The total size of the `Blob` in bytes.
         * @since v15.7.0, v14.18.0
         */
        readonly size: number;
        /**
         * The content-type of the `Blob`.
         * @since v15.7.0, v14.18.0
         */
        readonly type: string;
        /**
         * Creates a new `Blob` object containing a concatenation of the given sources.
         *
         * {ArrayBuffer}, {TypedArray}, {DataView}, and {Buffer} sources are copied into
         * the 'Blob' and can therefore be safely modified after the 'Blob' is created.
         *
         * String sources are also copied into the `Blob`.
         */
        constructor(sources: Array<ArrayBuffer | BinaryLike | Blob>, options?: BlobOptions);
        /**
         * Returns a promise that fulfills with an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) containing a copy of
         * the `Blob` data.
         * @since v15.7.0, v14.18.0
         */
        arrayBuffer(): Promise<ArrayBuffer>;
        /**
         * The `blob.bytes()` method returns the byte of the `Blob` object as a `Promise<Uint8Array>`.
         *
         * ```js
         * const blob = new Blob(['hello']);
         * blob.bytes().then((bytes) => {
         *   console.log(bytes); // Outputs: Uint8Array(5) [ 104, 101, 108, 108, 111 ]
         * });
         * ```
         */
        bytes(): Promise<Uint8Array>;
        /**
         * Creates and returns a new `Blob` containing a subset of this `Blob` objects
         * data. The original `Blob` is not altered.
         * @since v15.7.0, v14.18.0
         * @param start The starting index.
         * @param end The ending index.
         * @param type The content-type for the new `Blob`
         */
        slice(start?: number, end?: number, type?: string): Blob;
        /**
         * Returns a promise that fulfills with the contents of the `Blob` decoded as a
         * UTF-8 string.
         * @since v15.7.0, v14.18.0
         */
        text(): Promise<string>;
        /**
         * Returns a new `ReadableStream` that allows the content of the `Blob` to be read.
         * @since v16.7.0
         */
        stream(): WebReadableStream;
    }
    export interface FileOptions {
        /**
         * One of either `'transparent'` or `'native'`. When set to `'native'`, line endings in string source parts will be
         * converted to the platform native line-ending as specified by `require('node:os').EOL`.
         */
        endings?: "native" | "transparent";
        /** The File content-type. */
        type?: string;
        /** The last modified date of the file. `Default`: Date.now(). */
        lastModified?: number;
    }
    /**
     * A [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) provides information about files.
     * @since v19.2.0, v18.13.0
     */
    export class File extends Blob {
        constructor(sources: Array<BinaryLike | Blob>, fileName: string, options?: FileOptions);
        /**
         * The name of the `File`.
         * @since v19.2.0, v18.13.0
         */
        readonly name: string;
        /**
         * The last modified date of the `File`.
         * @since v19.2.0, v18.13.0
         */
        readonly lastModified: number;
    }
    export import atob = globalThis.atob;
    export import btoa = globalThis.btoa;

    global {
        namespace NodeJS {
            export { BufferEncoding };
        }
        // Buffer class
        type BufferEncoding =
            | "ascii"
            | "utf8"
            | "utf-8"
            | "utf16le"
            | "utf-16le"
            | "ucs2"
            | "ucs-2"
            | "base64"
            | "base64url"
            | "latin1"
            | "binary"
            | "hex";
        type WithImplicitCoercion<T> =
            | T
            | {
                valueOf(): T;
            };
        /**
         * Raw data is stored in instances of the Buffer class.
         * A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.
         * Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'base64url'|'binary'(deprecated)|'hex'
         */
        interface BufferConstructor {
            /**
             * Allocates a new buffer containing the given {str}.
             *
             * @param str String to store in buffer.
             * @param encoding encoding to use, optional.  Default is 'utf8'
             * @deprecated since v10.0.0 - Use `Buffer.from(string[, encoding])` instead.
             */
            new(str: string, encoding?: BufferEncoding): Buffer;
            /**
             * Allocates a new buffer of {size} octets.
             *
             * @param size count of octets to allocate.
             * @deprecated since v10.0.0 - Use `Buffer.alloc()` instead (also see `Buffer.allocUnsafe()`).
             */
            new(size: number): Buffer;
            /**
             * Allocates a new buffer containing the given {array} of octets.
             *
             * @param array The octets to store.
             * @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.
             */
            new(array: Uint8Array): Buffer;
            /**
             * Produces a Buffer backed by the same allocated memory as
             * the given {ArrayBuffer}/{SharedArrayBuffer}.
             *
             * @param arrayBuffer The ArrayBuffer with which to share memory.
             * @deprecated since v10.0.0 - Use `Buffer.from(arrayBuffer[, byteOffset[, length]])` instead.
             */
            new(arrayBuffer: ArrayBuffer | SharedArrayBuffer): Buffer;
            /**
             * Allocates a new buffer containing the given {array} of octets.
             *
             * @param array The octets to store.
             * @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.
             */
            new(array: readonly any[]): Buffer;
            /**
             * Copies the passed {buffer} data onto a new {Buffer} instance.
             *
             * @param buffer The buffer to copy.
             * @deprecated since v10.0.0 - Use `Buffer.from(buffer)` instead.
             */
            new(buffer: Buffer): Buffer;
            /**
             * Allocates a new `Buffer` using an `array` of bytes in the range `0` – `255`.
             * Array entries outside that range will be truncated to fit into it.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Creates a new Buffer containing the UTF-8 bytes of the string 'buffer'.
             * const buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);
             * ```
             *
             * If `array` is an `Array`\-like object (that is, one with a `length` property of
             * type `number`), it is treated as if it is an array, unless it is a `Buffer` or
             * a `Uint8Array`. This means all other `TypedArray` variants get treated as an `Array`. To create a `Buffer` from the bytes backing a `TypedArray`, use `Buffer.copyBytesFrom()`.
             *
             * A `TypeError` will be thrown if `array` is not an `Array` or another type
             * appropriate for `Buffer.from()` variants.
             *
             * `Buffer.from(array)` and `Buffer.from(string)` may also use the internal `Buffer` pool like `Buffer.allocUnsafe()` does.
             * @since v5.10.0
             */
            from(
                arrayBuffer: WithImplicitCoercion<ArrayBuffer | SharedArrayBuffer>,
                byteOffset?: number,
                length?: number,
            ): Buffer;
            /**
             * Creates a new Buffer using the passed {data}
             * @param data data to create a new Buffer
             */
            from(data: Uint8Array | readonly number[]): Buffer;
            from(data: WithImplicitCoercion<Uint8Array | readonly number[] | string>): Buffer;
            /**
             * Creates a new Buffer containing the given JavaScript string {str}.
             * If provided, the {encoding} parameter identifies the character encoding.
             * If not provided, {encoding} defaults to 'utf8'.
             */
            from(
                str:
                    | WithImplicitCoercion<string>
                    | {
                        [Symbol.toPrimitive](hint: "string"): string;
                    },
                encoding?: BufferEncoding,
            ): Buffer;
            /**
             * Creates a new Buffer using the passed {data}
             * @param values to create a new Buffer
             */
            of(...items: number[]): Buffer;
            /**
             * Returns `true` if `obj` is a `Buffer`, `false` otherwise.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * Buffer.isBuffer(Buffer.alloc(10)); // true
             * Buffer.isBuffer(Buffer.from('foo')); // true
             * Buffer.isBuffer('a string'); // false
             * Buffer.isBuffer([]); // false
             * Buffer.isBuffer(new Uint8Array(1024)); // false
             * ```
             * @since v0.1.101
             */
            isBuffer(obj: any): obj is Buffer;
            /**
             * Returns `true` if `encoding` is the name of a supported character encoding,
             * or `false` otherwise.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * console.log(Buffer.isEncoding('utf8'));
             * // Prints: true
             *
             * console.log(Buffer.isEncoding('hex'));
             * // Prints: true
             *
             * console.log(Buffer.isEncoding('utf/8'));
             * // Prints: false
             *
             * console.log(Buffer.isEncoding(''));
             * // Prints: false
             * ```
             * @since v0.9.1
             * @param encoding A character encoding name to check.
             */
            isEncoding(encoding: string): encoding is BufferEncoding;
            /**
             * Returns the byte length of a string when encoded using `encoding`.
             * This is not the same as [`String.prototype.length`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length), which does not account
             * for the encoding that is used to convert the string into bytes.
             *
             * For `'base64'`, `'base64url'`, and `'hex'`, this function assumes valid input.
             * For strings that contain non-base64/hex-encoded data (e.g. whitespace), the
             * return value might be greater than the length of a `Buffer` created from the
             * string.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const str = '\u00bd + \u00bc = \u00be';
             *
             * console.log(`${str}: ${str.length} characters, ` +
             *             `${Buffer.byteLength(str, 'utf8')} bytes`);
             * // Prints: ½ + ¼ = ¾: 9 characters, 12 bytes
             * ```
             *
             * When `string` is a
             * `Buffer`/[`DataView`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)/[`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/-
             * Reference/Global_Objects/TypedArray)/[`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)/[`SharedArrayBuffer`](https://develop-
             * er.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer), the byte length as reported by `.byteLength`is returned.
             * @since v0.1.90
             * @param string A value to calculate the length of.
             * @param [encoding='utf8'] If `string` is a string, this is its encoding.
             * @return The number of bytes contained within `string`.
             */
            byteLength(
                string: string | Buffer | NodeJS.ArrayBufferView | ArrayBuffer | SharedArrayBuffer,
                encoding?: BufferEncoding,
            ): number;
            /**
             * Returns a new `Buffer` which is the result of concatenating all the `Buffer` instances in the `list` together.
             *
             * If the list has no items, or if the `totalLength` is 0, then a new zero-length `Buffer` is returned.
             *
             * If `totalLength` is not provided, it is calculated from the `Buffer` instances
             * in `list` by adding their lengths.
             *
             * If `totalLength` is provided, it is coerced to an unsigned integer. If the
             * combined length of the `Buffer`s in `list` exceeds `totalLength`, the result is
             * truncated to `totalLength`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Create a single `Buffer` from a list of three `Buffer` instances.
             *
             * const buf1 = Buffer.alloc(10);
             * const buf2 = Buffer.alloc(14);
             * const buf3 = Buffer.alloc(18);
             * const totalLength = buf1.length + buf2.length + buf3.length;
             *
             * console.log(totalLength);
             * // Prints: 42
             *
             * const bufA = Buffer.concat([buf1, buf2, buf3], totalLength);
             *
             * console.log(bufA);
             * // Prints: <Buffer 00 00 00 00 ...>
             * console.log(bufA.length);
             * // Prints: 42
             * ```
             *
             * `Buffer.concat()` may also use the internal `Buffer` pool like `Buffer.allocUnsafe()` does.
             * @since v0.7.11
             * @param list List of `Buffer` or {@link Uint8Array} instances to concatenate.
             * @param totalLength Total length of the `Buffer` instances in `list` when concatenated.
             */
            concat(list: readonly Uint8Array[], totalLength?: number): Buffer;
            /**
             * Copies the underlying memory of `view` into a new `Buffer`.
             *
             * ```js
             * const u16 = new Uint16Array([0, 0xffff]);
             * const buf = Buffer.copyBytesFrom(u16, 1, 1);
             * u16[1] = 0;
             * console.log(buf.length); // 2
             * console.log(buf[0]); // 255
             * console.log(buf[1]); // 255
             * ```
             * @since v19.8.0
             * @param view The {TypedArray} to copy.
             * @param [offset=0] The starting offset within `view`.
             * @param [length=view.length - offset] The number of elements from `view` to copy.
             */
            copyBytesFrom(view: NodeJS.TypedArray, offset?: number, length?: number): Buffer;
            /**
             * Compares `buf1` to `buf2`, typically for the purpose of sorting arrays of `Buffer` instances. This is equivalent to calling `buf1.compare(buf2)`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.from('1234');
             * const buf2 = Buffer.from('0123');
             * const arr = [buf1, buf2];
             *
             * console.log(arr.sort(Buffer.compare));
             * // Prints: [ <Buffer 30 31 32 33>, <Buffer 31 32 33 34> ]
             * // (This result is equal to: [buf2, buf1].)
             * ```
             * @since v0.11.13
             * @return Either `-1`, `0`, or `1`, depending on the result of the comparison. See `compare` for details.
             */
            compare(buf1: Uint8Array, buf2: Uint8Array): -1 | 0 | 1;
            /**
             * Allocates a new `Buffer` of `size` bytes. If `fill` is `undefined`, the`Buffer` will be zero-filled.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.alloc(5);
             *
             * console.log(buf);
             * // Prints: <Buffer 00 00 00 00 00>
             * ```
             *
             * If `size` is larger than {@link constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown.
             *
             * If `fill` is specified, the allocated `Buffer` will be initialized by calling `buf.fill(fill)`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.alloc(5, 'a');
             *
             * console.log(buf);
             * // Prints: <Buffer 61 61 61 61 61>
             * ```
             *
             * If both `fill` and `encoding` are specified, the allocated `Buffer` will be
             * initialized by calling `buf.fill(fill, encoding)`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');
             *
             * console.log(buf);
             * // Prints: <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
             * ```
             *
             * Calling `Buffer.alloc()` can be measurably slower than the alternative `Buffer.allocUnsafe()` but ensures that the newly created `Buffer` instance
             * contents will never contain sensitive data from previous allocations, including
             * data that might not have been allocated for `Buffer`s.
             *
             * A `TypeError` will be thrown if `size` is not a number.
             * @since v5.10.0
             * @param size The desired length of the new `Buffer`.
             * @param [fill=0] A value to pre-fill the new `Buffer` with.
             * @param [encoding='utf8'] If `fill` is a string, this is its encoding.
             */
            alloc(size: number, fill?: string | Uint8Array | number, encoding?: BufferEncoding): Buffer;
            /**
             * Allocates a new `Buffer` of `size` bytes. If `size` is larger than {@link constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown.
             *
             * The underlying memory for `Buffer` instances created in this way is _not_
             * _initialized_. The contents of the newly created `Buffer` are unknown and _may contain sensitive data_. Use `Buffer.alloc()` instead to initialize`Buffer` instances with zeroes.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(10);
             *
             * console.log(buf);
             * // Prints (contents may vary): <Buffer a0 8b 28 3f 01 00 00 00 50 32>
             *
             * buf.fill(0);
             *
             * console.log(buf);
             * // Prints: <Buffer 00 00 00 00 00 00 00 00 00 00>
             * ```
             *
             * A `TypeError` will be thrown if `size` is not a number.
             *
             * The `Buffer` module pre-allocates an internal `Buffer` instance of
             * size `Buffer.poolSize` that is used as a pool for the fast allocation of new `Buffer` instances created using `Buffer.allocUnsafe()`, `Buffer.from(array)`,
             * and `Buffer.concat()` only when `size` is less than `Buffer.poolSize >>> 1` (floor of `Buffer.poolSize` divided by two).
             *
             * Use of this pre-allocated internal memory pool is a key difference between
             * calling `Buffer.alloc(size, fill)` vs. `Buffer.allocUnsafe(size).fill(fill)`.
             * Specifically, `Buffer.alloc(size, fill)` will _never_ use the internal `Buffer`pool, while `Buffer.allocUnsafe(size).fill(fill)`_will_ use the internal`Buffer` pool if `size` is less
             * than or equal to half `Buffer.poolSize`. The
             * difference is subtle but can be important when an application requires the
             * additional performance that `Buffer.allocUnsafe()` provides.
             * @since v5.10.0
             * @param size The desired length of the new `Buffer`.
             */
            allocUnsafe(size: number): Buffer;
            /**
             * Allocates a new `Buffer` of `size` bytes. If `size` is larger than {@link constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown. A zero-length `Buffer` is created if
             * `size` is 0.
             *
             * The underlying memory for `Buffer` instances created in this way is _not_
             * _initialized_. The contents of the newly created `Buffer` are unknown and _may contain sensitive data_. Use `buf.fill(0)` to initialize
             * such `Buffer` instances with zeroes.
             *
             * When using `Buffer.allocUnsafe()` to allocate new `Buffer` instances,
             * allocations under 4 KiB are sliced from a single pre-allocated `Buffer`. This
             * allows applications to avoid the garbage collection overhead of creating many
             * individually allocated `Buffer` instances. This approach improves both
             * performance and memory usage by eliminating the need to track and clean up as
             * many individual `ArrayBuffer` objects.
             *
             * However, in the case where a developer may need to retain a small chunk of
             * memory from a pool for an indeterminate amount of time, it may be appropriate
             * to create an un-pooled `Buffer` instance using `Buffer.allocUnsafeSlow()` and
             * then copying out the relevant bits.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Need to keep around a few small chunks of memory.
             * const store = [];
             *
             * socket.on('readable', () => {
             *   let data;
             *   while (null !== (data = readable.read())) {
             *     // Allocate for retained data.
             *     const sb = Buffer.allocUnsafeSlow(10);
             *
             *     // Copy the data into the new allocation.
             *     data.copy(sb, 0, 0, 10);
             *
             *     store.push(sb);
             *   }
             * });
             * ```
             *
             * A `TypeError` will be thrown if `size` is not a number.
             * @since v5.12.0
             * @param size The desired length of the new `Buffer`.
             */
            allocUnsafeSlow(size: number): Buffer;
            /**
             * This is the size (in bytes) of pre-allocated internal `Buffer` instances used
             * for pooling. This value may be modified.
             * @since v0.11.3
             */
            poolSize: number;
        }
        interface Buffer extends Uint8Array {
            /**
             * Writes `string` to `buf` at `offset` according to the character encoding in`encoding`. The `length` parameter is the number of bytes to write. If `buf` did
             * not contain enough space to fit the entire string, only part of `string` will be
             * written. However, partially encoded characters will not be written.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.alloc(256);
             *
             * const len = buf.write('\u00bd + \u00bc = \u00be', 0);
             *
             * console.log(`${len} bytes: ${buf.toString('utf8', 0, len)}`);
             * // Prints: 12 bytes: ½ + ¼ = ¾
             *
             * const buffer = Buffer.alloc(10);
             *
             * const length = buffer.write('abcd', 8);
             *
             * console.log(`${length} bytes: ${buffer.toString('utf8', 8, 10)}`);
             * // Prints: 2 bytes : ab
             * ```
             * @since v0.1.90
             * @param string String to write to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write `string`.
             * @param [length=buf.length - offset] Maximum number of bytes to write (written bytes will not exceed `buf.length - offset`).
             * @param [encoding='utf8'] The character encoding of `string`.
             * @return Number of bytes written.
             */
            write(string: string, encoding?: BufferEncoding): number;
            write(string: string, offset: number, encoding?: BufferEncoding): number;
            write(string: string, offset: number, length: number, encoding?: BufferEncoding): number;
            /**
             * Decodes `buf` to a string according to the specified character encoding in`encoding`. `start` and `end` may be passed to decode only a subset of `buf`.
             *
             * If `encoding` is `'utf8'` and a byte sequence in the input is not valid UTF-8,
             * then each invalid byte is replaced with the replacement character `U+FFFD`.
             *
             * The maximum length of a string instance (in UTF-16 code units) is available
             * as {@link constants.MAX_STRING_LENGTH}.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.allocUnsafe(26);
             *
             * for (let i = 0; i < 26; i++) {
             *   // 97 is the decimal ASCII value for 'a'.
             *   buf1[i] = i + 97;
             * }
             *
             * console.log(buf1.toString('utf8'));
             * // Prints: abcdefghijklmnopqrstuvwxyz
             * console.log(buf1.toString('utf8', 0, 5));
             * // Prints: abcde
             *
             * const buf2 = Buffer.from('tést');
             *
             * console.log(buf2.toString('hex'));
             * // Prints: 74c3a97374
             * console.log(buf2.toString('utf8', 0, 3));
             * // Prints: té
             * console.log(buf2.toString(undefined, 0, 3));
             * // Prints: té
             * ```
             * @since v0.1.90
             * @param [encoding='utf8'] The character encoding to use.
             * @param [start=0] The byte offset to start decoding at.
             * @param [end=buf.length] The byte offset to stop decoding at (not inclusive).
             */
            toString(encoding?: BufferEncoding, start?: number, end?: number): string;
            /**
             * Returns a JSON representation of `buf`. [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) implicitly calls
             * this function when stringifying a `Buffer` instance.
             *
             * `Buffer.from()` accepts objects in the format returned from this method.
             * In particular, `Buffer.from(buf.toJSON())` works like `Buffer.from(buf)`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);
             * const json = JSON.stringify(buf);
             *
             * console.log(json);
             * // Prints: {"type":"Buffer","data":[1,2,3,4,5]}
             *
             * const copy = JSON.parse(json, (key, value) => {
             *   return value &#x26;&#x26; value.type === 'Buffer' ?
             *     Buffer.from(value) :
             *     value;
             * });
             *
             * console.log(copy);
             * // Prints: <Buffer 01 02 03 04 05>
             * ```
             * @since v0.9.2
             */
            toJSON(): {
                type: "Buffer";
                data: number[];
            };
            /**
             * Returns `true` if both `buf` and `otherBuffer` have exactly the same bytes,`false` otherwise. Equivalent to `buf.compare(otherBuffer) === 0`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.from('ABC');
             * const buf2 = Buffer.from('414243', 'hex');
             * const buf3 = Buffer.from('ABCD');
             *
             * console.log(buf1.equals(buf2));
             * // Prints: true
             * console.log(buf1.equals(buf3));
             * // Prints: false
             * ```
             * @since v0.11.13
             * @param otherBuffer A `Buffer` or {@link Uint8Array} with which to compare `buf`.
             */
            equals(otherBuffer: Uint8Array): boolean;
            /**
             * Compares `buf` with `target` and returns a number indicating whether `buf`comes before, after, or is the same as `target` in sort order.
             * Comparison is based on the actual sequence of bytes in each `Buffer`.
             *
             * * `0` is returned if `target` is the same as `buf`
             * * `1` is returned if `target` should come _before_`buf` when sorted.
             * * `-1` is returned if `target` should come _after_`buf` when sorted.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.from('ABC');
             * const buf2 = Buffer.from('BCD');
             * const buf3 = Buffer.from('ABCD');
             *
             * console.log(buf1.compare(buf1));
             * // Prints: 0
             * console.log(buf1.compare(buf2));
             * // Prints: -1
             * console.log(buf1.compare(buf3));
             * // Prints: -1
             * console.log(buf2.compare(buf1));
             * // Prints: 1
             * console.log(buf2.compare(buf3));
             * // Prints: 1
             * console.log([buf1, buf2, buf3].sort(Buffer.compare));
             * // Prints: [ <Buffer 41 42 43>, <Buffer 41 42 43 44>, <Buffer 42 43 44> ]
             * // (This result is equal to: [buf1, buf3, buf2].)
             * ```
             *
             * The optional `targetStart`, `targetEnd`, `sourceStart`, and `sourceEnd` arguments can be used to limit the comparison to specific ranges within `target` and `buf` respectively.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);
             * const buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);
             *
             * console.log(buf1.compare(buf2, 5, 9, 0, 4));
             * // Prints: 0
             * console.log(buf1.compare(buf2, 0, 6, 4));
             * // Prints: -1
             * console.log(buf1.compare(buf2, 5, 6, 5));
             * // Prints: 1
             * ```
             *
             * `ERR_OUT_OF_RANGE` is thrown if `targetStart < 0`, `sourceStart < 0`, `targetEnd > target.byteLength`, or `sourceEnd > source.byteLength`.
             * @since v0.11.13
             * @param target A `Buffer` or {@link Uint8Array} with which to compare `buf`.
             * @param [targetStart=0] The offset within `target` at which to begin comparison.
             * @param [targetEnd=target.length] The offset within `target` at which to end comparison (not inclusive).
             * @param [sourceStart=0] The offset within `buf` at which to begin comparison.
             * @param [sourceEnd=buf.length] The offset within `buf` at which to end comparison (not inclusive).
             */
            compare(
                target: Uint8Array,
                targetStart?: number,
                targetEnd?: number,
                sourceStart?: number,
                sourceEnd?: number,
            ): -1 | 0 | 1;
            /**
             * Copies data from a region of `buf` to a region in `target`, even if the `target`memory region overlaps with `buf`.
             *
             * [`TypedArray.prototype.set()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set) performs the same operation, and is available
             * for all TypedArrays, including Node.js `Buffer`s, although it takes
             * different function arguments.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Create two `Buffer` instances.
             * const buf1 = Buffer.allocUnsafe(26);
             * const buf2 = Buffer.allocUnsafe(26).fill('!');
             *
             * for (let i = 0; i < 26; i++) {
             *   // 97 is the decimal ASCII value for 'a'.
             *   buf1[i] = i + 97;
             * }
             *
             * // Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`.
             * buf1.copy(buf2, 8, 16, 20);
             * // This is equivalent to:
             * // buf2.set(buf1.subarray(16, 20), 8);
             *
             * console.log(buf2.toString('ascii', 0, 25));
             * // Prints: !!!!!!!!qrst!!!!!!!!!!!!!
             * ```
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Create a `Buffer` and copy data from one region to an overlapping region
             * // within the same `Buffer`.
             *
             * const buf = Buffer.allocUnsafe(26);
             *
             * for (let i = 0; i < 26; i++) {
             *   // 97 is the decimal ASCII value for 'a'.
             *   buf[i] = i + 97;
             * }
             *
             * buf.copy(buf, 0, 4, 10);
             *
             * console.log(buf.toString());
             * // Prints: efghijghijklmnopqrstuvwxyz
             * ```
             * @since v0.1.90
             * @param target A `Buffer` or {@link Uint8Array} to copy into.
             * @param [targetStart=0] The offset within `target` at which to begin writing.
             * @param [sourceStart=0] The offset within `buf` from which to begin copying.
             * @param [sourceEnd=buf.length] The offset within `buf` at which to stop copying (not inclusive).
             * @return The number of bytes copied.
             */
            copy(target: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
            /**
             * Returns a new `Buffer` that references the same memory as the original, but
             * offset and cropped by the `start` and `end` indices.
             *
             * This method is not compatible with the `Uint8Array.prototype.slice()`,
             * which is a superclass of `Buffer`. To copy the slice, use`Uint8Array.prototype.slice()`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from('buffer');
             *
             * const copiedBuf = Uint8Array.prototype.slice.call(buf);
             * copiedBuf[0]++;
             * console.log(copiedBuf.toString());
             * // Prints: cuffer
             *
             * console.log(buf.toString());
             * // Prints: buffer
             *
             * // With buf.slice(), the original buffer is modified.
             * const notReallyCopiedBuf = buf.slice();
             * notReallyCopiedBuf[0]++;
             * console.log(notReallyCopiedBuf.toString());
             * // Prints: cuffer
             * console.log(buf.toString());
             * // Also prints: cuffer (!)
             * ```
             * @since v0.3.0
             * @deprecated Use `subarray` instead.
             * @param [start=0] Where the new `Buffer` will start.
             * @param [end=buf.length] Where the new `Buffer` will end (not inclusive).
             */
            slice(start?: number, end?: number): Buffer;
            /**
             * Returns a new `Buffer` that references the same memory as the original, but
             * offset and cropped by the `start` and `end` indices.
             *
             * Specifying `end` greater than `buf.length` will return the same result as
             * that of `end` equal to `buf.length`.
             *
             * This method is inherited from [`TypedArray.prototype.subarray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray).
             *
             * Modifying the new `Buffer` slice will modify the memory in the original `Buffer`because the allocated memory of the two objects overlap.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte
             * // from the original `Buffer`.
             *
             * const buf1 = Buffer.allocUnsafe(26);
             *
             * for (let i = 0; i < 26; i++) {
             *   // 97 is the decimal ASCII value for 'a'.
             *   buf1[i] = i + 97;
             * }
             *
             * const buf2 = buf1.subarray(0, 3);
             *
             * console.log(buf2.toString('ascii', 0, buf2.length));
             * // Prints: abc
             *
             * buf1[0] = 33;
             *
             * console.log(buf2.toString('ascii', 0, buf2.length));
             * // Prints: !bc
             * ```
             *
             * Specifying negative indexes causes the slice to be generated relative to the
             * end of `buf` rather than the beginning.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from('buffer');
             *
             * console.log(buf.subarray(-6, -1).toString());
             * // Prints: buffe
             * // (Equivalent to buf.subarray(0, 5).)
             *
             * console.log(buf.subarray(-6, -2).toString());
             * // Prints: buff
             * // (Equivalent to buf.subarray(0, 4).)
             *
             * console.log(buf.subarray(-5, -2).toString());
             * // Prints: uff
             * // (Equivalent to buf.subarray(1, 4).)
             * ```
             * @since v3.0.0
             * @param [start=0] Where the new `Buffer` will start.
             * @param [end=buf.length] Where the new `Buffer` will end (not inclusive).
             */
            subarray(start?: number, end?: number): Buffer;
            /**
             * Writes `value` to `buf` at the specified `offset` as big-endian.
             *
             * `value` is interpreted and written as a two's complement signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeBigInt64BE(0x0102030405060708n, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer 01 02 03 04 05 06 07 08>
             * ```
             * @since v12.0.0, v10.20.0
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`.
             * @return `offset` plus the number of bytes written.
             */
            writeBigInt64BE(value: bigint, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as little-endian.
             *
             * `value` is interpreted and written as a two's complement signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeBigInt64LE(0x0102030405060708n, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer 08 07 06 05 04 03 02 01>
             * ```
             * @since v12.0.0, v10.20.0
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`.
             * @return `offset` plus the number of bytes written.
             */
            writeBigInt64LE(value: bigint, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as big-endian.
             *
             * This function is also available under the `writeBigUint64BE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeBigUInt64BE(0xdecafafecacefaden, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer de ca fa fe ca ce fa de>
             * ```
             * @since v12.0.0, v10.20.0
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`.
             * @return `offset` plus the number of bytes written.
             */
            writeBigUInt64BE(value: bigint, offset?: number): number;
            /**
             * @alias Buffer.writeBigUInt64BE
             * @since v14.10.0, v12.19.0
             */
            writeBigUint64BE(value: bigint, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as little-endian
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeBigUInt64LE(0xdecafafecacefaden, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer de fa ce ca fe fa ca de>
             * ```
             *
             * This function is also available under the `writeBigUint64LE` alias.
             * @since v12.0.0, v10.20.0
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`.
             * @return `offset` plus the number of bytes written.
             */
            writeBigUInt64LE(value: bigint, offset?: number): number;
            /**
             * @alias Buffer.writeBigUInt64LE
             * @since v14.10.0, v12.19.0
             */
            writeBigUint64LE(value: bigint, offset?: number): number;
            /**
             * Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined
             * when `value` is anything other than an unsigned integer.
             *
             * This function is also available under the `writeUintLE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(6);
             *
             * buf.writeUIntLE(0x1234567890ab, 0, 6);
             *
             * console.log(buf);
             * // Prints: <Buffer ab 90 78 56 34 12>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param offset Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to write. Must satisfy `0 < byteLength <= 6`.
             * @return `offset` plus the number of bytes written.
             */
            writeUIntLE(value: number, offset: number, byteLength: number): number;
            /**
             * @alias Buffer.writeUIntLE
             * @since v14.9.0, v12.19.0
             */
            writeUintLE(value: number, offset: number, byteLength: number): number;
            /**
             * Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined
             * when `value` is anything other than an unsigned integer.
             *
             * This function is also available under the `writeUintBE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(6);
             *
             * buf.writeUIntBE(0x1234567890ab, 0, 6);
             *
             * console.log(buf);
             * // Prints: <Buffer 12 34 56 78 90 ab>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param offset Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to write. Must satisfy `0 < byteLength <= 6`.
             * @return `offset` plus the number of bytes written.
             */
            writeUIntBE(value: number, offset: number, byteLength: number): number;
            /**
             * @alias Buffer.writeUIntBE
             * @since v14.9.0, v12.19.0
             */
            writeUintBE(value: number, offset: number, byteLength: number): number;
            /**
             * Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined
             * when `value` is anything other than a signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(6);
             *
             * buf.writeIntLE(0x1234567890ab, 0, 6);
             *
             * console.log(buf);
             * // Prints: <Buffer ab 90 78 56 34 12>
             * ```
             * @since v0.11.15
             * @param value Number to be written to `buf`.
             * @param offset Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to write. Must satisfy `0 < byteLength <= 6`.
             * @return `offset` plus the number of bytes written.
             */
            writeIntLE(value: number, offset: number, byteLength: number): number;
            /**
             * Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined when`value` is anything other than a
             * signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(6);
             *
             * buf.writeIntBE(0x1234567890ab, 0, 6);
             *
             * console.log(buf);
             * // Prints: <Buffer 12 34 56 78 90 ab>
             * ```
             * @since v0.11.15
             * @param value Number to be written to `buf`.
             * @param offset Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to write. Must satisfy `0 < byteLength <= 6`.
             * @return `offset` plus the number of bytes written.
             */
            writeIntBE(value: number, offset: number, byteLength: number): number;
            /**
             * Reads an unsigned, big-endian 64-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readBigUint64BE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);
             *
             * console.log(buf.readBigUInt64BE(0));
             * // Prints: 4294967295n
             * ```
             * @since v12.0.0, v10.20.0
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`.
             */
            readBigUInt64BE(offset?: number): bigint;
            /**
             * @alias Buffer.readBigUInt64BE
             * @since v14.10.0, v12.19.0
             */
            readBigUint64BE(offset?: number): bigint;
            /**
             * Reads an unsigned, little-endian 64-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readBigUint64LE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);
             *
             * console.log(buf.readBigUInt64LE(0));
             * // Prints: 18446744069414584320n
             * ```
             * @since v12.0.0, v10.20.0
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`.
             */
            readBigUInt64LE(offset?: number): bigint;
            /**
             * @alias Buffer.readBigUInt64LE
             * @since v14.10.0, v12.19.0
             */
            readBigUint64LE(offset?: number): bigint;
            /**
             * Reads a signed, big-endian 64-bit integer from `buf` at the specified `offset`.
             *
             * Integers read from a `Buffer` are interpreted as two's complement signed
             * values.
             * @since v12.0.0, v10.20.0
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`.
             */
            readBigInt64BE(offset?: number): bigint;
            /**
             * Reads a signed, little-endian 64-bit integer from `buf` at the specified`offset`.
             *
             * Integers read from a `Buffer` are interpreted as two's complement signed
             * values.
             * @since v12.0.0, v10.20.0
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`.
             */
            readBigInt64LE(offset?: number): bigint;
            /**
             * Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as an unsigned, little-endian integer supporting
             * up to 48 bits of accuracy.
             *
             * This function is also available under the `readUintLE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);
             *
             * console.log(buf.readUIntLE(0, 6).toString(16));
             * // Prints: ab9078563412
             * ```
             * @since v0.11.15
             * @param offset Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to read. Must satisfy `0 < byteLength <= 6`.
             */
            readUIntLE(offset: number, byteLength: number): number;
            /**
             * @alias Buffer.readUIntLE
             * @since v14.9.0, v12.19.0
             */
            readUintLE(offset: number, byteLength: number): number;
            /**
             * Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as an unsigned big-endian integer supporting
             * up to 48 bits of accuracy.
             *
             * This function is also available under the `readUintBE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);
             *
             * console.log(buf.readUIntBE(0, 6).toString(16));
             * // Prints: 1234567890ab
             * console.log(buf.readUIntBE(1, 6).toString(16));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.11.15
             * @param offset Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to read. Must satisfy `0 < byteLength <= 6`.
             */
            readUIntBE(offset: number, byteLength: number): number;
            /**
             * @alias Buffer.readUIntBE
             * @since v14.9.0, v12.19.0
             */
            readUintBE(offset: number, byteLength: number): number;
            /**
             * Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as a little-endian, two's complement signed value
             * supporting up to 48 bits of accuracy.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);
             *
             * console.log(buf.readIntLE(0, 6).toString(16));
             * // Prints: -546f87a9cbee
             * ```
             * @since v0.11.15
             * @param offset Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to read. Must satisfy `0 < byteLength <= 6`.
             */
            readIntLE(offset: number, byteLength: number): number;
            /**
             * Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as a big-endian, two's complement signed value
             * supporting up to 48 bits of accuracy.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);
             *
             * console.log(buf.readIntBE(0, 6).toString(16));
             * // Prints: 1234567890ab
             * console.log(buf.readIntBE(1, 6).toString(16));
             * // Throws ERR_OUT_OF_RANGE.
             * console.log(buf.readIntBE(1, 0).toString(16));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.11.15
             * @param offset Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to read. Must satisfy `0 < byteLength <= 6`.
             */
            readIntBE(offset: number, byteLength: number): number;
            /**
             * Reads an unsigned 8-bit integer from `buf` at the specified `offset`.
             *
             * This function is also available under the `readUint8` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([1, -2]);
             *
             * console.log(buf.readUInt8(0));
             * // Prints: 1
             * console.log(buf.readUInt8(1));
             * // Prints: 254
             * console.log(buf.readUInt8(2));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.5.0
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`.
             */
            readUInt8(offset?: number): number;
            /**
             * @alias Buffer.readUInt8
             * @since v14.9.0, v12.19.0
             */
            readUint8(offset?: number): number;
            /**
             * Reads an unsigned, little-endian 16-bit integer from `buf` at the specified `offset`.
             *
             * This function is also available under the `readUint16LE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56]);
             *
             * console.log(buf.readUInt16LE(0).toString(16));
             * // Prints: 3412
             * console.log(buf.readUInt16LE(1).toString(16));
             * // Prints: 5634
             * console.log(buf.readUInt16LE(2).toString(16));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.5.5
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`.
             */
            readUInt16LE(offset?: number): number;
            /**
             * @alias Buffer.readUInt16LE
             * @since v14.9.0, v12.19.0
             */
            readUint16LE(offset?: number): number;
            /**
             * Reads an unsigned, big-endian 16-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readUint16BE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56]);
             *
             * console.log(buf.readUInt16BE(0).toString(16));
             * // Prints: 1234
             * console.log(buf.readUInt16BE(1).toString(16));
             * // Prints: 3456
             * ```
             * @since v0.5.5
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`.
             */
            readUInt16BE(offset?: number): number;
            /**
             * @alias Buffer.readUInt16BE
             * @since v14.9.0, v12.19.0
             */
            readUint16BE(offset?: number): number;
            /**
             * Reads an unsigned, little-endian 32-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readUint32LE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);
             *
             * console.log(buf.readUInt32LE(0).toString(16));
             * // Prints: 78563412
             * console.log(buf.readUInt32LE(1).toString(16));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.5.5
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.
             */
            readUInt32LE(offset?: number): number;
            /**
             * @alias Buffer.readUInt32LE
             * @since v14.9.0, v12.19.0
             */
            readUint32LE(offset?: number): number;
            /**
             * Reads an unsigned, big-endian 32-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readUint32BE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);
             *
             * console.log(buf.readUInt32BE(0).toString(16));
             * // Prints: 12345678
             * ```
             * @since v0.5.5
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.
             */
            readUInt32BE(offset?: number): number;
            /**
             * @alias Buffer.readUInt32BE
             * @since v14.9.0, v12.19.0
             */
            readUint32BE(offset?: number): number;
            /**
             * Reads a signed 8-bit integer from `buf` at the specified `offset`.
             *
             * Integers read from a `Buffer` are interpreted as two's complement signed values.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([-1, 5]);
             *
             * console.log(buf.readInt8(0));
             * // Prints: -1
             * console.log(buf.readInt8(1));
             * // Prints: 5
             * console.log(buf.readInt8(2));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.5.0
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`.
             */
            readInt8(offset?: number): number;
            /**
             * Reads a signed, little-endian 16-bit integer from `buf` at the specified`offset`.
             *
             * Integers read from a `Buffer` are interpreted as two's complement signed values.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0, 5]);
             *
             * console.log(buf.readInt16LE(0));
             * // Prints: 1280
             * console.log(buf.readInt16LE(1));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.5.5
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`.
             */
            readInt16LE(offset?: number): number;
            /**
             * Reads a signed, big-endian 16-bit integer from `buf` at the specified `offset`.
             *
             * Integers read from a `Buffer` are interpreted as two's complement signed values.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0, 5]);
             *
             * console.log(buf.readInt16BE(0));
             * // Prints: 5
             * ```
             * @since v0.5.5
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`.
             */
            readInt16BE(offset?: number): number;
            /**
             * Reads a signed, little-endian 32-bit integer from `buf` at the specified`offset`.
             *
             * Integers read from a `Buffer` are interpreted as two's complement signed values.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0, 0, 0, 5]);
             *
             * console.log(buf.readInt32LE(0));
             * // Prints: 83886080
             * console.log(buf.readInt32LE(1));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.5.5
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.
             */
            readInt32LE(offset?: number): number;
            /**
             * Reads a signed, big-endian 32-bit integer from `buf` at the specified `offset`.
             *
             * Integers read from a `Buffer` are interpreted as two's complement signed values.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0, 0, 0, 5]);
             *
             * console.log(buf.readInt32BE(0));
             * // Prints: 5
             * ```
             * @since v0.5.5
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.
             */
            readInt32BE(offset?: number): number;
            /**
             * Reads a 32-bit, little-endian float from `buf` at the specified `offset`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([1, 2, 3, 4]);
             *
             * console.log(buf.readFloatLE(0));
             * // Prints: 1.539989614439558e-36
             * console.log(buf.readFloatLE(1));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.11.15
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.
             */
            readFloatLE(offset?: number): number;
            /**
             * Reads a 32-bit, big-endian float from `buf` at the specified `offset`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([1, 2, 3, 4]);
             *
             * console.log(buf.readFloatBE(0));
             * // Prints: 2.387939260590663e-38
             * ```
             * @since v0.11.15
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.
             */
            readFloatBE(offset?: number): number;
            /**
             * Reads a 64-bit, little-endian double from `buf` at the specified `offset`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);
             *
             * console.log(buf.readDoubleLE(0));
             * // Prints: 5.447603722011605e-270
             * console.log(buf.readDoubleLE(1));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.11.15
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`.
             */
            readDoubleLE(offset?: number): number;
            /**
             * Reads a 64-bit, big-endian double from `buf` at the specified `offset`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);
             *
             * console.log(buf.readDoubleBE(0));
             * // Prints: 8.20788039913184e-304
             * ```
             * @since v0.11.15
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`.
             */
            readDoubleBE(offset?: number): number;
            reverse(): this;
            /**
             * Interprets `buf` as an array of unsigned 16-bit integers and swaps the
             * byte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 2.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);
             *
             * console.log(buf1);
             * // Prints: <Buffer 01 02 03 04 05 06 07 08>
             *
             * buf1.swap16();
             *
             * console.log(buf1);
             * // Prints: <Buffer 02 01 04 03 06 05 08 07>
             *
             * const buf2 = Buffer.from([0x1, 0x2, 0x3]);
             *
             * buf2.swap16();
             * // Throws ERR_INVALID_BUFFER_SIZE.
             * ```
             *
             * One convenient use of `buf.swap16()` is to perform a fast in-place conversion
             * between UTF-16 little-endian and UTF-16 big-endian:
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from('This is little-endian UTF-16', 'utf16le');
             * buf.swap16(); // Convert to big-endian UTF-16 text.
             * ```
             * @since v5.10.0
             * @return A reference to `buf`.
             */
            swap16(): Buffer;
            /**
             * Interprets `buf` as an array of unsigned 32-bit integers and swaps the
             * byte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 4.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);
             *
             * console.log(buf1);
             * // Prints: <Buffer 01 02 03 04 05 06 07 08>
             *
             * buf1.swap32();
             *
             * console.log(buf1);
             * // Prints: <Buffer 04 03 02 01 08 07 06 05>
             *
             * const buf2 = Buffer.from([0x1, 0x2, 0x3]);
             *
             * buf2.swap32();
             * // Throws ERR_INVALID_BUFFER_SIZE.
             * ```
             * @since v5.10.0
             * @return A reference to `buf`.
             */
            swap32(): Buffer;
            /**
             * Interprets `buf` as an array of 64-bit numbers and swaps byte order _in-place_.
             * Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 8.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);
             *
             * console.log(buf1);
             * // Prints: <Buffer 01 02 03 04 05 06 07 08>
             *
             * buf1.swap64();
             *
             * console.log(buf1);
             * // Prints: <Buffer 08 07 06 05 04 03 02 01>
             *
             * const buf2 = Buffer.from([0x1, 0x2, 0x3]);
             *
             * buf2.swap64();
             * // Throws ERR_INVALID_BUFFER_SIZE.
             * ```
             * @since v6.3.0
             * @return A reference to `buf`.
             */
            swap64(): Buffer;
            /**
             * Writes `value` to `buf` at the specified `offset`. `value` must be a
             * valid unsigned 8-bit integer. Behavior is undefined when `value` is anything
             * other than an unsigned 8-bit integer.
             *
             * This function is also available under the `writeUint8` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeUInt8(0x3, 0);
             * buf.writeUInt8(0x4, 1);
             * buf.writeUInt8(0x23, 2);
             * buf.writeUInt8(0x42, 3);
             *
             * console.log(buf);
             * // Prints: <Buffer 03 04 23 42>
             * ```
             * @since v0.5.0
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`.
             * @return `offset` plus the number of bytes written.
             */
            writeUInt8(value: number, offset?: number): number;
            /**
             * @alias Buffer.writeUInt8
             * @since v14.9.0, v12.19.0
             */
            writeUint8(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid unsigned 16-bit integer. Behavior is undefined when `value` is
             * anything other than an unsigned 16-bit integer.
             *
             * This function is also available under the `writeUint16LE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeUInt16LE(0xdead, 0);
             * buf.writeUInt16LE(0xbeef, 2);
             *
             * console.log(buf);
             * // Prints: <Buffer ad de ef be>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`.
             * @return `offset` plus the number of bytes written.
             */
            writeUInt16LE(value: number, offset?: number): number;
            /**
             * @alias Buffer.writeUInt16LE
             * @since v14.9.0, v12.19.0
             */
            writeUint16LE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid unsigned 16-bit integer. Behavior is undefined when `value`is anything other than an
             * unsigned 16-bit integer.
             *
             * This function is also available under the `writeUint16BE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeUInt16BE(0xdead, 0);
             * buf.writeUInt16BE(0xbeef, 2);
             *
             * console.log(buf);
             * // Prints: <Buffer de ad be ef>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`.
             * @return `offset` plus the number of bytes written.
             */
            writeUInt16BE(value: number, offset?: number): number;
            /**
             * @alias Buffer.writeUInt16BE
             * @since v14.9.0, v12.19.0
             */
            writeUint16BE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid unsigned 32-bit integer. Behavior is undefined when `value` is
             * anything other than an unsigned 32-bit integer.
             *
             * This function is also available under the `writeUint32LE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeUInt32LE(0xfeedface, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer ce fa ed fe>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.
             * @return `offset` plus the number of bytes written.
             */
            writeUInt32LE(value: number, offset?: number): number;
            /**
             * @alias Buffer.writeUInt32LE
             * @since v14.9.0, v12.19.0
             */
            writeUint32LE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid unsigned 32-bit integer. Behavior is undefined when `value`is anything other than an
             * unsigned 32-bit integer.
             *
             * This function is also available under the `writeUint32BE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeUInt32BE(0xfeedface, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer fe ed fa ce>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.
             * @return `offset` plus the number of bytes written.
             */
            writeUInt32BE(value: number, offset?: number): number;
            /**
             * @alias Buffer.writeUInt32BE
             * @since v14.9.0, v12.19.0
             */
            writeUint32BE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset`. `value` must be a valid
             * signed 8-bit integer. Behavior is undefined when `value` is anything other than
             * a signed 8-bit integer.
             *
             * `value` is interpreted and written as a two's complement signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(2);
             *
             * buf.writeInt8(2, 0);
             * buf.writeInt8(-2, 1);
             *
             * console.log(buf);
             * // Prints: <Buffer 02 fe>
             * ```
             * @since v0.5.0
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`.
             * @return `offset` plus the number of bytes written.
             */
            writeInt8(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as little-endian.  The `value` must be a valid signed 16-bit integer. Behavior is undefined when `value` is
             * anything other than a signed 16-bit integer.
             *
             * The `value` is interpreted and written as a two's complement signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(2);
             *
             * buf.writeInt16LE(0x0304, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer 04 03>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`.
             * @return `offset` plus the number of bytes written.
             */
            writeInt16LE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as big-endian.  The `value` must be a valid signed 16-bit integer. Behavior is undefined when `value` is
             * anything other than a signed 16-bit integer.
             *
             * The `value` is interpreted and written as a two's complement signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(2);
             *
             * buf.writeInt16BE(0x0102, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer 01 02>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`.
             * @return `offset` plus the number of bytes written.
             */
            writeInt16BE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid signed 32-bit integer. Behavior is undefined when `value` is
             * anything other than a signed 32-bit integer.
             *
             * The `value` is interpreted and written as a two's complement signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeInt32LE(0x05060708, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer 08 07 06 05>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.
             * @return `offset` plus the number of bytes written.
             */
            writeInt32LE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid signed 32-bit integer. Behavior is undefined when `value` is
             * anything other than a signed 32-bit integer.
             *
             * The `value` is interpreted and written as a two's complement signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeInt32BE(0x01020304, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer 01 02 03 04>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.
             * @return `offset` plus the number of bytes written.
             */
            writeInt32BE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as little-endian. Behavior is
             * undefined when `value` is anything other than a JavaScript number.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeFloatLE(0xcafebabe, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer bb fe 4a 4f>
             * ```
             * @since v0.11.15
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.
             * @return `offset` plus the number of bytes written.
             */
            writeFloatLE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as big-endian. Behavior is
             * undefined when `value` is anything other than a JavaScript number.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeFloatBE(0xcafebabe, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer 4f 4a fe bb>
             * ```
             * @since v0.11.15
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.
             * @return `offset` plus the number of bytes written.
             */
            writeFloatBE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a JavaScript number. Behavior is undefined when `value` is anything
             * other than a JavaScript number.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeDoubleLE(123.456, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer 77 be 9f 1a 2f dd 5e 40>
             * ```
             * @since v0.11.15
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`.
             * @return `offset` plus the number of bytes written.
             */
            writeDoubleLE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a JavaScript number. Behavior is undefined when `value` is anything
             * other than a JavaScript number.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeDoubleBE(123.456, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer 40 5e dd 2f 1a 9f be 77>
             * ```
             * @since v0.11.15
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`.
             * @return `offset` plus the number of bytes written.
             */
            writeDoubleBE(value: number, offset?: number): number;
            /**
             * Fills `buf` with the specified `value`. If the `offset` and `end` are not given,
             * the entire `buf` will be filled:
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Fill a `Buffer` with the ASCII character 'h'.
             *
             * const b = Buffer.allocUnsafe(50).fill('h');
             *
             * console.log(b.toString());
             * // Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
             *
             * // Fill a buffer with empty string
             * const c = Buffer.allocUnsafe(5).fill('');
             *
             * console.log(c.fill(''));
             * // Prints: <Buffer 00 00 00 00 00>
             * ```
             *
             * `value` is coerced to a `uint32` value if it is not a string, `Buffer`, or
             * integer. If the resulting integer is greater than `255` (decimal), `buf` will be
             * filled with `value &#x26; 255`.
             *
             * If the final write of a `fill()` operation falls on a multi-byte character,
             * then only the bytes of that character that fit into `buf` are written:
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Fill a `Buffer` with character that takes up two bytes in UTF-8.
             *
             * console.log(Buffer.allocUnsafe(5).fill('\u0222'));
             * // Prints: <Buffer c8 a2 c8 a2 c8>
             * ```
             *
             * If `value` contains invalid characters, it is truncated; if no valid
             * fill data remains, an exception is thrown:
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(5);
             *
             * console.log(buf.fill('a'));
             * // Prints: <Buffer 61 61 61 61 61>
             * console.log(buf.fill('aazz', 'hex'));
             * // Prints: <Buffer aa aa aa aa aa>
             * console.log(buf.fill('zz', 'hex'));
             * // Throws an exception.
             * ```
             * @since v0.5.0
             * @param value The value with which to fill `buf`. Empty value (string, Uint8Array, Buffer) is coerced to `0`.
             * @param [offset=0] Number of bytes to skip before starting to fill `buf`.
             * @param [end=buf.length] Where to stop filling `buf` (not inclusive).
             * @param [encoding='utf8'] The encoding for `value` if `value` is a string.
             * @return A reference to `buf`.
             */
            fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;
            /**
             * If `value` is:
             *
             * * a string, `value` is interpreted according to the character encoding in `encoding`.
             * * a `Buffer` or [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array), `value` will be used in its entirety.
             * To compare a partial `Buffer`, use `buf.subarray`.
             * * a number, `value` will be interpreted as an unsigned 8-bit integer
             * value between `0` and `255`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from('this is a buffer');
             *
             * console.log(buf.indexOf('this'));
             * // Prints: 0
             * console.log(buf.indexOf('is'));
             * // Prints: 2
             * console.log(buf.indexOf(Buffer.from('a buffer')));
             * // Prints: 8
             * console.log(buf.indexOf(97));
             * // Prints: 8 (97 is the decimal ASCII value for 'a')
             * console.log(buf.indexOf(Buffer.from('a buffer example')));
             * // Prints: -1
             * console.log(buf.indexOf(Buffer.from('a buffer example').slice(0, 8)));
             * // Prints: 8
             *
             * const utf16Buffer = Buffer.from('\u039a\u0391\u03a3\u03a3\u0395', 'utf16le');
             *
             * console.log(utf16Buffer.indexOf('\u03a3', 0, 'utf16le'));
             * // Prints: 4
             * console.log(utf16Buffer.indexOf('\u03a3', -4, 'utf16le'));
             * // Prints: 6
             * ```
             *
             * If `value` is not a string, number, or `Buffer`, this method will throw a `TypeError`. If `value` is a number, it will be coerced to a valid byte value,
             * an integer between 0 and 255.
             *
             * If `byteOffset` is not a number, it will be coerced to a number. If the result
             * of coercion is `NaN` or `0`, then the entire buffer will be searched. This
             * behavior matches [`String.prototype.indexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf).
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const b = Buffer.from('abcdef');
             *
             * // Passing a value that's a number, but not a valid byte.
             * // Prints: 2, equivalent to searching for 99 or 'c'.
             * console.log(b.indexOf(99.9));
             * console.log(b.indexOf(256 + 99));
             *
             * // Passing a byteOffset that coerces to NaN or 0.
             * // Prints: 1, searching the whole buffer.
             * console.log(b.indexOf('b', undefined));
             * console.log(b.indexOf('b', {}));
             * console.log(b.indexOf('b', null));
             * console.log(b.indexOf('b', []));
             * ```
             *
             * If `value` is an empty string or empty `Buffer` and `byteOffset` is less
             * than `buf.length`, `byteOffset` will be returned. If `value` is empty and`byteOffset` is at least `buf.length`, `buf.length` will be returned.
             * @since v1.5.0
             * @param value What to search for.
             * @param [byteOffset=0] Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`.
             * @param [encoding='utf8'] If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`.
             * @return The index of the first occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`.
             */
            indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
            /**
             * Identical to `buf.indexOf()`, except the last occurrence of `value` is found
             * rather than the first occurrence.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from('this buffer is a buffer');
             *
             * console.log(buf.lastIndexOf('this'));
             * // Prints: 0
             * console.log(buf.lastIndexOf('buffer'));
             * // Prints: 17
             * console.log(buf.lastIndexOf(Buffer.from('buffer')));
             * // Prints: 17
             * console.log(buf.lastIndexOf(97));
             * // Prints: 15 (97 is the decimal ASCII value for 'a')
             * console.log(buf.lastIndexOf(Buffer.from('yolo')));
             * // Prints: -1
             * console.log(buf.lastIndexOf('buffer', 5));
             * // Prints: 5
             * console.log(buf.lastIndexOf('buffer', 4));
             * // Prints: -1
             *
             * const utf16Buffer = Buffer.from('\u039a\u0391\u03a3\u03a3\u0395', 'utf16le');
             *
             * console.log(utf16Buffer.lastIndexOf('\u03a3', undefined, 'utf16le'));
             * // Prints: 6
             * console.log(utf16Buffer.lastIndexOf('\u03a3', -5, 'utf16le'));
             * // Prints: 4
             * ```
             *
             * If `value` is not a string, number, or `Buffer`, this method will throw a `TypeError`. If `value` is a number, it will be coerced to a valid byte value,
             * an integer between 0 and 255.
             *
             * If `byteOffset` is not a number, it will be coerced to a number. Any arguments
             * that coerce to `NaN`, like `{}` or `undefined`, will search the whole buffer.
             * This behavior matches [`String.prototype.lastIndexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf).
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const b = Buffer.from('abcdef');
             *
             * // Passing a value that's a number, but not a valid byte.
             * // Prints: 2, equivalent to searching for 99 or 'c'.
             * console.log(b.lastIndexOf(99.9));
             * console.log(b.lastIndexOf(256 + 99));
             *
             * // Passing a byteOffset that coerces to NaN.
             * // Prints: 1, searching the whole buffer.
             * console.log(b.lastIndexOf('b', undefined));
             * console.log(b.lastIndexOf('b', {}));
             *
             * // Passing a byteOffset that coerces to 0.
             * // Prints: -1, equivalent to passing 0.
             * console.log(b.lastIndexOf('b', null));
             * console.log(b.lastIndexOf('b', []));
             * ```
             *
             * If `value` is an empty string or empty `Buffer`, `byteOffset` will be returned.
             * @since v6.0.0
             * @param value What to search for.
             * @param [byteOffset=buf.length - 1] Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`.
             * @param [encoding='utf8'] If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`.
             * @return The index of the last occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`.
             */
            lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
            /**
             * Equivalent to `buf.indexOf() !== -1`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from('this is a buffer');
             *
             * console.log(buf.includes('this'));
             * // Prints: true
             * console.log(buf.includes('is'));
             * // Prints: true
             * console.log(buf.includes(Buffer.from('a buffer')));
             * // Prints: true
             * console.log(buf.includes(97));
             * // Prints: true (97 is the decimal ASCII value for 'a')
             * console.log(buf.includes(Buffer.from('a buffer example')));
             * // Prints: false
             * console.log(buf.includes(Buffer.from('a buffer example').slice(0, 8)));
             * // Prints: true
             * console.log(buf.includes('this', 4));
             * // Prints: false
             * ```
             * @since v5.3.0
             * @param value What to search for.
             * @param [byteOffset=0] Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`.
             * @param [encoding='utf8'] If `value` is a string, this is its encoding.
             * @return `true` if `value` was found in `buf`, `false` otherwise.
             */
            includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;
        }
        var Buffer: BufferConstructor;
        /**
         * Decodes a string of Base64-encoded data into bytes, and encodes those bytes
         * into a string using Latin-1 (ISO-8859-1).
         *
         * The `data` may be any JavaScript-value that can be coerced into a string.
         *
         * **This function is only provided for compatibility with legacy web platform APIs**
         * **and should never be used in new code, because they use strings to represent**
         * **binary data and predate the introduction of typed arrays in JavaScript.**
         * **For code running using Node.js APIs, converting between base64-encoded strings**
         * **and binary data should be performed using `Buffer.from(str, 'base64')` and `buf.toString('base64')`.**
         * @since v15.13.0, v14.17.0
         * @legacy Use `Buffer.from(data, 'base64')` instead.
         * @param data The Base64-encoded input string.
         */
        function atob(data: string): string;
        /**
         * Decodes a string into bytes using Latin-1 (ISO-8859), and encodes those bytes
         * into a string using Base64.
         *
         * The `data` may be any JavaScript-value that can be coerced into a string.
         *
         * **This function is only provided for compatibility with legacy web platform APIs**
         * **and should never be used in new code, because they use strings to represent**
         * **binary data and predate the introduction of typed arrays in JavaScript.**
         * **For code running using Node.js APIs, converting between base64-encoded strings**
         * **and binary data should be performed using `Buffer.from(str, 'base64')` and `buf.toString('base64')`.**
         * @since v15.13.0, v14.17.0
         * @legacy Use `buf.toString('base64')` instead.
         * @param data An ASCII (Latin1) string.
         */
        function btoa(data: string): string;
        interface Blob extends _Blob {}
        /**
         * `Blob` class is a global reference for `require('node:buffer').Blob`
         * https://nodejs.org/api/buffer.html#class-blob
         * @since v18.0.0
         */
        var Blob: typeof globalThis extends { onmessage: any; Blob: infer T } ? T
            : typeof import("buffer").Blob;
        interface File extends _File {}
        /**
         * `File` class is a global reference for `require('node:buffer').File`
         * https://nodejs.org/api/buffer.html#class-file
         * @since v20.0.0
         */
        var File: typeof globalThis extends { onmessage: any; File: infer T } ? T
            : typeof import("buffer").File;
    }
}
declare module "node:buffer" {
    export * from "buffer";
}
/**
 * The `node:child_process` module provides the ability to spawn subprocesses in
 * a manner that is similar, but not identical, to [`popen(3)`](http://man7.org/linux/man-pages/man3/popen.3.html). This capability
 * is primarily provided by the {@link spawn} function:
 *
 * ```js
 * const { spawn } = require('node:child_process');
 * const ls = spawn('ls', ['-lh', '/usr']);
 *
 * ls.stdout.on('data', (data) => {
 *   console.log(`stdout: ${data}`);
 * });
 *
 * ls.stderr.on('data', (data) => {
 *   console.error(`stderr: ${data}`);
 * });
 *
 * ls.on('close', (code) => {
 *   console.log(`child process exited with code ${code}`);
 * });
 * ```
 *
 * By default, pipes for `stdin`, `stdout`, and `stderr` are established between
 * the parent Node.js process and the spawned subprocess. These pipes have
 * limited (and platform-specific) capacity. If the subprocess writes to
 * stdout in excess of that limit without the output being captured, the
 * subprocess blocks waiting for the pipe buffer to accept more data. This is
 * identical to the behavior of pipes in the shell. Use the `{ stdio: 'ignore' }` option if the output will not be consumed.
 *
 * The command lookup is performed using the `options.env.PATH` environment
 * variable if `env` is in the `options` object. Otherwise, `process.env.PATH` is
 * used. If `options.env` is set without `PATH`, lookup on Unix is performed
 * on a default search path search of `/usr/bin:/bin` (see your operating system's
 * manual for execvpe/execvp), on Windows the current processes environment
 * variable `PATH` is used.
 *
 * On Windows, environment variables are case-insensitive. Node.js
 * lexicographically sorts the `env` keys and uses the first one that
 * case-insensitively matches. Only first (in lexicographic order) entry will be
 * passed to the subprocess. This might lead to issues on Windows when passing
 * objects to the `env` option that have multiple variants of the same key, such as `PATH` and `Path`.
 *
 * The {@link spawn} method spawns the child process asynchronously,
 * without blocking the Node.js event loop. The {@link spawnSync} function provides equivalent functionality in a synchronous manner that blocks
 * the event loop until the spawned process either exits or is terminated.
 *
 * For convenience, the `node:child_process` module provides a handful of
 * synchronous and asynchronous alternatives to {@link spawn} and {@link spawnSync}. Each of these alternatives are implemented on
 * top of {@link spawn} or {@link spawnSync}.
 *
 * * {@link exec}: spawns a shell and runs a command within that
 * shell, passing the `stdout` and `stderr` to a callback function when
 * complete.
 * * {@link execFile}: similar to {@link exec} except
 * that it spawns the command directly without first spawning a shell by
 * default.
 * * {@link fork}: spawns a new Node.js process and invokes a
 * specified module with an IPC communication channel established that allows
 * sending messages between parent and child.
 * * {@link execSync}: a synchronous version of {@link exec} that will block the Node.js event loop.
 * * {@link execFileSync}: a synchronous version of {@link execFile} that will block the Node.js event loop.
 *
 * For certain use cases, such as automating shell scripts, the `synchronous counterparts` may be more convenient. In many cases, however,
 * the synchronous methods can have significant impact on performance due to
 * stalling the event loop while spawned processes complete.
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/child_process.js)
 */
declare module "child_process" {
    import { ObjectEncodingOptions } from "node:fs";
    import { Abortable, EventEmitter } from "node:events";
    import * as dgram from "node:dgram";
    import * as net from "node:net";
    import { Pipe, Readable, Stream, Writable } from "node:stream";
    import { URL } from "node:url";
    type Serializable = string | object | number | boolean | bigint;
    type SendHandle = net.Socket | net.Server | dgram.Socket | undefined;
    /**
     * Instances of the `ChildProcess` represent spawned child processes.
     *
     * Instances of `ChildProcess` are not intended to be created directly. Rather,
     * use the {@link spawn}, {@link exec},{@link execFile}, or {@link fork} methods to create
     * instances of `ChildProcess`.
     * @since v2.2.0
     */
    class ChildProcess extends EventEmitter {
        /**
         * A `Writable Stream` that represents the child process's `stdin`.
         *
         * If a child process waits to read all of its input, the child will not continue
         * until this stream has been closed via `end()`.
         *
         * If the child was spawned with `stdio[0]` set to anything other than `'pipe'`,
         * then this will be `null`.
         *
         * `subprocess.stdin` is an alias for `subprocess.stdio[0]`. Both properties will
         * refer to the same value.
         *
         * The `subprocess.stdin` property can be `null` or `undefined` if the child process could not be successfully spawned.
         * @since v0.1.90
         */
        stdin: Writable | null;
        /**
         * A `Readable Stream` that represents the child process's `stdout`.
         *
         * If the child was spawned with `stdio[1]` set to anything other than `'pipe'`,
         * then this will be `null`.
         *
         * `subprocess.stdout` is an alias for `subprocess.stdio[1]`. Both properties will
         * refer to the same value.
         *
         * ```js
         * const { spawn } = require('node:child_process');
         *
         * const subprocess = spawn('ls');
         *
         * subprocess.stdout.on('data', (data) => {
         *   console.log(`Received chunk ${data}`);
         * });
         * ```
         *
         * The `subprocess.stdout` property can be `null` or `undefined` if the child process could not be successfully spawned.
         * @since v0.1.90
         */
        stdout: Readable | null;
        /**
         * A `Readable Stream` that represents the child process's `stderr`.
         *
         * If the child was spawned with `stdio[2]` set to anything other than `'pipe'`,
         * then this will be `null`.
         *
         * `subprocess.stderr` is an alias for `subprocess.stdio[2]`. Both properties will
         * refer to the same value.
         *
         * The `subprocess.stderr` property can be `null` or `undefined` if the child process could not be successfully spawned.
         * @since v0.1.90
         */
        stderr: Readable | null;
        /**
         * The `subprocess.channel` property is a reference to the child's IPC channel. If
         * no IPC channel exists, this property is `undefined`.
         * @since v7.1.0
         */
        readonly channel?: Pipe | null | undefined;
        /**
         * A sparse array of pipes to the child process, corresponding with positions in
         * the `stdio` option passed to {@link spawn} that have been set
         * to the value `'pipe'`. `subprocess.stdio[0]`, `subprocess.stdio[1]`, and `subprocess.stdio[2]` are also available as `subprocess.stdin`, `subprocess.stdout`, and `subprocess.stderr`,
         * respectively.
         *
         * In the following example, only the child's fd `1` (stdout) is configured as a
         * pipe, so only the parent's `subprocess.stdio[1]` is a stream, all other values
         * in the array are `null`.
         *
         * ```js
         * const assert = require('node:assert');
         * const fs = require('node:fs');
         * const child_process = require('node:child_process');
         *
         * const subprocess = child_process.spawn('ls', {
         *   stdio: [
         *     0, // Use parent's stdin for child.
         *     'pipe', // Pipe child's stdout to parent.
         *     fs.openSync('err.out', 'w'), // Direct child's stderr to a file.
         *   ],
         * });
         *
         * assert.strictEqual(subprocess.stdio[0], null);
         * assert.strictEqual(subprocess.stdio[0], subprocess.stdin);
         *
         * assert(subprocess.stdout);
         * assert.strictEqual(subprocess.stdio[1], subprocess.stdout);
         *
         * assert.strictEqual(subprocess.stdio[2], null);
         * assert.strictEqual(subprocess.stdio[2], subprocess.stderr);
         * ```
         *
         * The `subprocess.stdio` property can be `undefined` if the child process could
         * not be successfully spawned.
         * @since v0.7.10
         */
        readonly stdio: [
            Writable | null,
            // stdin
            Readable | null,
            // stdout
            Readable | null,
            // stderr
            Readable | Writable | null | undefined,
            // extra
            Readable | Writable | null | undefined, // extra
        ];
        /**
         * The `subprocess.killed` property indicates whether the child process
         * successfully received a signal from `subprocess.kill()`. The `killed` property
         * does not indicate that the child process has been terminated.
         * @since v0.5.10
         */
        readonly killed: boolean;
        /**
         * Returns the process identifier (PID) of the child process. If the child process
         * fails to spawn due to errors, then the value is `undefined` and `error` is
         * emitted.
         *
         * ```js
         * const { spawn } = require('node:child_process');
         * const grep = spawn('grep', ['ssh']);
         *
         * console.log(`Spawned child pid: ${grep.pid}`);
         * grep.stdin.end();
         * ```
         * @since v0.1.90
         */
        readonly pid?: number | undefined;
        /**
         * The `subprocess.connected` property indicates whether it is still possible to
         * send and receive messages from a child process. When `subprocess.connected` is `false`, it is no longer possible to send or receive messages.
         * @since v0.7.2
         */
        readonly connected: boolean;
        /**
         * The `subprocess.exitCode` property indicates the exit code of the child process.
         * If the child process is still running, the field will be `null`.
         */
        readonly exitCode: number | null;
        /**
         * The `subprocess.signalCode` property indicates the signal received by
         * the child process if any, else `null`.
         */
        readonly signalCode: NodeJS.Signals | null;
        /**
         * The `subprocess.spawnargs` property represents the full list of command-line
         * arguments the child process was launched with.
         */
        readonly spawnargs: string[];
        /**
         * The `subprocess.spawnfile` property indicates the executable file name of
         * the child process that is launched.
         *
         * For {@link fork}, its value will be equal to `process.execPath`.
         * For {@link spawn}, its value will be the name of
         * the executable file.
         * For {@link exec},  its value will be the name of the shell
         * in which the child process is launched.
         */
        readonly spawnfile: string;
        /**
         * The `subprocess.kill()` method sends a signal to the child process. If no
         * argument is given, the process will be sent the `'SIGTERM'` signal. See [`signal(7)`](http://man7.org/linux/man-pages/man7/signal.7.html) for a list of available signals. This function
         * returns `true` if [`kill(2)`](http://man7.org/linux/man-pages/man2/kill.2.html) succeeds, and `false` otherwise.
         *
         * ```js
         * const { spawn } = require('node:child_process');
         * const grep = spawn('grep', ['ssh']);
         *
         * grep.on('close', (code, signal) => {
         *   console.log(
         *     `child process terminated due to receipt of signal ${signal}`);
         * });
         *
         * // Send SIGHUP to process.
         * grep.kill('SIGHUP');
         * ```
         *
         * The `ChildProcess` object may emit an `'error'` event if the signal
         * cannot be delivered. Sending a signal to a child process that has already exited
         * is not an error but may have unforeseen consequences. Specifically, if the
         * process identifier (PID) has been reassigned to another process, the signal will
         * be delivered to that process instead which can have unexpected results.
         *
         * While the function is called `kill`, the signal delivered to the child process
         * may not actually terminate the process.
         *
         * See [`kill(2)`](http://man7.org/linux/man-pages/man2/kill.2.html) for reference.
         *
         * On Windows, where POSIX signals do not exist, the `signal` argument will be
         * ignored, and the process will be killed forcefully and abruptly (similar to `'SIGKILL'`).
         * See `Signal Events` for more details.
         *
         * On Linux, child processes of child processes will not be terminated
         * when attempting to kill their parent. This is likely to happen when running a
         * new process in a shell or with the use of the `shell` option of `ChildProcess`:
         *
         * ```js
         * 'use strict';
         * const { spawn } = require('node:child_process');
         *
         * const subprocess = spawn(
         *   'sh',
         *   [
         *     '-c',
         *     `node -e "setInterval(() => {
         *       console.log(process.pid, 'is alive')
         *     }, 500);"`,
         *   ], {
         *     stdio: ['inherit', 'inherit', 'inherit'],
         *   },
         * );
         *
         * setTimeout(() => {
         *   subprocess.kill(); // Does not terminate the Node.js process in the shell.
         * }, 2000);
         * ```
         * @since v0.1.90
         */
        kill(signal?: NodeJS.Signals | number): boolean;
        /**
         * Calls {@link ChildProcess.kill} with `'SIGTERM'`.
         * @since v20.5.0
         */
        [Symbol.dispose](): void;
        /**
         * When an IPC channel has been established between the parent and child (
         * i.e. when using {@link fork}), the `subprocess.send()` method can
         * be used to send messages to the child process. When the child process is a
         * Node.js instance, these messages can be received via the `'message'` event.
         *
         * The message goes through serialization and parsing. The resulting
         * message might not be the same as what is originally sent.
         *
         * For example, in the parent script:
         *
         * ```js
         * const cp = require('node:child_process');
         * const n = cp.fork(`${__dirname}/sub.js`);
         *
         * n.on('message', (m) => {
         *   console.log('PARENT got message:', m);
         * });
         *
         * // Causes the child to print: CHILD got message: { hello: 'world' }
         * n.send({ hello: 'world' });
         * ```
         *
         * And then the child script, `'sub.js'` might look like this:
         *
         * ```js
         * process.on('message', (m) => {
         *   console.log('CHILD got message:', m);
         * });
         *
         * // Causes the parent to print: PARENT got message: { foo: 'bar', baz: null }
         * process.send({ foo: 'bar', baz: NaN });
         * ```
         *
         * Child Node.js processes will have a `process.send()` method of their own
         * that allows the child to send messages back to the parent.
         *
         * There is a special case when sending a `{cmd: 'NODE_foo'}` message. Messages
         * containing a `NODE_` prefix in the `cmd` property are reserved for use within
         * Node.js core and will not be emitted in the child's `'message'` event. Rather, such messages are emitted using the `'internalMessage'` event and are consumed internally by Node.js.
         * Applications should avoid using such messages or listening for `'internalMessage'` events as it is subject to change without notice.
         *
         * The optional `sendHandle` argument that may be passed to `subprocess.send()` is
         * for passing a TCP server or socket object to the child process. The child will
         * receive the object as the second argument passed to the callback function
         * registered on the `'message'` event. Any data that is received and buffered in
         * the socket will not be sent to the child. Sending IPC sockets is not supported on Windows.
         *
         * The optional `callback` is a function that is invoked after the message is
         * sent but before the child may have received it. The function is called with a
         * single argument: `null` on success, or an `Error` object on failure.
         *
         * If no `callback` function is provided and the message cannot be sent, an `'error'` event will be emitted by the `ChildProcess` object. This can
         * happen, for instance, when the child process has already exited.
         *
         * `subprocess.send()` will return `false` if the channel has closed or when the
         * backlog of unsent messages exceeds a threshold that makes it unwise to send
         * more. Otherwise, the method returns `true`. The `callback` function can be
         * used to implement flow control.
         *
         * #### Example: sending a server object
         *
         * The `sendHandle` argument can be used, for instance, to pass the handle of
         * a TCP server object to the child process as illustrated in the example below:
         *
         * ```js
         * const subprocess = require('node:child_process').fork('subprocess.js');
         *
         * // Open up the server object and send the handle.
         * const server = require('node:net').createServer();
         * server.on('connection', (socket) => {
         *   socket.end('handled by parent');
         * });
         * server.listen(1337, () => {
         *   subprocess.send('server', server);
         * });
         * ```
         *
         * The child would then receive the server object as:
         *
         * ```js
         * process.on('message', (m, server) => {
         *   if (m === 'server') {
         *     server.on('connection', (socket) => {
         *       socket.end('handled by child');
         *     });
         *   }
         * });
         * ```
         *
         * Once the server is now shared between the parent and child, some connections
         * can be handled by the parent and some by the child.
         *
         * While the example above uses a server created using the `node:net` module, `node:dgram` module servers use exactly the same workflow with the exceptions of
         * listening on a `'message'` event instead of `'connection'` and using `server.bind()` instead of `server.listen()`. This is, however, only
         * supported on Unix platforms.
         *
         * #### Example: sending a socket object
         *
         * Similarly, the `sendHandler` argument can be used to pass the handle of a
         * socket to the child process. The example below spawns two children that each
         * handle connections with "normal" or "special" priority:
         *
         * ```js
         * const { fork } = require('node:child_process');
         * const normal = fork('subprocess.js', ['normal']);
         * const special = fork('subprocess.js', ['special']);
         *
         * // Open up the server and send sockets to child. Use pauseOnConnect to prevent
         * // the sockets from being read before they are sent to the child process.
         * const server = require('node:net').createServer({ pauseOnConnect: true });
         * server.on('connection', (socket) => {
         *
         *   // If this is special priority...
         *   if (socket.remoteAddress === '74.125.127.100') {
         *     special.send('socket', socket);
         *     return;
         *   }
         *   // This is normal priority.
         *   normal.send('socket', socket);
         * });
         * server.listen(1337);
         * ```
         *
         * The `subprocess.js` would receive the socket handle as the second argument
         * passed to the event callback function:
         *
         * ```js
         * process.on('message', (m, socket) => {
         *   if (m === 'socket') {
         *     if (socket) {
         *       // Check that the client socket exists.
         *       // It is possible for the socket to be closed between the time it is
         *       // sent and the time it is received in the child process.
         *       socket.end(`Request handled with ${process.argv[2]} priority`);
         *     }
         *   }
         * });
         * ```
         *
         * Do not use `.maxConnections` on a socket that has been passed to a subprocess.
         * The parent cannot track when the socket is destroyed.
         *
         * Any `'message'` handlers in the subprocess should verify that `socket` exists,
         * as the connection may have been closed during the time it takes to send the
         * connection to the child.
         * @since v0.5.9
         * @param sendHandle `undefined`, or a [`net.Socket`](https://nodejs.org/docs/latest-v22.x/api/net.html#class-netsocket), [`net.Server`](https://nodejs.org/docs/latest-v22.x/api/net.html#class-netserver), or [`dgram.Socket`](https://nodejs.org/docs/latest-v22.x/api/dgram.html#class-dgramsocket) object.
         * @param options The `options` argument, if present, is an object used to parameterize the sending of certain types of handles. `options` supports the following properties:
         */
        send(message: Serializable, callback?: (error: Error | null) => void): boolean;
        send(message: Serializable, sendHandle?: SendHandle, callback?: (error: Error | null) => void): boolean;
        send(
            message: Serializable,
            sendHandle?: SendHandle,
            options?: MessageOptions,
            callback?: (error: Error | null) => void,
        ): boolean;
        /**
         * Closes the IPC channel between parent and child, allowing the child to exit
         * gracefully once there are no other connections keeping it alive. After calling
         * this method the `subprocess.connected` and `process.connected` properties in
         * both the parent and child (respectively) will be set to `false`, and it will be
         * no longer possible to pass messages between the processes.
         *
         * The `'disconnect'` event will be emitted when there are no messages in the
         * process of being received. This will most often be triggered immediately after
         * calling `subprocess.disconnect()`.
         *
         * When the child process is a Node.js instance (e.g. spawned using {@link fork}), the `process.disconnect()` method can be invoked
         * within the child process to close the IPC channel as well.
         * @since v0.7.2
         */
        disconnect(): void;
        /**
         * By default, the parent will wait for the detached child to exit. To prevent the
         * parent from waiting for a given `subprocess` to exit, use the `subprocess.unref()` method. Doing so will cause the parent's event loop to not
         * include the child in its reference count, allowing the parent to exit
         * independently of the child, unless there is an established IPC channel between
         * the child and the parent.
         *
         * ```js
         * const { spawn } = require('node:child_process');
         *
         * const subprocess = spawn(process.argv[0], ['child_program.js'], {
         *   detached: true,
         *   stdio: 'ignore',
         * });
         *
         * subprocess.unref();
         * ```
         * @since v0.7.10
         */
        unref(): void;
        /**
         * Calling `subprocess.ref()` after making a call to `subprocess.unref()` will
         * restore the removed reference count for the child process, forcing the parent
         * to wait for the child to exit before exiting itself.
         *
         * ```js
         * const { spawn } = require('node:child_process');
         *
         * const subprocess = spawn(process.argv[0], ['child_program.js'], {
         *   detached: true,
         *   stdio: 'ignore',
         * });
         *
         * subprocess.unref();
         * subprocess.ref();
         * ```
         * @since v0.7.10
         */
        ref(): void;
        /**
         * events.EventEmitter
         * 1. close
         * 2. disconnect
         * 3. error
         * 4. exit
         * 5. message
         * 6. spawn
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "close", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        addListener(event: "disconnect", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "exit", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        addListener(event: "message", listener: (message: Serializable, sendHandle: SendHandle) => void): this;
        addListener(event: "spawn", listener: () => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "close", code: number | null, signal: NodeJS.Signals | null): boolean;
        emit(event: "disconnect"): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "exit", code: number | null, signal: NodeJS.Signals | null): boolean;
        emit(event: "message", message: Serializable, sendHandle: SendHandle): boolean;
        emit(event: "spawn", listener: () => void): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "close", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        on(event: "disconnect", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "exit", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        on(event: "message", listener: (message: Serializable, sendHandle: SendHandle) => void): this;
        on(event: "spawn", listener: () => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "close", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        once(event: "disconnect", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "exit", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        once(event: "message", listener: (message: Serializable, sendHandle: SendHandle) => void): this;
        once(event: "spawn", listener: () => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        prependListener(event: "disconnect", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "exit", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        prependListener(event: "message", listener: (message: Serializable, sendHandle: SendHandle) => void): this;
        prependListener(event: "spawn", listener: () => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(
            event: "close",
            listener: (code: number | null, signal: NodeJS.Signals | null) => void,
        ): this;
        prependOnceListener(event: "disconnect", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(
            event: "exit",
            listener: (code: number | null, signal: NodeJS.Signals | null) => void,
        ): this;
        prependOnceListener(event: "message", listener: (message: Serializable, sendHandle: SendHandle) => void): this;
        prependOnceListener(event: "spawn", listener: () => void): this;
    }
    // return this object when stdio option is undefined or not specified
    interface ChildProcessWithoutNullStreams extends ChildProcess {
        stdin: Writable;
        stdout: Readable;
        stderr: Readable;
        readonly stdio: [
            Writable,
            Readable,
            Readable,
            // stderr
            Readable | Writable | null | undefined,
            // extra, no modification
            Readable | Writable | null | undefined, // extra, no modification
        ];
    }
    // return this object when stdio option is a tuple of 3
    interface ChildProcessByStdio<I extends null | Writable, O extends null | Readable, E extends null | Readable>
        extends ChildProcess
    {
        stdin: I;
        stdout: O;
        stderr: E;
        readonly stdio: [
            I,
            O,
            E,
            Readable | Writable | null | undefined,
            // extra, no modification
            Readable | Writable | null | undefined, // extra, no modification
        ];
    }
    interface MessageOptions {
        keepOpen?: boolean | undefined;
    }
    type IOType = "overlapped" | "pipe" | "ignore" | "inherit";
    type StdioOptions = IOType | Array<IOType | "ipc" | Stream | number | null | undefined>;
    type SerializationType = "json" | "advanced";
    interface MessagingOptions extends Abortable {
        /**
         * Specify the kind of serialization used for sending messages between processes.
         * @default 'json'
         */
        serialization?: SerializationType | undefined;
        /**
         * The signal value to be used when the spawned process will be killed by the abort signal.
         * @default 'SIGTERM'
         */
        killSignal?: NodeJS.Signals | number | undefined;
        /**
         * In milliseconds the maximum amount of time the process is allowed to run.
         */
        timeout?: number | undefined;
    }
    interface ProcessEnvOptions {
        uid?: number | undefined;
        gid?: number | undefined;
        cwd?: string | URL | undefined;
        env?: NodeJS.ProcessEnv | undefined;
    }
    interface CommonOptions extends ProcessEnvOptions {
        /**
         * @default false
         */
        windowsHide?: boolean | undefined;
        /**
         * @default 0
         */
        timeout?: number | undefined;
    }
    interface CommonSpawnOptions extends CommonOptions, MessagingOptions, Abortable {
        argv0?: string | undefined;
        /**
         * Can be set to 'pipe', 'inherit', 'overlapped', or 'ignore', or an array of these strings.
         * If passed as an array, the first element is used for `stdin`, the second for
         * `stdout`, and the third for `stderr`. A fourth element can be used to
         * specify the `stdio` behavior beyond the standard streams. See
         * {@link ChildProcess.stdio} for more information.
         *
         * @default 'pipe'
         */
        stdio?: StdioOptions | undefined;
        shell?: boolean | string | undefined;
        windowsVerbatimArguments?: boolean | undefined;
    }
    interface SpawnOptions extends CommonSpawnOptions {
        detached?: boolean | undefined;
    }
    interface SpawnOptionsWithoutStdio extends SpawnOptions {
        stdio?: StdioPipeNamed | StdioPipe[] | undefined;
    }
    type StdioNull = "inherit" | "ignore" | Stream;
    type StdioPipeNamed = "pipe" | "overlapped";
    type StdioPipe = undefined | null | StdioPipeNamed;
    interface SpawnOptionsWithStdioTuple<
        Stdin extends StdioNull | StdioPipe,
        Stdout extends StdioNull | StdioPipe,
        Stderr extends StdioNull | StdioPipe,
    > extends SpawnOptions {
        stdio: [Stdin, Stdout, Stderr];
    }
    /**
     * The `child_process.spawn()` method spawns a new process using the given `command`, with command-line arguments in `args`. If omitted, `args` defaults
     * to an empty array.
     *
     * **If the `shell` option is enabled, do not pass unsanitized user input to this**
     * **function. Any input containing shell metacharacters may be used to trigger**
     * **arbitrary command execution.**
     *
     * A third argument may be used to specify additional options, with these defaults:
     *
     * ```js
     * const defaults = {
     *   cwd: undefined,
     *   env: process.env,
     * };
     * ```
     *
     * Use `cwd` to specify the working directory from which the process is spawned.
     * If not given, the default is to inherit the current working directory. If given,
     * but the path does not exist, the child process emits an `ENOENT` error
     * and exits immediately. `ENOENT` is also emitted when the command
     * does not exist.
     *
     * Use `env` to specify environment variables that will be visible to the new
     * process, the default is `process.env`.
     *
     * `undefined` values in `env` will be ignored.
     *
     * Example of running `ls -lh /usr`, capturing `stdout`, `stderr`, and the
     * exit code:
     *
     * ```js
     * const { spawn } = require('node:child_process');
     * const ls = spawn('ls', ['-lh', '/usr']);
     *
     * ls.stdout.on('data', (data) => {
     *   console.log(`stdout: ${data}`);
     * });
     *
     * ls.stderr.on('data', (data) => {
     *   console.error(`stderr: ${data}`);
     * });
     *
     * ls.on('close', (code) => {
     *   console.log(`child process exited with code ${code}`);
     * });
     * ```
     *
     * Example: A very elaborate way to run `ps ax | grep ssh`
     *
     * ```js
     * const { spawn } = require('node:child_process');
     * const ps = spawn('ps', ['ax']);
     * const grep = spawn('grep', ['ssh']);
     *
     * ps.stdout.on('data', (data) => {
     *   grep.stdin.write(data);
     * });
     *
     * ps.stderr.on('data', (data) => {
     *   console.error(`ps stderr: ${data}`);
     * });
     *
     * ps.on('close', (code) => {
     *   if (code !== 0) {
     *     console.log(`ps process exited with code ${code}`);
     *   }
     *   grep.stdin.end();
     * });
     *
     * grep.stdout.on('data', (data) => {
     *   console.log(data.toString());
     * });
     *
     * grep.stderr.on('data', (data) => {
     *   console.error(`grep stderr: ${data}`);
     * });
     *
     * grep.on('close', (code) => {
     *   if (code !== 0) {
     *     console.log(`grep process exited with code ${code}`);
     *   }
     * });
     * ```
     *
     * Example of checking for failed `spawn`:
     *
     * ```js
     * const { spawn } = require('node:child_process');
     * const subprocess = spawn('bad_command');
     *
     * subprocess.on('error', (err) => {
     *   console.error('Failed to start subprocess.');
     * });
     * ```
     *
     * Certain platforms (macOS, Linux) will use the value of `argv[0]` for the process
     * title while others (Windows, SunOS) will use `command`.
     *
     * Node.js overwrites `argv[0]` with `process.execPath` on startup, so `process.argv[0]` in a Node.js child process will not match the `argv0` parameter passed to `spawn` from the parent. Retrieve
     * it with the `process.argv0` property instead.
     *
     * If the `signal` option is enabled, calling `.abort()` on the corresponding `AbortController` is similar to calling `.kill()` on the child process except
     * the error passed to the callback will be an `AbortError`:
     *
     * ```js
     * const { spawn } = require('node:child_process');
     * const controller = new AbortController();
     * const { signal } = controller;
     * const grep = spawn('grep', ['ssh'], { signal });
     * grep.on('error', (err) => {
     *   // This will be called with err being an AbortError if the controller aborts
     * });
     * controller.abort(); // Stops the child process
     * ```
     * @since v0.1.90
     * @param command The command to run.
     * @param args List of string arguments.
     */
    function spawn(command: string, options?: SpawnOptionsWithoutStdio): ChildProcessWithoutNullStreams;
    function spawn(
        command: string,
        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioPipe, StdioPipe>,
    ): ChildProcessByStdio<Writable, Readable, Readable>;
    function spawn(
        command: string,
        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioPipe, StdioNull>,
    ): ChildProcessByStdio<Writable, Readable, null>;
    function spawn(
        command: string,
        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioNull, StdioPipe>,
    ): ChildProcessByStdio<Writable, null, Readable>;
    function spawn(
        command: string,
        options: SpawnOptionsWithStdioTuple<StdioNull, StdioPipe, StdioPipe>,
    ): ChildProcessByStdio<null, Readable, Readable>;
    function spawn(
        command: string,
        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioNull, StdioNull>,
    ): ChildProcessByStdio<Writable, null, null>;
    function spawn(
        command: string,
        options: SpawnOptionsWithStdioTuple<StdioNull, StdioPipe, StdioNull>,
    ): ChildProcessByStdio<null, Readable, null>;
    function spawn(
        command: string,
        options: SpawnOptionsWithStdioTuple<StdioNull, StdioNull, StdioPipe>,
    ): ChildProcessByStdio<null, null, Readable>;
    function spawn(
        command: string,
        options: SpawnOptionsWithStdioTuple<StdioNull, StdioNull, StdioNull>,
    ): ChildProcessByStdio<null, null, null>;
    function spawn(command: string, options: SpawnOptions): ChildProcess;
    // overloads of spawn with 'args'
    function spawn(
        command: string,
        args?: readonly string[],
        options?: SpawnOptionsWithoutStdio,
    ): ChildProcessWithoutNullStreams;
    function spawn(
        command: string,
        args: readonly string[],
        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioPipe, StdioPipe>,
    ): ChildProcessByStdio<Writable, Readable, Readable>;
    function spawn(
        command: string,
        args: readonly string[],
        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioPipe, StdioNull>,
    ): ChildProcessByStdio<Writable, Readable, null>;
    function spawn(
        command: string,
        args: readonly string[],
        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioNull, StdioPipe>,
    ): ChildProcessByStdio<Writable, null, Readable>;
    function spawn(
        command: string,
        args: readonly string[],
        options: SpawnOptionsWithStdioTuple<StdioNull, StdioPipe, StdioPipe>,
    ): ChildProcessByStdio<null, Readable, Readable>;
    function spawn(
        command: string,
        args: readonly string[],
        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioNull, StdioNull>,
    ): ChildProcessByStdio<Writable, null, null>;
    function spawn(
        command: string,
        args: readonly string[],
        options: SpawnOptionsWithStdioTuple<StdioNull, StdioPipe, StdioNull>,
    ): ChildProcessByStdio<null, Readable, null>;
    function spawn(
        command: string,
        args: readonly string[],
        options: SpawnOptionsWithStdioTuple<StdioNull, StdioNull, StdioPipe>,
    ): ChildProcessByStdio<null, null, Readable>;
    function spawn(
        command: string,
        args: readonly string[],
        options: SpawnOptionsWithStdioTuple<StdioNull, StdioNull, StdioNull>,
    ): ChildProcessByStdio<null, null, null>;
    function spawn(command: string, args: readonly string[], options: SpawnOptions): ChildProcess;
    interface ExecOptions extends CommonOptions {
        shell?: string | undefined;
        signal?: AbortSignal | undefined;
        maxBuffer?: number | undefined;
        killSignal?: NodeJS.Signals | number | undefined;
    }
    interface ExecOptionsWithStringEncoding extends ExecOptions {
        encoding: BufferEncoding;
    }
    interface ExecOptionsWithBufferEncoding extends ExecOptions {
        encoding: BufferEncoding | null; // specify `null`.
    }
    interface ExecException extends Error {
        cmd?: string | undefined;
        killed?: boolean | undefined;
        code?: number | undefined;
        signal?: NodeJS.Signals | undefined;
        stdout?: string;
        stderr?: string;
    }
    /**
     * Spawns a shell then executes the `command` within that shell, buffering any
     * generated output. The `command` string passed to the exec function is processed
     * directly by the shell and special characters (vary based on [shell](https://en.wikipedia.org/wiki/List_of_command-line_interpreters))
     * need to be dealt with accordingly:
     *
     * ```js
     * const { exec } = require('node:child_process');
     *
     * exec('"/path/to/test file/test.sh" arg1 arg2');
     * // Double quotes are used so that the space in the path is not interpreted as
     * // a delimiter of multiple arguments.
     *
     * exec('echo "The \\$HOME variable is $HOME"');
     * // The $HOME variable is escaped in the first instance, but not in the second.
     * ```
     *
     * **Never pass unsanitized user input to this function. Any input containing shell**
     * **metacharacters may be used to trigger arbitrary command execution.**
     *
     * If a `callback` function is provided, it is called with the arguments `(error, stdout, stderr)`. On success, `error` will be `null`. On error, `error` will be an instance of `Error`. The
     * `error.code` property will be
     * the exit code of the process. By convention, any exit code other than `0` indicates an error. `error.signal` will be the signal that terminated the
     * process.
     *
     * The `stdout` and `stderr` arguments passed to the callback will contain the
     * stdout and stderr output of the child process. By default, Node.js will decode
     * the output as UTF-8 and pass strings to the callback. The `encoding` option
     * can be used to specify the character encoding used to decode the stdout and
     * stderr output. If `encoding` is `'buffer'`, or an unrecognized character
     * encoding, `Buffer` objects will be passed to the callback instead.
     *
     * ```js
     * const { exec } = require('node:child_process');
     * exec('cat *.js missing_file | wc -l', (error, stdout, stderr) => {
     *   if (error) {
     *     console.error(`exec error: ${error}`);
     *     return;
     *   }
     *   console.log(`stdout: ${stdout}`);
     *   console.error(`stderr: ${stderr}`);
     * });
     * ```
     *
     * If `timeout` is greater than `0`, the parent will send the signal
     * identified by the `killSignal` property (the default is `'SIGTERM'`) if the
     * child runs longer than `timeout` milliseconds.
     *
     * Unlike the [`exec(3)`](http://man7.org/linux/man-pages/man3/exec.3.html) POSIX system call, `child_process.exec()` does not replace
     * the existing process and uses a shell to execute the command.
     *
     * If this method is invoked as its `util.promisify()` ed version, it returns
     * a `Promise` for an `Object` with `stdout` and `stderr` properties. The returned `ChildProcess` instance is attached to the `Promise` as a `child` property. In
     * case of an error (including any error resulting in an exit code other than 0), a
     * rejected promise is returned, with the same `error` object given in the
     * callback, but with two additional properties `stdout` and `stderr`.
     *
     * ```js
     * const util = require('node:util');
     * const exec = util.promisify(require('node:child_process').exec);
     *
     * async function lsExample() {
     *   const { stdout, stderr } = await exec('ls');
     *   console.log('stdout:', stdout);
     *   console.error('stderr:', stderr);
     * }
     * lsExample();
     * ```
     *
     * If the `signal` option is enabled, calling `.abort()` on the corresponding `AbortController` is similar to calling `.kill()` on the child process except
     * the error passed to the callback will be an `AbortError`:
     *
     * ```js
     * const { exec } = require('node:child_process');
     * const controller = new AbortController();
     * const { signal } = controller;
     * const child = exec('grep ssh', { signal }, (error) => {
     *   console.error(error); // an AbortError
     * });
     * controller.abort();
     * ```
     * @since v0.1.90
     * @param command The command to run, with space-separated arguments.
     * @param callback called with the output when process terminates.
     */
    function exec(
        command: string,
        callback?: (error: ExecException | null, stdout: string, stderr: string) => void,
    ): ChildProcess;
    // `options` with `"buffer"` or `null` for `encoding` means stdout/stderr are definitely `Buffer`.
    function exec(
        command: string,
        options: {
            encoding: "buffer" | null;
        } & ExecOptions,
        callback?: (error: ExecException | null, stdout: Buffer, stderr: Buffer) => void,
    ): ChildProcess;
    // `options` with well known `encoding` means stdout/stderr are definitely `string`.
    function exec(
        command: string,
        options: {
            encoding: BufferEncoding;
        } & ExecOptions,
        callback?: (error: ExecException | null, stdout: string, stderr: string) => void,
    ): ChildProcess;
    // `options` with an `encoding` whose type is `string` means stdout/stderr could either be `Buffer` or `string`.
    // There is no guarantee the `encoding` is unknown as `string` is a superset of `BufferEncoding`.
    function exec(
        command: string,
        options: {
            encoding: BufferEncoding;
        } & ExecOptions,
        callback?: (error: ExecException | null, stdout: string | Buffer, stderr: string | Buffer) => void,
    ): ChildProcess;
    // `options` without an `encoding` means stdout/stderr are definitely `string`.
    function exec(
        command: string,
        options: ExecOptions,
        callback?: (error: ExecException | null, stdout: string, stderr: string) => void,
    ): ChildProcess;
    // fallback if nothing else matches. Worst case is always `string | Buffer`.
    function exec(
        command: string,
        options: (ObjectEncodingOptions & ExecOptions) | undefined | null,
        callback?: (error: ExecException | null, stdout: string | Buffer, stderr: string | Buffer) => void,
    ): ChildProcess;
    interface PromiseWithChild<T> extends Promise<T> {
        child: ChildProcess;
    }
    namespace exec {
        function __promisify__(command: string): PromiseWithChild<{
            stdout: string;
            stderr: string;
        }>;
        function __promisify__(
            command: string,
            options: {
                encoding: "buffer" | null;
            } & ExecOptions,
        ): PromiseWithChild<{
            stdout: Buffer;
            stderr: Buffer;
        }>;
        function __promisify__(
            command: string,
            options: {
                encoding: BufferEncoding;
            } & ExecOptions,
        ): PromiseWithChild<{
            stdout: string;
            stderr: string;
        }>;
        function __promisify__(
            command: string,
            options: ExecOptions,
        ): PromiseWithChild<{
            stdout: string;
            stderr: string;
        }>;
        function __promisify__(
            command: string,
            options?: (ObjectEncodingOptions & ExecOptions) | null,
        ): PromiseWithChild<{
            stdout: string | Buffer;
            stderr: string | Buffer;
        }>;
    }
    interface ExecFileOptions extends CommonOptions, Abortable {
        maxBuffer?: number | undefined;
        killSignal?: NodeJS.Signals | number | undefined;
        windowsVerbatimArguments?: boolean | undefined;
        shell?: boolean | string | undefined;
        signal?: AbortSignal | undefined;
    }
    interface ExecFileOptionsWithStringEncoding extends ExecFileOptions {
        encoding: BufferEncoding;
    }
    interface ExecFileOptionsWithBufferEncoding extends ExecFileOptions {
        encoding: "buffer" | null;
    }
    interface ExecFileOptionsWithOtherEncoding extends ExecFileOptions {
        encoding: BufferEncoding;
    }
    type ExecFileException =
        & Omit<ExecException, "code">
        & Omit<NodeJS.ErrnoException, "code">
        & { code?: string | number | undefined | null };
    /**
     * The `child_process.execFile()` function is similar to {@link exec} except that it does not spawn a shell by default. Rather, the specified
     * executable `file` is spawned directly as a new process making it slightly more
     * efficient than {@link exec}.
     *
     * The same options as {@link exec} are supported. Since a shell is
     * not spawned, behaviors such as I/O redirection and file globbing are not
     * supported.
     *
     * ```js
     * const { execFile } = require('node:child_process');
     * const child = execFile('node', ['--version'], (error, stdout, stderr) => {
     *   if (error) {
     *     throw error;
     *   }
     *   console.log(stdout);
     * });
     * ```
     *
     * The `stdout` and `stderr` arguments passed to the callback will contain the
     * stdout and stderr output of the child process. By default, Node.js will decode
     * the output as UTF-8 and pass strings to the callback. The `encoding` option
     * can be used to specify the character encoding used to decode the stdout and
     * stderr output. If `encoding` is `'buffer'`, or an unrecognized character
     * encoding, `Buffer` objects will be passed to the callback instead.
     *
     * If this method is invoked as its `util.promisify()` ed version, it returns
     * a `Promise` for an `Object` with `stdout` and `stderr` properties. The returned `ChildProcess` instance is attached to the `Promise` as a `child` property. In
     * case of an error (including any error resulting in an exit code other than 0), a
     * rejected promise is returned, with the same `error` object given in the
     * callback, but with two additional properties `stdout` and `stderr`.
     *
     * ```js
     * const util = require('node:util');
     * const execFile = util.promisify(require('node:child_process').execFile);
     * async function getVersion() {
     *   const { stdout } = await execFile('node', ['--version']);
     *   console.log(stdout);
     * }
     * getVersion();
     * ```
     *
     * **If the `shell` option is enabled, do not pass unsanitized user input to this**
     * **function. Any input containing shell metacharacters may be used to trigger**
     * **arbitrary command execution.**
     *
     * If the `signal` option is enabled, calling `.abort()` on the corresponding `AbortController` is similar to calling `.kill()` on the child process except
     * the error passed to the callback will be an `AbortError`:
     *
     * ```js
     * const { execFile } = require('node:child_process');
     * const controller = new AbortController();
     * const { signal } = controller;
     * const child = execFile('node', ['--version'], { signal }, (error) => {
     *   console.error(error); // an AbortError
     * });
     * controller.abort();
     * ```
     * @since v0.1.91
     * @param file The name or path of the executable file to run.
     * @param args List of string arguments.
     * @param callback Called with the output when process terminates.
     */
    function execFile(file: string): ChildProcess;
    function execFile(
        file: string,
        options: (ObjectEncodingOptions & ExecFileOptions) | undefined | null,
    ): ChildProcess;
    function execFile(file: string, args?: readonly string[] | null): ChildProcess;
    function execFile(
        file: string,
        args: readonly string[] | undefined | null,
        options: (ObjectEncodingOptions & ExecFileOptions) | undefined | null,
    ): ChildProcess;
    // no `options` definitely means stdout/stderr are `string`.
    function execFile(
        file: string,
        callback: (error: ExecFileException | null, stdout: string, stderr: string) => void,
    ): ChildProcess;
    function execFile(
        file: string,
        args: readonly string[] | undefined | null,
        callback: (error: ExecFileException | null, stdout: string, stderr: string) => void,
    ): ChildProcess;
    // `options` with `"buffer"` or `null` for `encoding` means stdout/stderr are definitely `Buffer`.
    function execFile(
        file: string,
        options: ExecFileOptionsWithBufferEncoding,
        callback: (error: ExecFileException | null, stdout: Buffer, stderr: Buffer) => void,
    ): ChildProcess;
    function execFile(
        file: string,
        args: readonly string[] | undefined | null,
        options: ExecFileOptionsWithBufferEncoding,
        callback: (error: ExecFileException | null, stdout: Buffer, stderr: Buffer) => void,
    ): ChildProcess;
    // `options` with well known `encoding` means stdout/stderr are definitely `string`.
    function execFile(
        file: string,
        options: ExecFileOptionsWithStringEncoding,
        callback: (error: ExecFileException | null, stdout: string, stderr: string) => void,
    ): ChildProcess;
    function execFile(
        file: string,
        args: readonly string[] | undefined | null,
        options: ExecFileOptionsWithStringEncoding,
        callback: (error: ExecFileException | null, stdout: string, stderr: string) => void,
    ): ChildProcess;
    // `options` with an `encoding` whose type is `string` means stdout/stderr could either be `Buffer` or `string`.
    // There is no guarantee the `encoding` is unknown as `string` is a superset of `BufferEncoding`.
    function execFile(
        file: string,
        options: ExecFileOptionsWithOtherEncoding,
        callback: (error: ExecFileException | null, stdout: string | Buffer, stderr: string | Buffer) => void,
    ): ChildProcess;
    function execFile(
        file: string,
        args: readonly string[] | undefined | null,
        options: ExecFileOptionsWithOtherEncoding,
        callback: (error: ExecFileException | null, stdout: string | Buffer, stderr: string | Buffer) => void,
    ): ChildProcess;
    // `options` without an `encoding` means stdout/stderr are definitely `string`.
    function execFile(
        file: string,
        options: ExecFileOptions,
        callback: (error: ExecFileException | null, stdout: string, stderr: string) => void,
    ): ChildProcess;
    function execFile(
        file: string,
        args: readonly string[] | undefined | null,
        options: ExecFileOptions,
        callback: (error: ExecFileException | null, stdout: string, stderr: string) => void,
    ): ChildProcess;
    // fallback if nothing else matches. Worst case is always `string | Buffer`.
    function execFile(
        file: string,
        options: (ObjectEncodingOptions & ExecFileOptions) | undefined | null,
        callback:
            | ((error: ExecFileException | null, stdout: string | Buffer, stderr: string | Buffer) => void)
            | undefined
            | null,
    ): ChildProcess;
    function execFile(
        file: string,
        args: readonly string[] | undefined | null,
        options: (ObjectEncodingOptions & ExecFileOptions) | undefined | null,
        callback:
            | ((error: ExecFileException | null, stdout: string | Buffer, stderr: string | Buffer) => void)
            | undefined
            | null,
    ): ChildProcess;
    namespace execFile {
        function __promisify__(file: string): PromiseWithChild<{
            stdout: string;
            stderr: string;
        }>;
        function __promisify__(
            file: string,
            args: readonly string[] | undefined | null,
        ): PromiseWithChild<{
            stdout: string;
            stderr: string;
        }>;
        function __promisify__(
            file: string,
            options: ExecFileOptionsWithBufferEncoding,
        ): PromiseWithChild<{
            stdout: Buffer;
            stderr: Buffer;
        }>;
        function __promisify__(
            file: string,
            args: readonly string[] | undefined | null,
            options: ExecFileOptionsWithBufferEncoding,
        ): PromiseWithChild<{
            stdout: Buffer;
            stderr: Buffer;
        }>;
        function __promisify__(
            file: string,
            options: ExecFileOptionsWithStringEncoding,
        ): PromiseWithChild<{
            stdout: string;
            stderr: string;
        }>;
        function __promisify__(
            file: string,
            args: readonly string[] | undefined | null,
            options: ExecFileOptionsWithStringEncoding,
        ): PromiseWithChild<{
            stdout: string;
            stderr: string;
        }>;
        function __promisify__(
            file: string,
            options: ExecFileOptionsWithOtherEncoding,
        ): PromiseWithChild<{
            stdout: string | Buffer;
            stderr: string | Buffer;
        }>;
        function __promisify__(
            file: string,
            args: readonly string[] | undefined | null,
            options: ExecFileOptionsWithOtherEncoding,
        ): PromiseWithChild<{
            stdout: string | Buffer;
            stderr: string | Buffer;
        }>;
        function __promisify__(
            file: string,
            options: ExecFileOptions,
        ): PromiseWithChild<{
            stdout: string;
            stderr: string;
        }>;
        function __promisify__(
            file: string,
            args: readonly string[] | undefined | null,
            options: ExecFileOptions,
        ): PromiseWithChild<{
            stdout: string;
            stderr: string;
        }>;
        function __promisify__(
            file: string,
            options: (ObjectEncodingOptions & ExecFileOptions) | undefined | null,
        ): PromiseWithChild<{
            stdout: string | Buffer;
            stderr: string | Buffer;
        }>;
        function __promisify__(
            file: string,
            args: readonly string[] | undefined | null,
            options: (ObjectEncodingOptions & ExecFileOptions) | undefined | null,
        ): PromiseWithChild<{
            stdout: string | Buffer;
            stderr: string | Buffer;
        }>;
    }
    interface ForkOptions extends ProcessEnvOptions, MessagingOptions, Abortable {
        execPath?: string | undefined;
        execArgv?: string[] | undefined;
        silent?: boolean | undefined;
        /**
         * Can be set to 'pipe', 'inherit', 'overlapped', or 'ignore', or an array of these strings.
         * If passed as an array, the first element is used for `stdin`, the second for
         * `stdout`, and the third for `stderr`. A fourth element can be used to
         * specify the `stdio` behavior beyond the standard streams. See
         * {@link ChildProcess.stdio} for more information.
         *
         * @default 'pipe'
         */
        stdio?: StdioOptions | undefined;
        detached?: boolean | undefined;
        windowsVerbatimArguments?: boolean | undefined;
    }
    /**
     * The `child_process.fork()` method is a special case of {@link spawn} used specifically to spawn new Node.js processes.
     * Like {@link spawn}, a `ChildProcess` object is returned. The
     * returned `ChildProcess` will have an additional communication channel
     * built-in that allows messages to be passed back and forth between the parent and
     * child. See `subprocess.send()` for details.
     *
     * Keep in mind that spawned Node.js child processes are
     * independent of the parent with exception of the IPC communication channel
     * that is established between the two. Each process has its own memory, with
     * their own V8 instances. Because of the additional resource allocations
     * required, spawning a large number of child Node.js processes is not
     * recommended.
     *
     * By default, `child_process.fork()` will spawn new Node.js instances using the `process.execPath` of the parent process. The `execPath` property in the `options` object allows for an alternative
     * execution path to be used.
     *
     * Node.js processes launched with a custom `execPath` will communicate with the
     * parent process using the file descriptor (fd) identified using the
     * environment variable `NODE_CHANNEL_FD` on the child process.
     *
     * Unlike the [`fork(2)`](http://man7.org/linux/man-pages/man2/fork.2.html) POSIX system call, `child_process.fork()` does not clone the
     * current process.
     *
     * The `shell` option available in {@link spawn} is not supported by `child_process.fork()` and will be ignored if set.
     *
     * If the `signal` option is enabled, calling `.abort()` on the corresponding `AbortController` is similar to calling `.kill()` on the child process except
     * the error passed to the callback will be an `AbortError`:
     *
     * ```js
     * if (process.argv[2] === 'child') {
     *   setTimeout(() => {
     *     console.log(`Hello from ${process.argv[2]}!`);
     *   }, 1_000);
     * } else {
     *   const { fork } = require('node:child_process');
     *   const controller = new AbortController();
     *   const { signal } = controller;
     *   const child = fork(__filename, ['child'], { signal });
     *   child.on('error', (err) => {
     *     // This will be called with err being an AbortError if the controller aborts
     *   });
     *   controller.abort(); // Stops the child process
     * }
     * ```
     * @since v0.5.0
     * @param modulePath The module to run in the child.
     * @param args List of string arguments.
     */
    function fork(modulePath: string | URL, options?: ForkOptions): ChildProcess;
    function fork(modulePath: string | URL, args?: readonly string[], options?: ForkOptions): ChildProcess;
    interface SpawnSyncOptions extends CommonSpawnOptions {
        input?: string | NodeJS.ArrayBufferView | undefined;
        maxBuffer?: number | undefined;
        encoding?: BufferEncoding | "buffer" | null | undefined;
    }
    interface SpawnSyncOptionsWithStringEncoding extends SpawnSyncOptions {
        encoding: BufferEncoding;
    }
    interface SpawnSyncOptionsWithBufferEncoding extends SpawnSyncOptions {
        encoding?: "buffer" | null | undefined;
    }
    interface SpawnSyncReturns<T> {
        pid: number;
        output: Array<T | null>;
        stdout: T;
        stderr: T;
        status: number | null;
        signal: NodeJS.Signals | null;
        error?: Error | undefined;
    }
    /**
     * The `child_process.spawnSync()` method is generally identical to {@link spawn} with the exception that the function will not return
     * until the child process has fully closed. When a timeout has been encountered
     * and `killSignal` is sent, the method won't return until the process has
     * completely exited. If the process intercepts and handles the `SIGTERM` signal
     * and doesn't exit, the parent process will wait until the child process has
     * exited.
     *
     * **If the `shell` option is enabled, do not pass unsanitized user input to this**
     * **function. Any input containing shell metacharacters may be used to trigger**
     * **arbitrary command execution.**
     * @since v0.11.12
     * @param command The command to run.
     * @param args List of string arguments.
     */
    function spawnSync(command: string): SpawnSyncReturns<Buffer>;
    function spawnSync(command: string, options: SpawnSyncOptionsWithStringEncoding): SpawnSyncReturns<string>;
    function spawnSync(command: string, options: SpawnSyncOptionsWithBufferEncoding): SpawnSyncReturns<Buffer>;
    function spawnSync(command: string, options?: SpawnSyncOptions): SpawnSyncReturns<string | Buffer>;
    function spawnSync(command: string, args: readonly string[]): SpawnSyncReturns<Buffer>;
    function spawnSync(
        command: string,
        args: readonly string[],
        options: SpawnSyncOptionsWithStringEncoding,
    ): SpawnSyncReturns<string>;
    function spawnSync(
        command: string,
        args: readonly string[],
        options: SpawnSyncOptionsWithBufferEncoding,
    ): SpawnSyncReturns<Buffer>;
    function spawnSync(
        command: string,
        args?: readonly string[],
        options?: SpawnSyncOptions,
    ): SpawnSyncReturns<string | Buffer>;
    interface CommonExecOptions extends CommonOptions {
        input?: string | NodeJS.ArrayBufferView | undefined;
        /**
         * Can be set to 'pipe', 'inherit, or 'ignore', or an array of these strings.
         * If passed as an array, the first element is used for `stdin`, the second for
         * `stdout`, and the third for `stderr`. A fourth element can be used to
         * specify the `stdio` behavior beyond the standard streams. See
         * {@link ChildProcess.stdio} for more information.
         *
         * @default 'pipe'
         */
        stdio?: StdioOptions | undefined;
        killSignal?: NodeJS.Signals | number | undefined;
        maxBuffer?: number | undefined;
        encoding?: BufferEncoding | "buffer" | null | undefined;
    }
    interface ExecSyncOptions extends CommonExecOptions {
        shell?: string | undefined;
    }
    interface ExecSyncOptionsWithStringEncoding extends ExecSyncOptions {
        encoding: BufferEncoding;
    }
    interface ExecSyncOptionsWithBufferEncoding extends ExecSyncOptions {
        encoding?: "buffer" | null | undefined;
    }
    /**
     * The `child_process.execSync()` method is generally identical to {@link exec} with the exception that the method will not return
     * until the child process has fully closed. When a timeout has been encountered
     * and `killSignal` is sent, the method won't return until the process has
     * completely exited. If the child process intercepts and handles the `SIGTERM` signal and doesn't exit, the parent process will wait until the child process
     * has exited.
     *
     * If the process times out or has a non-zero exit code, this method will throw.
     * The `Error` object will contain the entire result from {@link spawnSync}.
     *
     * **Never pass unsanitized user input to this function. Any input containing shell**
     * **metacharacters may be used to trigger arbitrary command execution.**
     * @since v0.11.12
     * @param command The command to run.
     * @return The stdout from the command.
     */
    function execSync(command: string): Buffer;
    function execSync(command: string, options: ExecSyncOptionsWithStringEncoding): string;
    function execSync(command: string, options: ExecSyncOptionsWithBufferEncoding): Buffer;
    function execSync(command: string, options?: ExecSyncOptions): string | Buffer;
    interface ExecFileSyncOptions extends CommonExecOptions {
        shell?: boolean | string | undefined;
    }
    interface ExecFileSyncOptionsWithStringEncoding extends ExecFileSyncOptions {
        encoding: BufferEncoding;
    }
    interface ExecFileSyncOptionsWithBufferEncoding extends ExecFileSyncOptions {
        encoding?: "buffer" | null; // specify `null`.
    }
    /**
     * The `child_process.execFileSync()` method is generally identical to {@link execFile} with the exception that the method will not
     * return until the child process has fully closed. When a timeout has been
     * encountered and `killSignal` is sent, the method won't return until the process
     * has completely exited.
     *
     * If the child process intercepts and handles the `SIGTERM` signal and
     * does not exit, the parent process will still wait until the child process has
     * exited.
     *
     * If the process times out or has a non-zero exit code, this method will throw an `Error` that will include the full result of the underlying {@link spawnSync}.
     *
     * **If the `shell` option is enabled, do not pass unsanitized user input to this**
     * **function. Any input containing shell metacharacters may be used to trigger**
     * **arbitrary command execution.**
     * @since v0.11.12
     * @param file The name or path of the executable file to run.
     * @param args List of string arguments.
     * @return The stdout from the command.
     */
    function execFileSync(file: string): Buffer;
    function execFileSync(file: string, options: ExecFileSyncOptionsWithStringEncoding): string;
    function execFileSync(file: string, options: ExecFileSyncOptionsWithBufferEncoding): Buffer;
    function execFileSync(file: string, options?: ExecFileSyncOptions): string | Buffer;
    function execFileSync(file: string, args: readonly string[]): Buffer;
    function execFileSync(
        file: string,
        args: readonly string[],
        options: ExecFileSyncOptionsWithStringEncoding,
    ): string;
    function execFileSync(
        file: string,
        args: readonly string[],
        options: ExecFileSyncOptionsWithBufferEncoding,
    ): Buffer;
    function execFileSync(file: string, args?: readonly string[], options?: ExecFileSyncOptions): string | Buffer;
}
declare module "node:child_process" {
    export * from "child_process";
}
/**
 * Clusters of Node.js processes can be used to run multiple instances of Node.js
 * that can distribute workloads among their application threads. When process isolation
 * is not needed, use the [`worker_threads`](https://nodejs.org/docs/latest-v22.x/api/worker_threads.html)
 * module instead, which allows running multiple application threads within a single Node.js instance.
 *
 * The cluster module allows easy creation of child processes that all share
 * server ports.
 *
 * ```js
 * import cluster from 'node:cluster';
 * import http from 'node:http';
 * import { availableParallelism } from 'node:os';
 * import process from 'node:process';
 *
 * const numCPUs = availableParallelism();
 *
 * if (cluster.isPrimary) {
 *   console.log(`Primary ${process.pid} is running`);
 *
 *   // Fork workers.
 *   for (let i = 0; i < numCPUs; i++) {
 *     cluster.fork();
 *   }
 *
 *   cluster.on('exit', (worker, code, signal) => {
 *     console.log(`worker ${worker.process.pid} died`);
 *   });
 * } else {
 *   // Workers can share any TCP connection
 *   // In this case it is an HTTP server
 *   http.createServer((req, res) => {
 *     res.writeHead(200);
 *     res.end('hello world\n');
 *   }).listen(8000);
 *
 *   console.log(`Worker ${process.pid} started`);
 * }
 * ```
 *
 * Running Node.js will now share port 8000 between the workers:
 *
 * ```console
 * $ node server.js
 * Primary 3596 is running
 * Worker 4324 started
 * Worker 4520 started
 * Worker 6056 started
 * Worker 5644 started
 * ```
 *
 * On Windows, it is not yet possible to set up a named pipe server in a worker.
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/cluster.js)
 */
declare module "cluster" {
    import * as child from "node:child_process";
    import EventEmitter = require("node:events");
    import * as net from "node:net";
    type SerializationType = "json" | "advanced";
    export interface ClusterSettings {
        /**
         * List of string arguments passed to the Node.js executable.
         * @default process.execArgv
         */
        execArgv?: string[] | undefined;
        /**
         * File path to worker file.
         * @default process.argv[1]
         */
        exec?: string | undefined;
        /**
         * String arguments passed to worker.
         * @default process.argv.slice(2)
         */
        args?: string[] | undefined;
        /**
         * Whether or not to send output to parent's stdio.
         * @default false
         */
        silent?: boolean | undefined;
        /**
         * Configures the stdio of forked processes. Because the cluster module relies on IPC to function, this configuration must
         * contain an `'ipc'` entry. When this option is provided, it overrides `silent`. See [`child_prcess.spawn()`](https://nodejs.org/docs/latest-v22.x/api/child_process.html#child_processspawncommand-args-options)'s
         * [`stdio`](https://nodejs.org/docs/latest-v22.x/api/child_process.html#optionsstdio).
         */
        stdio?: any[] | undefined;
        /**
         * Sets the user identity of the process. (See [`setuid(2)`](https://man7.org/linux/man-pages/man2/setuid.2.html).)
         */
        uid?: number | undefined;
        /**
         * Sets the group identity of the process. (See [`setgid(2)`](https://man7.org/linux/man-pages/man2/setgid.2.html).)
         */
        gid?: number | undefined;
        /**
         * Sets inspector port of worker. This can be a number, or a function that takes no arguments and returns a number.
         * By default each worker gets its own port, incremented from the primary's `process.debugPort`.
         */
        inspectPort?: number | (() => number) | undefined;
        /**
         * Specify the kind of serialization used for sending messages between processes. Possible values are `'json'` and `'advanced'`.
         * See [Advanced serialization for `child_process`](https://nodejs.org/docs/latest-v22.x/api/child_process.html#advanced-serialization) for more details.
         * @default false
         */
        serialization?: SerializationType | undefined;
        /**
         * Current working directory of the worker process.
         * @default undefined (inherits from parent process)
         */
        cwd?: string | undefined;
        /**
         * Hide the forked processes console window that would normally be created on Windows systems.
         * @default false
         */
        windowsHide?: boolean | undefined;
    }
    export interface Address {
        address: string;
        port: number;
        /**
         * The `addressType` is one of:
         *
         * * `4` (TCPv4)
         * * `6` (TCPv6)
         * * `-1` (Unix domain socket)
         * * `'udp4'` or `'udp6'` (UDPv4 or UDPv6)
         */
        addressType: 4 | 6 | -1 | "udp4" | "udp6";
    }
    /**
     * A `Worker` object contains all public information and method about a worker.
     * In the primary it can be obtained using `cluster.workers`. In a worker
     * it can be obtained using `cluster.worker`.
     * @since v0.7.0
     */
    export class Worker extends EventEmitter {
        /**
         * Each new worker is given its own unique id, this id is stored in the `id`.
         *
         * While a worker is alive, this is the key that indexes it in `cluster.workers`.
         * @since v0.8.0
         */
        id: number;
        /**
         * All workers are created using [`child_process.fork()`](https://nodejs.org/docs/latest-v22.x/api/child_process.html#child_processforkmodulepath-args-options), the returned object
         * from this function is stored as `.process`. In a worker, the global `process` is stored.
         *
         * See: [Child Process module](https://nodejs.org/docs/latest-v22.x/api/child_process.html#child_processforkmodulepath-args-options).
         *
         * Workers will call `process.exit(0)` if the `'disconnect'` event occurs
         * on `process` and `.exitedAfterDisconnect` is not `true`. This protects against
         * accidental disconnection.
         * @since v0.7.0
         */
        process: child.ChildProcess;
        /**
         * Send a message to a worker or primary, optionally with a handle.
         *
         * In the primary, this sends a message to a specific worker. It is identical to [`ChildProcess.send()`](https://nodejs.org/docs/latest-v22.x/api/child_process.html#subprocesssendmessage-sendhandle-options-callback).
         *
         * In a worker, this sends a message to the primary. It is identical to `process.send()`.
         *
         * This example will echo back all messages from the primary:
         *
         * ```js
         * if (cluster.isPrimary) {
         *   const worker = cluster.fork();
         *   worker.send('hi there');
         *
         * } else if (cluster.isWorker) {
         *   process.on('message', (msg) => {
         *     process.send(msg);
         *   });
         * }
         * ```
         * @since v0.7.0
         * @param options The `options` argument, if present, is an object used to parameterize the sending of certain types of handles.
         */
        send(message: child.Serializable, callback?: (error: Error | null) => void): boolean;
        send(
            message: child.Serializable,
            sendHandle: child.SendHandle,
            callback?: (error: Error | null) => void,
        ): boolean;
        send(
            message: child.Serializable,
            sendHandle: child.SendHandle,
            options?: child.MessageOptions,
            callback?: (error: Error | null) => void,
        ): boolean;
        /**
         * This function will kill the worker. In the primary worker, it does this by
         * disconnecting the `worker.process`, and once disconnected, killing with `signal`. In the worker, it does it by killing the process with `signal`.
         *
         * The `kill()` function kills the worker process without waiting for a graceful
         * disconnect, it has the same behavior as `worker.process.kill()`.
         *
         * This method is aliased as `worker.destroy()` for backwards compatibility.
         *
         * In a worker, `process.kill()` exists, but it is not this function;
         * it is [`kill()`](https://nodejs.org/docs/latest-v22.x/api/process.html#processkillpid-signal).
         * @since v0.9.12
         * @param [signal='SIGTERM'] Name of the kill signal to send to the worker process.
         */
        kill(signal?: string): void;
        destroy(signal?: string): void;
        /**
         * In a worker, this function will close all servers, wait for the `'close'` event
         * on those servers, and then disconnect the IPC channel.
         *
         * In the primary, an internal message is sent to the worker causing it to call `.disconnect()` on itself.
         *
         * Causes `.exitedAfterDisconnect` to be set.
         *
         * After a server is closed, it will no longer accept new connections,
         * but connections may be accepted by any other listening worker. Existing
         * connections will be allowed to close as usual. When no more connections exist,
         * see `server.close()`, the IPC channel to the worker will close allowing it
         * to die gracefully.
         *
         * The above applies _only_ to server connections, client connections are not
         * automatically closed by workers, and disconnect does not wait for them to close
         * before exiting.
         *
         * In a worker, `process.disconnect` exists, but it is not this function;
         * it is `disconnect()`.
         *
         * Because long living server connections may block workers from disconnecting, it
         * may be useful to send a message, so application specific actions may be taken to
         * close them. It also may be useful to implement a timeout, killing a worker if
         * the `'disconnect'` event has not been emitted after some time.
         *
         * ```js
         * if (cluster.isPrimary) {
         *   const worker = cluster.fork();
         *   let timeout;
         *
         *   worker.on('listening', (address) => {
         *     worker.send('shutdown');
         *     worker.disconnect();
         *     timeout = setTimeout(() => {
         *       worker.kill();
         *     }, 2000);
         *   });
         *
         *   worker.on('disconnect', () => {
         *     clearTimeout(timeout);
         *   });
         *
         * } else if (cluster.isWorker) {
         *   const net = require('node:net');
         *   const server = net.createServer((socket) => {
         *     // Connections never end
         *   });
         *
         *   server.listen(8000);
         *
         *   process.on('message', (msg) => {
         *     if (msg === 'shutdown') {
         *       // Initiate graceful close of any connections to server
         *     }
         *   });
         * }
         * ```
         * @since v0.7.7
         * @return A reference to `worker`.
         */
        disconnect(): void;
        /**
         * This function returns `true` if the worker is connected to its primary via its
         * IPC channel, `false` otherwise. A worker is connected to its primary after it
         * has been created. It is disconnected after the `'disconnect'` event is emitted.
         * @since v0.11.14
         */
        isConnected(): boolean;
        /**
         * This function returns `true` if the worker's process has terminated (either
         * because of exiting or being signaled). Otherwise, it returns `false`.
         *
         * ```js
         * import cluster from 'node:cluster';
         * import http from 'node:http';
         * import { availableParallelism } from 'node:os';
         * import process from 'node:process';
         *
         * const numCPUs = availableParallelism();
         *
         * if (cluster.isPrimary) {
         *   console.log(`Primary ${process.pid} is running`);
         *
         *   // Fork workers.
         *   for (let i = 0; i < numCPUs; i++) {
         *     cluster.fork();
         *   }
         *
         *   cluster.on('fork', (worker) => {
         *     console.log('worker is dead:', worker.isDead());
         *   });
         *
         *   cluster.on('exit', (worker, code, signal) => {
         *     console.log('worker is dead:', worker.isDead());
         *   });
         * } else {
         *   // Workers can share any TCP connection. In this case, it is an HTTP server.
         *   http.createServer((req, res) => {
         *     res.writeHead(200);
         *     res.end(`Current process\n ${process.pid}`);
         *     process.kill(process.pid);
         *   }).listen(8000);
         * }
         * ```
         * @since v0.11.14
         */
        isDead(): boolean;
        /**
         * This property is `true` if the worker exited due to `.disconnect()`.
         * If the worker exited any other way, it is `false`. If the
         * worker has not exited, it is `undefined`.
         *
         * The boolean `worker.exitedAfterDisconnect` allows distinguishing between
         * voluntary and accidental exit, the primary may choose not to respawn a worker
         * based on this value.
         *
         * ```js
         * cluster.on('exit', (worker, code, signal) => {
         *   if (worker.exitedAfterDisconnect === true) {
         *     console.log('Oh, it was just voluntary – no need to worry');
         *   }
         * });
         *
         * // kill worker
         * worker.kill();
         * ```
         * @since v6.0.0
         */
        exitedAfterDisconnect: boolean;
        /**
         * events.EventEmitter
         *   1. disconnect
         *   2. error
         *   3. exit
         *   4. listening
         *   5. message
         *   6. online
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "disconnect", listener: () => void): this;
        addListener(event: "error", listener: (error: Error) => void): this;
        addListener(event: "exit", listener: (code: number, signal: string) => void): this;
        addListener(event: "listening", listener: (address: Address) => void): this;
        addListener(event: "message", listener: (message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.
        addListener(event: "online", listener: () => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "disconnect"): boolean;
        emit(event: "error", error: Error): boolean;
        emit(event: "exit", code: number, signal: string): boolean;
        emit(event: "listening", address: Address): boolean;
        emit(event: "message", message: any, handle: net.Socket | net.Server): boolean;
        emit(event: "online"): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "disconnect", listener: () => void): this;
        on(event: "error", listener: (error: Error) => void): this;
        on(event: "exit", listener: (code: number, signal: string) => void): this;
        on(event: "listening", listener: (address: Address) => void): this;
        on(event: "message", listener: (message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.
        on(event: "online", listener: () => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "disconnect", listener: () => void): this;
        once(event: "error", listener: (error: Error) => void): this;
        once(event: "exit", listener: (code: number, signal: string) => void): this;
        once(event: "listening", listener: (address: Address) => void): this;
        once(event: "message", listener: (message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.
        once(event: "online", listener: () => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "disconnect", listener: () => void): this;
        prependListener(event: "error", listener: (error: Error) => void): this;
        prependListener(event: "exit", listener: (code: number, signal: string) => void): this;
        prependListener(event: "listening", listener: (address: Address) => void): this;
        prependListener(event: "message", listener: (message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.
        prependListener(event: "online", listener: () => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "disconnect", listener: () => void): this;
        prependOnceListener(event: "error", listener: (error: Error) => void): this;
        prependOnceListener(event: "exit", listener: (code: number, signal: string) => void): this;
        prependOnceListener(event: "listening", listener: (address: Address) => void): this;
        prependOnceListener(event: "message", listener: (message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.
        prependOnceListener(event: "online", listener: () => void): this;
    }
    export interface Cluster extends EventEmitter {
        disconnect(callback?: () => void): void;
        /**
         * Spawn a new worker process.
         *
         * This can only be called from the primary process.
         * @param env Key/value pairs to add to worker process environment.
         * @since v0.6.0
         */
        fork(env?: any): Worker;
        /** @deprecated since v16.0.0 - use isPrimary. */
        readonly isMaster: boolean;
        /**
         * True if the process is a primary. This is determined by the `process.env.NODE_UNIQUE_ID`. If `process.env.NODE_UNIQUE_ID`
         * is undefined, then `isPrimary` is `true`.
         * @since v16.0.0
         */
        readonly isPrimary: boolean;
        /**
         * True if the process is not a primary (it is the negation of `cluster.isPrimary`).
         * @since v0.6.0
         */
        readonly isWorker: boolean;
        /**
         * The scheduling policy, either `cluster.SCHED_RR` for round-robin or `cluster.SCHED_NONE` to leave it to the operating system. This is a
         * global setting and effectively frozen once either the first worker is spawned, or [`.setupPrimary()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clustersetupprimarysettings)
         * is called, whichever comes first.
         *
         * `SCHED_RR` is the default on all operating systems except Windows. Windows will change to `SCHED_RR` once libuv is able to effectively distribute
         * IOCP handles without incurring a large performance hit.
         *
         * `cluster.schedulingPolicy` can also be set through the `NODE_CLUSTER_SCHED_POLICY` environment variable. Valid values are `'rr'` and `'none'`.
         * @since v0.11.2
         */
        schedulingPolicy: number;
        /**
         * After calling [`.setupPrimary()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clustersetupprimarysettings)
         * (or [`.fork()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clusterforkenv)) this settings object will contain
         * the settings, including the default values.
         *
         * This object is not intended to be changed or set manually.
         * @since v0.7.1
         */
        readonly settings: ClusterSettings;
        /** @deprecated since v16.0.0 - use [`.setupPrimary()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clustersetupprimarysettings) instead. */
        setupMaster(settings?: ClusterSettings): void;
        /**
         * `setupPrimary` is used to change the default 'fork' behavior. Once called, the settings will be present in `cluster.settings`.
         *
         * Any settings changes only affect future calls to [`.fork()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clusterforkenv)
         * and have no effect on workers that are already running.
         *
         * The only attribute of a worker that cannot be set via `.setupPrimary()` is the `env` passed to
         * [`.fork()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clusterforkenv).
         *
         * The defaults above apply to the first call only; the defaults for later calls are the current values at the time of
         * `cluster.setupPrimary()` is called.
         *
         * ```js
         * import cluster from 'node:cluster';
         *
         * cluster.setupPrimary({
         *   exec: 'worker.js',
         *   args: ['--use', 'https'],
         *   silent: true,
         * });
         * cluster.fork(); // https worker
         * cluster.setupPrimary({
         *   exec: 'worker.js',
         *   args: ['--use', 'http'],
         * });
         * cluster.fork(); // http worker
         * ```
         *
         * This can only be called from the primary process.
         * @since v16.0.0
         */
        setupPrimary(settings?: ClusterSettings): void;
        /**
         * A reference to the current worker object. Not available in the primary process.
         *
         * ```js
         * import cluster from 'node:cluster';
         *
         * if (cluster.isPrimary) {
         *   console.log('I am primary');
         *   cluster.fork();
         *   cluster.fork();
         * } else if (cluster.isWorker) {
         *   console.log(`I am worker #${cluster.worker.id}`);
         * }
         * ```
         * @since v0.7.0
         */
        readonly worker?: Worker | undefined;
        /**
         * A hash that stores the active worker objects, keyed by `id` field. This makes it easy to loop through all the workers. It is only available in the primary process.
         *
         * A worker is removed from `cluster.workers` after the worker has disconnected _and_ exited. The order between these two events cannot be determined in advance. However, it
         * is guaranteed that the removal from the `cluster.workers` list happens before the last `'disconnect'` or `'exit'` event is emitted.
         *
         * ```js
         * import cluster from 'node:cluster';
         *
         * for (const worker of Object.values(cluster.workers)) {
         *   worker.send('big announcement to all workers');
         * }
         * ```
         * @since v0.7.0
         */
        readonly workers?: NodeJS.Dict<Worker> | undefined;
        readonly SCHED_NONE: number;
        readonly SCHED_RR: number;
        /**
         * events.EventEmitter
         *   1. disconnect
         *   2. exit
         *   3. fork
         *   4. listening
         *   5. message
         *   6. online
         *   7. setup
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "disconnect", listener: (worker: Worker) => void): this;
        addListener(event: "exit", listener: (worker: Worker, code: number, signal: string) => void): this;
        addListener(event: "fork", listener: (worker: Worker) => void): this;
        addListener(event: "listening", listener: (worker: Worker, address: Address) => void): this;
        addListener(
            event: "message",
            listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void,
        ): this; // the handle is a net.Socket or net.Server object, or undefined.
        addListener(event: "online", listener: (worker: Worker) => void): this;
        addListener(event: "setup", listener: (settings: ClusterSettings) => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "disconnect", worker: Worker): boolean;
        emit(event: "exit", worker: Worker, code: number, signal: string): boolean;
        emit(event: "fork", worker: Worker): boolean;
        emit(event: "listening", worker: Worker, address: Address): boolean;
        emit(event: "message", worker: Worker, message: any, handle: net.Socket | net.Server): boolean;
        emit(event: "online", worker: Worker): boolean;
        emit(event: "setup", settings: ClusterSettings): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "disconnect", listener: (worker: Worker) => void): this;
        on(event: "exit", listener: (worker: Worker, code: number, signal: string) => void): this;
        on(event: "fork", listener: (worker: Worker) => void): this;
        on(event: "listening", listener: (worker: Worker, address: Address) => void): this;
        on(event: "message", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.
        on(event: "online", listener: (worker: Worker) => void): this;
        on(event: "setup", listener: (settings: ClusterSettings) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "disconnect", listener: (worker: Worker) => void): this;
        once(event: "exit", listener: (worker: Worker, code: number, signal: string) => void): this;
        once(event: "fork", listener: (worker: Worker) => void): this;
        once(event: "listening", listener: (worker: Worker, address: Address) => void): this;
        once(event: "message", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.
        once(event: "online", listener: (worker: Worker) => void): this;
        once(event: "setup", listener: (settings: ClusterSettings) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "disconnect", listener: (worker: Worker) => void): this;
        prependListener(event: "exit", listener: (worker: Worker, code: number, signal: string) => void): this;
        prependListener(event: "fork", listener: (worker: Worker) => void): this;
        prependListener(event: "listening", listener: (worker: Worker, address: Address) => void): this;
        // the handle is a net.Socket or net.Server object, or undefined.
        prependListener(
            event: "message",
            listener: (worker: Worker, message: any, handle?: net.Socket | net.Server) => void,
        ): this;
        prependListener(event: "online", listener: (worker: Worker) => void): this;
        prependListener(event: "setup", listener: (settings: ClusterSettings) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "disconnect", listener: (worker: Worker) => void): this;
        prependOnceListener(event: "exit", listener: (worker: Worker, code: number, signal: string) => void): this;
        prependOnceListener(event: "fork", listener: (worker: Worker) => void): this;
        prependOnceListener(event: "listening", listener: (worker: Worker, address: Address) => void): this;
        // the handle is a net.Socket or net.Server object, or undefined.
        prependOnceListener(
            event: "message",
            listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void,
        ): this;
        prependOnceListener(event: "online", listener: (worker: Worker) => void): this;
        prependOnceListener(event: "setup", listener: (settings: ClusterSettings) => void): this;
    }
    const cluster: Cluster;
    export default cluster;
}
declare module "node:cluster" {
    export * from "cluster";
    export { default as default } from "cluster";
}
/**
 * The `node:console` module provides a simple debugging console that is similar to
 * the JavaScript console mechanism provided by web browsers.
 *
 * The module exports two specific components:
 *
 * * A `Console` class with methods such as `console.log()`, `console.error()`, and `console.warn()` that can be used to write to any Node.js stream.
 * * A global `console` instance configured to write to [`process.stdout`](https://nodejs.org/docs/latest-v22.x/api/process.html#processstdout) and
 * [`process.stderr`](https://nodejs.org/docs/latest-v22.x/api/process.html#processstderr). The global `console` can be used without calling `require('node:console')`.
 *
 * _**Warning**_: The global console object's methods are neither consistently
 * synchronous like the browser APIs they resemble, nor are they consistently
 * asynchronous like all other Node.js streams. See the [`note on process I/O`](https://nodejs.org/docs/latest-v22.x/api/process.html#a-note-on-process-io) for
 * more information.
 *
 * Example using the global `console`:
 *
 * ```js
 * console.log('hello world');
 * // Prints: hello world, to stdout
 * console.log('hello %s', 'world');
 * // Prints: hello world, to stdout
 * console.error(new Error('Whoops, something bad happened'));
 * // Prints error message and stack trace to stderr:
 * //   Error: Whoops, something bad happened
 * //     at [eval]:5:15
 * //     at Script.runInThisContext (node:vm:132:18)
 * //     at Object.runInThisContext (node:vm:309:38)
 * //     at node:internal/process/execution:77:19
 * //     at [eval]-wrapper:6:22
 * //     at evalScript (node:internal/process/execution:76:60)
 * //     at node:internal/main/eval_string:23:3
 *
 * const name = 'Will Robinson';
 * console.warn(`Danger ${name}! Danger!`);
 * // Prints: Danger Will Robinson! Danger!, to stderr
 * ```
 *
 * Example using the `Console` class:
 *
 * ```js
 * const out = getStreamSomehow();
 * const err = getStreamSomehow();
 * const myConsole = new console.Console(out, err);
 *
 * myConsole.log('hello world');
 * // Prints: hello world, to out
 * myConsole.log('hello %s', 'world');
 * // Prints: hello world, to out
 * myConsole.error(new Error('Whoops, something bad happened'));
 * // Prints: [Error: Whoops, something bad happened], to err
 *
 * const name = 'Will Robinson';
 * myConsole.warn(`Danger ${name}! Danger!`);
 * // Prints: Danger Will Robinson! Danger!, to err
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/console.js)
 */
declare module "console" {
    import console = require("node:console");
    export = console;
}
declare module "node:console" {
    import { InspectOptions } from "node:util";
    global {
        // This needs to be global to avoid TS2403 in case lib.dom.d.ts is present in the same build
        interface Console {
            Console: console.ConsoleConstructor;
            /**
             * `console.assert()` writes a message if `value` is [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy) or omitted. It only
             * writes a message and does not otherwise affect execution. The output always
             * starts with `"Assertion failed"`. If provided, `message` is formatted using
             * [`util.format()`](https://nodejs.org/docs/latest-v22.x/api/util.html#utilformatformat-args).
             *
             * If `value` is [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy), nothing happens.
             *
             * ```js
             * console.assert(true, 'does nothing');
             *
             * console.assert(false, 'Whoops %s work', 'didn\'t');
             * // Assertion failed: Whoops didn't work
             *
             * console.assert();
             * // Assertion failed
             * ```
             * @since v0.1.101
             * @param value The value tested for being truthy.
             * @param message All arguments besides `value` are used as error message.
             */
            assert(value: any, message?: string, ...optionalParams: any[]): void;
            /**
             * When `stdout` is a TTY, calling `console.clear()` will attempt to clear the
             * TTY. When `stdout` is not a TTY, this method does nothing.
             *
             * The specific operation of `console.clear()` can vary across operating systems
             * and terminal types. For most Linux operating systems, `console.clear()` operates similarly to the `clear` shell command. On Windows, `console.clear()` will clear only the output in the
             * current terminal viewport for the Node.js
             * binary.
             * @since v8.3.0
             */
            clear(): void;
            /**
             * Maintains an internal counter specific to `label` and outputs to `stdout` the
             * number of times `console.count()` has been called with the given `label`.
             *
             * ```js
             * > console.count()
             * default: 1
             * undefined
             * > console.count('default')
             * default: 2
             * undefined
             * > console.count('abc')
             * abc: 1
             * undefined
             * > console.count('xyz')
             * xyz: 1
             * undefined
             * > console.count('abc')
             * abc: 2
             * undefined
             * > console.count()
             * default: 3
             * undefined
             * >
             * ```
             * @since v8.3.0
             * @param [label='default'] The display label for the counter.
             */
            count(label?: string): void;
            /**
             * Resets the internal counter specific to `label`.
             *
             * ```js
             * > console.count('abc');
             * abc: 1
             * undefined
             * > console.countReset('abc');
             * undefined
             * > console.count('abc');
             * abc: 1
             * undefined
             * >
             * ```
             * @since v8.3.0
             * @param [label='default'] The display label for the counter.
             */
            countReset(label?: string): void;
            /**
             * The `console.debug()` function is an alias for {@link log}.
             * @since v8.0.0
             */
            debug(message?: any, ...optionalParams: any[]): void;
            /**
             * Uses [`util.inspect()`](https://nodejs.org/docs/latest-v22.x/api/util.html#utilinspectobject-options) on `obj` and prints the resulting string to `stdout`.
             * This function bypasses any custom `inspect()` function defined on `obj`.
             * @since v0.1.101
             */
            dir(obj: any, options?: InspectOptions): void;
            /**
             * This method calls `console.log()` passing it the arguments received.
             * This method does not produce any XML formatting.
             * @since v8.0.0
             */
            dirxml(...data: any[]): void;
            /**
             * Prints to `stderr` with newline. Multiple arguments can be passed, with the
             * first used as the primary message and all additional used as substitution
             * values similar to [`printf(3)`](http://man7.org/linux/man-pages/man3/printf.3.html)
             * (the arguments are all passed to [`util.format()`](https://nodejs.org/docs/latest-v22.x/api/util.html#utilformatformat-args)).
             *
             * ```js
             * const code = 5;
             * console.error('error #%d', code);
             * // Prints: error #5, to stderr
             * console.error('error', code);
             * // Prints: error 5, to stderr
             * ```
             *
             * If formatting elements (e.g. `%d`) are not found in the first string then
             * [`util.inspect()`](https://nodejs.org/docs/latest-v22.x/api/util.html#utilinspectobject-options) is called on each argument and the
             * resulting string values are concatenated. See [`util.format()`](https://nodejs.org/docs/latest-v22.x/api/util.html#utilformatformat-args)
             * for more information.
             * @since v0.1.100
             */
            error(message?: any, ...optionalParams: any[]): void;
            /**
             * Increases indentation of subsequent lines by spaces for `groupIndentation` length.
             *
             * If one or more `label`s are provided, those are printed first without the
             * additional indentation.
             * @since v8.5.0
             */
            group(...label: any[]): void;
            /**
             * An alias for {@link group}.
             * @since v8.5.0
             */
            groupCollapsed(...label: any[]): void;
            /**
             * Decreases indentation of subsequent lines by spaces for `groupIndentation` length.
             * @since v8.5.0
             */
            groupEnd(): void;
            /**
             * The `console.info()` function is an alias for {@link log}.
             * @since v0.1.100
             */
            info(message?: any, ...optionalParams: any[]): void;
            /**
             * Prints to `stdout` with newline. Multiple arguments can be passed, with the
             * first used as the primary message and all additional used as substitution
             * values similar to [`printf(3)`](http://man7.org/linux/man-pages/man3/printf.3.html)
             * (the arguments are all passed to [`util.format()`](https://nodejs.org/docs/latest-v22.x/api/util.html#utilformatformat-args)).
             *
             * ```js
             * const count = 5;
             * console.log('count: %d', count);
             * // Prints: count: 5, to stdout
             * console.log('count:', count);
             * // Prints: count: 5, to stdout
             * ```
             *
             * See [`util.format()`](https://nodejs.org/docs/latest-v22.x/api/util.html#utilformatformat-args) for more information.
             * @since v0.1.100
             */
            log(message?: any, ...optionalParams: any[]): void;
            /**
             * Try to construct a table with the columns of the properties of `tabularData` (or use `properties`) and rows of `tabularData` and log it. Falls back to just
             * logging the argument if it can't be parsed as tabular.
             *
             * ```js
             * // These can't be parsed as tabular data
             * console.table(Symbol());
             * // Symbol()
             *
             * console.table(undefined);
             * // undefined
             *
             * console.table([{ a: 1, b: 'Y' }, { a: 'Z', b: 2 }]);
             * // ┌─────────┬─────┬─────┐
             * // │ (index) │  a  │  b  │
             * // ├─────────┼─────┼─────┤
             * // │    0    │  1  │ 'Y' │
             * // │    1    │ 'Z' │  2  │
             * // └─────────┴─────┴─────┘
             *
             * console.table([{ a: 1, b: 'Y' }, { a: 'Z', b: 2 }], ['a']);
             * // ┌─────────┬─────┐
             * // │ (index) │  a  │
             * // ├─────────┼─────┤
             * // │    0    │  1  │
             * // │    1    │ 'Z' │
             * // └─────────┴─────┘
             * ```
             * @since v10.0.0
             * @param properties Alternate properties for constructing the table.
             */
            table(tabularData: any, properties?: readonly string[]): void;
            /**
             * Starts a timer that can be used to compute the duration of an operation. Timers
             * are identified by a unique `label`. Use the same `label` when calling {@link timeEnd} to stop the timer and output the elapsed time in
             * suitable time units to `stdout`. For example, if the elapsed
             * time is 3869ms, `console.timeEnd()` displays "3.869s".
             * @since v0.1.104
             * @param [label='default']
             */
            time(label?: string): void;
            /**
             * Stops a timer that was previously started by calling {@link time} and
             * prints the result to `stdout`:
             *
             * ```js
             * console.time('bunch-of-stuff');
             * // Do a bunch of stuff.
             * console.timeEnd('bunch-of-stuff');
             * // Prints: bunch-of-stuff: 225.438ms
             * ```
             * @since v0.1.104
             * @param [label='default']
             */
            timeEnd(label?: string): void;
            /**
             * For a timer that was previously started by calling {@link time}, prints
             * the elapsed time and other `data` arguments to `stdout`:
             *
             * ```js
             * console.time('process');
             * const value = expensiveProcess1(); // Returns 42
             * console.timeLog('process', value);
             * // Prints "process: 365.227ms 42".
             * doExpensiveProcess2(value);
             * console.timeEnd('process');
             * ```
             * @since v10.7.0
             * @param [label='default']
             */
            timeLog(label?: string, ...data: any[]): void;
            /**
             * Prints to `stderr` the string `'Trace: '`, followed by the [`util.format()`](https://nodejs.org/docs/latest-v22.x/api/util.html#utilformatformat-args)
             * formatted message and stack trace to the current position in the code.
             *
             * ```js
             * console.trace('Show me');
             * // Prints: (stack trace will vary based on where trace is called)
             * //  Trace: Show me
             * //    at repl:2:9
             * //    at REPLServer.defaultEval (repl.js:248:27)
             * //    at bound (domain.js:287:14)
             * //    at REPLServer.runBound [as eval] (domain.js:300:12)
             * //    at REPLServer.<anonymous> (repl.js:412:12)
             * //    at emitOne (events.js:82:20)
             * //    at REPLServer.emit (events.js:169:7)
             * //    at REPLServer.Interface._onLine (readline.js:210:10)
             * //    at REPLServer.Interface._line (readline.js:549:8)
             * //    at REPLServer.Interface._ttyWrite (readline.js:826:14)
             * ```
             * @since v0.1.104
             */
            trace(message?: any, ...optionalParams: any[]): void;
            /**
             * The `console.warn()` function is an alias for {@link error}.
             * @since v0.1.100
             */
            warn(message?: any, ...optionalParams: any[]): void;
            // --- Inspector mode only ---
            /**
             * This method does not display anything unless used in the inspector. The `console.profile()`
             * method starts a JavaScript CPU profile with an optional label until {@link profileEnd}
             * is called. The profile is then added to the Profile panel of the inspector.
             *
             * ```js
             * console.profile('MyLabel');
             * // Some code
             * console.profileEnd('MyLabel');
             * // Adds the profile 'MyLabel' to the Profiles panel of the inspector.
             * ```
             * @since v8.0.0
             */
            profile(label?: string): void;
            /**
             * This method does not display anything unless used in the inspector. Stops the current
             * JavaScript CPU profiling session if one has been started and prints the report to the
             * Profiles panel of the inspector. See {@link profile} for an example.
             *
             * If this method is called without a label, the most recently started profile is stopped.
             * @since v8.0.0
             */
            profileEnd(label?: string): void;
            /**
             * This method does not display anything unless used in the inspector. The `console.timeStamp()`
             * method adds an event with the label `'label'` to the Timeline panel of the inspector.
             * @since v8.0.0
             */
            timeStamp(label?: string): void;
        }
        /**
         * The `console` module provides a simple debugging console that is similar to the
         * JavaScript console mechanism provided by web browsers.
         *
         * The module exports two specific components:
         *
         * * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
         * * A global `console` instance configured to write to [`process.stdout`](https://nodejs.org/docs/latest-v22.x/api/process.html#processstdout) and
         * [`process.stderr`](https://nodejs.org/docs/latest-v22.x/api/process.html#processstderr). The global `console` can be used without calling `require('console')`.
         *
         * _**Warning**_: The global console object's methods are neither consistently
         * synchronous like the browser APIs they resemble, nor are they consistently
         * asynchronous like all other Node.js streams. See the [`note on process I/O`](https://nodejs.org/docs/latest-v22.x/api/process.html#a-note-on-process-io) for
         * more information.
         *
         * Example using the global `console`:
         *
         * ```js
         * console.log('hello world');
         * // Prints: hello world, to stdout
         * console.log('hello %s', 'world');
         * // Prints: hello world, to stdout
         * console.error(new Error('Whoops, something bad happened'));
         * // Prints error message and stack trace to stderr:
         * //   Error: Whoops, something bad happened
         * //     at [eval]:5:15
         * //     at Script.runInThisContext (node:vm:132:18)
         * //     at Object.runInThisContext (node:vm:309:38)
         * //     at node:internal/process/execution:77:19
         * //     at [eval]-wrapper:6:22
         * //     at evalScript (node:internal/process/execution:76:60)
         * //     at node:internal/main/eval_string:23:3
         *
         * const name = 'Will Robinson';
         * console.warn(`Danger ${name}! Danger!`);
         * // Prints: Danger Will Robinson! Danger!, to stderr
         * ```
         *
         * Example using the `Console` class:
         *
         * ```js
         * const out = getStreamSomehow();
         * const err = getStreamSomehow();
         * const myConsole = new console.Console(out, err);
         *
         * myConsole.log('hello world');
         * // Prints: hello world, to out
         * myConsole.log('hello %s', 'world');
         * // Prints: hello world, to out
         * myConsole.error(new Error('Whoops, something bad happened'));
         * // Prints: [Error: Whoops, something bad happened], to err
         *
         * const name = 'Will Robinson';
         * myConsole.warn(`Danger ${name}! Danger!`);
         * // Prints: Danger Will Robinson! Danger!, to err
         * ```
         * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/console.js)
         */
        namespace console {
            interface ConsoleConstructorOptions {
                stdout: NodeJS.WritableStream;
                stderr?: NodeJS.WritableStream | undefined;
                /**
                 * Ignore errors when writing to the underlying streams.
                 * @default true
                 */
                ignoreErrors?: boolean | undefined;
                /**
                 * Set color support for this `Console` instance. Setting to true enables coloring while inspecting
                 * values. Setting to `false` disables coloring while inspecting values. Setting to `'auto'` makes color
                 * support depend on the value of the `isTTY` property and the value returned by `getColorDepth()` on the
                 * respective stream. This option can not be used, if `inspectOptions.colors` is set as well.
                 * @default auto
                 */
                colorMode?: boolean | "auto" | undefined;
                /**
                 * Specifies options that are passed along to
                 * [`util.inspect()`](https://nodejs.org/docs/latest-v22.x/api/util.html#utilinspectobject-options).
                 */
                inspectOptions?: InspectOptions | undefined;
                /**
                 * Set group indentation.
                 * @default 2
                 */
                groupIndentation?: number | undefined;
            }
            interface ConsoleConstructor {
                prototype: Console;
                new(stdout: NodeJS.WritableStream, stderr?: NodeJS.WritableStream, ignoreErrors?: boolean): Console;
                new(options: ConsoleConstructorOptions): Console;
            }
        }
        var console: Console;
    }
    export = globalThis.console;
}
/** @deprecated since v6.3.0 - use constants property exposed by the relevant module instead. */
declare module "constants" {
    import { constants as osConstants, SignalConstants } from "node:os";
    import { constants as cryptoConstants } from "node:crypto";
    import { constants as fsConstants } from "node:fs";

    const exp:
        & typeof osConstants.errno
        & typeof osConstants.priority
        & SignalConstants
        & typeof cryptoConstants
        & typeof fsConstants;
    export = exp;
}

declare module "node:constants" {
    import constants = require("constants");
    export = constants;
}
/**
 * The `node:crypto` module provides cryptographic functionality that includes a
 * set of wrappers for OpenSSL's hash, HMAC, cipher, decipher, sign, and verify
 * functions.
 *
 * ```js
 * const { createHmac } = await import('node:crypto');
 *
 * const secret = 'abcdefg';
 * const hash = createHmac('sha256', secret)
 *                .update('I love cupcakes')
 *                .digest('hex');
 * console.log(hash);
 * // Prints:
 * //   c0fa1bc00531bd78ef38c628449c5102aeabd49b5dc3a2a516ea6ea959d6658e
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/crypto.js)
 */
declare module "crypto" {
    import * as stream from "node:stream";
    import { PeerCertificate } from "node:tls";
    /**
     * SPKAC is a Certificate Signing Request mechanism originally implemented by
     * Netscape and was specified formally as part of HTML5's `keygen` element.
     *
     * `<keygen>` is deprecated since [HTML 5.2](https://www.w3.org/TR/html52/changes.html#features-removed) and new projects
     * should not use this element anymore.
     *
     * The `node:crypto` module provides the `Certificate` class for working with SPKAC
     * data. The most common usage is handling output generated by the HTML5 `<keygen>` element. Node.js uses [OpenSSL's SPKAC
     * implementation](https://www.openssl.org/docs/man3.0/man1/openssl-spkac.html) internally.
     * @since v0.11.8
     */
    class Certificate {
        /**
         * ```js
         * const { Certificate } = await import('node:crypto');
         * const spkac = getSpkacSomehow();
         * const challenge = Certificate.exportChallenge(spkac);
         * console.log(challenge.toString('utf8'));
         * // Prints: the challenge as a UTF8 string
         * ```
         * @since v9.0.0
         * @param encoding The `encoding` of the `spkac` string.
         * @return The challenge component of the `spkac` data structure, which includes a public key and a challenge.
         */
        static exportChallenge(spkac: BinaryLike): Buffer;
        /**
         * ```js
         * const { Certificate } = await import('node:crypto');
         * const spkac = getSpkacSomehow();
         * const publicKey = Certificate.exportPublicKey(spkac);
         * console.log(publicKey);
         * // Prints: the public key as <Buffer ...>
         * ```
         * @since v9.0.0
         * @param encoding The `encoding` of the `spkac` string.
         * @return The public key component of the `spkac` data structure, which includes a public key and a challenge.
         */
        static exportPublicKey(spkac: BinaryLike, encoding?: string): Buffer;
        /**
         * ```js
         * import { Buffer } from 'node:buffer';
         * const { Certificate } = await import('node:crypto');
         *
         * const spkac = getSpkacSomehow();
         * console.log(Certificate.verifySpkac(Buffer.from(spkac)));
         * // Prints: true or false
         * ```
         * @since v9.0.0
         * @param encoding The `encoding` of the `spkac` string.
         * @return `true` if the given `spkac` data structure is valid, `false` otherwise.
         */
        static verifySpkac(spkac: NodeJS.ArrayBufferView): boolean;
        /**
         * @deprecated
         * @param spkac
         * @returns The challenge component of the `spkac` data structure,
         * which includes a public key and a challenge.
         */
        exportChallenge(spkac: BinaryLike): Buffer;
        /**
         * @deprecated
         * @param spkac
         * @param encoding The encoding of the spkac string.
         * @returns The public key component of the `spkac` data structure,
         * which includes a public key and a challenge.
         */
        exportPublicKey(spkac: BinaryLike, encoding?: string): Buffer;
        /**
         * @deprecated
         * @param spkac
         * @returns `true` if the given `spkac` data structure is valid,
         * `false` otherwise.
         */
        verifySpkac(spkac: NodeJS.ArrayBufferView): boolean;
    }
    namespace constants {
        // https://nodejs.org/dist/latest-v22.x/docs/api/crypto.html#crypto-constants
        const OPENSSL_VERSION_NUMBER: number;
        /** Applies multiple bug workarounds within OpenSSL. See https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html for detail. */
        const SSL_OP_ALL: number;
        /** Instructs OpenSSL to allow a non-[EC]DHE-based key exchange mode for TLS v1.3 */
        const SSL_OP_ALLOW_NO_DHE_KEX: number;
        /** Allows legacy insecure renegotiation between OpenSSL and unpatched clients or servers. See https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html. */
        const SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: number;
        /** Attempts to use the server's preferences instead of the client's when selecting a cipher. See https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html. */
        const SSL_OP_CIPHER_SERVER_PREFERENCE: number;
        /** Instructs OpenSSL to use Cisco's version identifier of DTLS_BAD_VER. */
        const SSL_OP_CISCO_ANYCONNECT: number;
        /** Instructs OpenSSL to turn on cookie exchange. */
        const SSL_OP_COOKIE_EXCHANGE: number;
        /** Instructs OpenSSL to add server-hello extension from an early version of the cryptopro draft. */
        const SSL_OP_CRYPTOPRO_TLSEXT_BUG: number;
        /** Instructs OpenSSL to disable a SSL 3.0/TLS 1.0 vulnerability workaround added in OpenSSL 0.9.6d. */
        const SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: number;
        /** Allows initial connection to servers that do not support RI. */
        const SSL_OP_LEGACY_SERVER_CONNECT: number;
        /** Instructs OpenSSL to disable support for SSL/TLS compression. */
        const SSL_OP_NO_COMPRESSION: number;
        /** Instructs OpenSSL to disable encrypt-then-MAC. */
        const SSL_OP_NO_ENCRYPT_THEN_MAC: number;
        const SSL_OP_NO_QUERY_MTU: number;
        /** Instructs OpenSSL to disable renegotiation. */
        const SSL_OP_NO_RENEGOTIATION: number;
        /** Instructs OpenSSL to always start a new session when performing renegotiation. */
        const SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: number;
        /** Instructs OpenSSL to turn off SSL v2 */
        const SSL_OP_NO_SSLv2: number;
        /** Instructs OpenSSL to turn off SSL v3 */
        const SSL_OP_NO_SSLv3: number;
        /** Instructs OpenSSL to disable use of RFC4507bis tickets. */
        const SSL_OP_NO_TICKET: number;
        /** Instructs OpenSSL to turn off TLS v1 */
        const SSL_OP_NO_TLSv1: number;
        /** Instructs OpenSSL to turn off TLS v1.1 */
        const SSL_OP_NO_TLSv1_1: number;
        /** Instructs OpenSSL to turn off TLS v1.2 */
        const SSL_OP_NO_TLSv1_2: number;
        /** Instructs OpenSSL to turn off TLS v1.3 */
        const SSL_OP_NO_TLSv1_3: number;
        /** Instructs OpenSSL server to prioritize ChaCha20-Poly1305 when the client does. This option has no effect if `SSL_OP_CIPHER_SERVER_PREFERENCE` is not enabled. */
        const SSL_OP_PRIORITIZE_CHACHA: number;
        /** Instructs OpenSSL to disable version rollback attack detection. */
        const SSL_OP_TLS_ROLLBACK_BUG: number;
        const ENGINE_METHOD_RSA: number;
        const ENGINE_METHOD_DSA: number;
        const ENGINE_METHOD_DH: number;
        const ENGINE_METHOD_RAND: number;
        const ENGINE_METHOD_EC: number;
        const ENGINE_METHOD_CIPHERS: number;
        const ENGINE_METHOD_DIGESTS: number;
        const ENGINE_METHOD_PKEY_METHS: number;
        const ENGINE_METHOD_PKEY_ASN1_METHS: number;
        const ENGINE_METHOD_ALL: number;
        const ENGINE_METHOD_NONE: number;
        const DH_CHECK_P_NOT_SAFE_PRIME: number;
        const DH_CHECK_P_NOT_PRIME: number;
        const DH_UNABLE_TO_CHECK_GENERATOR: number;
        const DH_NOT_SUITABLE_GENERATOR: number;
        const RSA_PKCS1_PADDING: number;
        const RSA_SSLV23_PADDING: number;
        const RSA_NO_PADDING: number;
        const RSA_PKCS1_OAEP_PADDING: number;
        const RSA_X931_PADDING: number;
        const RSA_PKCS1_PSS_PADDING: number;
        /** Sets the salt length for RSA_PKCS1_PSS_PADDING to the digest size when signing or verifying. */
        const RSA_PSS_SALTLEN_DIGEST: number;
        /** Sets the salt length for RSA_PKCS1_PSS_PADDING to the maximum permissible value when signing data. */
        const RSA_PSS_SALTLEN_MAX_SIGN: number;
        /** Causes the salt length for RSA_PKCS1_PSS_PADDING to be determined automatically when verifying a signature. */
        const RSA_PSS_SALTLEN_AUTO: number;
        const POINT_CONVERSION_COMPRESSED: number;
        const POINT_CONVERSION_UNCOMPRESSED: number;
        const POINT_CONVERSION_HYBRID: number;
        /** Specifies the built-in default cipher list used by Node.js (colon-separated values). */
        const defaultCoreCipherList: string;
        /** Specifies the active default cipher list used by the current Node.js process  (colon-separated values). */
        const defaultCipherList: string;
    }
    interface HashOptions extends stream.TransformOptions {
        /**
         * For XOF hash functions such as `shake256`, the
         * outputLength option can be used to specify the desired output length in bytes.
         */
        outputLength?: number | undefined;
    }
    /** @deprecated since v10.0.0 */
    const fips: boolean;
    /**
     * Creates and returns a `Hash` object that can be used to generate hash digests
     * using the given `algorithm`. Optional `options` argument controls stream
     * behavior. For XOF hash functions such as `'shake256'`, the `outputLength` option
     * can be used to specify the desired output length in bytes.
     *
     * The `algorithm` is dependent on the available algorithms supported by the
     * version of OpenSSL on the platform. Examples are `'sha256'`, `'sha512'`, etc.
     * On recent releases of OpenSSL, `openssl list -digest-algorithms` will
     * display the available digest algorithms.
     *
     * Example: generating the sha256 sum of a file
     *
     * ```js
     * import {
     *   createReadStream,
     * } from 'node:fs';
     * import { argv } from 'node:process';
     * const {
     *   createHash,
     * } = await import('node:crypto');
     *
     * const filename = argv[2];
     *
     * const hash = createHash('sha256');
     *
     * const input = createReadStream(filename);
     * input.on('readable', () => {
     *   // Only one element is going to be produced by the
     *   // hash stream.
     *   const data = input.read();
     *   if (data)
     *     hash.update(data);
     *   else {
     *     console.log(`${hash.digest('hex')} ${filename}`);
     *   }
     * });
     * ```
     * @since v0.1.92
     * @param options `stream.transform` options
     */
    function createHash(algorithm: string, options?: HashOptions): Hash;
    /**
     * Creates and returns an `Hmac` object that uses the given `algorithm` and `key`.
     * Optional `options` argument controls stream behavior.
     *
     * The `algorithm` is dependent on the available algorithms supported by the
     * version of OpenSSL on the platform. Examples are `'sha256'`, `'sha512'`, etc.
     * On recent releases of OpenSSL, `openssl list -digest-algorithms` will
     * display the available digest algorithms.
     *
     * The `key` is the HMAC key used to generate the cryptographic HMAC hash. If it is
     * a `KeyObject`, its type must be `secret`. If it is a string, please consider `caveats when using strings as inputs to cryptographic APIs`. If it was
     * obtained from a cryptographically secure source of entropy, such as {@link randomBytes} or {@link generateKey}, its length should not
     * exceed the block size of `algorithm` (e.g., 512 bits for SHA-256).
     *
     * Example: generating the sha256 HMAC of a file
     *
     * ```js
     * import {
     *   createReadStream,
     * } from 'node:fs';
     * import { argv } from 'node:process';
     * const {
     *   createHmac,
     * } = await import('node:crypto');
     *
     * const filename = argv[2];
     *
     * const hmac = createHmac('sha256', 'a secret');
     *
     * const input = createReadStream(filename);
     * input.on('readable', () => {
     *   // Only one element is going to be produced by the
     *   // hash stream.
     *   const data = input.read();
     *   if (data)
     *     hmac.update(data);
     *   else {
     *     console.log(`${hmac.digest('hex')} ${filename}`);
     *   }
     * });
     * ```
     * @since v0.1.94
     * @param options `stream.transform` options
     */
    function createHmac(algorithm: string, key: BinaryLike | KeyObject, options?: stream.TransformOptions): Hmac;
    // https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings
    type BinaryToTextEncoding = "base64" | "base64url" | "hex" | "binary";
    type CharacterEncoding = "utf8" | "utf-8" | "utf16le" | "utf-16le" | "latin1";
    type LegacyCharacterEncoding = "ascii" | "binary" | "ucs2" | "ucs-2";
    type Encoding = BinaryToTextEncoding | CharacterEncoding | LegacyCharacterEncoding;
    type ECDHKeyFormat = "compressed" | "uncompressed" | "hybrid";
    /**
     * The `Hash` class is a utility for creating hash digests of data. It can be
     * used in one of two ways:
     *
     * * As a `stream` that is both readable and writable, where data is written
     * to produce a computed hash digest on the readable side, or
     * * Using the `hash.update()` and `hash.digest()` methods to produce the
     * computed hash.
     *
     * The {@link createHash} method is used to create `Hash` instances. `Hash`objects are not to be created directly using the `new` keyword.
     *
     * Example: Using `Hash` objects as streams:
     *
     * ```js
     * const {
     *   createHash,
     * } = await import('node:crypto');
     *
     * const hash = createHash('sha256');
     *
     * hash.on('readable', () => {
     *   // Only one element is going to be produced by the
     *   // hash stream.
     *   const data = hash.read();
     *   if (data) {
     *     console.log(data.toString('hex'));
     *     // Prints:
     *     //   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50
     *   }
     * });
     *
     * hash.write('some data to hash');
     * hash.end();
     * ```
     *
     * Example: Using `Hash` and piped streams:
     *
     * ```js
     * import { createReadStream } from 'node:fs';
     * import { stdout } from 'node:process';
     * const { createHash } = await import('node:crypto');
     *
     * const hash = createHash('sha256');
     *
     * const input = createReadStream('test.js');
     * input.pipe(hash).setEncoding('hex').pipe(stdout);
     * ```
     *
     * Example: Using the `hash.update()` and `hash.digest()` methods:
     *
     * ```js
     * const {
     *   createHash,
     * } = await import('node:crypto');
     *
     * const hash = createHash('sha256');
     *
     * hash.update('some data to hash');
     * console.log(hash.digest('hex'));
     * // Prints:
     * //   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50
     * ```
     * @since v0.1.92
     */
    class Hash extends stream.Transform {
        private constructor();
        /**
         * Creates a new `Hash` object that contains a deep copy of the internal state
         * of the current `Hash` object.
         *
         * The optional `options` argument controls stream behavior. For XOF hash
         * functions such as `'shake256'`, the `outputLength` option can be used to
         * specify the desired output length in bytes.
         *
         * An error is thrown when an attempt is made to copy the `Hash` object after
         * its `hash.digest()` method has been called.
         *
         * ```js
         * // Calculate a rolling hash.
         * const {
         *   createHash,
         * } = await import('node:crypto');
         *
         * const hash = createHash('sha256');
         *
         * hash.update('one');
         * console.log(hash.copy().digest('hex'));
         *
         * hash.update('two');
         * console.log(hash.copy().digest('hex'));
         *
         * hash.update('three');
         * console.log(hash.copy().digest('hex'));
         *
         * // Etc.
         * ```
         * @since v13.1.0
         * @param options `stream.transform` options
         */
        copy(options?: HashOptions): Hash;
        /**
         * Updates the hash content with the given `data`, the encoding of which
         * is given in `inputEncoding`.
         * If `encoding` is not provided, and the `data` is a string, an
         * encoding of `'utf8'` is enforced. If `data` is a `Buffer`, `TypedArray`, or`DataView`, then `inputEncoding` is ignored.
         *
         * This can be called many times with new data as it is streamed.
         * @since v0.1.92
         * @param inputEncoding The `encoding` of the `data` string.
         */
        update(data: BinaryLike): Hash;
        update(data: string, inputEncoding: Encoding): Hash;
        /**
         * Calculates the digest of all of the data passed to be hashed (using the `hash.update()` method).
         * If `encoding` is provided a string will be returned; otherwise
         * a `Buffer` is returned.
         *
         * The `Hash` object can not be used again after `hash.digest()` method has been
         * called. Multiple calls will cause an error to be thrown.
         * @since v0.1.92
         * @param encoding The `encoding` of the return value.
         */
        digest(): Buffer;
        digest(encoding: BinaryToTextEncoding): string;
    }
    /**
     * The `Hmac` class is a utility for creating cryptographic HMAC digests. It can
     * be used in one of two ways:
     *
     * * As a `stream` that is both readable and writable, where data is written
     * to produce a computed HMAC digest on the readable side, or
     * * Using the `hmac.update()` and `hmac.digest()` methods to produce the
     * computed HMAC digest.
     *
     * The {@link createHmac} method is used to create `Hmac` instances. `Hmac`objects are not to be created directly using the `new` keyword.
     *
     * Example: Using `Hmac` objects as streams:
     *
     * ```js
     * const {
     *   createHmac,
     * } = await import('node:crypto');
     *
     * const hmac = createHmac('sha256', 'a secret');
     *
     * hmac.on('readable', () => {
     *   // Only one element is going to be produced by the
     *   // hash stream.
     *   const data = hmac.read();
     *   if (data) {
     *     console.log(data.toString('hex'));
     *     // Prints:
     *     //   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e
     *   }
     * });
     *
     * hmac.write('some data to hash');
     * hmac.end();
     * ```
     *
     * Example: Using `Hmac` and piped streams:
     *
     * ```js
     * import { createReadStream } from 'node:fs';
     * import { stdout } from 'node:process';
     * const {
     *   createHmac,
     * } = await import('node:crypto');
     *
     * const hmac = createHmac('sha256', 'a secret');
     *
     * const input = createReadStream('test.js');
     * input.pipe(hmac).pipe(stdout);
     * ```
     *
     * Example: Using the `hmac.update()` and `hmac.digest()` methods:
     *
     * ```js
     * const {
     *   createHmac,
     * } = await import('node:crypto');
     *
     * const hmac = createHmac('sha256', 'a secret');
     *
     * hmac.update('some data to hash');
     * console.log(hmac.digest('hex'));
     * // Prints:
     * //   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e
     * ```
     * @since v0.1.94
     * @deprecated Since v20.13.0 Calling `Hmac` class directly with `Hmac()` or `new Hmac()` is deprecated due to being internals, not intended for public use. Please use the {@link createHmac} method to create Hmac instances.
     */
    class Hmac extends stream.Transform {
        private constructor();
        /**
         * Updates the `Hmac` content with the given `data`, the encoding of which
         * is given in `inputEncoding`.
         * If `encoding` is not provided, and the `data` is a string, an
         * encoding of `'utf8'` is enforced. If `data` is a `Buffer`, `TypedArray`, or`DataView`, then `inputEncoding` is ignored.
         *
         * This can be called many times with new data as it is streamed.
         * @since v0.1.94
         * @param inputEncoding The `encoding` of the `data` string.
         */
        update(data: BinaryLike): Hmac;
        update(data: string, inputEncoding: Encoding): Hmac;
        /**
         * Calculates the HMAC digest of all of the data passed using `hmac.update()`.
         * If `encoding` is
         * provided a string is returned; otherwise a `Buffer` is returned;
         *
         * The `Hmac` object can not be used again after `hmac.digest()` has been
         * called. Multiple calls to `hmac.digest()` will result in an error being thrown.
         * @since v0.1.94
         * @param encoding The `encoding` of the return value.
         */
        digest(): Buffer;
        digest(encoding: BinaryToTextEncoding): string;
    }
    type KeyObjectType = "secret" | "public" | "private";
    interface KeyExportOptions<T extends KeyFormat> {
        type: "pkcs1" | "spki" | "pkcs8" | "sec1";
        format: T;
        cipher?: string | undefined;
        passphrase?: string | Buffer | undefined;
    }
    interface JwkKeyExportOptions {
        format: "jwk";
    }
    interface JsonWebKey {
        crv?: string | undefined;
        d?: string | undefined;
        dp?: string | undefined;
        dq?: string | undefined;
        e?: string | undefined;
        k?: string | undefined;
        kty?: string | undefined;
        n?: string | undefined;
        p?: string | undefined;
        q?: string | undefined;
        qi?: string | undefined;
        x?: string | undefined;
        y?: string | undefined;
        [key: string]: unknown;
    }
    interface AsymmetricKeyDetails {
        /**
         * Key size in bits (RSA, DSA).
         */
        modulusLength?: number | undefined;
        /**
         * Public exponent (RSA).
         */
        publicExponent?: bigint | undefined;
        /**
         * Name of the message digest (RSA-PSS).
         */
        hashAlgorithm?: string | undefined;
        /**
         * Name of the message digest used by MGF1 (RSA-PSS).
         */
        mgf1HashAlgorithm?: string | undefined;
        /**
         * Minimal salt length in bytes (RSA-PSS).
         */
        saltLength?: number | undefined;
        /**
         * Size of q in bits (DSA).
         */
        divisorLength?: number | undefined;
        /**
         * Name of the curve (EC).
         */
        namedCurve?: string | undefined;
    }
    /**
     * Node.js uses a `KeyObject` class to represent a symmetric or asymmetric key,
     * and each kind of key exposes different functions. The {@link createSecretKey}, {@link createPublicKey} and {@link createPrivateKey} methods are used to create `KeyObject`instances. `KeyObject`
     * objects are not to be created directly using the `new`keyword.
     *
     * Most applications should consider using the new `KeyObject` API instead of
     * passing keys as strings or `Buffer`s due to improved security features.
     *
     * `KeyObject` instances can be passed to other threads via `postMessage()`.
     * The receiver obtains a cloned `KeyObject`, and the `KeyObject` does not need to
     * be listed in the `transferList` argument.
     * @since v11.6.0
     */
    class KeyObject {
        private constructor();
        /**
         * Example: Converting a `CryptoKey` instance to a `KeyObject`:
         *
         * ```js
         * const { KeyObject } = await import('node:crypto');
         * const { subtle } = globalThis.crypto;
         *
         * const key = await subtle.generateKey({
         *   name: 'HMAC',
         *   hash: 'SHA-256',
         *   length: 256,
         * }, true, ['sign', 'verify']);
         *
         * const keyObject = KeyObject.from(key);
         * console.log(keyObject.symmetricKeySize);
         * // Prints: 32 (symmetric key size in bytes)
         * ```
         * @since v15.0.0
         */
        static from(key: webcrypto.CryptoKey): KeyObject;
        /**
         * For asymmetric keys, this property represents the type of the key. Supported key
         * types are:
         *
         * * `'rsa'` (OID 1.2.840.113549.1.1.1)
         * * `'rsa-pss'` (OID 1.2.840.113549.1.1.10)
         * * `'dsa'` (OID 1.2.840.10040.4.1)
         * * `'ec'` (OID 1.2.840.10045.2.1)
         * * `'x25519'` (OID 1.3.101.110)
         * * `'x448'` (OID 1.3.101.111)
         * * `'ed25519'` (OID 1.3.101.112)
         * * `'ed448'` (OID 1.3.101.113)
         * * `'dh'` (OID 1.2.840.113549.1.3.1)
         *
         * This property is `undefined` for unrecognized `KeyObject` types and symmetric
         * keys.
         * @since v11.6.0
         */
        asymmetricKeyType?: KeyType | undefined;
        /**
         * For asymmetric keys, this property represents the size of the embedded key in
         * bytes. This property is `undefined` for symmetric keys.
         */
        asymmetricKeySize?: number | undefined;
        /**
         * This property exists only on asymmetric keys. Depending on the type of the key,
         * this object contains information about the key. None of the information obtained
         * through this property can be used to uniquely identify a key or to compromise
         * the security of the key.
         *
         * For RSA-PSS keys, if the key material contains a `RSASSA-PSS-params` sequence,
         * the `hashAlgorithm`, `mgf1HashAlgorithm`, and `saltLength` properties will be
         * set.
         *
         * Other key details might be exposed via this API using additional attributes.
         * @since v15.7.0
         */
        asymmetricKeyDetails?: AsymmetricKeyDetails | undefined;
        /**
         * For symmetric keys, the following encoding options can be used:
         *
         * For public keys, the following encoding options can be used:
         *
         * For private keys, the following encoding options can be used:
         *
         * The result type depends on the selected encoding format, when PEM the
         * result is a string, when DER it will be a buffer containing the data
         * encoded as DER, when [JWK](https://tools.ietf.org/html/rfc7517) it will be an object.
         *
         * When [JWK](https://tools.ietf.org/html/rfc7517) encoding format was selected, all other encoding options are
         * ignored.
         *
         * PKCS#1, SEC1, and PKCS#8 type keys can be encrypted by using a combination of
         * the `cipher` and `format` options. The PKCS#8 `type` can be used with any`format` to encrypt any key algorithm (RSA, EC, or DH) by specifying a`cipher`. PKCS#1 and SEC1 can only be
         * encrypted by specifying a `cipher`when the PEM `format` is used. For maximum compatibility, use PKCS#8 for
         * encrypted private keys. Since PKCS#8 defines its own
         * encryption mechanism, PEM-level encryption is not supported when encrypting
         * a PKCS#8 key. See [RFC 5208](https://www.rfc-editor.org/rfc/rfc5208.txt) for PKCS#8 encryption and [RFC 1421](https://www.rfc-editor.org/rfc/rfc1421.txt) for
         * PKCS#1 and SEC1 encryption.
         * @since v11.6.0
         */
        export(options: KeyExportOptions<"pem">): string | Buffer;
        export(options?: KeyExportOptions<"der">): Buffer;
        export(options?: JwkKeyExportOptions): JsonWebKey;
        /**
         * Returns `true` or `false` depending on whether the keys have exactly the same
         * type, value, and parameters. This method is not [constant time](https://en.wikipedia.org/wiki/Timing_attack).
         * @since v17.7.0, v16.15.0
         * @param otherKeyObject A `KeyObject` with which to compare `keyObject`.
         */
        equals(otherKeyObject: KeyObject): boolean;
        /**
         * For secret keys, this property represents the size of the key in bytes. This
         * property is `undefined` for asymmetric keys.
         * @since v11.6.0
         */
        symmetricKeySize?: number | undefined;
        /**
         * Depending on the type of this `KeyObject`, this property is either`'secret'` for secret (symmetric) keys, `'public'` for public (asymmetric) keys
         * or `'private'` for private (asymmetric) keys.
         * @since v11.6.0
         */
        type: KeyObjectType;
    }
    type CipherCCMTypes = "aes-128-ccm" | "aes-192-ccm" | "aes-256-ccm" | "chacha20-poly1305";
    type CipherGCMTypes = "aes-128-gcm" | "aes-192-gcm" | "aes-256-gcm";
    type CipherOCBTypes = "aes-128-ocb" | "aes-192-ocb" | "aes-256-ocb";
    type BinaryLike = string | NodeJS.ArrayBufferView;
    type CipherKey = BinaryLike | KeyObject;
    interface CipherCCMOptions extends stream.TransformOptions {
        authTagLength: number;
    }
    interface CipherGCMOptions extends stream.TransformOptions {
        authTagLength?: number | undefined;
    }
    interface CipherOCBOptions extends stream.TransformOptions {
        authTagLength: number;
    }
    /**
     * Creates and returns a `Cipher` object, with the given `algorithm`, `key` and
     * initialization vector (`iv`).
     *
     * The `options` argument controls stream behavior and is optional except when a
     * cipher in CCM or OCB mode (e.g. `'aes-128-ccm'`) is used. In that case, the`authTagLength` option is required and specifies the length of the
     * authentication tag in bytes, see `CCM mode`. In GCM mode, the `authTagLength`option is not required but can be used to set the length of the authentication
     * tag that will be returned by `getAuthTag()` and defaults to 16 bytes.
     * For `chacha20-poly1305`, the `authTagLength` option defaults to 16 bytes.
     *
     * The `algorithm` is dependent on OpenSSL, examples are `'aes192'`, etc. On
     * recent OpenSSL releases, `openssl list -cipher-algorithms` will
     * display the available cipher algorithms.
     *
     * The `key` is the raw key used by the `algorithm` and `iv` is an [initialization vector](https://en.wikipedia.org/wiki/Initialization_vector). Both arguments must be `'utf8'` encoded
     * strings,`Buffers`, `TypedArray`, or `DataView`s. The `key` may optionally be
     * a `KeyObject` of type `secret`. If the cipher does not need
     * an initialization vector, `iv` may be `null`.
     *
     * When passing strings for `key` or `iv`, please consider `caveats when using strings as inputs to cryptographic APIs`.
     *
     * Initialization vectors should be unpredictable and unique; ideally, they will be
     * cryptographically random. They do not have to be secret: IVs are typically just
     * added to ciphertext messages unencrypted. It may sound contradictory that
     * something has to be unpredictable and unique, but does not have to be secret;
     * remember that an attacker must not be able to predict ahead of time what a
     * given IV will be.
     * @since v0.1.94
     * @param options `stream.transform` options
     */
    function createCipheriv(
        algorithm: CipherCCMTypes,
        key: CipherKey,
        iv: BinaryLike,
        options: CipherCCMOptions,
    ): CipherCCM;
    function createCipheriv(
        algorithm: CipherOCBTypes,
        key: CipherKey,
        iv: BinaryLike,
        options: CipherOCBOptions,
    ): CipherOCB;
    function createCipheriv(
        algorithm: CipherGCMTypes,
        key: CipherKey,
        iv: BinaryLike,
        options?: CipherGCMOptions,
    ): CipherGCM;
    function createCipheriv(
        algorithm: string,
        key: CipherKey,
        iv: BinaryLike | null,
        options?: stream.TransformOptions,
    ): Cipher;
    /**
     * Instances of the `Cipher` class are used to encrypt data. The class can be
     * used in one of two ways:
     *
     * * As a `stream` that is both readable and writable, where plain unencrypted
     * data is written to produce encrypted data on the readable side, or
     * * Using the `cipher.update()` and `cipher.final()` methods to produce
     * the encrypted data.
     *
     * The {@link createCipheriv} method is
     * used to create `Cipher` instances. `Cipher` objects are not to be created
     * directly using the `new` keyword.
     *
     * Example: Using `Cipher` objects as streams:
     *
     * ```js
     * const {
     *   scrypt,
     *   randomFill,
     *   createCipheriv,
     * } = await import('node:crypto');
     *
     * const algorithm = 'aes-192-cbc';
     * const password = 'Password used to generate key';
     *
     * // First, we'll generate the key. The key length is dependent on the algorithm.
     * // In this case for aes192, it is 24 bytes (192 bits).
     * scrypt(password, 'salt', 24, (err, key) => {
     *   if (err) throw err;
     *   // Then, we'll generate a random initialization vector
     *   randomFill(new Uint8Array(16), (err, iv) => {
     *     if (err) throw err;
     *
     *     // Once we have the key and iv, we can create and use the cipher...
     *     const cipher = createCipheriv(algorithm, key, iv);
     *
     *     let encrypted = '';
     *     cipher.setEncoding('hex');
     *
     *     cipher.on('data', (chunk) => encrypted += chunk);
     *     cipher.on('end', () => console.log(encrypted));
     *
     *     cipher.write('some clear text data');
     *     cipher.end();
     *   });
     * });
     * ```
     *
     * Example: Using `Cipher` and piped streams:
     *
     * ```js
     * import {
     *   createReadStream,
     *   createWriteStream,
     * } from 'node:fs';
     *
     * import {
     *   pipeline,
     * } from 'node:stream';
     *
     * const {
     *   scrypt,
     *   randomFill,
     *   createCipheriv,
     * } = await import('node:crypto');
     *
     * const algorithm = 'aes-192-cbc';
     * const password = 'Password used to generate key';
     *
     * // First, we'll generate the key. The key length is dependent on the algorithm.
     * // In this case for aes192, it is 24 bytes (192 bits).
     * scrypt(password, 'salt', 24, (err, key) => {
     *   if (err) throw err;
     *   // Then, we'll generate a random initialization vector
     *   randomFill(new Uint8Array(16), (err, iv) => {
     *     if (err) throw err;
     *
     *     const cipher = createCipheriv(algorithm, key, iv);
     *
     *     const input = createReadStream('test.js');
     *     const output = createWriteStream('test.enc');
     *
     *     pipeline(input, cipher, output, (err) => {
     *       if (err) throw err;
     *     });
     *   });
     * });
     * ```
     *
     * Example: Using the `cipher.update()` and `cipher.final()` methods:
     *
     * ```js
     * const {
     *   scrypt,
     *   randomFill,
     *   createCipheriv,
     * } = await import('node:crypto');
     *
     * const algorithm = 'aes-192-cbc';
     * const password = 'Password used to generate key';
     *
     * // First, we'll generate the key. The key length is dependent on the algorithm.
     * // In this case for aes192, it is 24 bytes (192 bits).
     * scrypt(password, 'salt', 24, (err, key) => {
     *   if (err) throw err;
     *   // Then, we'll generate a random initialization vector
     *   randomFill(new Uint8Array(16), (err, iv) => {
     *     if (err) throw err;
     *
     *     const cipher = createCipheriv(algorithm, key, iv);
     *
     *     let encrypted = cipher.update('some clear text data', 'utf8', 'hex');
     *     encrypted += cipher.final('hex');
     *     console.log(encrypted);
     *   });
     * });
     * ```
     * @since v0.1.94
     */
    class Cipher extends stream.Transform {
        private constructor();
        /**
         * Updates the cipher with `data`. If the `inputEncoding` argument is given,
         * the `data`argument is a string using the specified encoding. If the `inputEncoding`argument is not given, `data` must be a `Buffer`, `TypedArray`, or `DataView`. If `data` is a `Buffer`,
         * `TypedArray`, or `DataView`, then `inputEncoding` is ignored.
         *
         * The `outputEncoding` specifies the output format of the enciphered
         * data. If the `outputEncoding`is specified, a string using the specified encoding is returned. If no`outputEncoding` is provided, a `Buffer` is returned.
         *
         * The `cipher.update()` method can be called multiple times with new data until `cipher.final()` is called. Calling `cipher.update()` after `cipher.final()` will result in an error being
         * thrown.
         * @since v0.1.94
         * @param inputEncoding The `encoding` of the data.
         * @param outputEncoding The `encoding` of the return value.
         */
        update(data: BinaryLike): Buffer;
        update(data: string, inputEncoding: Encoding): Buffer;
        update(data: NodeJS.ArrayBufferView, inputEncoding: undefined, outputEncoding: Encoding): string;
        update(data: string, inputEncoding: Encoding | undefined, outputEncoding: Encoding): string;
        /**
         * Once the `cipher.final()` method has been called, the `Cipher` object can no
         * longer be used to encrypt data. Attempts to call `cipher.final()` more than
         * once will result in an error being thrown.
         * @since v0.1.94
         * @param outputEncoding The `encoding` of the return value.
         * @return Any remaining enciphered contents. If `outputEncoding` is specified, a string is returned. If an `outputEncoding` is not provided, a {@link Buffer} is returned.
         */
        final(): Buffer;
        final(outputEncoding: BufferEncoding): string;
        /**
         * When using block encryption algorithms, the `Cipher` class will automatically
         * add padding to the input data to the appropriate block size. To disable the
         * default padding call `cipher.setAutoPadding(false)`.
         *
         * When `autoPadding` is `false`, the length of the entire input data must be a
         * multiple of the cipher's block size or `cipher.final()` will throw an error.
         * Disabling automatic padding is useful for non-standard padding, for instance
         * using `0x0` instead of PKCS padding.
         *
         * The `cipher.setAutoPadding()` method must be called before `cipher.final()`.
         * @since v0.7.1
         * @param [autoPadding=true]
         * @return for method chaining.
         */
        setAutoPadding(autoPadding?: boolean): this;
    }
    interface CipherCCM extends Cipher {
        setAAD(
            buffer: NodeJS.ArrayBufferView,
            options: {
                plaintextLength: number;
            },
        ): this;
        getAuthTag(): Buffer;
    }
    interface CipherGCM extends Cipher {
        setAAD(
            buffer: NodeJS.ArrayBufferView,
            options?: {
                plaintextLength: number;
            },
        ): this;
        getAuthTag(): Buffer;
    }
    interface CipherOCB extends Cipher {
        setAAD(
            buffer: NodeJS.ArrayBufferView,
            options?: {
                plaintextLength: number;
            },
        ): this;
        getAuthTag(): Buffer;
    }
    /**
     * Creates and returns a `Decipher` object that uses the given `algorithm`, `key` and initialization vector (`iv`).
     *
     * The `options` argument controls stream behavior and is optional except when a
     * cipher in CCM or OCB mode (e.g. `'aes-128-ccm'`) is used. In that case, the `authTagLength` option is required and specifies the length of the
     * authentication tag in bytes, see `CCM mode`. In GCM mode, the `authTagLength` option is not required but can be used to restrict accepted authentication tags
     * to those with the specified length.
     * For `chacha20-poly1305`, the `authTagLength` option defaults to 16 bytes.
     *
     * The `algorithm` is dependent on OpenSSL, examples are `'aes192'`, etc. On
     * recent OpenSSL releases, `openssl list -cipher-algorithms` will
     * display the available cipher algorithms.
     *
     * The `key` is the raw key used by the `algorithm` and `iv` is an [initialization vector](https://en.wikipedia.org/wiki/Initialization_vector). Both arguments must be `'utf8'` encoded
     * strings,`Buffers`, `TypedArray`, or `DataView`s. The `key` may optionally be
     * a `KeyObject` of type `secret`. If the cipher does not need
     * an initialization vector, `iv` may be `null`.
     *
     * When passing strings for `key` or `iv`, please consider `caveats when using strings as inputs to cryptographic APIs`.
     *
     * Initialization vectors should be unpredictable and unique; ideally, they will be
     * cryptographically random. They do not have to be secret: IVs are typically just
     * added to ciphertext messages unencrypted. It may sound contradictory that
     * something has to be unpredictable and unique, but does not have to be secret;
     * remember that an attacker must not be able to predict ahead of time what a given
     * IV will be.
     * @since v0.1.94
     * @param options `stream.transform` options
     */
    function createDecipheriv(
        algorithm: CipherCCMTypes,
        key: CipherKey,
        iv: BinaryLike,
        options: CipherCCMOptions,
    ): DecipherCCM;
    function createDecipheriv(
        algorithm: CipherOCBTypes,
        key: CipherKey,
        iv: BinaryLike,
        options: CipherOCBOptions,
    ): DecipherOCB;
    function createDecipheriv(
        algorithm: CipherGCMTypes,
        key: CipherKey,
        iv: BinaryLike,
        options?: CipherGCMOptions,
    ): DecipherGCM;
    function createDecipheriv(
        algorithm: string,
        key: CipherKey,
        iv: BinaryLike | null,
        options?: stream.TransformOptions,
    ): Decipher;
    /**
     * Instances of the `Decipher` class are used to decrypt data. The class can be
     * used in one of two ways:
     *
     * * As a `stream` that is both readable and writable, where plain encrypted
     * data is written to produce unencrypted data on the readable side, or
     * * Using the `decipher.update()` and `decipher.final()` methods to
     * produce the unencrypted data.
     *
     * The {@link createDecipheriv} method is
     * used to create `Decipher` instances. `Decipher` objects are not to be created
     * directly using the `new` keyword.
     *
     * Example: Using `Decipher` objects as streams:
     *
     * ```js
     * import { Buffer } from 'node:buffer';
     * const {
     *   scryptSync,
     *   createDecipheriv,
     * } = await import('node:crypto');
     *
     * const algorithm = 'aes-192-cbc';
     * const password = 'Password used to generate key';
     * // Key length is dependent on the algorithm. In this case for aes192, it is
     * // 24 bytes (192 bits).
     * // Use the async `crypto.scrypt()` instead.
     * const key = scryptSync(password, 'salt', 24);
     * // The IV is usually passed along with the ciphertext.
     * const iv = Buffer.alloc(16, 0); // Initialization vector.
     *
     * const decipher = createDecipheriv(algorithm, key, iv);
     *
     * let decrypted = '';
     * decipher.on('readable', () => {
     *   let chunk;
     *   while (null !== (chunk = decipher.read())) {
     *     decrypted += chunk.toString('utf8');
     *   }
     * });
     * decipher.on('end', () => {
     *   console.log(decrypted);
     *   // Prints: some clear text data
     * });
     *
     * // Encrypted with same algorithm, key and iv.
     * const encrypted =
     *   'e5f79c5915c02171eec6b212d5520d44480993d7d622a7c4c2da32f6efda0ffa';
     * decipher.write(encrypted, 'hex');
     * decipher.end();
     * ```
     *
     * Example: Using `Decipher` and piped streams:
     *
     * ```js
     * import {
     *   createReadStream,
     *   createWriteStream,
     * } from 'node:fs';
     * import { Buffer } from 'node:buffer';
     * const {
     *   scryptSync,
     *   createDecipheriv,
     * } = await import('node:crypto');
     *
     * const algorithm = 'aes-192-cbc';
     * const password = 'Password used to generate key';
     * // Use the async `crypto.scrypt()` instead.
     * const key = scryptSync(password, 'salt', 24);
     * // The IV is usually passed along with the ciphertext.
     * const iv = Buffer.alloc(16, 0); // Initialization vector.
     *
     * const decipher = createDecipheriv(algorithm, key, iv);
     *
     * const input = createReadStream('test.enc');
     * const output = createWriteStream('test.js');
     *
     * input.pipe(decipher).pipe(output);
     * ```
     *
     * Example: Using the `decipher.update()` and `decipher.final()` methods:
     *
     * ```js
     * import { Buffer } from 'node:buffer';
     * const {
     *   scryptSync,
     *   createDecipheriv,
     * } = await import('node:crypto');
     *
     * const algorithm = 'aes-192-cbc';
     * const password = 'Password used to generate key';
     * // Use the async `crypto.scrypt()` instead.
     * const key = scryptSync(password, 'salt', 24);
     * // The IV is usually passed along with the ciphertext.
     * const iv = Buffer.alloc(16, 0); // Initialization vector.
     *
     * const decipher = createDecipheriv(algorithm, key, iv);
     *
     * // Encrypted using same algorithm, key and iv.
     * const encrypted =
     *   'e5f79c5915c02171eec6b212d5520d44480993d7d622a7c4c2da32f6efda0ffa';
     * let decrypted = decipher.update(encrypted, 'hex', 'utf8');
     * decrypted += decipher.final('utf8');
     * console.log(decrypted);
     * // Prints: some clear text data
     * ```
     * @since v0.1.94
     */
    class Decipher extends stream.Transform {
        private constructor();
        /**
         * Updates the decipher with `data`. If the `inputEncoding` argument is given,
         * the `data` argument is a string using the specified encoding. If the `inputEncoding` argument is not given, `data` must be a `Buffer`. If `data` is a `Buffer` then `inputEncoding` is
         * ignored.
         *
         * The `outputEncoding` specifies the output format of the enciphered
         * data. If the `outputEncoding` is specified, a string using the specified encoding is returned. If no `outputEncoding` is provided, a `Buffer` is returned.
         *
         * The `decipher.update()` method can be called multiple times with new data until `decipher.final()` is called. Calling `decipher.update()` after `decipher.final()` will result in an error
         * being thrown.
         * @since v0.1.94
         * @param inputEncoding The `encoding` of the `data` string.
         * @param outputEncoding The `encoding` of the return value.
         */
        update(data: NodeJS.ArrayBufferView): Buffer;
        update(data: string, inputEncoding: Encoding): Buffer;
        update(data: NodeJS.ArrayBufferView, inputEncoding: undefined, outputEncoding: Encoding): string;
        update(data: string, inputEncoding: Encoding | undefined, outputEncoding: Encoding): string;
        /**
         * Once the `decipher.final()` method has been called, the `Decipher` object can
         * no longer be used to decrypt data. Attempts to call `decipher.final()` more
         * than once will result in an error being thrown.
         * @since v0.1.94
         * @param outputEncoding The `encoding` of the return value.
         * @return Any remaining deciphered contents. If `outputEncoding` is specified, a string is returned. If an `outputEncoding` is not provided, a {@link Buffer} is returned.
         */
        final(): Buffer;
        final(outputEncoding: BufferEncoding): string;
        /**
         * When data has been encrypted without standard block padding, calling `decipher.setAutoPadding(false)` will disable automatic padding to prevent `decipher.final()` from checking for and
         * removing padding.
         *
         * Turning auto padding off will only work if the input data's length is a
         * multiple of the ciphers block size.
         *
         * The `decipher.setAutoPadding()` method must be called before `decipher.final()`.
         * @since v0.7.1
         * @param [autoPadding=true]
         * @return for method chaining.
         */
        setAutoPadding(auto_padding?: boolean): this;
    }
    interface DecipherCCM extends Decipher {
        setAuthTag(buffer: NodeJS.ArrayBufferView): this;
        setAAD(
            buffer: NodeJS.ArrayBufferView,
            options: {
                plaintextLength: number;
            },
        ): this;
    }
    interface DecipherGCM extends Decipher {
        setAuthTag(buffer: NodeJS.ArrayBufferView): this;
        setAAD(
            buffer: NodeJS.ArrayBufferView,
            options?: {
                plaintextLength: number;
            },
        ): this;
    }
    interface DecipherOCB extends Decipher {
        setAuthTag(buffer: NodeJS.ArrayBufferView): this;
        setAAD(
            buffer: NodeJS.ArrayBufferView,
            options?: {
                plaintextLength: number;
            },
        ): this;
    }
    interface PrivateKeyInput {
        key: string | Buffer;
        format?: KeyFormat | undefined;
        type?: "pkcs1" | "pkcs8" | "sec1" | undefined;
        passphrase?: string | Buffer | undefined;
        encoding?: string | undefined;
    }
    interface PublicKeyInput {
        key: string | Buffer;
        format?: KeyFormat | undefined;
        type?: "pkcs1" | "spki" | undefined;
        encoding?: string | undefined;
    }
    /**
     * Asynchronously generates a new random secret key of the given `length`. The `type` will determine which validations will be performed on the `length`.
     *
     * ```js
     * const {
     *   generateKey,
     * } = await import('node:crypto');
     *
     * generateKey('hmac', { length: 512 }, (err, key) => {
     *   if (err) throw err;
     *   console.log(key.export().toString('hex'));  // 46e..........620
     * });
     * ```
     *
     * The size of a generated HMAC key should not exceed the block size of the
     * underlying hash function. See {@link createHmac} for more information.
     * @since v15.0.0
     * @param type The intended use of the generated secret key. Currently accepted values are `'hmac'` and `'aes'`.
     */
    function generateKey(
        type: "hmac" | "aes",
        options: {
            length: number;
        },
        callback: (err: Error | null, key: KeyObject) => void,
    ): void;
    /**
     * Synchronously generates a new random secret key of the given `length`. The `type` will determine which validations will be performed on the `length`.
     *
     * ```js
     * const {
     *   generateKeySync,
     * } = await import('node:crypto');
     *
     * const key = generateKeySync('hmac', { length: 512 });
     * console.log(key.export().toString('hex'));  // e89..........41e
     * ```
     *
     * The size of a generated HMAC key should not exceed the block size of the
     * underlying hash function. See {@link createHmac} for more information.
     * @since v15.0.0
     * @param type The intended use of the generated secret key. Currently accepted values are `'hmac'` and `'aes'`.
     */
    function generateKeySync(
        type: "hmac" | "aes",
        options: {
            length: number;
        },
    ): KeyObject;
    interface JsonWebKeyInput {
        key: JsonWebKey;
        format: "jwk";
    }
    /**
     * Creates and returns a new key object containing a private key. If `key` is a
     * string or `Buffer`, `format` is assumed to be `'pem'`; otherwise, `key` must be an object with the properties described above.
     *
     * If the private key is encrypted, a `passphrase` must be specified. The length
     * of the passphrase is limited to 1024 bytes.
     * @since v11.6.0
     */
    function createPrivateKey(key: PrivateKeyInput | string | Buffer | JsonWebKeyInput): KeyObject;
    /**
     * Creates and returns a new key object containing a public key. If `key` is a
     * string or `Buffer`, `format` is assumed to be `'pem'`; if `key` is a `KeyObject` with type `'private'`, the public key is derived from the given private key;
     * otherwise, `key` must be an object with the properties described above.
     *
     * If the format is `'pem'`, the `'key'` may also be an X.509 certificate.
     *
     * Because public keys can be derived from private keys, a private key may be
     * passed instead of a public key. In that case, this function behaves as if {@link createPrivateKey} had been called, except that the type of the
     * returned `KeyObject` will be `'public'` and that the private key cannot be
     * extracted from the returned `KeyObject`. Similarly, if a `KeyObject` with type `'private'` is given, a new `KeyObject` with type `'public'` will be returned
     * and it will be impossible to extract the private key from the returned object.
     * @since v11.6.0
     */
    function createPublicKey(key: PublicKeyInput | string | Buffer | KeyObject | JsonWebKeyInput): KeyObject;
    /**
     * Creates and returns a new key object containing a secret key for symmetric
     * encryption or `Hmac`.
     * @since v11.6.0
     * @param encoding The string encoding when `key` is a string.
     */
    function createSecretKey(key: NodeJS.ArrayBufferView): KeyObject;
    function createSecretKey(key: string, encoding: BufferEncoding): KeyObject;
    /**
     * Creates and returns a `Sign` object that uses the given `algorithm`. Use {@link getHashes} to obtain the names of the available digest algorithms.
     * Optional `options` argument controls the `stream.Writable` behavior.
     *
     * In some cases, a `Sign` instance can be created using the name of a signature
     * algorithm, such as `'RSA-SHA256'`, instead of a digest algorithm. This will use
     * the corresponding digest algorithm. This does not work for all signature
     * algorithms, such as `'ecdsa-with-SHA256'`, so it is best to always use digest
     * algorithm names.
     * @since v0.1.92
     * @param options `stream.Writable` options
     */
    function createSign(algorithm: string, options?: stream.WritableOptions): Sign;
    type DSAEncoding = "der" | "ieee-p1363";
    interface SigningOptions {
        /**
         * @see crypto.constants.RSA_PKCS1_PADDING
         */
        padding?: number | undefined;
        saltLength?: number | undefined;
        dsaEncoding?: DSAEncoding | undefined;
    }
    interface SignPrivateKeyInput extends PrivateKeyInput, SigningOptions {}
    interface SignKeyObjectInput extends SigningOptions {
        key: KeyObject;
    }
    interface SignJsonWebKeyInput extends JsonWebKeyInput, SigningOptions {}
    interface VerifyPublicKeyInput extends PublicKeyInput, SigningOptions {}
    interface VerifyKeyObjectInput extends SigningOptions {
        key: KeyObject;
    }
    interface VerifyJsonWebKeyInput extends JsonWebKeyInput, SigningOptions {}
    type KeyLike = string | Buffer | KeyObject;
    /**
     * The `Sign` class is a utility for generating signatures. It can be used in one
     * of two ways:
     *
     * * As a writable `stream`, where data to be signed is written and the `sign.sign()` method is used to generate and return the signature, or
     * * Using the `sign.update()` and `sign.sign()` methods to produce the
     * signature.
     *
     * The {@link createSign} method is used to create `Sign` instances. The
     * argument is the string name of the hash function to use. `Sign` objects are not
     * to be created directly using the `new` keyword.
     *
     * Example: Using `Sign` and `Verify` objects as streams:
     *
     * ```js
     * const {
     *   generateKeyPairSync,
     *   createSign,
     *   createVerify,
     * } = await import('node:crypto');
     *
     * const { privateKey, publicKey } = generateKeyPairSync('ec', {
     *   namedCurve: 'sect239k1',
     * });
     *
     * const sign = createSign('SHA256');
     * sign.write('some data to sign');
     * sign.end();
     * const signature = sign.sign(privateKey, 'hex');
     *
     * const verify = createVerify('SHA256');
     * verify.write('some data to sign');
     * verify.end();
     * console.log(verify.verify(publicKey, signature, 'hex'));
     * // Prints: true
     * ```
     *
     * Example: Using the `sign.update()` and `verify.update()` methods:
     *
     * ```js
     * const {
     *   generateKeyPairSync,
     *   createSign,
     *   createVerify,
     * } = await import('node:crypto');
     *
     * const { privateKey, publicKey } = generateKeyPairSync('rsa', {
     *   modulusLength: 2048,
     * });
     *
     * const sign = createSign('SHA256');
     * sign.update('some data to sign');
     * sign.end();
     * const signature = sign.sign(privateKey);
     *
     * const verify = createVerify('SHA256');
     * verify.update('some data to sign');
     * verify.end();
     * console.log(verify.verify(publicKey, signature));
     * // Prints: true
     * ```
     * @since v0.1.92
     */
    class Sign extends stream.Writable {
        private constructor();
        /**
         * Updates the `Sign` content with the given `data`, the encoding of which
         * is given in `inputEncoding`.
         * If `encoding` is not provided, and the `data` is a string, an
         * encoding of `'utf8'` is enforced. If `data` is a `Buffer`, `TypedArray`, or`DataView`, then `inputEncoding` is ignored.
         *
         * This can be called many times with new data as it is streamed.
         * @since v0.1.92
         * @param inputEncoding The `encoding` of the `data` string.
         */
        update(data: BinaryLike): this;
        update(data: string, inputEncoding: Encoding): this;
        /**
         * Calculates the signature on all the data passed through using either `sign.update()` or `sign.write()`.
         *
         * If `privateKey` is not a `KeyObject`, this function behaves as if `privateKey` had been passed to {@link createPrivateKey}. If it is an
         * object, the following additional properties can be passed:
         *
         * If `outputEncoding` is provided a string is returned; otherwise a `Buffer` is returned.
         *
         * The `Sign` object can not be again used after `sign.sign()` method has been
         * called. Multiple calls to `sign.sign()` will result in an error being thrown.
         * @since v0.1.92
         */
        sign(privateKey: KeyLike | SignKeyObjectInput | SignPrivateKeyInput | SignJsonWebKeyInput): Buffer;
        sign(
            privateKey: KeyLike | SignKeyObjectInput | SignPrivateKeyInput | SignJsonWebKeyInput,
            outputFormat: BinaryToTextEncoding,
        ): string;
    }
    /**
     * Creates and returns a `Verify` object that uses the given algorithm.
     * Use {@link getHashes} to obtain an array of names of the available
     * signing algorithms. Optional `options` argument controls the `stream.Writable` behavior.
     *
     * In some cases, a `Verify` instance can be created using the name of a signature
     * algorithm, such as `'RSA-SHA256'`, instead of a digest algorithm. This will use
     * the corresponding digest algorithm. This does not work for all signature
     * algorithms, such as `'ecdsa-with-SHA256'`, so it is best to always use digest
     * algorithm names.
     * @since v0.1.92
     * @param options `stream.Writable` options
     */
    function createVerify(algorithm: string, options?: stream.WritableOptions): Verify;
    /**
     * The `Verify` class is a utility for verifying signatures. It can be used in one
     * of two ways:
     *
     * * As a writable `stream` where written data is used to validate against the
     * supplied signature, or
     * * Using the `verify.update()` and `verify.verify()` methods to verify
     * the signature.
     *
     * The {@link createVerify} method is used to create `Verify` instances. `Verify` objects are not to be created directly using the `new` keyword.
     *
     * See `Sign` for examples.
     * @since v0.1.92
     */
    class Verify extends stream.Writable {
        private constructor();
        /**
         * Updates the `Verify` content with the given `data`, the encoding of which
         * is given in `inputEncoding`.
         * If `inputEncoding` is not provided, and the `data` is a string, an
         * encoding of `'utf8'` is enforced. If `data` is a `Buffer`, `TypedArray`, or `DataView`, then `inputEncoding` is ignored.
         *
         * This can be called many times with new data as it is streamed.
         * @since v0.1.92
         * @param inputEncoding The `encoding` of the `data` string.
         */
        update(data: BinaryLike): Verify;
        update(data: string, inputEncoding: Encoding): Verify;
        /**
         * Verifies the provided data using the given `object` and `signature`.
         *
         * If `object` is not a `KeyObject`, this function behaves as if `object` had been passed to {@link createPublicKey}. If it is an
         * object, the following additional properties can be passed:
         *
         * The `signature` argument is the previously calculated signature for the data, in
         * the `signatureEncoding`.
         * If a `signatureEncoding` is specified, the `signature` is expected to be a
         * string; otherwise `signature` is expected to be a `Buffer`, `TypedArray`, or `DataView`.
         *
         * The `verify` object can not be used again after `verify.verify()` has been
         * called. Multiple calls to `verify.verify()` will result in an error being
         * thrown.
         *
         * Because public keys can be derived from private keys, a private key may
         * be passed instead of a public key.
         * @since v0.1.92
         */
        verify(
            object: KeyLike | VerifyKeyObjectInput | VerifyPublicKeyInput | VerifyJsonWebKeyInput,
            signature: NodeJS.ArrayBufferView,
        ): boolean;
        verify(
            object: KeyLike | VerifyKeyObjectInput | VerifyPublicKeyInput | VerifyJsonWebKeyInput,
            signature: string,
            signature_format?: BinaryToTextEncoding,
        ): boolean;
    }
    /**
     * Creates a `DiffieHellman` key exchange object using the supplied `prime` and an
     * optional specific `generator`.
     *
     * The `generator` argument can be a number, string, or `Buffer`. If `generator` is not specified, the value `2` is used.
     *
     * If `primeEncoding` is specified, `prime` is expected to be a string; otherwise
     * a `Buffer`, `TypedArray`, or `DataView` is expected.
     *
     * If `generatorEncoding` is specified, `generator` is expected to be a string;
     * otherwise a number, `Buffer`, `TypedArray`, or `DataView` is expected.
     * @since v0.11.12
     * @param primeEncoding The `encoding` of the `prime` string.
     * @param [generator=2]
     * @param generatorEncoding The `encoding` of the `generator` string.
     */
    function createDiffieHellman(primeLength: number, generator?: number): DiffieHellman;
    function createDiffieHellman(
        prime: ArrayBuffer | NodeJS.ArrayBufferView,
        generator?: number | ArrayBuffer | NodeJS.ArrayBufferView,
    ): DiffieHellman;
    function createDiffieHellman(
        prime: ArrayBuffer | NodeJS.ArrayBufferView,
        generator: string,
        generatorEncoding: BinaryToTextEncoding,
    ): DiffieHellman;
    function createDiffieHellman(
        prime: string,
        primeEncoding: BinaryToTextEncoding,
        generator?: number | ArrayBuffer | NodeJS.ArrayBufferView,
    ): DiffieHellman;
    function createDiffieHellman(
        prime: string,
        primeEncoding: BinaryToTextEncoding,
        generator: string,
        generatorEncoding: BinaryToTextEncoding,
    ): DiffieHellman;
    /**
     * The `DiffieHellman` class is a utility for creating Diffie-Hellman key
     * exchanges.
     *
     * Instances of the `DiffieHellman` class can be created using the {@link createDiffieHellman} function.
     *
     * ```js
     * import assert from 'node:assert';
     *
     * const {
     *   createDiffieHellman,
     * } = await import('node:crypto');
     *
     * // Generate Alice's keys...
     * const alice = createDiffieHellman(2048);
     * const aliceKey = alice.generateKeys();
     *
     * // Generate Bob's keys...
     * const bob = createDiffieHellman(alice.getPrime(), alice.getGenerator());
     * const bobKey = bob.generateKeys();
     *
     * // Exchange and generate the secret...
     * const aliceSecret = alice.computeSecret(bobKey);
     * const bobSecret = bob.computeSecret(aliceKey);
     *
     * // OK
     * assert.strictEqual(aliceSecret.toString('hex'), bobSecret.toString('hex'));
     * ```
     * @since v0.5.0
     */
    class DiffieHellman {
        private constructor();
        /**
         * Generates private and public Diffie-Hellman key values unless they have been
         * generated or computed already, and returns
         * the public key in the specified `encoding`. This key should be
         * transferred to the other party.
         * If `encoding` is provided a string is returned; otherwise a `Buffer` is returned.
         *
         * This function is a thin wrapper around [`DH_generate_key()`](https://www.openssl.org/docs/man3.0/man3/DH_generate_key.html). In particular,
         * once a private key has been generated or set, calling this function only updates
         * the public key but does not generate a new private key.
         * @since v0.5.0
         * @param encoding The `encoding` of the return value.
         */
        generateKeys(): Buffer;
        generateKeys(encoding: BinaryToTextEncoding): string;
        /**
         * Computes the shared secret using `otherPublicKey` as the other
         * party's public key and returns the computed shared secret. The supplied
         * key is interpreted using the specified `inputEncoding`, and secret is
         * encoded using specified `outputEncoding`.
         * If the `inputEncoding` is not
         * provided, `otherPublicKey` is expected to be a `Buffer`, `TypedArray`, or `DataView`.
         *
         * If `outputEncoding` is given a string is returned; otherwise, a `Buffer` is returned.
         * @since v0.5.0
         * @param inputEncoding The `encoding` of an `otherPublicKey` string.
         * @param outputEncoding The `encoding` of the return value.
         */
        computeSecret(otherPublicKey: NodeJS.ArrayBufferView, inputEncoding?: null, outputEncoding?: null): Buffer;
        computeSecret(otherPublicKey: string, inputEncoding: BinaryToTextEncoding, outputEncoding?: null): Buffer;
        computeSecret(
            otherPublicKey: NodeJS.ArrayBufferView,
            inputEncoding: null,
            outputEncoding: BinaryToTextEncoding,
        ): string;
        computeSecret(
            otherPublicKey: string,
            inputEncoding: BinaryToTextEncoding,
            outputEncoding: BinaryToTextEncoding,
        ): string;
        /**
         * Returns the Diffie-Hellman prime in the specified `encoding`.
         * If `encoding` is provided a string is
         * returned; otherwise a `Buffer` is returned.
         * @since v0.5.0
         * @param encoding The `encoding` of the return value.
         */
        getPrime(): Buffer;
        getPrime(encoding: BinaryToTextEncoding): string;
        /**
         * Returns the Diffie-Hellman generator in the specified `encoding`.
         * If `encoding` is provided a string is
         * returned; otherwise a `Buffer` is returned.
         * @since v0.5.0
         * @param encoding The `encoding` of the return value.
         */
        getGenerator(): Buffer;
        getGenerator(encoding: BinaryToTextEncoding): string;
        /**
         * Returns the Diffie-Hellman public key in the specified `encoding`.
         * If `encoding` is provided a
         * string is returned; otherwise a `Buffer` is returned.
         * @since v0.5.0
         * @param encoding The `encoding` of the return value.
         */
        getPublicKey(): Buffer;
        getPublicKey(encoding: BinaryToTextEncoding): string;
        /**
         * Returns the Diffie-Hellman private key in the specified `encoding`.
         * If `encoding` is provided a
         * string is returned; otherwise a `Buffer` is returned.
         * @since v0.5.0
         * @param encoding The `encoding` of the return value.
         */
        getPrivateKey(): Buffer;
        getPrivateKey(encoding: BinaryToTextEncoding): string;
        /**
         * Sets the Diffie-Hellman public key. If the `encoding` argument is provided, `publicKey` is expected
         * to be a string. If no `encoding` is provided, `publicKey` is expected
         * to be a `Buffer`, `TypedArray`, or `DataView`.
         * @since v0.5.0
         * @param encoding The `encoding` of the `publicKey` string.
         */
        setPublicKey(publicKey: NodeJS.ArrayBufferView): void;
        setPublicKey(publicKey: string, encoding: BufferEncoding): void;
        /**
         * Sets the Diffie-Hellman private key. If the `encoding` argument is provided,`privateKey` is expected
         * to be a string. If no `encoding` is provided, `privateKey` is expected
         * to be a `Buffer`, `TypedArray`, or `DataView`.
         *
         * This function does not automatically compute the associated public key. Either `diffieHellman.setPublicKey()` or `diffieHellman.generateKeys()` can be
         * used to manually provide the public key or to automatically derive it.
         * @since v0.5.0
         * @param encoding The `encoding` of the `privateKey` string.
         */
        setPrivateKey(privateKey: NodeJS.ArrayBufferView): void;
        setPrivateKey(privateKey: string, encoding: BufferEncoding): void;
        /**
         * A bit field containing any warnings and/or errors resulting from a check
         * performed during initialization of the `DiffieHellman` object.
         *
         * The following values are valid for this property (as defined in `node:constants` module):
         *
         * * `DH_CHECK_P_NOT_SAFE_PRIME`
         * * `DH_CHECK_P_NOT_PRIME`
         * * `DH_UNABLE_TO_CHECK_GENERATOR`
         * * `DH_NOT_SUITABLE_GENERATOR`
         * @since v0.11.12
         */
        verifyError: number;
    }
    /**
     * The `DiffieHellmanGroup` class takes a well-known modp group as its argument.
     * It works the same as `DiffieHellman`, except that it does not allow changing its keys after creation.
     * In other words, it does not implement `setPublicKey()` or `setPrivateKey()` methods.
     *
     * ```js
     * const { createDiffieHellmanGroup } = await import('node:crypto');
     * const dh = createDiffieHellmanGroup('modp1');
     * ```
     * The name (e.g. `'modp1'`) is taken from [RFC 2412](https://www.rfc-editor.org/rfc/rfc2412.txt) (modp1 and 2) and [RFC 3526](https://www.rfc-editor.org/rfc/rfc3526.txt):
     * ```bash
     * $ perl -ne 'print "$1\n" if /"(modp\d+)"/' src/node_crypto_groups.h
     * modp1  #  768 bits
     * modp2  # 1024 bits
     * modp5  # 1536 bits
     * modp14 # 2048 bits
     * modp15 # etc.
     * modp16
     * modp17
     * modp18
     * ```
     * @since v0.7.5
     */
    const DiffieHellmanGroup: DiffieHellmanGroupConstructor;
    interface DiffieHellmanGroupConstructor {
        new(name: string): DiffieHellmanGroup;
        (name: string): DiffieHellmanGroup;
        readonly prototype: DiffieHellmanGroup;
    }
    type DiffieHellmanGroup = Omit<DiffieHellman, "setPublicKey" | "setPrivateKey">;
    /**
     * Creates a predefined `DiffieHellmanGroup` key exchange object. The
     * supported groups are listed in the documentation for `DiffieHellmanGroup`.
     *
     * The returned object mimics the interface of objects created by {@link createDiffieHellman}, but will not allow changing
     * the keys (with `diffieHellman.setPublicKey()`, for example). The
     * advantage of using this method is that the parties do not have to
     * generate nor exchange a group modulus beforehand, saving both processor
     * and communication time.
     *
     * Example (obtaining a shared secret):
     *
     * ```js
     * const {
     *   getDiffieHellman,
     * } = await import('node:crypto');
     * const alice = getDiffieHellman('modp14');
     * const bob = getDiffieHellman('modp14');
     *
     * alice.generateKeys();
     * bob.generateKeys();
     *
     * const aliceSecret = alice.computeSecret(bob.getPublicKey(), null, 'hex');
     * const bobSecret = bob.computeSecret(alice.getPublicKey(), null, 'hex');
     *
     * // aliceSecret and bobSecret should be the same
     * console.log(aliceSecret === bobSecret);
     * ```
     * @since v0.7.5
     */
    function getDiffieHellman(groupName: string): DiffieHellmanGroup;
    /**
     * An alias for {@link getDiffieHellman}
     * @since v0.9.3
     */
    function createDiffieHellmanGroup(name: string): DiffieHellmanGroup;
    /**
     * Provides an asynchronous Password-Based Key Derivation Function 2 (PBKDF2)
     * implementation. A selected HMAC digest algorithm specified by `digest` is
     * applied to derive a key of the requested byte length (`keylen`) from the `password`, `salt` and `iterations`.
     *
     * The supplied `callback` function is called with two arguments: `err` and `derivedKey`. If an error occurs while deriving the key, `err` will be set;
     * otherwise `err` will be `null`. By default, the successfully generated `derivedKey` will be passed to the callback as a `Buffer`. An error will be
     * thrown if any of the input arguments specify invalid values or types.
     *
     * The `iterations` argument must be a number set as high as possible. The
     * higher the number of iterations, the more secure the derived key will be,
     * but will take a longer amount of time to complete.
     *
     * The `salt` should be as unique as possible. It is recommended that a salt is
     * random and at least 16 bytes long. See [NIST SP 800-132](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf) for details.
     *
     * When passing strings for `password` or `salt`, please consider `caveats when using strings as inputs to cryptographic APIs`.
     *
     * ```js
     * const {
     *   pbkdf2,
     * } = await import('node:crypto');
     *
     * pbkdf2('secret', 'salt', 100000, 64, 'sha512', (err, derivedKey) => {
     *   if (err) throw err;
     *   console.log(derivedKey.toString('hex'));  // '3745e48...08d59ae'
     * });
     * ```
     *
     * An array of supported digest functions can be retrieved using {@link getHashes}.
     *
     * This API uses libuv's threadpool, which can have surprising and
     * negative performance implications for some applications; see the `UV_THREADPOOL_SIZE` documentation for more information.
     * @since v0.5.5
     */
    function pbkdf2(
        password: BinaryLike,
        salt: BinaryLike,
        iterations: number,
        keylen: number,
        digest: string,
        callback: (err: Error | null, derivedKey: Buffer) => void,
    ): void;
    /**
     * Provides a synchronous Password-Based Key Derivation Function 2 (PBKDF2)
     * implementation. A selected HMAC digest algorithm specified by `digest` is
     * applied to derive a key of the requested byte length (`keylen`) from the `password`, `salt` and `iterations`.
     *
     * If an error occurs an `Error` will be thrown, otherwise the derived key will be
     * returned as a `Buffer`.
     *
     * The `iterations` argument must be a number set as high as possible. The
     * higher the number of iterations, the more secure the derived key will be,
     * but will take a longer amount of time to complete.
     *
     * The `salt` should be as unique as possible. It is recommended that a salt is
     * random and at least 16 bytes long. See [NIST SP 800-132](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf) for details.
     *
     * When passing strings for `password` or `salt`, please consider `caveats when using strings as inputs to cryptographic APIs`.
     *
     * ```js
     * const {
     *   pbkdf2Sync,
     * } = await import('node:crypto');
     *
     * const key = pbkdf2Sync('secret', 'salt', 100000, 64, 'sha512');
     * console.log(key.toString('hex'));  // '3745e48...08d59ae'
     * ```
     *
     * An array of supported digest functions can be retrieved using {@link getHashes}.
     * @since v0.9.3
     */
    function pbkdf2Sync(
        password: BinaryLike,
        salt: BinaryLike,
        iterations: number,
        keylen: number,
        digest: string,
    ): Buffer;
    /**
     * Generates cryptographically strong pseudorandom data. The `size` argument
     * is a number indicating the number of bytes to generate.
     *
     * If a `callback` function is provided, the bytes are generated asynchronously
     * and the `callback` function is invoked with two arguments: `err` and `buf`.
     * If an error occurs, `err` will be an `Error` object; otherwise it is `null`. The `buf` argument is a `Buffer` containing the generated bytes.
     *
     * ```js
     * // Asynchronous
     * const {
     *   randomBytes,
     * } = await import('node:crypto');
     *
     * randomBytes(256, (err, buf) => {
     *   if (err) throw err;
     *   console.log(`${buf.length} bytes of random data: ${buf.toString('hex')}`);
     * });
     * ```
     *
     * If the `callback` function is not provided, the random bytes are generated
     * synchronously and returned as a `Buffer`. An error will be thrown if
     * there is a problem generating the bytes.
     *
     * ```js
     * // Synchronous
     * const {
     *   randomBytes,
     * } = await import('node:crypto');
     *
     * const buf = randomBytes(256);
     * console.log(
     *   `${buf.length} bytes of random data: ${buf.toString('hex')}`);
     * ```
     *
     * The `crypto.randomBytes()` method will not complete until there is
     * sufficient entropy available.
     * This should normally never take longer than a few milliseconds. The only time
     * when generating the random bytes may conceivably block for a longer period of
     * time is right after boot, when the whole system is still low on entropy.
     *
     * This API uses libuv's threadpool, which can have surprising and
     * negative performance implications for some applications; see the `UV_THREADPOOL_SIZE` documentation for more information.
     *
     * The asynchronous version of `crypto.randomBytes()` is carried out in a single
     * threadpool request. To minimize threadpool task length variation, partition
     * large `randomBytes` requests when doing so as part of fulfilling a client
     * request.
     * @since v0.5.8
     * @param size The number of bytes to generate. The `size` must not be larger than `2**31 - 1`.
     * @return if the `callback` function is not provided.
     */
    function randomBytes(size: number): Buffer;
    function randomBytes(size: number, callback: (err: Error | null, buf: Buffer) => void): void;
    function pseudoRandomBytes(size: number): Buffer;
    function pseudoRandomBytes(size: number, callback: (err: Error | null, buf: Buffer) => void): void;
    /**
     * Return a random integer `n` such that `min <= n < max`.  This
     * implementation avoids [modulo bias](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#Modulo_bias).
     *
     * The range (`max - min`) must be less than 2**48. `min` and `max` must
     * be [safe integers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger).
     *
     * If the `callback` function is not provided, the random integer is
     * generated synchronously.
     *
     * ```js
     * // Asynchronous
     * const {
     *   randomInt,
     * } = await import('node:crypto');
     *
     * randomInt(3, (err, n) => {
     *   if (err) throw err;
     *   console.log(`Random number chosen from (0, 1, 2): ${n}`);
     * });
     * ```
     *
     * ```js
     * // Synchronous
     * const {
     *   randomInt,
     * } = await import('node:crypto');
     *
     * const n = randomInt(3);
     * console.log(`Random number chosen from (0, 1, 2): ${n}`);
     * ```
     *
     * ```js
     * // With `min` argument
     * const {
     *   randomInt,
     * } = await import('node:crypto');
     *
     * const n = randomInt(1, 7);
     * console.log(`The dice rolled: ${n}`);
     * ```
     * @since v14.10.0, v12.19.0
     * @param [min=0] Start of random range (inclusive).
     * @param max End of random range (exclusive).
     * @param callback `function(err, n) {}`.
     */
    function randomInt(max: number): number;
    function randomInt(min: number, max: number): number;
    function randomInt(max: number, callback: (err: Error | null, value: number) => void): void;
    function randomInt(min: number, max: number, callback: (err: Error | null, value: number) => void): void;
    /**
     * Synchronous version of {@link randomFill}.
     *
     * ```js
     * import { Buffer } from 'node:buffer';
     * const { randomFillSync } = await import('node:crypto');
     *
     * const buf = Buffer.alloc(10);
     * console.log(randomFillSync(buf).toString('hex'));
     *
     * randomFillSync(buf, 5);
     * console.log(buf.toString('hex'));
     *
     * // The above is equivalent to the following:
     * randomFillSync(buf, 5, 5);
     * console.log(buf.toString('hex'));
     * ```
     *
     * Any `ArrayBuffer`, `TypedArray` or `DataView` instance may be passed as`buffer`.
     *
     * ```js
     * import { Buffer } from 'node:buffer';
     * const { randomFillSync } = await import('node:crypto');
     *
     * const a = new Uint32Array(10);
     * console.log(Buffer.from(randomFillSync(a).buffer,
     *                         a.byteOffset, a.byteLength).toString('hex'));
     *
     * const b = new DataView(new ArrayBuffer(10));
     * console.log(Buffer.from(randomFillSync(b).buffer,
     *                         b.byteOffset, b.byteLength).toString('hex'));
     *
     * const c = new ArrayBuffer(10);
     * console.log(Buffer.from(randomFillSync(c)).toString('hex'));
     * ```
     * @since v7.10.0, v6.13.0
     * @param buffer Must be supplied. The size of the provided `buffer` must not be larger than `2**31 - 1`.
     * @param [offset=0]
     * @param [size=buffer.length - offset]
     * @return The object passed as `buffer` argument.
     */
    function randomFillSync<T extends NodeJS.ArrayBufferView>(buffer: T, offset?: number, size?: number): T;
    /**
     * This function is similar to {@link randomBytes} but requires the first
     * argument to be a `Buffer` that will be filled. It also
     * requires that a callback is passed in.
     *
     * If the `callback` function is not provided, an error will be thrown.
     *
     * ```js
     * import { Buffer } from 'node:buffer';
     * const { randomFill } = await import('node:crypto');
     *
     * const buf = Buffer.alloc(10);
     * randomFill(buf, (err, buf) => {
     *   if (err) throw err;
     *   console.log(buf.toString('hex'));
     * });
     *
     * randomFill(buf, 5, (err, buf) => {
     *   if (err) throw err;
     *   console.log(buf.toString('hex'));
     * });
     *
     * // The above is equivalent to the following:
     * randomFill(buf, 5, 5, (err, buf) => {
     *   if (err) throw err;
     *   console.log(buf.toString('hex'));
     * });
     * ```
     *
     * Any `ArrayBuffer`, `TypedArray`, or `DataView` instance may be passed as `buffer`.
     *
     * While this includes instances of `Float32Array` and `Float64Array`, this
     * function should not be used to generate random floating-point numbers. The
     * result may contain `+Infinity`, `-Infinity`, and `NaN`, and even if the array
     * contains finite numbers only, they are not drawn from a uniform random
     * distribution and have no meaningful lower or upper bounds.
     *
     * ```js
     * import { Buffer } from 'node:buffer';
     * const { randomFill } = await import('node:crypto');
     *
     * const a = new Uint32Array(10);
     * randomFill(a, (err, buf) => {
     *   if (err) throw err;
     *   console.log(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)
     *     .toString('hex'));
     * });
     *
     * const b = new DataView(new ArrayBuffer(10));
     * randomFill(b, (err, buf) => {
     *   if (err) throw err;
     *   console.log(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)
     *     .toString('hex'));
     * });
     *
     * const c = new ArrayBuffer(10);
     * randomFill(c, (err, buf) => {
     *   if (err) throw err;
     *   console.log(Buffer.from(buf).toString('hex'));
     * });
     * ```
     *
     * This API uses libuv's threadpool, which can have surprising and
     * negative performance implications for some applications; see the `UV_THREADPOOL_SIZE` documentation for more information.
     *
     * The asynchronous version of `crypto.randomFill()` is carried out in a single
     * threadpool request. To minimize threadpool task length variation, partition
     * large `randomFill` requests when doing so as part of fulfilling a client
     * request.
     * @since v7.10.0, v6.13.0
     * @param buffer Must be supplied. The size of the provided `buffer` must not be larger than `2**31 - 1`.
     * @param [offset=0]
     * @param [size=buffer.length - offset]
     * @param callback `function(err, buf) {}`.
     */
    function randomFill<T extends NodeJS.ArrayBufferView>(
        buffer: T,
        callback: (err: Error | null, buf: T) => void,
    ): void;
    function randomFill<T extends NodeJS.ArrayBufferView>(
        buffer: T,
        offset: number,
        callback: (err: Error | null, buf: T) => void,
    ): void;
    function randomFill<T extends NodeJS.ArrayBufferView>(
        buffer: T,
        offset: number,
        size: number,
        callback: (err: Error | null, buf: T) => void,
    ): void;
    interface ScryptOptions {
        cost?: number | undefined;
        blockSize?: number | undefined;
        parallelization?: number | undefined;
        N?: number | undefined;
        r?: number | undefined;
        p?: number | undefined;
        maxmem?: number | undefined;
    }
    /**
     * Provides an asynchronous [scrypt](https://en.wikipedia.org/wiki/Scrypt) implementation. Scrypt is a password-based
     * key derivation function that is designed to be expensive computationally and
     * memory-wise in order to make brute-force attacks unrewarding.
     *
     * The `salt` should be as unique as possible. It is recommended that a salt is
     * random and at least 16 bytes long. See [NIST SP 800-132](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf) for details.
     *
     * When passing strings for `password` or `salt`, please consider `caveats when using strings as inputs to cryptographic APIs`.
     *
     * The `callback` function is called with two arguments: `err` and `derivedKey`. `err` is an exception object when key derivation fails, otherwise `err` is `null`. `derivedKey` is passed to the
     * callback as a `Buffer`.
     *
     * An exception is thrown when any of the input arguments specify invalid values
     * or types.
     *
     * ```js
     * const {
     *   scrypt,
     * } = await import('node:crypto');
     *
     * // Using the factory defaults.
     * scrypt('password', 'salt', 64, (err, derivedKey) => {
     *   if (err) throw err;
     *   console.log(derivedKey.toString('hex'));  // '3745e48...08d59ae'
     * });
     * // Using a custom N parameter. Must be a power of two.
     * scrypt('password', 'salt', 64, { N: 1024 }, (err, derivedKey) => {
     *   if (err) throw err;
     *   console.log(derivedKey.toString('hex'));  // '3745e48...aa39b34'
     * });
     * ```
     * @since v10.5.0
     */
    function scrypt(
        password: BinaryLike,
        salt: BinaryLike,
        keylen: number,
        callback: (err: Error | null, derivedKey: Buffer) => void,
    ): void;
    function scrypt(
        password: BinaryLike,
        salt: BinaryLike,
        keylen: number,
        options: ScryptOptions,
        callback: (err: Error | null, derivedKey: Buffer) => void,
    ): void;
    /**
     * Provides a synchronous [scrypt](https://en.wikipedia.org/wiki/Scrypt) implementation. Scrypt is a password-based
     * key derivation function that is designed to be expensive computationally and
     * memory-wise in order to make brute-force attacks unrewarding.
     *
     * The `salt` should be as unique as possible. It is recommended that a salt is
     * random and at least 16 bytes long. See [NIST SP 800-132](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf) for details.
     *
     * When passing strings for `password` or `salt`, please consider `caveats when using strings as inputs to cryptographic APIs`.
     *
     * An exception is thrown when key derivation fails, otherwise the derived key is
     * returned as a `Buffer`.
     *
     * An exception is thrown when any of the input arguments specify invalid values
     * or types.
     *
     * ```js
     * const {
     *   scryptSync,
     * } = await import('node:crypto');
     * // Using the factory defaults.
     *
     * const key1 = scryptSync('password', 'salt', 64);
     * console.log(key1.toString('hex'));  // '3745e48...08d59ae'
     * // Using a custom N parameter. Must be a power of two.
     * const key2 = scryptSync('password', 'salt', 64, { N: 1024 });
     * console.log(key2.toString('hex'));  // '3745e48...aa39b34'
     * ```
     * @since v10.5.0
     */
    function scryptSync(password: BinaryLike, salt: BinaryLike, keylen: number, options?: ScryptOptions): Buffer;
    interface RsaPublicKey {
        key: KeyLike;
        padding?: number | undefined;
    }
    interface RsaPrivateKey {
        key: KeyLike;
        passphrase?: string | undefined;
        /**
         * @default 'sha1'
         */
        oaepHash?: string | undefined;
        oaepLabel?: NodeJS.TypedArray | undefined;
        padding?: number | undefined;
    }
    /**
     * Encrypts the content of `buffer` with `key` and returns a new `Buffer` with encrypted content. The returned data can be decrypted using
     * the corresponding private key, for example using {@link privateDecrypt}.
     *
     * If `key` is not a `KeyObject`, this function behaves as if `key` had been passed to {@link createPublicKey}. If it is an
     * object, the `padding` property can be passed. Otherwise, this function uses `RSA_PKCS1_OAEP_PADDING`.
     *
     * Because RSA public keys can be derived from private keys, a private key may
     * be passed instead of a public key.
     * @since v0.11.14
     */
    function publicEncrypt(key: RsaPublicKey | RsaPrivateKey | KeyLike, buffer: NodeJS.ArrayBufferView): Buffer;
    /**
     * Decrypts `buffer` with `key`.`buffer` was previously encrypted using
     * the corresponding private key, for example using {@link privateEncrypt}.
     *
     * If `key` is not a `KeyObject`, this function behaves as if `key` had been passed to {@link createPublicKey}. If it is an
     * object, the `padding` property can be passed. Otherwise, this function uses `RSA_PKCS1_PADDING`.
     *
     * Because RSA public keys can be derived from private keys, a private key may
     * be passed instead of a public key.
     * @since v1.1.0
     */
    function publicDecrypt(key: RsaPublicKey | RsaPrivateKey | KeyLike, buffer: NodeJS.ArrayBufferView): Buffer;
    /**
     * Decrypts `buffer` with `privateKey`. `buffer` was previously encrypted using
     * the corresponding public key, for example using {@link publicEncrypt}.
     *
     * If `privateKey` is not a `KeyObject`, this function behaves as if `privateKey` had been passed to {@link createPrivateKey}. If it is an
     * object, the `padding` property can be passed. Otherwise, this function uses `RSA_PKCS1_OAEP_PADDING`.
     * @since v0.11.14
     */
    function privateDecrypt(privateKey: RsaPrivateKey | KeyLike, buffer: NodeJS.ArrayBufferView): Buffer;
    /**
     * Encrypts `buffer` with `privateKey`. The returned data can be decrypted using
     * the corresponding public key, for example using {@link publicDecrypt}.
     *
     * If `privateKey` is not a `KeyObject`, this function behaves as if `privateKey` had been passed to {@link createPrivateKey}. If it is an
     * object, the `padding` property can be passed. Otherwise, this function uses `RSA_PKCS1_PADDING`.
     * @since v1.1.0
     */
    function privateEncrypt(privateKey: RsaPrivateKey | KeyLike, buffer: NodeJS.ArrayBufferView): Buffer;
    /**
     * ```js
     * const {
     *   getCiphers,
     * } = await import('node:crypto');
     *
     * console.log(getCiphers()); // ['aes-128-cbc', 'aes-128-ccm', ...]
     * ```
     * @since v0.9.3
     * @return An array with the names of the supported cipher algorithms.
     */
    function getCiphers(): string[];
    /**
     * ```js
     * const {
     *   getCurves,
     * } = await import('node:crypto');
     *
     * console.log(getCurves()); // ['Oakley-EC2N-3', 'Oakley-EC2N-4', ...]
     * ```
     * @since v2.3.0
     * @return An array with the names of the supported elliptic curves.
     */
    function getCurves(): string[];
    /**
     * @since v10.0.0
     * @return `1` if and only if a FIPS compliant crypto provider is currently in use, `0` otherwise. A future semver-major release may change the return type of this API to a {boolean}.
     */
    function getFips(): 1 | 0;
    /**
     * Enables the FIPS compliant crypto provider in a FIPS-enabled Node.js build.
     * Throws an error if FIPS mode is not available.
     * @since v10.0.0
     * @param bool `true` to enable FIPS mode.
     */
    function setFips(bool: boolean): void;
    /**
     * ```js
     * const {
     *   getHashes,
     * } = await import('node:crypto');
     *
     * console.log(getHashes()); // ['DSA', 'DSA-SHA', 'DSA-SHA1', ...]
     * ```
     * @since v0.9.3
     * @return An array of the names of the supported hash algorithms, such as `'RSA-SHA256'`. Hash algorithms are also called "digest" algorithms.
     */
    function getHashes(): string[];
    /**
     * The `ECDH` class is a utility for creating Elliptic Curve Diffie-Hellman (ECDH)
     * key exchanges.
     *
     * Instances of the `ECDH` class can be created using the {@link createECDH} function.
     *
     * ```js
     * import assert from 'node:assert';
     *
     * const {
     *   createECDH,
     * } = await import('node:crypto');
     *
     * // Generate Alice's keys...
     * const alice = createECDH('secp521r1');
     * const aliceKey = alice.generateKeys();
     *
     * // Generate Bob's keys...
     * const bob = createECDH('secp521r1');
     * const bobKey = bob.generateKeys();
     *
     * // Exchange and generate the secret...
     * const aliceSecret = alice.computeSecret(bobKey);
     * const bobSecret = bob.computeSecret(aliceKey);
     *
     * assert.strictEqual(aliceSecret.toString('hex'), bobSecret.toString('hex'));
     * // OK
     * ```
     * @since v0.11.14
     */
    class ECDH {
        private constructor();
        /**
         * Converts the EC Diffie-Hellman public key specified by `key` and `curve` to the
         * format specified by `format`. The `format` argument specifies point encoding
         * and can be `'compressed'`, `'uncompressed'` or `'hybrid'`. The supplied key is
         * interpreted using the specified `inputEncoding`, and the returned key is encoded
         * using the specified `outputEncoding`.
         *
         * Use {@link getCurves} to obtain a list of available curve names.
         * On recent OpenSSL releases, `openssl ecparam -list_curves` will also display
         * the name and description of each available elliptic curve.
         *
         * If `format` is not specified the point will be returned in `'uncompressed'` format.
         *
         * If the `inputEncoding` is not provided, `key` is expected to be a `Buffer`, `TypedArray`, or `DataView`.
         *
         * Example (uncompressing a key):
         *
         * ```js
         * const {
         *   createECDH,
         *   ECDH,
         * } = await import('node:crypto');
         *
         * const ecdh = createECDH('secp256k1');
         * ecdh.generateKeys();
         *
         * const compressedKey = ecdh.getPublicKey('hex', 'compressed');
         *
         * const uncompressedKey = ECDH.convertKey(compressedKey,
         *                                         'secp256k1',
         *                                         'hex',
         *                                         'hex',
         *                                         'uncompressed');
         *
         * // The converted key and the uncompressed public key should be the same
         * console.log(uncompressedKey === ecdh.getPublicKey('hex'));
         * ```
         * @since v10.0.0
         * @param inputEncoding The `encoding` of the `key` string.
         * @param outputEncoding The `encoding` of the return value.
         * @param [format='uncompressed']
         */
        static convertKey(
            key: BinaryLike,
            curve: string,
            inputEncoding?: BinaryToTextEncoding,
            outputEncoding?: "latin1" | "hex" | "base64" | "base64url",
            format?: "uncompressed" | "compressed" | "hybrid",
        ): Buffer | string;
        /**
         * Generates private and public EC Diffie-Hellman key values, and returns
         * the public key in the specified `format` and `encoding`. This key should be
         * transferred to the other party.
         *
         * The `format` argument specifies point encoding and can be `'compressed'` or `'uncompressed'`. If `format` is not specified, the point will be returned in`'uncompressed'` format.
         *
         * If `encoding` is provided a string is returned; otherwise a `Buffer` is returned.
         * @since v0.11.14
         * @param encoding The `encoding` of the return value.
         * @param [format='uncompressed']
         */
        generateKeys(): Buffer;
        generateKeys(encoding: BinaryToTextEncoding, format?: ECDHKeyFormat): string;
        /**
         * Computes the shared secret using `otherPublicKey` as the other
         * party's public key and returns the computed shared secret. The supplied
         * key is interpreted using specified `inputEncoding`, and the returned secret
         * is encoded using the specified `outputEncoding`.
         * If the `inputEncoding` is not
         * provided, `otherPublicKey` is expected to be a `Buffer`, `TypedArray`, or `DataView`.
         *
         * If `outputEncoding` is given a string will be returned; otherwise a `Buffer` is returned.
         *
         * `ecdh.computeSecret` will throw an`ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY` error when `otherPublicKey` lies outside of the elliptic curve. Since `otherPublicKey` is
         * usually supplied from a remote user over an insecure network,
         * be sure to handle this exception accordingly.
         * @since v0.11.14
         * @param inputEncoding The `encoding` of the `otherPublicKey` string.
         * @param outputEncoding The `encoding` of the return value.
         */
        computeSecret(otherPublicKey: NodeJS.ArrayBufferView): Buffer;
        computeSecret(otherPublicKey: string, inputEncoding: BinaryToTextEncoding): Buffer;
        computeSecret(otherPublicKey: NodeJS.ArrayBufferView, outputEncoding: BinaryToTextEncoding): string;
        computeSecret(
            otherPublicKey: string,
            inputEncoding: BinaryToTextEncoding,
            outputEncoding: BinaryToTextEncoding,
        ): string;
        /**
         * If `encoding` is specified, a string is returned; otherwise a `Buffer` is
         * returned.
         * @since v0.11.14
         * @param encoding The `encoding` of the return value.
         * @return The EC Diffie-Hellman in the specified `encoding`.
         */
        getPrivateKey(): Buffer;
        getPrivateKey(encoding: BinaryToTextEncoding): string;
        /**
         * The `format` argument specifies point encoding and can be `'compressed'` or `'uncompressed'`. If `format` is not specified the point will be returned in`'uncompressed'` format.
         *
         * If `encoding` is specified, a string is returned; otherwise a `Buffer` is
         * returned.
         * @since v0.11.14
         * @param encoding The `encoding` of the return value.
         * @param [format='uncompressed']
         * @return The EC Diffie-Hellman public key in the specified `encoding` and `format`.
         */
        getPublicKey(encoding?: null, format?: ECDHKeyFormat): Buffer;
        getPublicKey(encoding: BinaryToTextEncoding, format?: ECDHKeyFormat): string;
        /**
         * Sets the EC Diffie-Hellman private key.
         * If `encoding` is provided, `privateKey` is expected
         * to be a string; otherwise `privateKey` is expected to be a `Buffer`, `TypedArray`, or `DataView`.
         *
         * If `privateKey` is not valid for the curve specified when the `ECDH` object was
         * created, an error is thrown. Upon setting the private key, the associated
         * public point (key) is also generated and set in the `ECDH` object.
         * @since v0.11.14
         * @param encoding The `encoding` of the `privateKey` string.
         */
        setPrivateKey(privateKey: NodeJS.ArrayBufferView): void;
        setPrivateKey(privateKey: string, encoding: BinaryToTextEncoding): void;
    }
    /**
     * Creates an Elliptic Curve Diffie-Hellman (`ECDH`) key exchange object using a
     * predefined curve specified by the `curveName` string. Use {@link getCurves} to obtain a list of available curve names. On recent
     * OpenSSL releases, `openssl ecparam -list_curves` will also display the name
     * and description of each available elliptic curve.
     * @since v0.11.14
     */
    function createECDH(curveName: string): ECDH;
    /**
     * This function compares the underlying bytes that represent the given `ArrayBuffer`, `TypedArray`, or `DataView` instances using a constant-time
     * algorithm.
     *
     * This function does not leak timing information that
     * would allow an attacker to guess one of the values. This is suitable for
     * comparing HMAC digests or secret values like authentication cookies or [capability urls](https://www.w3.org/TR/capability-urls/).
     *
     * `a` and `b` must both be `Buffer`s, `TypedArray`s, or `DataView`s, and they
     * must have the same byte length. An error is thrown if `a` and `b` have
     * different byte lengths.
     *
     * If at least one of `a` and `b` is a `TypedArray` with more than one byte per
     * entry, such as `Uint16Array`, the result will be computed using the platform
     * byte order.
     *
     * **When both of the inputs are `Float32Array`s or `Float64Array`s, this function might return unexpected results due to IEEE 754**
     * **encoding of floating-point numbers. In particular, neither `x === y` nor `Object.is(x, y)` implies that the byte representations of two floating-point**
     * **numbers `x` and `y` are equal.**
     *
     * Use of `crypto.timingSafeEqual` does not guarantee that the _surrounding_ code
     * is timing-safe. Care should be taken to ensure that the surrounding code does
     * not introduce timing vulnerabilities.
     * @since v6.6.0
     */
    function timingSafeEqual(a: NodeJS.ArrayBufferView, b: NodeJS.ArrayBufferView): boolean;
    type KeyType = "rsa" | "rsa-pss" | "dsa" | "ec" | "ed25519" | "ed448" | "x25519" | "x448";
    type KeyFormat = "pem" | "der" | "jwk";
    interface BasePrivateKeyEncodingOptions<T extends KeyFormat> {
        format: T;
        cipher?: string | undefined;
        passphrase?: string | undefined;
    }
    interface KeyPairKeyObjectResult {
        publicKey: KeyObject;
        privateKey: KeyObject;
    }
    interface ED25519KeyPairKeyObjectOptions {}
    interface ED448KeyPairKeyObjectOptions {}
    interface X25519KeyPairKeyObjectOptions {}
    interface X448KeyPairKeyObjectOptions {}
    interface ECKeyPairKeyObjectOptions {
        /**
         * Name of the curve to use
         */
        namedCurve: string;
        /**
         * Must be `'named'` or `'explicit'`. Default: `'named'`.
         */
        paramEncoding?: "explicit" | "named" | undefined;
    }
    interface RSAKeyPairKeyObjectOptions {
        /**
         * Key size in bits
         */
        modulusLength: number;
        /**
         * Public exponent
         * @default 0x10001
         */
        publicExponent?: number | undefined;
    }
    interface RSAPSSKeyPairKeyObjectOptions {
        /**
         * Key size in bits
         */
        modulusLength: number;
        /**
         * Public exponent
         * @default 0x10001
         */
        publicExponent?: number | undefined;
        /**
         * Name of the message digest
         */
        hashAlgorithm?: string;
        /**
         * Name of the message digest used by MGF1
         */
        mgf1HashAlgorithm?: string;
        /**
         * Minimal salt length in bytes
         */
        saltLength?: string;
    }
    interface DSAKeyPairKeyObjectOptions {
        /**
         * Key size in bits
         */
        modulusLength: number;
        /**
         * Size of q in bits
         */
        divisorLength: number;
    }
    interface RSAKeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {
        /**
         * Key size in bits
         */
        modulusLength: number;
        /**
         * Public exponent
         * @default 0x10001
         */
        publicExponent?: number | undefined;
        publicKeyEncoding: {
            type: "pkcs1" | "spki";
            format: PubF;
        };
        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {
            type: "pkcs1" | "pkcs8";
        };
    }
    interface RSAPSSKeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {
        /**
         * Key size in bits
         */
        modulusLength: number;
        /**
         * Public exponent
         * @default 0x10001
         */
        publicExponent?: number | undefined;
        /**
         * Name of the message digest
         */
        hashAlgorithm?: string;
        /**
         * Name of the message digest used by MGF1
         */
        mgf1HashAlgorithm?: string;
        /**
         * Minimal salt length in bytes
         */
        saltLength?: string;
        publicKeyEncoding: {
            type: "spki";
            format: PubF;
        };
        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {
            type: "pkcs8";
        };
    }
    interface DSAKeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {
        /**
         * Key size in bits
         */
        modulusLength: number;
        /**
         * Size of q in bits
         */
        divisorLength: number;
        publicKeyEncoding: {
            type: "spki";
            format: PubF;
        };
        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {
            type: "pkcs8";
        };
    }
    interface ECKeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> extends ECKeyPairKeyObjectOptions {
        publicKeyEncoding: {
            type: "pkcs1" | "spki";
            format: PubF;
        };
        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {
            type: "sec1" | "pkcs8";
        };
    }
    interface ED25519KeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {
        publicKeyEncoding: {
            type: "spki";
            format: PubF;
        };
        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {
            type: "pkcs8";
        };
    }
    interface ED448KeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {
        publicKeyEncoding: {
            type: "spki";
            format: PubF;
        };
        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {
            type: "pkcs8";
        };
    }
    interface X25519KeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {
        publicKeyEncoding: {
            type: "spki";
            format: PubF;
        };
        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {
            type: "pkcs8";
        };
    }
    interface X448KeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {
        publicKeyEncoding: {
            type: "spki";
            format: PubF;
        };
        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {
            type: "pkcs8";
        };
    }
    interface KeyPairSyncResult<T1 extends string | Buffer, T2 extends string | Buffer> {
        publicKey: T1;
        privateKey: T2;
    }
    /**
     * Generates a new asymmetric key pair of the given `type`. RSA, RSA-PSS, DSA, EC,
     * Ed25519, Ed448, X25519, X448, and DH are currently supported.
     *
     * If a `publicKeyEncoding` or `privateKeyEncoding` was specified, this function
     * behaves as if `keyObject.export()` had been called on its result. Otherwise,
     * the respective part of the key is returned as a `KeyObject`.
     *
     * When encoding public keys, it is recommended to use `'spki'`. When encoding
     * private keys, it is recommended to use `'pkcs8'` with a strong passphrase,
     * and to keep the passphrase confidential.
     *
     * ```js
     * const {
     *   generateKeyPairSync,
     * } = await import('node:crypto');
     *
     * const {
     *   publicKey,
     *   privateKey,
     * } = generateKeyPairSync('rsa', {
     *   modulusLength: 4096,
     *   publicKeyEncoding: {
     *     type: 'spki',
     *     format: 'pem',
     *   },
     *   privateKeyEncoding: {
     *     type: 'pkcs8',
     *     format: 'pem',
     *     cipher: 'aes-256-cbc',
     *     passphrase: 'top secret',
     *   },
     * });
     * ```
     *
     * The return value `{ publicKey, privateKey }` represents the generated key pair.
     * When PEM encoding was selected, the respective key will be a string, otherwise
     * it will be a buffer containing the data encoded as DER.
     * @since v10.12.0
     * @param type Must be `'rsa'`, `'rsa-pss'`, `'dsa'`, `'ec'`, `'ed25519'`, `'ed448'`, `'x25519'`, `'x448'`, or `'dh'`.
     */
    function generateKeyPairSync(
        type: "rsa",
        options: RSAKeyPairOptions<"pem", "pem">,
    ): KeyPairSyncResult<string, string>;
    function generateKeyPairSync(
        type: "rsa",
        options: RSAKeyPairOptions<"pem", "der">,
    ): KeyPairSyncResult<string, Buffer>;
    function generateKeyPairSync(
        type: "rsa",
        options: RSAKeyPairOptions<"der", "pem">,
    ): KeyPairSyncResult<Buffer, string>;
    function generateKeyPairSync(
        type: "rsa",
        options: RSAKeyPairOptions<"der", "der">,
    ): KeyPairSyncResult<Buffer, Buffer>;
    function generateKeyPairSync(type: "rsa", options: RSAKeyPairKeyObjectOptions): KeyPairKeyObjectResult;
    function generateKeyPairSync(
        type: "rsa-pss",
        options: RSAPSSKeyPairOptions<"pem", "pem">,
    ): KeyPairSyncResult<string, string>;
    function generateKeyPairSync(
        type: "rsa-pss",
        options: RSAPSSKeyPairOptions<"pem", "der">,
    ): KeyPairSyncResult<string, Buffer>;
    function generateKeyPairSync(
        type: "rsa-pss",
        options: RSAPSSKeyPairOptions<"der", "pem">,
    ): KeyPairSyncResult<Buffer, string>;
    function generateKeyPairSync(
        type: "rsa-pss",
        options: RSAPSSKeyPairOptions<"der", "der">,
    ): KeyPairSyncResult<Buffer, Buffer>;
    function generateKeyPairSync(type: "rsa-pss", options: RSAPSSKeyPairKeyObjectOptions): KeyPairKeyObjectResult;
    function generateKeyPairSync(
        type: "dsa",
        options: DSAKeyPairOptions<"pem", "pem">,
    ): KeyPairSyncResult<string, string>;
    function generateKeyPairSync(
        type: "dsa",
        options: DSAKeyPairOptions<"pem", "der">,
    ): KeyPairSyncResult<string, Buffer>;
    function generateKeyPairSync(
        type: "dsa",
        options: DSAKeyPairOptions<"der", "pem">,
    ): KeyPairSyncResult<Buffer, string>;
    function generateKeyPairSync(
        type: "dsa",
        options: DSAKeyPairOptions<"der", "der">,
    ): KeyPairSyncResult<Buffer, Buffer>;
    function generateKeyPairSync(type: "dsa", options: DSAKeyPairKeyObjectOptions): KeyPairKeyObjectResult;
    function generateKeyPairSync(
        type: "ec",
        options: ECKeyPairOptions<"pem", "pem">,
    ): KeyPairSyncResult<string, string>;
    function generateKeyPairSync(
        type: "ec",
        options: ECKeyPairOptions<"pem", "der">,
    ): KeyPairSyncResult<string, Buffer>;
    function generateKeyPairSync(
        type: "ec",
        options: ECKeyPairOptions<"der", "pem">,
    ): KeyPairSyncResult<Buffer, string>;
    function generateKeyPairSync(
        type: "ec",
        options: ECKeyPairOptions<"der", "der">,
    ): KeyPairSyncResult<Buffer, Buffer>;
    function generateKeyPairSync(type: "ec", options: ECKeyPairKeyObjectOptions): KeyPairKeyObjectResult;
    function generateKeyPairSync(
        type: "ed25519",
        options: ED25519KeyPairOptions<"pem", "pem">,
    ): KeyPairSyncResult<string, string>;
    function generateKeyPairSync(
        type: "ed25519",
        options: ED25519KeyPairOptions<"pem", "der">,
    ): KeyPairSyncResult<string, Buffer>;
    function generateKeyPairSync(
        type: "ed25519",
        options: ED25519KeyPairOptions<"der", "pem">,
    ): KeyPairSyncResult<Buffer, string>;
    function generateKeyPairSync(
        type: "ed25519",
        options: ED25519KeyPairOptions<"der", "der">,
    ): KeyPairSyncResult<Buffer, Buffer>;
    function generateKeyPairSync(type: "ed25519", options?: ED25519KeyPairKeyObjectOptions): KeyPairKeyObjectResult;
    function generateKeyPairSync(
        type: "ed448",
        options: ED448KeyPairOptions<"pem", "pem">,
    ): KeyPairSyncResult<string, string>;
    function generateKeyPairSync(
        type: "ed448",
        options: ED448KeyPairOptions<"pem", "der">,
    ): KeyPairSyncResult<string, Buffer>;
    function generateKeyPairSync(
        type: "ed448",
        options: ED448KeyPairOptions<"der", "pem">,
    ): KeyPairSyncResult<Buffer, string>;
    function generateKeyPairSync(
        type: "ed448",
        options: ED448KeyPairOptions<"der", "der">,
    ): KeyPairSyncResult<Buffer, Buffer>;
    function generateKeyPairSync(type: "ed448", options?: ED448KeyPairKeyObjectOptions): KeyPairKeyObjectResult;
    function generateKeyPairSync(
        type: "x25519",
        options: X25519KeyPairOptions<"pem", "pem">,
    ): KeyPairSyncResult<string, string>;
    function generateKeyPairSync(
        type: "x25519",
        options: X25519KeyPairOptions<"pem", "der">,
    ): KeyPairSyncResult<string, Buffer>;
    function generateKeyPairSync(
        type: "x25519",
        options: X25519KeyPairOptions<"der", "pem">,
    ): KeyPairSyncResult<Buffer, string>;
    function generateKeyPairSync(
        type: "x25519",
        options: X25519KeyPairOptions<"der", "der">,
    ): KeyPairSyncResult<Buffer, Buffer>;
    function generateKeyPairSync(type: "x25519", options?: X25519KeyPairKeyObjectOptions): KeyPairKeyObjectResult;
    function generateKeyPairSync(
        type: "x448",
        options: X448KeyPairOptions<"pem", "pem">,
    ): KeyPairSyncResult<string, string>;
    function generateKeyPairSync(
        type: "x448",
        options: X448KeyPairOptions<"pem", "der">,
    ): KeyPairSyncResult<string, Buffer>;
    function generateKeyPairSync(
        type: "x448",
        options: X448KeyPairOptions<"der", "pem">,
    ): KeyPairSyncResult<Buffer, string>;
    function generateKeyPairSync(
        type: "x448",
        options: X448KeyPairOptions<"der", "der">,
    ): KeyPairSyncResult<Buffer, Buffer>;
    function generateKeyPairSync(type: "x448", options?: X448KeyPairKeyObjectOptions): KeyPairKeyObjectResult;
    /**
     * Generates a new asymmetric key pair of the given `type`. RSA, RSA-PSS, DSA, EC,
     * Ed25519, Ed448, X25519, X448, and DH are currently supported.
     *
     * If a `publicKeyEncoding` or `privateKeyEncoding` was specified, this function
     * behaves as if `keyObject.export()` had been called on its result. Otherwise,
     * the respective part of the key is returned as a `KeyObject`.
     *
     * It is recommended to encode public keys as `'spki'` and private keys as `'pkcs8'` with encryption for long-term storage:
     *
     * ```js
     * const {
     *   generateKeyPair,
     * } = await import('node:crypto');
     *
     * generateKeyPair('rsa', {
     *   modulusLength: 4096,
     *   publicKeyEncoding: {
     *     type: 'spki',
     *     format: 'pem',
     *   },
     *   privateKeyEncoding: {
     *     type: 'pkcs8',
     *     format: 'pem',
     *     cipher: 'aes-256-cbc',
     *     passphrase: 'top secret',
     *   },
     * }, (err, publicKey, privateKey) => {
     *   // Handle errors and use the generated key pair.
     * });
     * ```
     *
     * On completion, `callback` will be called with `err` set to `undefined` and `publicKey` / `privateKey` representing the generated key pair.
     *
     * If this method is invoked as its `util.promisify()` ed version, it returns
     * a `Promise` for an `Object` with `publicKey` and `privateKey` properties.
     * @since v10.12.0
     * @param type Must be `'rsa'`, `'rsa-pss'`, `'dsa'`, `'ec'`, `'ed25519'`, `'ed448'`, `'x25519'`, `'x448'`, or `'dh'`.
     */
    function generateKeyPair(
        type: "rsa",
        options: RSAKeyPairOptions<"pem", "pem">,
        callback: (err: Error | null, publicKey: string, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "rsa",
        options: RSAKeyPairOptions<"pem", "der">,
        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "rsa",
        options: RSAKeyPairOptions<"der", "pem">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "rsa",
        options: RSAKeyPairOptions<"der", "der">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "rsa",
        options: RSAKeyPairKeyObjectOptions,
        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,
    ): void;
    function generateKeyPair(
        type: "rsa-pss",
        options: RSAPSSKeyPairOptions<"pem", "pem">,
        callback: (err: Error | null, publicKey: string, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "rsa-pss",
        options: RSAPSSKeyPairOptions<"pem", "der">,
        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "rsa-pss",
        options: RSAPSSKeyPairOptions<"der", "pem">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "rsa-pss",
        options: RSAPSSKeyPairOptions<"der", "der">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "rsa-pss",
        options: RSAPSSKeyPairKeyObjectOptions,
        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,
    ): void;
    function generateKeyPair(
        type: "dsa",
        options: DSAKeyPairOptions<"pem", "pem">,
        callback: (err: Error | null, publicKey: string, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "dsa",
        options: DSAKeyPairOptions<"pem", "der">,
        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "dsa",
        options: DSAKeyPairOptions<"der", "pem">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "dsa",
        options: DSAKeyPairOptions<"der", "der">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "dsa",
        options: DSAKeyPairKeyObjectOptions,
        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,
    ): void;
    function generateKeyPair(
        type: "ec",
        options: ECKeyPairOptions<"pem", "pem">,
        callback: (err: Error | null, publicKey: string, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "ec",
        options: ECKeyPairOptions<"pem", "der">,
        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "ec",
        options: ECKeyPairOptions<"der", "pem">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "ec",
        options: ECKeyPairOptions<"der", "der">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "ec",
        options: ECKeyPairKeyObjectOptions,
        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,
    ): void;
    function generateKeyPair(
        type: "ed25519",
        options: ED25519KeyPairOptions<"pem", "pem">,
        callback: (err: Error | null, publicKey: string, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "ed25519",
        options: ED25519KeyPairOptions<"pem", "der">,
        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "ed25519",
        options: ED25519KeyPairOptions<"der", "pem">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "ed25519",
        options: ED25519KeyPairOptions<"der", "der">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "ed25519",
        options: ED25519KeyPairKeyObjectOptions | undefined,
        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,
    ): void;
    function generateKeyPair(
        type: "ed448",
        options: ED448KeyPairOptions<"pem", "pem">,
        callback: (err: Error | null, publicKey: string, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "ed448",
        options: ED448KeyPairOptions<"pem", "der">,
        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "ed448",
        options: ED448KeyPairOptions<"der", "pem">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "ed448",
        options: ED448KeyPairOptions<"der", "der">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "ed448",
        options: ED448KeyPairKeyObjectOptions | undefined,
        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,
    ): void;
    function generateKeyPair(
        type: "x25519",
        options: X25519KeyPairOptions<"pem", "pem">,
        callback: (err: Error | null, publicKey: string, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "x25519",
        options: X25519KeyPairOptions<"pem", "der">,
        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "x25519",
        options: X25519KeyPairOptions<"der", "pem">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "x25519",
        options: X25519KeyPairOptions<"der", "der">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "x25519",
        options: X25519KeyPairKeyObjectOptions | undefined,
        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,
    ): void;
    function generateKeyPair(
        type: "x448",
        options: X448KeyPairOptions<"pem", "pem">,
        callback: (err: Error | null, publicKey: string, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "x448",
        options: X448KeyPairOptions<"pem", "der">,
        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "x448",
        options: X448KeyPairOptions<"der", "pem">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "x448",
        options: X448KeyPairOptions<"der", "der">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "x448",
        options: X448KeyPairKeyObjectOptions | undefined,
        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,
    ): void;
    namespace generateKeyPair {
        function __promisify__(
            type: "rsa",
            options: RSAKeyPairOptions<"pem", "pem">,
        ): Promise<{
            publicKey: string;
            privateKey: string;
        }>;
        function __promisify__(
            type: "rsa",
            options: RSAKeyPairOptions<"pem", "der">,
        ): Promise<{
            publicKey: string;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "rsa",
            options: RSAKeyPairOptions<"der", "pem">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: string;
        }>;
        function __promisify__(
            type: "rsa",
            options: RSAKeyPairOptions<"der", "der">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: Buffer;
        }>;
        function __promisify__(type: "rsa", options: RSAKeyPairKeyObjectOptions): Promise<KeyPairKeyObjectResult>;
        function __promisify__(
            type: "rsa-pss",
            options: RSAPSSKeyPairOptions<"pem", "pem">,
        ): Promise<{
            publicKey: string;
            privateKey: string;
        }>;
        function __promisify__(
            type: "rsa-pss",
            options: RSAPSSKeyPairOptions<"pem", "der">,
        ): Promise<{
            publicKey: string;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "rsa-pss",
            options: RSAPSSKeyPairOptions<"der", "pem">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: string;
        }>;
        function __promisify__(
            type: "rsa-pss",
            options: RSAPSSKeyPairOptions<"der", "der">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "rsa-pss",
            options: RSAPSSKeyPairKeyObjectOptions,
        ): Promise<KeyPairKeyObjectResult>;
        function __promisify__(
            type: "dsa",
            options: DSAKeyPairOptions<"pem", "pem">,
        ): Promise<{
            publicKey: string;
            privateKey: string;
        }>;
        function __promisify__(
            type: "dsa",
            options: DSAKeyPairOptions<"pem", "der">,
        ): Promise<{
            publicKey: string;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "dsa",
            options: DSAKeyPairOptions<"der", "pem">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: string;
        }>;
        function __promisify__(
            type: "dsa",
            options: DSAKeyPairOptions<"der", "der">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: Buffer;
        }>;
        function __promisify__(type: "dsa", options: DSAKeyPairKeyObjectOptions): Promise<KeyPairKeyObjectResult>;
        function __promisify__(
            type: "ec",
            options: ECKeyPairOptions<"pem", "pem">,
        ): Promise<{
            publicKey: string;
            privateKey: string;
        }>;
        function __promisify__(
            type: "ec",
            options: ECKeyPairOptions<"pem", "der">,
        ): Promise<{
            publicKey: string;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "ec",
            options: ECKeyPairOptions<"der", "pem">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: string;
        }>;
        function __promisify__(
            type: "ec",
            options: ECKeyPairOptions<"der", "der">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: Buffer;
        }>;
        function __promisify__(type: "ec", options: ECKeyPairKeyObjectOptions): Promise<KeyPairKeyObjectResult>;
        function __promisify__(
            type: "ed25519",
            options: ED25519KeyPairOptions<"pem", "pem">,
        ): Promise<{
            publicKey: string;
            privateKey: string;
        }>;
        function __promisify__(
            type: "ed25519",
            options: ED25519KeyPairOptions<"pem", "der">,
        ): Promise<{
            publicKey: string;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "ed25519",
            options: ED25519KeyPairOptions<"der", "pem">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: string;
        }>;
        function __promisify__(
            type: "ed25519",
            options: ED25519KeyPairOptions<"der", "der">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "ed25519",
            options?: ED25519KeyPairKeyObjectOptions,
        ): Promise<KeyPairKeyObjectResult>;
        function __promisify__(
            type: "ed448",
            options: ED448KeyPairOptions<"pem", "pem">,
        ): Promise<{
            publicKey: string;
            privateKey: string;
        }>;
        function __promisify__(
            type: "ed448",
            options: ED448KeyPairOptions<"pem", "der">,
        ): Promise<{
            publicKey: string;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "ed448",
            options: ED448KeyPairOptions<"der", "pem">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: string;
        }>;
        function __promisify__(
            type: "ed448",
            options: ED448KeyPairOptions<"der", "der">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: Buffer;
        }>;
        function __promisify__(type: "ed448", options?: ED448KeyPairKeyObjectOptions): Promise<KeyPairKeyObjectResult>;
        function __promisify__(
            type: "x25519",
            options: X25519KeyPairOptions<"pem", "pem">,
        ): Promise<{
            publicKey: string;
            privateKey: string;
        }>;
        function __promisify__(
            type: "x25519",
            options: X25519KeyPairOptions<"pem", "der">,
        ): Promise<{
            publicKey: string;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "x25519",
            options: X25519KeyPairOptions<"der", "pem">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: string;
        }>;
        function __promisify__(
            type: "x25519",
            options: X25519KeyPairOptions<"der", "der">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "x25519",
            options?: X25519KeyPairKeyObjectOptions,
        ): Promise<KeyPairKeyObjectResult>;
        function __promisify__(
            type: "x448",
            options: X448KeyPairOptions<"pem", "pem">,
        ): Promise<{
            publicKey: string;
            privateKey: string;
        }>;
        function __promisify__(
            type: "x448",
            options: X448KeyPairOptions<"pem", "der">,
        ): Promise<{
            publicKey: string;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "x448",
            options: X448KeyPairOptions<"der", "pem">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: string;
        }>;
        function __promisify__(
            type: "x448",
            options: X448KeyPairOptions<"der", "der">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: Buffer;
        }>;
        function __promisify__(type: "x448", options?: X448KeyPairKeyObjectOptions): Promise<KeyPairKeyObjectResult>;
    }
    /**
     * Calculates and returns the signature for `data` using the given private key and
     * algorithm. If `algorithm` is `null` or `undefined`, then the algorithm is
     * dependent upon the key type (especially Ed25519 and Ed448).
     *
     * If `key` is not a `KeyObject`, this function behaves as if `key` had been
     * passed to {@link createPrivateKey}. If it is an object, the following
     * additional properties can be passed:
     *
     * If the `callback` function is provided this function uses libuv's threadpool.
     * @since v12.0.0
     */
    function sign(
        algorithm: string | null | undefined,
        data: NodeJS.ArrayBufferView,
        key: KeyLike | SignKeyObjectInput | SignPrivateKeyInput | SignJsonWebKeyInput,
    ): Buffer;
    function sign(
        algorithm: string | null | undefined,
        data: NodeJS.ArrayBufferView,
        key: KeyLike | SignKeyObjectInput | SignPrivateKeyInput | SignJsonWebKeyInput,
        callback: (error: Error | null, data: Buffer) => void,
    ): void;
    /**
     * Verifies the given signature for `data` using the given key and algorithm. If `algorithm` is `null` or `undefined`, then the algorithm is dependent upon the
     * key type (especially Ed25519 and Ed448).
     *
     * If `key` is not a `KeyObject`, this function behaves as if `key` had been
     * passed to {@link createPublicKey}. If it is an object, the following
     * additional properties can be passed:
     *
     * The `signature` argument is the previously calculated signature for the `data`.
     *
     * Because public keys can be derived from private keys, a private key or a public
     * key may be passed for `key`.
     *
     * If the `callback` function is provided this function uses libuv's threadpool.
     * @since v12.0.0
     */
    function verify(
        algorithm: string | null | undefined,
        data: NodeJS.ArrayBufferView,
        key: KeyLike | VerifyKeyObjectInput | VerifyPublicKeyInput | VerifyJsonWebKeyInput,
        signature: NodeJS.ArrayBufferView,
    ): boolean;
    function verify(
        algorithm: string | null | undefined,
        data: NodeJS.ArrayBufferView,
        key: KeyLike | VerifyKeyObjectInput | VerifyPublicKeyInput | VerifyJsonWebKeyInput,
        signature: NodeJS.ArrayBufferView,
        callback: (error: Error | null, result: boolean) => void,
    ): void;
    /**
     * Computes the Diffie-Hellman secret based on a `privateKey` and a `publicKey`.
     * Both keys must have the same `asymmetricKeyType`, which must be one of `'dh'` (for Diffie-Hellman), `'ec'` (for ECDH), `'x448'`, or `'x25519'` (for ECDH-ES).
     * @since v13.9.0, v12.17.0
     */
    function diffieHellman(options: { privateKey: KeyObject; publicKey: KeyObject }): Buffer;
    /**
     * A utility for creating one-shot hash digests of data. It can be faster than the object-based `crypto.createHash()` when hashing a smaller amount of data
     * (<= 5MB) that's readily available. If the data can be big or if it is streamed, it's still recommended to use `crypto.createHash()` instead. The `algorithm`
     * is dependent on the available algorithms supported by the version of OpenSSL on the platform. Examples are `'sha256'`, `'sha512'`, etc. On recent releases
     * of OpenSSL, `openssl list -digest-algorithms` will display the available digest algorithms.
     *
     * Example:
     *
     * ```js
     * const crypto = require('node:crypto');
     * const { Buffer } = require('node:buffer');
     *
     * // Hashing a string and return the result as a hex-encoded string.
     * const string = 'Node.js';
     * // 10b3493287f831e81a438811a1ffba01f8cec4b7
     * console.log(crypto.hash('sha1', string));
     *
     * // Encode a base64-encoded string into a Buffer, hash it and return
     * // the result as a buffer.
     * const base64 = 'Tm9kZS5qcw==';
     * // <Buffer 10 b3 49 32 87 f8 31 e8 1a 43 88 11 a1 ff ba 01 f8 ce c4 b7>
     * console.log(crypto.hash('sha1', Buffer.from(base64, 'base64'), 'buffer'));
     * ```
     * @since v21.7.0, v20.12.0
     * @param data When `data` is a string, it will be encoded as UTF-8 before being hashed. If a different input encoding is desired for a string input, user
     *             could encode the string into a `TypedArray` using either `TextEncoder` or `Buffer.from()` and passing the encoded `TypedArray` into this API instead.
     * @param [outputEncoding='hex'] [Encoding](https://nodejs.org/docs/latest-v22.x/api/buffer.html#buffers-and-character-encodings) used to encode the returned digest.
     */
    function hash(algorithm: string, data: BinaryLike, outputEncoding?: BinaryToTextEncoding): string;
    function hash(algorithm: string, data: BinaryLike, outputEncoding: "buffer"): Buffer;
    function hash(
        algorithm: string,
        data: BinaryLike,
        outputEncoding?: BinaryToTextEncoding | "buffer",
    ): string | Buffer;
    type CipherMode = "cbc" | "ccm" | "cfb" | "ctr" | "ecb" | "gcm" | "ocb" | "ofb" | "stream" | "wrap" | "xts";
    interface CipherInfoOptions {
        /**
         * A test key length.
         */
        keyLength?: number | undefined;
        /**
         * A test IV length.
         */
        ivLength?: number | undefined;
    }
    interface CipherInfo {
        /**
         * The name of the cipher.
         */
        name: string;
        /**
         * The nid of the cipher.
         */
        nid: number;
        /**
         * The block size of the cipher in bytes.
         * This property is omitted when mode is 'stream'.
         */
        blockSize?: number | undefined;
        /**
         * The expected or default initialization vector length in bytes.
         * This property is omitted if the cipher does not use an initialization vector.
         */
        ivLength?: number | undefined;
        /**
         * The expected or default key length in bytes.
         */
        keyLength: number;
        /**
         * The cipher mode.
         */
        mode: CipherMode;
    }
    /**
     * Returns information about a given cipher.
     *
     * Some ciphers accept variable length keys and initialization vectors. By default,
     * the `crypto.getCipherInfo()` method will return the default values for these
     * ciphers. To test if a given key length or iv length is acceptable for given
     * cipher, use the `keyLength` and `ivLength` options. If the given values are
     * unacceptable, `undefined` will be returned.
     * @since v15.0.0
     * @param nameOrNid The name or nid of the cipher to query.
     */
    function getCipherInfo(nameOrNid: string | number, options?: CipherInfoOptions): CipherInfo | undefined;
    /**
     * HKDF is a simple key derivation function defined in RFC 5869\. The given `ikm`, `salt` and `info` are used with the `digest` to derive a key of `keylen` bytes.
     *
     * The supplied `callback` function is called with two arguments: `err` and `derivedKey`. If an errors occurs while deriving the key, `err` will be set;
     * otherwise `err` will be `null`. The successfully generated `derivedKey` will
     * be passed to the callback as an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer). An error will be thrown if any
     * of the input arguments specify invalid values or types.
     *
     * ```js
     * import { Buffer } from 'node:buffer';
     * const {
     *   hkdf,
     * } = await import('node:crypto');
     *
     * hkdf('sha512', 'key', 'salt', 'info', 64, (err, derivedKey) => {
     *   if (err) throw err;
     *   console.log(Buffer.from(derivedKey).toString('hex'));  // '24156e2...5391653'
     * });
     * ```
     * @since v15.0.0
     * @param digest The digest algorithm to use.
     * @param ikm The input keying material. Must be provided but can be zero-length.
     * @param salt The salt value. Must be provided but can be zero-length.
     * @param info Additional info value. Must be provided but can be zero-length, and cannot be more than 1024 bytes.
     * @param keylen The length of the key to generate. Must be greater than 0. The maximum allowable value is `255` times the number of bytes produced by the selected digest function (e.g. `sha512`
     * generates 64-byte hashes, making the maximum HKDF output 16320 bytes).
     */
    function hkdf(
        digest: string,
        irm: BinaryLike | KeyObject,
        salt: BinaryLike,
        info: BinaryLike,
        keylen: number,
        callback: (err: Error | null, derivedKey: ArrayBuffer) => void,
    ): void;
    /**
     * Provides a synchronous HKDF key derivation function as defined in RFC 5869\. The
     * given `ikm`, `salt` and `info` are used with the `digest` to derive a key of `keylen` bytes.
     *
     * The successfully generated `derivedKey` will be returned as an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer).
     *
     * An error will be thrown if any of the input arguments specify invalid values or
     * types, or if the derived key cannot be generated.
     *
     * ```js
     * import { Buffer } from 'node:buffer';
     * const {
     *   hkdfSync,
     * } = await import('node:crypto');
     *
     * const derivedKey = hkdfSync('sha512', 'key', 'salt', 'info', 64);
     * console.log(Buffer.from(derivedKey).toString('hex'));  // '24156e2...5391653'
     * ```
     * @since v15.0.0
     * @param digest The digest algorithm to use.
     * @param ikm The input keying material. Must be provided but can be zero-length.
     * @param salt The salt value. Must be provided but can be zero-length.
     * @param info Additional info value. Must be provided but can be zero-length, and cannot be more than 1024 bytes.
     * @param keylen The length of the key to generate. Must be greater than 0. The maximum allowable value is `255` times the number of bytes produced by the selected digest function (e.g. `sha512`
     * generates 64-byte hashes, making the maximum HKDF output 16320 bytes).
     */
    function hkdfSync(
        digest: string,
        ikm: BinaryLike | KeyObject,
        salt: BinaryLike,
        info: BinaryLike,
        keylen: number,
    ): ArrayBuffer;
    interface SecureHeapUsage {
        /**
         * The total allocated secure heap size as specified using the `--secure-heap=n` command-line flag.
         */
        total: number;
        /**
         * The minimum allocation from the secure heap as specified using the `--secure-heap-min` command-line flag.
         */
        min: number;
        /**
         * The total number of bytes currently allocated from the secure heap.
         */
        used: number;
        /**
         * The calculated ratio of `used` to `total` allocated bytes.
         */
        utilization: number;
    }
    /**
     * @since v15.6.0
     */
    function secureHeapUsed(): SecureHeapUsage;
    interface RandomUUIDOptions {
        /**
         * By default, to improve performance,
         * Node.js will pre-emptively generate and persistently cache enough
         * random data to generate up to 128 random UUIDs. To generate a UUID
         * without using the cache, set `disableEntropyCache` to `true`.
         *
         * @default `false`
         */
        disableEntropyCache?: boolean | undefined;
    }
    type UUID = `${string}-${string}-${string}-${string}-${string}`;
    /**
     * Generates a random [RFC 4122](https://www.rfc-editor.org/rfc/rfc4122.txt) version 4 UUID. The UUID is generated using a
     * cryptographic pseudorandom number generator.
     * @since v15.6.0, v14.17.0
     */
    function randomUUID(options?: RandomUUIDOptions): UUID;
    interface X509CheckOptions {
        /**
         * @default 'always'
         */
        subject?: "always" | "default" | "never";
        /**
         * @default true
         */
        wildcards?: boolean;
        /**
         * @default true
         */
        partialWildcards?: boolean;
        /**
         * @default false
         */
        multiLabelWildcards?: boolean;
        /**
         * @default false
         */
        singleLabelSubdomains?: boolean;
    }
    /**
     * Encapsulates an X509 certificate and provides read-only access to
     * its information.
     *
     * ```js
     * const { X509Certificate } = await import('node:crypto');
     *
     * const x509 = new X509Certificate('{... pem encoded cert ...}');
     *
     * console.log(x509.subject);
     * ```
     * @since v15.6.0
     */
    class X509Certificate {
        /**
         * Will be \`true\` if this is a Certificate Authority (CA) certificate.
         * @since v15.6.0
         */
        readonly ca: boolean;
        /**
         * The SHA-1 fingerprint of this certificate.
         *
         * Because SHA-1 is cryptographically broken and because the security of SHA-1 is
         * significantly worse than that of algorithms that are commonly used to sign
         * certificates, consider using `x509.fingerprint256` instead.
         * @since v15.6.0
         */
        readonly fingerprint: string;
        /**
         * The SHA-256 fingerprint of this certificate.
         * @since v15.6.0
         */
        readonly fingerprint256: string;
        /**
         * The SHA-512 fingerprint of this certificate.
         *
         * Because computing the SHA-256 fingerprint is usually faster and because it is
         * only half the size of the SHA-512 fingerprint, `x509.fingerprint256` may be
         * a better choice. While SHA-512 presumably provides a higher level of security in
         * general, the security of SHA-256 matches that of most algorithms that are
         * commonly used to sign certificates.
         * @since v17.2.0, v16.14.0
         */
        readonly fingerprint512: string;
        /**
         * The complete subject of this certificate.
         * @since v15.6.0
         */
        readonly subject: string;
        /**
         * The subject alternative name specified for this certificate.
         *
         * This is a comma-separated list of subject alternative names. Each entry begins
         * with a string identifying the kind of the subject alternative name followed by
         * a colon and the value associated with the entry.
         *
         * Earlier versions of Node.js incorrectly assumed that it is safe to split this
         * property at the two-character sequence `', '` (see [CVE-2021-44532](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44532)). However,
         * both malicious and legitimate certificates can contain subject alternative names
         * that include this sequence when represented as a string.
         *
         * After the prefix denoting the type of the entry, the remainder of each entry
         * might be enclosed in quotes to indicate that the value is a JSON string literal.
         * For backward compatibility, Node.js only uses JSON string literals within this
         * property when necessary to avoid ambiguity. Third-party code should be prepared
         * to handle both possible entry formats.
         * @since v15.6.0
         */
        readonly subjectAltName: string | undefined;
        /**
         * A textual representation of the certificate's authority information access
         * extension.
         *
         * This is a line feed separated list of access descriptions. Each line begins with
         * the access method and the kind of the access location, followed by a colon and
         * the value associated with the access location.
         *
         * After the prefix denoting the access method and the kind of the access location,
         * the remainder of each line might be enclosed in quotes to indicate that the
         * value is a JSON string literal. For backward compatibility, Node.js only uses
         * JSON string literals within this property when necessary to avoid ambiguity.
         * Third-party code should be prepared to handle both possible entry formats.
         * @since v15.6.0
         */
        readonly infoAccess: string | undefined;
        /**
         * An array detailing the key usages for this certificate.
         * @since v15.6.0
         */
        readonly keyUsage: string[];
        /**
         * The issuer identification included in this certificate.
         * @since v15.6.0
         */
        readonly issuer: string;
        /**
         * The issuer certificate or `undefined` if the issuer certificate is not
         * available.
         * @since v15.9.0
         */
        readonly issuerCertificate?: X509Certificate | undefined;
        /**
         * The public key `KeyObject` for this certificate.
         * @since v15.6.0
         */
        readonly publicKey: KeyObject;
        /**
         * A `Buffer` containing the DER encoding of this certificate.
         * @since v15.6.0
         */
        readonly raw: Buffer;
        /**
         * The serial number of this certificate.
         *
         * Serial numbers are assigned by certificate authorities and do not uniquely
         * identify certificates. Consider using `x509.fingerprint256` as a unique
         * identifier instead.
         * @since v15.6.0
         */
        readonly serialNumber: string;
        /**
         * The date/time from which this certificate is considered valid.
         * @since v15.6.0
         */
        readonly validFrom: string;
        /**
         * The date/time until which this certificate is considered valid.
         * @since v15.6.0
         */
        readonly validTo: string;
        constructor(buffer: BinaryLike);
        /**
         * Checks whether the certificate matches the given email address.
         *
         * If the `'subject'` option is undefined or set to `'default'`, the certificate
         * subject is only considered if the subject alternative name extension either does
         * not exist or does not contain any email addresses.
         *
         * If the `'subject'` option is set to `'always'` and if the subject alternative
         * name extension either does not exist or does not contain a matching email
         * address, the certificate subject is considered.
         *
         * If the `'subject'` option is set to `'never'`, the certificate subject is never
         * considered, even if the certificate contains no subject alternative names.
         * @since v15.6.0
         * @return Returns `email` if the certificate matches, `undefined` if it does not.
         */
        checkEmail(email: string, options?: Pick<X509CheckOptions, "subject">): string | undefined;
        /**
         * Checks whether the certificate matches the given host name.
         *
         * If the certificate matches the given host name, the matching subject name is
         * returned. The returned name might be an exact match (e.g., `foo.example.com`)
         * or it might contain wildcards (e.g., `*.example.com`). Because host name
         * comparisons are case-insensitive, the returned subject name might also differ
         * from the given `name` in capitalization.
         *
         * If the `'subject'` option is undefined or set to `'default'`, the certificate
         * subject is only considered if the subject alternative name extension either does
         * not exist or does not contain any DNS names. This behavior is consistent with [RFC 2818](https://www.rfc-editor.org/rfc/rfc2818.txt) ("HTTP Over TLS").
         *
         * If the `'subject'` option is set to `'always'` and if the subject alternative
         * name extension either does not exist or does not contain a matching DNS name,
         * the certificate subject is considered.
         *
         * If the `'subject'` option is set to `'never'`, the certificate subject is never
         * considered, even if the certificate contains no subject alternative names.
         * @since v15.6.0
         * @return Returns a subject name that matches `name`, or `undefined` if no subject name matches `name`.
         */
        checkHost(name: string, options?: X509CheckOptions): string | undefined;
        /**
         * Checks whether the certificate matches the given IP address (IPv4 or IPv6).
         *
         * Only [RFC 5280](https://www.rfc-editor.org/rfc/rfc5280.txt) `iPAddress` subject alternative names are considered, and they
         * must match the given `ip` address exactly. Other subject alternative names as
         * well as the subject field of the certificate are ignored.
         * @since v15.6.0
         * @return Returns `ip` if the certificate matches, `undefined` if it does not.
         */
        checkIP(ip: string): string | undefined;
        /**
         * Checks whether this certificate was issued by the given `otherCert`.
         * @since v15.6.0
         */
        checkIssued(otherCert: X509Certificate): boolean;
        /**
         * Checks whether the public key for this certificate is consistent with
         * the given private key.
         * @since v15.6.0
         * @param privateKey A private key.
         */
        checkPrivateKey(privateKey: KeyObject): boolean;
        /**
         * There is no standard JSON encoding for X509 certificates. The`toJSON()` method returns a string containing the PEM encoded
         * certificate.
         * @since v15.6.0
         */
        toJSON(): string;
        /**
         * Returns information about this certificate using the legacy `certificate object` encoding.
         * @since v15.6.0
         */
        toLegacyObject(): PeerCertificate;
        /**
         * Returns the PEM-encoded certificate.
         * @since v15.6.0
         */
        toString(): string;
        /**
         * Verifies that this certificate was signed by the given public key.
         * Does not perform any other validation checks on the certificate.
         * @since v15.6.0
         * @param publicKey A public key.
         */
        verify(publicKey: KeyObject): boolean;
    }
    type LargeNumberLike = NodeJS.ArrayBufferView | SharedArrayBuffer | ArrayBuffer | bigint;
    interface GeneratePrimeOptions {
        add?: LargeNumberLike | undefined;
        rem?: LargeNumberLike | undefined;
        /**
         * @default false
         */
        safe?: boolean | undefined;
        bigint?: boolean | undefined;
    }
    interface GeneratePrimeOptionsBigInt extends GeneratePrimeOptions {
        bigint: true;
    }
    interface GeneratePrimeOptionsArrayBuffer extends GeneratePrimeOptions {
        bigint?: false | undefined;
    }
    /**
     * Generates a pseudorandom prime of `size` bits.
     *
     * If `options.safe` is `true`, the prime will be a safe prime -- that is, `(prime - 1) / 2` will also be a prime.
     *
     * The `options.add` and `options.rem` parameters can be used to enforce additional
     * requirements, e.g., for Diffie-Hellman:
     *
     * * If `options.add` and `options.rem` are both set, the prime will satisfy the
     * condition that `prime % add = rem`.
     * * If only `options.add` is set and `options.safe` is not `true`, the prime will
     * satisfy the condition that `prime % add = 1`.
     * * If only `options.add` is set and `options.safe` is set to `true`, the prime
     * will instead satisfy the condition that `prime % add = 3`. This is necessary
     * because `prime % add = 1` for `options.add > 2` would contradict the condition
     * enforced by `options.safe`.
     * * `options.rem` is ignored if `options.add` is not given.
     *
     * Both `options.add` and `options.rem` must be encoded as big-endian sequences
     * if given as an `ArrayBuffer`, `SharedArrayBuffer`, `TypedArray`, `Buffer`, or `DataView`.
     *
     * By default, the prime is encoded as a big-endian sequence of octets
     * in an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer). If the `bigint` option is `true`, then a
     * [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) is provided.
     * @since v15.8.0
     * @param size The size (in bits) of the prime to generate.
     */
    function generatePrime(size: number, callback: (err: Error | null, prime: ArrayBuffer) => void): void;
    function generatePrime(
        size: number,
        options: GeneratePrimeOptionsBigInt,
        callback: (err: Error | null, prime: bigint) => void,
    ): void;
    function generatePrime(
        size: number,
        options: GeneratePrimeOptionsArrayBuffer,
        callback: (err: Error | null, prime: ArrayBuffer) => void,
    ): void;
    function generatePrime(
        size: number,
        options: GeneratePrimeOptions,
        callback: (err: Error | null, prime: ArrayBuffer | bigint) => void,
    ): void;
    /**
     * Generates a pseudorandom prime of `size` bits.
     *
     * If `options.safe` is `true`, the prime will be a safe prime -- that is, `(prime - 1) / 2` will also be a prime.
     *
     * The `options.add` and `options.rem` parameters can be used to enforce additional
     * requirements, e.g., for Diffie-Hellman:
     *
     * * If `options.add` and `options.rem` are both set, the prime will satisfy the
     * condition that `prime % add = rem`.
     * * If only `options.add` is set and `options.safe` is not `true`, the prime will
     * satisfy the condition that `prime % add = 1`.
     * * If only `options.add` is set and `options.safe` is set to `true`, the prime
     * will instead satisfy the condition that `prime % add = 3`. This is necessary
     * because `prime % add = 1` for `options.add > 2` would contradict the condition
     * enforced by `options.safe`.
     * * `options.rem` is ignored if `options.add` is not given.
     *
     * Both `options.add` and `options.rem` must be encoded as big-endian sequences
     * if given as an `ArrayBuffer`, `SharedArrayBuffer`, `TypedArray`, `Buffer`, or `DataView`.
     *
     * By default, the prime is encoded as a big-endian sequence of octets
     * in an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer). If the `bigint` option is `true`, then a
     * [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) is provided.
     * @since v15.8.0
     * @param size The size (in bits) of the prime to generate.
     */
    function generatePrimeSync(size: number): ArrayBuffer;
    function generatePrimeSync(size: number, options: GeneratePrimeOptionsBigInt): bigint;
    function generatePrimeSync(size: number, options: GeneratePrimeOptionsArrayBuffer): ArrayBuffer;
    function generatePrimeSync(size: number, options: GeneratePrimeOptions): ArrayBuffer | bigint;
    interface CheckPrimeOptions {
        /**
         * The number of Miller-Rabin probabilistic primality iterations to perform.
         * When the value is 0 (zero), a number of checks is used that yields a false positive rate of at most `2**-64` for random input.
         * Care must be used when selecting a number of checks.
         * Refer to the OpenSSL documentation for the BN_is_prime_ex function nchecks options for more details.
         *
         * @default 0
         */
        checks?: number | undefined;
    }
    /**
     * Checks the primality of the `candidate`.
     * @since v15.8.0
     * @param candidate A possible prime encoded as a sequence of big endian octets of arbitrary length.
     */
    function checkPrime(value: LargeNumberLike, callback: (err: Error | null, result: boolean) => void): void;
    function checkPrime(
        value: LargeNumberLike,
        options: CheckPrimeOptions,
        callback: (err: Error | null, result: boolean) => void,
    ): void;
    /**
     * Checks the primality of the `candidate`.
     * @since v15.8.0
     * @param candidate A possible prime encoded as a sequence of big endian octets of arbitrary length.
     * @return `true` if the candidate is a prime with an error probability less than `0.25 ** options.checks`.
     */
    function checkPrimeSync(candidate: LargeNumberLike, options?: CheckPrimeOptions): boolean;
    /**
     * Load and set the `engine` for some or all OpenSSL functions (selected by flags).
     *
     * `engine` could be either an id or a path to the engine's shared library.
     *
     * The optional `flags` argument uses `ENGINE_METHOD_ALL` by default. The `flags` is a bit field taking one of or a mix of the following flags (defined in `crypto.constants`):
     *
     * * `crypto.constants.ENGINE_METHOD_RSA`
     * * `crypto.constants.ENGINE_METHOD_DSA`
     * * `crypto.constants.ENGINE_METHOD_DH`
     * * `crypto.constants.ENGINE_METHOD_RAND`
     * * `crypto.constants.ENGINE_METHOD_EC`
     * * `crypto.constants.ENGINE_METHOD_CIPHERS`
     * * `crypto.constants.ENGINE_METHOD_DIGESTS`
     * * `crypto.constants.ENGINE_METHOD_PKEY_METHS`
     * * `crypto.constants.ENGINE_METHOD_PKEY_ASN1_METHS`
     * * `crypto.constants.ENGINE_METHOD_ALL`
     * * `crypto.constants.ENGINE_METHOD_NONE`
     * @since v0.11.11
     * @param flags
     */
    function setEngine(engine: string, flags?: number): void;
    /**
     * A convenient alias for {@link webcrypto.getRandomValues}. This
     * implementation is not compliant with the Web Crypto spec, to write
     * web-compatible code use {@link webcrypto.getRandomValues} instead.
     * @since v17.4.0
     * @return Returns `typedArray`.
     */
    function getRandomValues<T extends webcrypto.BufferSource>(typedArray: T): T;
    /**
     * A convenient alias for `crypto.webcrypto.subtle`.
     * @since v17.4.0
     */
    const subtle: webcrypto.SubtleCrypto;
    /**
     * An implementation of the Web Crypto API standard.
     *
     * See the {@link https://nodejs.org/docs/latest/api/webcrypto.html Web Crypto API documentation} for details.
     * @since v15.0.0
     */
    const webcrypto: webcrypto.Crypto;
    namespace webcrypto {
        type BufferSource = ArrayBufferView | ArrayBuffer;
        type KeyFormat = "jwk" | "pkcs8" | "raw" | "spki";
        type KeyType = "private" | "public" | "secret";
        type KeyUsage =
            | "decrypt"
            | "deriveBits"
            | "deriveKey"
            | "encrypt"
            | "sign"
            | "unwrapKey"
            | "verify"
            | "wrapKey";
        type AlgorithmIdentifier = Algorithm | string;
        type HashAlgorithmIdentifier = AlgorithmIdentifier;
        type NamedCurve = string;
        type BigInteger = Uint8Array;
        interface AesCbcParams extends Algorithm {
            iv: BufferSource;
        }
        interface AesCtrParams extends Algorithm {
            counter: BufferSource;
            length: number;
        }
        interface AesDerivedKeyParams extends Algorithm {
            length: number;
        }
        interface AesGcmParams extends Algorithm {
            additionalData?: BufferSource;
            iv: BufferSource;
            tagLength?: number;
        }
        interface AesKeyAlgorithm extends KeyAlgorithm {
            length: number;
        }
        interface AesKeyGenParams extends Algorithm {
            length: number;
        }
        interface Algorithm {
            name: string;
        }
        interface EcKeyAlgorithm extends KeyAlgorithm {
            namedCurve: NamedCurve;
        }
        interface EcKeyGenParams extends Algorithm {
            namedCurve: NamedCurve;
        }
        interface EcKeyImportParams extends Algorithm {
            namedCurve: NamedCurve;
        }
        interface EcdhKeyDeriveParams extends Algorithm {
            public: CryptoKey;
        }
        interface EcdsaParams extends Algorithm {
            hash: HashAlgorithmIdentifier;
        }
        interface Ed448Params extends Algorithm {
            context?: BufferSource;
        }
        interface HkdfParams extends Algorithm {
            hash: HashAlgorithmIdentifier;
            info: BufferSource;
            salt: BufferSource;
        }
        interface HmacImportParams extends Algorithm {
            hash: HashAlgorithmIdentifier;
            length?: number;
        }
        interface HmacKeyAlgorithm extends KeyAlgorithm {
            hash: KeyAlgorithm;
            length: number;
        }
        interface HmacKeyGenParams extends Algorithm {
            hash: HashAlgorithmIdentifier;
            length?: number;
        }
        interface JsonWebKey {
            alg?: string;
            crv?: string;
            d?: string;
            dp?: string;
            dq?: string;
            e?: string;
            ext?: boolean;
            k?: string;
            key_ops?: string[];
            kty?: string;
            n?: string;
            oth?: RsaOtherPrimesInfo[];
            p?: string;
            q?: string;
            qi?: string;
            use?: string;
            x?: string;
            y?: string;
        }
        interface KeyAlgorithm {
            name: string;
        }
        interface Pbkdf2Params extends Algorithm {
            hash: HashAlgorithmIdentifier;
            iterations: number;
            salt: BufferSource;
        }
        interface RsaHashedImportParams extends Algorithm {
            hash: HashAlgorithmIdentifier;
        }
        interface RsaHashedKeyAlgorithm extends RsaKeyAlgorithm {
            hash: KeyAlgorithm;
        }
        interface RsaHashedKeyGenParams extends RsaKeyGenParams {
            hash: HashAlgorithmIdentifier;
        }
        interface RsaKeyAlgorithm extends KeyAlgorithm {
            modulusLength: number;
            publicExponent: BigInteger;
        }
        interface RsaKeyGenParams extends Algorithm {
            modulusLength: number;
            publicExponent: BigInteger;
        }
        interface RsaOaepParams extends Algorithm {
            label?: BufferSource;
        }
        interface RsaOtherPrimesInfo {
            d?: string;
            r?: string;
            t?: string;
        }
        interface RsaPssParams extends Algorithm {
            saltLength: number;
        }
        /**
         * Calling `require('node:crypto').webcrypto` returns an instance of the `Crypto` class.
         * `Crypto` is a singleton that provides access to the remainder of the crypto API.
         * @since v15.0.0
         */
        interface Crypto {
            /**
             * Provides access to the `SubtleCrypto` API.
             * @since v15.0.0
             */
            readonly subtle: SubtleCrypto;
            /**
             * Generates cryptographically strong random values.
             * The given `typedArray` is filled with random values, and a reference to `typedArray` is returned.
             *
             * The given `typedArray` must be an integer-based instance of {@link NodeJS.TypedArray}, i.e. `Float32Array` and `Float64Array` are not accepted.
             *
             * An error will be thrown if the given `typedArray` is larger than 65,536 bytes.
             * @since v15.0.0
             */
            getRandomValues<T extends Exclude<NodeJS.TypedArray, Float32Array | Float64Array>>(typedArray: T): T;
            /**
             * Generates a random {@link https://www.rfc-editor.org/rfc/rfc4122.txt RFC 4122} version 4 UUID.
             * The UUID is generated using a cryptographic pseudorandom number generator.
             * @since v16.7.0
             */
            randomUUID(): UUID;
            CryptoKey: CryptoKeyConstructor;
        }
        // This constructor throws ILLEGAL_CONSTRUCTOR so it should not be newable.
        interface CryptoKeyConstructor {
            /** Illegal constructor */
            (_: { readonly _: unique symbol }): never; // Allows instanceof to work but not be callable by the user.
            readonly length: 0;
            readonly name: "CryptoKey";
            readonly prototype: CryptoKey;
        }
        /**
         * @since v15.0.0
         */
        interface CryptoKey {
            /**
             * An object detailing the algorithm for which the key can be used along with additional algorithm-specific parameters.
             * @since v15.0.0
             */
            readonly algorithm: KeyAlgorithm;
            /**
             * When `true`, the {@link CryptoKey} can be extracted using either `subtleCrypto.exportKey()` or `subtleCrypto.wrapKey()`.
             * @since v15.0.0
             */
            readonly extractable: boolean;
            /**
             * A string identifying whether the key is a symmetric (`'secret'`) or asymmetric (`'private'` or `'public'`) key.
             * @since v15.0.0
             */
            readonly type: KeyType;
            /**
             * An array of strings identifying the operations for which the key may be used.
             *
             * The possible usages are:
             * - `'encrypt'` - The key may be used to encrypt data.
             * - `'decrypt'` - The key may be used to decrypt data.
             * - `'sign'` - The key may be used to generate digital signatures.
             * - `'verify'` - The key may be used to verify digital signatures.
             * - `'deriveKey'` - The key may be used to derive a new key.
             * - `'deriveBits'` - The key may be used to derive bits.
             * - `'wrapKey'` - The key may be used to wrap another key.
             * - `'unwrapKey'` - The key may be used to unwrap another key.
             *
             * Valid key usages depend on the key algorithm (identified by `cryptokey.algorithm.name`).
             * @since v15.0.0
             */
            readonly usages: KeyUsage[];
        }
        /**
         * The `CryptoKeyPair` is a simple dictionary object with `publicKey` and `privateKey` properties, representing an asymmetric key pair.
         * @since v15.0.0
         */
        interface CryptoKeyPair {
            /**
             * A {@link CryptoKey} whose type will be `'private'`.
             * @since v15.0.0
             */
            privateKey: CryptoKey;
            /**
             * A {@link CryptoKey} whose type will be `'public'`.
             * @since v15.0.0
             */
            publicKey: CryptoKey;
        }
        /**
         * @since v15.0.0
         */
        interface SubtleCrypto {
            /**
             * Using the method and parameters specified in `algorithm` and the keying material provided by `key`,
             * `subtle.decrypt()` attempts to decipher the provided `data`. If successful,
             * the returned promise will be resolved with an `<ArrayBuffer>` containing the plaintext result.
             *
             * The algorithms currently supported include:
             *
             * - `'RSA-OAEP'`
             * - `'AES-CTR'`
             * - `'AES-CBC'`
             * - `'AES-GCM'`
             * @since v15.0.0
             */
            decrypt(
                algorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams,
                key: CryptoKey,
                data: BufferSource,
            ): Promise<ArrayBuffer>;
            /**
             * Using the method and parameters specified in `algorithm` and the keying material provided by `baseKey`,
             * `subtle.deriveBits()` attempts to generate `length` bits.
             * The Node.js implementation requires that when `length` is a number it must be multiple of `8`.
             * When `length` is `null` the maximum number of bits for a given algorithm is generated. This is allowed
             * for the `'ECDH'`, `'X25519'`, and `'X448'` algorithms.
             * If successful, the returned promise will be resolved with an `<ArrayBuffer>` containing the generated data.
             *
             * The algorithms currently supported include:
             *
             * - `'ECDH'`
             * - `'X25519'`
             * - `'X448'`
             * - `'HKDF'`
             * - `'PBKDF2'`
             * @since v15.0.0
             */
            deriveBits(algorithm: EcdhKeyDeriveParams, baseKey: CryptoKey, length: number | null): Promise<ArrayBuffer>;
            deriveBits(
                algorithm: AlgorithmIdentifier | HkdfParams | Pbkdf2Params,
                baseKey: CryptoKey,
                length: number,
            ): Promise<ArrayBuffer>;
            /**
             * Using the method and parameters specified in `algorithm`, and the keying material provided by `baseKey`,
             * `subtle.deriveKey()` attempts to generate a new <CryptoKey>` based on the method and parameters in `derivedKeyAlgorithm`.
             *
             * Calling `subtle.deriveKey()` is equivalent to calling `subtle.deriveBits()` to generate raw keying material,
             * then passing the result into the `subtle.importKey()` method using the `deriveKeyAlgorithm`, `extractable`, and `keyUsages` parameters as input.
             *
             * The algorithms currently supported include:
             *
             * - `'ECDH'`
             * - `'X25519'`
             * - `'X448'`
             * - `'HKDF'`
             * - `'PBKDF2'`
             * @param keyUsages See {@link https://nodejs.org/docs/latest/api/webcrypto.html#cryptokeyusages Key usages}.
             * @since v15.0.0
             */
            deriveKey(
                algorithm: AlgorithmIdentifier | EcdhKeyDeriveParams | HkdfParams | Pbkdf2Params,
                baseKey: CryptoKey,
                derivedKeyAlgorithm:
                    | AlgorithmIdentifier
                    | AesDerivedKeyParams
                    | HmacImportParams
                    | HkdfParams
                    | Pbkdf2Params,
                extractable: boolean,
                keyUsages: readonly KeyUsage[],
            ): Promise<CryptoKey>;
            /**
             * Using the method identified by `algorithm`, `subtle.digest()` attempts to generate a digest of `data`.
             * If successful, the returned promise is resolved with an `<ArrayBuffer>` containing the computed digest.
             *
             * If `algorithm` is provided as a `<string>`, it must be one of:
             *
             * - `'SHA-1'`
             * - `'SHA-256'`
             * - `'SHA-384'`
             * - `'SHA-512'`
             *
             * If `algorithm` is provided as an `<Object>`, it must have a `name` property whose value is one of the above.
             * @since v15.0.0
             */
            digest(algorithm: AlgorithmIdentifier, data: BufferSource): Promise<ArrayBuffer>;
            /**
             * Using the method and parameters specified by `algorithm` and the keying material provided by `key`,
             * `subtle.encrypt()` attempts to encipher `data`. If successful,
             * the returned promise is resolved with an `<ArrayBuffer>` containing the encrypted result.
             *
             * The algorithms currently supported include:
             *
             * - `'RSA-OAEP'`
             * - `'AES-CTR'`
             * - `'AES-CBC'`
             * - `'AES-GCM'`
             * @since v15.0.0
             */
            encrypt(
                algorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams,
                key: CryptoKey,
                data: BufferSource,
            ): Promise<ArrayBuffer>;
            /**
             * Exports the given key into the specified format, if supported.
             *
             * If the `<CryptoKey>` is not extractable, the returned promise will reject.
             *
             * When `format` is either `'pkcs8'` or `'spki'` and the export is successful,
             * the returned promise will be resolved with an `<ArrayBuffer>` containing the exported key data.
             *
             * When `format` is `'jwk'` and the export is successful, the returned promise will be resolved with a
             * JavaScript object conforming to the {@link https://tools.ietf.org/html/rfc7517 JSON Web Key} specification.
             * @param format Must be one of `'raw'`, `'pkcs8'`, `'spki'`, or `'jwk'`.
             * @returns `<Promise>` containing `<ArrayBuffer>`.
             * @since v15.0.0
             */
            exportKey(format: "jwk", key: CryptoKey): Promise<JsonWebKey>;
            exportKey(format: Exclude<KeyFormat, "jwk">, key: CryptoKey): Promise<ArrayBuffer>;
            /**
             * Using the method and parameters provided in `algorithm`,
             * `subtle.generateKey()` attempts to generate new keying material.
             * Depending the method used, the method may generate either a single `<CryptoKey>` or a `<CryptoKeyPair>`.
             *
             * The `<CryptoKeyPair>` (public and private key) generating algorithms supported include:
             *
             * - `'RSASSA-PKCS1-v1_5'`
             * - `'RSA-PSS'`
             * - `'RSA-OAEP'`
             * - `'ECDSA'`
             * - `'Ed25519'`
             * - `'Ed448'`
             * - `'ECDH'`
             * - `'X25519'`
             * - `'X448'`
             * The `<CryptoKey>` (secret key) generating algorithms supported include:
             *
             * - `'HMAC'`
             * - `'AES-CTR'`
             * - `'AES-CBC'`
             * - `'AES-GCM'`
             * - `'AES-KW'`
             * @param keyUsages See {@link https://nodejs.org/docs/latest/api/webcrypto.html#cryptokeyusages Key usages}.
             * @since v15.0.0
             */
            generateKey(
                algorithm: RsaHashedKeyGenParams | EcKeyGenParams,
                extractable: boolean,
                keyUsages: readonly KeyUsage[],
            ): Promise<CryptoKeyPair>;
            generateKey(
                algorithm: AesKeyGenParams | HmacKeyGenParams | Pbkdf2Params,
                extractable: boolean,
                keyUsages: readonly KeyUsage[],
            ): Promise<CryptoKey>;
            generateKey(
                algorithm: AlgorithmIdentifier,
                extractable: boolean,
                keyUsages: KeyUsage[],
            ): Promise<CryptoKeyPair | CryptoKey>;
            /**
             * The `subtle.importKey()` method attempts to interpret the provided `keyData` as the given `format`
             * to create a `<CryptoKey>` instance using the provided `algorithm`, `extractable`, and `keyUsages` arguments.
             * If the import is successful, the returned promise will be resolved with the created `<CryptoKey>`.
             *
             * If importing a `'PBKDF2'` key, `extractable` must be `false`.
             * @param format Must be one of `'raw'`, `'pkcs8'`, `'spki'`, or `'jwk'`.
             * @param keyUsages See {@link https://nodejs.org/docs/latest/api/webcrypto.html#cryptokeyusages Key usages}.
             * @since v15.0.0
             */
            importKey(
                format: "jwk",
                keyData: JsonWebKey,
                algorithm:
                    | AlgorithmIdentifier
                    | RsaHashedImportParams
                    | EcKeyImportParams
                    | HmacImportParams
                    | AesKeyAlgorithm,
                extractable: boolean,
                keyUsages: readonly KeyUsage[],
            ): Promise<CryptoKey>;
            importKey(
                format: Exclude<KeyFormat, "jwk">,
                keyData: BufferSource,
                algorithm:
                    | AlgorithmIdentifier
                    | RsaHashedImportParams
                    | EcKeyImportParams
                    | HmacImportParams
                    | AesKeyAlgorithm,
                extractable: boolean,
                keyUsages: KeyUsage[],
            ): Promise<CryptoKey>;
            /**
             * Using the method and parameters given by `algorithm` and the keying material provided by `key`,
             * `subtle.sign()` attempts to generate a cryptographic signature of `data`. If successful,
             * the returned promise is resolved with an `<ArrayBuffer>` containing the generated signature.
             *
             * The algorithms currently supported include:
             *
             * - `'RSASSA-PKCS1-v1_5'`
             * - `'RSA-PSS'`
             * - `'ECDSA'`
             * - `'Ed25519'`
             * - `'Ed448'`
             * - `'HMAC'`
             * @since v15.0.0
             */
            sign(
                algorithm: AlgorithmIdentifier | RsaPssParams | EcdsaParams | Ed448Params,
                key: CryptoKey,
                data: BufferSource,
            ): Promise<ArrayBuffer>;
            /**
             * In cryptography, "wrapping a key" refers to exporting and then encrypting the keying material.
             * The `subtle.unwrapKey()` method attempts to decrypt a wrapped key and create a `<CryptoKey>` instance.
             * It is equivalent to calling `subtle.decrypt()` first on the encrypted key data (using the `wrappedKey`, `unwrapAlgo`, and `unwrappingKey` arguments as input)
             * then passing the results in to the `subtle.importKey()` method using the `unwrappedKeyAlgo`, `extractable`, and `keyUsages` arguments as inputs.
             * If successful, the returned promise is resolved with a `<CryptoKey>` object.
             *
             * The wrapping algorithms currently supported include:
             *
             * - `'RSA-OAEP'`
             * - `'AES-CTR'`
             * - `'AES-CBC'`
             * - `'AES-GCM'`
             * - `'AES-KW'`
             *
             * The unwrapped key algorithms supported include:
             *
             * - `'RSASSA-PKCS1-v1_5'`
             * - `'RSA-PSS'`
             * - `'RSA-OAEP'`
             * - `'ECDSA'`
             * - `'Ed25519'`
             * - `'Ed448'`
             * - `'ECDH'`
             * - `'X25519'`
             * - `'X448'`
             * - `'HMAC'`
             * - `'AES-CTR'`
             * - `'AES-CBC'`
             * - `'AES-GCM'`
             * - `'AES-KW'`
             * @param format Must be one of `'raw'`, `'pkcs8'`, `'spki'`, or `'jwk'`.
             * @param keyUsages See {@link https://nodejs.org/docs/latest/api/webcrypto.html#cryptokeyusages Key usages}.
             * @since v15.0.0
             */
            unwrapKey(
                format: KeyFormat,
                wrappedKey: BufferSource,
                unwrappingKey: CryptoKey,
                unwrapAlgorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams,
                unwrappedKeyAlgorithm:
                    | AlgorithmIdentifier
                    | RsaHashedImportParams
                    | EcKeyImportParams
                    | HmacImportParams
                    | AesKeyAlgorithm,
                extractable: boolean,
                keyUsages: KeyUsage[],
            ): Promise<CryptoKey>;
            /**
             * Using the method and parameters given in `algorithm` and the keying material provided by `key`,
             * `subtle.verify()` attempts to verify that `signature` is a valid cryptographic signature of `data`.
             * The returned promise is resolved with either `true` or `false`.
             *
             * The algorithms currently supported include:
             *
             * - `'RSASSA-PKCS1-v1_5'`
             * - `'RSA-PSS'`
             * - `'ECDSA'`
             * - `'Ed25519'`
             * - `'Ed448'`
             * - `'HMAC'`
             * @since v15.0.0
             */
            verify(
                algorithm: AlgorithmIdentifier | RsaPssParams | EcdsaParams | Ed448Params,
                key: CryptoKey,
                signature: BufferSource,
                data: BufferSource,
            ): Promise<boolean>;
            /**
             * In cryptography, "wrapping a key" refers to exporting and then encrypting the keying material.
             * The `subtle.wrapKey()` method exports the keying material into the format identified by `format`,
             * then encrypts it using the method and parameters specified by `wrapAlgo` and the keying material provided by `wrappingKey`.
             * It is the equivalent to calling `subtle.exportKey()` using `format` and `key` as the arguments,
             * then passing the result to the `subtle.encrypt()` method using `wrappingKey` and `wrapAlgo` as inputs.
             * If successful, the returned promise will be resolved with an `<ArrayBuffer>` containing the encrypted key data.
             *
             * The wrapping algorithms currently supported include:
             *
             * - `'RSA-OAEP'`
             * - `'AES-CTR'`
             * - `'AES-CBC'`
             * - `'AES-GCM'`
             * - `'AES-KW'`
             * @param format Must be one of `'raw'`, `'pkcs8'`, `'spki'`, or `'jwk'`.
             * @since v15.0.0
             */
            wrapKey(
                format: KeyFormat,
                key: CryptoKey,
                wrappingKey: CryptoKey,
                wrapAlgorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams,
            ): Promise<ArrayBuffer>;
        }
    }

    global {
        var crypto: typeof globalThis extends {
            crypto: infer T;
            onmessage: any;
        } ? T
            : webcrypto.Crypto;
    }
}
declare module "node:crypto" {
    export * from "crypto";
}
/**
 * The `node:dgram` module provides an implementation of UDP datagram sockets.
 *
 * ```js
 * import dgram from 'node:dgram';
 *
 * const server = dgram.createSocket('udp4');
 *
 * server.on('error', (err) => {
 *   console.error(`server error:\n${err.stack}`);
 *   server.close();
 * });
 *
 * server.on('message', (msg, rinfo) => {
 *   console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);
 * });
 *
 * server.on('listening', () => {
 *   const address = server.address();
 *   console.log(`server listening ${address.address}:${address.port}`);
 * });
 *
 * server.bind(41234);
 * // Prints: server listening 0.0.0.0:41234
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/dgram.js)
 */
declare module "dgram" {
    import { AddressInfo } from "node:net";
    import * as dns from "node:dns";
    import { Abortable, EventEmitter } from "node:events";
    interface RemoteInfo {
        address: string;
        family: "IPv4" | "IPv6";
        port: number;
        size: number;
    }
    interface BindOptions {
        port?: number | undefined;
        address?: string | undefined;
        exclusive?: boolean | undefined;
        fd?: number | undefined;
    }
    type SocketType = "udp4" | "udp6";
    interface SocketOptions extends Abortable {
        type: SocketType;
        reuseAddr?: boolean | undefined;
        /**
         * @default false
         */
        ipv6Only?: boolean | undefined;
        recvBufferSize?: number | undefined;
        sendBufferSize?: number | undefined;
        lookup?:
            | ((
                hostname: string,
                options: dns.LookupOneOptions,
                callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void,
            ) => void)
            | undefined;
    }
    /**
     * Creates a `dgram.Socket` object. Once the socket is created, calling `socket.bind()` will instruct the socket to begin listening for datagram
     * messages. When `address` and `port` are not passed to `socket.bind()` the
     * method will bind the socket to the "all interfaces" address on a random port
     * (it does the right thing for both `udp4` and `udp6` sockets). The bound address
     * and port can be retrieved using `socket.address().address` and `socket.address().port`.
     *
     * If the `signal` option is enabled, calling `.abort()` on the corresponding `AbortController` is similar to calling `.close()` on the socket:
     *
     * ```js
     * const controller = new AbortController();
     * const { signal } = controller;
     * const server = dgram.createSocket({ type: 'udp4', signal });
     * server.on('message', (msg, rinfo) => {
     *   console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);
     * });
     * // Later, when you want to close the server.
     * controller.abort();
     * ```
     * @since v0.11.13
     * @param options Available options are:
     * @param callback Attached as a listener for `'message'` events. Optional.
     */
    function createSocket(type: SocketType, callback?: (msg: Buffer, rinfo: RemoteInfo) => void): Socket;
    function createSocket(options: SocketOptions, callback?: (msg: Buffer, rinfo: RemoteInfo) => void): Socket;
    /**
     * Encapsulates the datagram functionality.
     *
     * New instances of `dgram.Socket` are created using {@link createSocket}.
     * The `new` keyword is not to be used to create `dgram.Socket` instances.
     * @since v0.1.99
     */
    class Socket extends EventEmitter {
        /**
         * Tells the kernel to join a multicast group at the given `multicastAddress` and `multicastInterface` using the `IP_ADD_MEMBERSHIP` socket option. If the `multicastInterface` argument is not
         * specified, the operating system will choose
         * one interface and will add membership to it. To add membership to every
         * available interface, call `addMembership` multiple times, once per interface.
         *
         * When called on an unbound socket, this method will implicitly bind to a random
         * port, listening on all interfaces.
         *
         * When sharing a UDP socket across multiple `cluster` workers, the`socket.addMembership()` function must be called only once or an`EADDRINUSE` error will occur:
         *
         * ```js
         * import cluster from 'node:cluster';
         * import dgram from 'node:dgram';
         *
         * if (cluster.isPrimary) {
         *   cluster.fork(); // Works ok.
         *   cluster.fork(); // Fails with EADDRINUSE.
         * } else {
         *   const s = dgram.createSocket('udp4');
         *   s.bind(1234, () => {
         *     s.addMembership('224.0.0.114');
         *   });
         * }
         * ```
         * @since v0.6.9
         */
        addMembership(multicastAddress: string, multicastInterface?: string): void;
        /**
         * Returns an object containing the address information for a socket.
         * For UDP sockets, this object will contain `address`, `family`, and `port` properties.
         *
         * This method throws `EBADF` if called on an unbound socket.
         * @since v0.1.99
         */
        address(): AddressInfo;
        /**
         * For UDP sockets, causes the `dgram.Socket` to listen for datagram
         * messages on a named `port` and optional `address`. If `port` is not
         * specified or is `0`, the operating system will attempt to bind to a
         * random port. If `address` is not specified, the operating system will
         * attempt to listen on all addresses. Once binding is complete, a `'listening'` event is emitted and the optional `callback` function is
         * called.
         *
         * Specifying both a `'listening'` event listener and passing a `callback` to the `socket.bind()` method is not harmful but not very
         * useful.
         *
         * A bound datagram socket keeps the Node.js process running to receive
         * datagram messages.
         *
         * If binding fails, an `'error'` event is generated. In rare case (e.g.
         * attempting to bind with a closed socket), an `Error` may be thrown.
         *
         * Example of a UDP server listening on port 41234:
         *
         * ```js
         * import dgram from 'node:dgram';
         *
         * const server = dgram.createSocket('udp4');
         *
         * server.on('error', (err) => {
         *   console.error(`server error:\n${err.stack}`);
         *   server.close();
         * });
         *
         * server.on('message', (msg, rinfo) => {
         *   console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);
         * });
         *
         * server.on('listening', () => {
         *   const address = server.address();
         *   console.log(`server listening ${address.address}:${address.port}`);
         * });
         *
         * server.bind(41234);
         * // Prints: server listening 0.0.0.0:41234
         * ```
         * @since v0.1.99
         * @param callback with no parameters. Called when binding is complete.
         */
        bind(port?: number, address?: string, callback?: () => void): this;
        bind(port?: number, callback?: () => void): this;
        bind(callback?: () => void): this;
        bind(options: BindOptions, callback?: () => void): this;
        /**
         * Close the underlying socket and stop listening for data on it. If a callback is
         * provided, it is added as a listener for the `'close'` event.
         * @since v0.1.99
         * @param callback Called when the socket has been closed.
         */
        close(callback?: () => void): this;
        /**
         * Associates the `dgram.Socket` to a remote address and port. Every
         * message sent by this handle is automatically sent to that destination. Also,
         * the socket will only receive messages from that remote peer.
         * Trying to call `connect()` on an already connected socket will result
         * in an `ERR_SOCKET_DGRAM_IS_CONNECTED` exception. If `address` is not
         * provided, `'127.0.0.1'` (for `udp4` sockets) or `'::1'` (for `udp6` sockets)
         * will be used by default. Once the connection is complete, a `'connect'` event
         * is emitted and the optional `callback` function is called. In case of failure,
         * the `callback` is called or, failing this, an `'error'` event is emitted.
         * @since v12.0.0
         * @param callback Called when the connection is completed or on error.
         */
        connect(port: number, address?: string, callback?: () => void): void;
        connect(port: number, callback: () => void): void;
        /**
         * A synchronous function that disassociates a connected `dgram.Socket` from
         * its remote address. Trying to call `disconnect()` on an unbound or already
         * disconnected socket will result in an `ERR_SOCKET_DGRAM_NOT_CONNECTED` exception.
         * @since v12.0.0
         */
        disconnect(): void;
        /**
         * Instructs the kernel to leave a multicast group at `multicastAddress` using the `IP_DROP_MEMBERSHIP` socket option. This method is automatically called by the
         * kernel when the socket is closed or the process terminates, so most apps will
         * never have reason to call this.
         *
         * If `multicastInterface` is not specified, the operating system will attempt to
         * drop membership on all valid interfaces.
         * @since v0.6.9
         */
        dropMembership(multicastAddress: string, multicastInterface?: string): void;
        /**
         * This method throws `ERR_SOCKET_BUFFER_SIZE` if called on an unbound socket.
         * @since v8.7.0
         * @return the `SO_RCVBUF` socket receive buffer size in bytes.
         */
        getRecvBufferSize(): number;
        /**
         * This method throws `ERR_SOCKET_BUFFER_SIZE` if called on an unbound socket.
         * @since v8.7.0
         * @return the `SO_SNDBUF` socket send buffer size in bytes.
         */
        getSendBufferSize(): number;
        /**
         * @since v18.8.0, v16.19.0
         * @return Number of bytes queued for sending.
         */
        getSendQueueSize(): number;
        /**
         * @since v18.8.0, v16.19.0
         * @return Number of send requests currently in the queue awaiting to be processed.
         */
        getSendQueueCount(): number;
        /**
         * By default, binding a socket will cause it to block the Node.js process from
         * exiting as long as the socket is open. The `socket.unref()` method can be used
         * to exclude the socket from the reference counting that keeps the Node.js
         * process active. The `socket.ref()` method adds the socket back to the reference
         * counting and restores the default behavior.
         *
         * Calling `socket.ref()` multiples times will have no additional effect.
         *
         * The `socket.ref()` method returns a reference to the socket so calls can be
         * chained.
         * @since v0.9.1
         */
        ref(): this;
        /**
         * Returns an object containing the `address`, `family`, and `port` of the remote
         * endpoint. This method throws an `ERR_SOCKET_DGRAM_NOT_CONNECTED` exception
         * if the socket is not connected.
         * @since v12.0.0
         */
        remoteAddress(): AddressInfo;
        /**
         * Broadcasts a datagram on the socket.
         * For connectionless sockets, the destination `port` and `address` must be
         * specified. Connected sockets, on the other hand, will use their associated
         * remote endpoint, so the `port` and `address` arguments must not be set.
         *
         * The `msg` argument contains the message to be sent.
         * Depending on its type, different behavior can apply. If `msg` is a `Buffer`,
         * any `TypedArray` or a `DataView`,
         * the `offset` and `length` specify the offset within the `Buffer` where the
         * message begins and the number of bytes in the message, respectively.
         * If `msg` is a `String`, then it is automatically converted to a `Buffer` with `'utf8'` encoding. With messages that
         * contain multi-byte characters, `offset` and `length` will be calculated with
         * respect to `byte length` and not the character position.
         * If `msg` is an array, `offset` and `length` must not be specified.
         *
         * The `address` argument is a string. If the value of `address` is a host name,
         * DNS will be used to resolve the address of the host. If `address` is not
         * provided or otherwise nullish, `'127.0.0.1'` (for `udp4` sockets) or `'::1'` (for `udp6` sockets) will be used by default.
         *
         * If the socket has not been previously bound with a call to `bind`, the socket
         * is assigned a random port number and is bound to the "all interfaces" address
         * (`'0.0.0.0'` for `udp4` sockets, `'::0'` for `udp6` sockets.)
         *
         * An optional `callback` function may be specified to as a way of reporting
         * DNS errors or for determining when it is safe to reuse the `buf` object.
         * DNS lookups delay the time to send for at least one tick of the
         * Node.js event loop.
         *
         * The only way to know for sure that the datagram has been sent is by using a `callback`. If an error occurs and a `callback` is given, the error will be
         * passed as the first argument to the `callback`. If a `callback` is not given,
         * the error is emitted as an `'error'` event on the `socket` object.
         *
         * Offset and length are optional but both _must_ be set if either are used.
         * They are supported only when the first argument is a `Buffer`, a `TypedArray`,
         * or a `DataView`.
         *
         * This method throws `ERR_SOCKET_BAD_PORT` if called on an unbound socket.
         *
         * Example of sending a UDP packet to a port on `localhost`;
         *
         * ```js
         * import dgram from 'node:dgram';
         * import { Buffer } from 'node:buffer';
         *
         * const message = Buffer.from('Some bytes');
         * const client = dgram.createSocket('udp4');
         * client.send(message, 41234, 'localhost', (err) => {
         *   client.close();
         * });
         * ```
         *
         * Example of sending a UDP packet composed of multiple buffers to a port on`127.0.0.1`;
         *
         * ```js
         * import dgram from 'node:dgram';
         * import { Buffer } from 'node:buffer';
         *
         * const buf1 = Buffer.from('Some ');
         * const buf2 = Buffer.from('bytes');
         * const client = dgram.createSocket('udp4');
         * client.send([buf1, buf2], 41234, (err) => {
         *   client.close();
         * });
         * ```
         *
         * Sending multiple buffers might be faster or slower depending on the
         * application and operating system. Run benchmarks to
         * determine the optimal strategy on a case-by-case basis. Generally speaking,
         * however, sending multiple buffers is faster.
         *
         * Example of sending a UDP packet using a socket connected to a port on `localhost`:
         *
         * ```js
         * import dgram from 'node:dgram';
         * import { Buffer } from 'node:buffer';
         *
         * const message = Buffer.from('Some bytes');
         * const client = dgram.createSocket('udp4');
         * client.connect(41234, 'localhost', (err) => {
         *   client.send(message, (err) => {
         *     client.close();
         *   });
         * });
         * ```
         * @since v0.1.99
         * @param msg Message to be sent.
         * @param offset Offset in the buffer where the message starts.
         * @param length Number of bytes in the message.
         * @param port Destination port.
         * @param address Destination host name or IP address.
         * @param callback Called when the message has been sent.
         */
        send(
            msg: string | Uint8Array | readonly any[],
            port?: number,
            address?: string,
            callback?: (error: Error | null, bytes: number) => void,
        ): void;
        send(
            msg: string | Uint8Array | readonly any[],
            port?: number,
            callback?: (error: Error | null, bytes: number) => void,
        ): void;
        send(
            msg: string | Uint8Array | readonly any[],
            callback?: (error: Error | null, bytes: number) => void,
        ): void;
        send(
            msg: string | Uint8Array,
            offset: number,
            length: number,
            port?: number,
            address?: string,
            callback?: (error: Error | null, bytes: number) => void,
        ): void;
        send(
            msg: string | Uint8Array,
            offset: number,
            length: number,
            port?: number,
            callback?: (error: Error | null, bytes: number) => void,
        ): void;
        send(
            msg: string | Uint8Array,
            offset: number,
            length: number,
            callback?: (error: Error | null, bytes: number) => void,
        ): void;
        /**
         * Sets or clears the `SO_BROADCAST` socket option. When set to `true`, UDP
         * packets may be sent to a local interface's broadcast address.
         *
         * This method throws `EBADF` if called on an unbound socket.
         * @since v0.6.9
         */
        setBroadcast(flag: boolean): void;
        /**
         * _All references to scope in this section are referring to [IPv6 Zone Indices](https://en.wikipedia.org/wiki/IPv6_address#Scoped_literal_IPv6_addresses), which are defined by [RFC
         * 4007](https://tools.ietf.org/html/rfc4007). In string form, an IP_
         * _with a scope index is written as `'IP%scope'` where scope is an interface name_
         * _or interface number._
         *
         * Sets the default outgoing multicast interface of the socket to a chosen
         * interface or back to system interface selection. The `multicastInterface` must
         * be a valid string representation of an IP from the socket's family.
         *
         * For IPv4 sockets, this should be the IP configured for the desired physical
         * interface. All packets sent to multicast on the socket will be sent on the
         * interface determined by the most recent successful use of this call.
         *
         * For IPv6 sockets, `multicastInterface` should include a scope to indicate the
         * interface as in the examples that follow. In IPv6, individual `send` calls can
         * also use explicit scope in addresses, so only packets sent to a multicast
         * address without specifying an explicit scope are affected by the most recent
         * successful use of this call.
         *
         * This method throws `EBADF` if called on an unbound socket.
         *
         * #### Example: IPv6 outgoing multicast interface
         *
         * On most systems, where scope format uses the interface name:
         *
         * ```js
         * const socket = dgram.createSocket('udp6');
         *
         * socket.bind(1234, () => {
         *   socket.setMulticastInterface('::%eth1');
         * });
         * ```
         *
         * On Windows, where scope format uses an interface number:
         *
         * ```js
         * const socket = dgram.createSocket('udp6');
         *
         * socket.bind(1234, () => {
         *   socket.setMulticastInterface('::%2');
         * });
         * ```
         *
         * #### Example: IPv4 outgoing multicast interface
         *
         * All systems use an IP of the host on the desired physical interface:
         *
         * ```js
         * const socket = dgram.createSocket('udp4');
         *
         * socket.bind(1234, () => {
         *   socket.setMulticastInterface('10.0.0.2');
         * });
         * ```
         * @since v8.6.0
         */
        setMulticastInterface(multicastInterface: string): void;
        /**
         * Sets or clears the `IP_MULTICAST_LOOP` socket option. When set to `true`,
         * multicast packets will also be received on the local interface.
         *
         * This method throws `EBADF` if called on an unbound socket.
         * @since v0.3.8
         */
        setMulticastLoopback(flag: boolean): boolean;
        /**
         * Sets the `IP_MULTICAST_TTL` socket option. While TTL generally stands for
         * "Time to Live", in this context it specifies the number of IP hops that a
         * packet is allowed to travel through, specifically for multicast traffic. Each
         * router or gateway that forwards a packet decrements the TTL. If the TTL is
         * decremented to 0 by a router, it will not be forwarded.
         *
         * The `ttl` argument may be between 0 and 255\. The default on most systems is `1`.
         *
         * This method throws `EBADF` if called on an unbound socket.
         * @since v0.3.8
         */
        setMulticastTTL(ttl: number): number;
        /**
         * Sets the `SO_RCVBUF` socket option. Sets the maximum socket receive buffer
         * in bytes.
         *
         * This method throws `ERR_SOCKET_BUFFER_SIZE` if called on an unbound socket.
         * @since v8.7.0
         */
        setRecvBufferSize(size: number): void;
        /**
         * Sets the `SO_SNDBUF` socket option. Sets the maximum socket send buffer
         * in bytes.
         *
         * This method throws `ERR_SOCKET_BUFFER_SIZE` if called on an unbound socket.
         * @since v8.7.0
         */
        setSendBufferSize(size: number): void;
        /**
         * Sets the `IP_TTL` socket option. While TTL generally stands for "Time to Live",
         * in this context it specifies the number of IP hops that a packet is allowed to
         * travel through. Each router or gateway that forwards a packet decrements the
         * TTL. If the TTL is decremented to 0 by a router, it will not be forwarded.
         * Changing TTL values is typically done for network probes or when multicasting.
         *
         * The `ttl` argument may be between 1 and 255\. The default on most systems
         * is 64.
         *
         * This method throws `EBADF` if called on an unbound socket.
         * @since v0.1.101
         */
        setTTL(ttl: number): number;
        /**
         * By default, binding a socket will cause it to block the Node.js process from
         * exiting as long as the socket is open. The `socket.unref()` method can be used
         * to exclude the socket from the reference counting that keeps the Node.js
         * process active, allowing the process to exit even if the socket is still
         * listening.
         *
         * Calling `socket.unref()` multiple times will have no additional effect.
         *
         * The `socket.unref()` method returns a reference to the socket so calls can be
         * chained.
         * @since v0.9.1
         */
        unref(): this;
        /**
         * Tells the kernel to join a source-specific multicast channel at the given `sourceAddress` and `groupAddress`, using the `multicastInterface` with the `IP_ADD_SOURCE_MEMBERSHIP` socket
         * option. If the `multicastInterface` argument
         * is not specified, the operating system will choose one interface and will add
         * membership to it. To add membership to every available interface, call `socket.addSourceSpecificMembership()` multiple times, once per interface.
         *
         * When called on an unbound socket, this method will implicitly bind to a random
         * port, listening on all interfaces.
         * @since v13.1.0, v12.16.0
         */
        addSourceSpecificMembership(sourceAddress: string, groupAddress: string, multicastInterface?: string): void;
        /**
         * Instructs the kernel to leave a source-specific multicast channel at the given `sourceAddress` and `groupAddress` using the `IP_DROP_SOURCE_MEMBERSHIP` socket option. This method is
         * automatically called by the kernel when the
         * socket is closed or the process terminates, so most apps will never have
         * reason to call this.
         *
         * If `multicastInterface` is not specified, the operating system will attempt to
         * drop membership on all valid interfaces.
         * @since v13.1.0, v12.16.0
         */
        dropSourceSpecificMembership(sourceAddress: string, groupAddress: string, multicastInterface?: string): void;
        /**
         * events.EventEmitter
         * 1. close
         * 2. connect
         * 3. error
         * 4. listening
         * 5. message
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "connect", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "listening", listener: () => void): this;
        addListener(event: "message", listener: (msg: Buffer, rinfo: RemoteInfo) => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "close"): boolean;
        emit(event: "connect"): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "listening"): boolean;
        emit(event: "message", msg: Buffer, rinfo: RemoteInfo): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "connect", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "listening", listener: () => void): this;
        on(event: "message", listener: (msg: Buffer, rinfo: RemoteInfo) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "connect", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "listening", listener: () => void): this;
        once(event: "message", listener: (msg: Buffer, rinfo: RemoteInfo) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "connect", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "listening", listener: () => void): this;
        prependListener(event: "message", listener: (msg: Buffer, rinfo: RemoteInfo) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "connect", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: "listening", listener: () => void): this;
        prependOnceListener(event: "message", listener: (msg: Buffer, rinfo: RemoteInfo) => void): this;
        /**
         * Calls `socket.close()` and returns a promise that fulfills when the socket has closed.
         * @since v20.5.0
         */
        [Symbol.asyncDispose](): Promise<void>;
    }
}
declare module "node:dgram" {
    export * from "dgram";
}
/**
 * The `node:diagnostics_channel` module provides an API to create named channels
 * to report arbitrary message data for diagnostics purposes.
 *
 * It can be accessed using:
 *
 * ```js
 * import diagnostics_channel from 'node:diagnostics_channel';
 * ```
 *
 * It is intended that a module writer wanting to report diagnostics messages
 * will create one or many top-level channels to report messages through.
 * Channels may also be acquired at runtime but it is not encouraged
 * due to the additional overhead of doing so. Channels may be exported for
 * convenience, but as long as the name is known it can be acquired anywhere.
 *
 * If you intend for your module to produce diagnostics data for others to
 * consume it is recommended that you include documentation of what named
 * channels are used along with the shape of the message data. Channel names
 * should generally include the module name to avoid collisions with data from
 * other modules.
 * @since v15.1.0, v14.17.0
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/diagnostics_channel.js)
 */
declare module "diagnostics_channel" {
    import { AsyncLocalStorage } from "node:async_hooks";
    /**
     * Check if there are active subscribers to the named channel. This is helpful if
     * the message you want to send might be expensive to prepare.
     *
     * This API is optional but helpful when trying to publish messages from very
     * performance-sensitive code.
     *
     * ```js
     * import diagnostics_channel from 'node:diagnostics_channel';
     *
     * if (diagnostics_channel.hasSubscribers('my-channel')) {
     *   // There are subscribers, prepare and publish message
     * }
     * ```
     * @since v15.1.0, v14.17.0
     * @param name The channel name
     * @return If there are active subscribers
     */
    function hasSubscribers(name: string | symbol): boolean;
    /**
     * This is the primary entry-point for anyone wanting to publish to a named
     * channel. It produces a channel object which is optimized to reduce overhead at
     * publish time as much as possible.
     *
     * ```js
     * import diagnostics_channel from 'node:diagnostics_channel';
     *
     * const channel = diagnostics_channel.channel('my-channel');
     * ```
     * @since v15.1.0, v14.17.0
     * @param name The channel name
     * @return The named channel object
     */
    function channel(name: string | symbol): Channel;
    type ChannelListener = (message: unknown, name: string | symbol) => void;
    /**
     * Register a message handler to subscribe to this channel. This message handler
     * will be run synchronously whenever a message is published to the channel. Any
     * errors thrown in the message handler will trigger an `'uncaughtException'`.
     *
     * ```js
     * import diagnostics_channel from 'node:diagnostics_channel';
     *
     * diagnostics_channel.subscribe('my-channel', (message, name) => {
     *   // Received data
     * });
     * ```
     * @since v18.7.0, v16.17.0
     * @param name The channel name
     * @param onMessage The handler to receive channel messages
     */
    function subscribe(name: string | symbol, onMessage: ChannelListener): void;
    /**
     * Remove a message handler previously registered to this channel with {@link subscribe}.
     *
     * ```js
     * import diagnostics_channel from 'node:diagnostics_channel';
     *
     * function onMessage(message, name) {
     *   // Received data
     * }
     *
     * diagnostics_channel.subscribe('my-channel', onMessage);
     *
     * diagnostics_channel.unsubscribe('my-channel', onMessage);
     * ```
     * @since v18.7.0, v16.17.0
     * @param name The channel name
     * @param onMessage The previous subscribed handler to remove
     * @return `true` if the handler was found, `false` otherwise.
     */
    function unsubscribe(name: string | symbol, onMessage: ChannelListener): boolean;
    /**
     * Creates a `TracingChannel` wrapper for the given `TracingChannel Channels`. If a name is given, the corresponding tracing
     * channels will be created in the form of `tracing:${name}:${eventType}` where `eventType` corresponds to the types of `TracingChannel Channels`.
     *
     * ```js
     * import diagnostics_channel from 'node:diagnostics_channel';
     *
     * const channelsByName = diagnostics_channel.tracingChannel('my-channel');
     *
     * // or...
     *
     * const channelsByCollection = diagnostics_channel.tracingChannel({
     *   start: diagnostics_channel.channel('tracing:my-channel:start'),
     *   end: diagnostics_channel.channel('tracing:my-channel:end'),
     *   asyncStart: diagnostics_channel.channel('tracing:my-channel:asyncStart'),
     *   asyncEnd: diagnostics_channel.channel('tracing:my-channel:asyncEnd'),
     *   error: diagnostics_channel.channel('tracing:my-channel:error'),
     * });
     * ```
     * @since v19.9.0
     * @experimental
     * @param nameOrChannels Channel name or object containing all the `TracingChannel Channels`
     * @return Collection of channels to trace with
     */
    function tracingChannel<
        StoreType = unknown,
        ContextType extends object = StoreType extends object ? StoreType : object,
    >(
        nameOrChannels: string | TracingChannelCollection<StoreType, ContextType>,
    ): TracingChannel<StoreType, ContextType>;
    /**
     * The class `Channel` represents an individual named channel within the data
     * pipeline. It is used to track subscribers and to publish messages when there
     * are subscribers present. It exists as a separate object to avoid channel
     * lookups at publish time, enabling very fast publish speeds and allowing
     * for heavy use while incurring very minimal cost. Channels are created with {@link channel}, constructing a channel directly
     * with `new Channel(name)` is not supported.
     * @since v15.1.0, v14.17.0
     */
    class Channel<StoreType = unknown, ContextType = StoreType> {
        readonly name: string | symbol;
        /**
         * Check if there are active subscribers to this channel. This is helpful if
         * the message you want to send might be expensive to prepare.
         *
         * This API is optional but helpful when trying to publish messages from very
         * performance-sensitive code.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * if (channel.hasSubscribers) {
         *   // There are subscribers, prepare and publish message
         * }
         * ```
         * @since v15.1.0, v14.17.0
         */
        readonly hasSubscribers: boolean;
        private constructor(name: string | symbol);
        /**
         * Publish a message to any subscribers to the channel. This will trigger
         * message handlers synchronously so they will execute within the same context.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * channel.publish({
         *   some: 'message',
         * });
         * ```
         * @since v15.1.0, v14.17.0
         * @param message The message to send to the channel subscribers
         */
        publish(message: unknown): void;
        /**
         * Register a message handler to subscribe to this channel. This message handler
         * will be run synchronously whenever a message is published to the channel. Any
         * errors thrown in the message handler will trigger an `'uncaughtException'`.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * channel.subscribe((message, name) => {
         *   // Received data
         * });
         * ```
         * @since v15.1.0, v14.17.0
         * @deprecated Since v18.7.0,v16.17.0 - Use {@link subscribe(name, onMessage)}
         * @param onMessage The handler to receive channel messages
         */
        subscribe(onMessage: ChannelListener): void;
        /**
         * Remove a message handler previously registered to this channel with `channel.subscribe(onMessage)`.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * function onMessage(message, name) {
         *   // Received data
         * }
         *
         * channel.subscribe(onMessage);
         *
         * channel.unsubscribe(onMessage);
         * ```
         * @since v15.1.0, v14.17.0
         * @deprecated Since v18.7.0,v16.17.0 - Use {@link unsubscribe(name, onMessage)}
         * @param onMessage The previous subscribed handler to remove
         * @return `true` if the handler was found, `false` otherwise.
         */
        unsubscribe(onMessage: ChannelListener): void;
        /**
         * When `channel.runStores(context, ...)` is called, the given context data
         * will be applied to any store bound to the channel. If the store has already been
         * bound the previous `transform` function will be replaced with the new one.
         * The `transform` function may be omitted to set the given context data as the
         * context directly.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         * import { AsyncLocalStorage } from 'node:async_hooks';
         *
         * const store = new AsyncLocalStorage();
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * channel.bindStore(store, (data) => {
         *   return { data };
         * });
         * ```
         * @since v19.9.0
         * @experimental
         * @param store The store to which to bind the context data
         * @param transform Transform context data before setting the store context
         */
        bindStore(store: AsyncLocalStorage<StoreType>, transform?: (context: ContextType) => StoreType): void;
        /**
         * Remove a message handler previously registered to this channel with `channel.bindStore(store)`.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         * import { AsyncLocalStorage } from 'node:async_hooks';
         *
         * const store = new AsyncLocalStorage();
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * channel.bindStore(store);
         * channel.unbindStore(store);
         * ```
         * @since v19.9.0
         * @experimental
         * @param store The store to unbind from the channel.
         * @return `true` if the store was found, `false` otherwise.
         */
        unbindStore(store: any): void;
        /**
         * Applies the given data to any AsyncLocalStorage instances bound to the channel
         * for the duration of the given function, then publishes to the channel within
         * the scope of that data is applied to the stores.
         *
         * If a transform function was given to `channel.bindStore(store)` it will be
         * applied to transform the message data before it becomes the context value for
         * the store. The prior storage context is accessible from within the transform
         * function in cases where context linking is required.
         *
         * The context applied to the store should be accessible in any async code which
         * continues from execution which began during the given function, however
         * there are some situations in which `context loss` may occur.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         * import { AsyncLocalStorage } from 'node:async_hooks';
         *
         * const store = new AsyncLocalStorage();
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * channel.bindStore(store, (message) => {
         *   const parent = store.getStore();
         *   return new Span(message, parent);
         * });
         * channel.runStores({ some: 'message' }, () => {
         *   store.getStore(); // Span({ some: 'message' })
         * });
         * ```
         * @since v19.9.0
         * @experimental
         * @param context Message to send to subscribers and bind to stores
         * @param fn Handler to run within the entered storage context
         * @param thisArg The receiver to be used for the function call.
         * @param args Optional arguments to pass to the function.
         */
        runStores(): void;
    }
    interface TracingChannelSubscribers<ContextType extends object> {
        start: (message: ContextType) => void;
        end: (
            message: ContextType & {
                error?: unknown;
                result?: unknown;
            },
        ) => void;
        asyncStart: (
            message: ContextType & {
                error?: unknown;
                result?: unknown;
            },
        ) => void;
        asyncEnd: (
            message: ContextType & {
                error?: unknown;
                result?: unknown;
            },
        ) => void;
        error: (
            message: ContextType & {
                error: unknown;
            },
        ) => void;
    }
    interface TracingChannelCollection<StoreType = unknown, ContextType = StoreType> {
        start: Channel<StoreType, ContextType>;
        end: Channel<StoreType, ContextType>;
        asyncStart: Channel<StoreType, ContextType>;
        asyncEnd: Channel<StoreType, ContextType>;
        error: Channel<StoreType, ContextType>;
    }
    /**
     * The class `TracingChannel` is a collection of `TracingChannel Channels` which
     * together express a single traceable action. It is used to formalize and
     * simplify the process of producing events for tracing application flow. {@link tracingChannel} is used to construct a `TracingChannel`. As with `Channel` it is recommended to create and reuse a
     * single `TracingChannel` at the top-level of the file rather than creating them
     * dynamically.
     * @since v19.9.0
     * @experimental
     */
    class TracingChannel<StoreType = unknown, ContextType extends object = {}> implements TracingChannelCollection {
        start: Channel<StoreType, ContextType>;
        end: Channel<StoreType, ContextType>;
        asyncStart: Channel<StoreType, ContextType>;
        asyncEnd: Channel<StoreType, ContextType>;
        error: Channel<StoreType, ContextType>;
        /**
         * Helper to subscribe a collection of functions to the corresponding channels.
         * This is the same as calling `channel.subscribe(onMessage)` on each channel
         * individually.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channels = diagnostics_channel.tracingChannel('my-channel');
         *
         * channels.subscribe({
         *   start(message) {
         *     // Handle start message
         *   },
         *   end(message) {
         *     // Handle end message
         *   },
         *   asyncStart(message) {
         *     // Handle asyncStart message
         *   },
         *   asyncEnd(message) {
         *     // Handle asyncEnd message
         *   },
         *   error(message) {
         *     // Handle error message
         *   },
         * });
         * ```
         * @since v19.9.0
         * @experimental
         * @param subscribers Set of `TracingChannel Channels` subscribers
         */
        subscribe(subscribers: TracingChannelSubscribers<ContextType>): void;
        /**
         * Helper to unsubscribe a collection of functions from the corresponding channels.
         * This is the same as calling `channel.unsubscribe(onMessage)` on each channel
         * individually.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channels = diagnostics_channel.tracingChannel('my-channel');
         *
         * channels.unsubscribe({
         *   start(message) {
         *     // Handle start message
         *   },
         *   end(message) {
         *     // Handle end message
         *   },
         *   asyncStart(message) {
         *     // Handle asyncStart message
         *   },
         *   asyncEnd(message) {
         *     // Handle asyncEnd message
         *   },
         *   error(message) {
         *     // Handle error message
         *   },
         * });
         * ```
         * @since v19.9.0
         * @experimental
         * @param subscribers Set of `TracingChannel Channels` subscribers
         * @return `true` if all handlers were successfully unsubscribed, and `false` otherwise.
         */
        unsubscribe(subscribers: TracingChannelSubscribers<ContextType>): void;
        /**
         * Trace a synchronous function call. This will always produce a `start event` and `end event` around the execution and may produce an `error event` if the given function throws an error.
         * This will run the given function using `channel.runStores(context, ...)` on the `start` channel which ensures all
         * events should have any bound stores set to match this trace context.
         *
         * To ensure only correct trace graphs are formed, events will only be published if subscribers are present prior to starting the trace. Subscriptions
         * which are added after the trace begins will not receive future events from that trace, only future traces will be seen.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channels = diagnostics_channel.tracingChannel('my-channel');
         *
         * channels.traceSync(() => {
         *   // Do something
         * }, {
         *   some: 'thing',
         * });
         * ```
         * @since v19.9.0
         * @experimental
         * @param fn Function to wrap a trace around
         * @param context Shared object to correlate events through
         * @param thisArg The receiver to be used for the function call
         * @param args Optional arguments to pass to the function
         * @return The return value of the given function
         */
        traceSync<ThisArg = any, Args extends any[] = any[]>(
            fn: (this: ThisArg, ...args: Args) => any,
            context?: ContextType,
            thisArg?: ThisArg,
            ...args: Args
        ): void;
        /**
         * Trace a promise-returning function call. This will always produce a `start event` and `end event` around the synchronous portion of the
         * function execution, and will produce an `asyncStart event` and `asyncEnd event` when a promise continuation is reached. It may also
         * produce an `error event` if the given function throws an error or the
         * returned promise rejects. This will run the given function using `channel.runStores(context, ...)` on the `start` channel which ensures all
         * events should have any bound stores set to match this trace context.
         *
         * To ensure only correct trace graphs are formed, events will only be published if subscribers are present prior to starting the trace. Subscriptions
         * which are added after the trace begins will not receive future events from that trace, only future traces will be seen.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channels = diagnostics_channel.tracingChannel('my-channel');
         *
         * channels.tracePromise(async () => {
         *   // Do something
         * }, {
         *   some: 'thing',
         * });
         * ```
         * @since v19.9.0
         * @experimental
         * @param fn Promise-returning function to wrap a trace around
         * @param context Shared object to correlate trace events through
         * @param thisArg The receiver to be used for the function call
         * @param args Optional arguments to pass to the function
         * @return Chained from promise returned by the given function
         */
        tracePromise<ThisArg = any, Args extends any[] = any[]>(
            fn: (this: ThisArg, ...args: Args) => Promise<any>,
            context?: ContextType,
            thisArg?: ThisArg,
            ...args: Args
        ): void;
        /**
         * Trace a callback-receiving function call. This will always produce a `start event` and `end event` around the synchronous portion of the
         * function execution, and will produce a `asyncStart event` and `asyncEnd event` around the callback execution. It may also produce an `error event` if the given function throws an error or
         * the returned
         * promise rejects. This will run the given function using `channel.runStores(context, ...)` on the `start` channel which ensures all
         * events should have any bound stores set to match this trace context.
         *
         * The `position` will be -1 by default to indicate the final argument should
         * be used as the callback.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channels = diagnostics_channel.tracingChannel('my-channel');
         *
         * channels.traceCallback((arg1, callback) => {
         *   // Do something
         *   callback(null, 'result');
         * }, 1, {
         *   some: 'thing',
         * }, thisArg, arg1, callback);
         * ```
         *
         * The callback will also be run with `channel.runStores(context, ...)` which
         * enables context loss recovery in some cases.
         *
         * To ensure only correct trace graphs are formed, events will only be published if subscribers are present prior to starting the trace. Subscriptions
         * which are added after the trace begins will not receive future events from that trace, only future traces will be seen.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         * import { AsyncLocalStorage } from 'node:async_hooks';
         *
         * const channels = diagnostics_channel.tracingChannel('my-channel');
         * const myStore = new AsyncLocalStorage();
         *
         * // The start channel sets the initial store data to something
         * // and stores that store data value on the trace context object
         * channels.start.bindStore(myStore, (data) => {
         *   const span = new Span(data);
         *   data.span = span;
         *   return span;
         * });
         *
         * // Then asyncStart can restore from that data it stored previously
         * channels.asyncStart.bindStore(myStore, (data) => {
         *   return data.span;
         * });
         * ```
         * @since v19.9.0
         * @experimental
         * @param fn callback using function to wrap a trace around
         * @param position Zero-indexed argument position of expected callback
         * @param context Shared object to correlate trace events through
         * @param thisArg The receiver to be used for the function call
         * @param args Optional arguments to pass to the function
         * @return The return value of the given function
         */
        traceCallback<Fn extends (this: any, ...args: any) => any>(
            fn: Fn,
            position: number | undefined,
            context: ContextType | undefined,
            thisArg: any,
            ...args: Parameters<Fn>
        ): void;
    }
}
declare module "node:diagnostics_channel" {
    export * from "diagnostics_channel";
}
/**
 * The `node:dns` module enables name resolution. For example, use it to look up IP
 * addresses of host names.
 *
 * Although named for the [Domain Name System (DNS)](https://en.wikipedia.org/wiki/Domain_Name_System), it does not always use the
 * DNS protocol for lookups. {@link lookup} uses the operating system
 * facilities to perform name resolution. It may not need to perform any network
 * communication. To perform name resolution the way other applications on the same
 * system do, use {@link lookup}.
 *
 * ```js
 * const dns = require('node:dns');
 *
 * dns.lookup('example.org', (err, address, family) => {
 *   console.log('address: %j family: IPv%s', address, family);
 * });
 * // address: "93.184.216.34" family: IPv4
 * ```
 *
 * All other functions in the `node:dns` module connect to an actual DNS server to
 * perform name resolution. They will always use the network to perform DNS
 * queries. These functions do not use the same set of configuration files used by {@link lookup} (e.g. `/etc/hosts`). Use these functions to always perform
 * DNS queries, bypassing other name-resolution facilities.
 *
 * ```js
 * const dns = require('node:dns');
 *
 * dns.resolve4('archive.org', (err, addresses) => {
 *   if (err) throw err;
 *
 *   console.log(`addresses: ${JSON.stringify(addresses)}`);
 *
 *   addresses.forEach((a) => {
 *     dns.reverse(a, (err, hostnames) => {
 *       if (err) {
 *         throw err;
 *       }
 *       console.log(`reverse for ${a}: ${JSON.stringify(hostnames)}`);
 *     });
 *   });
 * });
 * ```
 *
 * See the [Implementation considerations section](https://nodejs.org/docs/latest-v22.x/api/dns.html#implementation-considerations) for more information.
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/dns.js)
 */
declare module "dns" {
    import * as dnsPromises from "node:dns/promises";
    // Supported getaddrinfo flags.
    /**
     * Limits returned address types to the types of non-loopback addresses configured on the system. For example, IPv4 addresses are
     * only returned if the current system has at least one IPv4 address configured.
     */
    export const ADDRCONFIG: number;
    /**
     * If the IPv6 family was specified, but no IPv6 addresses were found, then return IPv4 mapped IPv6 addresses. It is not supported
     * on some operating systems (e.g. FreeBSD 10.1).
     */
    export const V4MAPPED: number;
    /**
     * If `dns.V4MAPPED` is specified, return resolved IPv6 addresses as
     * well as IPv4 mapped IPv6 addresses.
     */
    export const ALL: number;
    export interface LookupOptions {
        /**
         * The record family. Must be `4`, `6`, or `0`. For backward compatibility reasons, `'IPv4'` and `'IPv6'` are interpreted
         * as `4` and `6` respectively. The value 0 indicates that either an IPv4 or IPv6 address is returned. If the value `0` is used
         * with `{ all: true } (see below)`, both IPv4 and IPv6 addresses are returned.
         * @default 0
         */
        family?: number | "IPv4" | "IPv6" | undefined;
        /**
         * One or more [supported `getaddrinfo`](https://nodejs.org/docs/latest-v22.x/api/dns.html#supported-getaddrinfo-flags) flags. Multiple flags may be
         * passed by bitwise `OR`ing their values.
         */
        hints?: number | undefined;
        /**
         * When `true`, the callback returns all resolved addresses in an array. Otherwise, returns a single address.
         * @default false
         */
        all?: boolean | undefined;
        /**
         * When `verbatim`, the resolved addresses are return unsorted. When `ipv4first`, the resolved addresses are sorted
         * by placing IPv4 addresses before IPv6 addresses. When `ipv6first`, the resolved addresses are sorted by placing IPv6
         * addresses before IPv4 addresses. Default value is configurable using
         * {@link setDefaultResultOrder} or [`--dns-result-order`](https://nodejs.org/docs/latest-v22.x/api/cli.html#--dns-result-orderorder).
         * @default `verbatim` (addresses are not reordered)
         * @since v22.1.0
         */
        order?: "ipv4first" | "ipv6first" | "verbatim" | undefined;
        /**
         * When `true`, the callback receives IPv4 and IPv6 addresses in the order the DNS resolver returned them. When `false`, IPv4
         * addresses are placed before IPv6 addresses. This option will be deprecated in favor of `order`. When both are specified,
         * `order` has higher precedence. New code should only use `order`. Default value is configurable using {@link setDefaultResultOrder}
         * @default true (addresses are not reordered)
         * @deprecated Please use `order` option
         */
        verbatim?: boolean | undefined;
    }
    export interface LookupOneOptions extends LookupOptions {
        all?: false | undefined;
    }
    export interface LookupAllOptions extends LookupOptions {
        all: true;
    }
    export interface LookupAddress {
        /**
         * A string representation of an IPv4 or IPv6 address.
         */
        address: string;
        /**
         * `4` or `6`, denoting the family of `address`, or `0` if the address is not an IPv4 or IPv6 address. `0` is a likely indicator of a
         * bug in the name resolution service used by the operating system.
         */
        family: number;
    }
    /**
     * Resolves a host name (e.g. `'nodejs.org'`) into the first found A (IPv4) or
     * AAAA (IPv6) record. All `option` properties are optional. If `options` is an
     * integer, then it must be `4` or `6` – if `options` is `0` or not provided, then
     * IPv4 and IPv6 addresses are both returned if found.
     *
     * With the `all` option set to `true`, the arguments for `callback` change to `(err, addresses)`, with `addresses` being an array of objects with the
     * properties `address` and `family`.
     *
     * On error, `err` is an `Error` object, where `err.code` is the error code.
     * Keep in mind that `err.code` will be set to `'ENOTFOUND'` not only when
     * the host name does not exist but also when the lookup fails in other ways
     * such as no available file descriptors.
     *
     * `dns.lookup()` does not necessarily have anything to do with the DNS protocol.
     * The implementation uses an operating system facility that can associate names
     * with addresses and vice versa. This implementation can have subtle but
     * important consequences on the behavior of any Node.js program. Please take some
     * time to consult the [Implementation considerations section](https://nodejs.org/docs/latest-v22.x/api/dns.html#implementation-considerations)
     * before using `dns.lookup()`.
     *
     * Example usage:
     *
     * ```js
     * const dns = require('node:dns');
     * const options = {
     *   family: 6,
     *   hints: dns.ADDRCONFIG | dns.V4MAPPED,
     * };
     * dns.lookup('example.com', options, (err, address, family) =>
     *   console.log('address: %j family: IPv%s', address, family));
     * // address: "2606:2800:220:1:248:1893:25c8:1946" family: IPv6
     *
     * // When options.all is true, the result will be an Array.
     * options.all = true;
     * dns.lookup('example.com', options, (err, addresses) =>
     *   console.log('addresses: %j', addresses));
     * // addresses: [{"address":"2606:2800:220:1:248:1893:25c8:1946","family":6}]
     * ```
     *
     * If this method is invoked as its [util.promisify()](https://nodejs.org/docs/latest-v22.x/api/util.html#utilpromisifyoriginal) ed
     * version, and `all` is not set to `true`, it returns a `Promise` for an `Object` with `address` and `family` properties.
     * @since v0.1.90
     */
    export function lookup(
        hostname: string,
        family: number,
        callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void,
    ): void;
    export function lookup(
        hostname: string,
        options: LookupOneOptions,
        callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void,
    ): void;
    export function lookup(
        hostname: string,
        options: LookupAllOptions,
        callback: (err: NodeJS.ErrnoException | null, addresses: LookupAddress[]) => void,
    ): void;
    export function lookup(
        hostname: string,
        options: LookupOptions,
        callback: (err: NodeJS.ErrnoException | null, address: string | LookupAddress[], family: number) => void,
    ): void;
    export function lookup(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void,
    ): void;
    export namespace lookup {
        function __promisify__(hostname: string, options: LookupAllOptions): Promise<LookupAddress[]>;
        function __promisify__(hostname: string, options?: LookupOneOptions | number): Promise<LookupAddress>;
        function __promisify__(hostname: string, options: LookupOptions): Promise<LookupAddress | LookupAddress[]>;
    }
    /**
     * Resolves the given `address` and `port` into a host name and service using
     * the operating system's underlying `getnameinfo` implementation.
     *
     * If `address` is not a valid IP address, a `TypeError` will be thrown.
     * The `port` will be coerced to a number. If it is not a legal port, a `TypeError` will be thrown.
     *
     * On an error, `err` is an [`Error`](https://nodejs.org/docs/latest-v22.x/api/errors.html#class-error) object,
     * where `err.code` is the error code.
     *
     * ```js
     * const dns = require('node:dns');
     * dns.lookupService('127.0.0.1', 22, (err, hostname, service) => {
     *   console.log(hostname, service);
     *   // Prints: localhost ssh
     * });
     * ```
     *
     * If this method is invoked as its [util.promisify()](https://nodejs.org/docs/latest-v22.x/api/util.html#utilpromisifyoriginal) ed
     * version, it returns a `Promise` for an `Object` with `hostname` and `service` properties.
     * @since v0.11.14
     */
    export function lookupService(
        address: string,
        port: number,
        callback: (err: NodeJS.ErrnoException | null, hostname: string, service: string) => void,
    ): void;
    export namespace lookupService {
        function __promisify__(
            address: string,
            port: number,
        ): Promise<{
            hostname: string;
            service: string;
        }>;
    }
    export interface ResolveOptions {
        ttl: boolean;
    }
    export interface ResolveWithTtlOptions extends ResolveOptions {
        ttl: true;
    }
    export interface RecordWithTtl {
        address: string;
        ttl: number;
    }
    /** @deprecated Use `AnyARecord` or `AnyAaaaRecord` instead. */
    export type AnyRecordWithTtl = AnyARecord | AnyAaaaRecord;
    export interface AnyARecord extends RecordWithTtl {
        type: "A";
    }
    export interface AnyAaaaRecord extends RecordWithTtl {
        type: "AAAA";
    }
    export interface CaaRecord {
        critical: number;
        issue?: string | undefined;
        issuewild?: string | undefined;
        iodef?: string | undefined;
        contactemail?: string | undefined;
        contactphone?: string | undefined;
    }
    export interface MxRecord {
        priority: number;
        exchange: string;
    }
    export interface AnyMxRecord extends MxRecord {
        type: "MX";
    }
    export interface NaptrRecord {
        flags: string;
        service: string;
        regexp: string;
        replacement: string;
        order: number;
        preference: number;
    }
    export interface AnyNaptrRecord extends NaptrRecord {
        type: "NAPTR";
    }
    export interface SoaRecord {
        nsname: string;
        hostmaster: string;
        serial: number;
        refresh: number;
        retry: number;
        expire: number;
        minttl: number;
    }
    export interface AnySoaRecord extends SoaRecord {
        type: "SOA";
    }
    export interface SrvRecord {
        priority: number;
        weight: number;
        port: number;
        name: string;
    }
    export interface AnySrvRecord extends SrvRecord {
        type: "SRV";
    }
    export interface AnyTxtRecord {
        type: "TXT";
        entries: string[];
    }
    export interface AnyNsRecord {
        type: "NS";
        value: string;
    }
    export interface AnyPtrRecord {
        type: "PTR";
        value: string;
    }
    export interface AnyCnameRecord {
        type: "CNAME";
        value: string;
    }
    export type AnyRecord =
        | AnyARecord
        | AnyAaaaRecord
        | AnyCnameRecord
        | AnyMxRecord
        | AnyNaptrRecord
        | AnyNsRecord
        | AnyPtrRecord
        | AnySoaRecord
        | AnySrvRecord
        | AnyTxtRecord;
    /**
     * Uses the DNS protocol to resolve a host name (e.g. `'nodejs.org'`) into an array
     * of the resource records. The `callback` function has arguments `(err, records)`. When successful, `records` will be an array of resource
     * records. The type and structure of individual results varies based on `rrtype`:
     *
     * <omitted>
     *
     * On error, `err` is an [`Error`](https://nodejs.org/docs/latest-v22.x/api/errors.html#class-error) object,
     * where `err.code` is one of the `DNS error codes`.
     * @since v0.1.27
     * @param hostname Host name to resolve.
     * @param [rrtype='A'] Resource record type.
     */
    export function resolve(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: "A",
        callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: "AAAA",
        callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: "ANY",
        callback: (err: NodeJS.ErrnoException | null, addresses: AnyRecord[]) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: "CNAME",
        callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: "MX",
        callback: (err: NodeJS.ErrnoException | null, addresses: MxRecord[]) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: "NAPTR",
        callback: (err: NodeJS.ErrnoException | null, addresses: NaptrRecord[]) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: "NS",
        callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: "PTR",
        callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: "SOA",
        callback: (err: NodeJS.ErrnoException | null, addresses: SoaRecord) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: "SRV",
        callback: (err: NodeJS.ErrnoException | null, addresses: SrvRecord[]) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: "TXT",
        callback: (err: NodeJS.ErrnoException | null, addresses: string[][]) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: string,
        callback: (
            err: NodeJS.ErrnoException | null,
            addresses: string[] | MxRecord[] | NaptrRecord[] | SoaRecord | SrvRecord[] | string[][] | AnyRecord[],
        ) => void,
    ): void;
    export namespace resolve {
        function __promisify__(hostname: string, rrtype?: "A" | "AAAA" | "CNAME" | "NS" | "PTR"): Promise<string[]>;
        function __promisify__(hostname: string, rrtype: "ANY"): Promise<AnyRecord[]>;
        function __promisify__(hostname: string, rrtype: "MX"): Promise<MxRecord[]>;
        function __promisify__(hostname: string, rrtype: "NAPTR"): Promise<NaptrRecord[]>;
        function __promisify__(hostname: string, rrtype: "SOA"): Promise<SoaRecord>;
        function __promisify__(hostname: string, rrtype: "SRV"): Promise<SrvRecord[]>;
        function __promisify__(hostname: string, rrtype: "TXT"): Promise<string[][]>;
        function __promisify__(
            hostname: string,
            rrtype: string,
        ): Promise<string[] | MxRecord[] | NaptrRecord[] | SoaRecord | SrvRecord[] | string[][] | AnyRecord[]>;
    }
    /**
     * Uses the DNS protocol to resolve a IPv4 addresses (`A` records) for the `hostname`. The `addresses` argument passed to the `callback` function
     * will contain an array of IPv4 addresses (e.g.`['74.125.79.104', '74.125.79.105', '74.125.79.106']`).
     * @since v0.1.16
     * @param hostname Host name to resolve.
     */
    export function resolve4(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void,
    ): void;
    export function resolve4(
        hostname: string,
        options: ResolveWithTtlOptions,
        callback: (err: NodeJS.ErrnoException | null, addresses: RecordWithTtl[]) => void,
    ): void;
    export function resolve4(
        hostname: string,
        options: ResolveOptions,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[] | RecordWithTtl[]) => void,
    ): void;
    export namespace resolve4 {
        function __promisify__(hostname: string): Promise<string[]>;
        function __promisify__(hostname: string, options: ResolveWithTtlOptions): Promise<RecordWithTtl[]>;
        function __promisify__(hostname: string, options?: ResolveOptions): Promise<string[] | RecordWithTtl[]>;
    }
    /**
     * Uses the DNS protocol to resolve IPv6 addresses (`AAAA` records) for the `hostname`. The `addresses` argument passed to the `callback` function
     * will contain an array of IPv6 addresses.
     * @since v0.1.16
     * @param hostname Host name to resolve.
     */
    export function resolve6(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void,
    ): void;
    export function resolve6(
        hostname: string,
        options: ResolveWithTtlOptions,
        callback: (err: NodeJS.ErrnoException | null, addresses: RecordWithTtl[]) => void,
    ): void;
    export function resolve6(
        hostname: string,
        options: ResolveOptions,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[] | RecordWithTtl[]) => void,
    ): void;
    export namespace resolve6 {
        function __promisify__(hostname: string): Promise<string[]>;
        function __promisify__(hostname: string, options: ResolveWithTtlOptions): Promise<RecordWithTtl[]>;
        function __promisify__(hostname: string, options?: ResolveOptions): Promise<string[] | RecordWithTtl[]>;
    }
    /**
     * Uses the DNS protocol to resolve `CNAME` records for the `hostname`. The `addresses` argument passed to the `callback` function
     * will contain an array of canonical name records available for the `hostname` (e.g. `['bar.example.com']`).
     * @since v0.3.2
     */
    export function resolveCname(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void,
    ): void;
    export namespace resolveCname {
        function __promisify__(hostname: string): Promise<string[]>;
    }
    /**
     * Uses the DNS protocol to resolve `CAA` records for the `hostname`. The `addresses` argument passed to the `callback` function
     * will contain an array of certification authority authorization records
     * available for the `hostname` (e.g. `[{critical: 0, iodef: 'mailto:pki@example.com'}, {critical: 128, issue: 'pki.example.com'}]`).
     * @since v15.0.0, v14.17.0
     */
    export function resolveCaa(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, records: CaaRecord[]) => void,
    ): void;
    export namespace resolveCaa {
        function __promisify__(hostname: string): Promise<CaaRecord[]>;
    }
    /**
     * Uses the DNS protocol to resolve mail exchange records (`MX` records) for the `hostname`. The `addresses` argument passed to the `callback` function will
     * contain an array of objects containing both a `priority` and `exchange` property (e.g. `[{priority: 10, exchange: 'mx.example.com'}, ...]`).
     * @since v0.1.27
     */
    export function resolveMx(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: MxRecord[]) => void,
    ): void;
    export namespace resolveMx {
        function __promisify__(hostname: string): Promise<MxRecord[]>;
    }
    /**
     * Uses the DNS protocol to resolve regular expression-based records (`NAPTR` records) for the `hostname`. The `addresses` argument passed to the `callback` function will contain an array of
     * objects with the following properties:
     *
     * * `flags`
     * * `service`
     * * `regexp`
     * * `replacement`
     * * `order`
     * * `preference`
     *
     * ```js
     * {
     *   flags: 's',
     *   service: 'SIP+D2U',
     *   regexp: '',
     *   replacement: '_sip._udp.example.com',
     *   order: 30,
     *   preference: 100
     * }
     * ```
     * @since v0.9.12
     */
    export function resolveNaptr(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: NaptrRecord[]) => void,
    ): void;
    export namespace resolveNaptr {
        function __promisify__(hostname: string): Promise<NaptrRecord[]>;
    }
    /**
     * Uses the DNS protocol to resolve name server records (`NS` records) for the `hostname`. The `addresses` argument passed to the `callback` function will
     * contain an array of name server records available for `hostname` (e.g. `['ns1.example.com', 'ns2.example.com']`).
     * @since v0.1.90
     */
    export function resolveNs(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void,
    ): void;
    export namespace resolveNs {
        function __promisify__(hostname: string): Promise<string[]>;
    }
    /**
     * Uses the DNS protocol to resolve pointer records (`PTR` records) for the `hostname`. The `addresses` argument passed to the `callback` function will
     * be an array of strings containing the reply records.
     * @since v6.0.0
     */
    export function resolvePtr(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void,
    ): void;
    export namespace resolvePtr {
        function __promisify__(hostname: string): Promise<string[]>;
    }
    /**
     * Uses the DNS protocol to resolve a start of authority record (`SOA` record) for
     * the `hostname`. The `address` argument passed to the `callback` function will
     * be an object with the following properties:
     *
     * * `nsname`
     * * `hostmaster`
     * * `serial`
     * * `refresh`
     * * `retry`
     * * `expire`
     * * `minttl`
     *
     * ```js
     * {
     *   nsname: 'ns.example.com',
     *   hostmaster: 'root.example.com',
     *   serial: 2013101809,
     *   refresh: 10000,
     *   retry: 2400,
     *   expire: 604800,
     *   minttl: 3600
     * }
     * ```
     * @since v0.11.10
     */
    export function resolveSoa(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, address: SoaRecord) => void,
    ): void;
    export namespace resolveSoa {
        function __promisify__(hostname: string): Promise<SoaRecord>;
    }
    /**
     * Uses the DNS protocol to resolve service records (`SRV` records) for the `hostname`. The `addresses` argument passed to the `callback` function will
     * be an array of objects with the following properties:
     *
     * * `priority`
     * * `weight`
     * * `port`
     * * `name`
     *
     * ```js
     * {
     *   priority: 10,
     *   weight: 5,
     *   port: 21223,
     *   name: 'service.example.com'
     * }
     * ```
     * @since v0.1.27
     */
    export function resolveSrv(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: SrvRecord[]) => void,
    ): void;
    export namespace resolveSrv {
        function __promisify__(hostname: string): Promise<SrvRecord[]>;
    }
    /**
     * Uses the DNS protocol to resolve text queries (`TXT` records) for the `hostname`. The `records` argument passed to the `callback` function is a
     * two-dimensional array of the text records available for `hostname` (e.g.`[ ['v=spf1 ip4:0.0.0.0 ', '~all' ] ]`). Each sub-array contains TXT chunks of
     * one record. Depending on the use case, these could be either joined together or
     * treated separately.
     * @since v0.1.27
     */
    export function resolveTxt(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[][]) => void,
    ): void;
    export namespace resolveTxt {
        function __promisify__(hostname: string): Promise<string[][]>;
    }
    /**
     * Uses the DNS protocol to resolve all records (also known as `ANY` or `*` query).
     * The `ret` argument passed to the `callback` function will be an array containing
     * various types of records. Each object has a property `type` that indicates the
     * type of the current record. And depending on the `type`, additional properties
     * will be present on the object:
     *
     * <omitted>
     *
     * Here is an example of the `ret` object passed to the callback:
     *
     * ```js
     * [ { type: 'A', address: '127.0.0.1', ttl: 299 },
     *   { type: 'CNAME', value: 'example.com' },
     *   { type: 'MX', exchange: 'alt4.aspmx.l.example.com', priority: 50 },
     *   { type: 'NS', value: 'ns1.example.com' },
     *   { type: 'TXT', entries: [ 'v=spf1 include:_spf.example.com ~all' ] },
     *   { type: 'SOA',
     *     nsname: 'ns1.example.com',
     *     hostmaster: 'admin.example.com',
     *     serial: 156696742,
     *     refresh: 900,
     *     retry: 900,
     *     expire: 1800,
     *     minttl: 60 } ]
     * ```
     *
     * DNS server operators may choose not to respond to `ANY` queries. It may be better to call individual methods like {@link resolve4}, {@link resolveMx}, and so on. For more details, see
     * [RFC 8482](https://tools.ietf.org/html/rfc8482).
     */
    export function resolveAny(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: AnyRecord[]) => void,
    ): void;
    export namespace resolveAny {
        function __promisify__(hostname: string): Promise<AnyRecord[]>;
    }
    /**
     * Performs a reverse DNS query that resolves an IPv4 or IPv6 address to an
     * array of host names.
     *
     * On error, `err` is an [`Error`](https://nodejs.org/docs/latest-v22.x/api/errors.html#class-error) object, where `err.code` is
     * one of the [DNS error codes](https://nodejs.org/docs/latest-v22.x/api/dns.html#error-codes).
     * @since v0.1.16
     */
    export function reverse(
        ip: string,
        callback: (err: NodeJS.ErrnoException | null, hostnames: string[]) => void,
    ): void;
    /**
     * Get the default value for `order` in {@link lookup} and [`dnsPromises.lookup()`](https://nodejs.org/docs/latest-v22.x/api/dns.html#dnspromiseslookuphostname-options).
     * The value could be:
     *
     * * `ipv4first`: for `order` defaulting to `ipv4first`.
     * * `ipv6first`: for `order` defaulting to `ipv6first`.
     * * `verbatim`: for `order` defaulting to `verbatim`.
     * @since v18.17.0
     */
    export function getDefaultResultOrder(): "ipv4first" | "ipv6first" | "verbatim";
    /**
     * Sets the IP address and port of servers to be used when performing DNS
     * resolution. The `servers` argument is an array of [RFC 5952](https://tools.ietf.org/html/rfc5952#section-6) formatted
     * addresses. If the port is the IANA default DNS port (53) it can be omitted.
     *
     * ```js
     * dns.setServers([
     *   '4.4.4.4',
     *   '[2001:4860:4860::8888]',
     *   '4.4.4.4:1053',
     *   '[2001:4860:4860::8888]:1053',
     * ]);
     * ```
     *
     * An error will be thrown if an invalid address is provided.
     *
     * The `dns.setServers()` method must not be called while a DNS query is in
     * progress.
     *
     * The {@link setServers} method affects only {@link resolve}, `dns.resolve*()` and {@link reverse} (and specifically _not_ {@link lookup}).
     *
     * This method works much like [resolve.conf](https://man7.org/linux/man-pages/man5/resolv.conf.5.html).
     * That is, if attempting to resolve with the first server provided results in a `NOTFOUND` error, the `resolve()` method will _not_ attempt to resolve with
     * subsequent servers provided. Fallback DNS servers will only be used if the
     * earlier ones time out or result in some other error.
     * @since v0.11.3
     * @param servers array of [RFC 5952](https://datatracker.ietf.org/doc/html/rfc5952#section-6) formatted addresses
     */
    export function setServers(servers: readonly string[]): void;
    /**
     * Returns an array of IP address strings, formatted according to [RFC 5952](https://tools.ietf.org/html/rfc5952#section-6),
     * that are currently configured for DNS resolution. A string will include a port
     * section if a custom port is used.
     *
     * ```js
     * [
     *   '4.4.4.4',
     *   '2001:4860:4860::8888',
     *   '4.4.4.4:1053',
     *   '[2001:4860:4860::8888]:1053',
     * ]
     * ```
     * @since v0.11.3
     */
    export function getServers(): string[];
    /**
     * Set the default value of `order` in {@link lookup} and [`dnsPromises.lookup()`](https://nodejs.org/docs/latest-v22.x/api/dns.html#dnspromiseslookuphostname-options).
     * The value could be:
     *
     * * `ipv4first`: sets default `order` to `ipv4first`.
     * * `ipv6first`: sets default `order` to `ipv6first`.
     * * `verbatim`: sets default `order` to `verbatim`.
     *
     * The default is `verbatim` and {@link setDefaultResultOrder} have higher
     * priority than [`--dns-result-order`](https://nodejs.org/docs/latest-v22.x/api/cli.html#--dns-result-orderorder). When using
     * [worker threads](https://nodejs.org/docs/latest-v22.x/api/worker_threads.html), {@link setDefaultResultOrder} from the main
     * thread won't affect the default dns orders in workers.
     * @since v16.4.0, v14.18.0
     * @param order must be `'ipv4first'`, `'ipv6first'` or `'verbatim'`.
     */
    export function setDefaultResultOrder(order: "ipv4first" | "ipv6first" | "verbatim"): void;
    // Error codes
    export const NODATA: "ENODATA";
    export const FORMERR: "EFORMERR";
    export const SERVFAIL: "ESERVFAIL";
    export const NOTFOUND: "ENOTFOUND";
    export const NOTIMP: "ENOTIMP";
    export const REFUSED: "EREFUSED";
    export const BADQUERY: "EBADQUERY";
    export const BADNAME: "EBADNAME";
    export const BADFAMILY: "EBADFAMILY";
    export const BADRESP: "EBADRESP";
    export const CONNREFUSED: "ECONNREFUSED";
    export const TIMEOUT: "ETIMEOUT";
    export const EOF: "EOF";
    export const FILE: "EFILE";
    export const NOMEM: "ENOMEM";
    export const DESTRUCTION: "EDESTRUCTION";
    export const BADSTR: "EBADSTR";
    export const BADFLAGS: "EBADFLAGS";
    export const NONAME: "ENONAME";
    export const BADHINTS: "EBADHINTS";
    export const NOTINITIALIZED: "ENOTINITIALIZED";
    export const LOADIPHLPAPI: "ELOADIPHLPAPI";
    export const ADDRGETNETWORKPARAMS: "EADDRGETNETWORKPARAMS";
    export const CANCELLED: "ECANCELLED";
    export interface ResolverOptions {
        /**
         * Query timeout in milliseconds, or `-1` to use the default timeout.
         */
        timeout?: number | undefined;
        /**
         * The number of tries the resolver will try contacting each name server before giving up.
         * @default 4
         */
        tries?: number;
    }
    /**
     * An independent resolver for DNS requests.
     *
     * Creating a new resolver uses the default server settings. Setting
     * the servers used for a resolver using [`resolver.setServers()`](https://nodejs.org/docs/latest-v22.x/api/dns.html#dnssetserversservers) does not affect
     * other resolvers:
     *
     * ```js
     * const { Resolver } = require('node:dns');
     * const resolver = new Resolver();
     * resolver.setServers(['4.4.4.4']);
     *
     * // This request will use the server at 4.4.4.4, independent of global settings.
     * resolver.resolve4('example.org', (err, addresses) => {
     *   // ...
     * });
     * ```
     *
     * The following methods from the `node:dns` module are available:
     *
     * * `resolver.getServers()`
     * * `resolver.resolve()`
     * * `resolver.resolve4()`
     * * `resolver.resolve6()`
     * * `resolver.resolveAny()`
     * * `resolver.resolveCaa()`
     * * `resolver.resolveCname()`
     * * `resolver.resolveMx()`
     * * `resolver.resolveNaptr()`
     * * `resolver.resolveNs()`
     * * `resolver.resolvePtr()`
     * * `resolver.resolveSoa()`
     * * `resolver.resolveSrv()`
     * * `resolver.resolveTxt()`
     * * `resolver.reverse()`
     * * `resolver.setServers()`
     * @since v8.3.0
     */
    export class Resolver {
        constructor(options?: ResolverOptions);
        /**
         * Cancel all outstanding DNS queries made by this resolver. The corresponding
         * callbacks will be called with an error with code `ECANCELLED`.
         * @since v8.3.0
         */
        cancel(): void;
        getServers: typeof getServers;
        resolve: typeof resolve;
        resolve4: typeof resolve4;
        resolve6: typeof resolve6;
        resolveAny: typeof resolveAny;
        resolveCaa: typeof resolveCaa;
        resolveCname: typeof resolveCname;
        resolveMx: typeof resolveMx;
        resolveNaptr: typeof resolveNaptr;
        resolveNs: typeof resolveNs;
        resolvePtr: typeof resolvePtr;
        resolveSoa: typeof resolveSoa;
        resolveSrv: typeof resolveSrv;
        resolveTxt: typeof resolveTxt;
        reverse: typeof reverse;
        /**
         * The resolver instance will send its requests from the specified IP address.
         * This allows programs to specify outbound interfaces when used on multi-homed
         * systems.
         *
         * If a v4 or v6 address is not specified, it is set to the default and the
         * operating system will choose a local address automatically.
         *
         * The resolver will use the v4 local address when making requests to IPv4 DNS
         * servers, and the v6 local address when making requests to IPv6 DNS servers.
         * The `rrtype` of resolution requests has no impact on the local address used.
         * @since v15.1.0, v14.17.0
         * @param [ipv4='0.0.0.0'] A string representation of an IPv4 address.
         * @param [ipv6='::0'] A string representation of an IPv6 address.
         */
        setLocalAddress(ipv4?: string, ipv6?: string): void;
        setServers: typeof setServers;
    }
    export { dnsPromises as promises };
}
declare module "node:dns" {
    export * from "dns";
}
/**
 * The `dns.promises` API provides an alternative set of asynchronous DNS methods
 * that return `Promise` objects rather than using callbacks. The API is accessible
 * via `require('node:dns').promises` or `require('node:dns/promises')`.
 * @since v10.6.0
 */
declare module "dns/promises" {
    import {
        AnyRecord,
        CaaRecord,
        LookupAddress,
        LookupAllOptions,
        LookupOneOptions,
        LookupOptions,
        MxRecord,
        NaptrRecord,
        RecordWithTtl,
        ResolveOptions,
        ResolverOptions,
        ResolveWithTtlOptions,
        SoaRecord,
        SrvRecord,
    } from "node:dns";
    /**
     * Returns an array of IP address strings, formatted according to [RFC 5952](https://tools.ietf.org/html/rfc5952#section-6),
     * that are currently configured for DNS resolution. A string will include a port
     * section if a custom port is used.
     *
     * ```js
     * [
     *   '4.4.4.4',
     *   '2001:4860:4860::8888',
     *   '4.4.4.4:1053',
     *   '[2001:4860:4860::8888]:1053',
     * ]
     * ```
     * @since v10.6.0
     */
    function getServers(): string[];
    /**
     * Resolves a host name (e.g. `'nodejs.org'`) into the first found A (IPv4) or
     * AAAA (IPv6) record. All `option` properties are optional. If `options` is an
     * integer, then it must be `4` or `6` – if `options` is not provided, then IPv4
     * and IPv6 addresses are both returned if found.
     *
     * With the `all` option set to `true`, the `Promise` is resolved with `addresses` being an array of objects with the properties `address` and `family`.
     *
     * On error, the `Promise` is rejected with an [`Error`](https://nodejs.org/docs/latest-v20.x/api/errors.html#class-error) object, where `err.code` is the error code.
     * Keep in mind that `err.code` will be set to `'ENOTFOUND'` not only when
     * the host name does not exist but also when the lookup fails in other ways
     * such as no available file descriptors.
     *
     * [`dnsPromises.lookup()`](https://nodejs.org/docs/latest-v20.x/api/dns.html#dnspromiseslookuphostname-options) does not necessarily have anything to do with the DNS
     * protocol. The implementation uses an operating system facility that can
     * associate names with addresses and vice versa. This implementation can have
     * subtle but important consequences on the behavior of any Node.js program. Please
     * take some time to consult the [Implementation considerations section](https://nodejs.org/docs/latest-v20.x/api/dns.html#implementation-considerations) before
     * using `dnsPromises.lookup()`.
     *
     * Example usage:
     *
     * ```js
     * const dns = require('node:dns');
     * const dnsPromises = dns.promises;
     * const options = {
     *   family: 6,
     *   hints: dns.ADDRCONFIG | dns.V4MAPPED,
     * };
     *
     * dnsPromises.lookup('example.com', options).then((result) => {
     *   console.log('address: %j family: IPv%s', result.address, result.family);
     *   // address: "2606:2800:220:1:248:1893:25c8:1946" family: IPv6
     * });
     *
     * // When options.all is true, the result will be an Array.
     * options.all = true;
     * dnsPromises.lookup('example.com', options).then((result) => {
     *   console.log('addresses: %j', result);
     *   // addresses: [{"address":"2606:2800:220:1:248:1893:25c8:1946","family":6}]
     * });
     * ```
     * @since v10.6.0
     */
    function lookup(hostname: string, family: number): Promise<LookupAddress>;
    function lookup(hostname: string, options: LookupOneOptions): Promise<LookupAddress>;
    function lookup(hostname: string, options: LookupAllOptions): Promise<LookupAddress[]>;
    function lookup(hostname: string, options: LookupOptions): Promise<LookupAddress | LookupAddress[]>;
    function lookup(hostname: string): Promise<LookupAddress>;
    /**
     * Resolves the given `address` and `port` into a host name and service using
     * the operating system's underlying `getnameinfo` implementation.
     *
     * If `address` is not a valid IP address, a `TypeError` will be thrown.
     * The `port` will be coerced to a number. If it is not a legal port, a `TypeError` will be thrown.
     *
     * On error, the `Promise` is rejected with an [`Error`](https://nodejs.org/docs/latest-v20.x/api/errors.html#class-error) object, where `err.code` is the error code.
     *
     * ```js
     * const dnsPromises = require('node:dns').promises;
     * dnsPromises.lookupService('127.0.0.1', 22).then((result) => {
     *   console.log(result.hostname, result.service);
     *   // Prints: localhost ssh
     * });
     * ```
     * @since v10.6.0
     */
    function lookupService(
        address: string,
        port: number,
    ): Promise<{
        hostname: string;
        service: string;
    }>;
    /**
     * Uses the DNS protocol to resolve a host name (e.g. `'nodejs.org'`) into an array
     * of the resource records. When successful, the `Promise` is resolved with an
     * array of resource records. The type and structure of individual results vary
     * based on `rrtype`:
     *
     * <omitted>
     *
     * On error, the `Promise` is rejected with an [`Error`](https://nodejs.org/docs/latest-v20.x/api/errors.html#class-error) object, where `err.code`
     * is one of the [DNS error codes](https://nodejs.org/docs/latest-v20.x/api/dns.html#error-codes).
     * @since v10.6.0
     * @param hostname Host name to resolve.
     * @param [rrtype='A'] Resource record type.
     */
    function resolve(hostname: string): Promise<string[]>;
    function resolve(hostname: string, rrtype: "A"): Promise<string[]>;
    function resolve(hostname: string, rrtype: "AAAA"): Promise<string[]>;
    function resolve(hostname: string, rrtype: "ANY"): Promise<AnyRecord[]>;
    function resolve(hostname: string, rrtype: "CAA"): Promise<CaaRecord[]>;
    function resolve(hostname: string, rrtype: "CNAME"): Promise<string[]>;
    function resolve(hostname: string, rrtype: "MX"): Promise<MxRecord[]>;
    function resolve(hostname: string, rrtype: "NAPTR"): Promise<NaptrRecord[]>;
    function resolve(hostname: string, rrtype: "NS"): Promise<string[]>;
    function resolve(hostname: string, rrtype: "PTR"): Promise<string[]>;
    function resolve(hostname: string, rrtype: "SOA"): Promise<SoaRecord>;
    function resolve(hostname: string, rrtype: "SRV"): Promise<SrvRecord[]>;
    function resolve(hostname: string, rrtype: "TXT"): Promise<string[][]>;
    function resolve(
        hostname: string,
        rrtype: string,
    ): Promise<string[] | MxRecord[] | NaptrRecord[] | SoaRecord | SrvRecord[] | string[][] | AnyRecord[]>;
    /**
     * Uses the DNS protocol to resolve IPv4 addresses (`A` records) for the `hostname`. On success, the `Promise` is resolved with an array of IPv4
     * addresses (e.g. `['74.125.79.104', '74.125.79.105', '74.125.79.106']`).
     * @since v10.6.0
     * @param hostname Host name to resolve.
     */
    function resolve4(hostname: string): Promise<string[]>;
    function resolve4(hostname: string, options: ResolveWithTtlOptions): Promise<RecordWithTtl[]>;
    function resolve4(hostname: string, options: ResolveOptions): Promise<string[] | RecordWithTtl[]>;
    /**
     * Uses the DNS protocol to resolve IPv6 addresses (`AAAA` records) for the `hostname`. On success, the `Promise` is resolved with an array of IPv6
     * addresses.
     * @since v10.6.0
     * @param hostname Host name to resolve.
     */
    function resolve6(hostname: string): Promise<string[]>;
    function resolve6(hostname: string, options: ResolveWithTtlOptions): Promise<RecordWithTtl[]>;
    function resolve6(hostname: string, options: ResolveOptions): Promise<string[] | RecordWithTtl[]>;
    /**
     * Uses the DNS protocol to resolve all records (also known as `ANY` or `*` query).
     * On success, the `Promise` is resolved with an array containing various types of
     * records. Each object has a property `type` that indicates the type of the
     * current record. And depending on the `type`, additional properties will be
     * present on the object:
     *
     * <omitted>
     *
     * Here is an example of the result object:
     *
     * ```js
     * [ { type: 'A', address: '127.0.0.1', ttl: 299 },
     *   { type: 'CNAME', value: 'example.com' },
     *   { type: 'MX', exchange: 'alt4.aspmx.l.example.com', priority: 50 },
     *   { type: 'NS', value: 'ns1.example.com' },
     *   { type: 'TXT', entries: [ 'v=spf1 include:_spf.example.com ~all' ] },
     *   { type: 'SOA',
     *     nsname: 'ns1.example.com',
     *     hostmaster: 'admin.example.com',
     *     serial: 156696742,
     *     refresh: 900,
     *     retry: 900,
     *     expire: 1800,
     *     minttl: 60 } ]
     * ```
     * @since v10.6.0
     */
    function resolveAny(hostname: string): Promise<AnyRecord[]>;
    /**
     * Uses the DNS protocol to resolve `CAA` records for the `hostname`. On success,
     * the `Promise` is resolved with an array of objects containing available
     * certification authority authorization records available for the `hostname` (e.g. `[{critical: 0, iodef: 'mailto:pki@example.com'},{critical: 128, issue: 'pki.example.com'}]`).
     * @since v15.0.0, v14.17.0
     */
    function resolveCaa(hostname: string): Promise<CaaRecord[]>;
    /**
     * Uses the DNS protocol to resolve `CNAME` records for the `hostname`. On success,
     * the `Promise` is resolved with an array of canonical name records available for
     * the `hostname` (e.g. `['bar.example.com']`).
     * @since v10.6.0
     */
    function resolveCname(hostname: string): Promise<string[]>;
    /**
     * Uses the DNS protocol to resolve mail exchange records (`MX` records) for the `hostname`. On success, the `Promise` is resolved with an array of objects
     * containing both a `priority` and `exchange` property (e.g.`[{priority: 10, exchange: 'mx.example.com'}, ...]`).
     * @since v10.6.0
     */
    function resolveMx(hostname: string): Promise<MxRecord[]>;
    /**
     * Uses the DNS protocol to resolve regular expression-based records (`NAPTR` records) for the `hostname`. On success, the `Promise` is resolved with an array
     * of objects with the following properties:
     *
     * * `flags`
     * * `service`
     * * `regexp`
     * * `replacement`
     * * `order`
     * * `preference`
     *
     * ```js
     * {
     *   flags: 's',
     *   service: 'SIP+D2U',
     *   regexp: '',
     *   replacement: '_sip._udp.example.com',
     *   order: 30,
     *   preference: 100
     * }
     * ```
     * @since v10.6.0
     */
    function resolveNaptr(hostname: string): Promise<NaptrRecord[]>;
    /**
     * Uses the DNS protocol to resolve name server records (`NS` records) for the `hostname`. On success, the `Promise` is resolved with an array of name server
     * records available for `hostname` (e.g.`['ns1.example.com', 'ns2.example.com']`).
     * @since v10.6.0
     */
    function resolveNs(hostname: string): Promise<string[]>;
    /**
     * Uses the DNS protocol to resolve pointer records (`PTR` records) for the `hostname`. On success, the `Promise` is resolved with an array of strings
     * containing the reply records.
     * @since v10.6.0
     */
    function resolvePtr(hostname: string): Promise<string[]>;
    /**
     * Uses the DNS protocol to resolve a start of authority record (`SOA` record) for
     * the `hostname`. On success, the `Promise` is resolved with an object with the
     * following properties:
     *
     * * `nsname`
     * * `hostmaster`
     * * `serial`
     * * `refresh`
     * * `retry`
     * * `expire`
     * * `minttl`
     *
     * ```js
     * {
     *   nsname: 'ns.example.com',
     *   hostmaster: 'root.example.com',
     *   serial: 2013101809,
     *   refresh: 10000,
     *   retry: 2400,
     *   expire: 604800,
     *   minttl: 3600
     * }
     * ```
     * @since v10.6.0
     */
    function resolveSoa(hostname: string): Promise<SoaRecord>;
    /**
     * Uses the DNS protocol to resolve service records (`SRV` records) for the `hostname`. On success, the `Promise` is resolved with an array of objects with
     * the following properties:
     *
     * * `priority`
     * * `weight`
     * * `port`
     * * `name`
     *
     * ```js
     * {
     *   priority: 10,
     *   weight: 5,
     *   port: 21223,
     *   name: 'service.example.com'
     * }
     * ```
     * @since v10.6.0
     */
    function resolveSrv(hostname: string): Promise<SrvRecord[]>;
    /**
     * Uses the DNS protocol to resolve text queries (`TXT` records) for the `hostname`. On success, the `Promise` is resolved with a two-dimensional array
     * of the text records available for `hostname` (e.g.`[ ['v=spf1 ip4:0.0.0.0 ', '~all' ] ]`). Each sub-array contains TXT chunks of
     * one record. Depending on the use case, these could be either joined together or
     * treated separately.
     * @since v10.6.0
     */
    function resolveTxt(hostname: string): Promise<string[][]>;
    /**
     * Performs a reverse DNS query that resolves an IPv4 or IPv6 address to an
     * array of host names.
     *
     * On error, the `Promise` is rejected with an [`Error`](https://nodejs.org/docs/latest-v20.x/api/errors.html#class-error) object, where `err.code`
     * is one of the [DNS error codes](https://nodejs.org/docs/latest-v20.x/api/dns.html#error-codes).
     * @since v10.6.0
     */
    function reverse(ip: string): Promise<string[]>;
    /**
     * Get the default value for `verbatim` in {@link lookup} and [dnsPromises.lookup()](https://nodejs.org/docs/latest-v20.x/api/dns.html#dnspromiseslookuphostname-options).
     * The value could be:
     *
     * * `ipv4first`: for `verbatim` defaulting to `false`.
     * * `verbatim`: for `verbatim` defaulting to `true`.
     * @since v20.1.0
     */
    function getDefaultResultOrder(): "ipv4first" | "verbatim";
    /**
     * Sets the IP address and port of servers to be used when performing DNS
     * resolution. The `servers` argument is an array of [RFC 5952](https://tools.ietf.org/html/rfc5952#section-6) formatted
     * addresses. If the port is the IANA default DNS port (53) it can be omitted.
     *
     * ```js
     * dnsPromises.setServers([
     *   '4.4.4.4',
     *   '[2001:4860:4860::8888]',
     *   '4.4.4.4:1053',
     *   '[2001:4860:4860::8888]:1053',
     * ]);
     * ```
     *
     * An error will be thrown if an invalid address is provided.
     *
     * The `dnsPromises.setServers()` method must not be called while a DNS query is in
     * progress.
     *
     * This method works much like [resolve.conf](https://man7.org/linux/man-pages/man5/resolv.conf.5.html).
     * That is, if attempting to resolve with the first server provided results in a `NOTFOUND` error, the `resolve()` method will _not_ attempt to resolve with
     * subsequent servers provided. Fallback DNS servers will only be used if the
     * earlier ones time out or result in some other error.
     * @since v10.6.0
     * @param servers array of `RFC 5952` formatted addresses
     */
    function setServers(servers: readonly string[]): void;
    /**
     * Set the default value of `order` in `dns.lookup()` and `{@link lookup}`. The value could be:
     *
     * * `ipv4first`: sets default `order` to `ipv4first`.
     * * `ipv6first`: sets default `order` to `ipv6first`.
     * * `verbatim`: sets default `order` to `verbatim`.
     *
     * The default is `verbatim` and [dnsPromises.setDefaultResultOrder()](https://nodejs.org/docs/latest-v20.x/api/dns.html#dnspromisessetdefaultresultorderorder)
     * have higher priority than [`--dns-result-order`](https://nodejs.org/docs/latest-v20.x/api/cli.html#--dns-result-orderorder).
     * When using [worker threads](https://nodejs.org/docs/latest-v20.x/api/worker_threads.html), [`dnsPromises.setDefaultResultOrder()`](https://nodejs.org/docs/latest-v20.x/api/dns.html#dnspromisessetdefaultresultorderorder)
     * from the main thread won't affect the default dns orders in workers.
     * @since v16.4.0, v14.18.0
     * @param order must be `'ipv4first'`, `'ipv6first'` or `'verbatim'`.
     */
    function setDefaultResultOrder(order: "ipv4first" | "ipv6first" | "verbatim"): void;
    // Error codes
    const NODATA: "ENODATA";
    const FORMERR: "EFORMERR";
    const SERVFAIL: "ESERVFAIL";
    const NOTFOUND: "ENOTFOUND";
    const NOTIMP: "ENOTIMP";
    const REFUSED: "EREFUSED";
    const BADQUERY: "EBADQUERY";
    const BADNAME: "EBADNAME";
    const BADFAMILY: "EBADFAMILY";
    const BADRESP: "EBADRESP";
    const CONNREFUSED: "ECONNREFUSED";
    const TIMEOUT: "ETIMEOUT";
    const EOF: "EOF";
    const FILE: "EFILE";
    const NOMEM: "ENOMEM";
    const DESTRUCTION: "EDESTRUCTION";
    const BADSTR: "EBADSTR";
    const BADFLAGS: "EBADFLAGS";
    const NONAME: "ENONAME";
    const BADHINTS: "EBADHINTS";
    const NOTINITIALIZED: "ENOTINITIALIZED";
    const LOADIPHLPAPI: "ELOADIPHLPAPI";
    const ADDRGETNETWORKPARAMS: "EADDRGETNETWORKPARAMS";
    const CANCELLED: "ECANCELLED";

    /**
     * An independent resolver for DNS requests.
     *
     * Creating a new resolver uses the default server settings. Setting
     * the servers used for a resolver using [`resolver.setServers()`](https://nodejs.org/docs/latest-v20.x/api/dns.html#dnspromisessetserversservers) does not affect
     * other resolvers:
     *
     * ```js
     * const { Resolver } = require('node:dns').promises;
     * const resolver = new Resolver();
     * resolver.setServers(['4.4.4.4']);
     *
     * // This request will use the server at 4.4.4.4, independent of global settings.
     * resolver.resolve4('example.org').then((addresses) => {
     *   // ...
     * });
     *
     * // Alternatively, the same code can be written using async-await style.
     * (async function() {
     *   const addresses = await resolver.resolve4('example.org');
     * })();
     * ```
     *
     * The following methods from the `dnsPromises` API are available:
     *
     * * `resolver.getServers()`
     * * `resolver.resolve()`
     * * `resolver.resolve4()`
     * * `resolver.resolve6()`
     * * `resolver.resolveAny()`
     * * `resolver.resolveCaa()`
     * * `resolver.resolveCname()`
     * * `resolver.resolveMx()`
     * * `resolver.resolveNaptr()`
     * * `resolver.resolveNs()`
     * * `resolver.resolvePtr()`
     * * `resolver.resolveSoa()`
     * * `resolver.resolveSrv()`
     * * `resolver.resolveTxt()`
     * * `resolver.reverse()`
     * * `resolver.setServers()`
     * @since v10.6.0
     */
    class Resolver {
        constructor(options?: ResolverOptions);
        /**
         * Cancel all outstanding DNS queries made by this resolver. The corresponding
         * callbacks will be called with an error with code `ECANCELLED`.
         * @since v8.3.0
         */
        cancel(): void;
        getServers: typeof getServers;
        resolve: typeof resolve;
        resolve4: typeof resolve4;
        resolve6: typeof resolve6;
        resolveAny: typeof resolveAny;
        resolveCaa: typeof resolveCaa;
        resolveCname: typeof resolveCname;
        resolveMx: typeof resolveMx;
        resolveNaptr: typeof resolveNaptr;
        resolveNs: typeof resolveNs;
        resolvePtr: typeof resolvePtr;
        resolveSoa: typeof resolveSoa;
        resolveSrv: typeof resolveSrv;
        resolveTxt: typeof resolveTxt;
        reverse: typeof reverse;
        /**
         * The resolver instance will send its requests from the specified IP address.
         * This allows programs to specify outbound interfaces when used on multi-homed
         * systems.
         *
         * If a v4 or v6 address is not specified, it is set to the default and the
         * operating system will choose a local address automatically.
         *
         * The resolver will use the v4 local address when making requests to IPv4 DNS
         * servers, and the v6 local address when making requests to IPv6 DNS servers.
         * The `rrtype` of resolution requests has no impact on the local address used.
         * @since v15.1.0, v14.17.0
         * @param [ipv4='0.0.0.0'] A string representation of an IPv4 address.
         * @param [ipv6='::0'] A string representation of an IPv6 address.
         */
        setLocalAddress(ipv4?: string, ipv6?: string): void;
        setServers: typeof setServers;
    }
}
declare module "node:dns/promises" {
    export * from "dns/promises";
}
export {}; // Don't export anything!

//// DOM-like Events
// NB: The Event / EventTarget / EventListener implementations below were copied
// from lib.dom.d.ts, then edited to reflect Node's documentation at
// https://nodejs.org/api/events.html#class-eventtarget.
// Please read that link to understand important implementation differences.

// This conditional type will be the existing global Event in a browser, or
// the copy below in a Node environment.
type __Event = typeof globalThis extends { onmessage: any; Event: any } ? {}
    : {
        /** This is not used in Node.js and is provided purely for completeness. */
        readonly bubbles: boolean;
        /** Alias for event.stopPropagation(). This is not used in Node.js and is provided purely for completeness. */
        cancelBubble: () => void;
        /** True if the event was created with the cancelable option */
        readonly cancelable: boolean;
        /** This is not used in Node.js and is provided purely for completeness. */
        readonly composed: boolean;
        /** Returns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness. */
        composedPath(): [EventTarget?];
        /** Alias for event.target. */
        readonly currentTarget: EventTarget | null;
        /** Is true if cancelable is true and event.preventDefault() has been called. */
        readonly defaultPrevented: boolean;
        /** This is not used in Node.js and is provided purely for completeness. */
        readonly eventPhase: 0 | 2;
        /** The `AbortSignal` "abort" event is emitted with `isTrusted` set to `true`. The value is `false` in all other cases. */
        readonly isTrusted: boolean;
        /** Sets the `defaultPrevented` property to `true` if `cancelable` is `true`. */
        preventDefault(): void;
        /** This is not used in Node.js and is provided purely for completeness. */
        returnValue: boolean;
        /** Alias for event.target. */
        readonly srcElement: EventTarget | null;
        /** Stops the invocation of event listeners after the current one completes. */
        stopImmediatePropagation(): void;
        /** This is not used in Node.js and is provided purely for completeness. */
        stopPropagation(): void;
        /** The `EventTarget` dispatching the event */
        readonly target: EventTarget | null;
        /** The millisecond timestamp when the Event object was created. */
        readonly timeStamp: number;
        /** Returns the type of event, e.g. "click", "hashchange", or "submit". */
        readonly type: string;
    };

// See comment above explaining conditional type
type __EventTarget = typeof globalThis extends { onmessage: any; EventTarget: any } ? {}
    : {
        /**
         * Adds a new handler for the `type` event. Any given `listener` is added only once per `type` and per `capture` option value.
         *
         * If the `once` option is true, the `listener` is removed after the next time a `type` event is dispatched.
         *
         * The `capture` option is not used by Node.js in any functional way other than tracking registered event listeners per the `EventTarget` specification.
         * Specifically, the `capture` option is used as part of the key when registering a `listener`.
         * Any individual `listener` may be added once with `capture = false`, and once with `capture = true`.
         */
        addEventListener(
            type: string,
            listener: EventListener | EventListenerObject,
            options?: AddEventListenerOptions | boolean,
        ): void;
        /** Dispatches a synthetic event event to target and returns true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise. */
        dispatchEvent(event: Event): boolean;
        /** Removes the event listener in target's event listener list with the same type, callback, and options. */
        removeEventListener(
            type: string,
            listener: EventListener | EventListenerObject,
            options?: EventListenerOptions | boolean,
        ): void;
    };

interface EventInit {
    bubbles?: boolean;
    cancelable?: boolean;
    composed?: boolean;
}

interface EventListenerOptions {
    /** Not directly used by Node.js. Added for API completeness. Default: `false`. */
    capture?: boolean;
}

interface AddEventListenerOptions extends EventListenerOptions {
    /** When `true`, the listener is automatically removed when it is first invoked. Default: `false`. */
    once?: boolean;
    /** When `true`, serves as a hint that the listener will not call the `Event` object's `preventDefault()` method. Default: false. */
    passive?: boolean;
    /** The listener will be removed when the given AbortSignal object's `abort()` method is called. */
    signal?: AbortSignal;
}

interface EventListener {
    (evt: Event): void;
}

interface EventListenerObject {
    handleEvent(object: Event): void;
}

import {} from "events"; // Make this an ambient declaration
declare global {
    /** An event which takes place in the DOM. */
    interface Event extends __Event {}
    var Event: typeof globalThis extends { onmessage: any; Event: infer T } ? T
        : {
            prototype: __Event;
            new(type: string, eventInitDict?: EventInit): __Event;
        };

    /**
     * EventTarget is a DOM interface implemented by objects that can
     * receive events and may have listeners for them.
     */
    interface EventTarget extends __EventTarget {}
    var EventTarget: typeof globalThis extends { onmessage: any; EventTarget: infer T } ? T
        : {
            prototype: __EventTarget;
            new(): __EventTarget;
        };
}
/**
 * **This module is pending deprecation.** Once a replacement API has been
 * finalized, this module will be fully deprecated. Most developers should
 * **not** have cause to use this module. Users who absolutely must have
 * the functionality that domains provide may rely on it for the time being
 * but should expect to have to migrate to a different solution
 * in the future.
 *
 * Domains provide a way to handle multiple different IO operations as a
 * single group. If any of the event emitters or callbacks registered to a
 * domain emit an `'error'` event, or throw an error, then the domain object
 * will be notified, rather than losing the context of the error in the `process.on('uncaughtException')` handler, or causing the program to
 * exit immediately with an error code.
 * @deprecated Since v1.4.2 - Deprecated
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/domain.js)
 */
declare module "domain" {
    import EventEmitter = require("node:events");
    /**
     * The `Domain` class encapsulates the functionality of routing errors and
     * uncaught exceptions to the active `Domain` object.
     *
     * To handle the errors that it catches, listen to its `'error'` event.
     */
    class Domain extends EventEmitter {
        /**
         * An array of timers and event emitters that have been explicitly added
         * to the domain.
         */
        members: Array<EventEmitter | NodeJS.Timer>;
        /**
         * The `enter()` method is plumbing used by the `run()`, `bind()`, and `intercept()` methods to set the active domain. It sets `domain.active` and `process.domain` to the domain, and implicitly
         * pushes the domain onto the domain
         * stack managed by the domain module (see {@link exit} for details on the
         * domain stack). The call to `enter()` delimits the beginning of a chain of
         * asynchronous calls and I/O operations bound to a domain.
         *
         * Calling `enter()` changes only the active domain, and does not alter the domain
         * itself. `enter()` and `exit()` can be called an arbitrary number of times on a
         * single domain.
         */
        enter(): void;
        /**
         * The `exit()` method exits the current domain, popping it off the domain stack.
         * Any time execution is going to switch to the context of a different chain of
         * asynchronous calls, it's important to ensure that the current domain is exited.
         * The call to `exit()` delimits either the end of or an interruption to the chain
         * of asynchronous calls and I/O operations bound to a domain.
         *
         * If there are multiple, nested domains bound to the current execution context, `exit()` will exit any domains nested within this domain.
         *
         * Calling `exit()` changes only the active domain, and does not alter the domain
         * itself. `enter()` and `exit()` can be called an arbitrary number of times on a
         * single domain.
         */
        exit(): void;
        /**
         * Run the supplied function in the context of the domain, implicitly
         * binding all event emitters, timers, and low-level requests that are
         * created in that context. Optionally, arguments can be passed to
         * the function.
         *
         * This is the most basic way to use a domain.
         *
         * ```js
         * const domain = require('node:domain');
         * const fs = require('node:fs');
         * const d = domain.create();
         * d.on('error', (er) => {
         *   console.error('Caught error!', er);
         * });
         * d.run(() => {
         *   process.nextTick(() => {
         *     setTimeout(() => { // Simulating some various async stuff
         *       fs.open('non-existent file', 'r', (er, fd) => {
         *         if (er) throw er;
         *         // proceed...
         *       });
         *     }, 100);
         *   });
         * });
         * ```
         *
         * In this example, the `d.on('error')` handler will be triggered, rather
         * than crashing the program.
         */
        run<T>(fn: (...args: any[]) => T, ...args: any[]): T;
        /**
         * Explicitly adds an emitter to the domain. If any event handlers called by
         * the emitter throw an error, or if the emitter emits an `'error'` event, it
         * will be routed to the domain's `'error'` event, just like with implicit
         * binding.
         *
         * This also works with timers that are returned from `setInterval()` and `setTimeout()`. If their callback function throws, it will be caught by
         * the domain `'error'` handler.
         *
         * If the Timer or `EventEmitter` was already bound to a domain, it is removed
         * from that one, and bound to this one instead.
         * @param emitter emitter or timer to be added to the domain
         */
        add(emitter: EventEmitter | NodeJS.Timer): void;
        /**
         * The opposite of {@link add}. Removes domain handling from the
         * specified emitter.
         * @param emitter emitter or timer to be removed from the domain
         */
        remove(emitter: EventEmitter | NodeJS.Timer): void;
        /**
         * The returned function will be a wrapper around the supplied callback
         * function. When the returned function is called, any errors that are
         * thrown will be routed to the domain's `'error'` event.
         *
         * ```js
         * const d = domain.create();
         *
         * function readSomeFile(filename, cb) {
         *   fs.readFile(filename, 'utf8', d.bind((er, data) => {
         *     // If this throws, it will also be passed to the domain.
         *     return cb(er, data ? JSON.parse(data) : null);
         *   }));
         * }
         *
         * d.on('error', (er) => {
         *   // An error occurred somewhere. If we throw it now, it will crash the program
         *   // with the normal line number and stack message.
         * });
         * ```
         * @param callback The callback function
         * @return The bound function
         */
        bind<T extends Function>(callback: T): T;
        /**
         * This method is almost identical to {@link bind}. However, in
         * addition to catching thrown errors, it will also intercept `Error` objects sent as the first argument to the function.
         *
         * In this way, the common `if (err) return callback(err);` pattern can be replaced
         * with a single error handler in a single place.
         *
         * ```js
         * const d = domain.create();
         *
         * function readSomeFile(filename, cb) {
         *   fs.readFile(filename, 'utf8', d.intercept((data) => {
         *     // Note, the first argument is never passed to the
         *     // callback since it is assumed to be the 'Error' argument
         *     // and thus intercepted by the domain.
         *
         *     // If this throws, it will also be passed to the domain
         *     // so the error-handling logic can be moved to the 'error'
         *     // event on the domain instead of being repeated throughout
         *     // the program.
         *     return cb(null, JSON.parse(data));
         *   }));
         * }
         *
         * d.on('error', (er) => {
         *   // An error occurred somewhere. If we throw it now, it will crash the program
         *   // with the normal line number and stack message.
         * });
         * ```
         * @param callback The callback function
         * @return The intercepted function
         */
        intercept<T extends Function>(callback: T): T;
    }
    function create(): Domain;
}
declare module "node:domain" {
    export * from "domain";
}
/**
 * Much of the Node.js core API is built around an idiomatic asynchronous
 * event-driven architecture in which certain kinds of objects (called "emitters")
 * emit named events that cause `Function` objects ("listeners") to be called.
 *
 * For instance: a `net.Server` object emits an event each time a peer
 * connects to it; a `fs.ReadStream` emits an event when the file is opened;
 * a `stream` emits an event whenever data is available to be read.
 *
 * All objects that emit events are instances of the `EventEmitter` class. These
 * objects expose an `eventEmitter.on()` function that allows one or more
 * functions to be attached to named events emitted by the object. Typically,
 * event names are camel-cased strings but any valid JavaScript property key
 * can be used.
 *
 * When the `EventEmitter` object emits an event, all of the functions attached
 * to that specific event are called _synchronously_. Any values returned by the
 * called listeners are _ignored_ and discarded.
 *
 * The following example shows a simple `EventEmitter` instance with a single
 * listener. The `eventEmitter.on()` method is used to register listeners, while
 * the `eventEmitter.emit()` method is used to trigger the event.
 *
 * ```js
 * import { EventEmitter } from 'node:events';
 *
 * class MyEmitter extends EventEmitter {}
 *
 * const myEmitter = new MyEmitter();
 * myEmitter.on('event', () => {
 *   console.log('an event occurred!');
 * });
 * myEmitter.emit('event');
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/events.js)
 */
declare module "events" {
    import { AsyncResource, AsyncResourceOptions } from "node:async_hooks";
    // NOTE: This class is in the docs but is **not actually exported** by Node.
    // If https://github.com/nodejs/node/issues/39903 gets resolved and Node
    // actually starts exporting the class, uncomment below.
    // import { EventListener, EventListenerObject } from '__dom-events';
    // /** The NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API. */
    // interface NodeEventTarget extends EventTarget {
    //     /**
    //      * Node.js-specific extension to the `EventTarget` class that emulates the equivalent `EventEmitter` API.
    //      * The only difference between `addListener()` and `addEventListener()` is that addListener() will return a reference to the EventTarget.
    //      */
    //     addListener(type: string, listener: EventListener | EventListenerObject, options?: { once: boolean }): this;
    //     /** Node.js-specific extension to the `EventTarget` class that returns an array of event `type` names for which event listeners are registered. */
    //     eventNames(): string[];
    //     /** Node.js-specific extension to the `EventTarget` class that returns the number of event listeners registered for the `type`. */
    //     listenerCount(type: string): number;
    //     /** Node.js-specific alias for `eventTarget.removeListener()`. */
    //     off(type: string, listener: EventListener | EventListenerObject): this;
    //     /** Node.js-specific alias for `eventTarget.addListener()`. */
    //     on(type: string, listener: EventListener | EventListenerObject, options?: { once: boolean }): this;
    //     /** Node.js-specific extension to the `EventTarget` class that adds a `once` listener for the given event `type`. This is equivalent to calling `on` with the `once` option set to `true`. */
    //     once(type: string, listener: EventListener | EventListenerObject): this;
    //     /**
    //      * Node.js-specific extension to the `EventTarget` class.
    //      * If `type` is specified, removes all registered listeners for `type`,
    //      * otherwise removes all registered listeners.
    //      */
    //     removeAllListeners(type: string): this;
    //     /**
    //      * Node.js-specific extension to the `EventTarget` class that removes the listener for the given `type`.
    //      * The only difference between `removeListener()` and `removeEventListener()` is that `removeListener()` will return a reference to the `EventTarget`.
    //      */
    //     removeListener(type: string, listener: EventListener | EventListenerObject): this;
    // }
    interface EventEmitterOptions {
        /**
         * Enables automatic capturing of promise rejection.
         */
        captureRejections?: boolean | undefined;
    }
    interface StaticEventEmitterOptions {
        /**
         * Can be used to cancel awaiting events.
         */
        signal?: AbortSignal | undefined;
    }
    interface StaticEventEmitterIteratorOptions extends StaticEventEmitterOptions {
        /**
         * Names of events that will end the iteration.
         */
        close?: string[] | undefined;
        /**
         * The high watermark. The emitter is paused every time the size of events being buffered is higher than it.
         * Supported only on emitters implementing `pause()` and `resume()` methods.
         * @default Number.MAX_SAFE_INTEGER
         */
        highWaterMark?: number | undefined;
        /**
         * The low watermark. The emitter is resumed every time the size of events being buffered is lower than it.
         * Supported only on emitters implementing `pause()` and `resume()` methods.
         * @default 1
         */
        lowWaterMark?: number | undefined;
    }
    interface EventEmitter<T extends EventMap<T> = DefaultEventMap> extends NodeJS.EventEmitter<T> {}
    type EventMap<T> = Record<keyof T, any[]> | DefaultEventMap;
    type DefaultEventMap = [never];
    type AnyRest = [...args: any[]];
    type Args<K, T> = T extends DefaultEventMap ? AnyRest : (
        K extends keyof T ? T[K] : never
    );
    type Key<K, T> = T extends DefaultEventMap ? string | symbol : K | keyof T;
    type Key2<K, T> = T extends DefaultEventMap ? string | symbol : K & keyof T;
    type Listener<K, T, F> = T extends DefaultEventMap ? F : (
        K extends keyof T ? (
                T[K] extends unknown[] ? (...args: T[K]) => void : never
            )
            : never
    );
    type Listener1<K, T> = Listener<K, T, (...args: any[]) => void>;
    type Listener2<K, T> = Listener<K, T, Function>;

    /**
     * The `EventEmitter` class is defined and exposed by the `node:events` module:
     *
     * ```js
     * import { EventEmitter } from 'node:events';
     * ```
     *
     * All `EventEmitter`s emit the event `'newListener'` when new listeners are
     * added and `'removeListener'` when existing listeners are removed.
     *
     * It supports the following option:
     * @since v0.1.26
     */
    class EventEmitter<T extends EventMap<T> = DefaultEventMap> {
        constructor(options?: EventEmitterOptions);

        [EventEmitter.captureRejectionSymbol]?<K>(error: Error, event: Key<K, T>, ...args: Args<K, T>): void;

        /**
         * Creates a `Promise` that is fulfilled when the `EventEmitter` emits the given
         * event or that is rejected if the `EventEmitter` emits `'error'` while waiting.
         * The `Promise` will resolve with an array of all the arguments emitted to the
         * given event.
         *
         * This method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event
         * semantics and does not listen to the `'error'` event.
         *
         * ```js
         * import { once, EventEmitter } from 'node:events';
         * import process from 'node:process';
         *
         * const ee = new EventEmitter();
         *
         * process.nextTick(() => {
         *   ee.emit('myevent', 42);
         * });
         *
         * const [value] = await once(ee, 'myevent');
         * console.log(value);
         *
         * const err = new Error('kaboom');
         * process.nextTick(() => {
         *   ee.emit('error', err);
         * });
         *
         * try {
         *   await once(ee, 'myevent');
         * } catch (err) {
         *   console.error('error happened', err);
         * }
         * ```
         *
         * The special handling of the `'error'` event is only used when `events.once()` is used to wait for another event. If `events.once()` is used to wait for the
         * '`error'` event itself, then it is treated as any other kind of event without
         * special handling:
         *
         * ```js
         * import { EventEmitter, once } from 'node:events';
         *
         * const ee = new EventEmitter();
         *
         * once(ee, 'error')
         *   .then(([err]) => console.log('ok', err.message))
         *   .catch((err) => console.error('error', err.message));
         *
         * ee.emit('error', new Error('boom'));
         *
         * // Prints: ok boom
         * ```
         *
         * An `AbortSignal` can be used to cancel waiting for the event:
         *
         * ```js
         * import { EventEmitter, once } from 'node:events';
         *
         * const ee = new EventEmitter();
         * const ac = new AbortController();
         *
         * async function foo(emitter, event, signal) {
         *   try {
         *     await once(emitter, event, { signal });
         *     console.log('event emitted!');
         *   } catch (error) {
         *     if (error.name === 'AbortError') {
         *       console.error('Waiting for the event was canceled!');
         *     } else {
         *       console.error('There was an error', error.message);
         *     }
         *   }
         * }
         *
         * foo(ee, 'foo', ac.signal);
         * ac.abort(); // Abort waiting for the event
         * ee.emit('foo'); // Prints: Waiting for the event was canceled!
         * ```
         * @since v11.13.0, v10.16.0
         */
        static once(
            emitter: NodeJS.EventEmitter,
            eventName: string | symbol,
            options?: StaticEventEmitterOptions,
        ): Promise<any[]>;
        static once(emitter: EventTarget, eventName: string, options?: StaticEventEmitterOptions): Promise<any[]>;
        /**
         * ```js
         * import { on, EventEmitter } from 'node:events';
         * import process from 'node:process';
         *
         * const ee = new EventEmitter();
         *
         * // Emit later on
         * process.nextTick(() => {
         *   ee.emit('foo', 'bar');
         *   ee.emit('foo', 42);
         * });
         *
         * for await (const event of on(ee, 'foo')) {
         *   // The execution of this inner block is synchronous and it
         *   // processes one event at a time (even with await). Do not use
         *   // if concurrent execution is required.
         *   console.log(event); // prints ['bar'] [42]
         * }
         * // Unreachable here
         * ```
         *
         * Returns an `AsyncIterator` that iterates `eventName` events. It will throw
         * if the `EventEmitter` emits `'error'`. It removes all listeners when
         * exiting the loop. The `value` returned by each iteration is an array
         * composed of the emitted event arguments.
         *
         * An `AbortSignal` can be used to cancel waiting on events:
         *
         * ```js
         * import { on, EventEmitter } from 'node:events';
         * import process from 'node:process';
         *
         * const ac = new AbortController();
         *
         * (async () => {
         *   const ee = new EventEmitter();
         *
         *   // Emit later on
         *   process.nextTick(() => {
         *     ee.emit('foo', 'bar');
         *     ee.emit('foo', 42);
         *   });
         *
         *   for await (const event of on(ee, 'foo', { signal: ac.signal })) {
         *     // The execution of this inner block is synchronous and it
         *     // processes one event at a time (even with await). Do not use
         *     // if concurrent execution is required.
         *     console.log(event); // prints ['bar'] [42]
         *   }
         *   // Unreachable here
         * })();
         *
         * process.nextTick(() => ac.abort());
         * ```
         *
         * Use the `close` option to specify an array of event names that will end the iteration:
         *
         * ```js
         * import { on, EventEmitter } from 'node:events';
         * import process from 'node:process';
         *
         * const ee = new EventEmitter();
         *
         * // Emit later on
         * process.nextTick(() => {
         *   ee.emit('foo', 'bar');
         *   ee.emit('foo', 42);
         *   ee.emit('close');
         * });
         *
         * for await (const event of on(ee, 'foo', { close: ['close'] })) {
         *   console.log(event); // prints ['bar'] [42]
         * }
         * // the loop will exit after 'close' is emitted
         * console.log('done'); // prints 'done'
         * ```
         * @since v13.6.0, v12.16.0
         * @return An `AsyncIterator` that iterates `eventName` events emitted by the `emitter`
         */
        static on(
            emitter: NodeJS.EventEmitter,
            eventName: string | symbol,
            options?: StaticEventEmitterIteratorOptions,
        ): AsyncIterableIterator<any[]>;
        static on(
            emitter: EventTarget,
            eventName: string,
            options?: StaticEventEmitterIteratorOptions,
        ): AsyncIterableIterator<any[]>;
        /**
         * A class method that returns the number of listeners for the given `eventName` registered on the given `emitter`.
         *
         * ```js
         * import { EventEmitter, listenerCount } from 'node:events';
         *
         * const myEmitter = new EventEmitter();
         * myEmitter.on('event', () => {});
         * myEmitter.on('event', () => {});
         * console.log(listenerCount(myEmitter, 'event'));
         * // Prints: 2
         * ```
         * @since v0.9.12
         * @deprecated Since v3.2.0 - Use `listenerCount` instead.
         * @param emitter The emitter to query
         * @param eventName The event name
         */
        static listenerCount(emitter: NodeJS.EventEmitter, eventName: string | symbol): number;
        /**
         * Returns a copy of the array of listeners for the event named `eventName`.
         *
         * For `EventEmitter`s this behaves exactly the same as calling `.listeners` on
         * the emitter.
         *
         * For `EventTarget`s this is the only way to get the event listeners for the
         * event target. This is useful for debugging and diagnostic purposes.
         *
         * ```js
         * import { getEventListeners, EventEmitter } from 'node:events';
         *
         * {
         *   const ee = new EventEmitter();
         *   const listener = () => console.log('Events are fun');
         *   ee.on('foo', listener);
         *   console.log(getEventListeners(ee, 'foo')); // [ [Function: listener] ]
         * }
         * {
         *   const et = new EventTarget();
         *   const listener = () => console.log('Events are fun');
         *   et.addEventListener('foo', listener);
         *   console.log(getEventListeners(et, 'foo')); // [ [Function: listener] ]
         * }
         * ```
         * @since v15.2.0, v14.17.0
         */
        static getEventListeners(emitter: EventTarget | NodeJS.EventEmitter, name: string | symbol): Function[];
        /**
         * Returns the currently set max amount of listeners.
         *
         * For `EventEmitter`s this behaves exactly the same as calling `.getMaxListeners` on
         * the emitter.
         *
         * For `EventTarget`s this is the only way to get the max event listeners for the
         * event target. If the number of event handlers on a single EventTarget exceeds
         * the max set, the EventTarget will print a warning.
         *
         * ```js
         * import { getMaxListeners, setMaxListeners, EventEmitter } from 'node:events';
         *
         * {
         *   const ee = new EventEmitter();
         *   console.log(getMaxListeners(ee)); // 10
         *   setMaxListeners(11, ee);
         *   console.log(getMaxListeners(ee)); // 11
         * }
         * {
         *   const et = new EventTarget();
         *   console.log(getMaxListeners(et)); // 10
         *   setMaxListeners(11, et);
         *   console.log(getMaxListeners(et)); // 11
         * }
         * ```
         * @since v19.9.0
         */
        static getMaxListeners(emitter: EventTarget | NodeJS.EventEmitter): number;
        /**
         * ```js
         * import { setMaxListeners, EventEmitter } from 'node:events';
         *
         * const target = new EventTarget();
         * const emitter = new EventEmitter();
         *
         * setMaxListeners(5, target, emitter);
         * ```
         * @since v15.4.0
         * @param n A non-negative number. The maximum number of listeners per `EventTarget` event.
         * @param eventsTargets Zero or more {EventTarget} or {EventEmitter} instances. If none are specified, `n` is set as the default max for all newly created {EventTarget} and {EventEmitter}
         * objects.
         */
        static setMaxListeners(n?: number, ...eventTargets: Array<EventTarget | NodeJS.EventEmitter>): void;
        /**
         * Listens once to the `abort` event on the provided `signal`.
         *
         * Listening to the `abort` event on abort signals is unsafe and may
         * lead to resource leaks since another third party with the signal can
         * call `e.stopImmediatePropagation()`. Unfortunately Node.js cannot change
         * this since it would violate the web standard. Additionally, the original
         * API makes it easy to forget to remove listeners.
         *
         * This API allows safely using `AbortSignal`s in Node.js APIs by solving these
         * two issues by listening to the event such that `stopImmediatePropagation` does
         * not prevent the listener from running.
         *
         * Returns a disposable so that it may be unsubscribed from more easily.
         *
         * ```js
         * import { addAbortListener } from 'node:events';
         *
         * function example(signal) {
         *   let disposable;
         *   try {
         *     signal.addEventListener('abort', (e) => e.stopImmediatePropagation());
         *     disposable = addAbortListener(signal, (e) => {
         *       // Do something when signal is aborted.
         *     });
         *   } finally {
         *     disposable?.[Symbol.dispose]();
         *   }
         * }
         * ```
         * @since v20.5.0
         * @experimental
         * @return Disposable that removes the `abort` listener.
         */
        static addAbortListener(signal: AbortSignal, resource: (event: Event) => void): Disposable;
        /**
         * This symbol shall be used to install a listener for only monitoring `'error'` events. Listeners installed using this symbol are called before the regular `'error'` listeners are called.
         *
         * Installing a listener using this symbol does not change the behavior once an `'error'` event is emitted. Therefore, the process will still crash if no
         * regular `'error'` listener is installed.
         * @since v13.6.0, v12.17.0
         */
        static readonly errorMonitor: unique symbol;
        /**
         * Value: `Symbol.for('nodejs.rejection')`
         *
         * See how to write a custom `rejection handler`.
         * @since v13.4.0, v12.16.0
         */
        static readonly captureRejectionSymbol: unique symbol;
        /**
         * Value: [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)
         *
         * Change the default `captureRejections` option on all new `EventEmitter` objects.
         * @since v13.4.0, v12.16.0
         */
        static captureRejections: boolean;
        /**
         * By default, a maximum of `10` listeners can be registered for any single
         * event. This limit can be changed for individual `EventEmitter` instances
         * using the `emitter.setMaxListeners(n)` method. To change the default
         * for _all_`EventEmitter` instances, the `events.defaultMaxListeners` property
         * can be used. If this value is not a positive number, a `RangeError` is thrown.
         *
         * Take caution when setting the `events.defaultMaxListeners` because the
         * change affects _all_ `EventEmitter` instances, including those created before
         * the change is made. However, calling `emitter.setMaxListeners(n)` still has
         * precedence over `events.defaultMaxListeners`.
         *
         * This is not a hard limit. The `EventEmitter` instance will allow
         * more listeners to be added but will output a trace warning to stderr indicating
         * that a "possible EventEmitter memory leak" has been detected. For any single
         * `EventEmitter`, the `emitter.getMaxListeners()` and `emitter.setMaxListeners()` methods can be used to
         * temporarily avoid this warning:
         *
         * ```js
         * import { EventEmitter } from 'node:events';
         * const emitter = new EventEmitter();
         * emitter.setMaxListeners(emitter.getMaxListeners() + 1);
         * emitter.once('event', () => {
         *   // do stuff
         *   emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));
         * });
         * ```
         *
         * The `--trace-warnings` command-line flag can be used to display the
         * stack trace for such warnings.
         *
         * The emitted warning can be inspected with `process.on('warning')` and will
         * have the additional `emitter`, `type`, and `count` properties, referring to
         * the event emitter instance, the event's name and the number of attached
         * listeners, respectively.
         * Its `name` property is set to `'MaxListenersExceededWarning'`.
         * @since v0.11.2
         */
        static defaultMaxListeners: number;
    }
    import internal = require("node:events");
    namespace EventEmitter {
        // Should just be `export { EventEmitter }`, but that doesn't work in TypeScript 3.4
        export { internal as EventEmitter };
        export interface Abortable {
            /**
             * When provided the corresponding `AbortController` can be used to cancel an asynchronous action.
             */
            signal?: AbortSignal | undefined;
        }

        export interface EventEmitterReferencingAsyncResource extends AsyncResource {
            readonly eventEmitter: EventEmitterAsyncResource;
        }

        export interface EventEmitterAsyncResourceOptions extends AsyncResourceOptions, EventEmitterOptions {
            /**
             * The type of async event, this is required when instantiating `EventEmitterAsyncResource`
             * directly rather than as a child class.
             * @default new.target.name if instantiated as a child class.
             */
            name?: string;
        }

        /**
         * Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that
         * require manual async tracking. Specifically, all events emitted by instances
         * of `events.EventEmitterAsyncResource` will run within its `async context`.
         *
         * ```js
         * import { EventEmitterAsyncResource, EventEmitter } from 'node:events';
         * import { notStrictEqual, strictEqual } from 'node:assert';
         * import { executionAsyncId, triggerAsyncId } from 'node:async_hooks';
         *
         * // Async tracking tooling will identify this as 'Q'.
         * const ee1 = new EventEmitterAsyncResource({ name: 'Q' });
         *
         * // 'foo' listeners will run in the EventEmitters async context.
         * ee1.on('foo', () => {
         *   strictEqual(executionAsyncId(), ee1.asyncId);
         *   strictEqual(triggerAsyncId(), ee1.triggerAsyncId);
         * });
         *
         * const ee2 = new EventEmitter();
         *
         * // 'foo' listeners on ordinary EventEmitters that do not track async
         * // context, however, run in the same async context as the emit().
         * ee2.on('foo', () => {
         *   notStrictEqual(executionAsyncId(), ee2.asyncId);
         *   notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);
         * });
         *
         * Promise.resolve().then(() => {
         *   ee1.emit('foo');
         *   ee2.emit('foo');
         * });
         * ```
         *
         * The `EventEmitterAsyncResource` class has the same methods and takes the
         * same options as `EventEmitter` and `AsyncResource` themselves.
         * @since v17.4.0, v16.14.0
         */
        export class EventEmitterAsyncResource extends EventEmitter {
            /**
             * @param options Only optional in child class.
             */
            constructor(options?: EventEmitterAsyncResourceOptions);
            /**
             * Call all `destroy` hooks. This should only ever be called once. An error will
             * be thrown if it is called more than once. This **must** be manually called. If
             * the resource is left to be collected by the GC then the `destroy` hooks will
             * never be called.
             */
            emitDestroy(): void;
            /**
             * The unique `asyncId` assigned to the resource.
             */
            readonly asyncId: number;
            /**
             * The same triggerAsyncId that is passed to the AsyncResource constructor.
             */
            readonly triggerAsyncId: number;
            /**
             * The returned `AsyncResource` object has an additional `eventEmitter` property
             * that provides a reference to this `EventEmitterAsyncResource`.
             */
            readonly asyncResource: EventEmitterReferencingAsyncResource;
        }
    }
    global {
        namespace NodeJS {
            interface EventEmitter<T extends EventMap<T> = DefaultEventMap> {
                [EventEmitter.captureRejectionSymbol]?<K>(error: Error, event: Key<K, T>, ...args: Args<K, T>): void;
                /**
                 * Alias for `emitter.on(eventName, listener)`.
                 * @since v0.1.26
                 */
                addListener<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                /**
                 * Adds the `listener` function to the end of the listeners array for the event
                 * named `eventName`. No checks are made to see if the `listener` has already
                 * been added. Multiple calls passing the same combination of `eventName` and
                 * `listener` will result in the `listener` being added, and called, multiple times.
                 *
                 * ```js
                 * server.on('connection', (stream) => {
                 *   console.log('someone connected!');
                 * });
                 * ```
                 *
                 * Returns a reference to the `EventEmitter`, so that calls can be chained.
                 *
                 * By default, event listeners are invoked in the order they are added. The `emitter.prependListener()` method can be used as an alternative to add the
                 * event listener to the beginning of the listeners array.
                 *
                 * ```js
                 * import { EventEmitter } from 'node:events';
                 * const myEE = new EventEmitter();
                 * myEE.on('foo', () => console.log('a'));
                 * myEE.prependListener('foo', () => console.log('b'));
                 * myEE.emit('foo');
                 * // Prints:
                 * //   b
                 * //   a
                 * ```
                 * @since v0.1.101
                 * @param eventName The name of the event.
                 * @param listener The callback function
                 */
                on<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                /**
                 * Adds a **one-time** `listener` function for the event named `eventName`. The
                 * next time `eventName` is triggered, this listener is removed and then invoked.
                 *
                 * ```js
                 * server.once('connection', (stream) => {
                 *   console.log('Ah, we have our first user!');
                 * });
                 * ```
                 *
                 * Returns a reference to the `EventEmitter`, so that calls can be chained.
                 *
                 * By default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the
                 * event listener to the beginning of the listeners array.
                 *
                 * ```js
                 * import { EventEmitter } from 'node:events';
                 * const myEE = new EventEmitter();
                 * myEE.once('foo', () => console.log('a'));
                 * myEE.prependOnceListener('foo', () => console.log('b'));
                 * myEE.emit('foo');
                 * // Prints:
                 * //   b
                 * //   a
                 * ```
                 * @since v0.3.0
                 * @param eventName The name of the event.
                 * @param listener The callback function
                 */
                once<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                /**
                 * Removes the specified `listener` from the listener array for the event named `eventName`.
                 *
                 * ```js
                 * const callback = (stream) => {
                 *   console.log('someone connected!');
                 * };
                 * server.on('connection', callback);
                 * // ...
                 * server.removeListener('connection', callback);
                 * ```
                 *
                 * `removeListener()` will remove, at most, one instance of a listener from the
                 * listener array. If any single listener has been added multiple times to the
                 * listener array for the specified `eventName`, then `removeListener()` must be
                 * called multiple times to remove each instance.
                 *
                 * Once an event is emitted, all listeners attached to it at the
                 * time of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution
                 * will not remove them from`emit()` in progress. Subsequent events behave as expected.
                 *
                 * ```js
                 * import { EventEmitter } from 'node:events';
                 * class MyEmitter extends EventEmitter {}
                 * const myEmitter = new MyEmitter();
                 *
                 * const callbackA = () => {
                 *   console.log('A');
                 *   myEmitter.removeListener('event', callbackB);
                 * };
                 *
                 * const callbackB = () => {
                 *   console.log('B');
                 * };
                 *
                 * myEmitter.on('event', callbackA);
                 *
                 * myEmitter.on('event', callbackB);
                 *
                 * // callbackA removes listener callbackB but it will still be called.
                 * // Internal listener array at time of emit [callbackA, callbackB]
                 * myEmitter.emit('event');
                 * // Prints:
                 * //   A
                 * //   B
                 *
                 * // callbackB is now removed.
                 * // Internal listener array [callbackA]
                 * myEmitter.emit('event');
                 * // Prints:
                 * //   A
                 * ```
                 *
                 * Because listeners are managed using an internal array, calling this will
                 * change the position indices of any listener registered _after_ the listener
                 * being removed. This will not impact the order in which listeners are called,
                 * but it means that any copies of the listener array as returned by
                 * the `emitter.listeners()` method will need to be recreated.
                 *
                 * When a single function has been added as a handler multiple times for a single
                 * event (as in the example below), `removeListener()` will remove the most
                 * recently added instance. In the example the `once('ping')` listener is removed:
                 *
                 * ```js
                 * import { EventEmitter } from 'node:events';
                 * const ee = new EventEmitter();
                 *
                 * function pong() {
                 *   console.log('pong');
                 * }
                 *
                 * ee.on('ping', pong);
                 * ee.once('ping', pong);
                 * ee.removeListener('ping', pong);
                 *
                 * ee.emit('ping');
                 * ee.emit('ping');
                 * ```
                 *
                 * Returns a reference to the `EventEmitter`, so that calls can be chained.
                 * @since v0.1.26
                 */
                removeListener<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                /**
                 * Alias for `emitter.removeListener()`.
                 * @since v10.0.0
                 */
                off<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                /**
                 * Removes all listeners, or those of the specified `eventName`.
                 *
                 * It is bad practice to remove listeners added elsewhere in the code,
                 * particularly when the `EventEmitter` instance was created by some other
                 * component or module (e.g. sockets or file streams).
                 *
                 * Returns a reference to the `EventEmitter`, so that calls can be chained.
                 * @since v0.1.26
                 */
                removeAllListeners(eventName?: Key<unknown, T>): this;
                /**
                 * By default `EventEmitter`s will print a warning if more than `10` listeners are
                 * added for a particular event. This is a useful default that helps finding
                 * memory leaks. The `emitter.setMaxListeners()` method allows the limit to be
                 * modified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.
                 *
                 * Returns a reference to the `EventEmitter`, so that calls can be chained.
                 * @since v0.3.5
                 */
                setMaxListeners(n: number): this;
                /**
                 * Returns the current max listener value for the `EventEmitter` which is either
                 * set by `emitter.setMaxListeners(n)` or defaults to {@link defaultMaxListeners}.
                 * @since v1.0.0
                 */
                getMaxListeners(): number;
                /**
                 * Returns a copy of the array of listeners for the event named `eventName`.
                 *
                 * ```js
                 * server.on('connection', (stream) => {
                 *   console.log('someone connected!');
                 * });
                 * console.log(util.inspect(server.listeners('connection')));
                 * // Prints: [ [Function] ]
                 * ```
                 * @since v0.1.26
                 */
                listeners<K>(eventName: Key<K, T>): Array<Listener2<K, T>>;
                /**
                 * Returns a copy of the array of listeners for the event named `eventName`,
                 * including any wrappers (such as those created by `.once()`).
                 *
                 * ```js
                 * import { EventEmitter } from 'node:events';
                 * const emitter = new EventEmitter();
                 * emitter.once('log', () => console.log('log once'));
                 *
                 * // Returns a new Array with a function `onceWrapper` which has a property
                 * // `listener` which contains the original listener bound above
                 * const listeners = emitter.rawListeners('log');
                 * const logFnWrapper = listeners[0];
                 *
                 * // Logs "log once" to the console and does not unbind the `once` event
                 * logFnWrapper.listener();
                 *
                 * // Logs "log once" to the console and removes the listener
                 * logFnWrapper();
                 *
                 * emitter.on('log', () => console.log('log persistently'));
                 * // Will return a new Array with a single function bound by `.on()` above
                 * const newListeners = emitter.rawListeners('log');
                 *
                 * // Logs "log persistently" twice
                 * newListeners[0]();
                 * emitter.emit('log');
                 * ```
                 * @since v9.4.0
                 */
                rawListeners<K>(eventName: Key<K, T>): Array<Listener2<K, T>>;
                /**
                 * Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments
                 * to each.
                 *
                 * Returns `true` if the event had listeners, `false` otherwise.
                 *
                 * ```js
                 * import { EventEmitter } from 'node:events';
                 * const myEmitter = new EventEmitter();
                 *
                 * // First listener
                 * myEmitter.on('event', function firstListener() {
                 *   console.log('Helloooo! first listener');
                 * });
                 * // Second listener
                 * myEmitter.on('event', function secondListener(arg1, arg2) {
                 *   console.log(`event with parameters ${arg1}, ${arg2} in second listener`);
                 * });
                 * // Third listener
                 * myEmitter.on('event', function thirdListener(...args) {
                 *   const parameters = args.join(', ');
                 *   console.log(`event with parameters ${parameters} in third listener`);
                 * });
                 *
                 * console.log(myEmitter.listeners('event'));
                 *
                 * myEmitter.emit('event', 1, 2, 3, 4, 5);
                 *
                 * // Prints:
                 * // [
                 * //   [Function: firstListener],
                 * //   [Function: secondListener],
                 * //   [Function: thirdListener]
                 * // ]
                 * // Helloooo! first listener
                 * // event with parameters 1, 2 in second listener
                 * // event with parameters 1, 2, 3, 4, 5 in third listener
                 * ```
                 * @since v0.1.26
                 */
                emit<K>(eventName: Key<K, T>, ...args: Args<K, T>): boolean;
                /**
                 * Returns the number of listeners listening for the event named `eventName`.
                 * If `listener` is provided, it will return how many times the listener is found
                 * in the list of the listeners of the event.
                 * @since v3.2.0
                 * @param eventName The name of the event being listened for
                 * @param listener The event handler function
                 */
                listenerCount<K>(eventName: Key<K, T>, listener?: Listener2<K, T>): number;
                /**
                 * Adds the `listener` function to the _beginning_ of the listeners array for the
                 * event named `eventName`. No checks are made to see if the `listener` has
                 * already been added. Multiple calls passing the same combination of `eventName`
                 * and `listener` will result in the `listener` being added, and called, multiple times.
                 *
                 * ```js
                 * server.prependListener('connection', (stream) => {
                 *   console.log('someone connected!');
                 * });
                 * ```
                 *
                 * Returns a reference to the `EventEmitter`, so that calls can be chained.
                 * @since v6.0.0
                 * @param eventName The name of the event.
                 * @param listener The callback function
                 */
                prependListener<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                /**
                 * Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this
                 * listener is removed, and then invoked.
                 *
                 * ```js
                 * server.prependOnceListener('connection', (stream) => {
                 *   console.log('Ah, we have our first user!');
                 * });
                 * ```
                 *
                 * Returns a reference to the `EventEmitter`, so that calls can be chained.
                 * @since v6.0.0
                 * @param eventName The name of the event.
                 * @param listener The callback function
                 */
                prependOnceListener<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                /**
                 * Returns an array listing the events for which the emitter has registered
                 * listeners. The values in the array are strings or `Symbol`s.
                 *
                 * ```js
                 * import { EventEmitter } from 'node:events';
                 *
                 * const myEE = new EventEmitter();
                 * myEE.on('foo', () => {});
                 * myEE.on('bar', () => {});
                 *
                 * const sym = Symbol('symbol');
                 * myEE.on(sym, () => {});
                 *
                 * console.log(myEE.eventNames());
                 * // Prints: [ 'foo', 'bar', Symbol(symbol) ]
                 * ```
                 * @since v6.0.0
                 */
                eventNames(): Array<(string | symbol) & Key2<unknown, T>>;
            }
        }
    }
    export = EventEmitter;
}
declare module "node:events" {
    import events = require("events");
    export = events;
}
/**
 * The `node:fs` module enables interacting with the file system in a
 * way modeled on standard POSIX functions.
 *
 * To use the promise-based APIs:
 *
 * ```js
 * import * as fs from 'node:fs/promises';
 * ```
 *
 * To use the callback and sync APIs:
 *
 * ```js
 * import * as fs from 'node:fs';
 * ```
 *
 * All file system operations have synchronous, callback, and promise-based
 * forms, and are accessible using both CommonJS syntax and ES6 Modules (ESM).
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/fs.js)
 */
declare module "fs" {
    import * as stream from "node:stream";
    import { Abortable, EventEmitter } from "node:events";
    import { URL } from "node:url";
    import * as promises from "node:fs/promises";
    export { promises };
    /**
     * Valid types for path values in "fs".
     */
    export type PathLike = string | Buffer | URL;
    export type PathOrFileDescriptor = PathLike | number;
    export type TimeLike = string | number | Date;
    export type NoParamCallback = (err: NodeJS.ErrnoException | null) => void;
    export type BufferEncodingOption =
        | "buffer"
        | {
            encoding: "buffer";
        };
    export interface ObjectEncodingOptions {
        encoding?: BufferEncoding | null | undefined;
    }
    export type EncodingOption = ObjectEncodingOptions | BufferEncoding | undefined | null;
    export type OpenMode = number | string;
    export type Mode = number | string;
    export interface StatsBase<T> {
        isFile(): boolean;
        isDirectory(): boolean;
        isBlockDevice(): boolean;
        isCharacterDevice(): boolean;
        isSymbolicLink(): boolean;
        isFIFO(): boolean;
        isSocket(): boolean;
        dev: T;
        ino: T;
        mode: T;
        nlink: T;
        uid: T;
        gid: T;
        rdev: T;
        size: T;
        blksize: T;
        blocks: T;
        atimeMs: T;
        mtimeMs: T;
        ctimeMs: T;
        birthtimeMs: T;
        atime: Date;
        mtime: Date;
        ctime: Date;
        birthtime: Date;
    }
    export interface Stats extends StatsBase<number> {}
    /**
     * A `fs.Stats` object provides information about a file.
     *
     * Objects returned from {@link stat}, {@link lstat}, {@link fstat}, and
     * their synchronous counterparts are of this type.
     * If `bigint` in the `options` passed to those methods is true, the numeric values
     * will be `bigint` instead of `number`, and the object will contain additional
     * nanosecond-precision properties suffixed with `Ns`. `Stat` objects are not to be created directly using the `new` keyword.
     *
     * ```console
     * Stats {
     *   dev: 2114,
     *   ino: 48064969,
     *   mode: 33188,
     *   nlink: 1,
     *   uid: 85,
     *   gid: 100,
     *   rdev: 0,
     *   size: 527,
     *   blksize: 4096,
     *   blocks: 8,
     *   atimeMs: 1318289051000.1,
     *   mtimeMs: 1318289051000.1,
     *   ctimeMs: 1318289051000.1,
     *   birthtimeMs: 1318289051000.1,
     *   atime: Mon, 10 Oct 2011 23:24:11 GMT,
     *   mtime: Mon, 10 Oct 2011 23:24:11 GMT,
     *   ctime: Mon, 10 Oct 2011 23:24:11 GMT,
     *   birthtime: Mon, 10 Oct 2011 23:24:11 GMT }
     * ```
     *
     * `bigint` version:
     *
     * ```console
     * BigIntStats {
     *   dev: 2114n,
     *   ino: 48064969n,
     *   mode: 33188n,
     *   nlink: 1n,
     *   uid: 85n,
     *   gid: 100n,
     *   rdev: 0n,
     *   size: 527n,
     *   blksize: 4096n,
     *   blocks: 8n,
     *   atimeMs: 1318289051000n,
     *   mtimeMs: 1318289051000n,
     *   ctimeMs: 1318289051000n,
     *   birthtimeMs: 1318289051000n,
     *   atimeNs: 1318289051000000000n,
     *   mtimeNs: 1318289051000000000n,
     *   ctimeNs: 1318289051000000000n,
     *   birthtimeNs: 1318289051000000000n,
     *   atime: Mon, 10 Oct 2011 23:24:11 GMT,
     *   mtime: Mon, 10 Oct 2011 23:24:11 GMT,
     *   ctime: Mon, 10 Oct 2011 23:24:11 GMT,
     *   birthtime: Mon, 10 Oct 2011 23:24:11 GMT }
     * ```
     * @since v0.1.21
     */
    export class Stats {
        private constructor();
    }
    export interface StatsFsBase<T> {
        /** Type of file system. */
        type: T;
        /**  Optimal transfer block size. */
        bsize: T;
        /**  Total data blocks in file system. */
        blocks: T;
        /** Free blocks in file system. */
        bfree: T;
        /** Available blocks for unprivileged users */
        bavail: T;
        /** Total file nodes in file system. */
        files: T;
        /** Free file nodes in file system. */
        ffree: T;
    }
    export interface StatsFs extends StatsFsBase<number> {}
    /**
     * Provides information about a mounted file system.
     *
     * Objects returned from {@link statfs} and its synchronous counterpart are of
     * this type. If `bigint` in the `options` passed to those methods is `true`, the
     * numeric values will be `bigint` instead of `number`.
     *
     * ```console
     * StatFs {
     *   type: 1397114950,
     *   bsize: 4096,
     *   blocks: 121938943,
     *   bfree: 61058895,
     *   bavail: 61058895,
     *   files: 999,
     *   ffree: 1000000
     * }
     * ```
     *
     * `bigint` version:
     *
     * ```console
     * StatFs {
     *   type: 1397114950n,
     *   bsize: 4096n,
     *   blocks: 121938943n,
     *   bfree: 61058895n,
     *   bavail: 61058895n,
     *   files: 999n,
     *   ffree: 1000000n
     * }
     * ```
     * @since v19.6.0, v18.15.0
     */
    export class StatsFs {}
    export interface BigIntStatsFs extends StatsFsBase<bigint> {}
    export interface StatFsOptions {
        bigint?: boolean | undefined;
    }
    /**
     * A representation of a directory entry, which can be a file or a subdirectory
     * within the directory, as returned by reading from an `fs.Dir`. The
     * directory entry is a combination of the file name and file type pairs.
     *
     * Additionally, when {@link readdir} or {@link readdirSync} is called with
     * the `withFileTypes` option set to `true`, the resulting array is filled with `fs.Dirent` objects, rather than strings or `Buffer` s.
     * @since v10.10.0
     */
    export class Dirent {
        /**
         * Returns `true` if the `fs.Dirent` object describes a regular file.
         * @since v10.10.0
         */
        isFile(): boolean;
        /**
         * Returns `true` if the `fs.Dirent` object describes a file system
         * directory.
         * @since v10.10.0
         */
        isDirectory(): boolean;
        /**
         * Returns `true` if the `fs.Dirent` object describes a block device.
         * @since v10.10.0
         */
        isBlockDevice(): boolean;
        /**
         * Returns `true` if the `fs.Dirent` object describes a character device.
         * @since v10.10.0
         */
        isCharacterDevice(): boolean;
        /**
         * Returns `true` if the `fs.Dirent` object describes a symbolic link.
         * @since v10.10.0
         */
        isSymbolicLink(): boolean;
        /**
         * Returns `true` if the `fs.Dirent` object describes a first-in-first-out
         * (FIFO) pipe.
         * @since v10.10.0
         */
        isFIFO(): boolean;
        /**
         * Returns `true` if the `fs.Dirent` object describes a socket.
         * @since v10.10.0
         */
        isSocket(): boolean;
        /**
         * The file name that this `fs.Dirent` object refers to. The type of this
         * value is determined by the `options.encoding` passed to {@link readdir} or {@link readdirSync}.
         * @since v10.10.0
         */
        name: string;
        /**
         * The base path that this `fs.Dirent` object refers to.
         * @since v20.12.0
         */
        parentPath: string;
        /**
         * Alias for `dirent.parentPath`.
         * @since v20.1.0
         * @deprecated Since v20.12.0
         */
        path: string;
    }
    /**
     * A class representing a directory stream.
     *
     * Created by {@link opendir}, {@link opendirSync}, or `fsPromises.opendir()`.
     *
     * ```js
     * import { opendir } from 'node:fs/promises';
     *
     * try {
     *   const dir = await opendir('./');
     *   for await (const dirent of dir)
     *     console.log(dirent.name);
     * } catch (err) {
     *   console.error(err);
     * }
     * ```
     *
     * When using the async iterator, the `fs.Dir` object will be automatically
     * closed after the iterator exits.
     * @since v12.12.0
     */
    export class Dir implements AsyncIterable<Dirent> {
        /**
         * The read-only path of this directory as was provided to {@link opendir},{@link opendirSync}, or `fsPromises.opendir()`.
         * @since v12.12.0
         */
        readonly path: string;
        /**
         * Asynchronously iterates over the directory via `readdir(3)` until all entries have been read.
         */
        [Symbol.asyncIterator](): AsyncIterableIterator<Dirent>;
        /**
         * Asynchronously close the directory's underlying resource handle.
         * Subsequent reads will result in errors.
         *
         * A promise is returned that will be fulfilled after the resource has been
         * closed.
         * @since v12.12.0
         */
        close(): Promise<void>;
        close(cb: NoParamCallback): void;
        /**
         * Synchronously close the directory's underlying resource handle.
         * Subsequent reads will result in errors.
         * @since v12.12.0
         */
        closeSync(): void;
        /**
         * Asynchronously read the next directory entry via [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) as an `fs.Dirent`.
         *
         * A promise is returned that will be fulfilled with an `fs.Dirent`, or `null` if there are no more directory entries to read.
         *
         * Directory entries returned by this function are in no particular order as
         * provided by the operating system's underlying directory mechanisms.
         * Entries added or removed while iterating over the directory might not be
         * included in the iteration results.
         * @since v12.12.0
         * @return containing {fs.Dirent|null}
         */
        read(): Promise<Dirent | null>;
        read(cb: (err: NodeJS.ErrnoException | null, dirEnt: Dirent | null) => void): void;
        /**
         * Synchronously read the next directory entry as an `fs.Dirent`. See the
         * POSIX [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) documentation for more detail.
         *
         * If there are no more directory entries to read, `null` will be returned.
         *
         * Directory entries returned by this function are in no particular order as
         * provided by the operating system's underlying directory mechanisms.
         * Entries added or removed while iterating over the directory might not be
         * included in the iteration results.
         * @since v12.12.0
         */
        readSync(): Dirent | null;
    }
    /**
     * Class: fs.StatWatcher
     * @since v14.3.0, v12.20.0
     * Extends `EventEmitter`
     * A successful call to {@link watchFile} method will return a new fs.StatWatcher object.
     */
    export interface StatWatcher extends EventEmitter {
        /**
         * When called, requests that the Node.js event loop _not_ exit so long as the `fs.StatWatcher` is active. Calling `watcher.ref()` multiple times will have
         * no effect.
         *
         * By default, all `fs.StatWatcher` objects are "ref'ed", making it normally
         * unnecessary to call `watcher.ref()` unless `watcher.unref()` had been
         * called previously.
         * @since v14.3.0, v12.20.0
         */
        ref(): this;
        /**
         * When called, the active `fs.StatWatcher` object will not require the Node.js
         * event loop to remain active. If there is no other activity keeping the
         * event loop running, the process may exit before the `fs.StatWatcher` object's
         * callback is invoked. Calling `watcher.unref()` multiple times will have
         * no effect.
         * @since v14.3.0, v12.20.0
         */
        unref(): this;
    }
    export interface FSWatcher extends EventEmitter {
        /**
         * Stop watching for changes on the given `fs.FSWatcher`. Once stopped, the `fs.FSWatcher` object is no longer usable.
         * @since v0.5.8
         */
        close(): void;
        /**
         * When called, requests that the Node.js event loop _not_ exit so long as the `fs.FSWatcher` is active. Calling `watcher.ref()` multiple times will have
         * no effect.
         *
         * By default, all `fs.FSWatcher` objects are "ref'ed", making it normally
         * unnecessary to call `watcher.ref()` unless `watcher.unref()` had been
         * called previously.
         * @since v14.3.0, v12.20.0
         */
        ref(): this;
        /**
         * When called, the active `fs.FSWatcher` object will not require the Node.js
         * event loop to remain active. If there is no other activity keeping the
         * event loop running, the process may exit before the `fs.FSWatcher` object's
         * callback is invoked. Calling `watcher.unref()` multiple times will have
         * no effect.
         * @since v14.3.0, v12.20.0
         */
        unref(): this;
        /**
         * events.EventEmitter
         *   1. change
         *   2. close
         *   3. error
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "error", listener: (error: Error) => void): this;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "error", listener: (error: Error) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "error", listener: (error: Error) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "error", listener: (error: Error) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "error", listener: (error: Error) => void): this;
    }
    /**
     * Instances of `fs.ReadStream` are created and returned using the {@link createReadStream} function.
     * @since v0.1.93
     */
    export class ReadStream extends stream.Readable {
        close(callback?: (err?: NodeJS.ErrnoException | null) => void): void;
        /**
         * The number of bytes that have been read so far.
         * @since v6.4.0
         */
        bytesRead: number;
        /**
         * The path to the file the stream is reading from as specified in the first
         * argument to `fs.createReadStream()`. If `path` is passed as a string, then`readStream.path` will be a string. If `path` is passed as a `Buffer`, then`readStream.path` will be a
         * `Buffer`. If `fd` is specified, then`readStream.path` will be `undefined`.
         * @since v0.1.93
         */
        path: string | Buffer;
        /**
         * This property is `true` if the underlying file has not been opened yet,
         * i.e. before the `'ready'` event is emitted.
         * @since v11.2.0, v10.16.0
         */
        pending: boolean;
        /**
         * events.EventEmitter
         *   1. open
         *   2. close
         *   3. ready
         */
        addListener(event: "close", listener: () => void): this;
        addListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        addListener(event: "end", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "open", listener: (fd: number) => void): this;
        addListener(event: "pause", listener: () => void): this;
        addListener(event: "readable", listener: () => void): this;
        addListener(event: "ready", listener: () => void): this;
        addListener(event: "resume", listener: () => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "data", listener: (chunk: Buffer | string) => void): this;
        on(event: "end", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "open", listener: (fd: number) => void): this;
        on(event: "pause", listener: () => void): this;
        on(event: "readable", listener: () => void): this;
        on(event: "ready", listener: () => void): this;
        on(event: "resume", listener: () => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "data", listener: (chunk: Buffer | string) => void): this;
        once(event: "end", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "open", listener: (fd: number) => void): this;
        once(event: "pause", listener: () => void): this;
        once(event: "readable", listener: () => void): this;
        once(event: "ready", listener: () => void): this;
        once(event: "resume", listener: () => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        prependListener(event: "end", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "open", listener: (fd: number) => void): this;
        prependListener(event: "pause", listener: () => void): this;
        prependListener(event: "readable", listener: () => void): this;
        prependListener(event: "ready", listener: () => void): this;
        prependListener(event: "resume", listener: () => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        prependOnceListener(event: "end", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: "open", listener: (fd: number) => void): this;
        prependOnceListener(event: "pause", listener: () => void): this;
        prependOnceListener(event: "readable", listener: () => void): this;
        prependOnceListener(event: "ready", listener: () => void): this;
        prependOnceListener(event: "resume", listener: () => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    /**
     * * Extends `stream.Writable`
     *
     * Instances of `fs.WriteStream` are created and returned using the {@link createWriteStream} function.
     * @since v0.1.93
     */
    export class WriteStream extends stream.Writable {
        /**
         * Closes `writeStream`. Optionally accepts a
         * callback that will be executed once the `writeStream`is closed.
         * @since v0.9.4
         */
        close(callback?: (err?: NodeJS.ErrnoException | null) => void): void;
        /**
         * The number of bytes written so far. Does not include data that is still queued
         * for writing.
         * @since v0.4.7
         */
        bytesWritten: number;
        /**
         * The path to the file the stream is writing to as specified in the first
         * argument to {@link createWriteStream}. If `path` is passed as a string, then`writeStream.path` will be a string. If `path` is passed as a `Buffer`, then`writeStream.path` will be a
         * `Buffer`.
         * @since v0.1.93
         */
        path: string | Buffer;
        /**
         * This property is `true` if the underlying file has not been opened yet,
         * i.e. before the `'ready'` event is emitted.
         * @since v11.2.0
         */
        pending: boolean;
        /**
         * events.EventEmitter
         *   1. open
         *   2. close
         *   3. ready
         */
        addListener(event: "close", listener: () => void): this;
        addListener(event: "drain", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "finish", listener: () => void): this;
        addListener(event: "open", listener: (fd: number) => void): this;
        addListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        addListener(event: "ready", listener: () => void): this;
        addListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "drain", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "finish", listener: () => void): this;
        on(event: "open", listener: (fd: number) => void): this;
        on(event: "pipe", listener: (src: stream.Readable) => void): this;
        on(event: "ready", listener: () => void): this;
        on(event: "unpipe", listener: (src: stream.Readable) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "drain", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "finish", listener: () => void): this;
        once(event: "open", listener: (fd: number) => void): this;
        once(event: "pipe", listener: (src: stream.Readable) => void): this;
        once(event: "ready", listener: () => void): this;
        once(event: "unpipe", listener: (src: stream.Readable) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "drain", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "finish", listener: () => void): this;
        prependListener(event: "open", listener: (fd: number) => void): this;
        prependListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        prependListener(event: "ready", listener: () => void): this;
        prependListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "drain", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: "finish", listener: () => void): this;
        prependOnceListener(event: "open", listener: (fd: number) => void): this;
        prependOnceListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: "ready", listener: () => void): this;
        prependOnceListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    /**
     * Asynchronously rename file at `oldPath` to the pathname provided
     * as `newPath`. In the case that `newPath` already exists, it will
     * be overwritten. If there is a directory at `newPath`, an error will
     * be raised instead. No arguments other than a possible exception are
     * given to the completion callback.
     *
     * See also: [`rename(2)`](http://man7.org/linux/man-pages/man2/rename.2.html).
     *
     * ```js
     * import { rename } from 'node:fs';
     *
     * rename('oldFile.txt', 'newFile.txt', (err) => {
     *   if (err) throw err;
     *   console.log('Rename complete!');
     * });
     * ```
     * @since v0.0.2
     */
    export function rename(oldPath: PathLike, newPath: PathLike, callback: NoParamCallback): void;
    export namespace rename {
        /**
         * Asynchronous rename(2) - Change the name or location of a file or directory.
         * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         */
        function __promisify__(oldPath: PathLike, newPath: PathLike): Promise<void>;
    }
    /**
     * Renames the file from `oldPath` to `newPath`. Returns `undefined`.
     *
     * See the POSIX [`rename(2)`](http://man7.org/linux/man-pages/man2/rename.2.html) documentation for more details.
     * @since v0.1.21
     */
    export function renameSync(oldPath: PathLike, newPath: PathLike): void;
    /**
     * Truncates the file. No arguments other than a possible exception are
     * given to the completion callback. A file descriptor can also be passed as the
     * first argument. In this case, `fs.ftruncate()` is called.
     *
     * ```js
     * import { truncate } from 'node:fs';
     * // Assuming that 'path/file.txt' is a regular file.
     * truncate('path/file.txt', (err) => {
     *   if (err) throw err;
     *   console.log('path/file.txt was truncated');
     * });
     * ```
     *
     * Passing a file descriptor is deprecated and may result in an error being thrown
     * in the future.
     *
     * See the POSIX [`truncate(2)`](http://man7.org/linux/man-pages/man2/truncate.2.html) documentation for more details.
     * @since v0.8.6
     * @param [len=0]
     */
    export function truncate(path: PathLike, len: number | undefined | null, callback: NoParamCallback): void;
    /**
     * Asynchronous truncate(2) - Truncate a file to a specified length.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    export function truncate(path: PathLike, callback: NoParamCallback): void;
    export namespace truncate {
        /**
         * Asynchronous truncate(2) - Truncate a file to a specified length.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param len If not specified, defaults to `0`.
         */
        function __promisify__(path: PathLike, len?: number | null): Promise<void>;
    }
    /**
     * Truncates the file. Returns `undefined`. A file descriptor can also be
     * passed as the first argument. In this case, `fs.ftruncateSync()` is called.
     *
     * Passing a file descriptor is deprecated and may result in an error being thrown
     * in the future.
     * @since v0.8.6
     * @param [len=0]
     */
    export function truncateSync(path: PathLike, len?: number | null): void;
    /**
     * Truncates the file descriptor. No arguments other than a possible exception are
     * given to the completion callback.
     *
     * See the POSIX [`ftruncate(2)`](http://man7.org/linux/man-pages/man2/ftruncate.2.html) documentation for more detail.
     *
     * If the file referred to by the file descriptor was larger than `len` bytes, only
     * the first `len` bytes will be retained in the file.
     *
     * For example, the following program retains only the first four bytes of the
     * file:
     *
     * ```js
     * import { open, close, ftruncate } from 'node:fs';
     *
     * function closeFd(fd) {
     *   close(fd, (err) => {
     *     if (err) throw err;
     *   });
     * }
     *
     * open('temp.txt', 'r+', (err, fd) => {
     *   if (err) throw err;
     *
     *   try {
     *     ftruncate(fd, 4, (err) => {
     *       closeFd(fd);
     *       if (err) throw err;
     *     });
     *   } catch (err) {
     *     closeFd(fd);
     *     if (err) throw err;
     *   }
     * });
     * ```
     *
     * If the file previously was shorter than `len` bytes, it is extended, and the
     * extended part is filled with null bytes (`'\0'`):
     *
     * If `len` is negative then `0` will be used.
     * @since v0.8.6
     * @param [len=0]
     */
    export function ftruncate(fd: number, len: number | undefined | null, callback: NoParamCallback): void;
    /**
     * Asynchronous ftruncate(2) - Truncate a file to a specified length.
     * @param fd A file descriptor.
     */
    export function ftruncate(fd: number, callback: NoParamCallback): void;
    export namespace ftruncate {
        /**
         * Asynchronous ftruncate(2) - Truncate a file to a specified length.
         * @param fd A file descriptor.
         * @param len If not specified, defaults to `0`.
         */
        function __promisify__(fd: number, len?: number | null): Promise<void>;
    }
    /**
     * Truncates the file descriptor. Returns `undefined`.
     *
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link ftruncate}.
     * @since v0.8.6
     * @param [len=0]
     */
    export function ftruncateSync(fd: number, len?: number | null): void;
    /**
     * Asynchronously changes owner and group of a file. No arguments other than a
     * possible exception are given to the completion callback.
     *
     * See the POSIX [`chown(2)`](http://man7.org/linux/man-pages/man2/chown.2.html) documentation for more detail.
     * @since v0.1.97
     */
    export function chown(path: PathLike, uid: number, gid: number, callback: NoParamCallback): void;
    export namespace chown {
        /**
         * Asynchronous chown(2) - Change ownership of a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;
    }
    /**
     * Synchronously changes owner and group of a file. Returns `undefined`.
     * This is the synchronous version of {@link chown}.
     *
     * See the POSIX [`chown(2)`](http://man7.org/linux/man-pages/man2/chown.2.html) documentation for more detail.
     * @since v0.1.97
     */
    export function chownSync(path: PathLike, uid: number, gid: number): void;
    /**
     * Sets the owner of the file. No arguments other than a possible exception are
     * given to the completion callback.
     *
     * See the POSIX [`fchown(2)`](http://man7.org/linux/man-pages/man2/fchown.2.html) documentation for more detail.
     * @since v0.4.7
     */
    export function fchown(fd: number, uid: number, gid: number, callback: NoParamCallback): void;
    export namespace fchown {
        /**
         * Asynchronous fchown(2) - Change ownership of a file.
         * @param fd A file descriptor.
         */
        function __promisify__(fd: number, uid: number, gid: number): Promise<void>;
    }
    /**
     * Sets the owner of the file. Returns `undefined`.
     *
     * See the POSIX [`fchown(2)`](http://man7.org/linux/man-pages/man2/fchown.2.html) documentation for more detail.
     * @since v0.4.7
     * @param uid The file's new owner's user id.
     * @param gid The file's new group's group id.
     */
    export function fchownSync(fd: number, uid: number, gid: number): void;
    /**
     * Set the owner of the symbolic link. No arguments other than a possible
     * exception are given to the completion callback.
     *
     * See the POSIX [`lchown(2)`](http://man7.org/linux/man-pages/man2/lchown.2.html) documentation for more detail.
     */
    export function lchown(path: PathLike, uid: number, gid: number, callback: NoParamCallback): void;
    export namespace lchown {
        /**
         * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;
    }
    /**
     * Set the owner for the path. Returns `undefined`.
     *
     * See the POSIX [`lchown(2)`](http://man7.org/linux/man-pages/man2/lchown.2.html) documentation for more details.
     * @param uid The file's new owner's user id.
     * @param gid The file's new group's group id.
     */
    export function lchownSync(path: PathLike, uid: number, gid: number): void;
    /**
     * Changes the access and modification times of a file in the same way as {@link utimes}, with the difference that if the path refers to a symbolic
     * link, then the link is not dereferenced: instead, the timestamps of the
     * symbolic link itself are changed.
     *
     * No arguments other than a possible exception are given to the completion
     * callback.
     * @since v14.5.0, v12.19.0
     */
    export function lutimes(path: PathLike, atime: TimeLike, mtime: TimeLike, callback: NoParamCallback): void;
    export namespace lutimes {
        /**
         * Changes the access and modification times of a file in the same way as `fsPromises.utimes()`,
         * with the difference that if the path refers to a symbolic link, then the link is not
         * dereferenced: instead, the timestamps of the symbolic link itself are changed.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param atime The last access time. If a string is provided, it will be coerced to number.
         * @param mtime The last modified time. If a string is provided, it will be coerced to number.
         */
        function __promisify__(path: PathLike, atime: TimeLike, mtime: TimeLike): Promise<void>;
    }
    /**
     * Change the file system timestamps of the symbolic link referenced by `path`.
     * Returns `undefined`, or throws an exception when parameters are incorrect or
     * the operation fails. This is the synchronous version of {@link lutimes}.
     * @since v14.5.0, v12.19.0
     */
    export function lutimesSync(path: PathLike, atime: TimeLike, mtime: TimeLike): void;
    /**
     * Asynchronously changes the permissions of a file. No arguments other than a
     * possible exception are given to the completion callback.
     *
     * See the POSIX [`chmod(2)`](http://man7.org/linux/man-pages/man2/chmod.2.html) documentation for more detail.
     *
     * ```js
     * import { chmod } from 'node:fs';
     *
     * chmod('my_file.txt', 0o775, (err) => {
     *   if (err) throw err;
     *   console.log('The permissions for file "my_file.txt" have been changed!');
     * });
     * ```
     * @since v0.1.30
     */
    export function chmod(path: PathLike, mode: Mode, callback: NoParamCallback): void;
    export namespace chmod {
        /**
         * Asynchronous chmod(2) - Change permissions of a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
         */
        function __promisify__(path: PathLike, mode: Mode): Promise<void>;
    }
    /**
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link chmod}.
     *
     * See the POSIX [`chmod(2)`](http://man7.org/linux/man-pages/man2/chmod.2.html) documentation for more detail.
     * @since v0.6.7
     */
    export function chmodSync(path: PathLike, mode: Mode): void;
    /**
     * Sets the permissions on the file. No arguments other than a possible exception
     * are given to the completion callback.
     *
     * See the POSIX [`fchmod(2)`](http://man7.org/linux/man-pages/man2/fchmod.2.html) documentation for more detail.
     * @since v0.4.7
     */
    export function fchmod(fd: number, mode: Mode, callback: NoParamCallback): void;
    export namespace fchmod {
        /**
         * Asynchronous fchmod(2) - Change permissions of a file.
         * @param fd A file descriptor.
         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
         */
        function __promisify__(fd: number, mode: Mode): Promise<void>;
    }
    /**
     * Sets the permissions on the file. Returns `undefined`.
     *
     * See the POSIX [`fchmod(2)`](http://man7.org/linux/man-pages/man2/fchmod.2.html) documentation for more detail.
     * @since v0.4.7
     */
    export function fchmodSync(fd: number, mode: Mode): void;
    /**
     * Changes the permissions on a symbolic link. No arguments other than a possible
     * exception are given to the completion callback.
     *
     * This method is only implemented on macOS.
     *
     * See the POSIX [`lchmod(2)`](https://www.freebsd.org/cgi/man.cgi?query=lchmod&sektion=2) documentation for more detail.
     * @deprecated Since v0.4.7
     */
    export function lchmod(path: PathLike, mode: Mode, callback: NoParamCallback): void;
    /** @deprecated */
    export namespace lchmod {
        /**
         * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
         */
        function __promisify__(path: PathLike, mode: Mode): Promise<void>;
    }
    /**
     * Changes the permissions on a symbolic link. Returns `undefined`.
     *
     * This method is only implemented on macOS.
     *
     * See the POSIX [`lchmod(2)`](https://www.freebsd.org/cgi/man.cgi?query=lchmod&sektion=2) documentation for more detail.
     * @deprecated Since v0.4.7
     */
    export function lchmodSync(path: PathLike, mode: Mode): void;
    /**
     * Asynchronous [`stat(2)`](http://man7.org/linux/man-pages/man2/stat.2.html). The callback gets two arguments `(err, stats)` where`stats` is an `fs.Stats` object.
     *
     * In case of an error, the `err.code` will be one of `Common System Errors`.
     *
     * {@link stat} follows symbolic links. Use {@link lstat} to look at the
     * links themselves.
     *
     * Using `fs.stat()` to check for the existence of a file before calling`fs.open()`, `fs.readFile()`, or `fs.writeFile()` is not recommended.
     * Instead, user code should open/read/write the file directly and handle the
     * error raised if the file is not available.
     *
     * To check if a file exists without manipulating it afterwards, {@link access} is recommended.
     *
     * For example, given the following directory structure:
     *
     * ```text
     * - txtDir
     * -- file.txt
     * - app.js
     * ```
     *
     * The next program will check for the stats of the given paths:
     *
     * ```js
     * import { stat } from 'node:fs';
     *
     * const pathsToCheck = ['./txtDir', './txtDir/file.txt'];
     *
     * for (let i = 0; i < pathsToCheck.length; i++) {
     *   stat(pathsToCheck[i], (err, stats) => {
     *     console.log(stats.isDirectory());
     *     console.log(stats);
     *   });
     * }
     * ```
     *
     * The resulting output will resemble:
     *
     * ```console
     * true
     * Stats {
     *   dev: 16777220,
     *   mode: 16877,
     *   nlink: 3,
     *   uid: 501,
     *   gid: 20,
     *   rdev: 0,
     *   blksize: 4096,
     *   ino: 14214262,
     *   size: 96,
     *   blocks: 0,
     *   atimeMs: 1561174653071.963,
     *   mtimeMs: 1561174614583.3518,
     *   ctimeMs: 1561174626623.5366,
     *   birthtimeMs: 1561174126937.2893,
     *   atime: 2019-06-22T03:37:33.072Z,
     *   mtime: 2019-06-22T03:36:54.583Z,
     *   ctime: 2019-06-22T03:37:06.624Z,
     *   birthtime: 2019-06-22T03:28:46.937Z
     * }
     * false
     * Stats {
     *   dev: 16777220,
     *   mode: 33188,
     *   nlink: 1,
     *   uid: 501,
     *   gid: 20,
     *   rdev: 0,
     *   blksize: 4096,
     *   ino: 14214074,
     *   size: 8,
     *   blocks: 8,
     *   atimeMs: 1561174616618.8555,
     *   mtimeMs: 1561174614584,
     *   ctimeMs: 1561174614583.8145,
     *   birthtimeMs: 1561174007710.7478,
     *   atime: 2019-06-22T03:36:56.619Z,
     *   mtime: 2019-06-22T03:36:54.584Z,
     *   ctime: 2019-06-22T03:36:54.584Z,
     *   birthtime: 2019-06-22T03:26:47.711Z
     * }
     * ```
     * @since v0.0.2
     */
    export function stat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;
    export function stat(
        path: PathLike,
        options:
            | (StatOptions & {
                bigint?: false | undefined;
            })
            | undefined,
        callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void,
    ): void;
    export function stat(
        path: PathLike,
        options: StatOptions & {
            bigint: true;
        },
        callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void,
    ): void;
    export function stat(
        path: PathLike,
        options: StatOptions | undefined,
        callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void,
    ): void;
    export namespace stat {
        /**
         * Asynchronous stat(2) - Get file status.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(
            path: PathLike,
            options?: StatOptions & {
                bigint?: false | undefined;
            },
        ): Promise<Stats>;
        function __promisify__(
            path: PathLike,
            options: StatOptions & {
                bigint: true;
            },
        ): Promise<BigIntStats>;
        function __promisify__(path: PathLike, options?: StatOptions): Promise<Stats | BigIntStats>;
    }
    export interface StatSyncFn extends Function {
        (path: PathLike, options?: undefined): Stats;
        (
            path: PathLike,
            options?: StatSyncOptions & {
                bigint?: false | undefined;
                throwIfNoEntry: false;
            },
        ): Stats | undefined;
        (
            path: PathLike,
            options: StatSyncOptions & {
                bigint: true;
                throwIfNoEntry: false;
            },
        ): BigIntStats | undefined;
        (
            path: PathLike,
            options?: StatSyncOptions & {
                bigint?: false | undefined;
            },
        ): Stats;
        (
            path: PathLike,
            options: StatSyncOptions & {
                bigint: true;
            },
        ): BigIntStats;
        (
            path: PathLike,
            options: StatSyncOptions & {
                bigint: boolean;
                throwIfNoEntry?: false | undefined;
            },
        ): Stats | BigIntStats;
        (path: PathLike, options?: StatSyncOptions): Stats | BigIntStats | undefined;
    }
    /**
     * Synchronous stat(2) - Get file status.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    export const statSync: StatSyncFn;
    /**
     * Invokes the callback with the `fs.Stats` for the file descriptor.
     *
     * See the POSIX [`fstat(2)`](http://man7.org/linux/man-pages/man2/fstat.2.html) documentation for more detail.
     * @since v0.1.95
     */
    export function fstat(fd: number, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;
    export function fstat(
        fd: number,
        options:
            | (StatOptions & {
                bigint?: false | undefined;
            })
            | undefined,
        callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void,
    ): void;
    export function fstat(
        fd: number,
        options: StatOptions & {
            bigint: true;
        },
        callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void,
    ): void;
    export function fstat(
        fd: number,
        options: StatOptions | undefined,
        callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void,
    ): void;
    export namespace fstat {
        /**
         * Asynchronous fstat(2) - Get file status.
         * @param fd A file descriptor.
         */
        function __promisify__(
            fd: number,
            options?: StatOptions & {
                bigint?: false | undefined;
            },
        ): Promise<Stats>;
        function __promisify__(
            fd: number,
            options: StatOptions & {
                bigint: true;
            },
        ): Promise<BigIntStats>;
        function __promisify__(fd: number, options?: StatOptions): Promise<Stats | BigIntStats>;
    }
    /**
     * Retrieves the `fs.Stats` for the file descriptor.
     *
     * See the POSIX [`fstat(2)`](http://man7.org/linux/man-pages/man2/fstat.2.html) documentation for more detail.
     * @since v0.1.95
     */
    export function fstatSync(
        fd: number,
        options?: StatOptions & {
            bigint?: false | undefined;
        },
    ): Stats;
    export function fstatSync(
        fd: number,
        options: StatOptions & {
            bigint: true;
        },
    ): BigIntStats;
    export function fstatSync(fd: number, options?: StatOptions): Stats | BigIntStats;
    /**
     * Retrieves the `fs.Stats` for the symbolic link referred to by the path.
     * The callback gets two arguments `(err, stats)` where `stats` is a `fs.Stats` object. `lstat()` is identical to `stat()`, except that if `path` is a symbolic
     * link, then the link itself is stat-ed, not the file that it refers to.
     *
     * See the POSIX [`lstat(2)`](http://man7.org/linux/man-pages/man2/lstat.2.html) documentation for more details.
     * @since v0.1.30
     */
    export function lstat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;
    export function lstat(
        path: PathLike,
        options:
            | (StatOptions & {
                bigint?: false | undefined;
            })
            | undefined,
        callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void,
    ): void;
    export function lstat(
        path: PathLike,
        options: StatOptions & {
            bigint: true;
        },
        callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void,
    ): void;
    export function lstat(
        path: PathLike,
        options: StatOptions | undefined,
        callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void,
    ): void;
    export namespace lstat {
        /**
         * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(
            path: PathLike,
            options?: StatOptions & {
                bigint?: false | undefined;
            },
        ): Promise<Stats>;
        function __promisify__(
            path: PathLike,
            options: StatOptions & {
                bigint: true;
            },
        ): Promise<BigIntStats>;
        function __promisify__(path: PathLike, options?: StatOptions): Promise<Stats | BigIntStats>;
    }
    /**
     * Asynchronous [`statfs(2)`](http://man7.org/linux/man-pages/man2/statfs.2.html). Returns information about the mounted file system which
     * contains `path`. The callback gets two arguments `(err, stats)` where `stats`is an `fs.StatFs` object.
     *
     * In case of an error, the `err.code` will be one of `Common System Errors`.
     * @since v19.6.0, v18.15.0
     * @param path A path to an existing file or directory on the file system to be queried.
     */
    export function statfs(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: StatsFs) => void): void;
    export function statfs(
        path: PathLike,
        options:
            | (StatFsOptions & {
                bigint?: false | undefined;
            })
            | undefined,
        callback: (err: NodeJS.ErrnoException | null, stats: StatsFs) => void,
    ): void;
    export function statfs(
        path: PathLike,
        options: StatFsOptions & {
            bigint: true;
        },
        callback: (err: NodeJS.ErrnoException | null, stats: BigIntStatsFs) => void,
    ): void;
    export function statfs(
        path: PathLike,
        options: StatFsOptions | undefined,
        callback: (err: NodeJS.ErrnoException | null, stats: StatsFs | BigIntStatsFs) => void,
    ): void;
    export namespace statfs {
        /**
         * Asynchronous statfs(2) - Returns information about the mounted file system which contains path. The callback gets two arguments (err, stats) where stats is an <fs.StatFs> object.
         * @param path A path to an existing file or directory on the file system to be queried.
         */
        function __promisify__(
            path: PathLike,
            options?: StatFsOptions & {
                bigint?: false | undefined;
            },
        ): Promise<StatsFs>;
        function __promisify__(
            path: PathLike,
            options: StatFsOptions & {
                bigint: true;
            },
        ): Promise<BigIntStatsFs>;
        function __promisify__(path: PathLike, options?: StatFsOptions): Promise<StatsFs | BigIntStatsFs>;
    }
    /**
     * Synchronous [`statfs(2)`](http://man7.org/linux/man-pages/man2/statfs.2.html). Returns information about the mounted file system which
     * contains `path`.
     *
     * In case of an error, the `err.code` will be one of `Common System Errors`.
     * @since v19.6.0, v18.15.0
     * @param path A path to an existing file or directory on the file system to be queried.
     */
    export function statfsSync(
        path: PathLike,
        options?: StatFsOptions & {
            bigint?: false | undefined;
        },
    ): StatsFs;
    export function statfsSync(
        path: PathLike,
        options: StatFsOptions & {
            bigint: true;
        },
    ): BigIntStatsFs;
    export function statfsSync(path: PathLike, options?: StatFsOptions): StatsFs | BigIntStatsFs;
    /**
     * Synchronous lstat(2) - Get file status. Does not dereference symbolic links.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    export const lstatSync: StatSyncFn;
    /**
     * Creates a new link from the `existingPath` to the `newPath`. See the POSIX [`link(2)`](http://man7.org/linux/man-pages/man2/link.2.html) documentation for more detail. No arguments other than
     * a possible
     * exception are given to the completion callback.
     * @since v0.1.31
     */
    export function link(existingPath: PathLike, newPath: PathLike, callback: NoParamCallback): void;
    export namespace link {
        /**
         * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.
         * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(existingPath: PathLike, newPath: PathLike): Promise<void>;
    }
    /**
     * Creates a new link from the `existingPath` to the `newPath`. See the POSIX [`link(2)`](http://man7.org/linux/man-pages/man2/link.2.html) documentation for more detail. Returns `undefined`.
     * @since v0.1.31
     */
    export function linkSync(existingPath: PathLike, newPath: PathLike): void;
    /**
     * Creates the link called `path` pointing to `target`. No arguments other than a
     * possible exception are given to the completion callback.
     *
     * See the POSIX [`symlink(2)`](http://man7.org/linux/man-pages/man2/symlink.2.html) documentation for more details.
     *
     * The `type` argument is only available on Windows and ignored on other platforms.
     * It can be set to `'dir'`, `'file'`, or `'junction'`. If the `type` argument is
     * not a string, Node.js will autodetect `target` type and use `'file'` or `'dir'`.
     * If the `target` does not exist, `'file'` will be used. Windows junction points
     * require the destination path to be absolute. When using `'junction'`, the`target` argument will automatically be normalized to absolute path. Junction
     * points on NTFS volumes can only point to directories.
     *
     * Relative targets are relative to the link's parent directory.
     *
     * ```js
     * import { symlink } from 'node:fs';
     *
     * symlink('./mew', './mewtwo', callback);
     * ```
     *
     * The above example creates a symbolic link `mewtwo` which points to `mew` in the
     * same directory:
     *
     * ```bash
     * $ tree .
     * .
     * ├── mew
     * └── mewtwo -> ./mew
     * ```
     * @since v0.1.31
     * @param [type='null']
     */
    export function symlink(
        target: PathLike,
        path: PathLike,
        type: symlink.Type | undefined | null,
        callback: NoParamCallback,
    ): void;
    /**
     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.
     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
     */
    export function symlink(target: PathLike, path: PathLike, callback: NoParamCallback): void;
    export namespace symlink {
        /**
         * Asynchronous symlink(2) - Create a new symbolic link to an existing file.
         * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
         * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
         * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).
         * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.
         */
        function __promisify__(target: PathLike, path: PathLike, type?: string | null): Promise<void>;
        type Type = "dir" | "file" | "junction";
    }
    /**
     * Returns `undefined`.
     *
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link symlink}.
     * @since v0.1.31
     * @param [type='null']
     */
    export function symlinkSync(target: PathLike, path: PathLike, type?: symlink.Type | null): void;
    /**
     * Reads the contents of the symbolic link referred to by `path`. The callback gets
     * two arguments `(err, linkString)`.
     *
     * See the POSIX [`readlink(2)`](http://man7.org/linux/man-pages/man2/readlink.2.html) documentation for more details.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use for
     * the link path passed to the callback. If the `encoding` is set to `'buffer'`,
     * the link path returned will be passed as a `Buffer` object.
     * @since v0.1.31
     */
    export function readlink(
        path: PathLike,
        options: EncodingOption,
        callback: (err: NodeJS.ErrnoException | null, linkString: string) => void,
    ): void;
    /**
     * Asynchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function readlink(
        path: PathLike,
        options: BufferEncodingOption,
        callback: (err: NodeJS.ErrnoException | null, linkString: Buffer) => void,
    ): void;
    /**
     * Asynchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function readlink(
        path: PathLike,
        options: EncodingOption,
        callback: (err: NodeJS.ErrnoException | null, linkString: string | Buffer) => void,
    ): void;
    /**
     * Asynchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    export function readlink(
        path: PathLike,
        callback: (err: NodeJS.ErrnoException | null, linkString: string) => void,
    ): void;
    export namespace readlink {
        /**
         * Asynchronous readlink(2) - read value of a symbolic link.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string>;
        /**
         * Asynchronous readlink(2) - read value of a symbolic link.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options: BufferEncodingOption): Promise<Buffer>;
        /**
         * Asynchronous readlink(2) - read value of a symbolic link.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string | Buffer>;
    }
    /**
     * Returns the symbolic link's string value.
     *
     * See the POSIX [`readlink(2)`](http://man7.org/linux/man-pages/man2/readlink.2.html) documentation for more details.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use for
     * the link path returned. If the `encoding` is set to `'buffer'`,
     * the link path returned will be passed as a `Buffer` object.
     * @since v0.1.31
     */
    export function readlinkSync(path: PathLike, options?: EncodingOption): string;
    /**
     * Synchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function readlinkSync(path: PathLike, options: BufferEncodingOption): Buffer;
    /**
     * Synchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function readlinkSync(path: PathLike, options?: EncodingOption): string | Buffer;
    /**
     * Asynchronously computes the canonical pathname by resolving `.`, `..`, and
     * symbolic links.
     *
     * A canonical pathname is not necessarily unique. Hard links and bind mounts can
     * expose a file system entity through many pathnames.
     *
     * This function behaves like [`realpath(3)`](http://man7.org/linux/man-pages/man3/realpath.3.html), with some exceptions:
     *
     * 1. No case conversion is performed on case-insensitive file systems.
     * 2. The maximum number of symbolic links is platform-independent and generally
     * (much) higher than what the native [`realpath(3)`](http://man7.org/linux/man-pages/man3/realpath.3.html) implementation supports.
     *
     * The `callback` gets two arguments `(err, resolvedPath)`. May use `process.cwd` to resolve relative paths.
     *
     * Only paths that can be converted to UTF8 strings are supported.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use for
     * the path passed to the callback. If the `encoding` is set to `'buffer'`,
     * the path returned will be passed as a `Buffer` object.
     *
     * If `path` resolves to a socket or a pipe, the function will return a system
     * dependent name for that object.
     * @since v0.1.31
     */
    export function realpath(
        path: PathLike,
        options: EncodingOption,
        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,
    ): void;
    /**
     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function realpath(
        path: PathLike,
        options: BufferEncodingOption,
        callback: (err: NodeJS.ErrnoException | null, resolvedPath: Buffer) => void,
    ): void;
    /**
     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function realpath(
        path: PathLike,
        options: EncodingOption,
        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string | Buffer) => void,
    ): void;
    /**
     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    export function realpath(
        path: PathLike,
        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,
    ): void;
    export namespace realpath {
        /**
         * Asynchronous realpath(3) - return the canonicalized absolute pathname.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string>;
        /**
         * Asynchronous realpath(3) - return the canonicalized absolute pathname.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options: BufferEncodingOption): Promise<Buffer>;
        /**
         * Asynchronous realpath(3) - return the canonicalized absolute pathname.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string | Buffer>;
        /**
         * Asynchronous [`realpath(3)`](http://man7.org/linux/man-pages/man3/realpath.3.html).
         *
         * The `callback` gets two arguments `(err, resolvedPath)`.
         *
         * Only paths that can be converted to UTF8 strings are supported.
         *
         * The optional `options` argument can be a string specifying an encoding, or an
         * object with an `encoding` property specifying the character encoding to use for
         * the path passed to the callback. If the `encoding` is set to `'buffer'`,
         * the path returned will be passed as a `Buffer` object.
         *
         * On Linux, when Node.js is linked against musl libc, the procfs file system must
         * be mounted on `/proc` in order for this function to work. Glibc does not have
         * this restriction.
         * @since v9.2.0
         */
        function native(
            path: PathLike,
            options: EncodingOption,
            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,
        ): void;
        function native(
            path: PathLike,
            options: BufferEncodingOption,
            callback: (err: NodeJS.ErrnoException | null, resolvedPath: Buffer) => void,
        ): void;
        function native(
            path: PathLike,
            options: EncodingOption,
            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string | Buffer) => void,
        ): void;
        function native(
            path: PathLike,
            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,
        ): void;
    }
    /**
     * Returns the resolved pathname.
     *
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link realpath}.
     * @since v0.1.31
     */
    export function realpathSync(path: PathLike, options?: EncodingOption): string;
    /**
     * Synchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function realpathSync(path: PathLike, options: BufferEncodingOption): Buffer;
    /**
     * Synchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function realpathSync(path: PathLike, options?: EncodingOption): string | Buffer;
    export namespace realpathSync {
        function native(path: PathLike, options?: EncodingOption): string;
        function native(path: PathLike, options: BufferEncodingOption): Buffer;
        function native(path: PathLike, options?: EncodingOption): string | Buffer;
    }
    /**
     * Asynchronously removes a file or symbolic link. No arguments other than a
     * possible exception are given to the completion callback.
     *
     * ```js
     * import { unlink } from 'node:fs';
     * // Assuming that 'path/file.txt' is a regular file.
     * unlink('path/file.txt', (err) => {
     *   if (err) throw err;
     *   console.log('path/file.txt was deleted');
     * });
     * ```
     *
     * `fs.unlink()` will not work on a directory, empty or otherwise. To remove a
     * directory, use {@link rmdir}.
     *
     * See the POSIX [`unlink(2)`](http://man7.org/linux/man-pages/man2/unlink.2.html) documentation for more details.
     * @since v0.0.2
     */
    export function unlink(path: PathLike, callback: NoParamCallback): void;
    export namespace unlink {
        /**
         * Asynchronous unlink(2) - delete a name and possibly the file it refers to.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(path: PathLike): Promise<void>;
    }
    /**
     * Synchronous [`unlink(2)`](http://man7.org/linux/man-pages/man2/unlink.2.html). Returns `undefined`.
     * @since v0.1.21
     */
    export function unlinkSync(path: PathLike): void;
    export interface RmDirOptions {
        /**
         * If an `EBUSY`, `EMFILE`, `ENFILE`, `ENOTEMPTY`, or
         * `EPERM` error is encountered, Node.js will retry the operation with a linear
         * backoff wait of `retryDelay` ms longer on each try. This option represents the
         * number of retries. This option is ignored if the `recursive` option is not
         * `true`.
         * @default 0
         */
        maxRetries?: number | undefined;
        /**
         * @deprecated since v14.14.0 In future versions of Node.js and will trigger a warning
         * `fs.rmdir(path, { recursive: true })` will throw if `path` does not exist or is a file.
         * Use `fs.rm(path, { recursive: true, force: true })` instead.
         *
         * If `true`, perform a recursive directory removal. In
         * recursive mode, operations are retried on failure.
         * @default false
         */
        recursive?: boolean | undefined;
        /**
         * The amount of time in milliseconds to wait between retries.
         * This option is ignored if the `recursive` option is not `true`.
         * @default 100
         */
        retryDelay?: number | undefined;
    }
    /**
     * Asynchronous [`rmdir(2)`](http://man7.org/linux/man-pages/man2/rmdir.2.html). No arguments other than a possible exception are given
     * to the completion callback.
     *
     * Using `fs.rmdir()` on a file (not a directory) results in an `ENOENT` error on
     * Windows and an `ENOTDIR` error on POSIX.
     *
     * To get a behavior similar to the `rm -rf` Unix command, use {@link rm} with options `{ recursive: true, force: true }`.
     * @since v0.0.2
     */
    export function rmdir(path: PathLike, callback: NoParamCallback): void;
    export function rmdir(path: PathLike, options: RmDirOptions, callback: NoParamCallback): void;
    export namespace rmdir {
        /**
         * Asynchronous rmdir(2) - delete a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(path: PathLike, options?: RmDirOptions): Promise<void>;
    }
    /**
     * Synchronous [`rmdir(2)`](http://man7.org/linux/man-pages/man2/rmdir.2.html). Returns `undefined`.
     *
     * Using `fs.rmdirSync()` on a file (not a directory) results in an `ENOENT` error
     * on Windows and an `ENOTDIR` error on POSIX.
     *
     * To get a behavior similar to the `rm -rf` Unix command, use {@link rmSync} with options `{ recursive: true, force: true }`.
     * @since v0.1.21
     */
    export function rmdirSync(path: PathLike, options?: RmDirOptions): void;
    export interface RmOptions {
        /**
         * When `true`, exceptions will be ignored if `path` does not exist.
         * @default false
         */
        force?: boolean | undefined;
        /**
         * If an `EBUSY`, `EMFILE`, `ENFILE`, `ENOTEMPTY`, or
         * `EPERM` error is encountered, Node.js will retry the operation with a linear
         * backoff wait of `retryDelay` ms longer on each try. This option represents the
         * number of retries. This option is ignored if the `recursive` option is not
         * `true`.
         * @default 0
         */
        maxRetries?: number | undefined;
        /**
         * If `true`, perform a recursive directory removal. In
         * recursive mode, operations are retried on failure.
         * @default false
         */
        recursive?: boolean | undefined;
        /**
         * The amount of time in milliseconds to wait between retries.
         * This option is ignored if the `recursive` option is not `true`.
         * @default 100
         */
        retryDelay?: number | undefined;
    }
    /**
     * Asynchronously removes files and directories (modeled on the standard POSIX `rm` utility). No arguments other than a possible exception are given to the
     * completion callback.
     * @since v14.14.0
     */
    export function rm(path: PathLike, callback: NoParamCallback): void;
    export function rm(path: PathLike, options: RmOptions, callback: NoParamCallback): void;
    export namespace rm {
        /**
         * Asynchronously removes files and directories (modeled on the standard POSIX `rm` utility).
         */
        function __promisify__(path: PathLike, options?: RmOptions): Promise<void>;
    }
    /**
     * Synchronously removes files and directories (modeled on the standard POSIX `rm` utility). Returns `undefined`.
     * @since v14.14.0
     */
    export function rmSync(path: PathLike, options?: RmOptions): void;
    export interface MakeDirectoryOptions {
        /**
         * Indicates whether parent folders should be created.
         * If a folder was created, the path to the first created folder will be returned.
         * @default false
         */
        recursive?: boolean | undefined;
        /**
         * A file mode. If a string is passed, it is parsed as an octal integer. If not specified
         * @default 0o777
         */
        mode?: Mode | undefined;
    }
    /**
     * Asynchronously creates a directory.
     *
     * The callback is given a possible exception and, if `recursive` is `true`, the
     * first directory path created, `(err[, path])`.`path` can still be `undefined` when `recursive` is `true`, if no directory was
     * created (for instance, if it was previously created).
     *
     * The optional `options` argument can be an integer specifying `mode` (permission
     * and sticky bits), or an object with a `mode` property and a `recursive` property indicating whether parent directories should be created. Calling `fs.mkdir()` when `path` is a directory that
     * exists results in an error only
     * when `recursive` is false. If `recursive` is false and the directory exists,
     * an `EEXIST` error occurs.
     *
     * ```js
     * import { mkdir } from 'node:fs';
     *
     * // Create ./tmp/a/apple, regardless of whether ./tmp and ./tmp/a exist.
     * mkdir('./tmp/a/apple', { recursive: true }, (err) => {
     *   if (err) throw err;
     * });
     * ```
     *
     * On Windows, using `fs.mkdir()` on the root directory even with recursion will
     * result in an error:
     *
     * ```js
     * import { mkdir } from 'node:fs';
     *
     * mkdir('/', { recursive: true }, (err) => {
     *   // => [Error: EPERM: operation not permitted, mkdir 'C:\']
     * });
     * ```
     *
     * See the POSIX [`mkdir(2)`](http://man7.org/linux/man-pages/man2/mkdir.2.html) documentation for more details.
     * @since v0.1.8
     */
    export function mkdir(
        path: PathLike,
        options: MakeDirectoryOptions & {
            recursive: true;
        },
        callback: (err: NodeJS.ErrnoException | null, path?: string) => void,
    ): void;
    /**
     * Asynchronous mkdir(2) - create a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
     */
    export function mkdir(
        path: PathLike,
        options:
            | Mode
            | (MakeDirectoryOptions & {
                recursive?: false | undefined;
            })
            | null
            | undefined,
        callback: NoParamCallback,
    ): void;
    /**
     * Asynchronous mkdir(2) - create a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
     */
    export function mkdir(
        path: PathLike,
        options: Mode | MakeDirectoryOptions | null | undefined,
        callback: (err: NodeJS.ErrnoException | null, path?: string) => void,
    ): void;
    /**
     * Asynchronous mkdir(2) - create a directory with a mode of `0o777`.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    export function mkdir(path: PathLike, callback: NoParamCallback): void;
    export namespace mkdir {
        /**
         * Asynchronous mkdir(2) - create a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
         */
        function __promisify__(
            path: PathLike,
            options: MakeDirectoryOptions & {
                recursive: true;
            },
        ): Promise<string | undefined>;
        /**
         * Asynchronous mkdir(2) - create a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
         */
        function __promisify__(
            path: PathLike,
            options?:
                | Mode
                | (MakeDirectoryOptions & {
                    recursive?: false | undefined;
                })
                | null,
        ): Promise<void>;
        /**
         * Asynchronous mkdir(2) - create a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
         */
        function __promisify__(
            path: PathLike,
            options?: Mode | MakeDirectoryOptions | null,
        ): Promise<string | undefined>;
    }
    /**
     * Synchronously creates a directory. Returns `undefined`, or if `recursive` is `true`, the first directory path created.
     * This is the synchronous version of {@link mkdir}.
     *
     * See the POSIX [`mkdir(2)`](http://man7.org/linux/man-pages/man2/mkdir.2.html) documentation for more details.
     * @since v0.1.21
     */
    export function mkdirSync(
        path: PathLike,
        options: MakeDirectoryOptions & {
            recursive: true;
        },
    ): string | undefined;
    /**
     * Synchronous mkdir(2) - create a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
     */
    export function mkdirSync(
        path: PathLike,
        options?:
            | Mode
            | (MakeDirectoryOptions & {
                recursive?: false | undefined;
            })
            | null,
    ): void;
    /**
     * Synchronous mkdir(2) - create a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
     */
    export function mkdirSync(path: PathLike, options?: Mode | MakeDirectoryOptions | null): string | undefined;
    /**
     * Creates a unique temporary directory.
     *
     * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory. Due to platform
     * inconsistencies, avoid trailing `X` characters in `prefix`. Some platforms,
     * notably the BSDs, can return more than six random characters, and replace
     * trailing `X` characters in `prefix` with random characters.
     *
     * The created directory path is passed as a string to the callback's second
     * parameter.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use.
     *
     * ```js
     * import { mkdtemp } from 'node:fs';
     * import { join } from 'node:path';
     * import { tmpdir } from 'node:os';
     *
     * mkdtemp(join(tmpdir(), 'foo-'), (err, directory) => {
     *   if (err) throw err;
     *   console.log(directory);
     *   // Prints: /tmp/foo-itXde2 or C:\Users\...\AppData\Local\Temp\foo-itXde2
     * });
     * ```
     *
     * The `fs.mkdtemp()` method will append the six randomly selected characters
     * directly to the `prefix` string. For instance, given a directory `/tmp`, if the
     * intention is to create a temporary directory _within_`/tmp`, the `prefix`must end with a trailing platform-specific path separator
     * (`require('node:path').sep`).
     *
     * ```js
     * import { tmpdir } from 'node:os';
     * import { mkdtemp } from 'node:fs';
     *
     * // The parent directory for the new temporary directory
     * const tmpDir = tmpdir();
     *
     * // This method is *INCORRECT*:
     * mkdtemp(tmpDir, (err, directory) => {
     *   if (err) throw err;
     *   console.log(directory);
     *   // Will print something similar to `/tmpabc123`.
     *   // A new temporary directory is created at the file system root
     *   // rather than *within* the /tmp directory.
     * });
     *
     * // This method is *CORRECT*:
     * import { sep } from 'node:path';
     * mkdtemp(`${tmpDir}${sep}`, (err, directory) => {
     *   if (err) throw err;
     *   console.log(directory);
     *   // Will print something similar to `/tmp/abc123`.
     *   // A new temporary directory is created within
     *   // the /tmp directory.
     * });
     * ```
     * @since v5.10.0
     */
    export function mkdtemp(
        prefix: string,
        options: EncodingOption,
        callback: (err: NodeJS.ErrnoException | null, folder: string) => void,
    ): void;
    /**
     * Asynchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function mkdtemp(
        prefix: string,
        options:
            | "buffer"
            | {
                encoding: "buffer";
            },
        callback: (err: NodeJS.ErrnoException | null, folder: Buffer) => void,
    ): void;
    /**
     * Asynchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function mkdtemp(
        prefix: string,
        options: EncodingOption,
        callback: (err: NodeJS.ErrnoException | null, folder: string | Buffer) => void,
    ): void;
    /**
     * Asynchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
     */
    export function mkdtemp(
        prefix: string,
        callback: (err: NodeJS.ErrnoException | null, folder: string) => void,
    ): void;
    export namespace mkdtemp {
        /**
         * Asynchronously creates a unique temporary directory.
         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(prefix: string, options?: EncodingOption): Promise<string>;
        /**
         * Asynchronously creates a unique temporary directory.
         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(prefix: string, options: BufferEncodingOption): Promise<Buffer>;
        /**
         * Asynchronously creates a unique temporary directory.
         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(prefix: string, options?: EncodingOption): Promise<string | Buffer>;
    }
    /**
     * Returns the created directory path.
     *
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link mkdtemp}.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use.
     * @since v5.10.0
     */
    export function mkdtempSync(prefix: string, options?: EncodingOption): string;
    /**
     * Synchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function mkdtempSync(prefix: string, options: BufferEncodingOption): Buffer;
    /**
     * Synchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function mkdtempSync(prefix: string, options?: EncodingOption): string | Buffer;
    /**
     * Reads the contents of a directory. The callback gets two arguments `(err, files)` where `files` is an array of the names of the files in the directory excluding `'.'` and `'..'`.
     *
     * See the POSIX [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) documentation for more details.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use for
     * the filenames passed to the callback. If the `encoding` is set to `'buffer'`,
     * the filenames returned will be passed as `Buffer` objects.
     *
     * If `options.withFileTypes` is set to `true`, the `files` array will contain `fs.Dirent` objects.
     * @since v0.1.8
     */
    export function readdir(
        path: PathLike,
        options:
            | {
                encoding: BufferEncoding | null;
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            }
            | BufferEncoding
            | undefined
            | null,
        callback: (err: NodeJS.ErrnoException | null, files: string[]) => void,
    ): void;
    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function readdir(
        path: PathLike,
        options:
            | {
                encoding: "buffer";
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            }
            | "buffer",
        callback: (err: NodeJS.ErrnoException | null, files: Buffer[]) => void,
    ): void;
    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function readdir(
        path: PathLike,
        options:
            | (ObjectEncodingOptions & {
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            })
            | BufferEncoding
            | undefined
            | null,
        callback: (err: NodeJS.ErrnoException | null, files: string[] | Buffer[]) => void,
    ): void;
    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    export function readdir(
        path: PathLike,
        callback: (err: NodeJS.ErrnoException | null, files: string[]) => void,
    ): void;
    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.
     */
    export function readdir(
        path: PathLike,
        options: ObjectEncodingOptions & {
            withFileTypes: true;
            recursive?: boolean | undefined;
        },
        callback: (err: NodeJS.ErrnoException | null, files: Dirent[]) => void,
    ): void;
    export namespace readdir {
        /**
         * Asynchronous readdir(3) - read a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(
            path: PathLike,
            options?:
                | {
                    encoding: BufferEncoding | null;
                    withFileTypes?: false | undefined;
                    recursive?: boolean | undefined;
                }
                | BufferEncoding
                | null,
        ): Promise<string[]>;
        /**
         * Asynchronous readdir(3) - read a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(
            path: PathLike,
            options:
                | "buffer"
                | {
                    encoding: "buffer";
                    withFileTypes?: false | undefined;
                    recursive?: boolean | undefined;
                },
        ): Promise<Buffer[]>;
        /**
         * Asynchronous readdir(3) - read a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(
            path: PathLike,
            options?:
                | (ObjectEncodingOptions & {
                    withFileTypes?: false | undefined;
                    recursive?: boolean | undefined;
                })
                | BufferEncoding
                | null,
        ): Promise<string[] | Buffer[]>;
        /**
         * Asynchronous readdir(3) - read a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options If called with `withFileTypes: true` the result data will be an array of Dirent
         */
        function __promisify__(
            path: PathLike,
            options: ObjectEncodingOptions & {
                withFileTypes: true;
                recursive?: boolean | undefined;
            },
        ): Promise<Dirent[]>;
    }
    /**
     * Reads the contents of the directory.
     *
     * See the POSIX [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) documentation for more details.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use for
     * the filenames returned. If the `encoding` is set to `'buffer'`,
     * the filenames returned will be passed as `Buffer` objects.
     *
     * If `options.withFileTypes` is set to `true`, the result will contain `fs.Dirent` objects.
     * @since v0.1.21
     */
    export function readdirSync(
        path: PathLike,
        options?:
            | {
                encoding: BufferEncoding | null;
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            }
            | BufferEncoding
            | null,
    ): string[];
    /**
     * Synchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function readdirSync(
        path: PathLike,
        options:
            | {
                encoding: "buffer";
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            }
            | "buffer",
    ): Buffer[];
    /**
     * Synchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function readdirSync(
        path: PathLike,
        options?:
            | (ObjectEncodingOptions & {
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            })
            | BufferEncoding
            | null,
    ): string[] | Buffer[];
    /**
     * Synchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.
     */
    export function readdirSync(
        path: PathLike,
        options: ObjectEncodingOptions & {
            withFileTypes: true;
            recursive?: boolean | undefined;
        },
    ): Dirent[];
    /**
     * Closes the file descriptor. No arguments other than a possible exception are
     * given to the completion callback.
     *
     * Calling `fs.close()` on any file descriptor (`fd`) that is currently in use
     * through any other `fs` operation may lead to undefined behavior.
     *
     * See the POSIX [`close(2)`](http://man7.org/linux/man-pages/man2/close.2.html) documentation for more detail.
     * @since v0.0.2
     */
    export function close(fd: number, callback?: NoParamCallback): void;
    export namespace close {
        /**
         * Asynchronous close(2) - close a file descriptor.
         * @param fd A file descriptor.
         */
        function __promisify__(fd: number): Promise<void>;
    }
    /**
     * Closes the file descriptor. Returns `undefined`.
     *
     * Calling `fs.closeSync()` on any file descriptor (`fd`) that is currently in use
     * through any other `fs` operation may lead to undefined behavior.
     *
     * See the POSIX [`close(2)`](http://man7.org/linux/man-pages/man2/close.2.html) documentation for more detail.
     * @since v0.1.21
     */
    export function closeSync(fd: number): void;
    /**
     * Asynchronous file open. See the POSIX [`open(2)`](http://man7.org/linux/man-pages/man2/open.2.html) documentation for more details.
     *
     * `mode` sets the file mode (permission and sticky bits), but only if the file was
     * created. On Windows, only the write permission can be manipulated; see {@link chmod}.
     *
     * The callback gets two arguments `(err, fd)`.
     *
     * Some characters (`< > : " / \ | ? *`) are reserved under Windows as documented
     * by [Naming Files, Paths, and Namespaces](https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file). Under NTFS, if the filename contains
     * a colon, Node.js will open a file system stream, as described by [this MSDN page](https://docs.microsoft.com/en-us/windows/desktop/FileIO/using-streams).
     *
     * Functions based on `fs.open()` exhibit this behavior as well:`fs.writeFile()`, `fs.readFile()`, etc.
     * @since v0.0.2
     * @param [flags='r'] See `support of file system `flags``.
     * @param [mode=0o666]
     */
    export function open(
        path: PathLike,
        flags: OpenMode | undefined,
        mode: Mode | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, fd: number) => void,
    ): void;
    /**
     * Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be `0o666`.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param [flags='r'] See `support of file system `flags``.
     */
    export function open(
        path: PathLike,
        flags: OpenMode | undefined,
        callback: (err: NodeJS.ErrnoException | null, fd: number) => void,
    ): void;
    /**
     * Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be `0o666`.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    export function open(path: PathLike, callback: (err: NodeJS.ErrnoException | null, fd: number) => void): void;
    export namespace open {
        /**
         * Asynchronous open(2) - open and possibly create a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.
         */
        function __promisify__(path: PathLike, flags: OpenMode, mode?: Mode | null): Promise<number>;
    }
    /**
     * Returns an integer representing the file descriptor.
     *
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link open}.
     * @since v0.1.21
     * @param [flags='r']
     * @param [mode=0o666]
     */
    export function openSync(path: PathLike, flags: OpenMode, mode?: Mode | null): number;
    /**
     * Change the file system timestamps of the object referenced by `path`.
     *
     * The `atime` and `mtime` arguments follow these rules:
     *
     * * Values can be either numbers representing Unix epoch time in seconds, `Date`s, or a numeric string like `'123456789.0'`.
     * * If the value can not be converted to a number, or is `NaN`, `Infinity`, or `-Infinity`, an `Error` will be thrown.
     * @since v0.4.2
     */
    export function utimes(path: PathLike, atime: TimeLike, mtime: TimeLike, callback: NoParamCallback): void;
    export namespace utimes {
        /**
         * Asynchronously change file timestamps of the file referenced by the supplied path.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param atime The last access time. If a string is provided, it will be coerced to number.
         * @param mtime The last modified time. If a string is provided, it will be coerced to number.
         */
        function __promisify__(path: PathLike, atime: TimeLike, mtime: TimeLike): Promise<void>;
    }
    /**
     * Returns `undefined`.
     *
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link utimes}.
     * @since v0.4.2
     */
    export function utimesSync(path: PathLike, atime: TimeLike, mtime: TimeLike): void;
    /**
     * Change the file system timestamps of the object referenced by the supplied file
     * descriptor. See {@link utimes}.
     * @since v0.4.2
     */
    export function futimes(fd: number, atime: TimeLike, mtime: TimeLike, callback: NoParamCallback): void;
    export namespace futimes {
        /**
         * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.
         * @param fd A file descriptor.
         * @param atime The last access time. If a string is provided, it will be coerced to number.
         * @param mtime The last modified time. If a string is provided, it will be coerced to number.
         */
        function __promisify__(fd: number, atime: TimeLike, mtime: TimeLike): Promise<void>;
    }
    /**
     * Synchronous version of {@link futimes}. Returns `undefined`.
     * @since v0.4.2
     */
    export function futimesSync(fd: number, atime: TimeLike, mtime: TimeLike): void;
    /**
     * Request that all data for the open file descriptor is flushed to the storage
     * device. The specific implementation is operating system and device specific.
     * Refer to the POSIX [`fsync(2)`](http://man7.org/linux/man-pages/man2/fsync.2.html) documentation for more detail. No arguments other
     * than a possible exception are given to the completion callback.
     * @since v0.1.96
     */
    export function fsync(fd: number, callback: NoParamCallback): void;
    export namespace fsync {
        /**
         * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.
         * @param fd A file descriptor.
         */
        function __promisify__(fd: number): Promise<void>;
    }
    /**
     * Request that all data for the open file descriptor is flushed to the storage
     * device. The specific implementation is operating system and device specific.
     * Refer to the POSIX [`fsync(2)`](http://man7.org/linux/man-pages/man2/fsync.2.html) documentation for more detail. Returns `undefined`.
     * @since v0.1.96
     */
    export function fsyncSync(fd: number): void;
    /**
     * Write `buffer` to the file specified by `fd`.
     *
     * `offset` determines the part of the buffer to be written, and `length` is
     * an integer specifying the number of bytes to write.
     *
     * `position` refers to the offset from the beginning of the file where this data
     * should be written. If `typeof position !== 'number'`, the data will be written
     * at the current position. See [`pwrite(2)`](http://man7.org/linux/man-pages/man2/pwrite.2.html).
     *
     * The callback will be given three arguments `(err, bytesWritten, buffer)` where `bytesWritten` specifies how many _bytes_ were written from `buffer`.
     *
     * If this method is invoked as its `util.promisify()` ed version, it returns
     * a promise for an `Object` with `bytesWritten` and `buffer` properties.
     *
     * It is unsafe to use `fs.write()` multiple times on the same file without waiting
     * for the callback. For this scenario, {@link createWriteStream} is
     * recommended.
     *
     * On Linux, positional writes don't work when the file is opened in append mode.
     * The kernel ignores the position argument and always appends the data to
     * the end of the file.
     * @since v0.0.2
     * @param [offset=0]
     * @param [length=buffer.byteLength - offset]
     * @param [position='null']
     */
    export function write<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        offset: number | undefined | null,
        length: number | undefined | null,
        position: number | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
    ): void;
    /**
     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
     */
    export function write<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        offset: number | undefined | null,
        length: number | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
    ): void;
    /**
     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
     */
    export function write<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        offset: number | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
    ): void;
    /**
     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     */
    export function write<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
    ): void;
    /**
     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     * @param string A string to write.
     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
     * @param encoding The expected string encoding.
     */
    export function write(
        fd: number,
        string: string,
        position: number | undefined | null,
        encoding: BufferEncoding | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void,
    ): void;
    /**
     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     * @param string A string to write.
     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
     */
    export function write(
        fd: number,
        string: string,
        position: number | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void,
    ): void;
    /**
     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     * @param string A string to write.
     */
    export function write(
        fd: number,
        string: string,
        callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void,
    ): void;
    export namespace write {
        /**
         * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
         * @param fd A file descriptor.
         * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
         * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
         */
        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
            fd: number,
            buffer?: TBuffer,
            offset?: number,
            length?: number,
            position?: number | null,
        ): Promise<{
            bytesWritten: number;
            buffer: TBuffer;
        }>;
        /**
         * Asynchronously writes `string` to the file referenced by the supplied file descriptor.
         * @param fd A file descriptor.
         * @param string A string to write.
         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
         * @param encoding The expected string encoding.
         */
        function __promisify__(
            fd: number,
            string: string,
            position?: number | null,
            encoding?: BufferEncoding | null,
        ): Promise<{
            bytesWritten: number;
            buffer: string;
        }>;
    }
    /**
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link write}.
     * @since v0.1.21
     * @param [offset=0]
     * @param [length=buffer.byteLength - offset]
     * @param [position='null']
     * @return The number of bytes written.
     */
    export function writeSync(
        fd: number,
        buffer: NodeJS.ArrayBufferView,
        offset?: number | null,
        length?: number | null,
        position?: number | null,
    ): number;
    /**
     * Synchronously writes `string` to the file referenced by the supplied file descriptor, returning the number of bytes written.
     * @param fd A file descriptor.
     * @param string A string to write.
     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
     * @param encoding The expected string encoding.
     */
    export function writeSync(
        fd: number,
        string: string,
        position?: number | null,
        encoding?: BufferEncoding | null,
    ): number;
    export type ReadPosition = number | bigint;
    export interface ReadSyncOptions {
        /**
         * @default 0
         */
        offset?: number | undefined;
        /**
         * @default `length of buffer`
         */
        length?: number | undefined;
        /**
         * @default null
         */
        position?: ReadPosition | null | undefined;
    }
    export interface ReadAsyncOptions<TBuffer extends NodeJS.ArrayBufferView> extends ReadSyncOptions {
        buffer?: TBuffer;
    }
    /**
     * Read data from the file specified by `fd`.
     *
     * The callback is given the three arguments, `(err, bytesRead, buffer)`.
     *
     * If the file is not modified concurrently, the end-of-file is reached when the
     * number of bytes read is zero.
     *
     * If this method is invoked as its `util.promisify()` ed version, it returns
     * a promise for an `Object` with `bytesRead` and `buffer` properties.
     * @since v0.0.2
     * @param buffer The buffer that the data will be written to.
     * @param offset The position in `buffer` to write the data to.
     * @param length The number of bytes to read.
     * @param position Specifies where to begin reading from in the file. If `position` is `null` or `-1 `, data will be read from the current file position, and the file position will be updated. If
     * `position` is an integer, the file position will be unchanged.
     */
    export function read<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        offset: number,
        length: number,
        position: ReadPosition | null,
        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,
    ): void;
    /**
     * Similar to the above `fs.read` function, this version takes an optional `options` object.
     * If not otherwise specified in an `options` object,
     * `buffer` defaults to `Buffer.alloc(16384)`,
     * `offset` defaults to `0`,
     * `length` defaults to `buffer.byteLength`, `- offset` as of Node 17.6.0
     * `position` defaults to `null`
     * @since v12.17.0, 13.11.0
     */
    export function read<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        options: ReadAsyncOptions<TBuffer>,
        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,
    ): void;
    export function read(
        fd: number,
        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: NodeJS.ArrayBufferView) => void,
    ): void;
    export namespace read {
        /**
         * @param fd A file descriptor.
         * @param buffer The buffer that the data will be written to.
         * @param offset The offset in the buffer at which to start writing.
         * @param length The number of bytes to read.
         * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.
         */
        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
            fd: number,
            buffer: TBuffer,
            offset: number,
            length: number,
            position: number | null,
        ): Promise<{
            bytesRead: number;
            buffer: TBuffer;
        }>;
        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
            fd: number,
            options: ReadAsyncOptions<TBuffer>,
        ): Promise<{
            bytesRead: number;
            buffer: TBuffer;
        }>;
        function __promisify__(fd: number): Promise<{
            bytesRead: number;
            buffer: NodeJS.ArrayBufferView;
        }>;
    }
    /**
     * Returns the number of `bytesRead`.
     *
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link read}.
     * @since v0.1.21
     * @param [position='null']
     */
    export function readSync(
        fd: number,
        buffer: NodeJS.ArrayBufferView,
        offset: number,
        length: number,
        position: ReadPosition | null,
    ): number;
    /**
     * Similar to the above `fs.readSync` function, this version takes an optional `options` object.
     * If no `options` object is specified, it will default with the above values.
     */
    export function readSync(fd: number, buffer: NodeJS.ArrayBufferView, opts?: ReadSyncOptions): number;
    /**
     * Asynchronously reads the entire contents of a file.
     *
     * ```js
     * import { readFile } from 'node:fs';
     *
     * readFile('/etc/passwd', (err, data) => {
     *   if (err) throw err;
     *   console.log(data);
     * });
     * ```
     *
     * The callback is passed two arguments `(err, data)`, where `data` is the
     * contents of the file.
     *
     * If no encoding is specified, then the raw buffer is returned.
     *
     * If `options` is a string, then it specifies the encoding:
     *
     * ```js
     * import { readFile } from 'node:fs';
     *
     * readFile('/etc/passwd', 'utf8', callback);
     * ```
     *
     * When the path is a directory, the behavior of `fs.readFile()` and {@link readFileSync} is platform-specific. On macOS, Linux, and Windows, an
     * error will be returned. On FreeBSD, a representation of the directory's contents
     * will be returned.
     *
     * ```js
     * import { readFile } from 'node:fs';
     *
     * // macOS, Linux, and Windows
     * readFile('<directory>', (err, data) => {
     *   // => [Error: EISDIR: illegal operation on a directory, read <directory>]
     * });
     *
     * //  FreeBSD
     * readFile('<directory>', (err, data) => {
     *   // => null, <data>
     * });
     * ```
     *
     * It is possible to abort an ongoing request using an `AbortSignal`. If a
     * request is aborted the callback is called with an `AbortError`:
     *
     * ```js
     * import { readFile } from 'node:fs';
     *
     * const controller = new AbortController();
     * const signal = controller.signal;
     * readFile(fileInfo[0].name, { signal }, (err, buf) => {
     *   // ...
     * });
     * // When you want to abort the request
     * controller.abort();
     * ```
     *
     * The `fs.readFile()` function buffers the entire file. To minimize memory costs,
     * when possible prefer streaming via `fs.createReadStream()`.
     *
     * Aborting an ongoing request does not abort individual operating
     * system requests but rather the internal buffering `fs.readFile` performs.
     * @since v0.1.29
     * @param path filename or file descriptor
     */
    export function readFile(
        path: PathOrFileDescriptor,
        options:
            | ({
                encoding?: null | undefined;
                flag?: string | undefined;
            } & Abortable)
            | undefined
            | null,
        callback: (err: NodeJS.ErrnoException | null, data: Buffer) => void,
    ): void;
    /**
     * Asynchronously reads the entire contents of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
     * If a flag is not provided, it defaults to `'r'`.
     */
    export function readFile(
        path: PathOrFileDescriptor,
        options:
            | ({
                encoding: BufferEncoding;
                flag?: string | undefined;
            } & Abortable)
            | BufferEncoding,
        callback: (err: NodeJS.ErrnoException | null, data: string) => void,
    ): void;
    /**
     * Asynchronously reads the entire contents of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
     * If a flag is not provided, it defaults to `'r'`.
     */
    export function readFile(
        path: PathOrFileDescriptor,
        options:
            | (ObjectEncodingOptions & {
                flag?: string | undefined;
            } & Abortable)
            | BufferEncoding
            | undefined
            | null,
        callback: (err: NodeJS.ErrnoException | null, data: string | Buffer) => void,
    ): void;
    /**
     * Asynchronously reads the entire contents of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     */
    export function readFile(
        path: PathOrFileDescriptor,
        callback: (err: NodeJS.ErrnoException | null, data: Buffer) => void,
    ): void;
    export namespace readFile {
        /**
         * Asynchronously reads the entire contents of a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
         * @param options An object that may contain an optional flag.
         * If a flag is not provided, it defaults to `'r'`.
         */
        function __promisify__(
            path: PathOrFileDescriptor,
            options?: {
                encoding?: null | undefined;
                flag?: string | undefined;
            } | null,
        ): Promise<Buffer>;
        /**
         * Asynchronously reads the entire contents of a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
         * If a flag is not provided, it defaults to `'r'`.
         */
        function __promisify__(
            path: PathOrFileDescriptor,
            options:
                | {
                    encoding: BufferEncoding;
                    flag?: string | undefined;
                }
                | BufferEncoding,
        ): Promise<string>;
        /**
         * Asynchronously reads the entire contents of a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
         * If a flag is not provided, it defaults to `'r'`.
         */
        function __promisify__(
            path: PathOrFileDescriptor,
            options?:
                | (ObjectEncodingOptions & {
                    flag?: string | undefined;
                })
                | BufferEncoding
                | null,
        ): Promise<string | Buffer>;
    }
    /**
     * Returns the contents of the `path`.
     *
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link readFile}.
     *
     * If the `encoding` option is specified then this function returns a
     * string. Otherwise it returns a buffer.
     *
     * Similar to {@link readFile}, when the path is a directory, the behavior of `fs.readFileSync()` is platform-specific.
     *
     * ```js
     * import { readFileSync } from 'node:fs';
     *
     * // macOS, Linux, and Windows
     * readFileSync('<directory>');
     * // => [Error: EISDIR: illegal operation on a directory, read <directory>]
     *
     * //  FreeBSD
     * readFileSync('<directory>'); // => <data>
     * ```
     * @since v0.1.8
     * @param path filename or file descriptor
     */
    export function readFileSync(
        path: PathOrFileDescriptor,
        options?: {
            encoding?: null | undefined;
            flag?: string | undefined;
        } | null,
    ): Buffer;
    /**
     * Synchronously reads the entire contents of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
     * If a flag is not provided, it defaults to `'r'`.
     */
    export function readFileSync(
        path: PathOrFileDescriptor,
        options:
            | {
                encoding: BufferEncoding;
                flag?: string | undefined;
            }
            | BufferEncoding,
    ): string;
    /**
     * Synchronously reads the entire contents of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
     * If a flag is not provided, it defaults to `'r'`.
     */
    export function readFileSync(
        path: PathOrFileDescriptor,
        options?:
            | (ObjectEncodingOptions & {
                flag?: string | undefined;
            })
            | BufferEncoding
            | null,
    ): string | Buffer;
    export type WriteFileOptions =
        | (
            & ObjectEncodingOptions
            & Abortable
            & {
                mode?: Mode | undefined;
                flag?: string | undefined;
                flush?: boolean | undefined;
            }
        )
        | BufferEncoding
        | null;
    /**
     * When `file` is a filename, asynchronously writes data to the file, replacing the
     * file if it already exists. `data` can be a string or a buffer.
     *
     * When `file` is a file descriptor, the behavior is similar to calling `fs.write()` directly (which is recommended). See the notes below on using
     * a file descriptor.
     *
     * The `encoding` option is ignored if `data` is a buffer.
     *
     * The `mode` option only affects the newly created file. See {@link open} for more details.
     *
     * ```js
     * import { writeFile } from 'node:fs';
     * import { Buffer } from 'node:buffer';
     *
     * const data = new Uint8Array(Buffer.from('Hello Node.js'));
     * writeFile('message.txt', data, (err) => {
     *   if (err) throw err;
     *   console.log('The file has been saved!');
     * });
     * ```
     *
     * If `options` is a string, then it specifies the encoding:
     *
     * ```js
     * import { writeFile } from 'node:fs';
     *
     * writeFile('message.txt', 'Hello Node.js', 'utf8', callback);
     * ```
     *
     * It is unsafe to use `fs.writeFile()` multiple times on the same file without
     * waiting for the callback. For this scenario, {@link createWriteStream} is
     * recommended.
     *
     * Similarly to `fs.readFile` \- `fs.writeFile` is a convenience method that
     * performs multiple `write` calls internally to write the buffer passed to it.
     * For performance sensitive code consider using {@link createWriteStream}.
     *
     * It is possible to use an `AbortSignal` to cancel an `fs.writeFile()`.
     * Cancelation is "best effort", and some amount of data is likely still
     * to be written.
     *
     * ```js
     * import { writeFile } from 'node:fs';
     * import { Buffer } from 'node:buffer';
     *
     * const controller = new AbortController();
     * const { signal } = controller;
     * const data = new Uint8Array(Buffer.from('Hello Node.js'));
     * writeFile('message.txt', data, { signal }, (err) => {
     *   // When a request is aborted - the callback is called with an AbortError
     * });
     * // When the request should be aborted
     * controller.abort();
     * ```
     *
     * Aborting an ongoing request does not abort individual operating
     * system requests but rather the internal buffering `fs.writeFile` performs.
     * @since v0.1.29
     * @param file filename or file descriptor
     */
    export function writeFile(
        file: PathOrFileDescriptor,
        data: string | NodeJS.ArrayBufferView,
        options: WriteFileOptions,
        callback: NoParamCallback,
    ): void;
    /**
     * Asynchronously writes data to a file, replacing the file if it already exists.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
     */
    export function writeFile(
        path: PathOrFileDescriptor,
        data: string | NodeJS.ArrayBufferView,
        callback: NoParamCallback,
    ): void;
    export namespace writeFile {
        /**
         * Asynchronously writes data to a file, replacing the file if it already exists.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
         * If `encoding` is not supplied, the default of `'utf8'` is used.
         * If `mode` is not supplied, the default of `0o666` is used.
         * If `mode` is a string, it is parsed as an octal integer.
         * If `flag` is not supplied, the default of `'w'` is used.
         */
        function __promisify__(
            path: PathOrFileDescriptor,
            data: string | NodeJS.ArrayBufferView,
            options?: WriteFileOptions,
        ): Promise<void>;
    }
    /**
     * Returns `undefined`.
     *
     * The `mode` option only affects the newly created file. See {@link open} for more details.
     *
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link writeFile}.
     * @since v0.1.29
     * @param file filename or file descriptor
     */
    export function writeFileSync(
        file: PathOrFileDescriptor,
        data: string | NodeJS.ArrayBufferView,
        options?: WriteFileOptions,
    ): void;
    /**
     * Asynchronously append data to a file, creating the file if it does not yet
     * exist. `data` can be a string or a `Buffer`.
     *
     * The `mode` option only affects the newly created file. See {@link open} for more details.
     *
     * ```js
     * import { appendFile } from 'node:fs';
     *
     * appendFile('message.txt', 'data to append', (err) => {
     *   if (err) throw err;
     *   console.log('The "data to append" was appended to file!');
     * });
     * ```
     *
     * If `options` is a string, then it specifies the encoding:
     *
     * ```js
     * import { appendFile } from 'node:fs';
     *
     * appendFile('message.txt', 'data to append', 'utf8', callback);
     * ```
     *
     * The `path` may be specified as a numeric file descriptor that has been opened
     * for appending (using `fs.open()` or `fs.openSync()`). The file descriptor will
     * not be closed automatically.
     *
     * ```js
     * import { open, close, appendFile } from 'node:fs';
     *
     * function closeFd(fd) {
     *   close(fd, (err) => {
     *     if (err) throw err;
     *   });
     * }
     *
     * open('message.txt', 'a', (err, fd) => {
     *   if (err) throw err;
     *
     *   try {
     *     appendFile(fd, 'data to append', 'utf8', (err) => {
     *       closeFd(fd);
     *       if (err) throw err;
     *     });
     *   } catch (err) {
     *     closeFd(fd);
     *     throw err;
     *   }
     * });
     * ```
     * @since v0.6.7
     * @param path filename or file descriptor
     */
    export function appendFile(
        path: PathOrFileDescriptor,
        data: string | Uint8Array,
        options: WriteFileOptions,
        callback: NoParamCallback,
    ): void;
    /**
     * Asynchronously append data to a file, creating the file if it does not exist.
     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
     */
    export function appendFile(file: PathOrFileDescriptor, data: string | Uint8Array, callback: NoParamCallback): void;
    export namespace appendFile {
        /**
         * Asynchronously append data to a file, creating the file if it does not exist.
         * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
         * If `encoding` is not supplied, the default of `'utf8'` is used.
         * If `mode` is not supplied, the default of `0o666` is used.
         * If `mode` is a string, it is parsed as an octal integer.
         * If `flag` is not supplied, the default of `'a'` is used.
         */
        function __promisify__(
            file: PathOrFileDescriptor,
            data: string | Uint8Array,
            options?: WriteFileOptions,
        ): Promise<void>;
    }
    /**
     * Synchronously append data to a file, creating the file if it does not yet
     * exist. `data` can be a string or a `Buffer`.
     *
     * The `mode` option only affects the newly created file. See {@link open} for more details.
     *
     * ```js
     * import { appendFileSync } from 'node:fs';
     *
     * try {
     *   appendFileSync('message.txt', 'data to append');
     *   console.log('The "data to append" was appended to file!');
     * } catch (err) {
     *   // Handle the error
     * }
     * ```
     *
     * If `options` is a string, then it specifies the encoding:
     *
     * ```js
     * import { appendFileSync } from 'node:fs';
     *
     * appendFileSync('message.txt', 'data to append', 'utf8');
     * ```
     *
     * The `path` may be specified as a numeric file descriptor that has been opened
     * for appending (using `fs.open()` or `fs.openSync()`). The file descriptor will
     * not be closed automatically.
     *
     * ```js
     * import { openSync, closeSync, appendFileSync } from 'node:fs';
     *
     * let fd;
     *
     * try {
     *   fd = openSync('message.txt', 'a');
     *   appendFileSync(fd, 'data to append', 'utf8');
     * } catch (err) {
     *   // Handle the error
     * } finally {
     *   if (fd !== undefined)
     *     closeSync(fd);
     * }
     * ```
     * @since v0.6.7
     * @param path filename or file descriptor
     */
    export function appendFileSync(
        path: PathOrFileDescriptor,
        data: string | Uint8Array,
        options?: WriteFileOptions,
    ): void;
    /**
     * Watch for changes on `filename`. The callback `listener` will be called each
     * time the file is accessed.
     *
     * The `options` argument may be omitted. If provided, it should be an object. The `options` object may contain a boolean named `persistent` that indicates
     * whether the process should continue to run as long as files are being watched.
     * The `options` object may specify an `interval` property indicating how often the
     * target should be polled in milliseconds.
     *
     * The `listener` gets two arguments the current stat object and the previous
     * stat object:
     *
     * ```js
     * import { watchFile } from 'fs';
     *
     * watchFile('message.text', (curr, prev) => {
     *   console.log(`the current mtime is: ${curr.mtime}`);
     *   console.log(`the previous mtime was: ${prev.mtime}`);
     * });
     * ```
     *
     * These stat objects are instances of `fs.Stat`. If the `bigint` option is `true`,
     * the numeric values in these objects are specified as `BigInt`s.
     *
     * To be notified when the file was modified, not just accessed, it is necessary
     * to compare `curr.mtimeMs` and `prev.mtimeMs`.
     *
     * When an `fs.watchFile` operation results in an `ENOENT` error, it
     * will invoke the listener once, with all the fields zeroed (or, for dates, the
     * Unix Epoch). If the file is created later on, the listener will be called
     * again, with the latest stat objects. This is a change in functionality since
     * v0.10.
     *
     * Using {@link watch} is more efficient than `fs.watchFile` and `fs.unwatchFile`. `fs.watch` should be used instead of `fs.watchFile` and `fs.unwatchFile` when possible.
     *
     * When a file being watched by `fs.watchFile()` disappears and reappears,
     * then the contents of `previous` in the second callback event (the file's
     * reappearance) will be the same as the contents of `previous` in the first
     * callback event (its disappearance).
     *
     * This happens when:
     *
     * * the file is deleted, followed by a restore
     * * the file is renamed and then renamed a second time back to its original name
     * @since v0.1.31
     */
    export interface WatchFileOptions {
        bigint?: boolean | undefined;
        persistent?: boolean | undefined;
        interval?: number | undefined;
    }
    /**
     * Watch for changes on `filename`. The callback `listener` will be called each
     * time the file is accessed.
     *
     * The `options` argument may be omitted. If provided, it should be an object. The `options` object may contain a boolean named `persistent` that indicates
     * whether the process should continue to run as long as files are being watched.
     * The `options` object may specify an `interval` property indicating how often the
     * target should be polled in milliseconds.
     *
     * The `listener` gets two arguments the current stat object and the previous
     * stat object:
     *
     * ```js
     * import { watchFile } from 'node:fs';
     *
     * watchFile('message.text', (curr, prev) => {
     *   console.log(`the current mtime is: ${curr.mtime}`);
     *   console.log(`the previous mtime was: ${prev.mtime}`);
     * });
     * ```
     *
     * These stat objects are instances of `fs.Stat`. If the `bigint` option is `true`,
     * the numeric values in these objects are specified as `BigInt`s.
     *
     * To be notified when the file was modified, not just accessed, it is necessary
     * to compare `curr.mtimeMs` and `prev.mtimeMs`.
     *
     * When an `fs.watchFile` operation results in an `ENOENT` error, it
     * will invoke the listener once, with all the fields zeroed (or, for dates, the
     * Unix Epoch). If the file is created later on, the listener will be called
     * again, with the latest stat objects. This is a change in functionality since
     * v0.10.
     *
     * Using {@link watch} is more efficient than `fs.watchFile` and `fs.unwatchFile`. `fs.watch` should be used instead of `fs.watchFile` and `fs.unwatchFile` when possible.
     *
     * When a file being watched by `fs.watchFile()` disappears and reappears,
     * then the contents of `previous` in the second callback event (the file's
     * reappearance) will be the same as the contents of `previous` in the first
     * callback event (its disappearance).
     *
     * This happens when:
     *
     * * the file is deleted, followed by a restore
     * * the file is renamed and then renamed a second time back to its original name
     * @since v0.1.31
     */
    export function watchFile(
        filename: PathLike,
        options:
            | (WatchFileOptions & {
                bigint?: false | undefined;
            })
            | undefined,
        listener: StatsListener,
    ): StatWatcher;
    export function watchFile(
        filename: PathLike,
        options:
            | (WatchFileOptions & {
                bigint: true;
            })
            | undefined,
        listener: BigIntStatsListener,
    ): StatWatcher;
    /**
     * Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed.
     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     */
    export function watchFile(filename: PathLike, listener: StatsListener): StatWatcher;
    /**
     * Stop watching for changes on `filename`. If `listener` is specified, only that
     * particular listener is removed. Otherwise, _all_ listeners are removed,
     * effectively stopping watching of `filename`.
     *
     * Calling `fs.unwatchFile()` with a filename that is not being watched is a
     * no-op, not an error.
     *
     * Using {@link watch} is more efficient than `fs.watchFile()` and `fs.unwatchFile()`. `fs.watch()` should be used instead of `fs.watchFile()` and `fs.unwatchFile()` when possible.
     * @since v0.1.31
     * @param listener Optional, a listener previously attached using `fs.watchFile()`
     */
    export function unwatchFile(filename: PathLike, listener?: StatsListener): void;
    export function unwatchFile(filename: PathLike, listener?: BigIntStatsListener): void;
    export interface WatchOptions extends Abortable {
        encoding?: BufferEncoding | "buffer" | undefined;
        persistent?: boolean | undefined;
        recursive?: boolean | undefined;
    }
    export type WatchEventType = "rename" | "change";
    export type WatchListener<T> = (event: WatchEventType, filename: T | null) => void;
    export type StatsListener = (curr: Stats, prev: Stats) => void;
    export type BigIntStatsListener = (curr: BigIntStats, prev: BigIntStats) => void;
    /**
     * Watch for changes on `filename`, where `filename` is either a file or a
     * directory.
     *
     * The second argument is optional. If `options` is provided as a string, it
     * specifies the `encoding`. Otherwise `options` should be passed as an object.
     *
     * The listener callback gets two arguments `(eventType, filename)`. `eventType`is either `'rename'` or `'change'`, and `filename` is the name of the file
     * which triggered the event.
     *
     * On most platforms, `'rename'` is emitted whenever a filename appears or
     * disappears in the directory.
     *
     * The listener callback is attached to the `'change'` event fired by `fs.FSWatcher`, but it is not the same thing as the `'change'` value of `eventType`.
     *
     * If a `signal` is passed, aborting the corresponding AbortController will close
     * the returned `fs.FSWatcher`.
     * @since v0.5.10
     * @param listener
     */
    export function watch(
        filename: PathLike,
        options:
            | (WatchOptions & {
                encoding: "buffer";
            })
            | "buffer",
        listener?: WatchListener<Buffer>,
    ): FSWatcher;
    /**
     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.
     * If `encoding` is not supplied, the default of `'utf8'` is used.
     * If `persistent` is not supplied, the default of `true` is used.
     * If `recursive` is not supplied, the default of `false` is used.
     */
    export function watch(
        filename: PathLike,
        options?: WatchOptions | BufferEncoding | null,
        listener?: WatchListener<string>,
    ): FSWatcher;
    /**
     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.
     * If `encoding` is not supplied, the default of `'utf8'` is used.
     * If `persistent` is not supplied, the default of `true` is used.
     * If `recursive` is not supplied, the default of `false` is used.
     */
    export function watch(
        filename: PathLike,
        options: WatchOptions | string,
        listener?: WatchListener<string | Buffer>,
    ): FSWatcher;
    /**
     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     */
    export function watch(filename: PathLike, listener?: WatchListener<string>): FSWatcher;
    /**
     * Test whether or not the given path exists by checking with the file system.
     * Then call the `callback` argument with either true or false:
     *
     * ```js
     * import { exists } from 'node:fs';
     *
     * exists('/etc/passwd', (e) => {
     *   console.log(e ? 'it exists' : 'no passwd!');
     * });
     * ```
     *
     * **The parameters for this callback are not consistent with other Node.js**
     * **callbacks.** Normally, the first parameter to a Node.js callback is an `err` parameter, optionally followed by other parameters. The `fs.exists()` callback
     * has only one boolean parameter. This is one reason `fs.access()` is recommended
     * instead of `fs.exists()`.
     *
     * Using `fs.exists()` to check for the existence of a file before calling `fs.open()`, `fs.readFile()`, or `fs.writeFile()` is not recommended. Doing
     * so introduces a race condition, since other processes may change the file's
     * state between the two calls. Instead, user code should open/read/write the
     * file directly and handle the error raised if the file does not exist.
     *
     * **write (NOT RECOMMENDED)**
     *
     * ```js
     * import { exists, open, close } from 'node:fs';
     *
     * exists('myfile', (e) => {
     *   if (e) {
     *     console.error('myfile already exists');
     *   } else {
     *     open('myfile', 'wx', (err, fd) => {
     *       if (err) throw err;
     *
     *       try {
     *         writeMyData(fd);
     *       } finally {
     *         close(fd, (err) => {
     *           if (err) throw err;
     *         });
     *       }
     *     });
     *   }
     * });
     * ```
     *
     * **write (RECOMMENDED)**
     *
     * ```js
     * import { open, close } from 'node:fs';
     * open('myfile', 'wx', (err, fd) => {
     *   if (err) {
     *     if (err.code === 'EEXIST') {
     *       console.error('myfile already exists');
     *       return;
     *     }
     *
     *     throw err;
     *   }
     *
     *   try {
     *     writeMyData(fd);
     *   } finally {
     *     close(fd, (err) => {
     *       if (err) throw err;
     *     });
     *   }
     * });
     * ```
     *
     * **read (NOT RECOMMENDED)**
     *
     * ```js
     * import { open, close, exists } from 'node:fs';
     *
     * exists('myfile', (e) => {
     *   if (e) {
     *     open('myfile', 'r', (err, fd) => {
     *       if (err) throw err;
     *
     *       try {
     *         readMyData(fd);
     *       } finally {
     *         close(fd, (err) => {
     *           if (err) throw err;
     *         });
     *       }
     *     });
     *   } else {
     *     console.error('myfile does not exist');
     *   }
     * });
     * ```
     *
     * **read (RECOMMENDED)**
     *
     * ```js
     * import { open, close } from 'node:fs';
     *
     * open('myfile', 'r', (err, fd) => {
     *   if (err) {
     *     if (err.code === 'ENOENT') {
     *       console.error('myfile does not exist');
     *       return;
     *     }
     *
     *     throw err;
     *   }
     *
     *   try {
     *     readMyData(fd);
     *   } finally {
     *     close(fd, (err) => {
     *       if (err) throw err;
     *     });
     *   }
     * });
     * ```
     *
     * The "not recommended" examples above check for existence and then use the
     * file; the "recommended" examples are better because they use the file directly
     * and handle the error, if any.
     *
     * In general, check for the existence of a file only if the file won't be
     * used directly, for example when its existence is a signal from another
     * process.
     * @since v0.0.2
     * @deprecated Since v1.0.0 - Use {@link stat} or {@link access} instead.
     */
    export function exists(path: PathLike, callback: (exists: boolean) => void): void;
    /** @deprecated */
    export namespace exists {
        /**
         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         */
        function __promisify__(path: PathLike): Promise<boolean>;
    }
    /**
     * Returns `true` if the path exists, `false` otherwise.
     *
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link exists}.
     *
     * `fs.exists()` is deprecated, but `fs.existsSync()` is not. The `callback` parameter to `fs.exists()` accepts parameters that are inconsistent with other
     * Node.js callbacks. `fs.existsSync()` does not use a callback.
     *
     * ```js
     * import { existsSync } from 'node:fs';
     *
     * if (existsSync('/etc/passwd'))
     *   console.log('The path exists.');
     * ```
     * @since v0.1.21
     */
    export function existsSync(path: PathLike): boolean;
    export namespace constants {
        // File Access Constants
        /** Constant for fs.access(). File is visible to the calling process. */
        const F_OK: number;
        /** Constant for fs.access(). File can be read by the calling process. */
        const R_OK: number;
        /** Constant for fs.access(). File can be written by the calling process. */
        const W_OK: number;
        /** Constant for fs.access(). File can be executed by the calling process. */
        const X_OK: number;
        // File Copy Constants
        /** Constant for fs.copyFile. Flag indicating the destination file should not be overwritten if it already exists. */
        const COPYFILE_EXCL: number;
        /**
         * Constant for fs.copyFile. copy operation will attempt to create a copy-on-write reflink.
         * If the underlying platform does not support copy-on-write, then a fallback copy mechanism is used.
         */
        const COPYFILE_FICLONE: number;
        /**
         * Constant for fs.copyFile. Copy operation will attempt to create a copy-on-write reflink.
         * If the underlying platform does not support copy-on-write, then the operation will fail with an error.
         */
        const COPYFILE_FICLONE_FORCE: number;
        // File Open Constants
        /** Constant for fs.open(). Flag indicating to open a file for read-only access. */
        const O_RDONLY: number;
        /** Constant for fs.open(). Flag indicating to open a file for write-only access. */
        const O_WRONLY: number;
        /** Constant for fs.open(). Flag indicating to open a file for read-write access. */
        const O_RDWR: number;
        /** Constant for fs.open(). Flag indicating to create the file if it does not already exist. */
        const O_CREAT: number;
        /** Constant for fs.open(). Flag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists. */
        const O_EXCL: number;
        /**
         * Constant for fs.open(). Flag indicating that if path identifies a terminal device,
         * opening the path shall not cause that terminal to become the controlling terminal for the process
         * (if the process does not already have one).
         */
        const O_NOCTTY: number;
        /** Constant for fs.open(). Flag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero. */
        const O_TRUNC: number;
        /** Constant for fs.open(). Flag indicating that data will be appended to the end of the file. */
        const O_APPEND: number;
        /** Constant for fs.open(). Flag indicating that the open should fail if the path is not a directory. */
        const O_DIRECTORY: number;
        /**
         * constant for fs.open().
         * Flag indicating reading accesses to the file system will no longer result in
         * an update to the atime information associated with the file.
         * This flag is available on Linux operating systems only.
         */
        const O_NOATIME: number;
        /** Constant for fs.open(). Flag indicating that the open should fail if the path is a symbolic link. */
        const O_NOFOLLOW: number;
        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O. */
        const O_SYNC: number;
        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O with write operations waiting for data integrity. */
        const O_DSYNC: number;
        /** Constant for fs.open(). Flag indicating to open the symbolic link itself rather than the resource it is pointing to. */
        const O_SYMLINK: number;
        /** Constant for fs.open(). When set, an attempt will be made to minimize caching effects of file I/O. */
        const O_DIRECT: number;
        /** Constant for fs.open(). Flag indicating to open the file in nonblocking mode when possible. */
        const O_NONBLOCK: number;
        // File Type Constants
        /** Constant for fs.Stats mode property for determining a file's type. Bit mask used to extract the file type code. */
        const S_IFMT: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a regular file. */
        const S_IFREG: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a directory. */
        const S_IFDIR: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a character-oriented device file. */
        const S_IFCHR: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a block-oriented device file. */
        const S_IFBLK: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a FIFO/pipe. */
        const S_IFIFO: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a symbolic link. */
        const S_IFLNK: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a socket. */
        const S_IFSOCK: number;
        // File Mode Constants
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by owner. */
        const S_IRWXU: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by owner. */
        const S_IRUSR: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by owner. */
        const S_IWUSR: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by owner. */
        const S_IXUSR: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by group. */
        const S_IRWXG: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by group. */
        const S_IRGRP: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by group. */
        const S_IWGRP: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by group. */
        const S_IXGRP: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by others. */
        const S_IRWXO: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by others. */
        const S_IROTH: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by others. */
        const S_IWOTH: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by others. */
        const S_IXOTH: number;
        /**
         * When set, a memory file mapping is used to access the file. This flag
         * is available on Windows operating systems only. On other operating systems,
         * this flag is ignored.
         */
        const UV_FS_O_FILEMAP: number;
    }
    /**
     * Tests a user's permissions for the file or directory specified by `path`.
     * The `mode` argument is an optional integer that specifies the accessibility
     * checks to be performed. `mode` should be either the value `fs.constants.F_OK` or a mask consisting of the bitwise OR of any of `fs.constants.R_OK`, `fs.constants.W_OK`, and `fs.constants.X_OK`
     * (e.g.`fs.constants.W_OK | fs.constants.R_OK`). Check `File access constants` for
     * possible values of `mode`.
     *
     * The final argument, `callback`, is a callback function that is invoked with
     * a possible error argument. If any of the accessibility checks fail, the error
     * argument will be an `Error` object. The following examples check if `package.json` exists, and if it is readable or writable.
     *
     * ```js
     * import { access, constants } from 'node:fs';
     *
     * const file = 'package.json';
     *
     * // Check if the file exists in the current directory.
     * access(file, constants.F_OK, (err) => {
     *   console.log(`${file} ${err ? 'does not exist' : 'exists'}`);
     * });
     *
     * // Check if the file is readable.
     * access(file, constants.R_OK, (err) => {
     *   console.log(`${file} ${err ? 'is not readable' : 'is readable'}`);
     * });
     *
     * // Check if the file is writable.
     * access(file, constants.W_OK, (err) => {
     *   console.log(`${file} ${err ? 'is not writable' : 'is writable'}`);
     * });
     *
     * // Check if the file is readable and writable.
     * access(file, constants.R_OK | constants.W_OK, (err) => {
     *   console.log(`${file} ${err ? 'is not' : 'is'} readable and writable`);
     * });
     * ```
     *
     * Do not use `fs.access()` to check for the accessibility of a file before calling `fs.open()`, `fs.readFile()`, or `fs.writeFile()`. Doing
     * so introduces a race condition, since other processes may change the file's
     * state between the two calls. Instead, user code should open/read/write the
     * file directly and handle the error raised if the file is not accessible.
     *
     * **write (NOT RECOMMENDED)**
     *
     * ```js
     * import { access, open, close } from 'node:fs';
     *
     * access('myfile', (err) => {
     *   if (!err) {
     *     console.error('myfile already exists');
     *     return;
     *   }
     *
     *   open('myfile', 'wx', (err, fd) => {
     *     if (err) throw err;
     *
     *     try {
     *       writeMyData(fd);
     *     } finally {
     *       close(fd, (err) => {
     *         if (err) throw err;
     *       });
     *     }
     *   });
     * });
     * ```
     *
     * **write (RECOMMENDED)**
     *
     * ```js
     * import { open, close } from 'node:fs';
     *
     * open('myfile', 'wx', (err, fd) => {
     *   if (err) {
     *     if (err.code === 'EEXIST') {
     *       console.error('myfile already exists');
     *       return;
     *     }
     *
     *     throw err;
     *   }
     *
     *   try {
     *     writeMyData(fd);
     *   } finally {
     *     close(fd, (err) => {
     *       if (err) throw err;
     *     });
     *   }
     * });
     * ```
     *
     * **read (NOT RECOMMENDED)**
     *
     * ```js
     * import { access, open, close } from 'node:fs';
     * access('myfile', (err) => {
     *   if (err) {
     *     if (err.code === 'ENOENT') {
     *       console.error('myfile does not exist');
     *       return;
     *     }
     *
     *     throw err;
     *   }
     *
     *   open('myfile', 'r', (err, fd) => {
     *     if (err) throw err;
     *
     *     try {
     *       readMyData(fd);
     *     } finally {
     *       close(fd, (err) => {
     *         if (err) throw err;
     *       });
     *     }
     *   });
     * });
     * ```
     *
     * **read (RECOMMENDED)**
     *
     * ```js
     * import { open, close } from 'node:fs';
     *
     * open('myfile', 'r', (err, fd) => {
     *   if (err) {
     *     if (err.code === 'ENOENT') {
     *       console.error('myfile does not exist');
     *       return;
     *     }
     *
     *     throw err;
     *   }
     *
     *   try {
     *     readMyData(fd);
     *   } finally {
     *     close(fd, (err) => {
     *       if (err) throw err;
     *     });
     *   }
     * });
     * ```
     *
     * The "not recommended" examples above check for accessibility and then use the
     * file; the "recommended" examples are better because they use the file directly
     * and handle the error, if any.
     *
     * In general, check for the accessibility of a file only if the file will not be
     * used directly, for example when its accessibility is a signal from another
     * process.
     *
     * On Windows, access-control policies (ACLs) on a directory may limit access to
     * a file or directory. The `fs.access()` function, however, does not check the
     * ACL and therefore may report that a path is accessible even if the ACL restricts
     * the user from reading or writing to it.
     * @since v0.11.15
     * @param [mode=fs.constants.F_OK]
     */
    export function access(path: PathLike, mode: number | undefined, callback: NoParamCallback): void;
    /**
     * Asynchronously tests a user's permissions for the file specified by path.
     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     */
    export function access(path: PathLike, callback: NoParamCallback): void;
    export namespace access {
        /**
         * Asynchronously tests a user's permissions for the file specified by path.
         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         */
        function __promisify__(path: PathLike, mode?: number): Promise<void>;
    }
    /**
     * Synchronously tests a user's permissions for the file or directory specified
     * by `path`. The `mode` argument is an optional integer that specifies the
     * accessibility checks to be performed. `mode` should be either the value `fs.constants.F_OK` or a mask consisting of the bitwise OR of any of `fs.constants.R_OK`, `fs.constants.W_OK`, and
     * `fs.constants.X_OK` (e.g.`fs.constants.W_OK | fs.constants.R_OK`). Check `File access constants` for
     * possible values of `mode`.
     *
     * If any of the accessibility checks fail, an `Error` will be thrown. Otherwise,
     * the method will return `undefined`.
     *
     * ```js
     * import { accessSync, constants } from 'node:fs';
     *
     * try {
     *   accessSync('etc/passwd', constants.R_OK | constants.W_OK);
     *   console.log('can read/write');
     * } catch (err) {
     *   console.error('no access!');
     * }
     * ```
     * @since v0.11.15
     * @param [mode=fs.constants.F_OK]
     */
    export function accessSync(path: PathLike, mode?: number): void;
    interface StreamOptions {
        flags?: string | undefined;
        encoding?: BufferEncoding | undefined;
        fd?: number | promises.FileHandle | undefined;
        mode?: number | undefined;
        autoClose?: boolean | undefined;
        emitClose?: boolean | undefined;
        start?: number | undefined;
        signal?: AbortSignal | null | undefined;
        highWaterMark?: number | undefined;
    }
    interface FSImplementation {
        open?: (...args: any[]) => any;
        close?: (...args: any[]) => any;
    }
    interface CreateReadStreamFSImplementation extends FSImplementation {
        read: (...args: any[]) => any;
    }
    interface CreateWriteStreamFSImplementation extends FSImplementation {
        write: (...args: any[]) => any;
        writev?: (...args: any[]) => any;
    }
    interface ReadStreamOptions extends StreamOptions {
        fs?: CreateReadStreamFSImplementation | null | undefined;
        end?: number | undefined;
    }
    interface WriteStreamOptions extends StreamOptions {
        fs?: CreateWriteStreamFSImplementation | null | undefined;
        flush?: boolean | undefined;
    }
    /**
     * Unlike the 16 KiB default `highWaterMark` for a `stream.Readable`, the stream
     * returned by this method has a default `highWaterMark` of 64 KiB.
     *
     * `options` can include `start` and `end` values to read a range of bytes from
     * the file instead of the entire file. Both `start` and `end` are inclusive and
     * start counting at 0, allowed values are in the
     * \[0, [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\] range. If `fd` is specified and `start` is
     * omitted or `undefined`, `fs.createReadStream()` reads sequentially from the
     * current file position. The `encoding` can be any one of those accepted by `Buffer`.
     *
     * If `fd` is specified, `ReadStream` will ignore the `path` argument and will use
     * the specified file descriptor. This means that no `'open'` event will be
     * emitted. `fd` should be blocking; non-blocking `fd`s should be passed to `net.Socket`.
     *
     * If `fd` points to a character device that only supports blocking reads
     * (such as keyboard or sound card), read operations do not finish until data is
     * available. This can prevent the process from exiting and the stream from
     * closing naturally.
     *
     * By default, the stream will emit a `'close'` event after it has been
     * destroyed.  Set the `emitClose` option to `false` to change this behavior.
     *
     * By providing the `fs` option, it is possible to override the corresponding `fs` implementations for `open`, `read`, and `close`. When providing the `fs` option,
     * an override for `read` is required. If no `fd` is provided, an override for `open` is also required. If `autoClose` is `true`, an override for `close` is
     * also required.
     *
     * ```js
     * import { createReadStream } from 'node:fs';
     *
     * // Create a stream from some character device.
     * const stream = createReadStream('/dev/input/event0');
     * setTimeout(() => {
     *   stream.close(); // This may not close the stream.
     *   // Artificially marking end-of-stream, as if the underlying resource had
     *   // indicated end-of-file by itself, allows the stream to close.
     *   // This does not cancel pending read operations, and if there is such an
     *   // operation, the process may still not be able to exit successfully
     *   // until it finishes.
     *   stream.push(null);
     *   stream.read(0);
     * }, 100);
     * ```
     *
     * If `autoClose` is false, then the file descriptor won't be closed, even if
     * there's an error. It is the application's responsibility to close it and make
     * sure there's no file descriptor leak. If `autoClose` is set to true (default
     * behavior), on `'error'` or `'end'` the file descriptor will be closed
     * automatically.
     *
     * `mode` sets the file mode (permission and sticky bits), but only if the
     * file was created.
     *
     * An example to read the last 10 bytes of a file which is 100 bytes long:
     *
     * ```js
     * import { createReadStream } from 'node:fs';
     *
     * createReadStream('sample.txt', { start: 90, end: 99 });
     * ```
     *
     * If `options` is a string, then it specifies the encoding.
     * @since v0.1.31
     */
    export function createReadStream(path: PathLike, options?: BufferEncoding | ReadStreamOptions): ReadStream;
    /**
     * `options` may also include a `start` option to allow writing data at some
     * position past the beginning of the file, allowed values are in the
     * \[0, [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\] range. Modifying a file rather than
     * replacing it may require the `flags` option to be set to `r+` rather than the
     * default `w`. The `encoding` can be any one of those accepted by `Buffer`.
     *
     * If `autoClose` is set to true (default behavior) on `'error'` or `'finish'` the file descriptor will be closed automatically. If `autoClose` is false,
     * then the file descriptor won't be closed, even if there's an error.
     * It is the application's responsibility to close it and make sure there's no
     * file descriptor leak.
     *
     * By default, the stream will emit a `'close'` event after it has been
     * destroyed.  Set the `emitClose` option to `false` to change this behavior.
     *
     * By providing the `fs` option it is possible to override the corresponding `fs` implementations for `open`, `write`, `writev`, and `close`. Overriding `write()` without `writev()` can reduce
     * performance as some optimizations (`_writev()`)
     * will be disabled. When providing the `fs` option, overrides for at least one of `write` and `writev` are required. If no `fd` option is supplied, an override
     * for `open` is also required. If `autoClose` is `true`, an override for `close` is also required.
     *
     * Like `fs.ReadStream`, if `fd` is specified, `fs.WriteStream` will ignore the `path` argument and will use the specified file descriptor. This means that no `'open'` event will be
     * emitted. `fd` should be blocking; non-blocking `fd`s
     * should be passed to `net.Socket`.
     *
     * If `options` is a string, then it specifies the encoding.
     * @since v0.1.31
     */
    export function createWriteStream(path: PathLike, options?: BufferEncoding | WriteStreamOptions): WriteStream;
    /**
     * Forces all currently queued I/O operations associated with the file to the
     * operating system's synchronized I/O completion state. Refer to the POSIX [`fdatasync(2)`](http://man7.org/linux/man-pages/man2/fdatasync.2.html) documentation for details. No arguments other
     * than a possible
     * exception are given to the completion callback.
     * @since v0.1.96
     */
    export function fdatasync(fd: number, callback: NoParamCallback): void;
    export namespace fdatasync {
        /**
         * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.
         * @param fd A file descriptor.
         */
        function __promisify__(fd: number): Promise<void>;
    }
    /**
     * Forces all currently queued I/O operations associated with the file to the
     * operating system's synchronized I/O completion state. Refer to the POSIX [`fdatasync(2)`](http://man7.org/linux/man-pages/man2/fdatasync.2.html) documentation for details. Returns `undefined`.
     * @since v0.1.96
     */
    export function fdatasyncSync(fd: number): void;
    /**
     * Asynchronously copies `src` to `dest`. By default, `dest` is overwritten if it
     * already exists. No arguments other than a possible exception are given to the
     * callback function. Node.js makes no guarantees about the atomicity of the copy
     * operation. If an error occurs after the destination file has been opened for
     * writing, Node.js will attempt to remove the destination.
     *
     * `mode` is an optional integer that specifies the behavior
     * of the copy operation. It is possible to create a mask consisting of the bitwise
     * OR of two or more values (e.g.`fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE`).
     *
     * * `fs.constants.COPYFILE_EXCL`: The copy operation will fail if `dest` already
     * exists.
     * * `fs.constants.COPYFILE_FICLONE`: The copy operation will attempt to create a
     * copy-on-write reflink. If the platform does not support copy-on-write, then a
     * fallback copy mechanism is used.
     * * `fs.constants.COPYFILE_FICLONE_FORCE`: The copy operation will attempt to
     * create a copy-on-write reflink. If the platform does not support
     * copy-on-write, then the operation will fail.
     *
     * ```js
     * import { copyFile, constants } from 'node:fs';
     *
     * function callback(err) {
     *   if (err) throw err;
     *   console.log('source.txt was copied to destination.txt');
     * }
     *
     * // destination.txt will be created or overwritten by default.
     * copyFile('source.txt', 'destination.txt', callback);
     *
     * // By using COPYFILE_EXCL, the operation will fail if destination.txt exists.
     * copyFile('source.txt', 'destination.txt', constants.COPYFILE_EXCL, callback);
     * ```
     * @since v8.5.0
     * @param src source filename to copy
     * @param dest destination filename of the copy operation
     * @param [mode=0] modifiers for copy operation.
     */
    export function copyFile(src: PathLike, dest: PathLike, callback: NoParamCallback): void;
    export function copyFile(src: PathLike, dest: PathLike, mode: number, callback: NoParamCallback): void;
    export namespace copyFile {
        function __promisify__(src: PathLike, dst: PathLike, mode?: number): Promise<void>;
    }
    /**
     * Synchronously copies `src` to `dest`. By default, `dest` is overwritten if it
     * already exists. Returns `undefined`. Node.js makes no guarantees about the
     * atomicity of the copy operation. If an error occurs after the destination file
     * has been opened for writing, Node.js will attempt to remove the destination.
     *
     * `mode` is an optional integer that specifies the behavior
     * of the copy operation. It is possible to create a mask consisting of the bitwise
     * OR of two or more values (e.g.`fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE`).
     *
     * * `fs.constants.COPYFILE_EXCL`: The copy operation will fail if `dest` already
     * exists.
     * * `fs.constants.COPYFILE_FICLONE`: The copy operation will attempt to create a
     * copy-on-write reflink. If the platform does not support copy-on-write, then a
     * fallback copy mechanism is used.
     * * `fs.constants.COPYFILE_FICLONE_FORCE`: The copy operation will attempt to
     * create a copy-on-write reflink. If the platform does not support
     * copy-on-write, then the operation will fail.
     *
     * ```js
     * import { copyFileSync, constants } from 'node:fs';
     *
     * // destination.txt will be created or overwritten by default.
     * copyFileSync('source.txt', 'destination.txt');
     * console.log('source.txt was copied to destination.txt');
     *
     * // By using COPYFILE_EXCL, the operation will fail if destination.txt exists.
     * copyFileSync('source.txt', 'destination.txt', constants.COPYFILE_EXCL);
     * ```
     * @since v8.5.0
     * @param src source filename to copy
     * @param dest destination filename of the copy operation
     * @param [mode=0] modifiers for copy operation.
     */
    export function copyFileSync(src: PathLike, dest: PathLike, mode?: number): void;
    /**
     * Write an array of `ArrayBufferView`s to the file specified by `fd` using `writev()`.
     *
     * `position` is the offset from the beginning of the file where this data
     * should be written. If `typeof position !== 'number'`, the data will be written
     * at the current position.
     *
     * The callback will be given three arguments: `err`, `bytesWritten`, and `buffers`. `bytesWritten` is how many bytes were written from `buffers`.
     *
     * If this method is `util.promisify()` ed, it returns a promise for an `Object` with `bytesWritten` and `buffers` properties.
     *
     * It is unsafe to use `fs.writev()` multiple times on the same file without
     * waiting for the callback. For this scenario, use {@link createWriteStream}.
     *
     * On Linux, positional writes don't work when the file is opened in append mode.
     * The kernel ignores the position argument and always appends the data to
     * the end of the file.
     * @since v12.9.0
     * @param [position='null']
     */
    export function writev(
        fd: number,
        buffers: readonly NodeJS.ArrayBufferView[],
        cb: (err: NodeJS.ErrnoException | null, bytesWritten: number, buffers: NodeJS.ArrayBufferView[]) => void,
    ): void;
    export function writev(
        fd: number,
        buffers: readonly NodeJS.ArrayBufferView[],
        position: number,
        cb: (err: NodeJS.ErrnoException | null, bytesWritten: number, buffers: NodeJS.ArrayBufferView[]) => void,
    ): void;
    export interface WriteVResult {
        bytesWritten: number;
        buffers: NodeJS.ArrayBufferView[];
    }
    export namespace writev {
        function __promisify__(
            fd: number,
            buffers: readonly NodeJS.ArrayBufferView[],
            position?: number,
        ): Promise<WriteVResult>;
    }
    /**
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link writev}.
     * @since v12.9.0
     * @param [position='null']
     * @return The number of bytes written.
     */
    export function writevSync(fd: number, buffers: readonly NodeJS.ArrayBufferView[], position?: number): number;
    /**
     * Read from a file specified by `fd` and write to an array of `ArrayBufferView`s
     * using `readv()`.
     *
     * `position` is the offset from the beginning of the file from where data
     * should be read. If `typeof position !== 'number'`, the data will be read
     * from the current position.
     *
     * The callback will be given three arguments: `err`, `bytesRead`, and `buffers`. `bytesRead` is how many bytes were read from the file.
     *
     * If this method is invoked as its `util.promisify()` ed version, it returns
     * a promise for an `Object` with `bytesRead` and `buffers` properties.
     * @since v13.13.0, v12.17.0
     * @param [position='null']
     */
    export function readv(
        fd: number,
        buffers: readonly NodeJS.ArrayBufferView[],
        cb: (err: NodeJS.ErrnoException | null, bytesRead: number, buffers: NodeJS.ArrayBufferView[]) => void,
    ): void;
    export function readv(
        fd: number,
        buffers: readonly NodeJS.ArrayBufferView[],
        position: number,
        cb: (err: NodeJS.ErrnoException | null, bytesRead: number, buffers: NodeJS.ArrayBufferView[]) => void,
    ): void;
    export interface ReadVResult {
        bytesRead: number;
        buffers: NodeJS.ArrayBufferView[];
    }
    export namespace readv {
        function __promisify__(
            fd: number,
            buffers: readonly NodeJS.ArrayBufferView[],
            position?: number,
        ): Promise<ReadVResult>;
    }
    /**
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link readv}.
     * @since v13.13.0, v12.17.0
     * @param [position='null']
     * @return The number of bytes read.
     */
    export function readvSync(fd: number, buffers: readonly NodeJS.ArrayBufferView[], position?: number): number;

    export interface OpenAsBlobOptions {
        /**
         * An optional mime type for the blob.
         *
         * @default 'undefined'
         */
        type?: string | undefined;
    }

    /**
     * Returns a `Blob` whose data is backed by the given file.
     *
     * The file must not be modified after the `Blob` is created. Any modifications
     * will cause reading the `Blob` data to fail with a `DOMException` error.
     * Synchronous stat operations on the file when the `Blob` is created, and before
     * each read in order to detect whether the file data has been modified on disk.
     *
     * ```js
     * import { openAsBlob } from 'node:fs';
     *
     * const blob = await openAsBlob('the.file.txt');
     * const ab = await blob.arrayBuffer();
     * blob.stream();
     * ```
     * @since v19.8.0
     * @experimental
     */
    export function openAsBlob(path: PathLike, options?: OpenAsBlobOptions): Promise<Blob>;

    export interface OpenDirOptions {
        /**
         * @default 'utf8'
         */
        encoding?: BufferEncoding | undefined;
        /**
         * Number of directory entries that are buffered
         * internally when reading from the directory. Higher values lead to better
         * performance but higher memory usage.
         * @default 32
         */
        bufferSize?: number | undefined;
        /**
         * @default false
         */
        recursive?: boolean;
    }
    /**
     * Synchronously open a directory. See [`opendir(3)`](http://man7.org/linux/man-pages/man3/opendir.3.html).
     *
     * Creates an `fs.Dir`, which contains all further functions for reading from
     * and cleaning up the directory.
     *
     * The `encoding` option sets the encoding for the `path` while opening the
     * directory and subsequent read operations.
     * @since v12.12.0
     */
    export function opendirSync(path: PathLike, options?: OpenDirOptions): Dir;
    /**
     * Asynchronously open a directory. See the POSIX [`opendir(3)`](http://man7.org/linux/man-pages/man3/opendir.3.html) documentation for
     * more details.
     *
     * Creates an `fs.Dir`, which contains all further functions for reading from
     * and cleaning up the directory.
     *
     * The `encoding` option sets the encoding for the `path` while opening the
     * directory and subsequent read operations.
     * @since v12.12.0
     */
    export function opendir(path: PathLike, cb: (err: NodeJS.ErrnoException | null, dir: Dir) => void): void;
    export function opendir(
        path: PathLike,
        options: OpenDirOptions,
        cb: (err: NodeJS.ErrnoException | null, dir: Dir) => void,
    ): void;
    export namespace opendir {
        function __promisify__(path: PathLike, options?: OpenDirOptions): Promise<Dir>;
    }
    export interface BigIntStats extends StatsBase<bigint> {
        atimeNs: bigint;
        mtimeNs: bigint;
        ctimeNs: bigint;
        birthtimeNs: bigint;
    }
    export interface BigIntOptions {
        bigint: true;
    }
    export interface StatOptions {
        bigint?: boolean | undefined;
    }
    export interface StatSyncOptions extends StatOptions {
        throwIfNoEntry?: boolean | undefined;
    }
    interface CopyOptionsBase {
        /**
         * Dereference symlinks
         * @default false
         */
        dereference?: boolean;
        /**
         * When `force` is `false`, and the destination
         * exists, throw an error.
         * @default false
         */
        errorOnExist?: boolean;
        /**
         * Overwrite existing file or directory. _The copy
         * operation will ignore errors if you set this to false and the destination
         * exists. Use the `errorOnExist` option to change this behavior.
         * @default true
         */
        force?: boolean;
        /**
         * Modifiers for copy operation. See `mode` flag of {@link copyFileSync()}
         */
        mode?: number;
        /**
         * When `true` timestamps from `src` will
         * be preserved.
         * @default false
         */
        preserveTimestamps?: boolean;
        /**
         * Copy directories recursively.
         * @default false
         */
        recursive?: boolean;
        /**
         * When true, path resolution for symlinks will be skipped
         * @default false
         */
        verbatimSymlinks?: boolean;
    }
    export interface CopyOptions extends CopyOptionsBase {
        /**
         * Function to filter copied files/directories. Return
         * `true` to copy the item, `false` to ignore it.
         */
        filter?(source: string, destination: string): boolean | Promise<boolean>;
    }
    export interface CopySyncOptions extends CopyOptionsBase {
        /**
         * Function to filter copied files/directories. Return
         * `true` to copy the item, `false` to ignore it.
         */
        filter?(source: string, destination: string): boolean;
    }
    /**
     * Asynchronously copies the entire directory structure from `src` to `dest`,
     * including subdirectories and files.
     *
     * When copying a directory to another directory, globs are not supported and
     * behavior is similar to `cp dir1/ dir2/`.
     * @since v16.7.0
     * @experimental
     * @param src source path to copy.
     * @param dest destination path to copy to.
     */
    export function cp(
        source: string | URL,
        destination: string | URL,
        callback: (err: NodeJS.ErrnoException | null) => void,
    ): void;
    export function cp(
        source: string | URL,
        destination: string | URL,
        opts: CopyOptions,
        callback: (err: NodeJS.ErrnoException | null) => void,
    ): void;
    /**
     * Synchronously copies the entire directory structure from `src` to `dest`,
     * including subdirectories and files.
     *
     * When copying a directory to another directory, globs are not supported and
     * behavior is similar to `cp dir1/ dir2/`.
     * @since v16.7.0
     * @experimental
     * @param src source path to copy.
     * @param dest destination path to copy to.
     */
    export function cpSync(source: string | URL, destination: string | URL, opts?: CopySyncOptions): void;

    export interface GlobOptions {
        /**
         * Current working directory.
         * @default process.cwd()
         */
        cwd?: string | undefined;
        /**
         * Function to filter out files/directories. Return true to exclude the item, false to include it.
         */
        exclude?: ((fileName: string) => boolean) | undefined;
        /**
         * `true` if the glob should return paths as `Dirent`s, `false` otherwise.
         * @default false
         * @since v22.2.0
         */
        withFileTypes?: boolean | undefined;
    }
    export interface GlobOptionsWithFileTypes extends GlobOptions {
        withFileTypes: true;
    }
    export interface GlobOptionsWithoutFileTypes extends GlobOptions {
        withFileTypes?: false | undefined;
    }
    /**
     * Retrieves the files matching the specified pattern.
     */
    export function glob(
        pattern: string | string[],
        callback: (err: NodeJS.ErrnoException | null, matches: string[]) => void,
    ): void;
    export function glob(
        pattern: string | string[],
        options: GlobOptionsWithFileTypes,
        callback: (
            err: NodeJS.ErrnoException | null,
            matches: Dirent[],
        ) => void,
    ): void;
    export function glob(
        pattern: string | string[],
        options: GlobOptionsWithoutFileTypes,
        callback: (
            err: NodeJS.ErrnoException | null,
            matches: string[],
        ) => void,
    ): void;
    export function glob(
        pattern: string | string[],
        options: GlobOptions,
        callback: (
            err: NodeJS.ErrnoException | null,
            matches: Dirent[] | string[],
        ) => void,
    ): void;
    /**
     * Retrieves the files matching the specified pattern.
     */
    export function globSync(pattern: string | string[]): string[];
    export function globSync(
        pattern: string | string[],
        options: GlobOptionsWithFileTypes,
    ): Dirent[];
    export function globSync(
        pattern: string | string[],
        options: GlobOptionsWithoutFileTypes,
    ): string[];
    export function globSync(
        pattern: string | string[],
        options: GlobOptions,
    ): Dirent[] | string[];
}
declare module "node:fs" {
    export * from "fs";
}
/**
 * The `fs/promises` API provides asynchronous file system methods that return
 * promises.
 *
 * The promise APIs use the underlying Node.js threadpool to perform file
 * system operations off the event loop thread. These operations are not
 * synchronized or threadsafe. Care must be taken when performing multiple
 * concurrent modifications on the same file or data corruption may occur.
 * @since v10.0.0
 */
declare module "fs/promises" {
    import { Abortable } from "node:events";
    import { Stream } from "node:stream";
    import { ReadableStream } from "node:stream/web";
    import {
        BigIntStats,
        BigIntStatsFs,
        BufferEncodingOption,
        constants as fsConstants,
        CopyOptions,
        Dir,
        Dirent,
        GlobOptions,
        GlobOptionsWithFileTypes,
        GlobOptionsWithoutFileTypes,
        MakeDirectoryOptions,
        Mode,
        ObjectEncodingOptions,
        OpenDirOptions,
        OpenMode,
        PathLike,
        ReadStream,
        ReadVResult,
        RmDirOptions,
        RmOptions,
        StatFsOptions,
        StatOptions,
        Stats,
        StatsFs,
        TimeLike,
        WatchEventType,
        WatchOptions,
        WriteStream,
        WriteVResult,
    } from "node:fs";
    import { Interface as ReadlineInterface } from "node:readline";
    interface FileChangeInfo<T extends string | Buffer> {
        eventType: WatchEventType;
        filename: T | null;
    }
    interface FlagAndOpenMode {
        mode?: Mode | undefined;
        flag?: OpenMode | undefined;
    }
    interface FileReadResult<T extends NodeJS.ArrayBufferView> {
        bytesRead: number;
        buffer: T;
    }
    interface FileReadOptions<T extends NodeJS.ArrayBufferView = Buffer> {
        /**
         * @default `Buffer.alloc(0xffff)`
         */
        buffer?: T;
        /**
         * @default 0
         */
        offset?: number | null;
        /**
         * @default `buffer.byteLength`
         */
        length?: number | null;
        position?: number | null;
    }
    interface CreateReadStreamOptions {
        encoding?: BufferEncoding | null | undefined;
        autoClose?: boolean | undefined;
        emitClose?: boolean | undefined;
        start?: number | undefined;
        end?: number | undefined;
        highWaterMark?: number | undefined;
    }
    interface CreateWriteStreamOptions {
        encoding?: BufferEncoding | null | undefined;
        autoClose?: boolean | undefined;
        emitClose?: boolean | undefined;
        start?: number | undefined;
        highWaterMark?: number | undefined;
        flush?: boolean | undefined;
    }
    interface ReadableWebStreamOptions {
        /**
         * Whether to open a normal or a `'bytes'` stream.
         * @since v20.0.0
         */
        type?: "bytes" | undefined;
    }
    // TODO: Add `EventEmitter` close
    interface FileHandle {
        /**
         * The numeric file descriptor managed by the {FileHandle} object.
         * @since v10.0.0
         */
        readonly fd: number;
        /**
         * Alias of `filehandle.writeFile()`.
         *
         * When operating on file handles, the mode cannot be changed from what it was set
         * to with `fsPromises.open()`. Therefore, this is equivalent to `filehandle.writeFile()`.
         * @since v10.0.0
         * @return Fulfills with `undefined` upon success.
         */
        appendFile(
            data: string | Uint8Array,
            options?:
                | (ObjectEncodingOptions & FlagAndOpenMode & { flush?: boolean | undefined })
                | BufferEncoding
                | null,
        ): Promise<void>;
        /**
         * Changes the ownership of the file. A wrapper for [`chown(2)`](http://man7.org/linux/man-pages/man2/chown.2.html).
         * @since v10.0.0
         * @param uid The file's new owner's user id.
         * @param gid The file's new group's group id.
         * @return Fulfills with `undefined` upon success.
         */
        chown(uid: number, gid: number): Promise<void>;
        /**
         * Modifies the permissions on the file. See [`chmod(2)`](http://man7.org/linux/man-pages/man2/chmod.2.html).
         * @since v10.0.0
         * @param mode the file mode bit mask.
         * @return Fulfills with `undefined` upon success.
         */
        chmod(mode: Mode): Promise<void>;
        /**
         * Unlike the 16 KiB default `highWaterMark` for a `stream.Readable`, the stream
         * returned by this method has a default `highWaterMark` of 64 KiB.
         *
         * `options` can include `start` and `end` values to read a range of bytes from
         * the file instead of the entire file. Both `start` and `end` are inclusive and
         * start counting at 0, allowed values are in the
         * \[0, [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\] range. If `start` is
         * omitted or `undefined`, `filehandle.createReadStream()` reads sequentially from
         * the current file position. The `encoding` can be any one of those accepted by `Buffer`.
         *
         * If the `FileHandle` points to a character device that only supports blocking
         * reads (such as keyboard or sound card), read operations do not finish until data
         * is available. This can prevent the process from exiting and the stream from
         * closing naturally.
         *
         * By default, the stream will emit a `'close'` event after it has been
         * destroyed.  Set the `emitClose` option to `false` to change this behavior.
         *
         * ```js
         * import { open } from 'node:fs/promises';
         *
         * const fd = await open('/dev/input/event0');
         * // Create a stream from some character device.
         * const stream = fd.createReadStream();
         * setTimeout(() => {
         *   stream.close(); // This may not close the stream.
         *   // Artificially marking end-of-stream, as if the underlying resource had
         *   // indicated end-of-file by itself, allows the stream to close.
         *   // This does not cancel pending read operations, and if there is such an
         *   // operation, the process may still not be able to exit successfully
         *   // until it finishes.
         *   stream.push(null);
         *   stream.read(0);
         * }, 100);
         * ```
         *
         * If `autoClose` is false, then the file descriptor won't be closed, even if
         * there's an error. It is the application's responsibility to close it and make
         * sure there's no file descriptor leak. If `autoClose` is set to true (default
         * behavior), on `'error'` or `'end'` the file descriptor will be closed
         * automatically.
         *
         * An example to read the last 10 bytes of a file which is 100 bytes long:
         *
         * ```js
         * import { open } from 'node:fs/promises';
         *
         * const fd = await open('sample.txt');
         * fd.createReadStream({ start: 90, end: 99 });
         * ```
         * @since v16.11.0
         */
        createReadStream(options?: CreateReadStreamOptions): ReadStream;
        /**
         * `options` may also include a `start` option to allow writing data at some
         * position past the beginning of the file, allowed values are in the
         * \[0, [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\] range. Modifying a file rather than
         * replacing it may require the `flags` `open` option to be set to `r+` rather than
         * the default `r`. The `encoding` can be any one of those accepted by `Buffer`.
         *
         * If `autoClose` is set to true (default behavior) on `'error'` or `'finish'` the file descriptor will be closed automatically. If `autoClose` is false,
         * then the file descriptor won't be closed, even if there's an error.
         * It is the application's responsibility to close it and make sure there's no
         * file descriptor leak.
         *
         * By default, the stream will emit a `'close'` event after it has been
         * destroyed.  Set the `emitClose` option to `false` to change this behavior.
         * @since v16.11.0
         */
        createWriteStream(options?: CreateWriteStreamOptions): WriteStream;
        /**
         * Forces all currently queued I/O operations associated with the file to the
         * operating system's synchronized I/O completion state. Refer to the POSIX [`fdatasync(2)`](http://man7.org/linux/man-pages/man2/fdatasync.2.html) documentation for details.
         *
         * Unlike `filehandle.sync` this method does not flush modified metadata.
         * @since v10.0.0
         * @return Fulfills with `undefined` upon success.
         */
        datasync(): Promise<void>;
        /**
         * Request that all data for the open file descriptor is flushed to the storage
         * device. The specific implementation is operating system and device specific.
         * Refer to the POSIX [`fsync(2)`](http://man7.org/linux/man-pages/man2/fsync.2.html) documentation for more detail.
         * @since v10.0.0
         * @return Fulfills with `undefined` upon success.
         */
        sync(): Promise<void>;
        /**
         * Reads data from the file and stores that in the given buffer.
         *
         * If the file is not modified concurrently, the end-of-file is reached when the
         * number of bytes read is zero.
         * @since v10.0.0
         * @param buffer A buffer that will be filled with the file data read.
         * @param offset The location in the buffer at which to start filling.
         * @param length The number of bytes to read.
         * @param position The location where to begin reading data from the file. If `null`, data will be read from the current file position, and the position will be updated. If `position` is an
         * integer, the current file position will remain unchanged.
         * @return Fulfills upon success with an object with two properties:
         */
        read<T extends NodeJS.ArrayBufferView>(
            buffer: T,
            offset?: number | null,
            length?: number | null,
            position?: number | null,
        ): Promise<FileReadResult<T>>;
        read<T extends NodeJS.ArrayBufferView = Buffer>(options?: FileReadOptions<T>): Promise<FileReadResult<T>>;
        /**
         * Returns a `ReadableStream` that may be used to read the files data.
         *
         * An error will be thrown if this method is called more than once or is called
         * after the `FileHandle` is closed or closing.
         *
         * ```js
         * import {
         *   open,
         * } from 'node:fs/promises';
         *
         * const file = await open('./some/file/to/read');
         *
         * for await (const chunk of file.readableWebStream())
         *   console.log(chunk);
         *
         * await file.close();
         * ```
         *
         * While the `ReadableStream` will read the file to completion, it will not
         * close the `FileHandle` automatically. User code must still call the`fileHandle.close()` method.
         * @since v17.0.0
         * @experimental
         */
        readableWebStream(options?: ReadableWebStreamOptions): ReadableStream;
        /**
         * Asynchronously reads the entire contents of a file.
         *
         * If `options` is a string, then it specifies the `encoding`.
         *
         * The `FileHandle` has to support reading.
         *
         * If one or more `filehandle.read()` calls are made on a file handle and then a `filehandle.readFile()` call is made, the data will be read from the current
         * position till the end of the file. It doesn't always read from the beginning
         * of the file.
         * @since v10.0.0
         * @return Fulfills upon a successful read with the contents of the file. If no encoding is specified (using `options.encoding`), the data is returned as a {Buffer} object. Otherwise, the
         * data will be a string.
         */
        readFile(
            options?: {
                encoding?: null | undefined;
                flag?: OpenMode | undefined;
            } | null,
        ): Promise<Buffer>;
        /**
         * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.
         * The `FileHandle` must have been opened for reading.
         * @param options An object that may contain an optional flag.
         * If a flag is not provided, it defaults to `'r'`.
         */
        readFile(
            options:
                | {
                    encoding: BufferEncoding;
                    flag?: OpenMode | undefined;
                }
                | BufferEncoding,
        ): Promise<string>;
        /**
         * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.
         * The `FileHandle` must have been opened for reading.
         * @param options An object that may contain an optional flag.
         * If a flag is not provided, it defaults to `'r'`.
         */
        readFile(
            options?:
                | (ObjectEncodingOptions & {
                    flag?: OpenMode | undefined;
                })
                | BufferEncoding
                | null,
        ): Promise<string | Buffer>;
        /**
         * Convenience method to create a `readline` interface and stream over the file.
         * See `filehandle.createReadStream()` for the options.
         *
         * ```js
         * import { open } from 'node:fs/promises';
         *
         * const file = await open('./some/file/to/read');
         *
         * for await (const line of file.readLines()) {
         *   console.log(line);
         * }
         * ```
         * @since v18.11.0
         */
        readLines(options?: CreateReadStreamOptions): ReadlineInterface;
        /**
         * @since v10.0.0
         * @return Fulfills with an {fs.Stats} for the file.
         */
        stat(
            opts?: StatOptions & {
                bigint?: false | undefined;
            },
        ): Promise<Stats>;
        stat(
            opts: StatOptions & {
                bigint: true;
            },
        ): Promise<BigIntStats>;
        stat(opts?: StatOptions): Promise<Stats | BigIntStats>;
        /**
         * Truncates the file.
         *
         * If the file was larger than `len` bytes, only the first `len` bytes will be
         * retained in the file.
         *
         * The following example retains only the first four bytes of the file:
         *
         * ```js
         * import { open } from 'node:fs/promises';
         *
         * let filehandle = null;
         * try {
         *   filehandle = await open('temp.txt', 'r+');
         *   await filehandle.truncate(4);
         * } finally {
         *   await filehandle?.close();
         * }
         * ```
         *
         * If the file previously was shorter than `len` bytes, it is extended, and the
         * extended part is filled with null bytes (`'\0'`):
         *
         * If `len` is negative then `0` will be used.
         * @since v10.0.0
         * @param [len=0]
         * @return Fulfills with `undefined` upon success.
         */
        truncate(len?: number): Promise<void>;
        /**
         * Change the file system timestamps of the object referenced by the `FileHandle` then fulfills the promise with no arguments upon success.
         * @since v10.0.0
         */
        utimes(atime: TimeLike, mtime: TimeLike): Promise<void>;
        /**
         * Asynchronously writes data to a file, replacing the file if it already exists. `data` can be a string, a buffer, an
         * [AsyncIterable](https://tc39.github.io/ecma262/#sec-asynciterable-interface), or an
         * [Iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol) object.
         * The promise is fulfilled with no arguments upon success.
         *
         * If `options` is a string, then it specifies the `encoding`.
         *
         * The `FileHandle` has to support writing.
         *
         * It is unsafe to use `filehandle.writeFile()` multiple times on the same file
         * without waiting for the promise to be fulfilled (or rejected).
         *
         * If one or more `filehandle.write()` calls are made on a file handle and then a`filehandle.writeFile()` call is made, the data will be written from the
         * current position till the end of the file. It doesn't always write from the
         * beginning of the file.
         * @since v10.0.0
         */
        writeFile(
            data: string | Uint8Array,
            options?:
                | (ObjectEncodingOptions & FlagAndOpenMode & Abortable & { flush?: boolean | undefined })
                | BufferEncoding
                | null,
        ): Promise<void>;
        /**
         * Write `buffer` to the file.
         *
         * The promise is fulfilled with an object containing two properties:
         *
         * It is unsafe to use `filehandle.write()` multiple times on the same file
         * without waiting for the promise to be fulfilled (or rejected). For this
         * scenario, use `filehandle.createWriteStream()`.
         *
         * On Linux, positional writes do not work when the file is opened in append mode.
         * The kernel ignores the position argument and always appends the data to
         * the end of the file.
         * @since v10.0.0
         * @param offset The start position from within `buffer` where the data to write begins.
         * @param [length=buffer.byteLength - offset] The number of bytes from `buffer` to write.
         * @param [position='null'] The offset from the beginning of the file where the data from `buffer` should be written. If `position` is not a `number`, the data will be written at the current
         * position. See the POSIX pwrite(2) documentation for more detail.
         */
        write<TBuffer extends Uint8Array>(
            buffer: TBuffer,
            offset?: number | null,
            length?: number | null,
            position?: number | null,
        ): Promise<{
            bytesWritten: number;
            buffer: TBuffer;
        }>;
        write(
            data: string,
            position?: number | null,
            encoding?: BufferEncoding | null,
        ): Promise<{
            bytesWritten: number;
            buffer: string;
        }>;
        /**
         * Write an array of [ArrayBufferView](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView) s to the file.
         *
         * The promise is fulfilled with an object containing a two properties:
         *
         * It is unsafe to call `writev()` multiple times on the same file without waiting
         * for the promise to be fulfilled (or rejected).
         *
         * On Linux, positional writes don't work when the file is opened in append mode.
         * The kernel ignores the position argument and always appends the data to
         * the end of the file.
         * @since v12.9.0
         * @param [position='null'] The offset from the beginning of the file where the data from `buffers` should be written. If `position` is not a `number`, the data will be written at the current
         * position.
         */
        writev(buffers: readonly NodeJS.ArrayBufferView[], position?: number): Promise<WriteVResult>;
        /**
         * Read from a file and write to an array of [ArrayBufferView](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView) s
         * @since v13.13.0, v12.17.0
         * @param [position='null'] The offset from the beginning of the file where the data should be read from. If `position` is not a `number`, the data will be read from the current position.
         * @return Fulfills upon success an object containing two properties:
         */
        readv(buffers: readonly NodeJS.ArrayBufferView[], position?: number): Promise<ReadVResult>;
        /**
         * Closes the file handle after waiting for any pending operation on the handle to
         * complete.
         *
         * ```js
         * import { open } from 'node:fs/promises';
         *
         * let filehandle;
         * try {
         *   filehandle = await open('thefile.txt', 'r');
         * } finally {
         *   await filehandle?.close();
         * }
         * ```
         * @since v10.0.0
         * @return Fulfills with `undefined` upon success.
         */
        close(): Promise<void>;
        /**
         * An alias for {@link FileHandle.close()}.
         * @since v20.4.0
         */
        [Symbol.asyncDispose](): Promise<void>;
    }
    const constants: typeof fsConstants;
    /**
     * Tests a user's permissions for the file or directory specified by `path`.
     * The `mode` argument is an optional integer that specifies the accessibility
     * checks to be performed. `mode` should be either the value `fs.constants.F_OK` or a mask consisting of the bitwise OR of any of `fs.constants.R_OK`, `fs.constants.W_OK`, and `fs.constants.X_OK`
     * (e.g.`fs.constants.W_OK | fs.constants.R_OK`). Check `File access constants` for
     * possible values of `mode`.
     *
     * If the accessibility check is successful, the promise is fulfilled with no
     * value. If any of the accessibility checks fail, the promise is rejected
     * with an [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) object. The following example checks if the file`/etc/passwd` can be read and
     * written by the current process.
     *
     * ```js
     * import { access, constants } from 'node:fs/promises';
     *
     * try {
     *   await access('/etc/passwd', constants.R_OK | constants.W_OK);
     *   console.log('can access');
     * } catch {
     *   console.error('cannot access');
     * }
     * ```
     *
     * Using `fsPromises.access()` to check for the accessibility of a file before
     * calling `fsPromises.open()` is not recommended. Doing so introduces a race
     * condition, since other processes may change the file's state between the two
     * calls. Instead, user code should open/read/write the file directly and handle
     * the error raised if the file is not accessible.
     * @since v10.0.0
     * @param [mode=fs.constants.F_OK]
     * @return Fulfills with `undefined` upon success.
     */
    function access(path: PathLike, mode?: number): Promise<void>;
    /**
     * Asynchronously copies `src` to `dest`. By default, `dest` is overwritten if it
     * already exists.
     *
     * No guarantees are made about the atomicity of the copy operation. If an
     * error occurs after the destination file has been opened for writing, an attempt
     * will be made to remove the destination.
     *
     * ```js
     * import { copyFile, constants } from 'node:fs/promises';
     *
     * try {
     *   await copyFile('source.txt', 'destination.txt');
     *   console.log('source.txt was copied to destination.txt');
     * } catch {
     *   console.error('The file could not be copied');
     * }
     *
     * // By using COPYFILE_EXCL, the operation will fail if destination.txt exists.
     * try {
     *   await copyFile('source.txt', 'destination.txt', constants.COPYFILE_EXCL);
     *   console.log('source.txt was copied to destination.txt');
     * } catch {
     *   console.error('The file could not be copied');
     * }
     * ```
     * @since v10.0.0
     * @param src source filename to copy
     * @param dest destination filename of the copy operation
     * @param [mode=0] Optional modifiers that specify the behavior of the copy operation. It is possible to create a mask consisting of the bitwise OR of two or more values (e.g.
     * `fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE`)
     * @return Fulfills with `undefined` upon success.
     */
    function copyFile(src: PathLike, dest: PathLike, mode?: number): Promise<void>;
    /**
     * Opens a `FileHandle`.
     *
     * Refer to the POSIX [`open(2)`](http://man7.org/linux/man-pages/man2/open.2.html) documentation for more detail.
     *
     * Some characters (`< > : " / \ | ? *`) are reserved under Windows as documented
     * by [Naming Files, Paths, and Namespaces](https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file). Under NTFS, if the filename contains
     * a colon, Node.js will open a file system stream, as described by [this MSDN page](https://docs.microsoft.com/en-us/windows/desktop/FileIO/using-streams).
     * @since v10.0.0
     * @param [flags='r'] See `support of file system `flags``.
     * @param [mode=0o666] Sets the file mode (permission and sticky bits) if the file is created.
     * @return Fulfills with a {FileHandle} object.
     */
    function open(path: PathLike, flags?: string | number, mode?: Mode): Promise<FileHandle>;
    /**
     * Renames `oldPath` to `newPath`.
     * @since v10.0.0
     * @return Fulfills with `undefined` upon success.
     */
    function rename(oldPath: PathLike, newPath: PathLike): Promise<void>;
    /**
     * Truncates (shortens or extends the length) of the content at `path` to `len` bytes.
     * @since v10.0.0
     * @param [len=0]
     * @return Fulfills with `undefined` upon success.
     */
    function truncate(path: PathLike, len?: number): Promise<void>;
    /**
     * Removes the directory identified by `path`.
     *
     * Using `fsPromises.rmdir()` on a file (not a directory) results in the
     * promise being rejected with an `ENOENT` error on Windows and an `ENOTDIR` error on POSIX.
     *
     * To get a behavior similar to the `rm -rf` Unix command, use `fsPromises.rm()` with options `{ recursive: true, force: true }`.
     * @since v10.0.0
     * @return Fulfills with `undefined` upon success.
     */
    function rmdir(path: PathLike, options?: RmDirOptions): Promise<void>;
    /**
     * Removes files and directories (modeled on the standard POSIX `rm` utility).
     * @since v14.14.0
     * @return Fulfills with `undefined` upon success.
     */
    function rm(path: PathLike, options?: RmOptions): Promise<void>;
    /**
     * Asynchronously creates a directory.
     *
     * The optional `options` argument can be an integer specifying `mode` (permission
     * and sticky bits), or an object with a `mode` property and a `recursive` property indicating whether parent directories should be created. Calling `fsPromises.mkdir()` when `path` is a directory
     * that exists results in a
     * rejection only when `recursive` is false.
     *
     * ```js
     * import { mkdir } from 'node:fs/promises';
     *
     * try {
     *   const projectFolder = new URL('./test/project/', import.meta.url);
     *   const createDir = await mkdir(projectFolder, { recursive: true });
     *
     *   console.log(`created ${createDir}`);
     * } catch (err) {
     *   console.error(err.message);
     * }
     * ```
     * @since v10.0.0
     * @return Upon success, fulfills with `undefined` if `recursive` is `false`, or the first directory path created if `recursive` is `true`.
     */
    function mkdir(
        path: PathLike,
        options: MakeDirectoryOptions & {
            recursive: true;
        },
    ): Promise<string | undefined>;
    /**
     * Asynchronous mkdir(2) - create a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
     */
    function mkdir(
        path: PathLike,
        options?:
            | Mode
            | (MakeDirectoryOptions & {
                recursive?: false | undefined;
            })
            | null,
    ): Promise<void>;
    /**
     * Asynchronous mkdir(2) - create a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
     */
    function mkdir(path: PathLike, options?: Mode | MakeDirectoryOptions | null): Promise<string | undefined>;
    /**
     * Reads the contents of a directory.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use for
     * the filenames. If the `encoding` is set to `'buffer'`, the filenames returned
     * will be passed as `Buffer` objects.
     *
     * If `options.withFileTypes` is set to `true`, the returned array will contain `fs.Dirent` objects.
     *
     * ```js
     * import { readdir } from 'node:fs/promises';
     *
     * try {
     *   const files = await readdir(path);
     *   for (const file of files)
     *     console.log(file);
     * } catch (err) {
     *   console.error(err);
     * }
     * ```
     * @since v10.0.0
     * @return Fulfills with an array of the names of the files in the directory excluding `'.'` and `'..'`.
     */
    function readdir(
        path: PathLike,
        options?:
            | (ObjectEncodingOptions & {
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            })
            | BufferEncoding
            | null,
    ): Promise<string[]>;
    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function readdir(
        path: PathLike,
        options:
            | {
                encoding: "buffer";
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            }
            | "buffer",
    ): Promise<Buffer[]>;
    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function readdir(
        path: PathLike,
        options?:
            | (ObjectEncodingOptions & {
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            })
            | BufferEncoding
            | null,
    ): Promise<string[] | Buffer[]>;
    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.
     */
    function readdir(
        path: PathLike,
        options: ObjectEncodingOptions & {
            withFileTypes: true;
            recursive?: boolean | undefined;
        },
    ): Promise<Dirent[]>;
    /**
     * Reads the contents of the symbolic link referred to by `path`. See the POSIX [`readlink(2)`](http://man7.org/linux/man-pages/man2/readlink.2.html) documentation for more detail. The promise is
     * fulfilled with the`linkString` upon success.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use for
     * the link path returned. If the `encoding` is set to `'buffer'`, the link path
     * returned will be passed as a `Buffer` object.
     * @since v10.0.0
     * @return Fulfills with the `linkString` upon success.
     */
    function readlink(path: PathLike, options?: ObjectEncodingOptions | BufferEncoding | null): Promise<string>;
    /**
     * Asynchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function readlink(path: PathLike, options: BufferEncodingOption): Promise<Buffer>;
    /**
     * Asynchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function readlink(path: PathLike, options?: ObjectEncodingOptions | string | null): Promise<string | Buffer>;
    /**
     * Creates a symbolic link.
     *
     * The `type` argument is only used on Windows platforms and can be one of `'dir'`, `'file'`, or `'junction'`. If the `type` argument is not a string, Node.js will
     * autodetect `target` type and use `'file'` or `'dir'`. If the `target` does not
     * exist, `'file'` will be used. Windows junction points require the destination
     * path to be absolute. When using `'junction'`, the `target` argument will
     * automatically be normalized to absolute path. Junction points on NTFS volumes
     * can only point to directories.
     * @since v10.0.0
     * @param [type='null']
     * @return Fulfills with `undefined` upon success.
     */
    function symlink(target: PathLike, path: PathLike, type?: string | null): Promise<void>;
    /**
     * Equivalent to `fsPromises.stat()` unless `path` refers to a symbolic link,
     * in which case the link itself is stat-ed, not the file that it refers to.
     * Refer to the POSIX [`lstat(2)`](http://man7.org/linux/man-pages/man2/lstat.2.html) document for more detail.
     * @since v10.0.0
     * @return Fulfills with the {fs.Stats} object for the given symbolic link `path`.
     */
    function lstat(
        path: PathLike,
        opts?: StatOptions & {
            bigint?: false | undefined;
        },
    ): Promise<Stats>;
    function lstat(
        path: PathLike,
        opts: StatOptions & {
            bigint: true;
        },
    ): Promise<BigIntStats>;
    function lstat(path: PathLike, opts?: StatOptions): Promise<Stats | BigIntStats>;
    /**
     * @since v10.0.0
     * @return Fulfills with the {fs.Stats} object for the given `path`.
     */
    function stat(
        path: PathLike,
        opts?: StatOptions & {
            bigint?: false | undefined;
        },
    ): Promise<Stats>;
    function stat(
        path: PathLike,
        opts: StatOptions & {
            bigint: true;
        },
    ): Promise<BigIntStats>;
    function stat(path: PathLike, opts?: StatOptions): Promise<Stats | BigIntStats>;
    /**
     * @since v19.6.0, v18.15.0
     * @return Fulfills with the {fs.StatFs} object for the given `path`.
     */
    function statfs(
        path: PathLike,
        opts?: StatFsOptions & {
            bigint?: false | undefined;
        },
    ): Promise<StatsFs>;
    function statfs(
        path: PathLike,
        opts: StatFsOptions & {
            bigint: true;
        },
    ): Promise<BigIntStatsFs>;
    function statfs(path: PathLike, opts?: StatFsOptions): Promise<StatsFs | BigIntStatsFs>;
    /**
     * Creates a new link from the `existingPath` to the `newPath`. See the POSIX [`link(2)`](http://man7.org/linux/man-pages/man2/link.2.html) documentation for more detail.
     * @since v10.0.0
     * @return Fulfills with `undefined` upon success.
     */
    function link(existingPath: PathLike, newPath: PathLike): Promise<void>;
    /**
     * If `path` refers to a symbolic link, then the link is removed without affecting
     * the file or directory to which that link refers. If the `path` refers to a file
     * path that is not a symbolic link, the file is deleted. See the POSIX [`unlink(2)`](http://man7.org/linux/man-pages/man2/unlink.2.html) documentation for more detail.
     * @since v10.0.0
     * @return Fulfills with `undefined` upon success.
     */
    function unlink(path: PathLike): Promise<void>;
    /**
     * Changes the permissions of a file.
     * @since v10.0.0
     * @return Fulfills with `undefined` upon success.
     */
    function chmod(path: PathLike, mode: Mode): Promise<void>;
    /**
     * Changes the permissions on a symbolic link.
     *
     * This method is only implemented on macOS.
     * @deprecated Since v10.0.0
     * @return Fulfills with `undefined` upon success.
     */
    function lchmod(path: PathLike, mode: Mode): Promise<void>;
    /**
     * Changes the ownership on a symbolic link.
     * @since v10.0.0
     * @return Fulfills with `undefined` upon success.
     */
    function lchown(path: PathLike, uid: number, gid: number): Promise<void>;
    /**
     * Changes the access and modification times of a file in the same way as `fsPromises.utimes()`, with the difference that if the path refers to a
     * symbolic link, then the link is not dereferenced: instead, the timestamps of
     * the symbolic link itself are changed.
     * @since v14.5.0, v12.19.0
     * @return Fulfills with `undefined` upon success.
     */
    function lutimes(path: PathLike, atime: TimeLike, mtime: TimeLike): Promise<void>;
    /**
     * Changes the ownership of a file.
     * @since v10.0.0
     * @return Fulfills with `undefined` upon success.
     */
    function chown(path: PathLike, uid: number, gid: number): Promise<void>;
    /**
     * Change the file system timestamps of the object referenced by `path`.
     *
     * The `atime` and `mtime` arguments follow these rules:
     *
     * * Values can be either numbers representing Unix epoch time, `Date`s, or a
     * numeric string like `'123456789.0'`.
     * * If the value can not be converted to a number, or is `NaN`, `Infinity`, or `-Infinity`, an `Error` will be thrown.
     * @since v10.0.0
     * @return Fulfills with `undefined` upon success.
     */
    function utimes(path: PathLike, atime: TimeLike, mtime: TimeLike): Promise<void>;
    /**
     * Determines the actual location of `path` using the same semantics as the `fs.realpath.native()` function.
     *
     * Only paths that can be converted to UTF8 strings are supported.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use for
     * the path. If the `encoding` is set to `'buffer'`, the path returned will be
     * passed as a `Buffer` object.
     *
     * On Linux, when Node.js is linked against musl libc, the procfs file system must
     * be mounted on `/proc` in order for this function to work. Glibc does not have
     * this restriction.
     * @since v10.0.0
     * @return Fulfills with the resolved path upon success.
     */
    function realpath(path: PathLike, options?: ObjectEncodingOptions | BufferEncoding | null): Promise<string>;
    /**
     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function realpath(path: PathLike, options: BufferEncodingOption): Promise<Buffer>;
    /**
     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function realpath(
        path: PathLike,
        options?: ObjectEncodingOptions | BufferEncoding | null,
    ): Promise<string | Buffer>;
    /**
     * Creates a unique temporary directory. A unique directory name is generated by
     * appending six random characters to the end of the provided `prefix`. Due to
     * platform inconsistencies, avoid trailing `X` characters in `prefix`. Some
     * platforms, notably the BSDs, can return more than six random characters, and
     * replace trailing `X` characters in `prefix` with random characters.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use.
     *
     * ```js
     * import { mkdtemp } from 'node:fs/promises';
     * import { join } from 'node:path';
     * import { tmpdir } from 'node:os';
     *
     * try {
     *   await mkdtemp(join(tmpdir(), 'foo-'));
     * } catch (err) {
     *   console.error(err);
     * }
     * ```
     *
     * The `fsPromises.mkdtemp()` method will append the six randomly selected
     * characters directly to the `prefix` string. For instance, given a directory `/tmp`, if the intention is to create a temporary directory _within_ `/tmp`, the `prefix` must end with a trailing
     * platform-specific path separator
     * (`require('node:path').sep`).
     * @since v10.0.0
     * @return Fulfills with a string containing the file system path of the newly created temporary directory.
     */
    function mkdtemp(prefix: string, options?: ObjectEncodingOptions | BufferEncoding | null): Promise<string>;
    /**
     * Asynchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function mkdtemp(prefix: string, options: BufferEncodingOption): Promise<Buffer>;
    /**
     * Asynchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function mkdtemp(prefix: string, options?: ObjectEncodingOptions | BufferEncoding | null): Promise<string | Buffer>;
    /**
     * Asynchronously writes data to a file, replacing the file if it already exists. `data` can be a string, a buffer, an
     * [AsyncIterable](https://tc39.github.io/ecma262/#sec-asynciterable-interface), or an
     * [Iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol) object.
     *
     * The `encoding` option is ignored if `data` is a buffer.
     *
     * If `options` is a string, then it specifies the encoding.
     *
     * The `mode` option only affects the newly created file. See `fs.open()` for more details.
     *
     * Any specified `FileHandle` has to support writing.
     *
     * It is unsafe to use `fsPromises.writeFile()` multiple times on the same file
     * without waiting for the promise to be settled.
     *
     * Similarly to `fsPromises.readFile` \- `fsPromises.writeFile` is a convenience
     * method that performs multiple `write` calls internally to write the buffer
     * passed to it. For performance sensitive code consider using `fs.createWriteStream()` or `filehandle.createWriteStream()`.
     *
     * It is possible to use an `AbortSignal` to cancel an `fsPromises.writeFile()`.
     * Cancelation is "best effort", and some amount of data is likely still
     * to be written.
     *
     * ```js
     * import { writeFile } from 'node:fs/promises';
     * import { Buffer } from 'node:buffer';
     *
     * try {
     *   const controller = new AbortController();
     *   const { signal } = controller;
     *   const data = new Uint8Array(Buffer.from('Hello Node.js'));
     *   const promise = writeFile('message.txt', data, { signal });
     *
     *   // Abort the request before the promise settles.
     *   controller.abort();
     *
     *   await promise;
     * } catch (err) {
     *   // When a request is aborted - err is an AbortError
     *   console.error(err);
     * }
     * ```
     *
     * Aborting an ongoing request does not abort individual operating
     * system requests but rather the internal buffering `fs.writeFile` performs.
     * @since v10.0.0
     * @param file filename or `FileHandle`
     * @return Fulfills with `undefined` upon success.
     */
    function writeFile(
        file: PathLike | FileHandle,
        data:
            | string
            | NodeJS.ArrayBufferView
            | Iterable<string | NodeJS.ArrayBufferView>
            | AsyncIterable<string | NodeJS.ArrayBufferView>
            | Stream,
        options?:
            | (ObjectEncodingOptions & {
                mode?: Mode | undefined;
                flag?: OpenMode | undefined;
                /**
                 * If all data is successfully written to the file, and `flush`
                 * is `true`, `filehandle.sync()` is used to flush the data.
                 * @default false
                 */
                flush?: boolean | undefined;
            } & Abortable)
            | BufferEncoding
            | null,
    ): Promise<void>;
    /**
     * Asynchronously append data to a file, creating the file if it does not yet
     * exist. `data` can be a string or a `Buffer`.
     *
     * If `options` is a string, then it specifies the `encoding`.
     *
     * The `mode` option only affects the newly created file. See `fs.open()` for more details.
     *
     * The `path` may be specified as a `FileHandle` that has been opened
     * for appending (using `fsPromises.open()`).
     * @since v10.0.0
     * @param path filename or {FileHandle}
     * @return Fulfills with `undefined` upon success.
     */
    function appendFile(
        path: PathLike | FileHandle,
        data: string | Uint8Array,
        options?: (ObjectEncodingOptions & FlagAndOpenMode & { flush?: boolean | undefined }) | BufferEncoding | null,
    ): Promise<void>;
    /**
     * Asynchronously reads the entire contents of a file.
     *
     * If no encoding is specified (using `options.encoding`), the data is returned
     * as a `Buffer` object. Otherwise, the data will be a string.
     *
     * If `options` is a string, then it specifies the encoding.
     *
     * When the `path` is a directory, the behavior of `fsPromises.readFile()` is
     * platform-specific. On macOS, Linux, and Windows, the promise will be rejected
     * with an error. On FreeBSD, a representation of the directory's contents will be
     * returned.
     *
     * An example of reading a `package.json` file located in the same directory of the
     * running code:
     *
     * ```js
     * import { readFile } from 'node:fs/promises';
     * try {
     *   const filePath = new URL('./package.json', import.meta.url);
     *   const contents = await readFile(filePath, { encoding: 'utf8' });
     *   console.log(contents);
     * } catch (err) {
     *   console.error(err.message);
     * }
     * ```
     *
     * It is possible to abort an ongoing `readFile` using an `AbortSignal`. If a
     * request is aborted the promise returned is rejected with an `AbortError`:
     *
     * ```js
     * import { readFile } from 'node:fs/promises';
     *
     * try {
     *   const controller = new AbortController();
     *   const { signal } = controller;
     *   const promise = readFile(fileName, { signal });
     *
     *   // Abort the request before the promise settles.
     *   controller.abort();
     *
     *   await promise;
     * } catch (err) {
     *   // When a request is aborted - err is an AbortError
     *   console.error(err);
     * }
     * ```
     *
     * Aborting an ongoing request does not abort individual operating
     * system requests but rather the internal buffering `fs.readFile` performs.
     *
     * Any specified `FileHandle` has to support reading.
     * @since v10.0.0
     * @param path filename or `FileHandle`
     * @return Fulfills with the contents of the file.
     */
    function readFile(
        path: PathLike | FileHandle,
        options?:
            | ({
                encoding?: null | undefined;
                flag?: OpenMode | undefined;
            } & Abortable)
            | null,
    ): Promise<Buffer>;
    /**
     * Asynchronously reads the entire contents of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.
     * @param options An object that may contain an optional flag.
     * If a flag is not provided, it defaults to `'r'`.
     */
    function readFile(
        path: PathLike | FileHandle,
        options:
            | ({
                encoding: BufferEncoding;
                flag?: OpenMode | undefined;
            } & Abortable)
            | BufferEncoding,
    ): Promise<string>;
    /**
     * Asynchronously reads the entire contents of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.
     * @param options An object that may contain an optional flag.
     * If a flag is not provided, it defaults to `'r'`.
     */
    function readFile(
        path: PathLike | FileHandle,
        options?:
            | (
                & ObjectEncodingOptions
                & Abortable
                & {
                    flag?: OpenMode | undefined;
                }
            )
            | BufferEncoding
            | null,
    ): Promise<string | Buffer>;
    /**
     * Asynchronously open a directory for iterative scanning. See the POSIX [`opendir(3)`](http://man7.org/linux/man-pages/man3/opendir.3.html) documentation for more detail.
     *
     * Creates an `fs.Dir`, which contains all further functions for reading from
     * and cleaning up the directory.
     *
     * The `encoding` option sets the encoding for the `path` while opening the
     * directory and subsequent read operations.
     *
     * Example using async iteration:
     *
     * ```js
     * import { opendir } from 'node:fs/promises';
     *
     * try {
     *   const dir = await opendir('./');
     *   for await (const dirent of dir)
     *     console.log(dirent.name);
     * } catch (err) {
     *   console.error(err);
     * }
     * ```
     *
     * When using the async iterator, the `fs.Dir` object will be automatically
     * closed after the iterator exits.
     * @since v12.12.0
     * @return Fulfills with an {fs.Dir}.
     */
    function opendir(path: PathLike, options?: OpenDirOptions): Promise<Dir>;
    /**
     * Returns an async iterator that watches for changes on `filename`, where `filename`is either a file or a directory.
     *
     * ```js
     * const { watch } = require('node:fs/promises');
     *
     * const ac = new AbortController();
     * const { signal } = ac;
     * setTimeout(() => ac.abort(), 10000);
     *
     * (async () => {
     *   try {
     *     const watcher = watch(__filename, { signal });
     *     for await (const event of watcher)
     *       console.log(event);
     *   } catch (err) {
     *     if (err.name === 'AbortError')
     *       return;
     *     throw err;
     *   }
     * })();
     * ```
     *
     * On most platforms, `'rename'` is emitted whenever a filename appears or
     * disappears in the directory.
     *
     * All the `caveats` for `fs.watch()` also apply to `fsPromises.watch()`.
     * @since v15.9.0, v14.18.0
     * @return of objects with the properties:
     */
    function watch(
        filename: PathLike,
        options:
            | (WatchOptions & {
                encoding: "buffer";
            })
            | "buffer",
    ): AsyncIterable<FileChangeInfo<Buffer>>;
    /**
     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.
     * If `encoding` is not supplied, the default of `'utf8'` is used.
     * If `persistent` is not supplied, the default of `true` is used.
     * If `recursive` is not supplied, the default of `false` is used.
     */
    function watch(filename: PathLike, options?: WatchOptions | BufferEncoding): AsyncIterable<FileChangeInfo<string>>;
    /**
     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.
     * If `encoding` is not supplied, the default of `'utf8'` is used.
     * If `persistent` is not supplied, the default of `true` is used.
     * If `recursive` is not supplied, the default of `false` is used.
     */
    function watch(
        filename: PathLike,
        options: WatchOptions | string,
    ): AsyncIterable<FileChangeInfo<string>> | AsyncIterable<FileChangeInfo<Buffer>>;
    /**
     * Asynchronously copies the entire directory structure from `src` to `dest`,
     * including subdirectories and files.
     *
     * When copying a directory to another directory, globs are not supported and
     * behavior is similar to `cp dir1/ dir2/`.
     * @since v16.7.0
     * @experimental
     * @param src source path to copy.
     * @param dest destination path to copy to.
     * @return Fulfills with `undefined` upon success.
     */
    function cp(source: string | URL, destination: string | URL, opts?: CopyOptions): Promise<void>;
    /**
     * Retrieves the files matching the specified pattern.
     */
    function glob(pattern: string | string[]): AsyncIterableIterator<string>;
    function glob(
        pattern: string | string[],
        opt: GlobOptionsWithFileTypes,
    ): AsyncIterableIterator<Dirent>;
    function glob(
        pattern: string | string[],
        opt: GlobOptionsWithoutFileTypes,
    ): AsyncIterableIterator<string>;
    function glob(
        pattern: string | string[],
        opt: GlobOptions,
    ): AsyncIterableIterator<Dirent> | AsyncIterableIterator<string>;
}
declare module "node:fs/promises" {
    export * from "fs/promises";
}
export {}; // Make this a module

// #region Fetch and friends
// Conditional type aliases, used at the end of this file.
// Will either be empty if lib.dom (or lib.webworker) is included, or the undici version otherwise.
type _Request = typeof globalThis extends { onmessage: any } ? {} : import("undici-types").Request;
type _Response = typeof globalThis extends { onmessage: any } ? {} : import("undici-types").Response;
type _FormData = typeof globalThis extends { onmessage: any } ? {} : import("undici-types").FormData;
type _Headers = typeof globalThis extends { onmessage: any } ? {} : import("undici-types").Headers;
type _MessageEvent = typeof globalThis extends { onmessage: any } ? {} : import("undici-types").MessageEvent;
type _RequestInit = typeof globalThis extends { onmessage: any } ? {}
    : import("undici-types").RequestInit;
type _ResponseInit = typeof globalThis extends { onmessage: any } ? {}
    : import("undici-types").ResponseInit;
type _WebSocket = typeof globalThis extends { onmessage: any } ? {} : import("undici-types").WebSocket;
type _EventSource = typeof globalThis extends { onmessage: any } ? {} : import("undici-types").EventSource;
// #endregion Fetch and friends

// Conditional type definitions for webstorage interface, which conflicts with lib.dom otherwise.
type _Storage = typeof globalThis extends { onabort: any } ? {} : {
    /**
     * Returns the number of key/value pairs.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Storage/length)
     */
    readonly length: number;
    /**
     * Removes all key/value pairs, if there are any.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Storage/clear)
     */
    clear(): void;
    /**
     * Returns the current value associated with the given key, or null if the given key does not exist.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Storage/getItem)
     */
    getItem(key: string): string | null;
    /**
     * Returns the name of the nth key, or null if n is greater than or equal to the number of key/value pairs.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Storage/key)
     */
    key(index: number): string | null;
    /**
     * Removes the key/value pair with the given key, if a key/value pair with the given key exists.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Storage/removeItem)
     */
    removeItem(key: string): void;
    /**
     * Sets the value of the pair identified by key to value, creating a new key/value pair if none existed for key previously.
     *
     * Throws a "QuotaExceededError" DOMException exception if the new value couldn't be set.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Storage/setItem)
     */
    setItem(key: string, value: string): void;
    [key: string]: any;
};

// #region DOMException
type _DOMException = typeof globalThis extends { onmessage: any } ? {} : NodeDOMException;
interface NodeDOMException extends Error {
    /**
     * @deprecated
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMException/code)
     */
    readonly code: number;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMException/message) */
    readonly message: string;
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMException/name) */
    readonly name: string;
    readonly INDEX_SIZE_ERR: 1;
    readonly DOMSTRING_SIZE_ERR: 2;
    readonly HIERARCHY_REQUEST_ERR: 3;
    readonly WRONG_DOCUMENT_ERR: 4;
    readonly INVALID_CHARACTER_ERR: 5;
    readonly NO_DATA_ALLOWED_ERR: 6;
    readonly NO_MODIFICATION_ALLOWED_ERR: 7;
    readonly NOT_FOUND_ERR: 8;
    readonly NOT_SUPPORTED_ERR: 9;
    readonly INUSE_ATTRIBUTE_ERR: 10;
    readonly INVALID_STATE_ERR: 11;
    readonly SYNTAX_ERR: 12;
    readonly INVALID_MODIFICATION_ERR: 13;
    readonly NAMESPACE_ERR: 14;
    readonly INVALID_ACCESS_ERR: 15;
    readonly VALIDATION_ERR: 16;
    readonly TYPE_MISMATCH_ERR: 17;
    readonly SECURITY_ERR: 18;
    readonly NETWORK_ERR: 19;
    readonly ABORT_ERR: 20;
    readonly URL_MISMATCH_ERR: 21;
    readonly QUOTA_EXCEEDED_ERR: 22;
    readonly TIMEOUT_ERR: 23;
    readonly INVALID_NODE_TYPE_ERR: 24;
    readonly DATA_CLONE_ERR: 25;
}
interface NodeDOMExceptionConstructor {
    prototype: DOMException;
    new(message?: string, nameOrOptions?: string | { name?: string; cause?: unknown }): DOMException;
    readonly INDEX_SIZE_ERR: 1;
    readonly DOMSTRING_SIZE_ERR: 2;
    readonly HIERARCHY_REQUEST_ERR: 3;
    readonly WRONG_DOCUMENT_ERR: 4;
    readonly INVALID_CHARACTER_ERR: 5;
    readonly NO_DATA_ALLOWED_ERR: 6;
    readonly NO_MODIFICATION_ALLOWED_ERR: 7;
    readonly NOT_FOUND_ERR: 8;
    readonly NOT_SUPPORTED_ERR: 9;
    readonly INUSE_ATTRIBUTE_ERR: 10;
    readonly INVALID_STATE_ERR: 11;
    readonly SYNTAX_ERR: 12;
    readonly INVALID_MODIFICATION_ERR: 13;
    readonly NAMESPACE_ERR: 14;
    readonly INVALID_ACCESS_ERR: 15;
    readonly VALIDATION_ERR: 16;
    readonly TYPE_MISMATCH_ERR: 17;
    readonly SECURITY_ERR: 18;
    readonly NETWORK_ERR: 19;
    readonly ABORT_ERR: 20;
    readonly URL_MISMATCH_ERR: 21;
    readonly QUOTA_EXCEEDED_ERR: 22;
    readonly TIMEOUT_ERR: 23;
    readonly INVALID_NODE_TYPE_ERR: 24;
    readonly DATA_CLONE_ERR: 25;
}
// #endregion DOMException

declare global {
    // Declare "static" methods in Error
    interface ErrorConstructor {
        /** Create .stack property on a target object */
        captureStackTrace(targetObject: object, constructorOpt?: Function): void;

        /**
         * Optional override for formatting stack traces
         *
         * @see https://v8.dev/docs/stack-trace-api#customizing-stack-traces
         */
        prepareStackTrace?: ((err: Error, stackTraces: NodeJS.CallSite[]) => any) | undefined;

        stackTraceLimit: number;
    }

    /*-----------------------------------------------*
    *                                               *
    *                   GLOBAL                      *
    *                                               *
    ------------------------------------------------*/

    // For backwards compability
    interface NodeRequire extends NodeJS.Require {}
    interface RequireResolve extends NodeJS.RequireResolve {}
    interface NodeModule extends NodeJS.Module {}

    var process: NodeJS.Process;
    var console: Console;

    var __filename: string;
    var __dirname: string;

    var require: NodeRequire;
    var module: NodeModule;

    // Same as module.exports
    var exports: any;

    /**
     * Only available if `--expose-gc` is passed to the process.
     */
    var gc: undefined | (() => void);

    // #region borrowed
    // from https://github.com/microsoft/TypeScript/blob/38da7c600c83e7b31193a62495239a0fe478cb67/lib/lib.webworker.d.ts#L633 until moved to separate lib
    /** A controller object that allows you to abort one or more DOM requests as and when desired. */
    interface AbortController {
        /**
         * Returns the AbortSignal object associated with this object.
         */

        readonly signal: AbortSignal;
        /**
         * Invoking this method will set this object's AbortSignal's aborted flag and signal to any observers that the associated activity is to be aborted.
         */
        abort(reason?: any): void;
    }

    /** A signal object that allows you to communicate with a DOM request (such as a Fetch) and abort it if required via an AbortController object. */
    interface AbortSignal extends EventTarget {
        /**
         * Returns true if this AbortSignal's AbortController has signaled to abort, and false otherwise.
         */
        readonly aborted: boolean;
        readonly reason: any;
        onabort: null | ((this: AbortSignal, event: Event) => any);
        throwIfAborted(): void;
    }

    var AbortController: typeof globalThis extends { onmessage: any; AbortController: infer T } ? T
        : {
            prototype: AbortController;
            new(): AbortController;
        };

    var AbortSignal: typeof globalThis extends { onmessage: any; AbortSignal: infer T } ? T
        : {
            prototype: AbortSignal;
            new(): AbortSignal;
            abort(reason?: any): AbortSignal;
            timeout(milliseconds: number): AbortSignal;
            any(signals: AbortSignal[]): AbortSignal;
        };
    // #endregion borrowed

    // #region Storage
    /**
     * This Web Storage API interface provides access to a particular domain's session or local storage. It allows, for example, the addition, modification, or deletion of stored data items.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Storage)
     */
    interface Storage extends _Storage {}

    // Conditional on `onabort` rather than `onmessage`, in order to exclude lib.webworker
    var Storage: typeof globalThis extends { onabort: any; Storage: infer T } ? T
        : {
            prototype: Storage;
            new(): Storage;
        };

    /**
     * A browser-compatible implementation of [`localStorage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage).
     * Data is stored unencrypted in the file specified by the `--localstorage-file` CLI flag.
     * Any modification of this data outside of the Web Storage API is not supported.
     * Enable this API with the `--experimental-webstorage` CLI flag.
     * @since v22.4.0
     */
    var localStorage: Storage;

    /**
     * A browser-compatible implementation of [`sessionStorage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage).
     * Data is stored in memory, with a storage quota of 10 MB.
     * Any modification of this data outside of the Web Storage API is not supported.
     * Enable this API with the `--experimental-webstorage` CLI flag.
     * @since v22.4.0
     */
    var sessionStorage: Storage;
    // #endregion Storage

    // #region Disposable
    interface SymbolConstructor {
        /**
         * A method that is used to release resources held by an object. Called by the semantics of the `using` statement.
         */
        readonly dispose: unique symbol;

        /**
         * A method that is used to asynchronously release resources held by an object. Called by the semantics of the `await using` statement.
         */
        readonly asyncDispose: unique symbol;
    }

    interface Disposable {
        [Symbol.dispose](): void;
    }

    interface AsyncDisposable {
        [Symbol.asyncDispose](): PromiseLike<void>;
    }
    // #endregion Disposable

    // #region ArrayLike.at()
    interface RelativeIndexable<T> {
        /**
         * Takes an integer value and returns the item at that index,
         * allowing for positive and negative integers.
         * Negative integers count back from the last item in the array.
         */
        at(index: number): T | undefined;
    }
    interface String extends RelativeIndexable<string> {}
    interface Array<T> extends RelativeIndexable<T> {}
    interface ReadonlyArray<T> extends RelativeIndexable<T> {}
    interface Int8Array extends RelativeIndexable<number> {}
    interface Uint8Array extends RelativeIndexable<number> {}
    interface Uint8ClampedArray extends RelativeIndexable<number> {}
    interface Int16Array extends RelativeIndexable<number> {}
    interface Uint16Array extends RelativeIndexable<number> {}
    interface Int32Array extends RelativeIndexable<number> {}
    interface Uint32Array extends RelativeIndexable<number> {}
    interface Float32Array extends RelativeIndexable<number> {}
    interface Float64Array extends RelativeIndexable<number> {}
    interface BigInt64Array extends RelativeIndexable<bigint> {}
    interface BigUint64Array extends RelativeIndexable<bigint> {}
    // #endregion ArrayLike.at() end

    /**
     * @since v17.0.0
     *
     * Creates a deep clone of an object.
     */
    function structuredClone<T>(
        value: T,
        transfer?: { transfer: ReadonlyArray<import("worker_threads").TransferListItem> },
    ): T;

    // #region DOMException
    /**
     * @since v17.0.0
     * An abnormal event (called an exception) which occurs as a result of calling a method or accessing a property of a web API.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMException)
     */
    interface DOMException extends _DOMException {}

    /**
     * @since v17.0.0
     *
     * The WHATWG `DOMException` class. See [DOMException](https://developer.mozilla.org/docs/Web/API/DOMException) for more details.
     */
    var DOMException: typeof globalThis extends { onmessage: any; DOMException: infer T } ? T
        : NodeDOMExceptionConstructor;
    // #endregion DOMException

    /*----------------------------------------------*
    *                                               *
    *               GLOBAL INTERFACES               *
    *                                               *
    *-----------------------------------------------*/
    namespace NodeJS {
        interface CallSite {
            /**
             * Value of "this"
             */
            getThis(): unknown;

            /**
             * Type of "this" as a string.
             * This is the name of the function stored in the constructor field of
             * "this", if available.  Otherwise the object's [[Class]] internal
             * property.
             */
            getTypeName(): string | null;

            /**
             * Current function
             */
            getFunction(): Function | undefined;

            /**
             * Name of the current function, typically its name property.
             * If a name property is not available an attempt will be made to try
             * to infer a name from the function's context.
             */
            getFunctionName(): string | null;

            /**
             * Name of the property [of "this" or one of its prototypes] that holds
             * the current function
             */
            getMethodName(): string | null;

            /**
             * Name of the script [if this function was defined in a script]
             */
            getFileName(): string | undefined;

            /**
             * Current line number [if this function was defined in a script]
             */
            getLineNumber(): number | null;

            /**
             * Current column number [if this function was defined in a script]
             */
            getColumnNumber(): number | null;

            /**
             * A call site object representing the location where eval was called
             * [if this function was created using a call to eval]
             */
            getEvalOrigin(): string | undefined;

            /**
             * Is this a toplevel invocation, that is, is "this" the global object?
             */
            isToplevel(): boolean;

            /**
             * Does this call take place in code defined by a call to eval?
             */
            isEval(): boolean;

            /**
             * Is this call in native V8 code?
             */
            isNative(): boolean;

            /**
             * Is this a constructor call?
             */
            isConstructor(): boolean;

            /**
             * is this an async call (i.e. await, Promise.all(), or Promise.any())?
             */
            isAsync(): boolean;

            /**
             * is this an async call to Promise.all()?
             */
            isPromiseAll(): boolean;

            /**
             * returns the index of the promise element that was followed in
             * Promise.all() or Promise.any() for async stack traces, or null
             * if the CallSite is not an async
             */
            getPromiseIndex(): number | null;

            getScriptNameOrSourceURL(): string;
            getScriptHash(): string;

            getEnclosingColumnNumber(): number;
            getEnclosingLineNumber(): number;
            getPosition(): number;

            toString(): string;
        }

        interface ErrnoException extends Error {
            errno?: number | undefined;
            code?: string | undefined;
            path?: string | undefined;
            syscall?: string | undefined;
        }

        interface ReadableStream extends EventEmitter {
            readable: boolean;
            read(size?: number): string | Buffer;
            setEncoding(encoding: BufferEncoding): this;
            pause(): this;
            resume(): this;
            isPaused(): boolean;
            pipe<T extends WritableStream>(destination: T, options?: { end?: boolean | undefined }): T;
            unpipe(destination?: WritableStream): this;
            unshift(chunk: string | Uint8Array, encoding?: BufferEncoding): void;
            wrap(oldStream: ReadableStream): this;
            [Symbol.asyncIterator](): AsyncIterableIterator<string | Buffer>;
        }

        interface WritableStream extends EventEmitter {
            writable: boolean;
            write(buffer: Uint8Array | string, cb?: (err?: Error | null) => void): boolean;
            write(str: string, encoding?: BufferEncoding, cb?: (err?: Error | null) => void): boolean;
            end(cb?: () => void): this;
            end(data: string | Uint8Array, cb?: () => void): this;
            end(str: string, encoding?: BufferEncoding, cb?: () => void): this;
        }

        interface ReadWriteStream extends ReadableStream, WritableStream {}

        interface RefCounted {
            ref(): this;
            unref(): this;
        }

        type TypedArray =
            | Uint8Array
            | Uint8ClampedArray
            | Uint16Array
            | Uint32Array
            | Int8Array
            | Int16Array
            | Int32Array
            | BigUint64Array
            | BigInt64Array
            | Float32Array
            | Float64Array;
        type ArrayBufferView = TypedArray | DataView;

        interface Require {
            (id: string): any;
            resolve: RequireResolve;
            cache: Dict<NodeModule>;
            /**
             * @deprecated
             */
            extensions: RequireExtensions;
            main: Module | undefined;
        }

        interface RequireResolve {
            (id: string, options?: { paths?: string[] | undefined }): string;
            paths(request: string): string[] | null;
        }

        interface RequireExtensions extends Dict<(m: Module, filename: string) => any> {
            ".js": (m: Module, filename: string) => any;
            ".json": (m: Module, filename: string) => any;
            ".node": (m: Module, filename: string) => any;
        }
        interface Module {
            /**
             * `true` if the module is running during the Node.js preload
             */
            isPreloading: boolean;
            exports: any;
            require: Require;
            id: string;
            filename: string;
            loaded: boolean;
            /** @deprecated since v14.6.0 Please use `require.main` and `module.children` instead. */
            parent: Module | null | undefined;
            children: Module[];
            /**
             * @since v11.14.0
             *
             * The directory name of the module. This is usually the same as the path.dirname() of the module.id.
             */
            path: string;
            paths: string[];
        }

        interface Dict<T> {
            [key: string]: T | undefined;
        }

        interface ReadOnlyDict<T> {
            readonly [key: string]: T | undefined;
        }
    }

    interface RequestInit extends _RequestInit {}

    function fetch(
        input: string | URL | globalThis.Request,
        init?: RequestInit,
    ): Promise<Response>;

    interface Request extends _Request {}
    var Request: typeof globalThis extends {
        onmessage: any;
        Request: infer T;
    } ? T
        : typeof import("undici-types").Request;

    interface ResponseInit extends _ResponseInit {}

    interface Response extends _Response {}
    var Response: typeof globalThis extends {
        onmessage: any;
        Response: infer T;
    } ? T
        : typeof import("undici-types").Response;

    interface FormData extends _FormData {}
    var FormData: typeof globalThis extends {
        onmessage: any;
        FormData: infer T;
    } ? T
        : typeof import("undici-types").FormData;

    interface Headers extends _Headers {}
    var Headers: typeof globalThis extends {
        onmessage: any;
        Headers: infer T;
    } ? T
        : typeof import("undici-types").Headers;

    interface MessageEvent extends _MessageEvent {}
    /**
     * @since v15.0.0
     */
    var MessageEvent: typeof globalThis extends {
        onmessage: any;
        MessageEvent: infer T;
    } ? T
        : typeof import("undici-types").MessageEvent;

    interface WebSocket extends _WebSocket {}
    var WebSocket: typeof globalThis extends { onmessage: any; WebSocket: infer T } ? T
        : typeof import("undici-types").WebSocket;

    interface EventSource extends _EventSource {}
    /**
     * Only available through the [--experimental-eventsource](https://nodejs.org/api/cli.html#--experimental-eventsource) flag.
     *
     * @since v22.3.0
     */
    var EventSource: typeof globalThis extends { onmessage: any; EventSource: infer T } ? T
        : typeof import("undici-types").EventSource;
}
declare var global: typeof globalThis;
/**
 * To use the HTTP server and client one must `require('node:http')`.
 *
 * The HTTP interfaces in Node.js are designed to support many features
 * of the protocol which have been traditionally difficult to use.
 * In particular, large, possibly chunk-encoded, messages. The interface is
 * careful to never buffer entire requests or responses, so the
 * user is able to stream data.
 *
 * HTTP message headers are represented by an object like this:
 *
 * ```json
 * { "content-length": "123",
 *   "content-type": "text/plain",
 *   "connection": "keep-alive",
 *   "host": "example.com",
 *   "accept": "*" }
 * ```
 *
 * Keys are lowercased. Values are not modified.
 *
 * In order to support the full spectrum of possible HTTP applications, the Node.js
 * HTTP API is very low-level. It deals with stream handling and message
 * parsing only. It parses a message into headers and body but it does not
 * parse the actual headers or the body.
 *
 * See `message.headers` for details on how duplicate headers are handled.
 *
 * The raw headers as they were received are retained in the `rawHeaders` property, which is an array of `[key, value, key2, value2, ...]`. For
 * example, the previous message header object might have a `rawHeaders` list like the following:
 *
 * ```js
 * [ 'ConTent-Length', '123456',
 *   'content-LENGTH', '123',
 *   'content-type', 'text/plain',
 *   'CONNECTION', 'keep-alive',
 *   'Host', 'example.com',
 *   'accepT', '*' ]
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/http.js)
 */
declare module "http" {
    import * as stream from "node:stream";
    import { URL } from "node:url";
    import { LookupOptions } from "node:dns";
    import { EventEmitter } from "node:events";
    import { LookupFunction, Server as NetServer, Socket, TcpSocketConnectOpts } from "node:net";
    // incoming headers will never contain number
    interface IncomingHttpHeaders extends NodeJS.Dict<string | string[]> {
        accept?: string | undefined;
        "accept-language"?: string | undefined;
        "accept-patch"?: string | undefined;
        "accept-ranges"?: string | undefined;
        "access-control-allow-credentials"?: string | undefined;
        "access-control-allow-headers"?: string | undefined;
        "access-control-allow-methods"?: string | undefined;
        "access-control-allow-origin"?: string | undefined;
        "access-control-expose-headers"?: string | undefined;
        "access-control-max-age"?: string | undefined;
        "access-control-request-headers"?: string | undefined;
        "access-control-request-method"?: string | undefined;
        age?: string | undefined;
        allow?: string | undefined;
        "alt-svc"?: string | undefined;
        authorization?: string | undefined;
        "cache-control"?: string | undefined;
        connection?: string | undefined;
        "content-disposition"?: string | undefined;
        "content-encoding"?: string | undefined;
        "content-language"?: string | undefined;
        "content-length"?: string | undefined;
        "content-location"?: string | undefined;
        "content-range"?: string | undefined;
        "content-type"?: string | undefined;
        cookie?: string | undefined;
        date?: string | undefined;
        etag?: string | undefined;
        expect?: string | undefined;
        expires?: string | undefined;
        forwarded?: string | undefined;
        from?: string | undefined;
        host?: string | undefined;
        "if-match"?: string | undefined;
        "if-modified-since"?: string | undefined;
        "if-none-match"?: string | undefined;
        "if-unmodified-since"?: string | undefined;
        "last-modified"?: string | undefined;
        location?: string | undefined;
        origin?: string | undefined;
        pragma?: string | undefined;
        "proxy-authenticate"?: string | undefined;
        "proxy-authorization"?: string | undefined;
        "public-key-pins"?: string | undefined;
        range?: string | undefined;
        referer?: string | undefined;
        "retry-after"?: string | undefined;
        "sec-websocket-accept"?: string | undefined;
        "sec-websocket-extensions"?: string | undefined;
        "sec-websocket-key"?: string | undefined;
        "sec-websocket-protocol"?: string | undefined;
        "sec-websocket-version"?: string | undefined;
        "set-cookie"?: string[] | undefined;
        "strict-transport-security"?: string | undefined;
        tk?: string | undefined;
        trailer?: string | undefined;
        "transfer-encoding"?: string | undefined;
        upgrade?: string | undefined;
        "user-agent"?: string | undefined;
        vary?: string | undefined;
        via?: string | undefined;
        warning?: string | undefined;
        "www-authenticate"?: string | undefined;
    }
    // outgoing headers allows numbers (as they are converted internally to strings)
    type OutgoingHttpHeader = number | string | string[];
    interface OutgoingHttpHeaders extends NodeJS.Dict<OutgoingHttpHeader> {
        accept?: string | string[] | undefined;
        "accept-charset"?: string | string[] | undefined;
        "accept-encoding"?: string | string[] | undefined;
        "accept-language"?: string | string[] | undefined;
        "accept-ranges"?: string | undefined;
        "access-control-allow-credentials"?: string | undefined;
        "access-control-allow-headers"?: string | undefined;
        "access-control-allow-methods"?: string | undefined;
        "access-control-allow-origin"?: string | undefined;
        "access-control-expose-headers"?: string | undefined;
        "access-control-max-age"?: string | undefined;
        "access-control-request-headers"?: string | undefined;
        "access-control-request-method"?: string | undefined;
        age?: string | undefined;
        allow?: string | undefined;
        authorization?: string | undefined;
        "cache-control"?: string | undefined;
        "cdn-cache-control"?: string | undefined;
        connection?: string | string[] | undefined;
        "content-disposition"?: string | undefined;
        "content-encoding"?: string | undefined;
        "content-language"?: string | undefined;
        "content-length"?: string | number | undefined;
        "content-location"?: string | undefined;
        "content-range"?: string | undefined;
        "content-security-policy"?: string | undefined;
        "content-security-policy-report-only"?: string | undefined;
        cookie?: string | string[] | undefined;
        dav?: string | string[] | undefined;
        dnt?: string | undefined;
        date?: string | undefined;
        etag?: string | undefined;
        expect?: string | undefined;
        expires?: string | undefined;
        forwarded?: string | undefined;
        from?: string | undefined;
        host?: string | undefined;
        "if-match"?: string | undefined;
        "if-modified-since"?: string | undefined;
        "if-none-match"?: string | undefined;
        "if-range"?: string | undefined;
        "if-unmodified-since"?: string | undefined;
        "last-modified"?: string | undefined;
        link?: string | string[] | undefined;
        location?: string | undefined;
        "max-forwards"?: string | undefined;
        origin?: string | undefined;
        prgama?: string | string[] | undefined;
        "proxy-authenticate"?: string | string[] | undefined;
        "proxy-authorization"?: string | undefined;
        "public-key-pins"?: string | undefined;
        "public-key-pins-report-only"?: string | undefined;
        range?: string | undefined;
        referer?: string | undefined;
        "referrer-policy"?: string | undefined;
        refresh?: string | undefined;
        "retry-after"?: string | undefined;
        "sec-websocket-accept"?: string | undefined;
        "sec-websocket-extensions"?: string | string[] | undefined;
        "sec-websocket-key"?: string | undefined;
        "sec-websocket-protocol"?: string | string[] | undefined;
        "sec-websocket-version"?: string | undefined;
        server?: string | undefined;
        "set-cookie"?: string | string[] | undefined;
        "strict-transport-security"?: string | undefined;
        te?: string | undefined;
        trailer?: string | undefined;
        "transfer-encoding"?: string | undefined;
        "user-agent"?: string | undefined;
        upgrade?: string | undefined;
        "upgrade-insecure-requests"?: string | undefined;
        vary?: string | undefined;
        via?: string | string[] | undefined;
        warning?: string | undefined;
        "www-authenticate"?: string | string[] | undefined;
        "x-content-type-options"?: string | undefined;
        "x-dns-prefetch-control"?: string | undefined;
        "x-frame-options"?: string | undefined;
        "x-xss-protection"?: string | undefined;
    }
    interface ClientRequestArgs {
        _defaultAgent?: Agent | undefined;
        agent?: Agent | boolean | undefined;
        auth?: string | null | undefined;
        createConnection?:
            | ((
                options: ClientRequestArgs,
                oncreate: (err: Error | null, socket: stream.Duplex) => void,
            ) => stream.Duplex | null | undefined)
            | undefined;
        defaultPort?: number | string | undefined;
        family?: number | undefined;
        headers?: OutgoingHttpHeaders | undefined;
        hints?: LookupOptions["hints"];
        host?: string | null | undefined;
        hostname?: string | null | undefined;
        insecureHTTPParser?: boolean | undefined;
        localAddress?: string | undefined;
        localPort?: number | undefined;
        lookup?: LookupFunction | undefined;
        /**
         * @default 16384
         */
        maxHeaderSize?: number | undefined;
        method?: string | undefined;
        path?: string | null | undefined;
        port?: number | string | null | undefined;
        protocol?: string | null | undefined;
        setHost?: boolean | undefined;
        signal?: AbortSignal | undefined;
        socketPath?: string | undefined;
        timeout?: number | undefined;
        uniqueHeaders?: Array<string | string[]> | undefined;
        joinDuplicateHeaders?: boolean;
    }
    interface ServerOptions<
        Request extends typeof IncomingMessage = typeof IncomingMessage,
        Response extends typeof ServerResponse = typeof ServerResponse,
    > {
        /**
         * Specifies the `IncomingMessage` class to be used. Useful for extending the original `IncomingMessage`.
         */
        IncomingMessage?: Request | undefined;
        /**
         * Specifies the `ServerResponse` class to be used. Useful for extending the original `ServerResponse`.
         */
        ServerResponse?: Response | undefined;
        /**
         * Sets the timeout value in milliseconds for receiving the entire request from the client.
         * @see Server.requestTimeout for more information.
         * @default 300000
         * @since v18.0.0
         */
        requestTimeout?: number | undefined;
        /**
         * It joins the field line values of multiple headers in a request with `, ` instead of discarding the duplicates.
         * @default false
         * @since v18.14.0
         */
        joinDuplicateHeaders?: boolean;
        /**
         * The number of milliseconds of inactivity a server needs to wait for additional incoming data,
         * after it has finished writing the last response, before a socket will be destroyed.
         * @see Server.keepAliveTimeout for more information.
         * @default 5000
         * @since v18.0.0
         */
        keepAliveTimeout?: number | undefined;
        /**
         * Sets the interval value in milliseconds to check for request and headers timeout in incomplete requests.
         * @default 30000
         */
        connectionsCheckingInterval?: number | undefined;
        /**
         * Optionally overrides all `socket`s' `readableHighWaterMark` and `writableHighWaterMark`.
         * This affects `highWaterMark` property of both `IncomingMessage` and `ServerResponse`.
         * Default: @see stream.getDefaultHighWaterMark().
         * @since v20.1.0
         */
        highWaterMark?: number | undefined;
        /**
         * Use an insecure HTTP parser that accepts invalid HTTP headers when `true`.
         * Using the insecure parser should be avoided.
         * See --insecure-http-parser for more information.
         * @default false
         */
        insecureHTTPParser?: boolean | undefined;
        /**
         * Optionally overrides the value of `--max-http-header-size` for requests received by
         * this server, i.e. the maximum length of request headers in bytes.
         * @default 16384
         * @since v13.3.0
         */
        maxHeaderSize?: number | undefined;
        /**
         * If set to `true`, it disables the use of Nagle's algorithm immediately after a new incoming connection is received.
         * @default true
         * @since v16.5.0
         */
        noDelay?: boolean | undefined;
        /**
         * If set to `true`, it enables keep-alive functionality on the socket immediately after a new incoming connection is received,
         * similarly on what is done in `socket.setKeepAlive([enable][, initialDelay])`.
         * @default false
         * @since v16.5.0
         */
        keepAlive?: boolean | undefined;
        /**
         * If set to a positive number, it sets the initial delay before the first keepalive probe is sent on an idle socket.
         * @default 0
         * @since v16.5.0
         */
        keepAliveInitialDelay?: number | undefined;
        /**
         * A list of response headers that should be sent only once.
         * If the header's value is an array, the items will be joined using `; `.
         */
        uniqueHeaders?: Array<string | string[]> | undefined;
    }
    type RequestListener<
        Request extends typeof IncomingMessage = typeof IncomingMessage,
        Response extends typeof ServerResponse = typeof ServerResponse,
    > = (req: InstanceType<Request>, res: InstanceType<Response> & { req: InstanceType<Request> }) => void;
    /**
     * @since v0.1.17
     */
    class Server<
        Request extends typeof IncomingMessage = typeof IncomingMessage,
        Response extends typeof ServerResponse = typeof ServerResponse,
    > extends NetServer {
        constructor(requestListener?: RequestListener<Request, Response>);
        constructor(options: ServerOptions<Request, Response>, requestListener?: RequestListener<Request, Response>);
        /**
         * Sets the timeout value for sockets, and emits a `'timeout'` event on
         * the Server object, passing the socket as an argument, if a timeout
         * occurs.
         *
         * If there is a `'timeout'` event listener on the Server object, then it
         * will be called with the timed-out socket as an argument.
         *
         * By default, the Server does not timeout sockets. However, if a callback
         * is assigned to the Server's `'timeout'` event, timeouts must be handled
         * explicitly.
         * @since v0.9.12
         * @param [msecs=0 (no timeout)]
         */
        setTimeout(msecs?: number, callback?: () => void): this;
        setTimeout(callback: () => void): this;
        /**
         * Limits maximum incoming headers count. If set to 0, no limit will be applied.
         * @since v0.7.0
         */
        maxHeadersCount: number | null;
        /**
         * The maximum number of requests socket can handle
         * before closing keep alive connection.
         *
         * A value of `0` will disable the limit.
         *
         * When the limit is reached it will set the `Connection` header value to `close`,
         * but will not actually close the connection, subsequent requests sent
         * after the limit is reached will get `503 Service Unavailable` as a response.
         * @since v16.10.0
         */
        maxRequestsPerSocket: number | null;
        /**
         * The number of milliseconds of inactivity before a socket is presumed
         * to have timed out.
         *
         * A value of `0` will disable the timeout behavior on incoming connections.
         *
         * The socket timeout logic is set up on connection, so changing this
         * value only affects new connections to the server, not any existing connections.
         * @since v0.9.12
         */
        timeout: number;
        /**
         * Limit the amount of time the parser will wait to receive the complete HTTP
         * headers.
         *
         * If the timeout expires, the server responds with status 408 without
         * forwarding the request to the request listener and then closes the connection.
         *
         * It must be set to a non-zero value (e.g. 120 seconds) to protect against
         * potential Denial-of-Service attacks in case the server is deployed without a
         * reverse proxy in front.
         * @since v11.3.0, v10.14.0
         */
        headersTimeout: number;
        /**
         * The number of milliseconds of inactivity a server needs to wait for additional
         * incoming data, after it has finished writing the last response, before a socket
         * will be destroyed. If the server receives new data before the keep-alive
         * timeout has fired, it will reset the regular inactivity timeout, i.e., `server.timeout`.
         *
         * A value of `0` will disable the keep-alive timeout behavior on incoming
         * connections.
         * A value of `0` makes the http server behave similarly to Node.js versions prior
         * to 8.0.0, which did not have a keep-alive timeout.
         *
         * The socket timeout logic is set up on connection, so changing this value only
         * affects new connections to the server, not any existing connections.
         * @since v8.0.0
         */
        keepAliveTimeout: number;
        /**
         * Sets the timeout value in milliseconds for receiving the entire request from
         * the client.
         *
         * If the timeout expires, the server responds with status 408 without
         * forwarding the request to the request listener and then closes the connection.
         *
         * It must be set to a non-zero value (e.g. 120 seconds) to protect against
         * potential Denial-of-Service attacks in case the server is deployed without a
         * reverse proxy in front.
         * @since v14.11.0
         */
        requestTimeout: number;
        /**
         * Closes all connections connected to this server.
         * @since v18.2.0
         */
        closeAllConnections(): void;
        /**
         * Closes all connections connected to this server which are not sending a request
         * or waiting for a response.
         * @since v18.2.0
         */
        closeIdleConnections(): void;
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "connection", listener: (socket: Socket) => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "listening", listener: () => void): this;
        addListener(event: "checkContinue", listener: RequestListener<Request, Response>): this;
        addListener(event: "checkExpectation", listener: RequestListener<Request, Response>): this;
        addListener(event: "clientError", listener: (err: Error, socket: stream.Duplex) => void): this;
        addListener(
            event: "connect",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        addListener(event: "dropRequest", listener: (req: InstanceType<Request>, socket: stream.Duplex) => void): this;
        addListener(event: "request", listener: RequestListener<Request, Response>): this;
        addListener(
            event: "upgrade",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        emit(event: string, ...args: any[]): boolean;
        emit(event: "close"): boolean;
        emit(event: "connection", socket: Socket): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "listening"): boolean;
        emit(
            event: "checkContinue",
            req: InstanceType<Request>,
            res: InstanceType<Response> & { req: InstanceType<Request> },
        ): boolean;
        emit(
            event: "checkExpectation",
            req: InstanceType<Request>,
            res: InstanceType<Response> & { req: InstanceType<Request> },
        ): boolean;
        emit(event: "clientError", err: Error, socket: stream.Duplex): boolean;
        emit(event: "connect", req: InstanceType<Request>, socket: stream.Duplex, head: Buffer): boolean;
        emit(event: "dropRequest", req: InstanceType<Request>, socket: stream.Duplex): boolean;
        emit(
            event: "request",
            req: InstanceType<Request>,
            res: InstanceType<Response> & { req: InstanceType<Request> },
        ): boolean;
        emit(event: "upgrade", req: InstanceType<Request>, socket: stream.Duplex, head: Buffer): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "connection", listener: (socket: Socket) => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "listening", listener: () => void): this;
        on(event: "checkContinue", listener: RequestListener<Request, Response>): this;
        on(event: "checkExpectation", listener: RequestListener<Request, Response>): this;
        on(event: "clientError", listener: (err: Error, socket: stream.Duplex) => void): this;
        on(event: "connect", listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void): this;
        on(event: "dropRequest", listener: (req: InstanceType<Request>, socket: stream.Duplex) => void): this;
        on(event: "request", listener: RequestListener<Request, Response>): this;
        on(event: "upgrade", listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "connection", listener: (socket: Socket) => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "listening", listener: () => void): this;
        once(event: "checkContinue", listener: RequestListener<Request, Response>): this;
        once(event: "checkExpectation", listener: RequestListener<Request, Response>): this;
        once(event: "clientError", listener: (err: Error, socket: stream.Duplex) => void): this;
        once(
            event: "connect",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        once(event: "dropRequest", listener: (req: InstanceType<Request>, socket: stream.Duplex) => void): this;
        once(event: "request", listener: RequestListener<Request, Response>): this;
        once(
            event: "upgrade",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "connection", listener: (socket: Socket) => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "listening", listener: () => void): this;
        prependListener(event: "checkContinue", listener: RequestListener<Request, Response>): this;
        prependListener(event: "checkExpectation", listener: RequestListener<Request, Response>): this;
        prependListener(event: "clientError", listener: (err: Error, socket: stream.Duplex) => void): this;
        prependListener(
            event: "connect",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        prependListener(
            event: "dropRequest",
            listener: (req: InstanceType<Request>, socket: stream.Duplex) => void,
        ): this;
        prependListener(event: "request", listener: RequestListener<Request, Response>): this;
        prependListener(
            event: "upgrade",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "connection", listener: (socket: Socket) => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: "listening", listener: () => void): this;
        prependOnceListener(event: "checkContinue", listener: RequestListener<Request, Response>): this;
        prependOnceListener(event: "checkExpectation", listener: RequestListener<Request, Response>): this;
        prependOnceListener(event: "clientError", listener: (err: Error, socket: stream.Duplex) => void): this;
        prependOnceListener(
            event: "connect",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        prependOnceListener(
            event: "dropRequest",
            listener: (req: InstanceType<Request>, socket: stream.Duplex) => void,
        ): this;
        prependOnceListener(event: "request", listener: RequestListener<Request, Response>): this;
        prependOnceListener(
            event: "upgrade",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
    }
    /**
     * This class serves as the parent class of {@link ClientRequest} and {@link ServerResponse}. It is an abstract outgoing message from
     * the perspective of the participants of an HTTP transaction.
     * @since v0.1.17
     */
    class OutgoingMessage<Request extends IncomingMessage = IncomingMessage> extends stream.Writable {
        readonly req: Request;
        chunkedEncoding: boolean;
        shouldKeepAlive: boolean;
        useChunkedEncodingByDefault: boolean;
        sendDate: boolean;
        /**
         * @deprecated Use `writableEnded` instead.
         */
        finished: boolean;
        /**
         * Read-only. `true` if the headers were sent, otherwise `false`.
         * @since v0.9.3
         */
        readonly headersSent: boolean;
        /**
         * Alias of `outgoingMessage.socket`.
         * @since v0.3.0
         * @deprecated Since v15.12.0,v14.17.1 - Use `socket` instead.
         */
        readonly connection: Socket | null;
        /**
         * Reference to the underlying socket. Usually, users will not want to access
         * this property.
         *
         * After calling `outgoingMessage.end()`, this property will be nulled.
         * @since v0.3.0
         */
        readonly socket: Socket | null;
        constructor();
        /**
         * Once a socket is associated with the message and is connected, `socket.setTimeout()` will be called with `msecs` as the first parameter.
         * @since v0.9.12
         * @param callback Optional function to be called when a timeout occurs. Same as binding to the `timeout` event.
         */
        setTimeout(msecs: number, callback?: () => void): this;
        /**
         * Sets a single header value. If the header already exists in the to-be-sent
         * headers, its value will be replaced. Use an array of strings to send multiple
         * headers with the same name.
         * @since v0.4.0
         * @param name Header name
         * @param value Header value
         */
        setHeader(name: string, value: number | string | readonly string[]): this;
        /**
         * Append a single header value to the header object.
         *
         * If the value is an array, this is equivalent to calling this method multiple
         * times.
         *
         * If there were no previous values for the header, this is equivalent to calling `outgoingMessage.setHeader(name, value)`.
         *
         * Depending of the value of `options.uniqueHeaders` when the client request or the
         * server were created, this will end up in the header being sent multiple times or
         * a single time with values joined using `; `.
         * @since v18.3.0, v16.17.0
         * @param name Header name
         * @param value Header value
         */
        appendHeader(name: string, value: string | readonly string[]): this;
        /**
         * Gets the value of the HTTP header with the given name. If that header is not
         * set, the returned value will be `undefined`.
         * @since v0.4.0
         * @param name Name of header
         */
        getHeader(name: string): number | string | string[] | undefined;
        /**
         * Returns a shallow copy of the current outgoing headers. Since a shallow
         * copy is used, array values may be mutated without additional calls to
         * various header-related HTTP module methods. The keys of the returned
         * object are the header names and the values are the respective header
         * values. All header names are lowercase.
         *
         * The object returned by the `outgoingMessage.getHeaders()` method does
         * not prototypically inherit from the JavaScript `Object`. This means that
         * typical `Object` methods such as `obj.toString()`, `obj.hasOwnProperty()`,
         * and others are not defined and will not work.
         *
         * ```js
         * outgoingMessage.setHeader('Foo', 'bar');
         * outgoingMessage.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);
         *
         * const headers = outgoingMessage.getHeaders();
         * // headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }
         * ```
         * @since v7.7.0
         */
        getHeaders(): OutgoingHttpHeaders;
        /**
         * Returns an array containing the unique names of the current outgoing headers.
         * All names are lowercase.
         * @since v7.7.0
         */
        getHeaderNames(): string[];
        /**
         * Returns `true` if the header identified by `name` is currently set in the
         * outgoing headers. The header name is case-insensitive.
         *
         * ```js
         * const hasContentType = outgoingMessage.hasHeader('content-type');
         * ```
         * @since v7.7.0
         */
        hasHeader(name: string): boolean;
        /**
         * Removes a header that is queued for implicit sending.
         *
         * ```js
         * outgoingMessage.removeHeader('Content-Encoding');
         * ```
         * @since v0.4.0
         * @param name Header name
         */
        removeHeader(name: string): void;
        /**
         * Adds HTTP trailers (headers but at the end of the message) to the message.
         *
         * Trailers will **only** be emitted if the message is chunked encoded. If not,
         * the trailers will be silently discarded.
         *
         * HTTP requires the `Trailer` header to be sent to emit trailers,
         * with a list of header field names in its value, e.g.
         *
         * ```js
         * message.writeHead(200, { 'Content-Type': 'text/plain',
         *                          'Trailer': 'Content-MD5' });
         * message.write(fileData);
         * message.addTrailers({ 'Content-MD5': '7895bf4b8828b55ceaf47747b4bca667' });
         * message.end();
         * ```
         *
         * Attempting to set a header field name or value that contains invalid characters
         * will result in a `TypeError` being thrown.
         * @since v0.3.0
         */
        addTrailers(headers: OutgoingHttpHeaders | ReadonlyArray<[string, string]>): void;
        /**
         * Flushes the message headers.
         *
         * For efficiency reason, Node.js normally buffers the message headers
         * until `outgoingMessage.end()` is called or the first chunk of message data
         * is written. It then tries to pack the headers and data into a single TCP
         * packet.
         *
         * It is usually desired (it saves a TCP round-trip), but not when the first
         * data is not sent until possibly much later. `outgoingMessage.flushHeaders()` bypasses the optimization and kickstarts the message.
         * @since v1.6.0
         */
        flushHeaders(): void;
    }
    /**
     * This object is created internally by an HTTP server, not by the user. It is
     * passed as the second parameter to the `'request'` event.
     * @since v0.1.17
     */
    class ServerResponse<Request extends IncomingMessage = IncomingMessage> extends OutgoingMessage<Request> {
        /**
         * When using implicit headers (not calling `response.writeHead()` explicitly),
         * this property controls the status code that will be sent to the client when
         * the headers get flushed.
         *
         * ```js
         * response.statusCode = 404;
         * ```
         *
         * After response header was sent to the client, this property indicates the
         * status code which was sent out.
         * @since v0.4.0
         */
        statusCode: number;
        /**
         * When using implicit headers (not calling `response.writeHead()` explicitly),
         * this property controls the status message that will be sent to the client when
         * the headers get flushed. If this is left as `undefined` then the standard
         * message for the status code will be used.
         *
         * ```js
         * response.statusMessage = 'Not found';
         * ```
         *
         * After response header was sent to the client, this property indicates the
         * status message which was sent out.
         * @since v0.11.8
         */
        statusMessage: string;
        /**
         * If set to `true`, Node.js will check whether the `Content-Length` header value and the size of the body, in bytes, are equal.
         * Mismatching the `Content-Length` header value will result
         * in an `Error` being thrown, identified by `code:``'ERR_HTTP_CONTENT_LENGTH_MISMATCH'`.
         * @since v18.10.0, v16.18.0
         */
        strictContentLength: boolean;
        constructor(req: Request);
        assignSocket(socket: Socket): void;
        detachSocket(socket: Socket): void;
        /**
         * Sends an HTTP/1.1 100 Continue message to the client, indicating that
         * the request body should be sent. See the `'checkContinue'` event on `Server`.
         * @since v0.3.0
         */
        writeContinue(callback?: () => void): void;
        /**
         * Sends an HTTP/1.1 103 Early Hints message to the client with a Link header,
         * indicating that the user agent can preload/preconnect the linked resources.
         * The `hints` is an object containing the values of headers to be sent with
         * early hints message. The optional `callback` argument will be called when
         * the response message has been written.
         *
         * **Example**
         *
         * ```js
         * const earlyHintsLink = '</styles.css>; rel=preload; as=style';
         * response.writeEarlyHints({
         *   'link': earlyHintsLink,
         * });
         *
         * const earlyHintsLinks = [
         *   '</styles.css>; rel=preload; as=style',
         *   '</scripts.js>; rel=preload; as=script',
         * ];
         * response.writeEarlyHints({
         *   'link': earlyHintsLinks,
         *   'x-trace-id': 'id for diagnostics',
         * });
         *
         * const earlyHintsCallback = () => console.log('early hints message sent');
         * response.writeEarlyHints({
         *   'link': earlyHintsLinks,
         * }, earlyHintsCallback);
         * ```
         * @since v18.11.0
         * @param hints An object containing the values of headers
         * @param callback Will be called when the response message has been written
         */
        writeEarlyHints(hints: Record<string, string | string[]>, callback?: () => void): void;
        /**
         * Sends a response header to the request. The status code is a 3-digit HTTP
         * status code, like `404`. The last argument, `headers`, are the response headers.
         * Optionally one can give a human-readable `statusMessage` as the second
         * argument.
         *
         * `headers` may be an `Array` where the keys and values are in the same list.
         * It is _not_ a list of tuples. So, the even-numbered offsets are key values,
         * and the odd-numbered offsets are the associated values. The array is in the same
         * format as `request.rawHeaders`.
         *
         * Returns a reference to the `ServerResponse`, so that calls can be chained.
         *
         * ```js
         * const body = 'hello world';
         * response
         *   .writeHead(200, {
         *     'Content-Length': Buffer.byteLength(body),
         *     'Content-Type': 'text/plain',
         *   })
         *   .end(body);
         * ```
         *
         * This method must only be called once on a message and it must
         * be called before `response.end()` is called.
         *
         * If `response.write()` or `response.end()` are called before calling
         * this, the implicit/mutable headers will be calculated and call this function.
         *
         * When headers have been set with `response.setHeader()`, they will be merged
         * with any headers passed to `response.writeHead()`, with the headers passed
         * to `response.writeHead()` given precedence.
         *
         * If this method is called and `response.setHeader()` has not been called,
         * it will directly write the supplied header values onto the network channel
         * without caching internally, and the `response.getHeader()` on the header
         * will not yield the expected result. If progressive population of headers is
         * desired with potential future retrieval and modification, use `response.setHeader()` instead.
         *
         * ```js
         * // Returns content-type = text/plain
         * const server = http.createServer((req, res) => {
         *   res.setHeader('Content-Type', 'text/html');
         *   res.setHeader('X-Foo', 'bar');
         *   res.writeHead(200, { 'Content-Type': 'text/plain' });
         *   res.end('ok');
         * });
         * ```
         *
         * `Content-Length` is read in bytes, not characters. Use `Buffer.byteLength()` to determine the length of the body in bytes. Node.js
         * will check whether `Content-Length` and the length of the body which has
         * been transmitted are equal or not.
         *
         * Attempting to set a header field name or value that contains invalid characters
         * will result in a \[`Error`\]\[\] being thrown.
         * @since v0.1.30
         */
        writeHead(
            statusCode: number,
            statusMessage?: string,
            headers?: OutgoingHttpHeaders | OutgoingHttpHeader[],
        ): this;
        writeHead(statusCode: number, headers?: OutgoingHttpHeaders | OutgoingHttpHeader[]): this;
        /**
         * Sends a HTTP/1.1 102 Processing message to the client, indicating that
         * the request body should be sent.
         * @since v10.0.0
         */
        writeProcessing(): void;
    }
    interface InformationEvent {
        statusCode: number;
        statusMessage: string;
        httpVersion: string;
        httpVersionMajor: number;
        httpVersionMinor: number;
        headers: IncomingHttpHeaders;
        rawHeaders: string[];
    }
    /**
     * This object is created internally and returned from {@link request}. It
     * represents an _in-progress_ request whose header has already been queued. The
     * header is still mutable using the `setHeader(name, value)`, `getHeader(name)`, `removeHeader(name)` API. The actual header will
     * be sent along with the first data chunk or when calling `request.end()`.
     *
     * To get the response, add a listener for `'response'` to the request object. `'response'` will be emitted from the request object when the response
     * headers have been received. The `'response'` event is executed with one
     * argument which is an instance of {@link IncomingMessage}.
     *
     * During the `'response'` event, one can add listeners to the
     * response object; particularly to listen for the `'data'` event.
     *
     * If no `'response'` handler is added, then the response will be
     * entirely discarded. However, if a `'response'` event handler is added,
     * then the data from the response object **must** be consumed, either by
     * calling `response.read()` whenever there is a `'readable'` event, or
     * by adding a `'data'` handler, or by calling the `.resume()` method.
     * Until the data is consumed, the `'end'` event will not fire. Also, until
     * the data is read it will consume memory that can eventually lead to a
     * 'process out of memory' error.
     *
     * For backward compatibility, `res` will only emit `'error'` if there is an `'error'` listener registered.
     *
     * Set `Content-Length` header to limit the response body size.
     * If `response.strictContentLength` is set to `true`, mismatching the `Content-Length` header value will result in an `Error` being thrown,
     * identified by `code:``'ERR_HTTP_CONTENT_LENGTH_MISMATCH'`.
     *
     * `Content-Length` value should be in bytes, not characters. Use `Buffer.byteLength()` to determine the length of the body in bytes.
     * @since v0.1.17
     */
    class ClientRequest extends OutgoingMessage {
        /**
         * The `request.aborted` property will be `true` if the request has
         * been aborted.
         * @since v0.11.14
         * @deprecated Since v17.0.0, v16.12.0 - Check `destroyed` instead.
         */
        aborted: boolean;
        /**
         * The request host.
         * @since v14.5.0, v12.19.0
         */
        host: string;
        /**
         * The request protocol.
         * @since v14.5.0, v12.19.0
         */
        protocol: string;
        /**
         * When sending request through a keep-alive enabled agent, the underlying socket
         * might be reused. But if server closes connection at unfortunate time, client
         * may run into a 'ECONNRESET' error.
         *
         * ```js
         * import http from 'node:http';
         *
         * // Server has a 5 seconds keep-alive timeout by default
         * http
         *   .createServer((req, res) => {
         *     res.write('hello\n');
         *     res.end();
         *   })
         *   .listen(3000);
         *
         * setInterval(() => {
         *   // Adapting a keep-alive agent
         *   http.get('http://localhost:3000', { agent }, (res) => {
         *     res.on('data', (data) => {
         *       // Do nothing
         *     });
         *   });
         * }, 5000); // Sending request on 5s interval so it's easy to hit idle timeout
         * ```
         *
         * By marking a request whether it reused socket or not, we can do
         * automatic error retry base on it.
         *
         * ```js
         * import http from 'node:http';
         * const agent = new http.Agent({ keepAlive: true });
         *
         * function retriableRequest() {
         *   const req = http
         *     .get('http://localhost:3000', { agent }, (res) => {
         *       // ...
         *     })
         *     .on('error', (err) => {
         *       // Check if retry is needed
         *       if (req.reusedSocket &#x26;&#x26; err.code === 'ECONNRESET') {
         *         retriableRequest();
         *       }
         *     });
         * }
         *
         * retriableRequest();
         * ```
         * @since v13.0.0, v12.16.0
         */
        reusedSocket: boolean;
        /**
         * Limits maximum response headers count. If set to 0, no limit will be applied.
         */
        maxHeadersCount: number;
        constructor(url: string | URL | ClientRequestArgs, cb?: (res: IncomingMessage) => void);
        /**
         * The request method.
         * @since v0.1.97
         */
        method: string;
        /**
         * The request path.
         * @since v0.4.0
         */
        path: string;
        /**
         * Marks the request as aborting. Calling this will cause remaining data
         * in the response to be dropped and the socket to be destroyed.
         * @since v0.3.8
         * @deprecated Since v14.1.0,v13.14.0 - Use `destroy` instead.
         */
        abort(): void;
        onSocket(socket: Socket): void;
        /**
         * Once a socket is assigned to this request and is connected `socket.setTimeout()` will be called.
         * @since v0.5.9
         * @param timeout Milliseconds before a request times out.
         * @param callback Optional function to be called when a timeout occurs. Same as binding to the `'timeout'` event.
         */
        setTimeout(timeout: number, callback?: () => void): this;
        /**
         * Once a socket is assigned to this request and is connected `socket.setNoDelay()` will be called.
         * @since v0.5.9
         */
        setNoDelay(noDelay?: boolean): void;
        /**
         * Once a socket is assigned to this request and is connected `socket.setKeepAlive()` will be called.
         * @since v0.5.9
         */
        setSocketKeepAlive(enable?: boolean, initialDelay?: number): void;
        /**
         * Returns an array containing the unique names of the current outgoing raw
         * headers. Header names are returned with their exact casing being set.
         *
         * ```js
         * request.setHeader('Foo', 'bar');
         * request.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);
         *
         * const headerNames = request.getRawHeaderNames();
         * // headerNames === ['Foo', 'Set-Cookie']
         * ```
         * @since v15.13.0, v14.17.0
         */
        getRawHeaderNames(): string[];
        /**
         * @deprecated
         */
        addListener(event: "abort", listener: () => void): this;
        addListener(
            event: "connect",
            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,
        ): this;
        addListener(event: "continue", listener: () => void): this;
        addListener(event: "information", listener: (info: InformationEvent) => void): this;
        addListener(event: "response", listener: (response: IncomingMessage) => void): this;
        addListener(event: "socket", listener: (socket: Socket) => void): this;
        addListener(event: "timeout", listener: () => void): this;
        addListener(
            event: "upgrade",
            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,
        ): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "drain", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "finish", listener: () => void): this;
        addListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        addListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        /**
         * @deprecated
         */
        on(event: "abort", listener: () => void): this;
        on(event: "connect", listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        on(event: "continue", listener: () => void): this;
        on(event: "information", listener: (info: InformationEvent) => void): this;
        on(event: "response", listener: (response: IncomingMessage) => void): this;
        on(event: "socket", listener: (socket: Socket) => void): this;
        on(event: "timeout", listener: () => void): this;
        on(event: "upgrade", listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "drain", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "finish", listener: () => void): this;
        on(event: "pipe", listener: (src: stream.Readable) => void): this;
        on(event: "unpipe", listener: (src: stream.Readable) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        /**
         * @deprecated
         */
        once(event: "abort", listener: () => void): this;
        once(event: "connect", listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        once(event: "continue", listener: () => void): this;
        once(event: "information", listener: (info: InformationEvent) => void): this;
        once(event: "response", listener: (response: IncomingMessage) => void): this;
        once(event: "socket", listener: (socket: Socket) => void): this;
        once(event: "timeout", listener: () => void): this;
        once(event: "upgrade", listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "drain", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "finish", listener: () => void): this;
        once(event: "pipe", listener: (src: stream.Readable) => void): this;
        once(event: "unpipe", listener: (src: stream.Readable) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        /**
         * @deprecated
         */
        prependListener(event: "abort", listener: () => void): this;
        prependListener(
            event: "connect",
            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,
        ): this;
        prependListener(event: "continue", listener: () => void): this;
        prependListener(event: "information", listener: (info: InformationEvent) => void): this;
        prependListener(event: "response", listener: (response: IncomingMessage) => void): this;
        prependListener(event: "socket", listener: (socket: Socket) => void): this;
        prependListener(event: "timeout", listener: () => void): this;
        prependListener(
            event: "upgrade",
            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,
        ): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "drain", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "finish", listener: () => void): this;
        prependListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        prependListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        /**
         * @deprecated
         */
        prependOnceListener(event: "abort", listener: () => void): this;
        prependOnceListener(
            event: "connect",
            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,
        ): this;
        prependOnceListener(event: "continue", listener: () => void): this;
        prependOnceListener(event: "information", listener: (info: InformationEvent) => void): this;
        prependOnceListener(event: "response", listener: (response: IncomingMessage) => void): this;
        prependOnceListener(event: "socket", listener: (socket: Socket) => void): this;
        prependOnceListener(event: "timeout", listener: () => void): this;
        prependOnceListener(
            event: "upgrade",
            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,
        ): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "drain", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: "finish", listener: () => void): this;
        prependOnceListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    /**
     * An `IncomingMessage` object is created by {@link Server} or {@link ClientRequest} and passed as the first argument to the `'request'` and `'response'` event respectively. It may be used to
     * access response
     * status, headers, and data.
     *
     * Different from its `socket` value which is a subclass of `stream.Duplex`, the `IncomingMessage` itself extends `stream.Readable` and is created separately to
     * parse and emit the incoming HTTP headers and payload, as the underlying socket
     * may be reused multiple times in case of keep-alive.
     * @since v0.1.17
     */
    class IncomingMessage extends stream.Readable {
        constructor(socket: Socket);
        /**
         * The `message.aborted` property will be `true` if the request has
         * been aborted.
         * @since v10.1.0
         * @deprecated Since v17.0.0,v16.12.0 - Check `message.destroyed` from <a href="stream.html#class-streamreadable" class="type">stream.Readable</a>.
         */
        aborted: boolean;
        /**
         * In case of server request, the HTTP version sent by the client. In the case of
         * client response, the HTTP version of the connected-to server.
         * Probably either `'1.1'` or `'1.0'`.
         *
         * Also `message.httpVersionMajor` is the first integer and `message.httpVersionMinor` is the second.
         * @since v0.1.1
         */
        httpVersion: string;
        httpVersionMajor: number;
        httpVersionMinor: number;
        /**
         * The `message.complete` property will be `true` if a complete HTTP message has
         * been received and successfully parsed.
         *
         * This property is particularly useful as a means of determining if a client or
         * server fully transmitted a message before a connection was terminated:
         *
         * ```js
         * const req = http.request({
         *   host: '127.0.0.1',
         *   port: 8080,
         *   method: 'POST',
         * }, (res) => {
         *   res.resume();
         *   res.on('end', () => {
         *     if (!res.complete)
         *       console.error(
         *         'The connection was terminated while the message was still being sent');
         *   });
         * });
         * ```
         * @since v0.3.0
         */
        complete: boolean;
        /**
         * Alias for `message.socket`.
         * @since v0.1.90
         * @deprecated Since v16.0.0 - Use `socket`.
         */
        connection: Socket;
        /**
         * The `net.Socket` object associated with the connection.
         *
         * With HTTPS support, use `request.socket.getPeerCertificate()` to obtain the
         * client's authentication details.
         *
         * This property is guaranteed to be an instance of the `net.Socket` class,
         * a subclass of `stream.Duplex`, unless the user specified a socket
         * type other than `net.Socket` or internally nulled.
         * @since v0.3.0
         */
        socket: Socket;
        /**
         * The request/response headers object.
         *
         * Key-value pairs of header names and values. Header names are lower-cased.
         *
         * ```js
         * // Prints something like:
         * //
         * // { 'user-agent': 'curl/7.22.0',
         * //   host: '127.0.0.1:8000',
         * //   accept: '*' }
         * console.log(request.headers);
         * ```
         *
         * Duplicates in raw headers are handled in the following ways, depending on the
         * header name:
         *
         * * Duplicates of `age`, `authorization`, `content-length`, `content-type`, `etag`, `expires`, `from`, `host`, `if-modified-since`, `if-unmodified-since`, `last-modified`, `location`,
         * `max-forwards`, `proxy-authorization`, `referer`, `retry-after`, `server`, or `user-agent` are discarded.
         * To allow duplicate values of the headers listed above to be joined,
         * use the option `joinDuplicateHeaders` in {@link request} and {@link createServer}. See RFC 9110 Section 5.3 for more
         * information.
         * * `set-cookie` is always an array. Duplicates are added to the array.
         * * For duplicate `cookie` headers, the values are joined together with `; `.
         * * For all other headers, the values are joined together with `, `.
         * @since v0.1.5
         */
        headers: IncomingHttpHeaders;
        /**
         * Similar to `message.headers`, but there is no join logic and the values are
         * always arrays of strings, even for headers received just once.
         *
         * ```js
         * // Prints something like:
         * //
         * // { 'user-agent': ['curl/7.22.0'],
         * //   host: ['127.0.0.1:8000'],
         * //   accept: ['*'] }
         * console.log(request.headersDistinct);
         * ```
         * @since v18.3.0, v16.17.0
         */
        headersDistinct: NodeJS.Dict<string[]>;
        /**
         * The raw request/response headers list exactly as they were received.
         *
         * The keys and values are in the same list. It is _not_ a
         * list of tuples. So, the even-numbered offsets are key values, and the
         * odd-numbered offsets are the associated values.
         *
         * Header names are not lowercased, and duplicates are not merged.
         *
         * ```js
         * // Prints something like:
         * //
         * // [ 'user-agent',
         * //   'this is invalid because there can be only one',
         * //   'User-Agent',
         * //   'curl/7.22.0',
         * //   'Host',
         * //   '127.0.0.1:8000',
         * //   'ACCEPT',
         * //   '*' ]
         * console.log(request.rawHeaders);
         * ```
         * @since v0.11.6
         */
        rawHeaders: string[];
        /**
         * The request/response trailers object. Only populated at the `'end'` event.
         * @since v0.3.0
         */
        trailers: NodeJS.Dict<string>;
        /**
         * Similar to `message.trailers`, but there is no join logic and the values are
         * always arrays of strings, even for headers received just once.
         * Only populated at the `'end'` event.
         * @since v18.3.0, v16.17.0
         */
        trailersDistinct: NodeJS.Dict<string[]>;
        /**
         * The raw request/response trailer keys and values exactly as they were
         * received. Only populated at the `'end'` event.
         * @since v0.11.6
         */
        rawTrailers: string[];
        /**
         * Calls `message.socket.setTimeout(msecs, callback)`.
         * @since v0.5.9
         */
        setTimeout(msecs: number, callback?: () => void): this;
        /**
         * **Only valid for request obtained from {@link Server}.**
         *
         * The request method as a string. Read only. Examples: `'GET'`, `'DELETE'`.
         * @since v0.1.1
         */
        method?: string | undefined;
        /**
         * **Only valid for request obtained from {@link Server}.**
         *
         * Request URL string. This contains only the URL that is present in the actual
         * HTTP request. Take the following request:
         *
         * ```http
         * GET /status?name=ryan HTTP/1.1
         * Accept: text/plain
         * ```
         *
         * To parse the URL into its parts:
         *
         * ```js
         * new URL(`http://${process.env.HOST ?? 'localhost'}${request.url}`);
         * ```
         *
         * When `request.url` is `'/status?name=ryan'` and `process.env.HOST` is undefined:
         *
         * ```console
         * $ node
         * > new URL(`http://${process.env.HOST ?? 'localhost'}${request.url}`);
         * URL {
         *   href: 'http://localhost/status?name=ryan',
         *   origin: 'http://localhost',
         *   protocol: 'http:',
         *   username: '',
         *   password: '',
         *   host: 'localhost',
         *   hostname: 'localhost',
         *   port: '',
         *   pathname: '/status',
         *   search: '?name=ryan',
         *   searchParams: URLSearchParams { 'name' => 'ryan' },
         *   hash: ''
         * }
         * ```
         *
         * Ensure that you set `process.env.HOST` to the server's host name, or consider replacing this part entirely. If using `req.headers.host`, ensure proper
         * validation is used, as clients may specify a custom `Host` header.
         * @since v0.1.90
         */
        url?: string | undefined;
        /**
         * **Only valid for response obtained from {@link ClientRequest}.**
         *
         * The 3-digit HTTP response status code. E.G. `404`.
         * @since v0.1.1
         */
        statusCode?: number | undefined;
        /**
         * **Only valid for response obtained from {@link ClientRequest}.**
         *
         * The HTTP response status message (reason phrase). E.G. `OK` or `Internal Server Error`.
         * @since v0.11.10
         */
        statusMessage?: string | undefined;
        /**
         * Calls `destroy()` on the socket that received the `IncomingMessage`. If `error` is provided, an `'error'` event is emitted on the socket and `error` is passed
         * as an argument to any listeners on the event.
         * @since v0.3.0
         */
        destroy(error?: Error): this;
    }
    interface AgentOptions extends Partial<TcpSocketConnectOpts> {
        /**
         * Keep sockets around in a pool to be used by other requests in the future. Default = false
         */
        keepAlive?: boolean | undefined;
        /**
         * When using HTTP KeepAlive, how often to send TCP KeepAlive packets over sockets being kept alive. Default = 1000.
         * Only relevant if keepAlive is set to true.
         */
        keepAliveMsecs?: number | undefined;
        /**
         * Maximum number of sockets to allow per host. Default for Node 0.10 is 5, default for Node 0.12 is Infinity
         */
        maxSockets?: number | undefined;
        /**
         * Maximum number of sockets allowed for all hosts in total. Each request will use a new socket until the maximum is reached. Default: Infinity.
         */
        maxTotalSockets?: number | undefined;
        /**
         * Maximum number of sockets to leave open in a free state. Only relevant if keepAlive is set to true. Default = 256.
         */
        maxFreeSockets?: number | undefined;
        /**
         * Socket timeout in milliseconds. This will set the timeout after the socket is connected.
         */
        timeout?: number | undefined;
        /**
         * Scheduling strategy to apply when picking the next free socket to use.
         * @default `lifo`
         */
        scheduling?: "fifo" | "lifo" | undefined;
    }
    /**
     * An `Agent` is responsible for managing connection persistence
     * and reuse for HTTP clients. It maintains a queue of pending requests
     * for a given host and port, reusing a single socket connection for each
     * until the queue is empty, at which time the socket is either destroyed
     * or put into a pool where it is kept to be used again for requests to the
     * same host and port. Whether it is destroyed or pooled depends on the `keepAlive` `option`.
     *
     * Pooled connections have TCP Keep-Alive enabled for them, but servers may
     * still close idle connections, in which case they will be removed from the
     * pool and a new connection will be made when a new HTTP request is made for
     * that host and port. Servers may also refuse to allow multiple requests
     * over the same connection, in which case the connection will have to be
     * remade for every request and cannot be pooled. The `Agent` will still make
     * the requests to that server, but each one will occur over a new connection.
     *
     * When a connection is closed by the client or the server, it is removed
     * from the pool. Any unused sockets in the pool will be unrefed so as not
     * to keep the Node.js process running when there are no outstanding requests.
     * (see `socket.unref()`).
     *
     * It is good practice, to `destroy()` an `Agent` instance when it is no
     * longer in use, because unused sockets consume OS resources.
     *
     * Sockets are removed from an agent when the socket emits either
     * a `'close'` event or an `'agentRemove'` event. When intending to keep one
     * HTTP request open for a long time without keeping it in the agent, something
     * like the following may be done:
     *
     * ```js
     * http.get(options, (res) => {
     *   // Do stuff
     * }).on('socket', (socket) => {
     *   socket.emit('agentRemove');
     * });
     * ```
     *
     * An agent may also be used for an individual request. By providing `{agent: false}` as an option to the `http.get()` or `http.request()` functions, a one-time use `Agent` with default options
     * will be used
     * for the client connection.
     *
     * `agent:false`:
     *
     * ```js
     * http.get({
     *   hostname: 'localhost',
     *   port: 80,
     *   path: '/',
     *   agent: false,  // Create a new agent just for this one request
     * }, (res) => {
     *   // Do stuff with response
     * });
     * ```
     *
     * `options` in [`socket.connect()`](https://nodejs.org/docs/latest-v22.x/api/net.html#socketconnectoptions-connectlistener) are also supported.
     *
     * To configure any of them, a custom {@link Agent} instance must be created.
     *
     * ```js
     * const http = require('node:http');
     * const keepAliveAgent = new http.Agent({ keepAlive: true });
     * options.agent = keepAliveAgent;
     * http.request(options, onResponseCallback)
     * ```
     * @since v0.3.4
     */
    class Agent extends EventEmitter {
        /**
         * By default set to 256. For agents with `keepAlive` enabled, this
         * sets the maximum number of sockets that will be left open in the free
         * state.
         * @since v0.11.7
         */
        maxFreeSockets: number;
        /**
         * By default set to `Infinity`. Determines how many concurrent sockets the agent
         * can have open per origin. Origin is the returned value of `agent.getName()`.
         * @since v0.3.6
         */
        maxSockets: number;
        /**
         * By default set to `Infinity`. Determines how many concurrent sockets the agent
         * can have open. Unlike `maxSockets`, this parameter applies across all origins.
         * @since v14.5.0, v12.19.0
         */
        maxTotalSockets: number;
        /**
         * An object which contains arrays of sockets currently awaiting use by
         * the agent when `keepAlive` is enabled. Do not modify.
         *
         * Sockets in the `freeSockets` list will be automatically destroyed and
         * removed from the array on `'timeout'`.
         * @since v0.11.4
         */
        readonly freeSockets: NodeJS.ReadOnlyDict<Socket[]>;
        /**
         * An object which contains arrays of sockets currently in use by the
         * agent. Do not modify.
         * @since v0.3.6
         */
        readonly sockets: NodeJS.ReadOnlyDict<Socket[]>;
        /**
         * An object which contains queues of requests that have not yet been assigned to
         * sockets. Do not modify.
         * @since v0.5.9
         */
        readonly requests: NodeJS.ReadOnlyDict<IncomingMessage[]>;
        constructor(opts?: AgentOptions);
        /**
         * Destroy any sockets that are currently in use by the agent.
         *
         * It is usually not necessary to do this. However, if using an
         * agent with `keepAlive` enabled, then it is best to explicitly shut down
         * the agent when it is no longer needed. Otherwise,
         * sockets might stay open for quite a long time before the server
         * terminates them.
         * @since v0.11.4
         */
        destroy(): void;
    }
    const METHODS: string[];
    const STATUS_CODES: {
        [errorCode: number]: string | undefined;
        [errorCode: string]: string | undefined;
    };
    /**
     * Returns a new instance of {@link Server}.
     *
     * The `requestListener` is a function which is automatically
     * added to the `'request'` event.
     *
     * ```js
     * import http from 'node:http';
     *
     * // Create a local server to receive data from
     * const server = http.createServer((req, res) => {
     *   res.writeHead(200, { 'Content-Type': 'application/json' });
     *   res.end(JSON.stringify({
     *     data: 'Hello World!',
     *   }));
     * });
     *
     * server.listen(8000);
     * ```
     *
     * ```js
     * import http from 'node:http';
     *
     * // Create a local server to receive data from
     * const server = http.createServer();
     *
     * // Listen to the request event
     * server.on('request', (request, res) => {
     *   res.writeHead(200, { 'Content-Type': 'application/json' });
     *   res.end(JSON.stringify({
     *     data: 'Hello World!',
     *   }));
     * });
     *
     * server.listen(8000);
     * ```
     * @since v0.1.13
     */
    function createServer<
        Request extends typeof IncomingMessage = typeof IncomingMessage,
        Response extends typeof ServerResponse = typeof ServerResponse,
    >(requestListener?: RequestListener<Request, Response>): Server<Request, Response>;
    function createServer<
        Request extends typeof IncomingMessage = typeof IncomingMessage,
        Response extends typeof ServerResponse = typeof ServerResponse,
    >(
        options: ServerOptions<Request, Response>,
        requestListener?: RequestListener<Request, Response>,
    ): Server<Request, Response>;
    // although RequestOptions are passed as ClientRequestArgs to ClientRequest directly,
    // create interface RequestOptions would make the naming more clear to developers
    interface RequestOptions extends ClientRequestArgs {}
    /**
     * `options` in `socket.connect()` are also supported.
     *
     * Node.js maintains several connections per server to make HTTP requests.
     * This function allows one to transparently issue requests.
     *
     * `url` can be a string or a `URL` object. If `url` is a
     * string, it is automatically parsed with `new URL()`. If it is a `URL` object, it will be automatically converted to an ordinary `options` object.
     *
     * If both `url` and `options` are specified, the objects are merged, with the `options` properties taking precedence.
     *
     * The optional `callback` parameter will be added as a one-time listener for
     * the `'response'` event.
     *
     * `http.request()` returns an instance of the {@link ClientRequest} class. The `ClientRequest` instance is a writable stream. If one needs to
     * upload a file with a POST request, then write to the `ClientRequest` object.
     *
     * ```js
     * import http from 'node:http';
     * import { Buffer } from 'node:buffer';
     *
     * const postData = JSON.stringify({
     *   'msg': 'Hello World!',
     * });
     *
     * const options = {
     *   hostname: 'www.google.com',
     *   port: 80,
     *   path: '/upload',
     *   method: 'POST',
     *   headers: {
     *     'Content-Type': 'application/json',
     *     'Content-Length': Buffer.byteLength(postData),
     *   },
     * };
     *
     * const req = http.request(options, (res) => {
     *   console.log(`STATUS: ${res.statusCode}`);
     *   console.log(`HEADERS: ${JSON.stringify(res.headers)}`);
     *   res.setEncoding('utf8');
     *   res.on('data', (chunk) => {
     *     console.log(`BODY: ${chunk}`);
     *   });
     *   res.on('end', () => {
     *     console.log('No more data in response.');
     *   });
     * });
     *
     * req.on('error', (e) => {
     *   console.error(`problem with request: ${e.message}`);
     * });
     *
     * // Write data to request body
     * req.write(postData);
     * req.end();
     * ```
     *
     * In the example `req.end()` was called. With `http.request()` one
     * must always call `req.end()` to signify the end of the request -
     * even if there is no data being written to the request body.
     *
     * If any error is encountered during the request (be that with DNS resolution,
     * TCP level errors, or actual HTTP parse errors) an `'error'` event is emitted
     * on the returned request object. As with all `'error'` events, if no listeners
     * are registered the error will be thrown.
     *
     * There are a few special headers that should be noted.
     *
     * * Sending a 'Connection: keep-alive' will notify Node.js that the connection to
     * the server should be persisted until the next request.
     * * Sending a 'Content-Length' header will disable the default chunked encoding.
     * * Sending an 'Expect' header will immediately send the request headers.
     * Usually, when sending 'Expect: 100-continue', both a timeout and a listener
     * for the `'continue'` event should be set. See RFC 2616 Section 8.2.3 for more
     * information.
     * * Sending an Authorization header will override using the `auth` option
     * to compute basic authentication.
     *
     * Example using a `URL` as `options`:
     *
     * ```js
     * const options = new URL('http://abc:xyz@example.com');
     *
     * const req = http.request(options, (res) => {
     *   // ...
     * });
     * ```
     *
     * In a successful request, the following events will be emitted in the following
     * order:
     *
     * * `'socket'`
     * * `'response'`
     *    * `'data'` any number of times, on the `res` object
     *    (`'data'` will not be emitted at all if the response body is empty, for
     *    instance, in most redirects)
     *    * `'end'` on the `res` object
     * * `'close'`
     *
     * In the case of a connection error, the following events will be emitted:
     *
     * * `'socket'`
     * * `'error'`
     * * `'close'`
     *
     * In the case of a premature connection close before the response is received,
     * the following events will be emitted in the following order:
     *
     * * `'socket'`
     * * `'error'` with an error with message `'Error: socket hang up'` and code `'ECONNRESET'`
     * * `'close'`
     *
     * In the case of a premature connection close after the response is received,
     * the following events will be emitted in the following order:
     *
     * * `'socket'`
     * * `'response'`
     *    * `'data'` any number of times, on the `res` object
     * * (connection closed here)
     * * `'aborted'` on the `res` object
     * * `'close'`
     * * `'error'` on the `res` object with an error with message `'Error: aborted'` and code `'ECONNRESET'`
     * * `'close'` on the `res` object
     *
     * If `req.destroy()` is called before a socket is assigned, the following
     * events will be emitted in the following order:
     *
     * * (`req.destroy()` called here)
     * * `'error'` with an error with message `'Error: socket hang up'` and code `'ECONNRESET'`, or the error with which `req.destroy()` was called
     * * `'close'`
     *
     * If `req.destroy()` is called before the connection succeeds, the following
     * events will be emitted in the following order:
     *
     * * `'socket'`
     * * (`req.destroy()` called here)
     * * `'error'` with an error with message `'Error: socket hang up'` and code `'ECONNRESET'`, or the error with which `req.destroy()` was called
     * * `'close'`
     *
     * If `req.destroy()` is called after the response is received, the following
     * events will be emitted in the following order:
     *
     * * `'socket'`
     * * `'response'`
     *    * `'data'` any number of times, on the `res` object
     * * (`req.destroy()` called here)
     * * `'aborted'` on the `res` object
     * * `'close'`
     * * `'error'` on the `res` object with an error with message `'Error: aborted'` and code `'ECONNRESET'`, or the error with which `req.destroy()` was called
     * * `'close'` on the `res` object
     *
     * If `req.abort()` is called before a socket is assigned, the following
     * events will be emitted in the following order:
     *
     * * (`req.abort()` called here)
     * * `'abort'`
     * * `'close'`
     *
     * If `req.abort()` is called before the connection succeeds, the following
     * events will be emitted in the following order:
     *
     * * `'socket'`
     * * (`req.abort()` called here)
     * * `'abort'`
     * * `'error'` with an error with message `'Error: socket hang up'` and code `'ECONNRESET'`
     * * `'close'`
     *
     * If `req.abort()` is called after the response is received, the following
     * events will be emitted in the following order:
     *
     * * `'socket'`
     * * `'response'`
     *    * `'data'` any number of times, on the `res` object
     * * (`req.abort()` called here)
     * * `'abort'`
     * * `'aborted'` on the `res` object
     * * `'error'` on the `res` object with an error with message `'Error: aborted'` and code `'ECONNRESET'`.
     * * `'close'`
     * * `'close'` on the `res` object
     *
     * Setting the `timeout` option or using the `setTimeout()` function will
     * not abort the request or do anything besides add a `'timeout'` event.
     *
     * Passing an `AbortSignal` and then calling `abort()` on the corresponding `AbortController` will behave the same way as calling `.destroy()` on the
     * request. Specifically, the `'error'` event will be emitted with an error with
     * the message `'AbortError: The operation was aborted'`, the code `'ABORT_ERR'` and the `cause`, if one was provided.
     * @since v0.3.6
     */
    function request(options: RequestOptions | string | URL, callback?: (res: IncomingMessage) => void): ClientRequest;
    function request(
        url: string | URL,
        options: RequestOptions,
        callback?: (res: IncomingMessage) => void,
    ): ClientRequest;
    /**
     * Since most requests are GET requests without bodies, Node.js provides this
     * convenience method. The only difference between this method and {@link request} is that it sets the method to GET by default and calls `req.end()` automatically. The callback must take care to
     * consume the response
     * data for reasons stated in {@link ClientRequest} section.
     *
     * The `callback` is invoked with a single argument that is an instance of {@link IncomingMessage}.
     *
     * JSON fetching example:
     *
     * ```js
     * http.get('http://localhost:8000/', (res) => {
     *   const { statusCode } = res;
     *   const contentType = res.headers['content-type'];
     *
     *   let error;
     *   // Any 2xx status code signals a successful response but
     *   // here we're only checking for 200.
     *   if (statusCode !== 200) {
     *     error = new Error('Request Failed.\n' +
     *                       `Status Code: ${statusCode}`);
     *   } else if (!/^application\/json/.test(contentType)) {
     *     error = new Error('Invalid content-type.\n' +
     *                       `Expected application/json but received ${contentType}`);
     *   }
     *   if (error) {
     *     console.error(error.message);
     *     // Consume response data to free up memory
     *     res.resume();
     *     return;
     *   }
     *
     *   res.setEncoding('utf8');
     *   let rawData = '';
     *   res.on('data', (chunk) => { rawData += chunk; });
     *   res.on('end', () => {
     *     try {
     *       const parsedData = JSON.parse(rawData);
     *       console.log(parsedData);
     *     } catch (e) {
     *       console.error(e.message);
     *     }
     *   });
     * }).on('error', (e) => {
     *   console.error(`Got error: ${e.message}`);
     * });
     *
     * // Create a local server to receive data from
     * const server = http.createServer((req, res) => {
     *   res.writeHead(200, { 'Content-Type': 'application/json' });
     *   res.end(JSON.stringify({
     *     data: 'Hello World!',
     *   }));
     * });
     *
     * server.listen(8000);
     * ```
     * @since v0.3.6
     * @param options Accepts the same `options` as {@link request}, with the method set to GET by default.
     */
    function get(options: RequestOptions | string | URL, callback?: (res: IncomingMessage) => void): ClientRequest;
    function get(url: string | URL, options: RequestOptions, callback?: (res: IncomingMessage) => void): ClientRequest;
    /**
     * Performs the low-level validations on the provided `name` that are done when `res.setHeader(name, value)` is called.
     *
     * Passing illegal value as `name` will result in a `TypeError` being thrown,
     * identified by `code: 'ERR_INVALID_HTTP_TOKEN'`.
     *
     * It is not necessary to use this method before passing headers to an HTTP request
     * or response. The HTTP module will automatically validate such headers.
     *
     * Example:
     *
     * ```js
     * import { validateHeaderName } from 'node:http';
     *
     * try {
     *   validateHeaderName('');
     * } catch (err) {
     *   console.error(err instanceof TypeError); // --> true
     *   console.error(err.code); // --> 'ERR_INVALID_HTTP_TOKEN'
     *   console.error(err.message); // --> 'Header name must be a valid HTTP token [""]'
     * }
     * ```
     * @since v14.3.0
     * @param [label='Header name'] Label for error message.
     */
    function validateHeaderName(name: string): void;
    /**
     * Performs the low-level validations on the provided `value` that are done when `res.setHeader(name, value)` is called.
     *
     * Passing illegal value as `value` will result in a `TypeError` being thrown.
     *
     * * Undefined value error is identified by `code: 'ERR_HTTP_INVALID_HEADER_VALUE'`.
     * * Invalid value character error is identified by `code: 'ERR_INVALID_CHAR'`.
     *
     * It is not necessary to use this method before passing headers to an HTTP request
     * or response. The HTTP module will automatically validate such headers.
     *
     * Examples:
     *
     * ```js
     * import { validateHeaderValue } from 'node:http';
     *
     * try {
     *   validateHeaderValue('x-my-header', undefined);
     * } catch (err) {
     *   console.error(err instanceof TypeError); // --> true
     *   console.error(err.code === 'ERR_HTTP_INVALID_HEADER_VALUE'); // --> true
     *   console.error(err.message); // --> 'Invalid value "undefined" for header "x-my-header"'
     * }
     *
     * try {
     *   validateHeaderValue('x-my-header', 'oʊmɪɡə');
     * } catch (err) {
     *   console.error(err instanceof TypeError); // --> true
     *   console.error(err.code === 'ERR_INVALID_CHAR'); // --> true
     *   console.error(err.message); // --> 'Invalid character in header content ["x-my-header"]'
     * }
     * ```
     * @since v14.3.0
     * @param name Header name
     * @param value Header value
     */
    function validateHeaderValue(name: string, value: string): void;
    /**
     * Set the maximum number of idle HTTP parsers.
     * @since v18.8.0, v16.18.0
     * @param [max=1000]
     */
    function setMaxIdleHTTPParsers(max: number): void;
    /**
     * Global instance of `Agent` which is used as the default for all HTTP client
     * requests. Diverges from a default `Agent` configuration by having `keepAlive`
     * enabled and a `timeout` of 5 seconds.
     * @since v0.5.9
     */
    let globalAgent: Agent;
    /**
     * Read-only property specifying the maximum allowed size of HTTP headers in bytes.
     * Defaults to 16KB. Configurable using the `--max-http-header-size` CLI option.
     */
    const maxHeaderSize: number;
    /**
     * A browser-compatible implementation of [WebSocket](https://nodejs.org/docs/latest/api/http.html#websocket).
     * @since v22.5.0
     */
    const WebSocket: import("undici-types").WebSocket;
    /**
     * @since v22.5.0
     */
    const CloseEvent: import("undici-types").CloseEvent;
    /**
     * @since v22.5.0
     */
    const MessageEvent: import("undici-types").MessageEvent;
}
declare module "node:http" {
    export * from "http";
}
/**
 * The `node:http2` module provides an implementation of the [HTTP/2](https://tools.ietf.org/html/rfc7540) protocol.
 * It can be accessed using:
 *
 * ```js
 * const http2 = require('node:http2');
 * ```
 * @since v8.4.0
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/http2.js)
 */
declare module "http2" {
    import EventEmitter = require("node:events");
    import * as fs from "node:fs";
    import * as net from "node:net";
    import * as stream from "node:stream";
    import * as tls from "node:tls";
    import * as url from "node:url";
    import {
        IncomingHttpHeaders as Http1IncomingHttpHeaders,
        IncomingMessage,
        OutgoingHttpHeaders,
        ServerResponse,
    } from "node:http";
    export { OutgoingHttpHeaders } from "node:http";
    export interface IncomingHttpStatusHeader {
        ":status"?: number | undefined;
    }
    export interface IncomingHttpHeaders extends Http1IncomingHttpHeaders {
        ":path"?: string | undefined;
        ":method"?: string | undefined;
        ":authority"?: string | undefined;
        ":scheme"?: string | undefined;
    }
    // Http2Stream
    export interface StreamPriorityOptions {
        exclusive?: boolean | undefined;
        parent?: number | undefined;
        weight?: number | undefined;
        silent?: boolean | undefined;
    }
    export interface StreamState {
        localWindowSize?: number | undefined;
        state?: number | undefined;
        localClose?: number | undefined;
        remoteClose?: number | undefined;
        sumDependencyWeight?: number | undefined;
        weight?: number | undefined;
    }
    export interface ServerStreamResponseOptions {
        endStream?: boolean | undefined;
        waitForTrailers?: boolean | undefined;
    }
    export interface StatOptions {
        offset: number;
        length: number;
    }
    export interface ServerStreamFileResponseOptions {
        // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
        statCheck?(stats: fs.Stats, headers: OutgoingHttpHeaders, statOptions: StatOptions): void | boolean;
        waitForTrailers?: boolean | undefined;
        offset?: number | undefined;
        length?: number | undefined;
    }
    export interface ServerStreamFileResponseOptionsWithError extends ServerStreamFileResponseOptions {
        onError?(err: NodeJS.ErrnoException): void;
    }
    export interface Http2Stream extends stream.Duplex {
        /**
         * Set to `true` if the `Http2Stream` instance was aborted abnormally. When set,
         * the `'aborted'` event will have been emitted.
         * @since v8.4.0
         */
        readonly aborted: boolean;
        /**
         * This property shows the number of characters currently buffered to be written.
         * See `net.Socket.bufferSize` for details.
         * @since v11.2.0, v10.16.0
         */
        readonly bufferSize: number;
        /**
         * Set to `true` if the `Http2Stream` instance has been closed.
         * @since v9.4.0
         */
        readonly closed: boolean;
        /**
         * Set to `true` if the `Http2Stream` instance has been destroyed and is no longer
         * usable.
         * @since v8.4.0
         */
        readonly destroyed: boolean;
        /**
         * Set to `true` if the `END_STREAM` flag was set in the request or response
         * HEADERS frame received, indicating that no additional data should be received
         * and the readable side of the `Http2Stream` will be closed.
         * @since v10.11.0
         */
        readonly endAfterHeaders: boolean;
        /**
         * The numeric stream identifier of this `Http2Stream` instance. Set to `undefined` if the stream identifier has not yet been assigned.
         * @since v8.4.0
         */
        readonly id?: number | undefined;
        /**
         * Set to `true` if the `Http2Stream` instance has not yet been assigned a
         * numeric stream identifier.
         * @since v9.4.0
         */
        readonly pending: boolean;
        /**
         * Set to the `RST_STREAM` `error code` reported when the `Http2Stream` is
         * destroyed after either receiving an `RST_STREAM` frame from the connected peer,
         * calling `http2stream.close()`, or `http2stream.destroy()`. Will be `undefined` if the `Http2Stream` has not been closed.
         * @since v8.4.0
         */
        readonly rstCode: number;
        /**
         * An object containing the outbound headers sent for this `Http2Stream`.
         * @since v9.5.0
         */
        readonly sentHeaders: OutgoingHttpHeaders;
        /**
         * An array of objects containing the outbound informational (additional) headers
         * sent for this `Http2Stream`.
         * @since v9.5.0
         */
        readonly sentInfoHeaders?: OutgoingHttpHeaders[] | undefined;
        /**
         * An object containing the outbound trailers sent for this `HttpStream`.
         * @since v9.5.0
         */
        readonly sentTrailers?: OutgoingHttpHeaders | undefined;
        /**
         * A reference to the `Http2Session` instance that owns this `Http2Stream`. The
         * value will be `undefined` after the `Http2Stream` instance is destroyed.
         * @since v8.4.0
         */
        readonly session: Http2Session | undefined;
        /**
         * Provides miscellaneous information about the current state of the `Http2Stream`.
         *
         * A current state of this `Http2Stream`.
         * @since v8.4.0
         */
        readonly state: StreamState;
        /**
         * Closes the `Http2Stream` instance by sending an `RST_STREAM` frame to the
         * connected HTTP/2 peer.
         * @since v8.4.0
         * @param [code=http2.constants.NGHTTP2_NO_ERROR] Unsigned 32-bit integer identifying the error code.
         * @param callback An optional function registered to listen for the `'close'` event.
         */
        close(code?: number, callback?: () => void): void;
        /**
         * Updates the priority for this `Http2Stream` instance.
         * @since v8.4.0
         */
        priority(options: StreamPriorityOptions): void;
        /**
         * ```js
         * const http2 = require('node:http2');
         * const client = http2.connect('http://example.org:8000');
         * const { NGHTTP2_CANCEL } = http2.constants;
         * const req = client.request({ ':path': '/' });
         *
         * // Cancel the stream if there's no activity after 5 seconds
         * req.setTimeout(5000, () => req.close(NGHTTP2_CANCEL));
         * ```
         * @since v8.4.0
         */
        setTimeout(msecs: number, callback?: () => void): void;
        /**
         * Sends a trailing `HEADERS` frame to the connected HTTP/2 peer. This method
         * will cause the `Http2Stream` to be immediately closed and must only be
         * called after the `'wantTrailers'` event has been emitted. When sending a
         * request or sending a response, the `options.waitForTrailers` option must be set
         * in order to keep the `Http2Stream` open after the final `DATA` frame so that
         * trailers can be sent.
         *
         * ```js
         * const http2 = require('node:http2');
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   stream.respond(undefined, { waitForTrailers: true });
         *   stream.on('wantTrailers', () => {
         *     stream.sendTrailers({ xyz: 'abc' });
         *   });
         *   stream.end('Hello World');
         * });
         * ```
         *
         * The HTTP/1 specification forbids trailers from containing HTTP/2 pseudo-header
         * fields (e.g. `':method'`, `':path'`, etc).
         * @since v10.0.0
         */
        sendTrailers(headers: OutgoingHttpHeaders): void;
        addListener(event: "aborted", listener: () => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        addListener(event: "drain", listener: () => void): this;
        addListener(event: "end", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "finish", listener: () => void): this;
        addListener(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
        addListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        addListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        addListener(event: "streamClosed", listener: (code: number) => void): this;
        addListener(event: "timeout", listener: () => void): this;
        addListener(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        addListener(event: "wantTrailers", listener: () => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "aborted"): boolean;
        emit(event: "close"): boolean;
        emit(event: "data", chunk: Buffer | string): boolean;
        emit(event: "drain"): boolean;
        emit(event: "end"): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "finish"): boolean;
        emit(event: "frameError", frameType: number, errorCode: number): boolean;
        emit(event: "pipe", src: stream.Readable): boolean;
        emit(event: "unpipe", src: stream.Readable): boolean;
        emit(event: "streamClosed", code: number): boolean;
        emit(event: "timeout"): boolean;
        emit(event: "trailers", trailers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: "wantTrailers"): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "aborted", listener: () => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "data", listener: (chunk: Buffer | string) => void): this;
        on(event: "drain", listener: () => void): this;
        on(event: "end", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "finish", listener: () => void): this;
        on(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
        on(event: "pipe", listener: (src: stream.Readable) => void): this;
        on(event: "unpipe", listener: (src: stream.Readable) => void): this;
        on(event: "streamClosed", listener: (code: number) => void): this;
        on(event: "timeout", listener: () => void): this;
        on(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        on(event: "wantTrailers", listener: () => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "aborted", listener: () => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "data", listener: (chunk: Buffer | string) => void): this;
        once(event: "drain", listener: () => void): this;
        once(event: "end", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "finish", listener: () => void): this;
        once(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
        once(event: "pipe", listener: (src: stream.Readable) => void): this;
        once(event: "unpipe", listener: (src: stream.Readable) => void): this;
        once(event: "streamClosed", listener: (code: number) => void): this;
        once(event: "timeout", listener: () => void): this;
        once(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        once(event: "wantTrailers", listener: () => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "aborted", listener: () => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        prependListener(event: "drain", listener: () => void): this;
        prependListener(event: "end", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "finish", listener: () => void): this;
        prependListener(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
        prependListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        prependListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        prependListener(event: "streamClosed", listener: (code: number) => void): this;
        prependListener(event: "timeout", listener: () => void): this;
        prependListener(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        prependListener(event: "wantTrailers", listener: () => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "aborted", listener: () => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        prependOnceListener(event: "drain", listener: () => void): this;
        prependOnceListener(event: "end", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: "finish", listener: () => void): this;
        prependOnceListener(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
        prependOnceListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: "streamClosed", listener: (code: number) => void): this;
        prependOnceListener(event: "timeout", listener: () => void): this;
        prependOnceListener(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        prependOnceListener(event: "wantTrailers", listener: () => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface ClientHttp2Stream extends Http2Stream {
        addListener(event: "continue", listener: () => {}): this;
        addListener(
            event: "headers",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        addListener(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        addListener(
            event: "response",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "continue"): boolean;
        emit(event: "headers", headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;
        emit(event: "push", headers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: "response", headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "continue", listener: () => {}): this;
        on(
            event: "headers",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        on(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        on(
            event: "response",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "continue", listener: () => {}): this;
        once(
            event: "headers",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        once(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        once(
            event: "response",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "continue", listener: () => {}): this;
        prependListener(
            event: "headers",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        prependListener(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        prependListener(
            event: "response",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "continue", listener: () => {}): this;
        prependOnceListener(
            event: "headers",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        prependOnceListener(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        prependOnceListener(
            event: "response",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface ServerHttp2Stream extends Http2Stream {
        /**
         * True if headers were sent, false otherwise (read-only).
         * @since v8.4.0
         */
        readonly headersSent: boolean;
        /**
         * Read-only property mapped to the `SETTINGS_ENABLE_PUSH` flag of the remote
         * client's most recent `SETTINGS` frame. Will be `true` if the remote peer
         * accepts push streams, `false` otherwise. Settings are the same for every `Http2Stream` in the same `Http2Session`.
         * @since v8.4.0
         */
        readonly pushAllowed: boolean;
        /**
         * Sends an additional informational `HEADERS` frame to the connected HTTP/2 peer.
         * @since v8.4.0
         */
        additionalHeaders(headers: OutgoingHttpHeaders): void;
        /**
         * Initiates a push stream. The callback is invoked with the new `Http2Stream` instance created for the push stream passed as the second argument, or an `Error` passed as the first argument.
         *
         * ```js
         * const http2 = require('node:http2');
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   stream.respond({ ':status': 200 });
         *   stream.pushStream({ ':path': '/' }, (err, pushStream, headers) => {
         *     if (err) throw err;
         *     pushStream.respond({ ':status': 200 });
         *     pushStream.end('some pushed data');
         *   });
         *   stream.end('some data');
         * });
         * ```
         *
         * Setting the weight of a push stream is not allowed in the `HEADERS` frame. Pass
         * a `weight` value to `http2stream.priority` with the `silent` option set to `true` to enable server-side bandwidth balancing between concurrent streams.
         *
         * Calling `http2stream.pushStream()` from within a pushed stream is not permitted
         * and will throw an error.
         * @since v8.4.0
         * @param callback Callback that is called once the push stream has been initiated.
         */
        pushStream(
            headers: OutgoingHttpHeaders,
            callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void,
        ): void;
        pushStream(
            headers: OutgoingHttpHeaders,
            options?: StreamPriorityOptions,
            callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void,
        ): void;
        /**
         * ```js
         * const http2 = require('node:http2');
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   stream.respond({ ':status': 200 });
         *   stream.end('some data');
         * });
         * ```
         *
         * Initiates a response. When the `options.waitForTrailers` option is set, the`'wantTrailers'` event will be emitted immediately after queuing the last chunk
         * of payload data to be sent. The `http2stream.sendTrailers()` method can then be
         * used to sent trailing header fields to the peer.
         *
         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
         * close when the final `DATA` frame is transmitted. User code must call either `http2stream.sendTrailers()` or `http2stream.close()` to close the `Http2Stream`.
         *
         * ```js
         * const http2 = require('node:http2');
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   stream.respond({ ':status': 200 }, { waitForTrailers: true });
         *   stream.on('wantTrailers', () => {
         *     stream.sendTrailers({ ABC: 'some value to send' });
         *   });
         *   stream.end('some data');
         * });
         * ```
         * @since v8.4.0
         */
        respond(headers?: OutgoingHttpHeaders, options?: ServerStreamResponseOptions): void;
        /**
         * Initiates a response whose data is read from the given file descriptor. No
         * validation is performed on the given file descriptor. If an error occurs while
         * attempting to read data using the file descriptor, the `Http2Stream` will be
         * closed using an `RST_STREAM` frame using the standard `INTERNAL_ERROR` code.
         *
         * When used, the `Http2Stream` object's `Duplex` interface will be closed
         * automatically.
         *
         * ```js
         * const http2 = require('node:http2');
         * const fs = require('node:fs');
         *
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   const fd = fs.openSync('/some/file', 'r');
         *
         *   const stat = fs.fstatSync(fd);
         *   const headers = {
         *     'content-length': stat.size,
         *     'last-modified': stat.mtime.toUTCString(),
         *     'content-type': 'text/plain; charset=utf-8',
         *   };
         *   stream.respondWithFD(fd, headers);
         *   stream.on('close', () => fs.closeSync(fd));
         * });
         * ```
         *
         * The optional `options.statCheck` function may be specified to give user code
         * an opportunity to set additional content headers based on the `fs.Stat` details
         * of the given fd. If the `statCheck` function is provided, the `http2stream.respondWithFD()` method will perform an `fs.fstat()` call to
         * collect details on the provided file descriptor.
         *
         * The `offset` and `length` options may be used to limit the response to a
         * specific range subset. This can be used, for instance, to support HTTP Range
         * requests.
         *
         * The file descriptor or `FileHandle` is not closed when the stream is closed,
         * so it will need to be closed manually once it is no longer needed.
         * Using the same file descriptor concurrently for multiple streams
         * is not supported and may result in data loss. Re-using a file descriptor
         * after a stream has finished is supported.
         *
         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
         * will be emitted immediately after queuing the last chunk of payload data to be
         * sent. The `http2stream.sendTrailers()` method can then be used to sent trailing
         * header fields to the peer.
         *
         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
         * close when the final `DATA` frame is transmitted. User code _must_ call either `http2stream.sendTrailers()` or `http2stream.close()` to close the `Http2Stream`.
         *
         * ```js
         * const http2 = require('node:http2');
         * const fs = require('node:fs');
         *
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   const fd = fs.openSync('/some/file', 'r');
         *
         *   const stat = fs.fstatSync(fd);
         *   const headers = {
         *     'content-length': stat.size,
         *     'last-modified': stat.mtime.toUTCString(),
         *     'content-type': 'text/plain; charset=utf-8',
         *   };
         *   stream.respondWithFD(fd, headers, { waitForTrailers: true });
         *   stream.on('wantTrailers', () => {
         *     stream.sendTrailers({ ABC: 'some value to send' });
         *   });
         *
         *   stream.on('close', () => fs.closeSync(fd));
         * });
         * ```
         * @since v8.4.0
         * @param fd A readable file descriptor.
         */
        respondWithFD(
            fd: number | fs.promises.FileHandle,
            headers?: OutgoingHttpHeaders,
            options?: ServerStreamFileResponseOptions,
        ): void;
        /**
         * Sends a regular file as the response. The `path` must specify a regular file
         * or an `'error'` event will be emitted on the `Http2Stream` object.
         *
         * When used, the `Http2Stream` object's `Duplex` interface will be closed
         * automatically.
         *
         * The optional `options.statCheck` function may be specified to give user code
         * an opportunity to set additional content headers based on the `fs.Stat` details
         * of the given file:
         *
         * If an error occurs while attempting to read the file data, the `Http2Stream` will be closed using an `RST_STREAM` frame using the standard `INTERNAL_ERROR` code. If the `onError` callback is
         * defined, then it will be called. Otherwise
         * the stream will be destroyed.
         *
         * Example using a file path:
         *
         * ```js
         * const http2 = require('node:http2');
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   function statCheck(stat, headers) {
         *     headers['last-modified'] = stat.mtime.toUTCString();
         *   }
         *
         *   function onError(err) {
         *     // stream.respond() can throw if the stream has been destroyed by
         *     // the other side.
         *     try {
         *       if (err.code === 'ENOENT') {
         *         stream.respond({ ':status': 404 });
         *       } else {
         *         stream.respond({ ':status': 500 });
         *       }
         *     } catch (err) {
         *       // Perform actual error handling.
         *       console.error(err);
         *     }
         *     stream.end();
         *   }
         *
         *   stream.respondWithFile('/some/file',
         *                          { 'content-type': 'text/plain; charset=utf-8' },
         *                          { statCheck, onError });
         * });
         * ```
         *
         * The `options.statCheck` function may also be used to cancel the send operation
         * by returning `false`. For instance, a conditional request may check the stat
         * results to determine if the file has been modified to return an appropriate `304` response:
         *
         * ```js
         * const http2 = require('node:http2');
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   function statCheck(stat, headers) {
         *     // Check the stat here...
         *     stream.respond({ ':status': 304 });
         *     return false; // Cancel the send operation
         *   }
         *   stream.respondWithFile('/some/file',
         *                          { 'content-type': 'text/plain; charset=utf-8' },
         *                          { statCheck });
         * });
         * ```
         *
         * The `content-length` header field will be automatically set.
         *
         * The `offset` and `length` options may be used to limit the response to a
         * specific range subset. This can be used, for instance, to support HTTP Range
         * requests.
         *
         * The `options.onError` function may also be used to handle all the errors
         * that could happen before the delivery of the file is initiated. The
         * default behavior is to destroy the stream.
         *
         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
         * will be emitted immediately after queuing the last chunk of payload data to be
         * sent. The `http2stream.sendTrailers()` method can then be used to sent trailing
         * header fields to the peer.
         *
         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
         * close when the final `DATA` frame is transmitted. User code must call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.
         *
         * ```js
         * const http2 = require('node:http2');
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   stream.respondWithFile('/some/file',
         *                          { 'content-type': 'text/plain; charset=utf-8' },
         *                          { waitForTrailers: true });
         *   stream.on('wantTrailers', () => {
         *     stream.sendTrailers({ ABC: 'some value to send' });
         *   });
         * });
         * ```
         * @since v8.4.0
         */
        respondWithFile(
            path: string,
            headers?: OutgoingHttpHeaders,
            options?: ServerStreamFileResponseOptionsWithError,
        ): void;
    }
    // Http2Session
    export interface Settings {
        headerTableSize?: number | undefined;
        enablePush?: boolean | undefined;
        initialWindowSize?: number | undefined;
        maxFrameSize?: number | undefined;
        maxConcurrentStreams?: number | undefined;
        maxHeaderListSize?: number | undefined;
        enableConnectProtocol?: boolean | undefined;
    }
    export interface ClientSessionRequestOptions {
        endStream?: boolean | undefined;
        exclusive?: boolean | undefined;
        parent?: number | undefined;
        weight?: number | undefined;
        waitForTrailers?: boolean | undefined;
        signal?: AbortSignal | undefined;
    }
    export interface SessionState {
        effectiveLocalWindowSize?: number | undefined;
        effectiveRecvDataLength?: number | undefined;
        nextStreamID?: number | undefined;
        localWindowSize?: number | undefined;
        lastProcStreamID?: number | undefined;
        remoteWindowSize?: number | undefined;
        outboundQueueSize?: number | undefined;
        deflateDynamicTableSize?: number | undefined;
        inflateDynamicTableSize?: number | undefined;
    }
    export interface Http2Session extends EventEmitter {
        /**
         * Value will be `undefined` if the `Http2Session` is not yet connected to a
         * socket, `h2c` if the `Http2Session` is not connected to a `TLSSocket`, or
         * will return the value of the connected `TLSSocket`'s own `alpnProtocol` property.
         * @since v9.4.0
         */
        readonly alpnProtocol?: string | undefined;
        /**
         * Will be `true` if this `Http2Session` instance has been closed, otherwise `false`.
         * @since v9.4.0
         */
        readonly closed: boolean;
        /**
         * Will be `true` if this `Http2Session` instance is still connecting, will be set
         * to `false` before emitting `connect` event and/or calling the `http2.connect` callback.
         * @since v10.0.0
         */
        readonly connecting: boolean;
        /**
         * Will be `true` if this `Http2Session` instance has been destroyed and must no
         * longer be used, otherwise `false`.
         * @since v8.4.0
         */
        readonly destroyed: boolean;
        /**
         * Value is `undefined` if the `Http2Session` session socket has not yet been
         * connected, `true` if the `Http2Session` is connected with a `TLSSocket`,
         * and `false` if the `Http2Session` is connected to any other kind of socket
         * or stream.
         * @since v9.4.0
         */
        readonly encrypted?: boolean | undefined;
        /**
         * A prototype-less object describing the current local settings of this `Http2Session`. The local settings are local to _this_`Http2Session` instance.
         * @since v8.4.0
         */
        readonly localSettings: Settings;
        /**
         * If the `Http2Session` is connected to a `TLSSocket`, the `originSet` property
         * will return an `Array` of origins for which the `Http2Session` may be
         * considered authoritative.
         *
         * The `originSet` property is only available when using a secure TLS connection.
         * @since v9.4.0
         */
        readonly originSet?: string[] | undefined;
        /**
         * Indicates whether the `Http2Session` is currently waiting for acknowledgment of
         * a sent `SETTINGS` frame. Will be `true` after calling the `http2session.settings()` method. Will be `false` once all sent `SETTINGS` frames have been acknowledged.
         * @since v8.4.0
         */
        readonly pendingSettingsAck: boolean;
        /**
         * A prototype-less object describing the current remote settings of this`Http2Session`. The remote settings are set by the _connected_ HTTP/2 peer.
         * @since v8.4.0
         */
        readonly remoteSettings: Settings;
        /**
         * Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but
         * limits available methods to ones safe to use with HTTP/2.
         *
         * `destroy`, `emit`, `end`, `pause`, `read`, `resume`, and `write` will throw
         * an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for more information.
         *
         * `setTimeout` method will be called on this `Http2Session`.
         *
         * All other interactions will be routed directly to the socket.
         * @since v8.4.0
         */
        readonly socket: net.Socket | tls.TLSSocket;
        /**
         * Provides miscellaneous information about the current state of the`Http2Session`.
         *
         * An object describing the current status of this `Http2Session`.
         * @since v8.4.0
         */
        readonly state: SessionState;
        /**
         * The `http2session.type` will be equal to `http2.constants.NGHTTP2_SESSION_SERVER` if this `Http2Session` instance is a
         * server, and `http2.constants.NGHTTP2_SESSION_CLIENT` if the instance is a
         * client.
         * @since v8.4.0
         */
        readonly type: number;
        /**
         * Gracefully closes the `Http2Session`, allowing any existing streams to
         * complete on their own and preventing new `Http2Stream` instances from being
         * created. Once closed, `http2session.destroy()`_might_ be called if there
         * are no open `Http2Stream` instances.
         *
         * If specified, the `callback` function is registered as a handler for the`'close'` event.
         * @since v9.4.0
         */
        close(callback?: () => void): void;
        /**
         * Immediately terminates the `Http2Session` and the associated `net.Socket` or `tls.TLSSocket`.
         *
         * Once destroyed, the `Http2Session` will emit the `'close'` event. If `error` is not undefined, an `'error'` event will be emitted immediately before the `'close'` event.
         *
         * If there are any remaining open `Http2Streams` associated with the `Http2Session`, those will also be destroyed.
         * @since v8.4.0
         * @param error An `Error` object if the `Http2Session` is being destroyed due to an error.
         * @param code The HTTP/2 error code to send in the final `GOAWAY` frame. If unspecified, and `error` is not undefined, the default is `INTERNAL_ERROR`, otherwise defaults to `NO_ERROR`.
         */
        destroy(error?: Error, code?: number): void;
        /**
         * Transmits a `GOAWAY` frame to the connected peer _without_ shutting down the`Http2Session`.
         * @since v9.4.0
         * @param code An HTTP/2 error code
         * @param lastStreamID The numeric ID of the last processed `Http2Stream`
         * @param opaqueData A `TypedArray` or `DataView` instance containing additional data to be carried within the `GOAWAY` frame.
         */
        goaway(code?: number, lastStreamID?: number, opaqueData?: NodeJS.ArrayBufferView): void;
        /**
         * Sends a `PING` frame to the connected HTTP/2 peer. A `callback` function must
         * be provided. The method will return `true` if the `PING` was sent, `false` otherwise.
         *
         * The maximum number of outstanding (unacknowledged) pings is determined by the `maxOutstandingPings` configuration option. The default maximum is 10.
         *
         * If provided, the `payload` must be a `Buffer`, `TypedArray`, or `DataView` containing 8 bytes of data that will be transmitted with the `PING` and
         * returned with the ping acknowledgment.
         *
         * The callback will be invoked with three arguments: an error argument that will
         * be `null` if the `PING` was successfully acknowledged, a `duration` argument
         * that reports the number of milliseconds elapsed since the ping was sent and the
         * acknowledgment was received, and a `Buffer` containing the 8-byte `PING` payload.
         *
         * ```js
         * session.ping(Buffer.from('abcdefgh'), (err, duration, payload) => {
         *   if (!err) {
         *     console.log(`Ping acknowledged in ${duration} milliseconds`);
         *     console.log(`With payload '${payload.toString()}'`);
         *   }
         * });
         * ```
         *
         * If the `payload` argument is not specified, the default payload will be the
         * 64-bit timestamp (little endian) marking the start of the `PING` duration.
         * @since v8.9.3
         * @param payload Optional ping payload.
         */
        ping(callback: (err: Error | null, duration: number, payload: Buffer) => void): boolean;
        ping(
            payload: NodeJS.ArrayBufferView,
            callback: (err: Error | null, duration: number, payload: Buffer) => void,
        ): boolean;
        /**
         * Calls `ref()` on this `Http2Session` instance's underlying `net.Socket`.
         * @since v9.4.0
         */
        ref(): void;
        /**
         * Sets the local endpoint's window size.
         * The `windowSize` is the total window size to set, not
         * the delta.
         *
         * ```js
         * const http2 = require('node:http2');
         *
         * const server = http2.createServer();
         * const expectedWindowSize = 2 ** 20;
         * server.on('connect', (session) => {
         *
         *   // Set local window size to be 2 ** 20
         *   session.setLocalWindowSize(expectedWindowSize);
         * });
         * ```
         * @since v15.3.0, v14.18.0
         */
        setLocalWindowSize(windowSize: number): void;
        /**
         * Used to set a callback function that is called when there is no activity on
         * the `Http2Session` after `msecs` milliseconds. The given `callback` is
         * registered as a listener on the `'timeout'` event.
         * @since v8.4.0
         */
        setTimeout(msecs: number, callback?: () => void): void;
        /**
         * Updates the current local settings for this `Http2Session` and sends a new `SETTINGS` frame to the connected HTTP/2 peer.
         *
         * Once called, the `http2session.pendingSettingsAck` property will be `true` while the session is waiting for the remote peer to acknowledge the new
         * settings.
         *
         * The new settings will not become effective until the `SETTINGS` acknowledgment
         * is received and the `'localSettings'` event is emitted. It is possible to send
         * multiple `SETTINGS` frames while acknowledgment is still pending.
         * @since v8.4.0
         * @param callback Callback that is called once the session is connected or right away if the session is already connected.
         */
        settings(
            settings: Settings,
            callback?: (err: Error | null, settings: Settings, duration: number) => void,
        ): void;
        /**
         * Calls `unref()` on this `Http2Session`instance's underlying `net.Socket`.
         * @since v9.4.0
         */
        unref(): void;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(
            event: "frameError",
            listener: (frameType: number, errorCode: number, streamID: number) => void,
        ): this;
        addListener(
            event: "goaway",
            listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void,
        ): this;
        addListener(event: "localSettings", listener: (settings: Settings) => void): this;
        addListener(event: "ping", listener: () => void): this;
        addListener(event: "remoteSettings", listener: (settings: Settings) => void): this;
        addListener(event: "timeout", listener: () => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "close"): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "frameError", frameType: number, errorCode: number, streamID: number): boolean;
        emit(event: "goaway", errorCode: number, lastStreamID: number, opaqueData?: Buffer): boolean;
        emit(event: "localSettings", settings: Settings): boolean;
        emit(event: "ping"): boolean;
        emit(event: "remoteSettings", settings: Settings): boolean;
        emit(event: "timeout"): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "close", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "frameError", listener: (frameType: number, errorCode: number, streamID: number) => void): this;
        on(event: "goaway", listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void): this;
        on(event: "localSettings", listener: (settings: Settings) => void): this;
        on(event: "ping", listener: () => void): this;
        on(event: "remoteSettings", listener: (settings: Settings) => void): this;
        on(event: "timeout", listener: () => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "frameError", listener: (frameType: number, errorCode: number, streamID: number) => void): this;
        once(event: "goaway", listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void): this;
        once(event: "localSettings", listener: (settings: Settings) => void): this;
        once(event: "ping", listener: () => void): this;
        once(event: "remoteSettings", listener: (settings: Settings) => void): this;
        once(event: "timeout", listener: () => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(
            event: "frameError",
            listener: (frameType: number, errorCode: number, streamID: number) => void,
        ): this;
        prependListener(
            event: "goaway",
            listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void,
        ): this;
        prependListener(event: "localSettings", listener: (settings: Settings) => void): this;
        prependListener(event: "ping", listener: () => void): this;
        prependListener(event: "remoteSettings", listener: (settings: Settings) => void): this;
        prependListener(event: "timeout", listener: () => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(
            event: "frameError",
            listener: (frameType: number, errorCode: number, streamID: number) => void,
        ): this;
        prependOnceListener(
            event: "goaway",
            listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void,
        ): this;
        prependOnceListener(event: "localSettings", listener: (settings: Settings) => void): this;
        prependOnceListener(event: "ping", listener: () => void): this;
        prependOnceListener(event: "remoteSettings", listener: (settings: Settings) => void): this;
        prependOnceListener(event: "timeout", listener: () => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface ClientHttp2Session extends Http2Session {
        /**
         * For HTTP/2 Client `Http2Session` instances only, the `http2session.request()` creates and returns an `Http2Stream` instance that can be used to send an
         * HTTP/2 request to the connected server.
         *
         * When a `ClientHttp2Session` is first created, the socket may not yet be
         * connected. if `clienthttp2session.request()` is called during this time, the
         * actual request will be deferred until the socket is ready to go.
         * If the `session` is closed before the actual request be executed, an `ERR_HTTP2_GOAWAY_SESSION` is thrown.
         *
         * This method is only available if `http2session.type` is equal to `http2.constants.NGHTTP2_SESSION_CLIENT`.
         *
         * ```js
         * const http2 = require('node:http2');
         * const clientSession = http2.connect('https://localhost:1234');
         * const {
         *   HTTP2_HEADER_PATH,
         *   HTTP2_HEADER_STATUS,
         * } = http2.constants;
         *
         * const req = clientSession.request({ [HTTP2_HEADER_PATH]: '/' });
         * req.on('response', (headers) => {
         *   console.log(headers[HTTP2_HEADER_STATUS]);
         *   req.on('data', (chunk) => { // ..  });
         *   req.on('end', () => { // ..  });
         * });
         * ```
         *
         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
         * is emitted immediately after queuing the last chunk of payload data to be sent.
         * The `http2stream.sendTrailers()` method can then be called to send trailing
         * headers to the peer.
         *
         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
         * close when the final `DATA` frame is transmitted. User code must call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.
         *
         * When `options.signal` is set with an `AbortSignal` and then `abort` on the
         * corresponding `AbortController` is called, the request will emit an `'error'`event with an `AbortError` error.
         *
         * The `:method` and `:path` pseudo-headers are not specified within `headers`,
         * they respectively default to:
         *
         * * `:method` \= `'GET'`
         * * `:path` \= `/`
         * @since v8.4.0
         */
        request(headers?: OutgoingHttpHeaders, options?: ClientSessionRequestOptions): ClientHttp2Stream;
        addListener(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
        addListener(event: "origin", listener: (origins: string[]) => void): this;
        addListener(
            event: "connect",
            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
        ): this;
        addListener(
            event: "stream",
            listener: (
                stream: ClientHttp2Stream,
                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
                flags: number,
            ) => void,
        ): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "altsvc", alt: string, origin: string, stream: number): boolean;
        emit(event: "origin", origins: readonly string[]): boolean;
        emit(event: "connect", session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;
        emit(
            event: "stream",
            stream: ClientHttp2Stream,
            headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
            flags: number,
        ): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
        on(event: "origin", listener: (origins: string[]) => void): this;
        on(event: "connect", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
        on(
            event: "stream",
            listener: (
                stream: ClientHttp2Stream,
                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
                flags: number,
            ) => void,
        ): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
        once(event: "origin", listener: (origins: string[]) => void): this;
        once(
            event: "connect",
            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
        ): this;
        once(
            event: "stream",
            listener: (
                stream: ClientHttp2Stream,
                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
                flags: number,
            ) => void,
        ): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
        prependListener(event: "origin", listener: (origins: string[]) => void): this;
        prependListener(
            event: "connect",
            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
        ): this;
        prependListener(
            event: "stream",
            listener: (
                stream: ClientHttp2Stream,
                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
                flags: number,
            ) => void,
        ): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
        prependOnceListener(event: "origin", listener: (origins: string[]) => void): this;
        prependOnceListener(
            event: "connect",
            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
        ): this;
        prependOnceListener(
            event: "stream",
            listener: (
                stream: ClientHttp2Stream,
                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
                flags: number,
            ) => void,
        ): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface AlternativeServiceOptions {
        origin: number | string | url.URL;
    }
    export interface ServerHttp2Session extends Http2Session {
        readonly server: Http2Server | Http2SecureServer;
        /**
         * Submits an `ALTSVC` frame (as defined by [RFC 7838](https://tools.ietf.org/html/rfc7838)) to the connected client.
         *
         * ```js
         * const http2 = require('node:http2');
         *
         * const server = http2.createServer();
         * server.on('session', (session) => {
         *   // Set altsvc for origin https://example.org:80
         *   session.altsvc('h2=":8000"', 'https://example.org:80');
         * });
         *
         * server.on('stream', (stream) => {
         *   // Set altsvc for a specific stream
         *   stream.session.altsvc('h2=":8000"', stream.id);
         * });
         * ```
         *
         * Sending an `ALTSVC` frame with a specific stream ID indicates that the alternate
         * service is associated with the origin of the given `Http2Stream`.
         *
         * The `alt` and origin string _must_ contain only ASCII bytes and are
         * strictly interpreted as a sequence of ASCII bytes. The special value `'clear'`may be passed to clear any previously set alternative service for a given
         * domain.
         *
         * When a string is passed for the `originOrStream` argument, it will be parsed as
         * a URL and the origin will be derived. For instance, the origin for the
         * HTTP URL `'https://example.org/foo/bar'` is the ASCII string`'https://example.org'`. An error will be thrown if either the given string
         * cannot be parsed as a URL or if a valid origin cannot be derived.
         *
         * A `URL` object, or any object with an `origin` property, may be passed as`originOrStream`, in which case the value of the `origin` property will be
         * used. The value of the `origin` property _must_ be a properly serialized
         * ASCII origin.
         * @since v9.4.0
         * @param alt A description of the alternative service configuration as defined by `RFC 7838`.
         * @param originOrStream Either a URL string specifying the origin (or an `Object` with an `origin` property) or the numeric identifier of an active `Http2Stream` as given by the
         * `http2stream.id` property.
         */
        altsvc(alt: string, originOrStream: number | string | url.URL | AlternativeServiceOptions): void;
        /**
         * Submits an `ORIGIN` frame (as defined by [RFC 8336](https://tools.ietf.org/html/rfc8336)) to the connected client
         * to advertise the set of origins for which the server is capable of providing
         * authoritative responses.
         *
         * ```js
         * const http2 = require('node:http2');
         * const options = getSecureOptionsSomehow();
         * const server = http2.createSecureServer(options);
         * server.on('stream', (stream) => {
         *   stream.respond();
         *   stream.end('ok');
         * });
         * server.on('session', (session) => {
         *   session.origin('https://example.com', 'https://example.org');
         * });
         * ```
         *
         * When a string is passed as an `origin`, it will be parsed as a URL and the
         * origin will be derived. For instance, the origin for the HTTP URL `'https://example.org/foo/bar'` is the ASCII string` 'https://example.org'`. An error will be thrown if either the given
         * string
         * cannot be parsed as a URL or if a valid origin cannot be derived.
         *
         * A `URL` object, or any object with an `origin` property, may be passed as
         * an `origin`, in which case the value of the `origin` property will be
         * used. The value of the `origin` property _must_ be a properly serialized
         * ASCII origin.
         *
         * Alternatively, the `origins` option may be used when creating a new HTTP/2
         * server using the `http2.createSecureServer()` method:
         *
         * ```js
         * const http2 = require('node:http2');
         * const options = getSecureOptionsSomehow();
         * options.origins = ['https://example.com', 'https://example.org'];
         * const server = http2.createSecureServer(options);
         * server.on('stream', (stream) => {
         *   stream.respond();
         *   stream.end('ok');
         * });
         * ```
         * @since v10.12.0
         * @param origins One or more URL Strings passed as separate arguments.
         */
        origin(
            ...origins: Array<
                | string
                | url.URL
                | {
                    origin: string;
                }
            >
        ): void;
        addListener(
            event: "connect",
            listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
        ): this;
        addListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "connect", session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;
        emit(event: "stream", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "connect", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
        on(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(
            event: "connect",
            listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
        ): this;
        once(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(
            event: "connect",
            listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
        ): this;
        prependListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(
            event: "connect",
            listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
        ): this;
        prependOnceListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    // Http2Server
    export interface SessionOptions {
        maxDeflateDynamicTableSize?: number | undefined;
        maxSessionMemory?: number | undefined;
        maxHeaderListPairs?: number | undefined;
        maxOutstandingPings?: number | undefined;
        maxSendHeaderBlockLength?: number | undefined;
        paddingStrategy?: number | undefined;
        peerMaxConcurrentStreams?: number | undefined;
        settings?: Settings | undefined;
        remoteCustomSettings?: number[] | undefined;
        /**
         * Specifies a timeout in milliseconds that
         * a server should wait when an [`'unknownProtocol'`][] is emitted. If the
         * socket has not been destroyed by that time the server will destroy it.
         * @default 100000
         */
        unknownProtocolTimeout?: number | undefined;
        selectPadding?(frameLen: number, maxFrameLen: number): number;
    }
    export interface ClientSessionOptions extends SessionOptions {
        maxReservedRemoteStreams?: number | undefined;
        createConnection?: ((authority: url.URL, option: SessionOptions) => stream.Duplex) | undefined;
        protocol?: "http:" | "https:" | undefined;
    }
    export interface ServerSessionOptions extends SessionOptions {
        Http1IncomingMessage?: typeof IncomingMessage | undefined;
        Http1ServerResponse?: typeof ServerResponse | undefined;
        Http2ServerRequest?: typeof Http2ServerRequest | undefined;
        Http2ServerResponse?: typeof Http2ServerResponse | undefined;
    }
    export interface SecureClientSessionOptions extends ClientSessionOptions, tls.ConnectionOptions {}
    export interface SecureServerSessionOptions extends ServerSessionOptions, tls.TlsOptions {}
    export interface ServerOptions extends ServerSessionOptions {}
    export interface SecureServerOptions extends SecureServerSessionOptions {
        allowHTTP1?: boolean | undefined;
        origins?: string[] | undefined;
    }
    interface HTTP2ServerCommon {
        setTimeout(msec?: number, callback?: () => void): this;
        /**
         * Throws ERR_HTTP2_INVALID_SETTING_VALUE for invalid settings values.
         * Throws ERR_INVALID_ARG_TYPE for invalid settings argument.
         */
        updateSettings(settings: Settings): void;
    }
    export interface Http2Server extends net.Server, HTTP2ServerCommon {
        addListener(
            event: "checkContinue",
            listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
        ): this;
        addListener(
            event: "request",
            listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
        ): this;
        addListener(event: "session", listener: (session: ServerHttp2Session) => void): this;
        addListener(event: "sessionError", listener: (err: Error) => void): this;
        addListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        addListener(event: "timeout", listener: () => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "checkContinue", request: Http2ServerRequest, response: Http2ServerResponse): boolean;
        emit(event: "request", request: Http2ServerRequest, response: Http2ServerResponse): boolean;
        emit(event: "session", session: ServerHttp2Session): boolean;
        emit(event: "sessionError", err: Error): boolean;
        emit(event: "stream", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: "timeout"): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(
            event: "checkContinue",
            listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
        ): this;
        on(event: "request", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        on(event: "session", listener: (session: ServerHttp2Session) => void): this;
        on(event: "sessionError", listener: (err: Error) => void): this;
        on(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        on(event: "timeout", listener: () => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(
            event: "checkContinue",
            listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
        ): this;
        once(event: "request", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        once(event: "session", listener: (session: ServerHttp2Session) => void): this;
        once(event: "sessionError", listener: (err: Error) => void): this;
        once(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        once(event: "timeout", listener: () => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(
            event: "checkContinue",
            listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
        ): this;
        prependListener(
            event: "request",
            listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
        ): this;
        prependListener(event: "session", listener: (session: ServerHttp2Session) => void): this;
        prependListener(event: "sessionError", listener: (err: Error) => void): this;
        prependListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        prependListener(event: "timeout", listener: () => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(
            event: "checkContinue",
            listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
        ): this;
        prependOnceListener(
            event: "request",
            listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
        ): this;
        prependOnceListener(event: "session", listener: (session: ServerHttp2Session) => void): this;
        prependOnceListener(event: "sessionError", listener: (err: Error) => void): this;
        prependOnceListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        prependOnceListener(event: "timeout", listener: () => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface Http2SecureServer extends tls.Server, HTTP2ServerCommon {
        addListener(
            event: "checkContinue",
            listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
        ): this;
        addListener(
            event: "request",
            listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
        ): this;
        addListener(event: "session", listener: (session: ServerHttp2Session) => void): this;
        addListener(event: "sessionError", listener: (err: Error) => void): this;
        addListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        addListener(event: "timeout", listener: () => void): this;
        addListener(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "checkContinue", request: Http2ServerRequest, response: Http2ServerResponse): boolean;
        emit(event: "request", request: Http2ServerRequest, response: Http2ServerResponse): boolean;
        emit(event: "session", session: ServerHttp2Session): boolean;
        emit(event: "sessionError", err: Error): boolean;
        emit(event: "stream", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: "timeout"): boolean;
        emit(event: "unknownProtocol", socket: tls.TLSSocket): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(
            event: "checkContinue",
            listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
        ): this;
        on(event: "request", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        on(event: "session", listener: (session: ServerHttp2Session) => void): this;
        on(event: "sessionError", listener: (err: Error) => void): this;
        on(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        on(event: "timeout", listener: () => void): this;
        on(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(
            event: "checkContinue",
            listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
        ): this;
        once(event: "request", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        once(event: "session", listener: (session: ServerHttp2Session) => void): this;
        once(event: "sessionError", listener: (err: Error) => void): this;
        once(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        once(event: "timeout", listener: () => void): this;
        once(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(
            event: "checkContinue",
            listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
        ): this;
        prependListener(
            event: "request",
            listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
        ): this;
        prependListener(event: "session", listener: (session: ServerHttp2Session) => void): this;
        prependListener(event: "sessionError", listener: (err: Error) => void): this;
        prependListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        prependListener(event: "timeout", listener: () => void): this;
        prependListener(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(
            event: "checkContinue",
            listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
        ): this;
        prependOnceListener(
            event: "request",
            listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
        ): this;
        prependOnceListener(event: "session", listener: (session: ServerHttp2Session) => void): this;
        prependOnceListener(event: "sessionError", listener: (err: Error) => void): this;
        prependOnceListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        prependOnceListener(event: "timeout", listener: () => void): this;
        prependOnceListener(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    /**
     * A `Http2ServerRequest` object is created by {@link Server} or {@link SecureServer} and passed as the first argument to the `'request'` event. It may be used to access a request status,
     * headers, and
     * data.
     * @since v8.4.0
     */
    export class Http2ServerRequest extends stream.Readable {
        constructor(
            stream: ServerHttp2Stream,
            headers: IncomingHttpHeaders,
            options: stream.ReadableOptions,
            rawHeaders: readonly string[],
        );
        /**
         * The `request.aborted` property will be `true` if the request has
         * been aborted.
         * @since v10.1.0
         */
        readonly aborted: boolean;
        /**
         * The request authority pseudo header field. Because HTTP/2 allows requests
         * to set either `:authority` or `host`, this value is derived from `req.headers[':authority']` if present. Otherwise, it is derived from `req.headers['host']`.
         * @since v8.4.0
         */
        readonly authority: string;
        /**
         * See `request.socket`.
         * @since v8.4.0
         * @deprecated Since v13.0.0 - Use `socket`.
         */
        readonly connection: net.Socket | tls.TLSSocket;
        /**
         * The `request.complete` property will be `true` if the request has
         * been completed, aborted, or destroyed.
         * @since v12.10.0
         */
        readonly complete: boolean;
        /**
         * The request/response headers object.
         *
         * Key-value pairs of header names and values. Header names are lower-cased.
         *
         * ```js
         * // Prints something like:
         * //
         * // { 'user-agent': 'curl/7.22.0',
         * //   host: '127.0.0.1:8000',
         * //   accept: '*' }
         * console.log(request.headers);
         * ```
         *
         * See `HTTP/2 Headers Object`.
         *
         * In HTTP/2, the request path, host name, protocol, and method are represented as
         * special headers prefixed with the `:` character (e.g. `':path'`). These special
         * headers will be included in the `request.headers` object. Care must be taken not
         * to inadvertently modify these special headers or errors may occur. For instance,
         * removing all headers from the request will cause errors to occur:
         *
         * ```js
         * removeAllHeaders(request.headers);
         * assert(request.url);   // Fails because the :path header has been removed
         * ```
         * @since v8.4.0
         */
        readonly headers: IncomingHttpHeaders;
        /**
         * In case of server request, the HTTP version sent by the client. In the case of
         * client response, the HTTP version of the connected-to server. Returns `'2.0'`.
         *
         * Also `message.httpVersionMajor` is the first integer and `message.httpVersionMinor` is the second.
         * @since v8.4.0
         */
        readonly httpVersion: string;
        readonly httpVersionMinor: number;
        readonly httpVersionMajor: number;
        /**
         * The request method as a string. Read-only. Examples: `'GET'`, `'DELETE'`.
         * @since v8.4.0
         */
        readonly method: string;
        /**
         * The raw request/response headers list exactly as they were received.
         *
         * The keys and values are in the same list. It is _not_ a
         * list of tuples. So, the even-numbered offsets are key values, and the
         * odd-numbered offsets are the associated values.
         *
         * Header names are not lowercased, and duplicates are not merged.
         *
         * ```js
         * // Prints something like:
         * //
         * // [ 'user-agent',
         * //   'this is invalid because there can be only one',
         * //   'User-Agent',
         * //   'curl/7.22.0',
         * //   'Host',
         * //   '127.0.0.1:8000',
         * //   'ACCEPT',
         * //   '*' ]
         * console.log(request.rawHeaders);
         * ```
         * @since v8.4.0
         */
        readonly rawHeaders: string[];
        /**
         * The raw request/response trailer keys and values exactly as they were
         * received. Only populated at the `'end'` event.
         * @since v8.4.0
         */
        readonly rawTrailers: string[];
        /**
         * The request scheme pseudo header field indicating the scheme
         * portion of the target URL.
         * @since v8.4.0
         */
        readonly scheme: string;
        /**
         * Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but
         * applies getters, setters, and methods based on HTTP/2 logic.
         *
         * `destroyed`, `readable`, and `writable` properties will be retrieved from and
         * set on `request.stream`.
         *
         * `destroy`, `emit`, `end`, `on` and `once` methods will be called on `request.stream`.
         *
         * `setTimeout` method will be called on `request.stream.session`.
         *
         * `pause`, `read`, `resume`, and `write` will throw an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for
         * more information.
         *
         * All other interactions will be routed directly to the socket. With TLS support,
         * use `request.socket.getPeerCertificate()` to obtain the client's
         * authentication details.
         * @since v8.4.0
         */
        readonly socket: net.Socket | tls.TLSSocket;
        /**
         * The `Http2Stream` object backing the request.
         * @since v8.4.0
         */
        readonly stream: ServerHttp2Stream;
        /**
         * The request/response trailers object. Only populated at the `'end'` event.
         * @since v8.4.0
         */
        readonly trailers: IncomingHttpHeaders;
        /**
         * Request URL string. This contains only the URL that is present in the actual
         * HTTP request. If the request is:
         *
         * ```http
         * GET /status?name=ryan HTTP/1.1
         * Accept: text/plain
         * ```
         *
         * Then `request.url` will be:
         *
         * ```js
         * '/status?name=ryan'
         * ```
         *
         * To parse the url into its parts, `new URL()` can be used:
         *
         * ```console
         * $ node
         * > new URL('/status?name=ryan', 'http://example.com')
         * URL {
         *   href: 'http://example.com/status?name=ryan',
         *   origin: 'http://example.com',
         *   protocol: 'http:',
         *   username: '',
         *   password: '',
         *   host: 'example.com',
         *   hostname: 'example.com',
         *   port: '',
         *   pathname: '/status',
         *   search: '?name=ryan',
         *   searchParams: URLSearchParams { 'name' => 'ryan' },
         *   hash: ''
         * }
         * ```
         * @since v8.4.0
         */
        url: string;
        /**
         * Sets the `Http2Stream`'s timeout value to `msecs`. If a callback is
         * provided, then it is added as a listener on the `'timeout'` event on
         * the response object.
         *
         * If no `'timeout'` listener is added to the request, the response, or
         * the server, then `Http2Stream`s are destroyed when they time out. If a
         * handler is assigned to the request, the response, or the server's `'timeout'`events, timed out sockets must be handled explicitly.
         * @since v8.4.0
         */
        setTimeout(msecs: number, callback?: () => void): void;
        read(size?: number): Buffer | string | null;
        addListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        addListener(event: "end", listener: () => void): this;
        addListener(event: "readable", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "aborted", hadError: boolean, code: number): boolean;
        emit(event: "close"): boolean;
        emit(event: "data", chunk: Buffer | string): boolean;
        emit(event: "end"): boolean;
        emit(event: "readable"): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "data", listener: (chunk: Buffer | string) => void): this;
        on(event: "end", listener: () => void): this;
        on(event: "readable", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "data", listener: (chunk: Buffer | string) => void): this;
        once(event: "end", listener: () => void): this;
        once(event: "readable", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        prependListener(event: "end", listener: () => void): this;
        prependListener(event: "readable", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        prependOnceListener(event: "end", listener: () => void): this;
        prependOnceListener(event: "readable", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    /**
     * This object is created internally by an HTTP server, not by the user. It is
     * passed as the second parameter to the `'request'` event.
     * @since v8.4.0
     */
    export class Http2ServerResponse extends stream.Writable {
        constructor(stream: ServerHttp2Stream);
        /**
         * See `response.socket`.
         * @since v8.4.0
         * @deprecated Since v13.0.0 - Use `socket`.
         */
        readonly connection: net.Socket | tls.TLSSocket;
        /**
         * Append a single header value to the header object.
         *
         * If the value is an array, this is equivalent to calling this method multiple times.
         *
         * If there were no previous values for the header, this is equivalent to calling {@link setHeader}.
         *
         * Attempting to set a header field name or value that contains invalid characters will result in a
         * [TypeError](https://nodejs.org/docs/latest-v22.x/api/errors.html#class-typeerror) being thrown.
         *
         * ```js
         * // Returns headers including "set-cookie: a" and "set-cookie: b"
         * const server = http2.createServer((req, res) => {
         *   res.setHeader('set-cookie', 'a');
         *   res.appendHeader('set-cookie', 'b');
         *   res.writeHead(200);
         *   res.end('ok');
         * });
         * ```
         * @since v20.12.0
         */
        appendHeader(name: string, value: string | string[]): void;
        /**
         * Boolean value that indicates whether the response has completed. Starts
         * as `false`. After `response.end()` executes, the value will be `true`.
         * @since v8.4.0
         * @deprecated Since v13.4.0,v12.16.0 - Use `writableEnded`.
         */
        readonly finished: boolean;
        /**
         * True if headers were sent, false otherwise (read-only).
         * @since v8.4.0
         */
        readonly headersSent: boolean;
        /**
         * A reference to the original HTTP2 `request` object.
         * @since v15.7.0
         */
        readonly req: Http2ServerRequest;
        /**
         * Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but
         * applies getters, setters, and methods based on HTTP/2 logic.
         *
         * `destroyed`, `readable`, and `writable` properties will be retrieved from and
         * set on `response.stream`.
         *
         * `destroy`, `emit`, `end`, `on` and `once` methods will be called on `response.stream`.
         *
         * `setTimeout` method will be called on `response.stream.session`.
         *
         * `pause`, `read`, `resume`, and `write` will throw an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for
         * more information.
         *
         * All other interactions will be routed directly to the socket.
         *
         * ```js
         * const http2 = require('node:http2');
         * const server = http2.createServer((req, res) => {
         *   const ip = req.socket.remoteAddress;
         *   const port = req.socket.remotePort;
         *   res.end(`Your IP address is ${ip} and your source port is ${port}.`);
         * }).listen(3000);
         * ```
         * @since v8.4.0
         */
        readonly socket: net.Socket | tls.TLSSocket;
        /**
         * The `Http2Stream` object backing the response.
         * @since v8.4.0
         */
        readonly stream: ServerHttp2Stream;
        /**
         * When true, the Date header will be automatically generated and sent in
         * the response if it is not already present in the headers. Defaults to true.
         *
         * This should only be disabled for testing; HTTP requires the Date header
         * in responses.
         * @since v8.4.0
         */
        sendDate: boolean;
        /**
         * When using implicit headers (not calling `response.writeHead()` explicitly),
         * this property controls the status code that will be sent to the client when
         * the headers get flushed.
         *
         * ```js
         * response.statusCode = 404;
         * ```
         *
         * After response header was sent to the client, this property indicates the
         * status code which was sent out.
         * @since v8.4.0
         */
        statusCode: number;
        /**
         * Status message is not supported by HTTP/2 (RFC 7540 8.1.2.4). It returns
         * an empty string.
         * @since v8.4.0
         */
        statusMessage: "";
        /**
         * This method adds HTTP trailing headers (a header but at the end of the
         * message) to the response.
         *
         * Attempting to set a header field name or value that contains invalid characters
         * will result in a `TypeError` being thrown.
         * @since v8.4.0
         */
        addTrailers(trailers: OutgoingHttpHeaders): void;
        /**
         * This method signals to the server that all of the response headers and body
         * have been sent; that server should consider this message complete.
         * The method, `response.end()`, MUST be called on each response.
         *
         * If `data` is specified, it is equivalent to calling `response.write(data, encoding)` followed by `response.end(callback)`.
         *
         * If `callback` is specified, it will be called when the response stream
         * is finished.
         * @since v8.4.0
         */
        end(callback?: () => void): this;
        end(data: string | Uint8Array, callback?: () => void): this;
        end(data: string | Uint8Array, encoding: BufferEncoding, callback?: () => void): this;
        /**
         * Reads out a header that has already been queued but not sent to the client.
         * The name is case-insensitive.
         *
         * ```js
         * const contentType = response.getHeader('content-type');
         * ```
         * @since v8.4.0
         */
        getHeader(name: string): string;
        /**
         * Returns an array containing the unique names of the current outgoing headers.
         * All header names are lowercase.
         *
         * ```js
         * response.setHeader('Foo', 'bar');
         * response.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);
         *
         * const headerNames = response.getHeaderNames();
         * // headerNames === ['foo', 'set-cookie']
         * ```
         * @since v8.4.0
         */
        getHeaderNames(): string[];
        /**
         * Returns a shallow copy of the current outgoing headers. Since a shallow copy
         * is used, array values may be mutated without additional calls to various
         * header-related http module methods. The keys of the returned object are the
         * header names and the values are the respective header values. All header names
         * are lowercase.
         *
         * The object returned by the `response.getHeaders()` method _does not_ prototypically inherit from the JavaScript `Object`. This means that typical `Object` methods such as `obj.toString()`,
         * `obj.hasOwnProperty()`, and others
         * are not defined and _will not work_.
         *
         * ```js
         * response.setHeader('Foo', 'bar');
         * response.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);
         *
         * const headers = response.getHeaders();
         * // headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }
         * ```
         * @since v8.4.0
         */
        getHeaders(): OutgoingHttpHeaders;
        /**
         * Returns `true` if the header identified by `name` is currently set in the
         * outgoing headers. The header name matching is case-insensitive.
         *
         * ```js
         * const hasContentType = response.hasHeader('content-type');
         * ```
         * @since v8.4.0
         */
        hasHeader(name: string): boolean;
        /**
         * Removes a header that has been queued for implicit sending.
         *
         * ```js
         * response.removeHeader('Content-Encoding');
         * ```
         * @since v8.4.0
         */
        removeHeader(name: string): void;
        /**
         * Sets a single header value for implicit headers. If this header already exists
         * in the to-be-sent headers, its value will be replaced. Use an array of strings
         * here to send multiple headers with the same name.
         *
         * ```js
         * response.setHeader('Content-Type', 'text/html; charset=utf-8');
         * ```
         *
         * or
         *
         * ```js
         * response.setHeader('Set-Cookie', ['type=ninja', 'language=javascript']);
         * ```
         *
         * Attempting to set a header field name or value that contains invalid characters
         * will result in a `TypeError` being thrown.
         *
         * When headers have been set with `response.setHeader()`, they will be merged
         * with any headers passed to `response.writeHead()`, with the headers passed
         * to `response.writeHead()` given precedence.
         *
         * ```js
         * // Returns content-type = text/plain
         * const server = http2.createServer((req, res) => {
         *   res.setHeader('Content-Type', 'text/html; charset=utf-8');
         *   res.setHeader('X-Foo', 'bar');
         *   res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
         *   res.end('ok');
         * });
         * ```
         * @since v8.4.0
         */
        setHeader(name: string, value: number | string | readonly string[]): void;
        /**
         * Sets the `Http2Stream`'s timeout value to `msecs`. If a callback is
         * provided, then it is added as a listener on the `'timeout'` event on
         * the response object.
         *
         * If no `'timeout'` listener is added to the request, the response, or
         * the server, then `Http2Stream` s are destroyed when they time out. If a
         * handler is assigned to the request, the response, or the server's `'timeout'` events, timed out sockets must be handled explicitly.
         * @since v8.4.0
         */
        setTimeout(msecs: number, callback?: () => void): void;
        /**
         * If this method is called and `response.writeHead()` has not been called,
         * it will switch to implicit header mode and flush the implicit headers.
         *
         * This sends a chunk of the response body. This method may
         * be called multiple times to provide successive parts of the body.
         *
         * In the `node:http` module, the response body is omitted when the
         * request is a HEAD request. Similarly, the `204` and `304` responses _must not_ include a message body.
         *
         * `chunk` can be a string or a buffer. If `chunk` is a string,
         * the second parameter specifies how to encode it into a byte stream.
         * By default the `encoding` is `'utf8'`. `callback` will be called when this chunk
         * of data is flushed.
         *
         * This is the raw HTTP body and has nothing to do with higher-level multi-part
         * body encodings that may be used.
         *
         * The first time `response.write()` is called, it will send the buffered
         * header information and the first chunk of the body to the client. The second
         * time `response.write()` is called, Node.js assumes data will be streamed,
         * and sends the new data separately. That is, the response is buffered up to the
         * first chunk of the body.
         *
         * Returns `true` if the entire data was flushed successfully to the kernel
         * buffer. Returns `false` if all or part of the data was queued in user memory.`'drain'` will be emitted when the buffer is free again.
         * @since v8.4.0
         */
        write(chunk: string | Uint8Array, callback?: (err: Error) => void): boolean;
        write(chunk: string | Uint8Array, encoding: BufferEncoding, callback?: (err: Error) => void): boolean;
        /**
         * Sends a status `100 Continue` to the client, indicating that the request body
         * should be sent. See the `'checkContinue'` event on `Http2Server` and `Http2SecureServer`.
         * @since v8.4.0
         */
        writeContinue(): void;
        /**
         * Sends a status `103 Early Hints` to the client with a Link header,
         * indicating that the user agent can preload/preconnect the linked resources.
         * The `hints` is an object containing the values of headers to be sent with
         * early hints message.
         *
         * **Example**
         *
         * ```js
         * const earlyHintsLink = '</styles.css>; rel=preload; as=style';
         * response.writeEarlyHints({
         *   'link': earlyHintsLink,
         * });
         *
         * const earlyHintsLinks = [
         *   '</styles.css>; rel=preload; as=style',
         *   '</scripts.js>; rel=preload; as=script',
         * ];
         * response.writeEarlyHints({
         *   'link': earlyHintsLinks,
         * });
         * ```
         * @since v18.11.0
         */
        writeEarlyHints(hints: Record<string, string | string[]>): void;
        /**
         * Sends a response header to the request. The status code is a 3-digit HTTP
         * status code, like `404`. The last argument, `headers`, are the response headers.
         *
         * Returns a reference to the `Http2ServerResponse`, so that calls can be chained.
         *
         * For compatibility with `HTTP/1`, a human-readable `statusMessage` may be
         * passed as the second argument. However, because the `statusMessage` has no
         * meaning within HTTP/2, the argument will have no effect and a process warning
         * will be emitted.
         *
         * ```js
         * const body = 'hello world';
         * response.writeHead(200, {
         *   'Content-Length': Buffer.byteLength(body),
         *   'Content-Type': 'text/plain; charset=utf-8',
         * });
         * ```
         *
         * `Content-Length` is given in bytes not characters. The`Buffer.byteLength()` API may be used to determine the number of bytes in a
         * given encoding. On outbound messages, Node.js does not check if Content-Length
         * and the length of the body being transmitted are equal or not. However, when
         * receiving messages, Node.js will automatically reject messages when the `Content-Length` does not match the actual payload size.
         *
         * This method may be called at most one time on a message before `response.end()` is called.
         *
         * If `response.write()` or `response.end()` are called before calling
         * this, the implicit/mutable headers will be calculated and call this function.
         *
         * When headers have been set with `response.setHeader()`, they will be merged
         * with any headers passed to `response.writeHead()`, with the headers passed
         * to `response.writeHead()` given precedence.
         *
         * ```js
         * // Returns content-type = text/plain
         * const server = http2.createServer((req, res) => {
         *   res.setHeader('Content-Type', 'text/html; charset=utf-8');
         *   res.setHeader('X-Foo', 'bar');
         *   res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
         *   res.end('ok');
         * });
         * ```
         *
         * Attempting to set a header field name or value that contains invalid characters
         * will result in a `TypeError` being thrown.
         * @since v8.4.0
         */
        writeHead(statusCode: number, headers?: OutgoingHttpHeaders): this;
        writeHead(statusCode: number, statusMessage: string, headers?: OutgoingHttpHeaders): this;
        /**
         * Call `http2stream.pushStream()` with the given headers, and wrap the
         * given `Http2Stream` on a newly created `Http2ServerResponse` as the callback
         * parameter if successful. When `Http2ServerRequest` is closed, the callback is
         * called with an error `ERR_HTTP2_INVALID_STREAM`.
         * @since v8.4.0
         * @param headers An object describing the headers
         * @param callback Called once `http2stream.pushStream()` is finished, or either when the attempt to create the pushed `Http2Stream` has failed or has been rejected, or the state of
         * `Http2ServerRequest` is closed prior to calling the `http2stream.pushStream()` method
         */
        createPushResponse(
            headers: OutgoingHttpHeaders,
            callback: (err: Error | null, res: Http2ServerResponse) => void,
        ): void;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "drain", listener: () => void): this;
        addListener(event: "error", listener: (error: Error) => void): this;
        addListener(event: "finish", listener: () => void): this;
        addListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        addListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "close"): boolean;
        emit(event: "drain"): boolean;
        emit(event: "error", error: Error): boolean;
        emit(event: "finish"): boolean;
        emit(event: "pipe", src: stream.Readable): boolean;
        emit(event: "unpipe", src: stream.Readable): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "close", listener: () => void): this;
        on(event: "drain", listener: () => void): this;
        on(event: "error", listener: (error: Error) => void): this;
        on(event: "finish", listener: () => void): this;
        on(event: "pipe", listener: (src: stream.Readable) => void): this;
        on(event: "unpipe", listener: (src: stream.Readable) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "drain", listener: () => void): this;
        once(event: "error", listener: (error: Error) => void): this;
        once(event: "finish", listener: () => void): this;
        once(event: "pipe", listener: (src: stream.Readable) => void): this;
        once(event: "unpipe", listener: (src: stream.Readable) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "drain", listener: () => void): this;
        prependListener(event: "error", listener: (error: Error) => void): this;
        prependListener(event: "finish", listener: () => void): this;
        prependListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        prependListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "drain", listener: () => void): this;
        prependOnceListener(event: "error", listener: (error: Error) => void): this;
        prependOnceListener(event: "finish", listener: () => void): this;
        prependOnceListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export namespace constants {
        const NGHTTP2_SESSION_SERVER: number;
        const NGHTTP2_SESSION_CLIENT: number;
        const NGHTTP2_STREAM_STATE_IDLE: number;
        const NGHTTP2_STREAM_STATE_OPEN: number;
        const NGHTTP2_STREAM_STATE_RESERVED_LOCAL: number;
        const NGHTTP2_STREAM_STATE_RESERVED_REMOTE: number;
        const NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL: number;
        const NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE: number;
        const NGHTTP2_STREAM_STATE_CLOSED: number;
        const NGHTTP2_NO_ERROR: number;
        const NGHTTP2_PROTOCOL_ERROR: number;
        const NGHTTP2_INTERNAL_ERROR: number;
        const NGHTTP2_FLOW_CONTROL_ERROR: number;
        const NGHTTP2_SETTINGS_TIMEOUT: number;
        const NGHTTP2_STREAM_CLOSED: number;
        const NGHTTP2_FRAME_SIZE_ERROR: number;
        const NGHTTP2_REFUSED_STREAM: number;
        const NGHTTP2_CANCEL: number;
        const NGHTTP2_COMPRESSION_ERROR: number;
        const NGHTTP2_CONNECT_ERROR: number;
        const NGHTTP2_ENHANCE_YOUR_CALM: number;
        const NGHTTP2_INADEQUATE_SECURITY: number;
        const NGHTTP2_HTTP_1_1_REQUIRED: number;
        const NGHTTP2_ERR_FRAME_SIZE_ERROR: number;
        const NGHTTP2_FLAG_NONE: number;
        const NGHTTP2_FLAG_END_STREAM: number;
        const NGHTTP2_FLAG_END_HEADERS: number;
        const NGHTTP2_FLAG_ACK: number;
        const NGHTTP2_FLAG_PADDED: number;
        const NGHTTP2_FLAG_PRIORITY: number;
        const DEFAULT_SETTINGS_HEADER_TABLE_SIZE: number;
        const DEFAULT_SETTINGS_ENABLE_PUSH: number;
        const DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE: number;
        const DEFAULT_SETTINGS_MAX_FRAME_SIZE: number;
        const MAX_MAX_FRAME_SIZE: number;
        const MIN_MAX_FRAME_SIZE: number;
        const MAX_INITIAL_WINDOW_SIZE: number;
        const NGHTTP2_DEFAULT_WEIGHT: number;
        const NGHTTP2_SETTINGS_HEADER_TABLE_SIZE: number;
        const NGHTTP2_SETTINGS_ENABLE_PUSH: number;
        const NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS: number;
        const NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE: number;
        const NGHTTP2_SETTINGS_MAX_FRAME_SIZE: number;
        const NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE: number;
        const PADDING_STRATEGY_NONE: number;
        const PADDING_STRATEGY_MAX: number;
        const PADDING_STRATEGY_CALLBACK: number;
        const HTTP2_HEADER_STATUS: string;
        const HTTP2_HEADER_METHOD: string;
        const HTTP2_HEADER_AUTHORITY: string;
        const HTTP2_HEADER_SCHEME: string;
        const HTTP2_HEADER_PATH: string;
        const HTTP2_HEADER_ACCEPT_CHARSET: string;
        const HTTP2_HEADER_ACCEPT_ENCODING: string;
        const HTTP2_HEADER_ACCEPT_LANGUAGE: string;
        const HTTP2_HEADER_ACCEPT_RANGES: string;
        const HTTP2_HEADER_ACCEPT: string;
        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS: string;
        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_HEADERS: string;
        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_METHODS: string;
        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN: string;
        const HTTP2_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS: string;
        const HTTP2_HEADER_ACCESS_CONTROL_REQUEST_HEADERS: string;
        const HTTP2_HEADER_ACCESS_CONTROL_REQUEST_METHOD: string;
        const HTTP2_HEADER_AGE: string;
        const HTTP2_HEADER_ALLOW: string;
        const HTTP2_HEADER_AUTHORIZATION: string;
        const HTTP2_HEADER_CACHE_CONTROL: string;
        const HTTP2_HEADER_CONNECTION: string;
        const HTTP2_HEADER_CONTENT_DISPOSITION: string;
        const HTTP2_HEADER_CONTENT_ENCODING: string;
        const HTTP2_HEADER_CONTENT_LANGUAGE: string;
        const HTTP2_HEADER_CONTENT_LENGTH: string;
        const HTTP2_HEADER_CONTENT_LOCATION: string;
        const HTTP2_HEADER_CONTENT_MD5: string;
        const HTTP2_HEADER_CONTENT_RANGE: string;
        const HTTP2_HEADER_CONTENT_TYPE: string;
        const HTTP2_HEADER_COOKIE: string;
        const HTTP2_HEADER_DATE: string;
        const HTTP2_HEADER_ETAG: string;
        const HTTP2_HEADER_EXPECT: string;
        const HTTP2_HEADER_EXPIRES: string;
        const HTTP2_HEADER_FROM: string;
        const HTTP2_HEADER_HOST: string;
        const HTTP2_HEADER_IF_MATCH: string;
        const HTTP2_HEADER_IF_MODIFIED_SINCE: string;
        const HTTP2_HEADER_IF_NONE_MATCH: string;
        const HTTP2_HEADER_IF_RANGE: string;
        const HTTP2_HEADER_IF_UNMODIFIED_SINCE: string;
        const HTTP2_HEADER_LAST_MODIFIED: string;
        const HTTP2_HEADER_LINK: string;
        const HTTP2_HEADER_LOCATION: string;
        const HTTP2_HEADER_MAX_FORWARDS: string;
        const HTTP2_HEADER_PREFER: string;
        const HTTP2_HEADER_PROXY_AUTHENTICATE: string;
        const HTTP2_HEADER_PROXY_AUTHORIZATION: string;
        const HTTP2_HEADER_RANGE: string;
        const HTTP2_HEADER_REFERER: string;
        const HTTP2_HEADER_REFRESH: string;
        const HTTP2_HEADER_RETRY_AFTER: string;
        const HTTP2_HEADER_SERVER: string;
        const HTTP2_HEADER_SET_COOKIE: string;
        const HTTP2_HEADER_STRICT_TRANSPORT_SECURITY: string;
        const HTTP2_HEADER_TRANSFER_ENCODING: string;
        const HTTP2_HEADER_TE: string;
        const HTTP2_HEADER_UPGRADE: string;
        const HTTP2_HEADER_USER_AGENT: string;
        const HTTP2_HEADER_VARY: string;
        const HTTP2_HEADER_VIA: string;
        const HTTP2_HEADER_WWW_AUTHENTICATE: string;
        const HTTP2_HEADER_HTTP2_SETTINGS: string;
        const HTTP2_HEADER_KEEP_ALIVE: string;
        const HTTP2_HEADER_PROXY_CONNECTION: string;
        const HTTP2_METHOD_ACL: string;
        const HTTP2_METHOD_BASELINE_CONTROL: string;
        const HTTP2_METHOD_BIND: string;
        const HTTP2_METHOD_CHECKIN: string;
        const HTTP2_METHOD_CHECKOUT: string;
        const HTTP2_METHOD_CONNECT: string;
        const HTTP2_METHOD_COPY: string;
        const HTTP2_METHOD_DELETE: string;
        const HTTP2_METHOD_GET: string;
        const HTTP2_METHOD_HEAD: string;
        const HTTP2_METHOD_LABEL: string;
        const HTTP2_METHOD_LINK: string;
        const HTTP2_METHOD_LOCK: string;
        const HTTP2_METHOD_MERGE: string;
        const HTTP2_METHOD_MKACTIVITY: string;
        const HTTP2_METHOD_MKCALENDAR: string;
        const HTTP2_METHOD_MKCOL: string;
        const HTTP2_METHOD_MKREDIRECTREF: string;
        const HTTP2_METHOD_MKWORKSPACE: string;
        const HTTP2_METHOD_MOVE: string;
        const HTTP2_METHOD_OPTIONS: string;
        const HTTP2_METHOD_ORDERPATCH: string;
        const HTTP2_METHOD_PATCH: string;
        const HTTP2_METHOD_POST: string;
        const HTTP2_METHOD_PRI: string;
        const HTTP2_METHOD_PROPFIND: string;
        const HTTP2_METHOD_PROPPATCH: string;
        const HTTP2_METHOD_PUT: string;
        const HTTP2_METHOD_REBIND: string;
        const HTTP2_METHOD_REPORT: string;
        const HTTP2_METHOD_SEARCH: string;
        const HTTP2_METHOD_TRACE: string;
        const HTTP2_METHOD_UNBIND: string;
        const HTTP2_METHOD_UNCHECKOUT: string;
        const HTTP2_METHOD_UNLINK: string;
        const HTTP2_METHOD_UNLOCK: string;
        const HTTP2_METHOD_UPDATE: string;
        const HTTP2_METHOD_UPDATEREDIRECTREF: string;
        const HTTP2_METHOD_VERSION_CONTROL: string;
        const HTTP_STATUS_CONTINUE: number;
        const HTTP_STATUS_SWITCHING_PROTOCOLS: number;
        const HTTP_STATUS_PROCESSING: number;
        const HTTP_STATUS_OK: number;
        const HTTP_STATUS_CREATED: number;
        const HTTP_STATUS_ACCEPTED: number;
        const HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION: number;
        const HTTP_STATUS_NO_CONTENT: number;
        const HTTP_STATUS_RESET_CONTENT: number;
        const HTTP_STATUS_PARTIAL_CONTENT: number;
        const HTTP_STATUS_MULTI_STATUS: number;
        const HTTP_STATUS_ALREADY_REPORTED: number;
        const HTTP_STATUS_IM_USED: number;
        const HTTP_STATUS_MULTIPLE_CHOICES: number;
        const HTTP_STATUS_MOVED_PERMANENTLY: number;
        const HTTP_STATUS_FOUND: number;
        const HTTP_STATUS_SEE_OTHER: number;
        const HTTP_STATUS_NOT_MODIFIED: number;
        const HTTP_STATUS_USE_PROXY: number;
        const HTTP_STATUS_TEMPORARY_REDIRECT: number;
        const HTTP_STATUS_PERMANENT_REDIRECT: number;
        const HTTP_STATUS_BAD_REQUEST: number;
        const HTTP_STATUS_UNAUTHORIZED: number;
        const HTTP_STATUS_PAYMENT_REQUIRED: number;
        const HTTP_STATUS_FORBIDDEN: number;
        const HTTP_STATUS_NOT_FOUND: number;
        const HTTP_STATUS_METHOD_NOT_ALLOWED: number;
        const HTTP_STATUS_NOT_ACCEPTABLE: number;
        const HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED: number;
        const HTTP_STATUS_REQUEST_TIMEOUT: number;
        const HTTP_STATUS_CONFLICT: number;
        const HTTP_STATUS_GONE: number;
        const HTTP_STATUS_LENGTH_REQUIRED: number;
        const HTTP_STATUS_PRECONDITION_FAILED: number;
        const HTTP_STATUS_PAYLOAD_TOO_LARGE: number;
        const HTTP_STATUS_URI_TOO_LONG: number;
        const HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE: number;
        const HTTP_STATUS_RANGE_NOT_SATISFIABLE: number;
        const HTTP_STATUS_EXPECTATION_FAILED: number;
        const HTTP_STATUS_TEAPOT: number;
        const HTTP_STATUS_MISDIRECTED_REQUEST: number;
        const HTTP_STATUS_UNPROCESSABLE_ENTITY: number;
        const HTTP_STATUS_LOCKED: number;
        const HTTP_STATUS_FAILED_DEPENDENCY: number;
        const HTTP_STATUS_UNORDERED_COLLECTION: number;
        const HTTP_STATUS_UPGRADE_REQUIRED: number;
        const HTTP_STATUS_PRECONDITION_REQUIRED: number;
        const HTTP_STATUS_TOO_MANY_REQUESTS: number;
        const HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE: number;
        const HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS: number;
        const HTTP_STATUS_INTERNAL_SERVER_ERROR: number;
        const HTTP_STATUS_NOT_IMPLEMENTED: number;
        const HTTP_STATUS_BAD_GATEWAY: number;
        const HTTP_STATUS_SERVICE_UNAVAILABLE: number;
        const HTTP_STATUS_GATEWAY_TIMEOUT: number;
        const HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED: number;
        const HTTP_STATUS_VARIANT_ALSO_NEGOTIATES: number;
        const HTTP_STATUS_INSUFFICIENT_STORAGE: number;
        const HTTP_STATUS_LOOP_DETECTED: number;
        const HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED: number;
        const HTTP_STATUS_NOT_EXTENDED: number;
        const HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED: number;
    }
    /**
     * This symbol can be set as a property on the HTTP/2 headers object with
     * an array value in order to provide a list of headers considered sensitive.
     */
    export const sensitiveHeaders: symbol;
    /**
     * Returns an object containing the default settings for an `Http2Session` instance. This method returns a new object instance every time it is called
     * so instances returned may be safely modified for use.
     * @since v8.4.0
     */
    export function getDefaultSettings(): Settings;
    /**
     * Returns a `Buffer` instance containing serialized representation of the given
     * HTTP/2 settings as specified in the [HTTP/2](https://tools.ietf.org/html/rfc7540) specification. This is intended
     * for use with the `HTTP2-Settings` header field.
     *
     * ```js
     * const http2 = require('node:http2');
     *
     * const packed = http2.getPackedSettings({ enablePush: false });
     *
     * console.log(packed.toString('base64'));
     * // Prints: AAIAAAAA
     * ```
     * @since v8.4.0
     */
    export function getPackedSettings(settings: Settings): Buffer;
    /**
     * Returns a `HTTP/2 Settings Object` containing the deserialized settings from
     * the given `Buffer` as generated by `http2.getPackedSettings()`.
     * @since v8.4.0
     * @param buf The packed settings.
     */
    export function getUnpackedSettings(buf: Uint8Array): Settings;
    /**
     * Returns a `net.Server` instance that creates and manages `Http2Session` instances.
     *
     * Since there are no browsers known that support [unencrypted HTTP/2](https://http2.github.io/faq/#does-http2-require-encryption), the use of {@link createSecureServer} is necessary when
     * communicating
     * with browser clients.
     *
     * ```js
     * const http2 = require('node:http2');
     *
     * // Create an unencrypted HTTP/2 server.
     * // Since there are no browsers known that support
     * // unencrypted HTTP/2, the use of `http2.createSecureServer()`
     * // is necessary when communicating with browser clients.
     * const server = http2.createServer();
     *
     * server.on('stream', (stream, headers) => {
     *   stream.respond({
     *     'content-type': 'text/html; charset=utf-8',
     *     ':status': 200,
     *   });
     *   stream.end('<h1>Hello World</h1>');
     * });
     *
     * server.listen(8000);
     * ```
     * @since v8.4.0
     * @param onRequestHandler See `Compatibility API`
     */
    export function createServer(
        onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
    ): Http2Server;
    export function createServer(
        options: ServerOptions,
        onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
    ): Http2Server;
    /**
     * Returns a `tls.Server` instance that creates and manages `Http2Session` instances.
     *
     * ```js
     * const http2 = require('node:http2');
     * const fs = require('node:fs');
     *
     * const options = {
     *   key: fs.readFileSync('server-key.pem'),
     *   cert: fs.readFileSync('server-cert.pem'),
     * };
     *
     * // Create a secure HTTP/2 server
     * const server = http2.createSecureServer(options);
     *
     * server.on('stream', (stream, headers) => {
     *   stream.respond({
     *     'content-type': 'text/html; charset=utf-8',
     *     ':status': 200,
     *   });
     *   stream.end('<h1>Hello World</h1>');
     * });
     *
     * server.listen(8443);
     * ```
     * @since v8.4.0
     * @param onRequestHandler See `Compatibility API`
     */
    export function createSecureServer(
        onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
    ): Http2SecureServer;
    export function createSecureServer(
        options: SecureServerOptions,
        onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
    ): Http2SecureServer;
    /**
     * Returns a `ClientHttp2Session` instance.
     *
     * ```js
     * const http2 = require('node:http2');
     * const client = http2.connect('https://localhost:1234');
     *
     * // Use the client
     *
     * client.close();
     * ```
     * @since v8.4.0
     * @param authority The remote HTTP/2 server to connect to. This must be in the form of a minimal, valid URL with the `http://` or `https://` prefix, host name, and IP port (if a non-default port
     * is used). Userinfo (user ID and password), path, querystring, and fragment details in the URL will be ignored.
     * @param listener Will be registered as a one-time listener of the {@link 'connect'} event.
     */
    export function connect(
        authority: string | url.URL,
        listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
    ): ClientHttp2Session;
    export function connect(
        authority: string | url.URL,
        options?: ClientSessionOptions | SecureClientSessionOptions,
        listener?: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
    ): ClientHttp2Session;
    /**
     * Create an HTTP/2 server session from an existing socket.
     * @param socket A Duplex Stream
     * @param options Any `{@link createServer}` options can be provided.
     * @since v20.12.0
     */
    export function performServerHandshake(socket: stream.Duplex, options?: ServerOptions): ServerHttp2Session;
}
declare module "node:http2" {
    export * from "http2";
}
/**
 * HTTPS is the HTTP protocol over TLS/SSL. In Node.js this is implemented as a
 * separate module.
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/https.js)
 */
declare module "https" {
    import { Duplex } from "node:stream";
    import * as tls from "node:tls";
    import * as http from "node:http";
    import { URL } from "node:url";
    type ServerOptions<
        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,
        Response extends typeof http.ServerResponse = typeof http.ServerResponse,
    > = tls.SecureContextOptions & tls.TlsOptions & http.ServerOptions<Request, Response>;
    type RequestOptions =
        & http.RequestOptions
        & tls.SecureContextOptions
        & {
            checkServerIdentity?: typeof tls.checkServerIdentity | undefined;
            rejectUnauthorized?: boolean | undefined; // Defaults to true
            servername?: string | undefined; // SNI TLS Extension
        };
    interface AgentOptions extends http.AgentOptions, tls.ConnectionOptions {
        rejectUnauthorized?: boolean | undefined;
        maxCachedSessions?: number | undefined;
    }
    /**
     * An `Agent` object for HTTPS similar to `http.Agent`. See {@link request} for more information.
     * @since v0.4.5
     */
    class Agent extends http.Agent {
        constructor(options?: AgentOptions);
        options: AgentOptions;
    }
    interface Server<
        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,
        Response extends typeof http.ServerResponse = typeof http.ServerResponse,
    > extends http.Server<Request, Response> {}
    /**
     * See `http.Server` for more information.
     * @since v0.3.4
     */
    class Server<
        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,
        Response extends typeof http.ServerResponse = typeof http.ServerResponse,
    > extends tls.Server {
        constructor(requestListener?: http.RequestListener<Request, Response>);
        constructor(
            options: ServerOptions<Request, Response>,
            requestListener?: http.RequestListener<Request, Response>,
        );
        /**
         * Closes all connections connected to this server.
         * @since v18.2.0
         */
        closeAllConnections(): void;
        /**
         * Closes all connections connected to this server which are not sending a request or waiting for a response.
         * @since v18.2.0
         */
        closeIdleConnections(): void;
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "keylog", listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;
        addListener(
            event: "newSession",
            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,
        ): this;
        addListener(
            event: "OCSPRequest",
            listener: (
                certificate: Buffer,
                issuer: Buffer,
                callback: (err: Error | null, resp: Buffer) => void,
            ) => void,
        ): this;
        addListener(
            event: "resumeSession",
            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,
        ): this;
        addListener(event: "secureConnection", listener: (tlsSocket: tls.TLSSocket) => void): this;
        addListener(event: "tlsClientError", listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "connection", listener: (socket: Duplex) => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "listening", listener: () => void): this;
        addListener(event: "checkContinue", listener: http.RequestListener<Request, Response>): this;
        addListener(event: "checkExpectation", listener: http.RequestListener<Request, Response>): this;
        addListener(event: "clientError", listener: (err: Error, socket: Duplex) => void): this;
        addListener(
            event: "connect",
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
        addListener(event: "request", listener: http.RequestListener<Request, Response>): this;
        addListener(
            event: "upgrade",
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
        emit(event: string, ...args: any[]): boolean;
        emit(event: "keylog", line: Buffer, tlsSocket: tls.TLSSocket): boolean;
        emit(
            event: "newSession",
            sessionId: Buffer,
            sessionData: Buffer,
            callback: (err: Error, resp: Buffer) => void,
        ): boolean;
        emit(
            event: "OCSPRequest",
            certificate: Buffer,
            issuer: Buffer,
            callback: (err: Error | null, resp: Buffer) => void,
        ): boolean;
        emit(event: "resumeSession", sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void): boolean;
        emit(event: "secureConnection", tlsSocket: tls.TLSSocket): boolean;
        emit(event: "tlsClientError", err: Error, tlsSocket: tls.TLSSocket): boolean;
        emit(event: "close"): boolean;
        emit(event: "connection", socket: Duplex): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "listening"): boolean;
        emit(
            event: "checkContinue",
            req: InstanceType<Request>,
            res: InstanceType<Response> & {
                req: InstanceType<Request>;
            },
        ): boolean;
        emit(
            event: "checkExpectation",
            req: InstanceType<Request>,
            res: InstanceType<Response> & {
                req: InstanceType<Request>;
            },
        ): boolean;
        emit(event: "clientError", err: Error, socket: Duplex): boolean;
        emit(event: "connect", req: InstanceType<Request>, socket: Duplex, head: Buffer): boolean;
        emit(
            event: "request",
            req: InstanceType<Request>,
            res: InstanceType<Response> & {
                req: InstanceType<Request>;
            },
        ): boolean;
        emit(event: "upgrade", req: InstanceType<Request>, socket: Duplex, head: Buffer): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "keylog", listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;
        on(
            event: "newSession",
            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,
        ): this;
        on(
            event: "OCSPRequest",
            listener: (
                certificate: Buffer,
                issuer: Buffer,
                callback: (err: Error | null, resp: Buffer) => void,
            ) => void,
        ): this;
        on(
            event: "resumeSession",
            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,
        ): this;
        on(event: "secureConnection", listener: (tlsSocket: tls.TLSSocket) => void): this;
        on(event: "tlsClientError", listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "connection", listener: (socket: Duplex) => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "listening", listener: () => void): this;
        on(event: "checkContinue", listener: http.RequestListener<Request, Response>): this;
        on(event: "checkExpectation", listener: http.RequestListener<Request, Response>): this;
        on(event: "clientError", listener: (err: Error, socket: Duplex) => void): this;
        on(event: "connect", listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void): this;
        on(event: "request", listener: http.RequestListener<Request, Response>): this;
        on(event: "upgrade", listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "keylog", listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;
        once(
            event: "newSession",
            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,
        ): this;
        once(
            event: "OCSPRequest",
            listener: (
                certificate: Buffer,
                issuer: Buffer,
                callback: (err: Error | null, resp: Buffer) => void,
            ) => void,
        ): this;
        once(
            event: "resumeSession",
            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,
        ): this;
        once(event: "secureConnection", listener: (tlsSocket: tls.TLSSocket) => void): this;
        once(event: "tlsClientError", listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "connection", listener: (socket: Duplex) => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "listening", listener: () => void): this;
        once(event: "checkContinue", listener: http.RequestListener<Request, Response>): this;
        once(event: "checkExpectation", listener: http.RequestListener<Request, Response>): this;
        once(event: "clientError", listener: (err: Error, socket: Duplex) => void): this;
        once(event: "connect", listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void): this;
        once(event: "request", listener: http.RequestListener<Request, Response>): this;
        once(event: "upgrade", listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "keylog", listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;
        prependListener(
            event: "newSession",
            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,
        ): this;
        prependListener(
            event: "OCSPRequest",
            listener: (
                certificate: Buffer,
                issuer: Buffer,
                callback: (err: Error | null, resp: Buffer) => void,
            ) => void,
        ): this;
        prependListener(
            event: "resumeSession",
            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,
        ): this;
        prependListener(event: "secureConnection", listener: (tlsSocket: tls.TLSSocket) => void): this;
        prependListener(event: "tlsClientError", listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "connection", listener: (socket: Duplex) => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "listening", listener: () => void): this;
        prependListener(event: "checkContinue", listener: http.RequestListener<Request, Response>): this;
        prependListener(event: "checkExpectation", listener: http.RequestListener<Request, Response>): this;
        prependListener(event: "clientError", listener: (err: Error, socket: Duplex) => void): this;
        prependListener(
            event: "connect",
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
        prependListener(event: "request", listener: http.RequestListener<Request, Response>): this;
        prependListener(
            event: "upgrade",
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "keylog", listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;
        prependOnceListener(
            event: "newSession",
            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,
        ): this;
        prependOnceListener(
            event: "OCSPRequest",
            listener: (
                certificate: Buffer,
                issuer: Buffer,
                callback: (err: Error | null, resp: Buffer) => void,
            ) => void,
        ): this;
        prependOnceListener(
            event: "resumeSession",
            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,
        ): this;
        prependOnceListener(event: "secureConnection", listener: (tlsSocket: tls.TLSSocket) => void): this;
        prependOnceListener(event: "tlsClientError", listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "connection", listener: (socket: Duplex) => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: "listening", listener: () => void): this;
        prependOnceListener(event: "checkContinue", listener: http.RequestListener<Request, Response>): this;
        prependOnceListener(event: "checkExpectation", listener: http.RequestListener<Request, Response>): this;
        prependOnceListener(event: "clientError", listener: (err: Error, socket: Duplex) => void): this;
        prependOnceListener(
            event: "connect",
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
        prependOnceListener(event: "request", listener: http.RequestListener<Request, Response>): this;
        prependOnceListener(
            event: "upgrade",
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
    }
    /**
     * ```js
     * // curl -k https://localhost:8000/
     * const https = require('node:https');
     * const fs = require('node:fs');
     *
     * const options = {
     *   key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),
     *   cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem'),
     * };
     *
     * https.createServer(options, (req, res) => {
     *   res.writeHead(200);
     *   res.end('hello world\n');
     * }).listen(8000);
     * ```
     *
     * Or
     *
     * ```js
     * const https = require('node:https');
     * const fs = require('node:fs');
     *
     * const options = {
     *   pfx: fs.readFileSync('test/fixtures/test_cert.pfx'),
     *   passphrase: 'sample',
     * };
     *
     * https.createServer(options, (req, res) => {
     *   res.writeHead(200);
     *   res.end('hello world\n');
     * }).listen(8000);
     * ```
     * @since v0.3.4
     * @param options Accepts `options` from `createServer`, `createSecureContext` and `createServer`.
     * @param requestListener A listener to be added to the `'request'` event.
     */
    function createServer<
        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,
        Response extends typeof http.ServerResponse = typeof http.ServerResponse,
    >(requestListener?: http.RequestListener<Request, Response>): Server<Request, Response>;
    function createServer<
        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,
        Response extends typeof http.ServerResponse = typeof http.ServerResponse,
    >(
        options: ServerOptions<Request, Response>,
        requestListener?: http.RequestListener<Request, Response>,
    ): Server<Request, Response>;
    /**
     * Makes a request to a secure web server.
     *
     * The following additional `options` from `tls.connect()` are also accepted: `ca`, `cert`, `ciphers`, `clientCertEngine`, `crl`, `dhparam`, `ecdhCurve`, `honorCipherOrder`, `key`, `passphrase`,
     * `pfx`, `rejectUnauthorized`, `secureOptions`, `secureProtocol`, `servername`, `sessionIdContext`, `highWaterMark`.
     *
     * `options` can be an object, a string, or a `URL` object. If `options` is a
     * string, it is automatically parsed with `new URL()`. If it is a `URL` object, it will be automatically converted to an ordinary `options` object.
     *
     * `https.request()` returns an instance of the `http.ClientRequest` class. The `ClientRequest` instance is a writable stream. If one needs to
     * upload a file with a POST request, then write to the `ClientRequest` object.
     *
     * ```js
     * const https = require('node:https');
     *
     * const options = {
     *   hostname: 'encrypted.google.com',
     *   port: 443,
     *   path: '/',
     *   method: 'GET',
     * };
     *
     * const req = https.request(options, (res) => {
     *   console.log('statusCode:', res.statusCode);
     *   console.log('headers:', res.headers);
     *
     *   res.on('data', (d) => {
     *     process.stdout.write(d);
     *   });
     * });
     *
     * req.on('error', (e) => {
     *   console.error(e);
     * });
     * req.end();
     * ```
     *
     * Example using options from `tls.connect()`:
     *
     * ```js
     * const options = {
     *   hostname: 'encrypted.google.com',
     *   port: 443,
     *   path: '/',
     *   method: 'GET',
     *   key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),
     *   cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem'),
     * };
     * options.agent = new https.Agent(options);
     *
     * const req = https.request(options, (res) => {
     *   // ...
     * });
     * ```
     *
     * Alternatively, opt out of connection pooling by not using an `Agent`.
     *
     * ```js
     * const options = {
     *   hostname: 'encrypted.google.com',
     *   port: 443,
     *   path: '/',
     *   method: 'GET',
     *   key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),
     *   cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem'),
     *   agent: false,
     * };
     *
     * const req = https.request(options, (res) => {
     *   // ...
     * });
     * ```
     *
     * Example using a `URL` as `options`:
     *
     * ```js
     * const options = new URL('https://abc:xyz@example.com');
     *
     * const req = https.request(options, (res) => {
     *   // ...
     * });
     * ```
     *
     * Example pinning on certificate fingerprint, or the public key (similar to`pin-sha256`):
     *
     * ```js
     * const tls = require('node:tls');
     * const https = require('node:https');
     * const crypto = require('node:crypto');
     *
     * function sha256(s) {
     *   return crypto.createHash('sha256').update(s).digest('base64');
     * }
     * const options = {
     *   hostname: 'github.com',
     *   port: 443,
     *   path: '/',
     *   method: 'GET',
     *   checkServerIdentity: function(host, cert) {
     *     // Make sure the certificate is issued to the host we are connected to
     *     const err = tls.checkServerIdentity(host, cert);
     *     if (err) {
     *       return err;
     *     }
     *
     *     // Pin the public key, similar to HPKP pin-sha256 pinning
     *     const pubkey256 = 'pL1+qb9HTMRZJmuC/bB/ZI9d302BYrrqiVuRyW+DGrU=';
     *     if (sha256(cert.pubkey) !== pubkey256) {
     *       const msg = 'Certificate verification error: ' +
     *         `The public key of '${cert.subject.CN}' ` +
     *         'does not match our pinned fingerprint';
     *       return new Error(msg);
     *     }
     *
     *     // Pin the exact certificate, rather than the pub key
     *     const cert256 = '25:FE:39:32:D9:63:8C:8A:FC:A1:9A:29:87:' +
     *       'D8:3E:4C:1D:98:DB:71:E4:1A:48:03:98:EA:22:6A:BD:8B:93:16';
     *     if (cert.fingerprint256 !== cert256) {
     *       const msg = 'Certificate verification error: ' +
     *         `The certificate of '${cert.subject.CN}' ` +
     *         'does not match our pinned fingerprint';
     *       return new Error(msg);
     *     }
     *
     *     // This loop is informational only.
     *     // Print the certificate and public key fingerprints of all certs in the
     *     // chain. Its common to pin the public key of the issuer on the public
     *     // internet, while pinning the public key of the service in sensitive
     *     // environments.
     *     do {
     *       console.log('Subject Common Name:', cert.subject.CN);
     *       console.log('  Certificate SHA256 fingerprint:', cert.fingerprint256);
     *
     *       hash = crypto.createHash('sha256');
     *       console.log('  Public key ping-sha256:', sha256(cert.pubkey));
     *
     *       lastprint256 = cert.fingerprint256;
     *       cert = cert.issuerCertificate;
     *     } while (cert.fingerprint256 !== lastprint256);
     *
     *   },
     * };
     *
     * options.agent = new https.Agent(options);
     * const req = https.request(options, (res) => {
     *   console.log('All OK. Server matched our pinned cert or public key');
     *   console.log('statusCode:', res.statusCode);
     *   // Print the HPKP values
     *   console.log('headers:', res.headers['public-key-pins']);
     *
     *   res.on('data', (d) => {});
     * });
     *
     * req.on('error', (e) => {
     *   console.error(e.message);
     * });
     * req.end();
     * ```
     *
     * Outputs for example:
     *
     * ```text
     * Subject Common Name: github.com
     *   Certificate SHA256 fingerprint: 25:FE:39:32:D9:63:8C:8A:FC:A1:9A:29:87:D8:3E:4C:1D:98:DB:71:E4:1A:48:03:98:EA:22:6A:BD:8B:93:16
     *   Public key ping-sha256: pL1+qb9HTMRZJmuC/bB/ZI9d302BYrrqiVuRyW+DGrU=
     * Subject Common Name: DigiCert SHA2 Extended Validation Server CA
     *   Certificate SHA256 fingerprint: 40:3E:06:2A:26:53:05:91:13:28:5B:AF:80:A0:D4:AE:42:2C:84:8C:9F:78:FA:D0:1F:C9:4B:C5:B8:7F:EF:1A
     *   Public key ping-sha256: RRM1dGqnDFsCJXBTHky16vi1obOlCgFFn/yOhI/y+ho=
     * Subject Common Name: DigiCert High Assurance EV Root CA
     *   Certificate SHA256 fingerprint: 74:31:E5:F4:C3:C1:CE:46:90:77:4F:0B:61:E0:54:40:88:3B:A9:A0:1E:D0:0B:A6:AB:D7:80:6E:D3:B1:18:CF
     *   Public key ping-sha256: WoiWRyIOVNa9ihaBciRSC7XHjliYS9VwUGOIud4PB18=
     * All OK. Server matched our pinned cert or public key
     * statusCode: 200
     * headers: max-age=0; pin-sha256="WoiWRyIOVNa9ihaBciRSC7XHjliYS9VwUGOIud4PB18="; pin-sha256="RRM1dGqnDFsCJXBTHky16vi1obOlCgFFn/yOhI/y+ho=";
     * pin-sha256="k2v657xBsOVe1PQRwOsHsw3bsGT2VzIqz5K+59sNQws="; pin-sha256="K87oWBWM9UZfyddvDfoxL+8lpNyoUB2ptGtn0fv6G2Q="; pin-sha256="IQBnNBEiFuhj+8x6X8XLgh01V9Ic5/V3IRQLNFFc7v4=";
     * pin-sha256="iie1VXtL7HzAMF+/PVPR9xzT80kQxdZeJ+zduCB3uj0="; pin-sha256="LvRiGEjRqfzurezaWuj8Wie2gyHMrW5Q06LspMnox7A="; includeSubDomains
     * ```
     * @since v0.3.6
     * @param options Accepts all `options` from `request`, with some differences in default values:
     */
    function request(
        options: RequestOptions | string | URL,
        callback?: (res: http.IncomingMessage) => void,
    ): http.ClientRequest;
    function request(
        url: string | URL,
        options: RequestOptions,
        callback?: (res: http.IncomingMessage) => void,
    ): http.ClientRequest;
    /**
     * Like `http.get()` but for HTTPS.
     *
     * `options` can be an object, a string, or a `URL` object. If `options` is a
     * string, it is automatically parsed with `new URL()`. If it is a `URL` object, it will be automatically converted to an ordinary `options` object.
     *
     * ```js
     * const https = require('node:https');
     *
     * https.get('https://encrypted.google.com/', (res) => {
     *   console.log('statusCode:', res.statusCode);
     *   console.log('headers:', res.headers);
     *
     *   res.on('data', (d) => {
     *     process.stdout.write(d);
     *   });
     *
     * }).on('error', (e) => {
     *   console.error(e);
     * });
     * ```
     * @since v0.3.6
     * @param options Accepts the same `options` as {@link request}, with the `method` always set to `GET`.
     */
    function get(
        options: RequestOptions | string | URL,
        callback?: (res: http.IncomingMessage) => void,
    ): http.ClientRequest;
    function get(
        url: string | URL,
        options: RequestOptions,
        callback?: (res: http.IncomingMessage) => void,
    ): http.ClientRequest;
    let globalAgent: Agent;
}
declare module "node:https" {
    export * from "https";
}
/**
 * License for programmatically and manually incorporated
 * documentation aka. `JSDoc` from https://github.com/nodejs/node/tree/master/doc
 *
 * Copyright Node.js contributors. All rights reserved.
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

// NOTE: These definitions support NodeJS and TypeScript 4.9+.

// Reference required types from the default lib:
/// <reference lib="es2020" />
/// <reference lib="esnext.asynciterable" />
/// <reference lib="esnext.intl" />
/// <reference lib="esnext.bigint" />

// Base definitions for all NodeJS modules that are not specific to any version of TypeScript:
/// <reference path="assert.d.ts" />
/// <reference path="assert/strict.d.ts" />
/// <reference path="globals.d.ts" />
/// <reference path="async_hooks.d.ts" />
/// <reference path="buffer.d.ts" />
/// <reference path="child_process.d.ts" />
/// <reference path="cluster.d.ts" />
/// <reference path="console.d.ts" />
/// <reference path="constants.d.ts" />
/// <reference path="crypto.d.ts" />
/// <reference path="dgram.d.ts" />
/// <reference path="diagnostics_channel.d.ts" />
/// <reference path="dns.d.ts" />
/// <reference path="dns/promises.d.ts" />
/// <reference path="dns/promises.d.ts" />
/// <reference path="domain.d.ts" />
/// <reference path="dom-events.d.ts" />
/// <reference path="events.d.ts" />
/// <reference path="fs.d.ts" />
/// <reference path="fs/promises.d.ts" />
/// <reference path="http.d.ts" />
/// <reference path="http2.d.ts" />
/// <reference path="https.d.ts" />
/// <reference path="inspector.d.ts" />
/// <reference path="module.d.ts" />
/// <reference path="net.d.ts" />
/// <reference path="os.d.ts" />
/// <reference path="path.d.ts" />
/// <reference path="perf_hooks.d.ts" />
/// <reference path="process.d.ts" />
/// <reference path="punycode.d.ts" />
/// <reference path="querystring.d.ts" />
/// <reference path="readline.d.ts" />
/// <reference path="readline/promises.d.ts" />
/// <reference path="repl.d.ts" />
/// <reference path="sea.d.ts" />
/// <reference path="sqlite.d.ts" />
/// <reference path="stream.d.ts" />
/// <reference path="stream/promises.d.ts" />
/// <reference path="stream/consumers.d.ts" />
/// <reference path="stream/web.d.ts" />
/// <reference path="string_decoder.d.ts" />
/// <reference path="test.d.ts" />
/// <reference path="timers.d.ts" />
/// <reference path="timers/promises.d.ts" />
/// <reference path="tls.d.ts" />
/// <reference path="trace_events.d.ts" />
/// <reference path="tty.d.ts" />
/// <reference path="url.d.ts" />
/// <reference path="util.d.ts" />
/// <reference path="v8.d.ts" />
/// <reference path="vm.d.ts" />
/// <reference path="wasi.d.ts" />
/// <reference path="worker_threads.d.ts" />
/// <reference path="zlib.d.ts" />

/// <reference path="globals.global.d.ts" />
// These definitions are automatically generated by the generate-inspector script.
// Do not edit this file directly.
// See scripts/generate-inspector/README.md for information on how to update the protocol definitions.
// Changes to the module itself should be added to the generator template (scripts/generate-inspector/inspector.d.ts.template).

/**
 * The `node:inspector` module provides an API for interacting with the V8
 * inspector.
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/inspector.js)
 */
declare module 'inspector' {
    import EventEmitter = require('node:events');

    interface InspectorNotification<T> {
        method: string;
        params: T;
    }

    namespace Schema {
        /**
         * Description of the protocol domain.
         */
        interface Domain {
            /**
             * Domain name.
             */
            name: string;
            /**
             * Domain version.
             */
            version: string;
        }
        interface GetDomainsReturnType {
            /**
             * List of supported domains.
             */
            domains: Domain[];
        }
    }
    namespace Runtime {
        /**
         * Unique script identifier.
         */
        type ScriptId = string;
        /**
         * Unique object identifier.
         */
        type RemoteObjectId = string;
        /**
         * Primitive value which cannot be JSON-stringified.
         */
        type UnserializableValue = string;
        /**
         * Mirror object referencing original JavaScript object.
         */
        interface RemoteObject {
            /**
             * Object type.
             */
            type: string;
            /**
             * Object subtype hint. Specified for <code>object</code> type values only.
             */
            subtype?: string | undefined;
            /**
             * Object class (constructor) name. Specified for <code>object</code> type values only.
             */
            className?: string | undefined;
            /**
             * Remote object value in case of primitive values or JSON values (if it was requested).
             */
            value?: any;
            /**
             * Primitive value which can not be JSON-stringified does not have <code>value</code>, but gets this property.
             */
            unserializableValue?: UnserializableValue | undefined;
            /**
             * String representation of the object.
             */
            description?: string | undefined;
            /**
             * Unique object identifier (for non-primitive values).
             */
            objectId?: RemoteObjectId | undefined;
            /**
             * Preview containing abbreviated property values. Specified for <code>object</code> type values only.
             * @experimental
             */
            preview?: ObjectPreview | undefined;
            /**
             * @experimental
             */
            customPreview?: CustomPreview | undefined;
        }
        /**
         * @experimental
         */
        interface CustomPreview {
            header: string;
            hasBody: boolean;
            formatterObjectId: RemoteObjectId;
            bindRemoteObjectFunctionId: RemoteObjectId;
            configObjectId?: RemoteObjectId | undefined;
        }
        /**
         * Object containing abbreviated remote object value.
         * @experimental
         */
        interface ObjectPreview {
            /**
             * Object type.
             */
            type: string;
            /**
             * Object subtype hint. Specified for <code>object</code> type values only.
             */
            subtype?: string | undefined;
            /**
             * String representation of the object.
             */
            description?: string | undefined;
            /**
             * True iff some of the properties or entries of the original object did not fit.
             */
            overflow: boolean;
            /**
             * List of the properties.
             */
            properties: PropertyPreview[];
            /**
             * List of the entries. Specified for <code>map</code> and <code>set</code> subtype values only.
             */
            entries?: EntryPreview[] | undefined;
        }
        /**
         * @experimental
         */
        interface PropertyPreview {
            /**
             * Property name.
             */
            name: string;
            /**
             * Object type. Accessor means that the property itself is an accessor property.
             */
            type: string;
            /**
             * User-friendly property value string.
             */
            value?: string | undefined;
            /**
             * Nested value preview.
             */
            valuePreview?: ObjectPreview | undefined;
            /**
             * Object subtype hint. Specified for <code>object</code> type values only.
             */
            subtype?: string | undefined;
        }
        /**
         * @experimental
         */
        interface EntryPreview {
            /**
             * Preview of the key. Specified for map-like collection entries.
             */
            key?: ObjectPreview | undefined;
            /**
             * Preview of the value.
             */
            value: ObjectPreview;
        }
        /**
         * Object property descriptor.
         */
        interface PropertyDescriptor {
            /**
             * Property name or symbol description.
             */
            name: string;
            /**
             * The value associated with the property.
             */
            value?: RemoteObject | undefined;
            /**
             * True if the value associated with the property may be changed (data descriptors only).
             */
            writable?: boolean | undefined;
            /**
             * A function which serves as a getter for the property, or <code>undefined</code> if there is no getter (accessor descriptors only).
             */
            get?: RemoteObject | undefined;
            /**
             * A function which serves as a setter for the property, or <code>undefined</code> if there is no setter (accessor descriptors only).
             */
            set?: RemoteObject | undefined;
            /**
             * True if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.
             */
            configurable: boolean;
            /**
             * True if this property shows up during enumeration of the properties on the corresponding object.
             */
            enumerable: boolean;
            /**
             * True if the result was thrown during the evaluation.
             */
            wasThrown?: boolean | undefined;
            /**
             * True if the property is owned for the object.
             */
            isOwn?: boolean | undefined;
            /**
             * Property symbol object, if the property is of the <code>symbol</code> type.
             */
            symbol?: RemoteObject | undefined;
        }
        /**
         * Object internal property descriptor. This property isn't normally visible in JavaScript code.
         */
        interface InternalPropertyDescriptor {
            /**
             * Conventional property name.
             */
            name: string;
            /**
             * The value associated with the property.
             */
            value?: RemoteObject | undefined;
        }
        /**
         * Represents function call argument. Either remote object id <code>objectId</code>, primitive <code>value</code>, unserializable primitive value or neither of (for undefined) them should be specified.
         */
        interface CallArgument {
            /**
             * Primitive value or serializable javascript object.
             */
            value?: any;
            /**
             * Primitive value which can not be JSON-stringified.
             */
            unserializableValue?: UnserializableValue | undefined;
            /**
             * Remote object handle.
             */
            objectId?: RemoteObjectId | undefined;
        }
        /**
         * Id of an execution context.
         */
        type ExecutionContextId = number;
        /**
         * Description of an isolated world.
         */
        interface ExecutionContextDescription {
            /**
             * Unique id of the execution context. It can be used to specify in which execution context script evaluation should be performed.
             */
            id: ExecutionContextId;
            /**
             * Execution context origin.
             */
            origin: string;
            /**
             * Human readable name describing given context.
             */
            name: string;
            /**
             * Embedder-specific auxiliary data.
             */
            auxData?: {} | undefined;
        }
        /**
         * Detailed information about exception (or error) that was thrown during script compilation or execution.
         */
        interface ExceptionDetails {
            /**
             * Exception id.
             */
            exceptionId: number;
            /**
             * Exception text, which should be used together with exception object when available.
             */
            text: string;
            /**
             * Line number of the exception location (0-based).
             */
            lineNumber: number;
            /**
             * Column number of the exception location (0-based).
             */
            columnNumber: number;
            /**
             * Script ID of the exception location.
             */
            scriptId?: ScriptId | undefined;
            /**
             * URL of the exception location, to be used when the script was not reported.
             */
            url?: string | undefined;
            /**
             * JavaScript stack trace if available.
             */
            stackTrace?: StackTrace | undefined;
            /**
             * Exception object if available.
             */
            exception?: RemoteObject | undefined;
            /**
             * Identifier of the context where exception happened.
             */
            executionContextId?: ExecutionContextId | undefined;
        }
        /**
         * Number of milliseconds since epoch.
         */
        type Timestamp = number;
        /**
         * Stack entry for runtime errors and assertions.
         */
        interface CallFrame {
            /**
             * JavaScript function name.
             */
            functionName: string;
            /**
             * JavaScript script id.
             */
            scriptId: ScriptId;
            /**
             * JavaScript script name or url.
             */
            url: string;
            /**
             * JavaScript script line number (0-based).
             */
            lineNumber: number;
            /**
             * JavaScript script column number (0-based).
             */
            columnNumber: number;
        }
        /**
         * Call frames for assertions or error messages.
         */
        interface StackTrace {
            /**
             * String label of this stack trace. For async traces this may be a name of the function that initiated the async call.
             */
            description?: string | undefined;
            /**
             * JavaScript function name.
             */
            callFrames: CallFrame[];
            /**
             * Asynchronous JavaScript stack trace that preceded this stack, if available.
             */
            parent?: StackTrace | undefined;
            /**
             * Asynchronous JavaScript stack trace that preceded this stack, if available.
             * @experimental
             */
            parentId?: StackTraceId | undefined;
        }
        /**
         * Unique identifier of current debugger.
         * @experimental
         */
        type UniqueDebuggerId = string;
        /**
         * If <code>debuggerId</code> is set stack trace comes from another debugger and can be resolved there. This allows to track cross-debugger calls. See <code>Runtime.StackTrace</code> and <code>Debugger.paused</code> for usages.
         * @experimental
         */
        interface StackTraceId {
            id: string;
            debuggerId?: UniqueDebuggerId | undefined;
        }
        interface EvaluateParameterType {
            /**
             * Expression to evaluate.
             */
            expression: string;
            /**
             * Symbolic group name that can be used to release multiple objects.
             */
            objectGroup?: string | undefined;
            /**
             * Determines whether Command Line API should be available during the evaluation.
             */
            includeCommandLineAPI?: boolean | undefined;
            /**
             * In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state.
             */
            silent?: boolean | undefined;
            /**
             * Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
             */
            contextId?: ExecutionContextId | undefined;
            /**
             * Whether the result is expected to be a JSON object that should be sent by value.
             */
            returnByValue?: boolean | undefined;
            /**
             * Whether preview should be generated for the result.
             * @experimental
             */
            generatePreview?: boolean | undefined;
            /**
             * Whether execution should be treated as initiated by user in the UI.
             */
            userGesture?: boolean | undefined;
            /**
             * Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved.
             */
            awaitPromise?: boolean | undefined;
        }
        interface AwaitPromiseParameterType {
            /**
             * Identifier of the promise.
             */
            promiseObjectId: RemoteObjectId;
            /**
             * Whether the result is expected to be a JSON object that should be sent by value.
             */
            returnByValue?: boolean | undefined;
            /**
             * Whether preview should be generated for the result.
             */
            generatePreview?: boolean | undefined;
        }
        interface CallFunctionOnParameterType {
            /**
             * Declaration of the function to call.
             */
            functionDeclaration: string;
            /**
             * Identifier of the object to call function on. Either objectId or executionContextId should be specified.
             */
            objectId?: RemoteObjectId | undefined;
            /**
             * Call arguments. All call arguments must belong to the same JavaScript world as the target object.
             */
            arguments?: CallArgument[] | undefined;
            /**
             * In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state.
             */
            silent?: boolean | undefined;
            /**
             * Whether the result is expected to be a JSON object which should be sent by value.
             */
            returnByValue?: boolean | undefined;
            /**
             * Whether preview should be generated for the result.
             * @experimental
             */
            generatePreview?: boolean | undefined;
            /**
             * Whether execution should be treated as initiated by user in the UI.
             */
            userGesture?: boolean | undefined;
            /**
             * Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved.
             */
            awaitPromise?: boolean | undefined;
            /**
             * Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
             */
            executionContextId?: ExecutionContextId | undefined;
            /**
             * Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
             */
            objectGroup?: string | undefined;
        }
        interface GetPropertiesParameterType {
            /**
             * Identifier of the object to return properties for.
             */
            objectId: RemoteObjectId;
            /**
             * If true, returns properties belonging only to the element itself, not to its prototype chain.
             */
            ownProperties?: boolean | undefined;
            /**
             * If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
             * @experimental
             */
            accessorPropertiesOnly?: boolean | undefined;
            /**
             * Whether preview should be generated for the results.
             * @experimental
             */
            generatePreview?: boolean | undefined;
        }
        interface ReleaseObjectParameterType {
            /**
             * Identifier of the object to release.
             */
            objectId: RemoteObjectId;
        }
        interface ReleaseObjectGroupParameterType {
            /**
             * Symbolic object group name.
             */
            objectGroup: string;
        }
        interface SetCustomObjectFormatterEnabledParameterType {
            enabled: boolean;
        }
        interface CompileScriptParameterType {
            /**
             * Expression to compile.
             */
            expression: string;
            /**
             * Source url to be set for the script.
             */
            sourceURL: string;
            /**
             * Specifies whether the compiled script should be persisted.
             */
            persistScript: boolean;
            /**
             * Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
             */
            executionContextId?: ExecutionContextId | undefined;
        }
        interface RunScriptParameterType {
            /**
             * Id of the script to run.
             */
            scriptId: ScriptId;
            /**
             * Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
             */
            executionContextId?: ExecutionContextId | undefined;
            /**
             * Symbolic group name that can be used to release multiple objects.
             */
            objectGroup?: string | undefined;
            /**
             * In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state.
             */
            silent?: boolean | undefined;
            /**
             * Determines whether Command Line API should be available during the evaluation.
             */
            includeCommandLineAPI?: boolean | undefined;
            /**
             * Whether the result is expected to be a JSON object which should be sent by value.
             */
            returnByValue?: boolean | undefined;
            /**
             * Whether preview should be generated for the result.
             */
            generatePreview?: boolean | undefined;
            /**
             * Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved.
             */
            awaitPromise?: boolean | undefined;
        }
        interface QueryObjectsParameterType {
            /**
             * Identifier of the prototype to return objects for.
             */
            prototypeObjectId: RemoteObjectId;
        }
        interface GlobalLexicalScopeNamesParameterType {
            /**
             * Specifies in which execution context to lookup global scope variables.
             */
            executionContextId?: ExecutionContextId | undefined;
        }
        interface EvaluateReturnType {
            /**
             * Evaluation result.
             */
            result: RemoteObject;
            /**
             * Exception details.
             */
            exceptionDetails?: ExceptionDetails | undefined;
        }
        interface AwaitPromiseReturnType {
            /**
             * Promise result. Will contain rejected value if promise was rejected.
             */
            result: RemoteObject;
            /**
             * Exception details if stack strace is available.
             */
            exceptionDetails?: ExceptionDetails | undefined;
        }
        interface CallFunctionOnReturnType {
            /**
             * Call result.
             */
            result: RemoteObject;
            /**
             * Exception details.
             */
            exceptionDetails?: ExceptionDetails | undefined;
        }
        interface GetPropertiesReturnType {
            /**
             * Object properties.
             */
            result: PropertyDescriptor[];
            /**
             * Internal object properties (only of the element itself).
             */
            internalProperties?: InternalPropertyDescriptor[] | undefined;
            /**
             * Exception details.
             */
            exceptionDetails?: ExceptionDetails | undefined;
        }
        interface CompileScriptReturnType {
            /**
             * Id of the script.
             */
            scriptId?: ScriptId | undefined;
            /**
             * Exception details.
             */
            exceptionDetails?: ExceptionDetails | undefined;
        }
        interface RunScriptReturnType {
            /**
             * Run result.
             */
            result: RemoteObject;
            /**
             * Exception details.
             */
            exceptionDetails?: ExceptionDetails | undefined;
        }
        interface QueryObjectsReturnType {
            /**
             * Array with objects.
             */
            objects: RemoteObject;
        }
        interface GlobalLexicalScopeNamesReturnType {
            names: string[];
        }
        interface ExecutionContextCreatedEventDataType {
            /**
             * A newly created execution context.
             */
            context: ExecutionContextDescription;
        }
        interface ExecutionContextDestroyedEventDataType {
            /**
             * Id of the destroyed context
             */
            executionContextId: ExecutionContextId;
        }
        interface ExceptionThrownEventDataType {
            /**
             * Timestamp of the exception.
             */
            timestamp: Timestamp;
            exceptionDetails: ExceptionDetails;
        }
        interface ExceptionRevokedEventDataType {
            /**
             * Reason describing why exception was revoked.
             */
            reason: string;
            /**
             * The id of revoked exception, as reported in <code>exceptionThrown</code>.
             */
            exceptionId: number;
        }
        interface ConsoleAPICalledEventDataType {
            /**
             * Type of the call.
             */
            type: string;
            /**
             * Call arguments.
             */
            args: RemoteObject[];
            /**
             * Identifier of the context where the call was made.
             */
            executionContextId: ExecutionContextId;
            /**
             * Call timestamp.
             */
            timestamp: Timestamp;
            /**
             * Stack trace captured when the call was made.
             */
            stackTrace?: StackTrace | undefined;
            /**
             * Console context descriptor for calls on non-default console context (not console.*): 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call on named context.
             * @experimental
             */
            context?: string | undefined;
        }
        interface InspectRequestedEventDataType {
            object: RemoteObject;
            hints: {};
        }
    }
    namespace Debugger {
        /**
         * Breakpoint identifier.
         */
        type BreakpointId = string;
        /**
         * Call frame identifier.
         */
        type CallFrameId = string;
        /**
         * Location in the source code.
         */
        interface Location {
            /**
             * Script identifier as reported in the <code>Debugger.scriptParsed</code>.
             */
            scriptId: Runtime.ScriptId;
            /**
             * Line number in the script (0-based).
             */
            lineNumber: number;
            /**
             * Column number in the script (0-based).
             */
            columnNumber?: number | undefined;
        }
        /**
         * Location in the source code.
         * @experimental
         */
        interface ScriptPosition {
            lineNumber: number;
            columnNumber: number;
        }
        /**
         * JavaScript call frame. Array of call frames form the call stack.
         */
        interface CallFrame {
            /**
             * Call frame identifier. This identifier is only valid while the virtual machine is paused.
             */
            callFrameId: CallFrameId;
            /**
             * Name of the JavaScript function called on this call frame.
             */
            functionName: string;
            /**
             * Location in the source code.
             */
            functionLocation?: Location | undefined;
            /**
             * Location in the source code.
             */
            location: Location;
            /**
             * JavaScript script name or url.
             */
            url: string;
            /**
             * Scope chain for this call frame.
             */
            scopeChain: Scope[];
            /**
             * <code>this</code> object for this call frame.
             */
            this: Runtime.RemoteObject;
            /**
             * The value being returned, if the function is at return point.
             */
            returnValue?: Runtime.RemoteObject | undefined;
        }
        /**
         * Scope description.
         */
        interface Scope {
            /**
             * Scope type.
             */
            type: string;
            /**
             * Object representing the scope. For <code>global</code> and <code>with</code> scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties.
             */
            object: Runtime.RemoteObject;
            name?: string | undefined;
            /**
             * Location in the source code where scope starts
             */
            startLocation?: Location | undefined;
            /**
             * Location in the source code where scope ends
             */
            endLocation?: Location | undefined;
        }
        /**
         * Search match for resource.
         */
        interface SearchMatch {
            /**
             * Line number in resource content.
             */
            lineNumber: number;
            /**
             * Line with match content.
             */
            lineContent: string;
        }
        interface BreakLocation {
            /**
             * Script identifier as reported in the <code>Debugger.scriptParsed</code>.
             */
            scriptId: Runtime.ScriptId;
            /**
             * Line number in the script (0-based).
             */
            lineNumber: number;
            /**
             * Column number in the script (0-based).
             */
            columnNumber?: number | undefined;
            type?: string | undefined;
        }
        interface SetBreakpointsActiveParameterType {
            /**
             * New value for breakpoints active state.
             */
            active: boolean;
        }
        interface SetSkipAllPausesParameterType {
            /**
             * New value for skip pauses state.
             */
            skip: boolean;
        }
        interface SetBreakpointByUrlParameterType {
            /**
             * Line number to set breakpoint at.
             */
            lineNumber: number;
            /**
             * URL of the resources to set breakpoint on.
             */
            url?: string | undefined;
            /**
             * Regex pattern for the URLs of the resources to set breakpoints on. Either <code>url</code> or <code>urlRegex</code> must be specified.
             */
            urlRegex?: string | undefined;
            /**
             * Script hash of the resources to set breakpoint on.
             */
            scriptHash?: string | undefined;
            /**
             * Offset in the line to set breakpoint at.
             */
            columnNumber?: number | undefined;
            /**
             * Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
             */
            condition?: string | undefined;
        }
        interface SetBreakpointParameterType {
            /**
             * Location to set breakpoint in.
             */
            location: Location;
            /**
             * Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
             */
            condition?: string | undefined;
        }
        interface RemoveBreakpointParameterType {
            breakpointId: BreakpointId;
        }
        interface GetPossibleBreakpointsParameterType {
            /**
             * Start of range to search possible breakpoint locations in.
             */
            start: Location;
            /**
             * End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
             */
            end?: Location | undefined;
            /**
             * Only consider locations which are in the same (non-nested) function as start.
             */
            restrictToFunction?: boolean | undefined;
        }
        interface ContinueToLocationParameterType {
            /**
             * Location to continue to.
             */
            location: Location;
            targetCallFrames?: string | undefined;
        }
        interface PauseOnAsyncCallParameterType {
            /**
             * Debugger will pause when async call with given stack trace is started.
             */
            parentStackTraceId: Runtime.StackTraceId;
        }
        interface StepIntoParameterType {
            /**
             * Debugger will issue additional Debugger.paused notification if any async task is scheduled before next pause.
             * @experimental
             */
            breakOnAsyncCall?: boolean | undefined;
        }
        interface GetStackTraceParameterType {
            stackTraceId: Runtime.StackTraceId;
        }
        interface SearchInContentParameterType {
            /**
             * Id of the script to search in.
             */
            scriptId: Runtime.ScriptId;
            /**
             * String to search for.
             */
            query: string;
            /**
             * If true, search is case sensitive.
             */
            caseSensitive?: boolean | undefined;
            /**
             * If true, treats string parameter as regex.
             */
            isRegex?: boolean | undefined;
        }
        interface SetScriptSourceParameterType {
            /**
             * Id of the script to edit.
             */
            scriptId: Runtime.ScriptId;
            /**
             * New content of the script.
             */
            scriptSource: string;
            /**
             *  If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
             */
            dryRun?: boolean | undefined;
        }
        interface RestartFrameParameterType {
            /**
             * Call frame identifier to evaluate on.
             */
            callFrameId: CallFrameId;
        }
        interface GetScriptSourceParameterType {
            /**
             * Id of the script to get source for.
             */
            scriptId: Runtime.ScriptId;
        }
        interface SetPauseOnExceptionsParameterType {
            /**
             * Pause on exceptions mode.
             */
            state: string;
        }
        interface EvaluateOnCallFrameParameterType {
            /**
             * Call frame identifier to evaluate on.
             */
            callFrameId: CallFrameId;
            /**
             * Expression to evaluate.
             */
            expression: string;
            /**
             * String object group name to put result into (allows rapid releasing resulting object handles using <code>releaseObjectGroup</code>).
             */
            objectGroup?: string | undefined;
            /**
             * Specifies whether command line API should be available to the evaluated expression, defaults to false.
             */
            includeCommandLineAPI?: boolean | undefined;
            /**
             * In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state.
             */
            silent?: boolean | undefined;
            /**
             * Whether the result is expected to be a JSON object that should be sent by value.
             */
            returnByValue?: boolean | undefined;
            /**
             * Whether preview should be generated for the result.
             * @experimental
             */
            generatePreview?: boolean | undefined;
            /**
             * Whether to throw an exception if side effect cannot be ruled out during evaluation.
             */
            throwOnSideEffect?: boolean | undefined;
        }
        interface SetVariableValueParameterType {
            /**
             * 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
             */
            scopeNumber: number;
            /**
             * Variable name.
             */
            variableName: string;
            /**
             * New variable value.
             */
            newValue: Runtime.CallArgument;
            /**
             * Id of callframe that holds variable.
             */
            callFrameId: CallFrameId;
        }
        interface SetReturnValueParameterType {
            /**
             * New return value.
             */
            newValue: Runtime.CallArgument;
        }
        interface SetAsyncCallStackDepthParameterType {
            /**
             * Maximum depth of async call stacks. Setting to <code>0</code> will effectively disable collecting async call stacks (default).
             */
            maxDepth: number;
        }
        interface SetBlackboxPatternsParameterType {
            /**
             * Array of regexps that will be used to check script url for blackbox state.
             */
            patterns: string[];
        }
        interface SetBlackboxedRangesParameterType {
            /**
             * Id of the script.
             */
            scriptId: Runtime.ScriptId;
            positions: ScriptPosition[];
        }
        interface EnableReturnType {
            /**
             * Unique identifier of the debugger.
             * @experimental
             */
            debuggerId: Runtime.UniqueDebuggerId;
        }
        interface SetBreakpointByUrlReturnType {
            /**
             * Id of the created breakpoint for further reference.
             */
            breakpointId: BreakpointId;
            /**
             * List of the locations this breakpoint resolved into upon addition.
             */
            locations: Location[];
        }
        interface SetBreakpointReturnType {
            /**
             * Id of the created breakpoint for further reference.
             */
            breakpointId: BreakpointId;
            /**
             * Location this breakpoint resolved into.
             */
            actualLocation: Location;
        }
        interface GetPossibleBreakpointsReturnType {
            /**
             * List of the possible breakpoint locations.
             */
            locations: BreakLocation[];
        }
        interface GetStackTraceReturnType {
            stackTrace: Runtime.StackTrace;
        }
        interface SearchInContentReturnType {
            /**
             * List of search matches.
             */
            result: SearchMatch[];
        }
        interface SetScriptSourceReturnType {
            /**
             * New stack trace in case editing has happened while VM was stopped.
             */
            callFrames?: CallFrame[] | undefined;
            /**
             * Whether current call stack  was modified after applying the changes.
             */
            stackChanged?: boolean | undefined;
            /**
             * Async stack trace, if any.
             */
            asyncStackTrace?: Runtime.StackTrace | undefined;
            /**
             * Async stack trace, if any.
             * @experimental
             */
            asyncStackTraceId?: Runtime.StackTraceId | undefined;
            /**
             * Exception details if any.
             */
            exceptionDetails?: Runtime.ExceptionDetails | undefined;
        }
        interface RestartFrameReturnType {
            /**
             * New stack trace.
             */
            callFrames: CallFrame[];
            /**
             * Async stack trace, if any.
             */
            asyncStackTrace?: Runtime.StackTrace | undefined;
            /**
             * Async stack trace, if any.
             * @experimental
             */
            asyncStackTraceId?: Runtime.StackTraceId | undefined;
        }
        interface GetScriptSourceReturnType {
            /**
             * Script source.
             */
            scriptSource: string;
        }
        interface EvaluateOnCallFrameReturnType {
            /**
             * Object wrapper for the evaluation result.
             */
            result: Runtime.RemoteObject;
            /**
             * Exception details.
             */
            exceptionDetails?: Runtime.ExceptionDetails | undefined;
        }
        interface ScriptParsedEventDataType {
            /**
             * Identifier of the script parsed.
             */
            scriptId: Runtime.ScriptId;
            /**
             * URL or name of the script parsed (if any).
             */
            url: string;
            /**
             * Line offset of the script within the resource with given URL (for script tags).
             */
            startLine: number;
            /**
             * Column offset of the script within the resource with given URL.
             */
            startColumn: number;
            /**
             * Last line of the script.
             */
            endLine: number;
            /**
             * Length of the last line of the script.
             */
            endColumn: number;
            /**
             * Specifies script creation context.
             */
            executionContextId: Runtime.ExecutionContextId;
            /**
             * Content hash of the script.
             */
            hash: string;
            /**
             * Embedder-specific auxiliary data.
             */
            executionContextAuxData?: {} | undefined;
            /**
             * True, if this script is generated as a result of the live edit operation.
             * @experimental
             */
            isLiveEdit?: boolean | undefined;
            /**
             * URL of source map associated with script (if any).
             */
            sourceMapURL?: string | undefined;
            /**
             * True, if this script has sourceURL.
             */
            hasSourceURL?: boolean | undefined;
            /**
             * True, if this script is ES6 module.
             */
            isModule?: boolean | undefined;
            /**
             * This script length.
             */
            length?: number | undefined;
            /**
             * JavaScript top stack frame of where the script parsed event was triggered if available.
             * @experimental
             */
            stackTrace?: Runtime.StackTrace | undefined;
        }
        interface ScriptFailedToParseEventDataType {
            /**
             * Identifier of the script parsed.
             */
            scriptId: Runtime.ScriptId;
            /**
             * URL or name of the script parsed (if any).
             */
            url: string;
            /**
             * Line offset of the script within the resource with given URL (for script tags).
             */
            startLine: number;
            /**
             * Column offset of the script within the resource with given URL.
             */
            startColumn: number;
            /**
             * Last line of the script.
             */
            endLine: number;
            /**
             * Length of the last line of the script.
             */
            endColumn: number;
            /**
             * Specifies script creation context.
             */
            executionContextId: Runtime.ExecutionContextId;
            /**
             * Content hash of the script.
             */
            hash: string;
            /**
             * Embedder-specific auxiliary data.
             */
            executionContextAuxData?: {} | undefined;
            /**
             * URL of source map associated with script (if any).
             */
            sourceMapURL?: string | undefined;
            /**
             * True, if this script has sourceURL.
             */
            hasSourceURL?: boolean | undefined;
            /**
             * True, if this script is ES6 module.
             */
            isModule?: boolean | undefined;
            /**
             * This script length.
             */
            length?: number | undefined;
            /**
             * JavaScript top stack frame of where the script parsed event was triggered if available.
             * @experimental
             */
            stackTrace?: Runtime.StackTrace | undefined;
        }
        interface BreakpointResolvedEventDataType {
            /**
             * Breakpoint unique identifier.
             */
            breakpointId: BreakpointId;
            /**
             * Actual breakpoint location.
             */
            location: Location;
        }
        interface PausedEventDataType {
            /**
             * Call stack the virtual machine stopped on.
             */
            callFrames: CallFrame[];
            /**
             * Pause reason.
             */
            reason: string;
            /**
             * Object containing break-specific auxiliary properties.
             */
            data?: {} | undefined;
            /**
             * Hit breakpoints IDs
             */
            hitBreakpoints?: string[] | undefined;
            /**
             * Async stack trace, if any.
             */
            asyncStackTrace?: Runtime.StackTrace | undefined;
            /**
             * Async stack trace, if any.
             * @experimental
             */
            asyncStackTraceId?: Runtime.StackTraceId | undefined;
            /**
             * Just scheduled async call will have this stack trace as parent stack during async execution. This field is available only after <code>Debugger.stepInto</code> call with <code>breakOnAsynCall</code> flag.
             * @experimental
             */
            asyncCallStackTraceId?: Runtime.StackTraceId | undefined;
        }
    }
    namespace Console {
        /**
         * Console message.
         */
        interface ConsoleMessage {
            /**
             * Message source.
             */
            source: string;
            /**
             * Message severity.
             */
            level: string;
            /**
             * Message text.
             */
            text: string;
            /**
             * URL of the message origin.
             */
            url?: string | undefined;
            /**
             * Line number in the resource that generated this message (1-based).
             */
            line?: number | undefined;
            /**
             * Column number in the resource that generated this message (1-based).
             */
            column?: number | undefined;
        }
        interface MessageAddedEventDataType {
            /**
             * Console message that has been added.
             */
            message: ConsoleMessage;
        }
    }
    namespace Profiler {
        /**
         * Profile node. Holds callsite information, execution statistics and child nodes.
         */
        interface ProfileNode {
            /**
             * Unique id of the node.
             */
            id: number;
            /**
             * Function location.
             */
            callFrame: Runtime.CallFrame;
            /**
             * Number of samples where this node was on top of the call stack.
             */
            hitCount?: number | undefined;
            /**
             * Child node ids.
             */
            children?: number[] | undefined;
            /**
             * The reason of being not optimized. The function may be deoptimized or marked as don't optimize.
             */
            deoptReason?: string | undefined;
            /**
             * An array of source position ticks.
             */
            positionTicks?: PositionTickInfo[] | undefined;
        }
        /**
         * Profile.
         */
        interface Profile {
            /**
             * The list of profile nodes. First item is the root node.
             */
            nodes: ProfileNode[];
            /**
             * Profiling start timestamp in microseconds.
             */
            startTime: number;
            /**
             * Profiling end timestamp in microseconds.
             */
            endTime: number;
            /**
             * Ids of samples top nodes.
             */
            samples?: number[] | undefined;
            /**
             * Time intervals between adjacent samples in microseconds. The first delta is relative to the profile startTime.
             */
            timeDeltas?: number[] | undefined;
        }
        /**
         * Specifies a number of samples attributed to a certain source position.
         */
        interface PositionTickInfo {
            /**
             * Source line number (1-based).
             */
            line: number;
            /**
             * Number of samples attributed to the source line.
             */
            ticks: number;
        }
        /**
         * Coverage data for a source range.
         */
        interface CoverageRange {
            /**
             * JavaScript script source offset for the range start.
             */
            startOffset: number;
            /**
             * JavaScript script source offset for the range end.
             */
            endOffset: number;
            /**
             * Collected execution count of the source range.
             */
            count: number;
        }
        /**
         * Coverage data for a JavaScript function.
         */
        interface FunctionCoverage {
            /**
             * JavaScript function name.
             */
            functionName: string;
            /**
             * Source ranges inside the function with coverage data.
             */
            ranges: CoverageRange[];
            /**
             * Whether coverage data for this function has block granularity.
             */
            isBlockCoverage: boolean;
        }
        /**
         * Coverage data for a JavaScript script.
         */
        interface ScriptCoverage {
            /**
             * JavaScript script id.
             */
            scriptId: Runtime.ScriptId;
            /**
             * JavaScript script name or url.
             */
            url: string;
            /**
             * Functions contained in the script that has coverage data.
             */
            functions: FunctionCoverage[];
        }
        interface SetSamplingIntervalParameterType {
            /**
             * New sampling interval in microseconds.
             */
            interval: number;
        }
        interface StartPreciseCoverageParameterType {
            /**
             * Collect accurate call counts beyond simple 'covered' or 'not covered'.
             */
            callCount?: boolean | undefined;
            /**
             * Collect block-based coverage.
             */
            detailed?: boolean | undefined;
        }
        interface StopReturnType {
            /**
             * Recorded profile.
             */
            profile: Profile;
        }
        interface TakePreciseCoverageReturnType {
            /**
             * Coverage data for the current isolate.
             */
            result: ScriptCoverage[];
        }
        interface GetBestEffortCoverageReturnType {
            /**
             * Coverage data for the current isolate.
             */
            result: ScriptCoverage[];
        }
        interface ConsoleProfileStartedEventDataType {
            id: string;
            /**
             * Location of console.profile().
             */
            location: Debugger.Location;
            /**
             * Profile title passed as an argument to console.profile().
             */
            title?: string | undefined;
        }
        interface ConsoleProfileFinishedEventDataType {
            id: string;
            /**
             * Location of console.profileEnd().
             */
            location: Debugger.Location;
            profile: Profile;
            /**
             * Profile title passed as an argument to console.profile().
             */
            title?: string | undefined;
        }
    }
    namespace HeapProfiler {
        /**
         * Heap snapshot object id.
         */
        type HeapSnapshotObjectId = string;
        /**
         * Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.
         */
        interface SamplingHeapProfileNode {
            /**
             * Function location.
             */
            callFrame: Runtime.CallFrame;
            /**
             * Allocations size in bytes for the node excluding children.
             */
            selfSize: number;
            /**
             * Child nodes.
             */
            children: SamplingHeapProfileNode[];
        }
        /**
         * Profile.
         */
        interface SamplingHeapProfile {
            head: SamplingHeapProfileNode;
        }
        interface StartTrackingHeapObjectsParameterType {
            trackAllocations?: boolean | undefined;
        }
        interface StopTrackingHeapObjectsParameterType {
            /**
             * If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped.
             */
            reportProgress?: boolean | undefined;
        }
        interface TakeHeapSnapshotParameterType {
            /**
             * If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.
             */
            reportProgress?: boolean | undefined;
        }
        interface GetObjectByHeapObjectIdParameterType {
            objectId: HeapSnapshotObjectId;
            /**
             * Symbolic group name that can be used to release multiple objects.
             */
            objectGroup?: string | undefined;
        }
        interface AddInspectedHeapObjectParameterType {
            /**
             * Heap snapshot object id to be accessible by means of $x command line API.
             */
            heapObjectId: HeapSnapshotObjectId;
        }
        interface GetHeapObjectIdParameterType {
            /**
             * Identifier of the object to get heap object id for.
             */
            objectId: Runtime.RemoteObjectId;
        }
        interface StartSamplingParameterType {
            /**
             * Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes.
             */
            samplingInterval?: number | undefined;
        }
        interface GetObjectByHeapObjectIdReturnType {
            /**
             * Evaluation result.
             */
            result: Runtime.RemoteObject;
        }
        interface GetHeapObjectIdReturnType {
            /**
             * Id of the heap snapshot object corresponding to the passed remote object id.
             */
            heapSnapshotObjectId: HeapSnapshotObjectId;
        }
        interface StopSamplingReturnType {
            /**
             * Recorded sampling heap profile.
             */
            profile: SamplingHeapProfile;
        }
        interface GetSamplingProfileReturnType {
            /**
             * Return the sampling profile being collected.
             */
            profile: SamplingHeapProfile;
        }
        interface AddHeapSnapshotChunkEventDataType {
            chunk: string;
        }
        interface ReportHeapSnapshotProgressEventDataType {
            done: number;
            total: number;
            finished?: boolean | undefined;
        }
        interface LastSeenObjectIdEventDataType {
            lastSeenObjectId: number;
            timestamp: number;
        }
        interface HeapStatsUpdateEventDataType {
            /**
             * An array of triplets. Each triplet describes a fragment. The first integer is the fragment index, the second integer is a total count of objects for the fragment, the third integer is a total size of the objects for the fragment.
             */
            statsUpdate: number[];
        }
    }
    namespace NodeTracing {
        interface TraceConfig {
            /**
             * Controls how the trace buffer stores data.
             */
            recordMode?: string | undefined;
            /**
             * Included category filters.
             */
            includedCategories: string[];
        }
        interface StartParameterType {
            traceConfig: TraceConfig;
        }
        interface GetCategoriesReturnType {
            /**
             * A list of supported tracing categories.
             */
            categories: string[];
        }
        interface DataCollectedEventDataType {
            value: Array<{}>;
        }
    }
    namespace NodeWorker {
        type WorkerID = string;
        /**
         * Unique identifier of attached debugging session.
         */
        type SessionID = string;
        interface WorkerInfo {
            workerId: WorkerID;
            type: string;
            title: string;
            url: string;
        }
        interface SendMessageToWorkerParameterType {
            message: string;
            /**
             * Identifier of the session.
             */
            sessionId: SessionID;
        }
        interface EnableParameterType {
            /**
             * Whether to new workers should be paused until the frontend sends `Runtime.runIfWaitingForDebugger`
             * message to run them.
             */
            waitForDebuggerOnStart: boolean;
        }
        interface DetachParameterType {
            sessionId: SessionID;
        }
        interface AttachedToWorkerEventDataType {
            /**
             * Identifier assigned to the session used to send/receive messages.
             */
            sessionId: SessionID;
            workerInfo: WorkerInfo;
            waitingForDebugger: boolean;
        }
        interface DetachedFromWorkerEventDataType {
            /**
             * Detached session identifier.
             */
            sessionId: SessionID;
        }
        interface ReceivedMessageFromWorkerEventDataType {
            /**
             * Identifier of a session which sends a message.
             */
            sessionId: SessionID;
            message: string;
        }
    }
    namespace NodeRuntime {
        interface NotifyWhenWaitingForDisconnectParameterType {
            enabled: boolean;
        }
    }

    /**
     * The `inspector.Session` is used for dispatching messages to the V8 inspector
     * back-end and receiving message responses and notifications.
     */
    class Session extends EventEmitter {
        /**
         * Create a new instance of the inspector.Session class.
         * The inspector session needs to be connected through `session.connect()` before the messages can be dispatched to the inspector backend.
         */
        constructor();

        /**
         * Connects a session to the inspector back-end.
         */
        connect(): void;

        /**
         * Connects a session to the inspector back-end.
         * An exception will be thrown if this API was not called on a Worker thread.
         * @since v12.11.0
         */
        connectToMainThread(): void;

        /**
         * Immediately close the session. All pending message callbacks will be called with an error.
         * `session.connect()` will need to be called to be able to send messages again.
         * Reconnected session will lose all inspector state, such as enabled agents or configured breakpoints.
         */
        disconnect(): void;

        /**
         * Posts a message to the inspector back-end. `callback` will be notified when
         * a response is received. `callback` is a function that accepts two optional
         * arguments: error and message-specific result.
         *
         * ```js
         * session.post('Runtime.evaluate', { expression: '2 + 2' },
         *              (error, { result }) => console.log(result));
         * // Output: { type: 'number', value: 4, description: '4' }
         * ```
         *
         * The latest version of the V8 inspector protocol is published on the
         * [Chrome DevTools Protocol Viewer](https://chromedevtools.github.io/devtools-protocol/v8/).
         *
         * Node.js inspector supports all the Chrome DevTools Protocol domains declared
         * by V8. Chrome DevTools Protocol domain provides an interface for interacting
         * with one of the runtime agents used to inspect the application state and listen
         * to the run-time events.
         */
        post(method: string, callback?: (err: Error | null, params?: object) => void): void;
        post(method: string, params?: object, callback?: (err: Error | null, params?: object) => void): void;
        /**
         * Returns supported domains.
         */
        post(method: 'Schema.getDomains', callback?: (err: Error | null, params: Schema.GetDomainsReturnType) => void): void;
        /**
         * Evaluates expression on global object.
         */
        post(method: 'Runtime.evaluate', params?: Runtime.EvaluateParameterType, callback?: (err: Error | null, params: Runtime.EvaluateReturnType) => void): void;
        post(method: 'Runtime.evaluate', callback?: (err: Error | null, params: Runtime.EvaluateReturnType) => void): void;
        /**
         * Add handler to promise with given promise object id.
         */
        post(method: 'Runtime.awaitPromise', params?: Runtime.AwaitPromiseParameterType, callback?: (err: Error | null, params: Runtime.AwaitPromiseReturnType) => void): void;
        post(method: 'Runtime.awaitPromise', callback?: (err: Error | null, params: Runtime.AwaitPromiseReturnType) => void): void;
        /**
         * Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
         */
        post(method: 'Runtime.callFunctionOn', params?: Runtime.CallFunctionOnParameterType, callback?: (err: Error | null, params: Runtime.CallFunctionOnReturnType) => void): void;
        post(method: 'Runtime.callFunctionOn', callback?: (err: Error | null, params: Runtime.CallFunctionOnReturnType) => void): void;
        /**
         * Returns properties of a given object. Object group of the result is inherited from the target object.
         */
        post(method: 'Runtime.getProperties', params?: Runtime.GetPropertiesParameterType, callback?: (err: Error | null, params: Runtime.GetPropertiesReturnType) => void): void;
        post(method: 'Runtime.getProperties', callback?: (err: Error | null, params: Runtime.GetPropertiesReturnType) => void): void;
        /**
         * Releases remote object with given id.
         */
        post(method: 'Runtime.releaseObject', params?: Runtime.ReleaseObjectParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Runtime.releaseObject', callback?: (err: Error | null) => void): void;
        /**
         * Releases all remote objects that belong to a given group.
         */
        post(method: 'Runtime.releaseObjectGroup', params?: Runtime.ReleaseObjectGroupParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Runtime.releaseObjectGroup', callback?: (err: Error | null) => void): void;
        /**
         * Tells inspected instance to run if it was waiting for debugger to attach.
         */
        post(method: 'Runtime.runIfWaitingForDebugger', callback?: (err: Error | null) => void): void;
        /**
         * Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
         */
        post(method: 'Runtime.enable', callback?: (err: Error | null) => void): void;
        /**
         * Disables reporting of execution contexts creation.
         */
        post(method: 'Runtime.disable', callback?: (err: Error | null) => void): void;
        /**
         * Discards collected exceptions and console API calls.
         */
        post(method: 'Runtime.discardConsoleEntries', callback?: (err: Error | null) => void): void;
        /**
         * @experimental
         */
        post(method: 'Runtime.setCustomObjectFormatterEnabled', params?: Runtime.SetCustomObjectFormatterEnabledParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Runtime.setCustomObjectFormatterEnabled', callback?: (err: Error | null) => void): void;
        /**
         * Compiles expression.
         */
        post(method: 'Runtime.compileScript', params?: Runtime.CompileScriptParameterType, callback?: (err: Error | null, params: Runtime.CompileScriptReturnType) => void): void;
        post(method: 'Runtime.compileScript', callback?: (err: Error | null, params: Runtime.CompileScriptReturnType) => void): void;
        /**
         * Runs script with given id in a given context.
         */
        post(method: 'Runtime.runScript', params?: Runtime.RunScriptParameterType, callback?: (err: Error | null, params: Runtime.RunScriptReturnType) => void): void;
        post(method: 'Runtime.runScript', callback?: (err: Error | null, params: Runtime.RunScriptReturnType) => void): void;
        post(method: 'Runtime.queryObjects', params?: Runtime.QueryObjectsParameterType, callback?: (err: Error | null, params: Runtime.QueryObjectsReturnType) => void): void;
        post(method: 'Runtime.queryObjects', callback?: (err: Error | null, params: Runtime.QueryObjectsReturnType) => void): void;
        /**
         * Returns all let, const and class variables from global scope.
         */
        post(
            method: 'Runtime.globalLexicalScopeNames',
            params?: Runtime.GlobalLexicalScopeNamesParameterType,
            callback?: (err: Error | null, params: Runtime.GlobalLexicalScopeNamesReturnType) => void
        ): void;
        post(method: 'Runtime.globalLexicalScopeNames', callback?: (err: Error | null, params: Runtime.GlobalLexicalScopeNamesReturnType) => void): void;
        /**
         * Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
         */
        post(method: 'Debugger.enable', callback?: (err: Error | null, params: Debugger.EnableReturnType) => void): void;
        /**
         * Disables debugger for given page.
         */
        post(method: 'Debugger.disable', callback?: (err: Error | null) => void): void;
        /**
         * Activates / deactivates all breakpoints on the page.
         */
        post(method: 'Debugger.setBreakpointsActive', params?: Debugger.SetBreakpointsActiveParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.setBreakpointsActive', callback?: (err: Error | null) => void): void;
        /**
         * Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
         */
        post(method: 'Debugger.setSkipAllPauses', params?: Debugger.SetSkipAllPausesParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.setSkipAllPauses', callback?: (err: Error | null) => void): void;
        /**
         * Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
         */
        post(method: 'Debugger.setBreakpointByUrl', params?: Debugger.SetBreakpointByUrlParameterType, callback?: (err: Error | null, params: Debugger.SetBreakpointByUrlReturnType) => void): void;
        post(method: 'Debugger.setBreakpointByUrl', callback?: (err: Error | null, params: Debugger.SetBreakpointByUrlReturnType) => void): void;
        /**
         * Sets JavaScript breakpoint at a given location.
         */
        post(method: 'Debugger.setBreakpoint', params?: Debugger.SetBreakpointParameterType, callback?: (err: Error | null, params: Debugger.SetBreakpointReturnType) => void): void;
        post(method: 'Debugger.setBreakpoint', callback?: (err: Error | null, params: Debugger.SetBreakpointReturnType) => void): void;
        /**
         * Removes JavaScript breakpoint.
         */
        post(method: 'Debugger.removeBreakpoint', params?: Debugger.RemoveBreakpointParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.removeBreakpoint', callback?: (err: Error | null) => void): void;
        /**
         * Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
         */
        post(
            method: 'Debugger.getPossibleBreakpoints',
            params?: Debugger.GetPossibleBreakpointsParameterType,
            callback?: (err: Error | null, params: Debugger.GetPossibleBreakpointsReturnType) => void
        ): void;
        post(method: 'Debugger.getPossibleBreakpoints', callback?: (err: Error | null, params: Debugger.GetPossibleBreakpointsReturnType) => void): void;
        /**
         * Continues execution until specific location is reached.
         */
        post(method: 'Debugger.continueToLocation', params?: Debugger.ContinueToLocationParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.continueToLocation', callback?: (err: Error | null) => void): void;
        /**
         * @experimental
         */
        post(method: 'Debugger.pauseOnAsyncCall', params?: Debugger.PauseOnAsyncCallParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.pauseOnAsyncCall', callback?: (err: Error | null) => void): void;
        /**
         * Steps over the statement.
         */
        post(method: 'Debugger.stepOver', callback?: (err: Error | null) => void): void;
        /**
         * Steps into the function call.
         */
        post(method: 'Debugger.stepInto', params?: Debugger.StepIntoParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.stepInto', callback?: (err: Error | null) => void): void;
        /**
         * Steps out of the function call.
         */
        post(method: 'Debugger.stepOut', callback?: (err: Error | null) => void): void;
        /**
         * Stops on the next JavaScript statement.
         */
        post(method: 'Debugger.pause', callback?: (err: Error | null) => void): void;
        /**
         * This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
         * @experimental
         */
        post(method: 'Debugger.scheduleStepIntoAsync', callback?: (err: Error | null) => void): void;
        /**
         * Resumes JavaScript execution.
         */
        post(method: 'Debugger.resume', callback?: (err: Error | null) => void): void;
        /**
         * Returns stack trace with given <code>stackTraceId</code>.
         * @experimental
         */
        post(method: 'Debugger.getStackTrace', params?: Debugger.GetStackTraceParameterType, callback?: (err: Error | null, params: Debugger.GetStackTraceReturnType) => void): void;
        post(method: 'Debugger.getStackTrace', callback?: (err: Error | null, params: Debugger.GetStackTraceReturnType) => void): void;
        /**
         * Searches for given string in script content.
         */
        post(method: 'Debugger.searchInContent', params?: Debugger.SearchInContentParameterType, callback?: (err: Error | null, params: Debugger.SearchInContentReturnType) => void): void;
        post(method: 'Debugger.searchInContent', callback?: (err: Error | null, params: Debugger.SearchInContentReturnType) => void): void;
        /**
         * Edits JavaScript source live.
         */
        post(method: 'Debugger.setScriptSource', params?: Debugger.SetScriptSourceParameterType, callback?: (err: Error | null, params: Debugger.SetScriptSourceReturnType) => void): void;
        post(method: 'Debugger.setScriptSource', callback?: (err: Error | null, params: Debugger.SetScriptSourceReturnType) => void): void;
        /**
         * Restarts particular call frame from the beginning.
         */
        post(method: 'Debugger.restartFrame', params?: Debugger.RestartFrameParameterType, callback?: (err: Error | null, params: Debugger.RestartFrameReturnType) => void): void;
        post(method: 'Debugger.restartFrame', callback?: (err: Error | null, params: Debugger.RestartFrameReturnType) => void): void;
        /**
         * Returns source for the script with given id.
         */
        post(method: 'Debugger.getScriptSource', params?: Debugger.GetScriptSourceParameterType, callback?: (err: Error | null, params: Debugger.GetScriptSourceReturnType) => void): void;
        post(method: 'Debugger.getScriptSource', callback?: (err: Error | null, params: Debugger.GetScriptSourceReturnType) => void): void;
        /**
         * Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
         */
        post(method: 'Debugger.setPauseOnExceptions', params?: Debugger.SetPauseOnExceptionsParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.setPauseOnExceptions', callback?: (err: Error | null) => void): void;
        /**
         * Evaluates expression on a given call frame.
         */
        post(method: 'Debugger.evaluateOnCallFrame', params?: Debugger.EvaluateOnCallFrameParameterType, callback?: (err: Error | null, params: Debugger.EvaluateOnCallFrameReturnType) => void): void;
        post(method: 'Debugger.evaluateOnCallFrame', callback?: (err: Error | null, params: Debugger.EvaluateOnCallFrameReturnType) => void): void;
        /**
         * Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
         */
        post(method: 'Debugger.setVariableValue', params?: Debugger.SetVariableValueParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.setVariableValue', callback?: (err: Error | null) => void): void;
        /**
         * Changes return value in top frame. Available only at return break position.
         * @experimental
         */
        post(method: 'Debugger.setReturnValue', params?: Debugger.SetReturnValueParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.setReturnValue', callback?: (err: Error | null) => void): void;
        /**
         * Enables or disables async call stacks tracking.
         */
        post(method: 'Debugger.setAsyncCallStackDepth', params?: Debugger.SetAsyncCallStackDepthParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.setAsyncCallStackDepth', callback?: (err: Error | null) => void): void;
        /**
         * Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
         * @experimental
         */
        post(method: 'Debugger.setBlackboxPatterns', params?: Debugger.SetBlackboxPatternsParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.setBlackboxPatterns', callback?: (err: Error | null) => void): void;
        /**
         * Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
         * @experimental
         */
        post(method: 'Debugger.setBlackboxedRanges', params?: Debugger.SetBlackboxedRangesParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.setBlackboxedRanges', callback?: (err: Error | null) => void): void;
        /**
         * Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
         */
        post(method: 'Console.enable', callback?: (err: Error | null) => void): void;
        /**
         * Disables console domain, prevents further console messages from being reported to the client.
         */
        post(method: 'Console.disable', callback?: (err: Error | null) => void): void;
        /**
         * Does nothing.
         */
        post(method: 'Console.clearMessages', callback?: (err: Error | null) => void): void;
        post(method: 'Profiler.enable', callback?: (err: Error | null) => void): void;
        post(method: 'Profiler.disable', callback?: (err: Error | null) => void): void;
        /**
         * Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
         */
        post(method: 'Profiler.setSamplingInterval', params?: Profiler.SetSamplingIntervalParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Profiler.setSamplingInterval', callback?: (err: Error | null) => void): void;
        post(method: 'Profiler.start', callback?: (err: Error | null) => void): void;
        post(method: 'Profiler.stop', callback?: (err: Error | null, params: Profiler.StopReturnType) => void): void;
        /**
         * Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
         */
        post(method: 'Profiler.startPreciseCoverage', params?: Profiler.StartPreciseCoverageParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Profiler.startPreciseCoverage', callback?: (err: Error | null) => void): void;
        /**
         * Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
         */
        post(method: 'Profiler.stopPreciseCoverage', callback?: (err: Error | null) => void): void;
        /**
         * Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
         */
        post(method: 'Profiler.takePreciseCoverage', callback?: (err: Error | null, params: Profiler.TakePreciseCoverageReturnType) => void): void;
        /**
         * Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
         */
        post(method: 'Profiler.getBestEffortCoverage', callback?: (err: Error | null, params: Profiler.GetBestEffortCoverageReturnType) => void): void;
        post(method: 'HeapProfiler.enable', callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.disable', callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.startTrackingHeapObjects', params?: HeapProfiler.StartTrackingHeapObjectsParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.startTrackingHeapObjects', callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.stopTrackingHeapObjects', params?: HeapProfiler.StopTrackingHeapObjectsParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.stopTrackingHeapObjects', callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.takeHeapSnapshot', params?: HeapProfiler.TakeHeapSnapshotParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.takeHeapSnapshot', callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.collectGarbage', callback?: (err: Error | null) => void): void;
        post(
            method: 'HeapProfiler.getObjectByHeapObjectId',
            params?: HeapProfiler.GetObjectByHeapObjectIdParameterType,
            callback?: (err: Error | null, params: HeapProfiler.GetObjectByHeapObjectIdReturnType) => void
        ): void;
        post(method: 'HeapProfiler.getObjectByHeapObjectId', callback?: (err: Error | null, params: HeapProfiler.GetObjectByHeapObjectIdReturnType) => void): void;
        /**
         * Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
         */
        post(method: 'HeapProfiler.addInspectedHeapObject', params?: HeapProfiler.AddInspectedHeapObjectParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.addInspectedHeapObject', callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.getHeapObjectId', params?: HeapProfiler.GetHeapObjectIdParameterType, callback?: (err: Error | null, params: HeapProfiler.GetHeapObjectIdReturnType) => void): void;
        post(method: 'HeapProfiler.getHeapObjectId', callback?: (err: Error | null, params: HeapProfiler.GetHeapObjectIdReturnType) => void): void;
        post(method: 'HeapProfiler.startSampling', params?: HeapProfiler.StartSamplingParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.startSampling', callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.stopSampling', callback?: (err: Error | null, params: HeapProfiler.StopSamplingReturnType) => void): void;
        post(method: 'HeapProfiler.getSamplingProfile', callback?: (err: Error | null, params: HeapProfiler.GetSamplingProfileReturnType) => void): void;
        /**
         * Gets supported tracing categories.
         */
        post(method: 'NodeTracing.getCategories', callback?: (err: Error | null, params: NodeTracing.GetCategoriesReturnType) => void): void;
        /**
         * Start trace events collection.
         */
        post(method: 'NodeTracing.start', params?: NodeTracing.StartParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'NodeTracing.start', callback?: (err: Error | null) => void): void;
        /**
         * Stop trace events collection. Remaining collected events will be sent as a sequence of
         * dataCollected events followed by tracingComplete event.
         */
        post(method: 'NodeTracing.stop', callback?: (err: Error | null) => void): void;
        /**
         * Sends protocol message over session with given id.
         */
        post(method: 'NodeWorker.sendMessageToWorker', params?: NodeWorker.SendMessageToWorkerParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'NodeWorker.sendMessageToWorker', callback?: (err: Error | null) => void): void;
        /**
         * Instructs the inspector to attach to running workers. Will also attach to new workers
         * as they start
         */
        post(method: 'NodeWorker.enable', params?: NodeWorker.EnableParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'NodeWorker.enable', callback?: (err: Error | null) => void): void;
        /**
         * Detaches from all running workers and disables attaching to new workers as they are started.
         */
        post(method: 'NodeWorker.disable', callback?: (err: Error | null) => void): void;
        /**
         * Detached from the worker with given sessionId.
         */
        post(method: 'NodeWorker.detach', params?: NodeWorker.DetachParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'NodeWorker.detach', callback?: (err: Error | null) => void): void;
        /**
         * Enable the NodeRuntime events except by `NodeRuntime.waitingForDisconnect`.
         */
        post(method: 'NodeRuntime.enable', callback?: (err: Error | null) => void): void;
        /**
         * Disable NodeRuntime events
         */
        post(method: 'NodeRuntime.disable', callback?: (err: Error | null) => void): void;
        /**
         * Enable the `NodeRuntime.waitingForDisconnect`.
         */
        post(method: 'NodeRuntime.notifyWhenWaitingForDisconnect', params?: NodeRuntime.NotifyWhenWaitingForDisconnectParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'NodeRuntime.notifyWhenWaitingForDisconnect', callback?: (err: Error | null) => void): void;

        addListener(event: string, listener: (...args: any[]) => void): this;
        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        addListener(event: 'inspectorNotification', listener: (message: InspectorNotification<object>) => void): this;
        /**
         * Issued when new execution context is created.
         */
        addListener(event: 'Runtime.executionContextCreated', listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;
        /**
         * Issued when execution context is destroyed.
         */
        addListener(event: 'Runtime.executionContextDestroyed', listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;
        /**
         * Issued when all executionContexts were cleared in browser
         */
        addListener(event: 'Runtime.executionContextsCleared', listener: () => void): this;
        /**
         * Issued when exception was thrown and unhandled.
         */
        addListener(event: 'Runtime.exceptionThrown', listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;
        /**
         * Issued when unhandled exception was revoked.
         */
        addListener(event: 'Runtime.exceptionRevoked', listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;
        /**
         * Issued when console API was called.
         */
        addListener(event: 'Runtime.consoleAPICalled', listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;
        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        addListener(event: 'Runtime.inspectRequested', listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;
        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        addListener(event: 'Debugger.scriptParsed', listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;
        /**
         * Fired when virtual machine fails to parse the script.
         */
        addListener(event: 'Debugger.scriptFailedToParse', listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;
        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        addListener(event: 'Debugger.breakpointResolved', listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        addListener(event: 'Debugger.paused', listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine resumed execution.
         */
        addListener(event: 'Debugger.resumed', listener: () => void): this;
        /**
         * Issued when new console message is added.
         */
        addListener(event: 'Console.messageAdded', listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;
        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        addListener(event: 'Profiler.consoleProfileStarted', listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;
        addListener(event: 'Profiler.consoleProfileFinished', listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        addListener(event: 'HeapProfiler.addHeapSnapshotChunk', listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        addListener(event: 'HeapProfiler.resetProfiles', listener: () => void): this;
        addListener(event: 'HeapProfiler.reportHeapSnapshotProgress', listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        addListener(event: 'HeapProfiler.lastSeenObjectId', listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        addListener(event: 'HeapProfiler.heapStatsUpdate', listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;
        /**
         * Contains an bucket of collected trace events.
         */
        addListener(event: 'NodeTracing.dataCollected', listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;
        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        addListener(event: 'NodeTracing.tracingComplete', listener: () => void): this;
        /**
         * Issued when attached to a worker.
         */
        addListener(event: 'NodeWorker.attachedToWorker', listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;
        /**
         * Issued when detached from the worker.
         */
        addListener(event: 'NodeWorker.detachedFromWorker', listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;
        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        addListener(event: 'NodeWorker.receivedMessageFromWorker', listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;
        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        addListener(event: 'NodeRuntime.waitingForDisconnect', listener: () => void): this;
        /**
         * This event is fired when the runtime is waiting for the debugger. For
         * example, when inspector.waitingForDebugger is called
         */
        addListener(event: 'NodeRuntime.waitingForDebugger', listener: () => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: 'inspectorNotification', message: InspectorNotification<object>): boolean;
        emit(event: 'Runtime.executionContextCreated', message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>): boolean;
        emit(event: 'Runtime.executionContextDestroyed', message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>): boolean;
        emit(event: 'Runtime.executionContextsCleared'): boolean;
        emit(event: 'Runtime.exceptionThrown', message: InspectorNotification<Runtime.ExceptionThrownEventDataType>): boolean;
        emit(event: 'Runtime.exceptionRevoked', message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>): boolean;
        emit(event: 'Runtime.consoleAPICalled', message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>): boolean;
        emit(event: 'Runtime.inspectRequested', message: InspectorNotification<Runtime.InspectRequestedEventDataType>): boolean;
        emit(event: 'Debugger.scriptParsed', message: InspectorNotification<Debugger.ScriptParsedEventDataType>): boolean;
        emit(event: 'Debugger.scriptFailedToParse', message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>): boolean;
        emit(event: 'Debugger.breakpointResolved', message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>): boolean;
        emit(event: 'Debugger.paused', message: InspectorNotification<Debugger.PausedEventDataType>): boolean;
        emit(event: 'Debugger.resumed'): boolean;
        emit(event: 'Console.messageAdded', message: InspectorNotification<Console.MessageAddedEventDataType>): boolean;
        emit(event: 'Profiler.consoleProfileStarted', message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>): boolean;
        emit(event: 'Profiler.consoleProfileFinished', message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>): boolean;
        emit(event: 'HeapProfiler.addHeapSnapshotChunk', message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>): boolean;
        emit(event: 'HeapProfiler.resetProfiles'): boolean;
        emit(event: 'HeapProfiler.reportHeapSnapshotProgress', message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>): boolean;
        emit(event: 'HeapProfiler.lastSeenObjectId', message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>): boolean;
        emit(event: 'HeapProfiler.heapStatsUpdate', message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>): boolean;
        emit(event: 'NodeTracing.dataCollected', message: InspectorNotification<NodeTracing.DataCollectedEventDataType>): boolean;
        emit(event: 'NodeTracing.tracingComplete'): boolean;
        emit(event: 'NodeWorker.attachedToWorker', message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>): boolean;
        emit(event: 'NodeWorker.detachedFromWorker', message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>): boolean;
        emit(event: 'NodeWorker.receivedMessageFromWorker', message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>): boolean;
        emit(event: 'NodeRuntime.waitingForDisconnect'): boolean;
        emit(event: 'NodeRuntime.waitingForDebugger'): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        on(event: 'inspectorNotification', listener: (message: InspectorNotification<object>) => void): this;
        /**
         * Issued when new execution context is created.
         */
        on(event: 'Runtime.executionContextCreated', listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;
        /**
         * Issued when execution context is destroyed.
         */
        on(event: 'Runtime.executionContextDestroyed', listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;
        /**
         * Issued when all executionContexts were cleared in browser
         */
        on(event: 'Runtime.executionContextsCleared', listener: () => void): this;
        /**
         * Issued when exception was thrown and unhandled.
         */
        on(event: 'Runtime.exceptionThrown', listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;
        /**
         * Issued when unhandled exception was revoked.
         */
        on(event: 'Runtime.exceptionRevoked', listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;
        /**
         * Issued when console API was called.
         */
        on(event: 'Runtime.consoleAPICalled', listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;
        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        on(event: 'Runtime.inspectRequested', listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;
        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        on(event: 'Debugger.scriptParsed', listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;
        /**
         * Fired when virtual machine fails to parse the script.
         */
        on(event: 'Debugger.scriptFailedToParse', listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;
        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        on(event: 'Debugger.breakpointResolved', listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        on(event: 'Debugger.paused', listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine resumed execution.
         */
        on(event: 'Debugger.resumed', listener: () => void): this;
        /**
         * Issued when new console message is added.
         */
        on(event: 'Console.messageAdded', listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;
        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        on(event: 'Profiler.consoleProfileStarted', listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;
        on(event: 'Profiler.consoleProfileFinished', listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        on(event: 'HeapProfiler.addHeapSnapshotChunk', listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        on(event: 'HeapProfiler.resetProfiles', listener: () => void): this;
        on(event: 'HeapProfiler.reportHeapSnapshotProgress', listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        on(event: 'HeapProfiler.lastSeenObjectId', listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        on(event: 'HeapProfiler.heapStatsUpdate', listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;
        /**
         * Contains an bucket of collected trace events.
         */
        on(event: 'NodeTracing.dataCollected', listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;
        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        on(event: 'NodeTracing.tracingComplete', listener: () => void): this;
        /**
         * Issued when attached to a worker.
         */
        on(event: 'NodeWorker.attachedToWorker', listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;
        /**
         * Issued when detached from the worker.
         */
        on(event: 'NodeWorker.detachedFromWorker', listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;
        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        on(event: 'NodeWorker.receivedMessageFromWorker', listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;
        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        on(event: 'NodeRuntime.waitingForDisconnect', listener: () => void): this;
        /**
         * This event is fired when the runtime is waiting for the debugger. For
         * example, when inspector.waitingForDebugger is called
         */
        on(event: 'NodeRuntime.waitingForDebugger', listener: () => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        once(event: 'inspectorNotification', listener: (message: InspectorNotification<object>) => void): this;
        /**
         * Issued when new execution context is created.
         */
        once(event: 'Runtime.executionContextCreated', listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;
        /**
         * Issued when execution context is destroyed.
         */
        once(event: 'Runtime.executionContextDestroyed', listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;
        /**
         * Issued when all executionContexts were cleared in browser
         */
        once(event: 'Runtime.executionContextsCleared', listener: () => void): this;
        /**
         * Issued when exception was thrown and unhandled.
         */
        once(event: 'Runtime.exceptionThrown', listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;
        /**
         * Issued when unhandled exception was revoked.
         */
        once(event: 'Runtime.exceptionRevoked', listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;
        /**
         * Issued when console API was called.
         */
        once(event: 'Runtime.consoleAPICalled', listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;
        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        once(event: 'Runtime.inspectRequested', listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;
        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        once(event: 'Debugger.scriptParsed', listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;
        /**
         * Fired when virtual machine fails to parse the script.
         */
        once(event: 'Debugger.scriptFailedToParse', listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;
        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        once(event: 'Debugger.breakpointResolved', listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        once(event: 'Debugger.paused', listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine resumed execution.
         */
        once(event: 'Debugger.resumed', listener: () => void): this;
        /**
         * Issued when new console message is added.
         */
        once(event: 'Console.messageAdded', listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;
        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        once(event: 'Profiler.consoleProfileStarted', listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;
        once(event: 'Profiler.consoleProfileFinished', listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        once(event: 'HeapProfiler.addHeapSnapshotChunk', listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        once(event: 'HeapProfiler.resetProfiles', listener: () => void): this;
        once(event: 'HeapProfiler.reportHeapSnapshotProgress', listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        once(event: 'HeapProfiler.lastSeenObjectId', listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        once(event: 'HeapProfiler.heapStatsUpdate', listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;
        /**
         * Contains an bucket of collected trace events.
         */
        once(event: 'NodeTracing.dataCollected', listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;
        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        once(event: 'NodeTracing.tracingComplete', listener: () => void): this;
        /**
         * Issued when attached to a worker.
         */
        once(event: 'NodeWorker.attachedToWorker', listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;
        /**
         * Issued when detached from the worker.
         */
        once(event: 'NodeWorker.detachedFromWorker', listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;
        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        once(event: 'NodeWorker.receivedMessageFromWorker', listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;
        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        once(event: 'NodeRuntime.waitingForDisconnect', listener: () => void): this;
        /**
         * This event is fired when the runtime is waiting for the debugger. For
         * example, when inspector.waitingForDebugger is called
         */
        once(event: 'NodeRuntime.waitingForDebugger', listener: () => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        prependListener(event: 'inspectorNotification', listener: (message: InspectorNotification<object>) => void): this;
        /**
         * Issued when new execution context is created.
         */
        prependListener(event: 'Runtime.executionContextCreated', listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;
        /**
         * Issued when execution context is destroyed.
         */
        prependListener(event: 'Runtime.executionContextDestroyed', listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;
        /**
         * Issued when all executionContexts were cleared in browser
         */
        prependListener(event: 'Runtime.executionContextsCleared', listener: () => void): this;
        /**
         * Issued when exception was thrown and unhandled.
         */
        prependListener(event: 'Runtime.exceptionThrown', listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;
        /**
         * Issued when unhandled exception was revoked.
         */
        prependListener(event: 'Runtime.exceptionRevoked', listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;
        /**
         * Issued when console API was called.
         */
        prependListener(event: 'Runtime.consoleAPICalled', listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;
        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        prependListener(event: 'Runtime.inspectRequested', listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;
        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        prependListener(event: 'Debugger.scriptParsed', listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;
        /**
         * Fired when virtual machine fails to parse the script.
         */
        prependListener(event: 'Debugger.scriptFailedToParse', listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;
        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        prependListener(event: 'Debugger.breakpointResolved', listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        prependListener(event: 'Debugger.paused', listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine resumed execution.
         */
        prependListener(event: 'Debugger.resumed', listener: () => void): this;
        /**
         * Issued when new console message is added.
         */
        prependListener(event: 'Console.messageAdded', listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;
        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        prependListener(event: 'Profiler.consoleProfileStarted', listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;
        prependListener(event: 'Profiler.consoleProfileFinished', listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        prependListener(event: 'HeapProfiler.addHeapSnapshotChunk', listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        prependListener(event: 'HeapProfiler.resetProfiles', listener: () => void): this;
        prependListener(event: 'HeapProfiler.reportHeapSnapshotProgress', listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        prependListener(event: 'HeapProfiler.lastSeenObjectId', listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        prependListener(event: 'HeapProfiler.heapStatsUpdate', listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;
        /**
         * Contains an bucket of collected trace events.
         */
        prependListener(event: 'NodeTracing.dataCollected', listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;
        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        prependListener(event: 'NodeTracing.tracingComplete', listener: () => void): this;
        /**
         * Issued when attached to a worker.
         */
        prependListener(event: 'NodeWorker.attachedToWorker', listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;
        /**
         * Issued when detached from the worker.
         */
        prependListener(event: 'NodeWorker.detachedFromWorker', listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;
        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        prependListener(event: 'NodeWorker.receivedMessageFromWorker', listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;
        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        prependListener(event: 'NodeRuntime.waitingForDisconnect', listener: () => void): this;
        /**
         * This event is fired when the runtime is waiting for the debugger. For
         * example, when inspector.waitingForDebugger is called
         */
        prependListener(event: 'NodeRuntime.waitingForDebugger', listener: () => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        prependOnceListener(event: 'inspectorNotification', listener: (message: InspectorNotification<object>) => void): this;
        /**
         * Issued when new execution context is created.
         */
        prependOnceListener(event: 'Runtime.executionContextCreated', listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;
        /**
         * Issued when execution context is destroyed.
         */
        prependOnceListener(event: 'Runtime.executionContextDestroyed', listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;
        /**
         * Issued when all executionContexts were cleared in browser
         */
        prependOnceListener(event: 'Runtime.executionContextsCleared', listener: () => void): this;
        /**
         * Issued when exception was thrown and unhandled.
         */
        prependOnceListener(event: 'Runtime.exceptionThrown', listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;
        /**
         * Issued when unhandled exception was revoked.
         */
        prependOnceListener(event: 'Runtime.exceptionRevoked', listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;
        /**
         * Issued when console API was called.
         */
        prependOnceListener(event: 'Runtime.consoleAPICalled', listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;
        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        prependOnceListener(event: 'Runtime.inspectRequested', listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;
        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        prependOnceListener(event: 'Debugger.scriptParsed', listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;
        /**
         * Fired when virtual machine fails to parse the script.
         */
        prependOnceListener(event: 'Debugger.scriptFailedToParse', listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;
        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        prependOnceListener(event: 'Debugger.breakpointResolved', listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        prependOnceListener(event: 'Debugger.paused', listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine resumed execution.
         */
        prependOnceListener(event: 'Debugger.resumed', listener: () => void): this;
        /**
         * Issued when new console message is added.
         */
        prependOnceListener(event: 'Console.messageAdded', listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;
        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        prependOnceListener(event: 'Profiler.consoleProfileStarted', listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;
        prependOnceListener(event: 'Profiler.consoleProfileFinished', listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        prependOnceListener(event: 'HeapProfiler.addHeapSnapshotChunk', listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        prependOnceListener(event: 'HeapProfiler.resetProfiles', listener: () => void): this;
        prependOnceListener(event: 'HeapProfiler.reportHeapSnapshotProgress', listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        prependOnceListener(event: 'HeapProfiler.lastSeenObjectId', listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        prependOnceListener(event: 'HeapProfiler.heapStatsUpdate', listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;
        /**
         * Contains an bucket of collected trace events.
         */
        prependOnceListener(event: 'NodeTracing.dataCollected', listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;
        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        prependOnceListener(event: 'NodeTracing.tracingComplete', listener: () => void): this;
        /**
         * Issued when attached to a worker.
         */
        prependOnceListener(event: 'NodeWorker.attachedToWorker', listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;
        /**
         * Issued when detached from the worker.
         */
        prependOnceListener(event: 'NodeWorker.detachedFromWorker', listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;
        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        prependOnceListener(event: 'NodeWorker.receivedMessageFromWorker', listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;
        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        prependOnceListener(event: 'NodeRuntime.waitingForDisconnect', listener: () => void): this;
        /**
         * This event is fired when the runtime is waiting for the debugger. For
         * example, when inspector.waitingForDebugger is called
         */
        prependOnceListener(event: 'NodeRuntime.waitingForDebugger', listener: () => void): this;
    }

    /**
     * Activate inspector on host and port. Equivalent to `node --inspect=[[host:]port]`, but can be done programmatically after node has
     * started.
     *
     * If wait is `true`, will block until a client has connected to the inspect port
     * and flow control has been passed to the debugger client.
     *
     * See the [security warning](https://nodejs.org/docs/latest-v22.x/api/cli.html#warning-binding-inspector-to-a-public-ipport-combination-is-insecure)
     * regarding the `host` parameter usage.
     * @param port Port to listen on for inspector connections. Defaults to what was specified on the CLI.
     * @param host Host to listen on for inspector connections. Defaults to what was specified on the CLI.
     * @param wait Block until a client has connected. Defaults to what was specified on the CLI.
     * @returns Disposable that calls `inspector.close()`.
     */
    function open(port?: number, host?: string, wait?: boolean): Disposable;

    /**
     * Deactivate the inspector. Blocks until there are no active connections.
     */
    function close(): void;

    /**
     * Return the URL of the active inspector, or `undefined` if there is none.
     *
     * ```console
     * $ node --inspect -p 'inspector.url()'
     * Debugger listening on ws://127.0.0.1:9229/166e272e-7a30-4d09-97ce-f1c012b43c34
     * For help, see: https://nodejs.org/en/docs/inspector
     * ws://127.0.0.1:9229/166e272e-7a30-4d09-97ce-f1c012b43c34
     *
     * $ node --inspect=localhost:3000 -p 'inspector.url()'
     * Debugger listening on ws://localhost:3000/51cf8d0e-3c36-4c59-8efd-54519839e56a
     * For help, see: https://nodejs.org/en/docs/inspector
     * ws://localhost:3000/51cf8d0e-3c36-4c59-8efd-54519839e56a
     *
     * $ node -p 'inspector.url()'
     * undefined
     * ```
     */
    function url(): string | undefined;

    /**
     * Blocks until a client (existing or connected later) has sent `Runtime.runIfWaitingForDebugger` command.
     *
     * An exception will be thrown if there is no active inspector.
     * @since v12.7.0
     */
    function waitForDebugger(): void;

    // These methods are exposed by the V8 inspector console API (inspector/v8-console.h).
    // The method signatures differ from those of the Node.js console, and are deliberately
    // typed permissively.
    interface InspectorConsole {
        debug(...data: any[]): void;
        error(...data: any[]): void;
        info(...data: any[]): void;
        log(...data: any[]): void;
        warn(...data: any[]): void;
        dir(...data: any[]): void;
        dirxml(...data: any[]): void;
        table(...data: any[]): void;
        trace(...data: any[]): void;
        group(...data: any[]): void;
        groupCollapsed(...data: any[]): void;
        groupEnd(...data: any[]): void;
        clear(...data: any[]): void;
        count(label?: any): void;
        countReset(label?: any): void;
        assert(value?: any, ...data: any[]): void;
        profile(label?: any): void;
        profileEnd(label?: any): void;
        time(label?: any): void;
        timeLog(label?: any): void;
        timeStamp(label?: any): void;
    }

    /**
     * An object to send messages to the remote inspector console.
     * @since v11.0.0
     */
    const console: InspectorConsole;
}

/**
 * The `node:inspector` module provides an API for interacting with the V8
 * inspector.
 */
declare module 'node:inspector' {
    export * from 'inspector';
}

/**
 * The `node:inspector/promises` module provides an API for interacting with the V8
 * inspector.
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/inspector/promises.js)
 * @since v19.0.0
 */
declare module 'inspector/promises' {
    import EventEmitter = require('node:events');
    import {
        open,
        close,
        url,
        waitForDebugger,
        console,
        InspectorNotification,
        Schema,
        Runtime,
        Debugger,
        Console,
        Profiler,
        HeapProfiler,
        NodeTracing,
        NodeWorker,
        NodeRuntime,
    } from 'inspector';

    /**
     * The `inspector.Session` is used for dispatching messages to the V8 inspector
     * back-end and receiving message responses and notifications.
     * @since v19.0.0
     */
    class Session extends EventEmitter {
        /**
         * Create a new instance of the `inspector.Session` class.
         * The inspector session needs to be connected through `session.connect()` before the messages can be dispatched to the inspector backend.
         */
        constructor();

        /**
         * Connects a session to the inspector back-end.
         */
        connect(): void;

        /**
         * Connects a session to the inspector back-end.
         * An exception will be thrown if this API was not called on a Worker thread.
         */
        connectToMainThread(): void;

        /**
         * Immediately close the session. All pending message callbacks will be called with an error.
         * `session.connect()` will need to be called to be able to send messages again.
         * Reconnected session will lose all inspector state, such as enabled agents or configured breakpoints.
         */
        disconnect(): void;

        /**
         * Posts a message to the inspector back-end.
         *
         * ```js
         * import { Session } from 'node:inspector/promises';
         * try {
         *   const session = new Session();
         *   session.connect();
         *   const result = await session.post('Runtime.evaluate', { expression: '2 + 2' });
         *   console.log(result);
         * } catch (error) {
         *   console.error(error);
         * }
         * // Output: { result: { type: 'number', value: 4, description: '4' } }
         * ```
         *
         * The latest version of the V8 inspector protocol is published on the
         * [Chrome DevTools Protocol Viewer](https://chromedevtools.github.io/devtools-protocol/v8/).
         *
         * Node.js inspector supports all the Chrome DevTools Protocol domains declared
         * by V8. Chrome DevTools Protocol domain provides an interface for interacting
         * with one of the runtime agents used to inspect the application state and listen
         * to the run-time events.
         */
        post(method: string, params?: object): Promise<void>;
        /**
         * Returns supported domains.
         */
        post(method: 'Schema.getDomains'): Promise<Schema.GetDomainsReturnType>;
        /**
         * Evaluates expression on global object.
         */
        post(method: 'Runtime.evaluate', params?: Runtime.EvaluateParameterType): Promise<Runtime.EvaluateReturnType>;
        /**
         * Add handler to promise with given promise object id.
         */
        post(method: 'Runtime.awaitPromise', params?: Runtime.AwaitPromiseParameterType): Promise<Runtime.AwaitPromiseReturnType>;
        /**
         * Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
         */
        post(method: 'Runtime.callFunctionOn', params?: Runtime.CallFunctionOnParameterType): Promise<Runtime.CallFunctionOnReturnType>;
        /**
         * Returns properties of a given object. Object group of the result is inherited from the target object.
         */
        post(method: 'Runtime.getProperties', params?: Runtime.GetPropertiesParameterType): Promise<Runtime.GetPropertiesReturnType>;
        /**
         * Releases remote object with given id.
         */
        post(method: 'Runtime.releaseObject', params?: Runtime.ReleaseObjectParameterType): Promise<void>;
        /**
         * Releases all remote objects that belong to a given group.
         */
        post(method: 'Runtime.releaseObjectGroup', params?: Runtime.ReleaseObjectGroupParameterType): Promise<void>;
        /**
         * Tells inspected instance to run if it was waiting for debugger to attach.
         */
        post(method: 'Runtime.runIfWaitingForDebugger'): Promise<void>;
        /**
         * Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
         */
        post(method: 'Runtime.enable'): Promise<void>;
        /**
         * Disables reporting of execution contexts creation.
         */
        post(method: 'Runtime.disable'): Promise<void>;
        /**
         * Discards collected exceptions and console API calls.
         */
        post(method: 'Runtime.discardConsoleEntries'): Promise<void>;
        /**
         * @experimental
         */
        post(method: 'Runtime.setCustomObjectFormatterEnabled', params?: Runtime.SetCustomObjectFormatterEnabledParameterType): Promise<void>;
        /**
         * Compiles expression.
         */
        post(method: 'Runtime.compileScript', params?: Runtime.CompileScriptParameterType): Promise<Runtime.CompileScriptReturnType>;
        /**
         * Runs script with given id in a given context.
         */
        post(method: 'Runtime.runScript', params?: Runtime.RunScriptParameterType): Promise<Runtime.RunScriptReturnType>;
        post(method: 'Runtime.queryObjects', params?: Runtime.QueryObjectsParameterType): Promise<Runtime.QueryObjectsReturnType>;
        /**
         * Returns all let, const and class variables from global scope.
         */
        post(method: 'Runtime.globalLexicalScopeNames', params?: Runtime.GlobalLexicalScopeNamesParameterType): Promise<Runtime.GlobalLexicalScopeNamesReturnType>;
        /**
         * Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
         */
        post(method: 'Debugger.enable'): Promise<Debugger.EnableReturnType>;
        /**
         * Disables debugger for given page.
         */
        post(method: 'Debugger.disable'): Promise<void>;
        /**
         * Activates / deactivates all breakpoints on the page.
         */
        post(method: 'Debugger.setBreakpointsActive', params?: Debugger.SetBreakpointsActiveParameterType): Promise<void>;
        /**
         * Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
         */
        post(method: 'Debugger.setSkipAllPauses', params?: Debugger.SetSkipAllPausesParameterType): Promise<void>;
        /**
         * Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
         */
        post(method: 'Debugger.setBreakpointByUrl', params?: Debugger.SetBreakpointByUrlParameterType): Promise<Debugger.SetBreakpointByUrlReturnType>;
        /**
         * Sets JavaScript breakpoint at a given location.
         */
        post(method: 'Debugger.setBreakpoint', params?: Debugger.SetBreakpointParameterType): Promise<Debugger.SetBreakpointReturnType>;
        /**
         * Removes JavaScript breakpoint.
         */
        post(method: 'Debugger.removeBreakpoint', params?: Debugger.RemoveBreakpointParameterType): Promise<void>;
        /**
         * Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
         */
        post(method: 'Debugger.getPossibleBreakpoints', params?: Debugger.GetPossibleBreakpointsParameterType): Promise<Debugger.GetPossibleBreakpointsReturnType>;
        /**
         * Continues execution until specific location is reached.
         */
        post(method: 'Debugger.continueToLocation', params?: Debugger.ContinueToLocationParameterType): Promise<void>;
        /**
         * @experimental
         */
        post(method: 'Debugger.pauseOnAsyncCall', params?: Debugger.PauseOnAsyncCallParameterType): Promise<void>;
        /**
         * Steps over the statement.
         */
        post(method: 'Debugger.stepOver'): Promise<void>;
        /**
         * Steps into the function call.
         */
        post(method: 'Debugger.stepInto', params?: Debugger.StepIntoParameterType): Promise<void>;
        /**
         * Steps out of the function call.
         */
        post(method: 'Debugger.stepOut'): Promise<void>;
        /**
         * Stops on the next JavaScript statement.
         */
        post(method: 'Debugger.pause'): Promise<void>;
        /**
         * This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
         * @experimental
         */
        post(method: 'Debugger.scheduleStepIntoAsync'): Promise<void>;
        /**
         * Resumes JavaScript execution.
         */
        post(method: 'Debugger.resume'): Promise<void>;
        /**
         * Returns stack trace with given <code>stackTraceId</code>.
         * @experimental
         */
        post(method: 'Debugger.getStackTrace', params?: Debugger.GetStackTraceParameterType): Promise<Debugger.GetStackTraceReturnType>;
        /**
         * Searches for given string in script content.
         */
        post(method: 'Debugger.searchInContent', params?: Debugger.SearchInContentParameterType): Promise<Debugger.SearchInContentReturnType>;
        /**
         * Edits JavaScript source live.
         */
        post(method: 'Debugger.setScriptSource', params?: Debugger.SetScriptSourceParameterType): Promise<Debugger.SetScriptSourceReturnType>;
        /**
         * Restarts particular call frame from the beginning.
         */
        post(method: 'Debugger.restartFrame', params?: Debugger.RestartFrameParameterType): Promise<Debugger.RestartFrameReturnType>;
        /**
         * Returns source for the script with given id.
         */
        post(method: 'Debugger.getScriptSource', params?: Debugger.GetScriptSourceParameterType): Promise<Debugger.GetScriptSourceReturnType>;
        /**
         * Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
         */
        post(method: 'Debugger.setPauseOnExceptions', params?: Debugger.SetPauseOnExceptionsParameterType): Promise<void>;
        /**
         * Evaluates expression on a given call frame.
         */
        post(method: 'Debugger.evaluateOnCallFrame', params?: Debugger.EvaluateOnCallFrameParameterType): Promise<Debugger.EvaluateOnCallFrameReturnType>;
        /**
         * Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
         */
        post(method: 'Debugger.setVariableValue', params?: Debugger.SetVariableValueParameterType): Promise<void>;
        /**
         * Changes return value in top frame. Available only at return break position.
         * @experimental
         */
        post(method: 'Debugger.setReturnValue', params?: Debugger.SetReturnValueParameterType): Promise<void>;
        /**
         * Enables or disables async call stacks tracking.
         */
        post(method: 'Debugger.setAsyncCallStackDepth', params?: Debugger.SetAsyncCallStackDepthParameterType): Promise<void>;
        /**
         * Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
         * @experimental
         */
        post(method: 'Debugger.setBlackboxPatterns', params?: Debugger.SetBlackboxPatternsParameterType): Promise<void>;
        /**
         * Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
         * @experimental
         */
        post(method: 'Debugger.setBlackboxedRanges', params?: Debugger.SetBlackboxedRangesParameterType): Promise<void>;
        /**
         * Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
         */
        post(method: 'Console.enable'): Promise<void>;
        /**
         * Disables console domain, prevents further console messages from being reported to the client.
         */
        post(method: 'Console.disable'): Promise<void>;
        /**
         * Does nothing.
         */
        post(method: 'Console.clearMessages'): Promise<void>;
        post(method: 'Profiler.enable'): Promise<void>;
        post(method: 'Profiler.disable'): Promise<void>;
        /**
         * Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
         */
        post(method: 'Profiler.setSamplingInterval', params?: Profiler.SetSamplingIntervalParameterType): Promise<void>;
        post(method: 'Profiler.start'): Promise<void>;
        post(method: 'Profiler.stop'): Promise<Profiler.StopReturnType>;
        /**
         * Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
         */
        post(method: 'Profiler.startPreciseCoverage', params?: Profiler.StartPreciseCoverageParameterType): Promise<void>;
        /**
         * Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
         */
        post(method: 'Profiler.stopPreciseCoverage'): Promise<void>;
        /**
         * Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
         */
        post(method: 'Profiler.takePreciseCoverage'): Promise<Profiler.TakePreciseCoverageReturnType>;
        /**
         * Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
         */
        post(method: 'Profiler.getBestEffortCoverage'): Promise<Profiler.GetBestEffortCoverageReturnType>;
        post(method: 'HeapProfiler.enable'): Promise<void>;
        post(method: 'HeapProfiler.disable'): Promise<void>;
        post(method: 'HeapProfiler.startTrackingHeapObjects', params?: HeapProfiler.StartTrackingHeapObjectsParameterType): Promise<void>;
        post(method: 'HeapProfiler.stopTrackingHeapObjects', params?: HeapProfiler.StopTrackingHeapObjectsParameterType): Promise<void>;
        post(method: 'HeapProfiler.takeHeapSnapshot', params?: HeapProfiler.TakeHeapSnapshotParameterType): Promise<void>;
        post(method: 'HeapProfiler.collectGarbage'): Promise<void>;
        post(method: 'HeapProfiler.getObjectByHeapObjectId', params?: HeapProfiler.GetObjectByHeapObjectIdParameterType): Promise<HeapProfiler.GetObjectByHeapObjectIdReturnType>;
        /**
         * Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
         */
        post(method: 'HeapProfiler.addInspectedHeapObject', params?: HeapProfiler.AddInspectedHeapObjectParameterType): Promise<void>;
        post(method: 'HeapProfiler.getHeapObjectId', params?: HeapProfiler.GetHeapObjectIdParameterType): Promise<HeapProfiler.GetHeapObjectIdReturnType>;
        post(method: 'HeapProfiler.startSampling', params?: HeapProfiler.StartSamplingParameterType): Promise<void>;
        post(method: 'HeapProfiler.stopSampling'): Promise<HeapProfiler.StopSamplingReturnType>;
        post(method: 'HeapProfiler.getSamplingProfile'): Promise<HeapProfiler.GetSamplingProfileReturnType>;
        /**
         * Gets supported tracing categories.
         */
        post(method: 'NodeTracing.getCategories'): Promise<NodeTracing.GetCategoriesReturnType>;
        /**
         * Start trace events collection.
         */
        post(method: 'NodeTracing.start', params?: NodeTracing.StartParameterType): Promise<void>;
        /**
         * Stop trace events collection. Remaining collected events will be sent as a sequence of
         * dataCollected events followed by tracingComplete event.
         */
        post(method: 'NodeTracing.stop'): Promise<void>;
        /**
         * Sends protocol message over session with given id.
         */
        post(method: 'NodeWorker.sendMessageToWorker', params?: NodeWorker.SendMessageToWorkerParameterType): Promise<void>;
        /**
         * Instructs the inspector to attach to running workers. Will also attach to new workers
         * as they start
         */
        post(method: 'NodeWorker.enable', params?: NodeWorker.EnableParameterType): Promise<void>;
        /**
         * Detaches from all running workers and disables attaching to new workers as they are started.
         */
        post(method: 'NodeWorker.disable'): Promise<void>;
        /**
         * Detached from the worker with given sessionId.
         */
        post(method: 'NodeWorker.detach', params?: NodeWorker.DetachParameterType): Promise<void>;
        /**
         * Enable the NodeRuntime events except by `NodeRuntime.waitingForDisconnect`.
         */
        post(method: 'NodeRuntime.enable'): Promise<void>;
        /**
         * Disable NodeRuntime events
         */
        post(method: 'NodeRuntime.disable'): Promise<void>;
        /**
         * Enable the `NodeRuntime.waitingForDisconnect`.
         */
        post(method: 'NodeRuntime.notifyWhenWaitingForDisconnect', params?: NodeRuntime.NotifyWhenWaitingForDisconnectParameterType): Promise<void>;

        addListener(event: string, listener: (...args: any[]) => void): this;
        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        addListener(event: 'inspectorNotification', listener: (message: InspectorNotification<object>) => void): this;
        /**
         * Issued when new execution context is created.
         */
        addListener(event: 'Runtime.executionContextCreated', listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;
        /**
         * Issued when execution context is destroyed.
         */
        addListener(event: 'Runtime.executionContextDestroyed', listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;
        /**
         * Issued when all executionContexts were cleared in browser
         */
        addListener(event: 'Runtime.executionContextsCleared', listener: () => void): this;
        /**
         * Issued when exception was thrown and unhandled.
         */
        addListener(event: 'Runtime.exceptionThrown', listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;
        /**
         * Issued when unhandled exception was revoked.
         */
        addListener(event: 'Runtime.exceptionRevoked', listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;
        /**
         * Issued when console API was called.
         */
        addListener(event: 'Runtime.consoleAPICalled', listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;
        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        addListener(event: 'Runtime.inspectRequested', listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;
        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        addListener(event: 'Debugger.scriptParsed', listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;
        /**
         * Fired when virtual machine fails to parse the script.
         */
        addListener(event: 'Debugger.scriptFailedToParse', listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;
        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        addListener(event: 'Debugger.breakpointResolved', listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        addListener(event: 'Debugger.paused', listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine resumed execution.
         */
        addListener(event: 'Debugger.resumed', listener: () => void): this;
        /**
         * Issued when new console message is added.
         */
        addListener(event: 'Console.messageAdded', listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;
        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        addListener(event: 'Profiler.consoleProfileStarted', listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;
        addListener(event: 'Profiler.consoleProfileFinished', listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        addListener(event: 'HeapProfiler.addHeapSnapshotChunk', listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        addListener(event: 'HeapProfiler.resetProfiles', listener: () => void): this;
        addListener(event: 'HeapProfiler.reportHeapSnapshotProgress', listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        addListener(event: 'HeapProfiler.lastSeenObjectId', listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        addListener(event: 'HeapProfiler.heapStatsUpdate', listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;
        /**
         * Contains an bucket of collected trace events.
         */
        addListener(event: 'NodeTracing.dataCollected', listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;
        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        addListener(event: 'NodeTracing.tracingComplete', listener: () => void): this;
        /**
         * Issued when attached to a worker.
         */
        addListener(event: 'NodeWorker.attachedToWorker', listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;
        /**
         * Issued when detached from the worker.
         */
        addListener(event: 'NodeWorker.detachedFromWorker', listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;
        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        addListener(event: 'NodeWorker.receivedMessageFromWorker', listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;
        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        addListener(event: 'NodeRuntime.waitingForDisconnect', listener: () => void): this;
        /**
         * This event is fired when the runtime is waiting for the debugger. For
         * example, when inspector.waitingForDebugger is called
         */
        addListener(event: 'NodeRuntime.waitingForDebugger', listener: () => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: 'inspectorNotification', message: InspectorNotification<object>): boolean;
        emit(event: 'Runtime.executionContextCreated', message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>): boolean;
        emit(event: 'Runtime.executionContextDestroyed', message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>): boolean;
        emit(event: 'Runtime.executionContextsCleared'): boolean;
        emit(event: 'Runtime.exceptionThrown', message: InspectorNotification<Runtime.ExceptionThrownEventDataType>): boolean;
        emit(event: 'Runtime.exceptionRevoked', message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>): boolean;
        emit(event: 'Runtime.consoleAPICalled', message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>): boolean;
        emit(event: 'Runtime.inspectRequested', message: InspectorNotification<Runtime.InspectRequestedEventDataType>): boolean;
        emit(event: 'Debugger.scriptParsed', message: InspectorNotification<Debugger.ScriptParsedEventDataType>): boolean;
        emit(event: 'Debugger.scriptFailedToParse', message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>): boolean;
        emit(event: 'Debugger.breakpointResolved', message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>): boolean;
        emit(event: 'Debugger.paused', message: InspectorNotification<Debugger.PausedEventDataType>): boolean;
        emit(event: 'Debugger.resumed'): boolean;
        emit(event: 'Console.messageAdded', message: InspectorNotification<Console.MessageAddedEventDataType>): boolean;
        emit(event: 'Profiler.consoleProfileStarted', message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>): boolean;
        emit(event: 'Profiler.consoleProfileFinished', message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>): boolean;
        emit(event: 'HeapProfiler.addHeapSnapshotChunk', message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>): boolean;
        emit(event: 'HeapProfiler.resetProfiles'): boolean;
        emit(event: 'HeapProfiler.reportHeapSnapshotProgress', message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>): boolean;
        emit(event: 'HeapProfiler.lastSeenObjectId', message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>): boolean;
        emit(event: 'HeapProfiler.heapStatsUpdate', message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>): boolean;
        emit(event: 'NodeTracing.dataCollected', message: InspectorNotification<NodeTracing.DataCollectedEventDataType>): boolean;
        emit(event: 'NodeTracing.tracingComplete'): boolean;
        emit(event: 'NodeWorker.attachedToWorker', message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>): boolean;
        emit(event: 'NodeWorker.detachedFromWorker', message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>): boolean;
        emit(event: 'NodeWorker.receivedMessageFromWorker', message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>): boolean;
        emit(event: 'NodeRuntime.waitingForDisconnect'): boolean;
        emit(event: 'NodeRuntime.waitingForDebugger'): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        on(event: 'inspectorNotification', listener: (message: InspectorNotification<object>) => void): this;
        /**
         * Issued when new execution context is created.
         */
        on(event: 'Runtime.executionContextCreated', listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;
        /**
         * Issued when execution context is destroyed.
         */
        on(event: 'Runtime.executionContextDestroyed', listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;
        /**
         * Issued when all executionContexts were cleared in browser
         */
        on(event: 'Runtime.executionContextsCleared', listener: () => void): this;
        /**
         * Issued when exception was thrown and unhandled.
         */
        on(event: 'Runtime.exceptionThrown', listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;
        /**
         * Issued when unhandled exception was revoked.
         */
        on(event: 'Runtime.exceptionRevoked', listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;
        /**
         * Issued when console API was called.
         */
        on(event: 'Runtime.consoleAPICalled', listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;
        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        on(event: 'Runtime.inspectRequested', listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;
        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        on(event: 'Debugger.scriptParsed', listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;
        /**
         * Fired when virtual machine fails to parse the script.
         */
        on(event: 'Debugger.scriptFailedToParse', listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;
        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        on(event: 'Debugger.breakpointResolved', listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        on(event: 'Debugger.paused', listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine resumed execution.
         */
        on(event: 'Debugger.resumed', listener: () => void): this;
        /**
         * Issued when new console message is added.
         */
        on(event: 'Console.messageAdded', listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;
        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        on(event: 'Profiler.consoleProfileStarted', listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;
        on(event: 'Profiler.consoleProfileFinished', listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        on(event: 'HeapProfiler.addHeapSnapshotChunk', listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        on(event: 'HeapProfiler.resetProfiles', listener: () => void): this;
        on(event: 'HeapProfiler.reportHeapSnapshotProgress', listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        on(event: 'HeapProfiler.lastSeenObjectId', listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        on(event: 'HeapProfiler.heapStatsUpdate', listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;
        /**
         * Contains an bucket of collected trace events.
         */
        on(event: 'NodeTracing.dataCollected', listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;
        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        on(event: 'NodeTracing.tracingComplete', listener: () => void): this;
        /**
         * Issued when attached to a worker.
         */
        on(event: 'NodeWorker.attachedToWorker', listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;
        /**
         * Issued when detached from the worker.
         */
        on(event: 'NodeWorker.detachedFromWorker', listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;
        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        on(event: 'NodeWorker.receivedMessageFromWorker', listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;
        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        on(event: 'NodeRuntime.waitingForDisconnect', listener: () => void): this;
        /**
         * This event is fired when the runtime is waiting for the debugger. For
         * example, when inspector.waitingForDebugger is called
         */
        on(event: 'NodeRuntime.waitingForDebugger', listener: () => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        once(event: 'inspectorNotification', listener: (message: InspectorNotification<object>) => void): this;
        /**
         * Issued when new execution context is created.
         */
        once(event: 'Runtime.executionContextCreated', listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;
        /**
         * Issued when execution context is destroyed.
         */
        once(event: 'Runtime.executionContextDestroyed', listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;
        /**
         * Issued when all executionContexts were cleared in browser
         */
        once(event: 'Runtime.executionContextsCleared', listener: () => void): this;
        /**
         * Issued when exception was thrown and unhandled.
         */
        once(event: 'Runtime.exceptionThrown', listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;
        /**
         * Issued when unhandled exception was revoked.
         */
        once(event: 'Runtime.exceptionRevoked', listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;
        /**
         * Issued when console API was called.
         */
        once(event: 'Runtime.consoleAPICalled', listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;
        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        once(event: 'Runtime.inspectRequested', listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;
        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        once(event: 'Debugger.scriptParsed', listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;
        /**
         * Fired when virtual machine fails to parse the script.
         */
        once(event: 'Debugger.scriptFailedToParse', listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;
        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        once(event: 'Debugger.breakpointResolved', listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        once(event: 'Debugger.paused', listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine resumed execution.
         */
        once(event: 'Debugger.resumed', listener: () => void): this;
        /**
         * Issued when new console message is added.
         */
        once(event: 'Console.messageAdded', listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;
        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        once(event: 'Profiler.consoleProfileStarted', listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;
        once(event: 'Profiler.consoleProfileFinished', listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        once(event: 'HeapProfiler.addHeapSnapshotChunk', listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        once(event: 'HeapProfiler.resetProfiles', listener: () => void): this;
        once(event: 'HeapProfiler.reportHeapSnapshotProgress', listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        once(event: 'HeapProfiler.lastSeenObjectId', listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        once(event: 'HeapProfiler.heapStatsUpdate', listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;
        /**
         * Contains an bucket of collected trace events.
         */
        once(event: 'NodeTracing.dataCollected', listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;
        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        once(event: 'NodeTracing.tracingComplete', listener: () => void): this;
        /**
         * Issued when attached to a worker.
         */
        once(event: 'NodeWorker.attachedToWorker', listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;
        /**
         * Issued when detached from the worker.
         */
        once(event: 'NodeWorker.detachedFromWorker', listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;
        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        once(event: 'NodeWorker.receivedMessageFromWorker', listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;
        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        once(event: 'NodeRuntime.waitingForDisconnect', listener: () => void): this;
        /**
         * This event is fired when the runtime is waiting for the debugger. For
         * example, when inspector.waitingForDebugger is called
         */
        once(event: 'NodeRuntime.waitingForDebugger', listener: () => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        prependListener(event: 'inspectorNotification', listener: (message: InspectorNotification<object>) => void): this;
        /**
         * Issued when new execution context is created.
         */
        prependListener(event: 'Runtime.executionContextCreated', listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;
        /**
         * Issued when execution context is destroyed.
         */
        prependListener(event: 'Runtime.executionContextDestroyed', listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;
        /**
         * Issued when all executionContexts were cleared in browser
         */
        prependListener(event: 'Runtime.executionContextsCleared', listener: () => void): this;
        /**
         * Issued when exception was thrown and unhandled.
         */
        prependListener(event: 'Runtime.exceptionThrown', listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;
        /**
         * Issued when unhandled exception was revoked.
         */
        prependListener(event: 'Runtime.exceptionRevoked', listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;
        /**
         * Issued when console API was called.
         */
        prependListener(event: 'Runtime.consoleAPICalled', listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;
        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        prependListener(event: 'Runtime.inspectRequested', listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;
        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        prependListener(event: 'Debugger.scriptParsed', listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;
        /**
         * Fired when virtual machine fails to parse the script.
         */
        prependListener(event: 'Debugger.scriptFailedToParse', listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;
        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        prependListener(event: 'Debugger.breakpointResolved', listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        prependListener(event: 'Debugger.paused', listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine resumed execution.
         */
        prependListener(event: 'Debugger.resumed', listener: () => void): this;
        /**
         * Issued when new console message is added.
         */
        prependListener(event: 'Console.messageAdded', listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;
        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        prependListener(event: 'Profiler.consoleProfileStarted', listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;
        prependListener(event: 'Profiler.consoleProfileFinished', listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        prependListener(event: 'HeapProfiler.addHeapSnapshotChunk', listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        prependListener(event: 'HeapProfiler.resetProfiles', listener: () => void): this;
        prependListener(event: 'HeapProfiler.reportHeapSnapshotProgress', listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        prependListener(event: 'HeapProfiler.lastSeenObjectId', listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        prependListener(event: 'HeapProfiler.heapStatsUpdate', listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;
        /**
         * Contains an bucket of collected trace events.
         */
        prependListener(event: 'NodeTracing.dataCollected', listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;
        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        prependListener(event: 'NodeTracing.tracingComplete', listener: () => void): this;
        /**
         * Issued when attached to a worker.
         */
        prependListener(event: 'NodeWorker.attachedToWorker', listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;
        /**
         * Issued when detached from the worker.
         */
        prependListener(event: 'NodeWorker.detachedFromWorker', listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;
        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        prependListener(event: 'NodeWorker.receivedMessageFromWorker', listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;
        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        prependListener(event: 'NodeRuntime.waitingForDisconnect', listener: () => void): this;
        /**
         * This event is fired when the runtime is waiting for the debugger. For
         * example, when inspector.waitingForDebugger is called
         */
        prependListener(event: 'NodeRuntime.waitingForDebugger', listener: () => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        prependOnceListener(event: 'inspectorNotification', listener: (message: InspectorNotification<object>) => void): this;
        /**
         * Issued when new execution context is created.
         */
        prependOnceListener(event: 'Runtime.executionContextCreated', listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;
        /**
         * Issued when execution context is destroyed.
         */
        prependOnceListener(event: 'Runtime.executionContextDestroyed', listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;
        /**
         * Issued when all executionContexts were cleared in browser
         */
        prependOnceListener(event: 'Runtime.executionContextsCleared', listener: () => void): this;
        /**
         * Issued when exception was thrown and unhandled.
         */
        prependOnceListener(event: 'Runtime.exceptionThrown', listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;
        /**
         * Issued when unhandled exception was revoked.
         */
        prependOnceListener(event: 'Runtime.exceptionRevoked', listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;
        /**
         * Issued when console API was called.
         */
        prependOnceListener(event: 'Runtime.consoleAPICalled', listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;
        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        prependOnceListener(event: 'Runtime.inspectRequested', listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;
        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        prependOnceListener(event: 'Debugger.scriptParsed', listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;
        /**
         * Fired when virtual machine fails to parse the script.
         */
        prependOnceListener(event: 'Debugger.scriptFailedToParse', listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;
        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        prependOnceListener(event: 'Debugger.breakpointResolved', listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        prependOnceListener(event: 'Debugger.paused', listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine resumed execution.
         */
        prependOnceListener(event: 'Debugger.resumed', listener: () => void): this;
        /**
         * Issued when new console message is added.
         */
        prependOnceListener(event: 'Console.messageAdded', listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;
        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        prependOnceListener(event: 'Profiler.consoleProfileStarted', listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;
        prependOnceListener(event: 'Profiler.consoleProfileFinished', listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        prependOnceListener(event: 'HeapProfiler.addHeapSnapshotChunk', listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        prependOnceListener(event: 'HeapProfiler.resetProfiles', listener: () => void): this;
        prependOnceListener(event: 'HeapProfiler.reportHeapSnapshotProgress', listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        prependOnceListener(event: 'HeapProfiler.lastSeenObjectId', listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        prependOnceListener(event: 'HeapProfiler.heapStatsUpdate', listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;
        /**
         * Contains an bucket of collected trace events.
         */
        prependOnceListener(event: 'NodeTracing.dataCollected', listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;
        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        prependOnceListener(event: 'NodeTracing.tracingComplete', listener: () => void): this;
        /**
         * Issued when attached to a worker.
         */
        prependOnceListener(event: 'NodeWorker.attachedToWorker', listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;
        /**
         * Issued when detached from the worker.
         */
        prependOnceListener(event: 'NodeWorker.detachedFromWorker', listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;
        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        prependOnceListener(event: 'NodeWorker.receivedMessageFromWorker', listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;
        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        prependOnceListener(event: 'NodeRuntime.waitingForDisconnect', listener: () => void): this;
        /**
         * This event is fired when the runtime is waiting for the debugger. For
         * example, when inspector.waitingForDebugger is called
         */
        prependOnceListener(event: 'NodeRuntime.waitingForDebugger', listener: () => void): this;
    }

    export {
        Session,
        open,
        close,
        url,
        waitForDebugger,
        console,
        InspectorNotification,
        Schema,
        Runtime,
        Debugger,
        Console,
        Profiler,
        HeapProfiler,
        NodeTracing,
        NodeWorker,
        NodeRuntime,
    };
}

/**
 * The `node:inspector/promises` module provides an API for interacting with the V8
 * inspector.
 * @since v19.0.0
 */
declare module 'node:inspector/promises' {
    export * from 'inspector/promises';
}
    MIT License

    Copyright (c) Microsoft Corporation.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE
/**
 * @since v0.3.7
 * @experimental
 */
declare module "module" {
    import { URL } from "node:url";
    import { MessagePort } from "node:worker_threads";
    namespace Module {
        /**
         * The `module.syncBuiltinESMExports()` method updates all the live bindings for
         * builtin `ES Modules` to match the properties of the `CommonJS` exports. It
         * does not add or remove exported names from the `ES Modules`.
         *
         * ```js
         * const fs = require('node:fs');
         * const assert = require('node:assert');
         * const { syncBuiltinESMExports } = require('node:module');
         *
         * fs.readFile = newAPI;
         *
         * delete fs.readFileSync;
         *
         * function newAPI() {
         *   // ...
         * }
         *
         * fs.newAPI = newAPI;
         *
         * syncBuiltinESMExports();
         *
         * import('node:fs').then((esmFS) => {
         *   // It syncs the existing readFile property with the new value
         *   assert.strictEqual(esmFS.readFile, newAPI);
         *   // readFileSync has been deleted from the required fs
         *   assert.strictEqual('readFileSync' in fs, false);
         *   // syncBuiltinESMExports() does not remove readFileSync from esmFS
         *   assert.strictEqual('readFileSync' in esmFS, true);
         *   // syncBuiltinESMExports() does not add names
         *   assert.strictEqual(esmFS.newAPI, undefined);
         * });
         * ```
         * @since v12.12.0
         */
        function syncBuiltinESMExports(): void;
        /**
         * `path` is the resolved path for the file for which a corresponding source map
         * should be fetched.
         * @since v13.7.0, v12.17.0
         * @return Returns `module.SourceMap` if a source map is found, `undefined` otherwise.
         */
        function findSourceMap(path: string, error?: Error): SourceMap;
        interface SourceMapPayload {
            file: string;
            version: number;
            sources: string[];
            sourcesContent: string[];
            names: string[];
            mappings: string;
            sourceRoot: string;
        }
        interface SourceMapping {
            generatedLine: number;
            generatedColumn: number;
            originalSource: string;
            originalLine: number;
            originalColumn: number;
        }
        interface SourceOrigin {
            /**
             * The name of the range in the source map, if one was provided
             */
            name?: string;
            /**
             * The file name of the original source, as reported in the SourceMap
             */
            fileName: string;
            /**
             * The 1-indexed lineNumber of the corresponding call site in the original source
             */
            lineNumber: number;
            /**
             * The 1-indexed columnNumber of the corresponding call site in the original source
             */
            columnNumber: number;
        }
        /**
         * @since v13.7.0, v12.17.0
         */
        class SourceMap {
            /**
             * Getter for the payload used to construct the `SourceMap` instance.
             */
            readonly payload: SourceMapPayload;
            constructor(payload: SourceMapPayload);
            /**
             * Given a line offset and column offset in the generated source
             * file, returns an object representing the SourceMap range in the
             * original file if found, or an empty object if not.
             *
             * The object returned contains the following keys:
             *
             * The returned value represents the raw range as it appears in the
             * SourceMap, based on zero-indexed offsets, _not_ 1-indexed line and
             * column numbers as they appear in Error messages and CallSite
             * objects.
             *
             * To get the corresponding 1-indexed line and column numbers from a
             * lineNumber and columnNumber as they are reported by Error stacks
             * and CallSite objects, use `sourceMap.findOrigin(lineNumber, columnNumber)`
             * @param lineOffset The zero-indexed line number offset in the generated source
             * @param columnOffset The zero-indexed column number offset in the generated source
             */
            findEntry(lineOffset: number, columnOffset: number): SourceMapping;
            /**
             * Given a 1-indexed `lineNumber` and `columnNumber` from a call site in the generated source,
             * find the corresponding call site location in the original source.
             *
             * If the `lineNumber` and `columnNumber` provided are not found in any source map,
             * then an empty object is returned.
             * @param lineNumber The 1-indexed line number of the call site in the generated source
             * @param columnNumber The 1-indexed column number of the call site in the generated source
             */
            findOrigin(lineNumber: number, columnNumber: number): SourceOrigin | {};
        }
        interface ImportAttributes extends NodeJS.Dict<string> {
            type?: string | undefined;
        }
        type ModuleFormat = "builtin" | "commonjs" | "json" | "module" | "wasm";
        type ModuleSource = string | ArrayBuffer | NodeJS.TypedArray;
        interface GlobalPreloadContext {
            port: MessagePort;
        }
        /**
         * @deprecated This hook will be removed in a future version.
         * Use `initialize` instead. When a loader has an `initialize` export, `globalPreload` will be ignored.
         *
         * Sometimes it might be necessary to run some code inside of the same global scope that the application runs in.
         * This hook allows the return of a string that is run as a sloppy-mode script on startup.
         *
         * @param context Information to assist the preload code
         * @return Code to run before application startup
         */
        type GlobalPreloadHook = (context: GlobalPreloadContext) => string;
        /**
         * The `initialize` hook provides a way to define a custom function that runs in the hooks thread
         * when the hooks module is initialized. Initialization happens when the hooks module is registered via `register`.
         *
         * This hook can receive data from a `register` invocation, including ports and other transferrable objects.
         * The return value of `initialize` can be a `Promise`, in which case it will be awaited before the main application thread execution resumes.
         */
        type InitializeHook<Data = any> = (data: Data) => void | Promise<void>;
        interface ResolveHookContext {
            /**
             * Export conditions of the relevant `package.json`
             */
            conditions: string[];
            /**
             *  An object whose key-value pairs represent the assertions for the module to import
             */
            importAttributes: ImportAttributes;
            /**
             * The module importing this one, or undefined if this is the Node.js entry point
             */
            parentURL: string | undefined;
        }
        interface ResolveFnOutput {
            /**
             * A hint to the load hook (it might be ignored)
             */
            format?: ModuleFormat | null | undefined;
            /**
             * The import attributes to use when caching the module (optional; if excluded the input will be used)
             */
            importAttributes?: ImportAttributes | undefined;
            /**
             * A signal that this hook intends to terminate the chain of `resolve` hooks.
             * @default false
             */
            shortCircuit?: boolean | undefined;
            /**
             * The absolute URL to which this input resolves
             */
            url: string;
        }
        /**
         * The `resolve` hook chain is responsible for resolving file URL for a given module specifier and parent URL, and optionally its format (such as `'module'`) as a hint to the `load` hook.
         * If a format is specified, the load hook is ultimately responsible for providing the final `format` value (and it is free to ignore the hint provided by `resolve`);
         * if `resolve` provides a format, a custom `load` hook is required even if only to pass the value to the Node.js default `load` hook.
         *
         * @param specifier The specified URL path of the module to be resolved
         * @param context
         * @param nextResolve The subsequent `resolve` hook in the chain, or the Node.js default `resolve` hook after the last user-supplied resolve hook
         */
        type ResolveHook = (
            specifier: string,
            context: ResolveHookContext,
            nextResolve: (
                specifier: string,
                context?: ResolveHookContext,
            ) => ResolveFnOutput | Promise<ResolveFnOutput>,
        ) => ResolveFnOutput | Promise<ResolveFnOutput>;
        interface LoadHookContext {
            /**
             * Export conditions of the relevant `package.json`
             */
            conditions: string[];
            /**
             * The format optionally supplied by the `resolve` hook chain
             */
            format: ModuleFormat;
            /**
             *  An object whose key-value pairs represent the assertions for the module to import
             */
            importAttributes: ImportAttributes;
        }
        interface LoadFnOutput {
            format: ModuleFormat;
            /**
             * A signal that this hook intends to terminate the chain of `resolve` hooks.
             * @default false
             */
            shortCircuit?: boolean | undefined;
            /**
             * The source for Node.js to evaluate
             */
            source?: ModuleSource;
        }
        /**
         * The `load` hook provides a way to define a custom method of determining how a URL should be interpreted, retrieved, and parsed.
         * It is also in charge of validating the import assertion.
         *
         * @param url The URL/path of the module to be loaded
         * @param context Metadata about the module
         * @param nextLoad The subsequent `load` hook in the chain, or the Node.js default `load` hook after the last user-supplied `load` hook
         */
        type LoadHook = (
            url: string,
            context: LoadHookContext,
            nextLoad: (url: string, context?: LoadHookContext) => LoadFnOutput | Promise<LoadFnOutput>,
        ) => LoadFnOutput | Promise<LoadFnOutput>;
    }
    interface RegisterOptions<Data> {
        parentURL: string | URL;
        data?: Data | undefined;
        transferList?: any[] | undefined;
    }
    interface Module extends NodeModule {}
    class Module {
        static runMain(): void;
        static wrap(code: string): string;
        static createRequire(path: string | URL): NodeRequire;
        static builtinModules: string[];
        static isBuiltin(moduleName: string): boolean;
        static Module: typeof Module;
        static register<Data = any>(
            specifier: string | URL,
            parentURL?: string | URL,
            options?: RegisterOptions<Data>,
        ): void;
        static register<Data = any>(specifier: string | URL, options?: RegisterOptions<Data>): void;
        constructor(id: string, parent?: Module);
    }
    global {
        interface ImportMeta {
            /**
             * The directory name of the current module. This is the same as the `path.dirname()` of the `import.meta.filename`.
             * **Caveat:** only present on `file:` modules.
             */
            dirname: string;
            /**
             * The full absolute path and filename of the current module, with symlinks resolved.
             * This is the same as the `url.fileURLToPath()` of the `import.meta.url`.
             * **Caveat:** only local modules support this property. Modules not using the `file:` protocol will not provide it.
             */
            filename: string;
            /**
             * The absolute `file:` URL of the module.
             */
            url: string;
            /**
             * Provides a module-relative resolution function scoped to each module, returning
             * the URL string.
             *
             * Second `parent` parameter is only used when the `--experimental-import-meta-resolve`
             * command flag enabled.
             *
             * @since v20.6.0
             *
             * @param specifier The module specifier to resolve relative to `parent`.
             * @param parent The absolute parent module URL to resolve from.
             * @returns The absolute (`file:`) URL string for the resolved module.
             */
            resolve(specifier: string, parent?: string | URL | undefined): string;
        }
    }
    export = Module;
}
declare module "node:module" {
    import module = require("module");
    export = module;
}
/**
 * > Stability: 2 - Stable
 *
 * The `node:net` module provides an asynchronous network API for creating stream-based
 * TCP or `IPC` servers ({@link createServer}) and clients
 * ({@link createConnection}).
 *
 * It can be accessed using:
 *
 * ```js
 * const net = require('node:net');
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/net.js)
 */
declare module "net" {
    import * as stream from "node:stream";
    import { Abortable, EventEmitter } from "node:events";
    import * as dns from "node:dns";
    type LookupFunction = (
        hostname: string,
        options: dns.LookupOptions,
        callback: (err: NodeJS.ErrnoException | null, address: string | dns.LookupAddress[], family?: number) => void,
    ) => void;
    interface AddressInfo {
        address: string;
        family: string;
        port: number;
    }
    interface SocketConstructorOpts {
        fd?: number | undefined;
        allowHalfOpen?: boolean | undefined;
        readable?: boolean | undefined;
        writable?: boolean | undefined;
        signal?: AbortSignal;
    }
    interface OnReadOpts {
        buffer: Uint8Array | (() => Uint8Array);
        /**
         * This function is called for every chunk of incoming data.
         * Two arguments are passed to it: the number of bytes written to buffer and a reference to buffer.
         * Return false from this function to implicitly pause() the socket.
         */
        callback(bytesWritten: number, buf: Uint8Array): boolean;
    }
    interface ConnectOpts {
        /**
         * If specified, incoming data is stored in a single buffer and passed to the supplied callback when data arrives on the socket.
         * Note: this will cause the streaming functionality to not provide any data, however events like 'error', 'end', and 'close' will
         * still be emitted as normal and methods like pause() and resume() will also behave as expected.
         */
        onread?: OnReadOpts | undefined;
    }
    interface TcpSocketConnectOpts extends ConnectOpts {
        port: number;
        host?: string | undefined;
        localAddress?: string | undefined;
        localPort?: number | undefined;
        hints?: number | undefined;
        family?: number | undefined;
        lookup?: LookupFunction | undefined;
        noDelay?: boolean | undefined;
        keepAlive?: boolean | undefined;
        keepAliveInitialDelay?: number | undefined;
        /**
         * @since v18.13.0
         */
        autoSelectFamily?: boolean | undefined;
        /**
         * @since v18.13.0
         */
        autoSelectFamilyAttemptTimeout?: number | undefined;
    }
    interface IpcSocketConnectOpts extends ConnectOpts {
        path: string;
    }
    type SocketConnectOpts = TcpSocketConnectOpts | IpcSocketConnectOpts;
    type SocketReadyState = "opening" | "open" | "readOnly" | "writeOnly" | "closed";
    /**
     * This class is an abstraction of a TCP socket or a streaming `IPC` endpoint
     * (uses named pipes on Windows, and Unix domain sockets otherwise). It is also
     * an `EventEmitter`.
     *
     * A `net.Socket` can be created by the user and used directly to interact with
     * a server. For example, it is returned by {@link createConnection},
     * so the user can use it to talk to the server.
     *
     * It can also be created by Node.js and passed to the user when a connection
     * is received. For example, it is passed to the listeners of a `'connection'` event emitted on a {@link Server}, so the user can use
     * it to interact with the client.
     * @since v0.3.4
     */
    class Socket extends stream.Duplex {
        constructor(options?: SocketConstructorOpts);
        /**
         * Destroys the socket after all data is written. If the `finish` event was already emitted the socket is destroyed immediately.
         * If the socket is still writable it implicitly calls `socket.end()`.
         * @since v0.3.4
         */
        destroySoon(): void;
        /**
         * Sends data on the socket. The second parameter specifies the encoding in the
         * case of a string. It defaults to UTF8 encoding.
         *
         * Returns `true` if the entire data was flushed successfully to the kernel
         * buffer. Returns `false` if all or part of the data was queued in user memory.`'drain'` will be emitted when the buffer is again free.
         *
         * The optional `callback` parameter will be executed when the data is finally
         * written out, which may not be immediately.
         *
         * See `Writable` stream `write()` method for more
         * information.
         * @since v0.1.90
         * @param [encoding='utf8'] Only used when data is `string`.
         */
        write(buffer: Uint8Array | string, cb?: (err?: Error) => void): boolean;
        write(str: Uint8Array | string, encoding?: BufferEncoding, cb?: (err?: Error) => void): boolean;
        /**
         * Initiate a connection on a given socket.
         *
         * Possible signatures:
         *
         * * `socket.connect(options[, connectListener])`
         * * `socket.connect(path[, connectListener])` for `IPC` connections.
         * * `socket.connect(port[, host][, connectListener])` for TCP connections.
         * * Returns: `net.Socket` The socket itself.
         *
         * This function is asynchronous. When the connection is established, the `'connect'` event will be emitted. If there is a problem connecting,
         * instead of a `'connect'` event, an `'error'` event will be emitted with
         * the error passed to the `'error'` listener.
         * The last parameter `connectListener`, if supplied, will be added as a listener
         * for the `'connect'` event **once**.
         *
         * This function should only be used for reconnecting a socket after`'close'` has been emitted or otherwise it may lead to undefined
         * behavior.
         */
        connect(options: SocketConnectOpts, connectionListener?: () => void): this;
        connect(port: number, host: string, connectionListener?: () => void): this;
        connect(port: number, connectionListener?: () => void): this;
        connect(path: string, connectionListener?: () => void): this;
        /**
         * Set the encoding for the socket as a `Readable Stream`. See `readable.setEncoding()` for more information.
         * @since v0.1.90
         * @return The socket itself.
         */
        setEncoding(encoding?: BufferEncoding): this;
        /**
         * Pauses the reading of data. That is, `'data'` events will not be emitted.
         * Useful to throttle back an upload.
         * @return The socket itself.
         */
        pause(): this;
        /**
         * Close the TCP connection by sending an RST packet and destroy the stream.
         * If this TCP socket is in connecting status, it will send an RST packet and destroy this TCP socket once it is connected.
         * Otherwise, it will call `socket.destroy` with an `ERR_SOCKET_CLOSED` Error.
         * If this is not a TCP socket (for example, a pipe), calling this method will immediately throw an `ERR_INVALID_HANDLE_TYPE` Error.
         * @since v18.3.0, v16.17.0
         */
        resetAndDestroy(): this;
        /**
         * Resumes reading after a call to `socket.pause()`.
         * @return The socket itself.
         */
        resume(): this;
        /**
         * Sets the socket to timeout after `timeout` milliseconds of inactivity on
         * the socket. By default `net.Socket` do not have a timeout.
         *
         * When an idle timeout is triggered the socket will receive a `'timeout'` event but the connection will not be severed. The user must manually call `socket.end()` or `socket.destroy()` to
         * end the connection.
         *
         * ```js
         * socket.setTimeout(3000);
         * socket.on('timeout', () => {
         *   console.log('socket timeout');
         *   socket.end();
         * });
         * ```
         *
         * If `timeout` is 0, then the existing idle timeout is disabled.
         *
         * The optional `callback` parameter will be added as a one-time listener for the `'timeout'` event.
         * @since v0.1.90
         * @return The socket itself.
         */
        setTimeout(timeout: number, callback?: () => void): this;
        /**
         * Enable/disable the use of Nagle's algorithm.
         *
         * When a TCP connection is created, it will have Nagle's algorithm enabled.
         *
         * Nagle's algorithm delays data before it is sent via the network. It attempts
         * to optimize throughput at the expense of latency.
         *
         * Passing `true` for `noDelay` or not passing an argument will disable Nagle's
         * algorithm for the socket. Passing `false` for `noDelay` will enable Nagle's
         * algorithm.
         * @since v0.1.90
         * @param [noDelay=true]
         * @return The socket itself.
         */
        setNoDelay(noDelay?: boolean): this;
        /**
         * Enable/disable keep-alive functionality, and optionally set the initial
         * delay before the first keepalive probe is sent on an idle socket.
         *
         * Set `initialDelay` (in milliseconds) to set the delay between the last
         * data packet received and the first keepalive probe. Setting `0` for`initialDelay` will leave the value unchanged from the default
         * (or previous) setting.
         *
         * Enabling the keep-alive functionality will set the following socket options:
         *
         * * `SO_KEEPALIVE=1`
         * * `TCP_KEEPIDLE=initialDelay`
         * * `TCP_KEEPCNT=10`
         * * `TCP_KEEPINTVL=1`
         * @since v0.1.92
         * @param [enable=false]
         * @param [initialDelay=0]
         * @return The socket itself.
         */
        setKeepAlive(enable?: boolean, initialDelay?: number): this;
        /**
         * Returns the bound `address`, the address `family` name and `port` of the
         * socket as reported by the operating system:`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`
         * @since v0.1.90
         */
        address(): AddressInfo | {};
        /**
         * Calling `unref()` on a socket will allow the program to exit if this is the only
         * active socket in the event system. If the socket is already `unref`ed calling`unref()` again will have no effect.
         * @since v0.9.1
         * @return The socket itself.
         */
        unref(): this;
        /**
         * Opposite of `unref()`, calling `ref()` on a previously `unref`ed socket will _not_ let the program exit if it's the only socket left (the default behavior).
         * If the socket is `ref`ed calling `ref` again will have no effect.
         * @since v0.9.1
         * @return The socket itself.
         */
        ref(): this;
        /**
         * This property is only present if the family autoselection algorithm is enabled in `socket.connect(options)`
         * and it is an array of the addresses that have been attempted.
         *
         * Each address is a string in the form of `$IP:$PORT`.
         * If the connection was successful, then the last address is the one that the socket is currently connected to.
         * @since v19.4.0
         */
        readonly autoSelectFamilyAttemptedAddresses: string[];
        /**
         * This property shows the number of characters buffered for writing. The buffer
         * may contain strings whose length after encoding is not yet known. So this number
         * is only an approximation of the number of bytes in the buffer.
         *
         * `net.Socket` has the property that `socket.write()` always works. This is to
         * help users get up and running quickly. The computer cannot always keep up
         * with the amount of data that is written to a socket. The network connection
         * simply might be too slow. Node.js will internally queue up the data written to a
         * socket and send it out over the wire when it is possible.
         *
         * The consequence of this internal buffering is that memory may grow.
         * Users who experience large or growing `bufferSize` should attempt to
         * "throttle" the data flows in their program with `socket.pause()` and `socket.resume()`.
         * @since v0.3.8
         * @deprecated Since v14.6.0 - Use `writableLength` instead.
         */
        readonly bufferSize: number;
        /**
         * The amount of received bytes.
         * @since v0.5.3
         */
        readonly bytesRead: number;
        /**
         * The amount of bytes sent.
         * @since v0.5.3
         */
        readonly bytesWritten: number;
        /**
         * If `true`, `socket.connect(options[, connectListener])` was
         * called and has not yet finished. It will stay `true` until the socket becomes
         * connected, then it is set to `false` and the `'connect'` event is emitted. Note
         * that the `socket.connect(options[, connectListener])` callback is a listener for the `'connect'` event.
         * @since v6.1.0
         */
        readonly connecting: boolean;
        /**
         * This is `true` if the socket is not connected yet, either because `.connect()`has not yet been called or because it is still in the process of connecting
         * (see `socket.connecting`).
         * @since v11.2.0, v10.16.0
         */
        readonly pending: boolean;
        /**
         * See `writable.destroyed` for further details.
         */
        readonly destroyed: boolean;
        /**
         * The string representation of the local IP address the remote client is
         * connecting on. For example, in a server listening on `'0.0.0.0'`, if a client
         * connects on `'192.168.1.1'`, the value of `socket.localAddress` would be`'192.168.1.1'`.
         * @since v0.9.6
         */
        readonly localAddress?: string;
        /**
         * The numeric representation of the local port. For example, `80` or `21`.
         * @since v0.9.6
         */
        readonly localPort?: number;
        /**
         * The string representation of the local IP family. `'IPv4'` or `'IPv6'`.
         * @since v18.8.0, v16.18.0
         */
        readonly localFamily?: string;
        /**
         * This property represents the state of the connection as a string.
         *
         * * If the stream is connecting `socket.readyState` is `opening`.
         * * If the stream is readable and writable, it is `open`.
         * * If the stream is readable and not writable, it is `readOnly`.
         * * If the stream is not readable and writable, it is `writeOnly`.
         * @since v0.5.0
         */
        readonly readyState: SocketReadyState;
        /**
         * The string representation of the remote IP address. For example,`'74.125.127.100'` or `'2001:4860:a005::68'`. Value may be `undefined` if
         * the socket is destroyed (for example, if the client disconnected).
         * @since v0.5.10
         */
        readonly remoteAddress?: string | undefined;
        /**
         * The string representation of the remote IP family. `'IPv4'` or `'IPv6'`. Value may be `undefined` if
         * the socket is destroyed (for example, if the client disconnected).
         * @since v0.11.14
         */
        readonly remoteFamily?: string | undefined;
        /**
         * The numeric representation of the remote port. For example, `80` or `21`. Value may be `undefined` if
         * the socket is destroyed (for example, if the client disconnected).
         * @since v0.5.10
         */
        readonly remotePort?: number | undefined;
        /**
         * The socket timeout in milliseconds as set by `socket.setTimeout()`.
         * It is `undefined` if a timeout has not been set.
         * @since v10.7.0
         */
        readonly timeout?: number | undefined;
        /**
         * Half-closes the socket. i.e., it sends a FIN packet. It is possible the
         * server will still send some data.
         *
         * See `writable.end()` for further details.
         * @since v0.1.90
         * @param [encoding='utf8'] Only used when data is `string`.
         * @param callback Optional callback for when the socket is finished.
         * @return The socket itself.
         */
        end(callback?: () => void): this;
        end(buffer: Uint8Array | string, callback?: () => void): this;
        end(str: Uint8Array | string, encoding?: BufferEncoding, callback?: () => void): this;
        /**
         * events.EventEmitter
         *   1. close
         *   2. connect
         *   3. connectionAttempt
         *   4. connectionAttemptFailed
         *   5. connectionAttemptTimeout
         *   6. data
         *   7. drain
         *   8. end
         *   9. error
         *   10. lookup
         *   11. ready
         *   12. timeout
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "close", listener: (hadError: boolean) => void): this;
        addListener(event: "connect", listener: () => void): this;
        addListener(event: "connectionAttempt", listener: (ip: string, port: number, family: number) => void): this;
        addListener(
            event: "connectionAttemptFailed",
            listener: (ip: string, port: number, family: number) => void,
        ): this;
        addListener(
            event: "connectionAttemptTimeout",
            listener: (ip: string, port: number, family: number) => void,
        ): this;
        addListener(event: "data", listener: (data: Buffer) => void): this;
        addListener(event: "drain", listener: () => void): this;
        addListener(event: "end", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void,
        ): this;
        addListener(event: "ready", listener: () => void): this;
        addListener(event: "timeout", listener: () => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "close", hadError: boolean): boolean;
        emit(event: "connect"): boolean;
        emit(event: "connectionAttempt", ip: string, port: number, family: number): boolean;
        emit(event: "connectionAttemptFailed", ip: string, port: number, family: number): boolean;
        emit(event: "connectionAttemptTimeout", ip: string, port: number, family: number): boolean;
        emit(event: "data", data: Buffer): boolean;
        emit(event: "drain"): boolean;
        emit(event: "end"): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "lookup", err: Error, address: string, family: string | number, host: string): boolean;
        emit(event: "ready"): boolean;
        emit(event: "timeout"): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "close", listener: (hadError: boolean) => void): this;
        on(event: "connect", listener: () => void): this;
        on(event: "connectionAttempt", listener: (ip: string, port: number, family: number) => void): this;
        on(event: "connectionAttemptFailed", listener: (ip: string, port: number, family: number) => void): this;
        on(event: "connectionAttemptTimeout", listener: (ip: string, port: number, family: number) => void): this;
        on(event: "data", listener: (data: Buffer) => void): this;
        on(event: "drain", listener: () => void): this;
        on(event: "end", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void,
        ): this;
        on(event: "ready", listener: () => void): this;
        on(event: "timeout", listener: () => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "close", listener: (hadError: boolean) => void): this;
        once(event: "connectionAttempt", listener: (ip: string, port: number, family: number) => void): this;
        once(event: "connectionAttemptFailed", listener: (ip: string, port: number, family: number) => void): this;
        once(event: "connectionAttemptTimeout", listener: (ip: string, port: number, family: number) => void): this;
        once(event: "connect", listener: () => void): this;
        once(event: "data", listener: (data: Buffer) => void): this;
        once(event: "drain", listener: () => void): this;
        once(event: "end", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void,
        ): this;
        once(event: "ready", listener: () => void): this;
        once(event: "timeout", listener: () => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: (hadError: boolean) => void): this;
        prependListener(event: "connect", listener: () => void): this;
        prependListener(event: "connectionAttempt", listener: (ip: string, port: number, family: number) => void): this;
        prependListener(
            event: "connectionAttemptFailed",
            listener: (ip: string, port: number, family: number) => void,
        ): this;
        prependListener(
            event: "connectionAttemptTimeout",
            listener: (ip: string, port: number, family: number) => void,
        ): this;
        prependListener(event: "data", listener: (data: Buffer) => void): this;
        prependListener(event: "drain", listener: () => void): this;
        prependListener(event: "end", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void,
        ): this;
        prependListener(event: "ready", listener: () => void): this;
        prependListener(event: "timeout", listener: () => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: (hadError: boolean) => void): this;
        prependOnceListener(event: "connect", listener: () => void): this;
        prependOnceListener(
            event: "connectionAttempt",
            listener: (ip: string, port: number, family: number) => void,
        ): this;
        prependOnceListener(
            event: "connectionAttemptFailed",
            listener: (ip: string, port: number, family: number) => void,
        ): this;
        prependOnceListener(
            event: "connectionAttemptTimeout",
            listener: (ip: string, port: number, family: number) => void,
        ): this;
        prependOnceListener(event: "data", listener: (data: Buffer) => void): this;
        prependOnceListener(event: "drain", listener: () => void): this;
        prependOnceListener(event: "end", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void,
        ): this;
        prependOnceListener(event: "ready", listener: () => void): this;
        prependOnceListener(event: "timeout", listener: () => void): this;
    }
    interface ListenOptions extends Abortable {
        port?: number | undefined;
        host?: string | undefined;
        backlog?: number | undefined;
        path?: string | undefined;
        exclusive?: boolean | undefined;
        readableAll?: boolean | undefined;
        writableAll?: boolean | undefined;
        /**
         * @default false
         */
        ipv6Only?: boolean | undefined;
    }
    interface ServerOpts {
        /**
         * Indicates whether half-opened TCP connections are allowed.
         * @default false
         */
        allowHalfOpen?: boolean | undefined;
        /**
         * Indicates whether the socket should be paused on incoming connections.
         * @default false
         */
        pauseOnConnect?: boolean | undefined;
        /**
         * If set to `true`, it disables the use of Nagle's algorithm immediately after a new incoming connection is received.
         * @default false
         * @since v16.5.0
         */
        noDelay?: boolean | undefined;
        /**
         * If set to `true`, it enables keep-alive functionality on the socket immediately after a new incoming connection is received,
         * similarly on what is done in `socket.setKeepAlive([enable][, initialDelay])`.
         * @default false
         * @since v16.5.0
         */
        keepAlive?: boolean | undefined;
        /**
         * If set to a positive number, it sets the initial delay before the first keepalive probe is sent on an idle socket.
         * @default 0
         * @since v16.5.0
         */
        keepAliveInitialDelay?: number | undefined;
    }
    interface DropArgument {
        localAddress?: string;
        localPort?: number;
        localFamily?: string;
        remoteAddress?: string;
        remotePort?: number;
        remoteFamily?: string;
    }
    /**
     * This class is used to create a TCP or `IPC` server.
     * @since v0.1.90
     */
    class Server extends EventEmitter {
        constructor(connectionListener?: (socket: Socket) => void);
        constructor(options?: ServerOpts, connectionListener?: (socket: Socket) => void);
        /**
         * Start a server listening for connections. A `net.Server` can be a TCP or
         * an `IPC` server depending on what it listens to.
         *
         * Possible signatures:
         *
         * * `server.listen(handle[, backlog][, callback])`
         * * `server.listen(options[, callback])`
         * * `server.listen(path[, backlog][, callback])` for `IPC` servers
         * * `server.listen([port[, host[, backlog]]][, callback])` for TCP servers
         *
         * This function is asynchronous. When the server starts listening, the `'listening'` event will be emitted. The last parameter `callback`will be added as a listener for the `'listening'`
         * event.
         *
         * All `listen()` methods can take a `backlog` parameter to specify the maximum
         * length of the queue of pending connections. The actual length will be determined
         * by the OS through sysctl settings such as `tcp_max_syn_backlog` and `somaxconn` on Linux. The default value of this parameter is 511 (not 512).
         *
         * All {@link Socket} are set to `SO_REUSEADDR` (see [`socket(7)`](https://man7.org/linux/man-pages/man7/socket.7.html) for
         * details).
         *
         * The `server.listen()` method can be called again if and only if there was an
         * error during the first `server.listen()` call or `server.close()` has been
         * called. Otherwise, an `ERR_SERVER_ALREADY_LISTEN` error will be thrown.
         *
         * One of the most common errors raised when listening is `EADDRINUSE`.
         * This happens when another server is already listening on the requested`port`/`path`/`handle`. One way to handle this would be to retry
         * after a certain amount of time:
         *
         * ```js
         * server.on('error', (e) => {
         *   if (e.code === 'EADDRINUSE') {
         *     console.error('Address in use, retrying...');
         *     setTimeout(() => {
         *       server.close();
         *       server.listen(PORT, HOST);
         *     }, 1000);
         *   }
         * });
         * ```
         */
        listen(port?: number, hostname?: string, backlog?: number, listeningListener?: () => void): this;
        listen(port?: number, hostname?: string, listeningListener?: () => void): this;
        listen(port?: number, backlog?: number, listeningListener?: () => void): this;
        listen(port?: number, listeningListener?: () => void): this;
        listen(path: string, backlog?: number, listeningListener?: () => void): this;
        listen(path: string, listeningListener?: () => void): this;
        listen(options: ListenOptions, listeningListener?: () => void): this;
        listen(handle: any, backlog?: number, listeningListener?: () => void): this;
        listen(handle: any, listeningListener?: () => void): this;
        /**
         * Stops the server from accepting new connections and keeps existing
         * connections. This function is asynchronous, the server is finally closed
         * when all connections are ended and the server emits a `'close'` event.
         * The optional `callback` will be called once the `'close'` event occurs. Unlike
         * that event, it will be called with an `Error` as its only argument if the server
         * was not open when it was closed.
         * @since v0.1.90
         * @param callback Called when the server is closed.
         */
        close(callback?: (err?: Error) => void): this;
        /**
         * Returns the bound `address`, the address `family` name, and `port` of the server
         * as reported by the operating system if listening on an IP socket
         * (useful to find which port was assigned when getting an OS-assigned address):`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`.
         *
         * For a server listening on a pipe or Unix domain socket, the name is returned
         * as a string.
         *
         * ```js
         * const server = net.createServer((socket) => {
         *   socket.end('goodbye\n');
         * }).on('error', (err) => {
         *   // Handle errors here.
         *   throw err;
         * });
         *
         * // Grab an arbitrary unused port.
         * server.listen(() => {
         *   console.log('opened server on', server.address());
         * });
         * ```
         *
         * `server.address()` returns `null` before the `'listening'` event has been
         * emitted or after calling `server.close()`.
         * @since v0.1.90
         */
        address(): AddressInfo | string | null;
        /**
         * Asynchronously get the number of concurrent connections on the server. Works
         * when sockets were sent to forks.
         *
         * Callback should take two arguments `err` and `count`.
         * @since v0.9.7
         */
        getConnections(cb: (error: Error | null, count: number) => void): void;
        /**
         * Opposite of `unref()`, calling `ref()` on a previously `unref`ed server will _not_ let the program exit if it's the only server left (the default behavior).
         * If the server is `ref`ed calling `ref()` again will have no effect.
         * @since v0.9.1
         */
        ref(): this;
        /**
         * Calling `unref()` on a server will allow the program to exit if this is the only
         * active server in the event system. If the server is already `unref`ed calling`unref()` again will have no effect.
         * @since v0.9.1
         */
        unref(): this;
        /**
         * Set this property to reject connections when the server's connection count gets
         * high.
         *
         * It is not recommended to use this option once a socket has been sent to a child
         * with `child_process.fork()`.
         * @since v0.2.0
         */
        maxConnections: number;
        connections: number;
        /**
         * Indicates whether or not the server is listening for connections.
         * @since v5.7.0
         */
        readonly listening: boolean;
        /**
         * events.EventEmitter
         *   1. close
         *   2. connection
         *   3. error
         *   4. listening
         *   5. drop
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "connection", listener: (socket: Socket) => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "listening", listener: () => void): this;
        addListener(event: "drop", listener: (data?: DropArgument) => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "close"): boolean;
        emit(event: "connection", socket: Socket): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "listening"): boolean;
        emit(event: "drop", data?: DropArgument): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "connection", listener: (socket: Socket) => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "listening", listener: () => void): this;
        on(event: "drop", listener: (data?: DropArgument) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "connection", listener: (socket: Socket) => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "listening", listener: () => void): this;
        once(event: "drop", listener: (data?: DropArgument) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "connection", listener: (socket: Socket) => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "listening", listener: () => void): this;
        prependListener(event: "drop", listener: (data?: DropArgument) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "connection", listener: (socket: Socket) => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: "listening", listener: () => void): this;
        prependOnceListener(event: "drop", listener: (data?: DropArgument) => void): this;
        /**
         * Calls {@link Server.close()} and returns a promise that fulfills when the server has closed.
         * @since v20.5.0
         */
        [Symbol.asyncDispose](): Promise<void>;
    }
    type IPVersion = "ipv4" | "ipv6";
    /**
     * The `BlockList` object can be used with some network APIs to specify rules for
     * disabling inbound or outbound access to specific IP addresses, IP ranges, or
     * IP subnets.
     * @since v15.0.0, v14.18.0
     */
    class BlockList {
        /**
         * Adds a rule to block the given IP address.
         * @since v15.0.0, v14.18.0
         * @param address An IPv4 or IPv6 address.
         * @param [type='ipv4'] Either `'ipv4'` or `'ipv6'`.
         */
        addAddress(address: string, type?: IPVersion): void;
        addAddress(address: SocketAddress): void;
        /**
         * Adds a rule to block a range of IP addresses from `start` (inclusive) to`end` (inclusive).
         * @since v15.0.0, v14.18.0
         * @param start The starting IPv4 or IPv6 address in the range.
         * @param end The ending IPv4 or IPv6 address in the range.
         * @param [type='ipv4'] Either `'ipv4'` or `'ipv6'`.
         */
        addRange(start: string, end: string, type?: IPVersion): void;
        addRange(start: SocketAddress, end: SocketAddress): void;
        /**
         * Adds a rule to block a range of IP addresses specified as a subnet mask.
         * @since v15.0.0, v14.18.0
         * @param net The network IPv4 or IPv6 address.
         * @param prefix The number of CIDR prefix bits. For IPv4, this must be a value between `0` and `32`. For IPv6, this must be between `0` and `128`.
         * @param [type='ipv4'] Either `'ipv4'` or `'ipv6'`.
         */
        addSubnet(net: SocketAddress, prefix: number): void;
        addSubnet(net: string, prefix: number, type?: IPVersion): void;
        /**
         * Returns `true` if the given IP address matches any of the rules added to the`BlockList`.
         *
         * ```js
         * const blockList = new net.BlockList();
         * blockList.addAddress('123.123.123.123');
         * blockList.addRange('10.0.0.1', '10.0.0.10');
         * blockList.addSubnet('8592:757c:efae:4e45::', 64, 'ipv6');
         *
         * console.log(blockList.check('123.123.123.123'));  // Prints: true
         * console.log(blockList.check('10.0.0.3'));  // Prints: true
         * console.log(blockList.check('222.111.111.222'));  // Prints: false
         *
         * // IPv6 notation for IPv4 addresses works:
         * console.log(blockList.check('::ffff:7b7b:7b7b', 'ipv6')); // Prints: true
         * console.log(blockList.check('::ffff:123.123.123.123', 'ipv6')); // Prints: true
         * ```
         * @since v15.0.0, v14.18.0
         * @param address The IP address to check
         * @param [type='ipv4'] Either `'ipv4'` or `'ipv6'`.
         */
        check(address: SocketAddress): boolean;
        check(address: string, type?: IPVersion): boolean;
        /**
         * The list of rules added to the blocklist.
         * @since v15.0.0, v14.18.0
         */
        rules: readonly string[];
    }
    interface TcpNetConnectOpts extends TcpSocketConnectOpts, SocketConstructorOpts {
        timeout?: number | undefined;
    }
    interface IpcNetConnectOpts extends IpcSocketConnectOpts, SocketConstructorOpts {
        timeout?: number | undefined;
    }
    type NetConnectOpts = TcpNetConnectOpts | IpcNetConnectOpts;
    /**
     * Creates a new TCP or `IPC` server.
     *
     * If `allowHalfOpen` is set to `true`, when the other end of the socket
     * signals the end of transmission, the server will only send back the end of
     * transmission when `socket.end()` is explicitly called. For example, in the
     * context of TCP, when a FIN packed is received, a FIN packed is sent
     * back only when `socket.end()` is explicitly called. Until then the
     * connection is half-closed (non-readable but still writable). See `'end'` event and [RFC 1122](https://tools.ietf.org/html/rfc1122) (section 4.2.2.13) for more information.
     *
     * If `pauseOnConnect` is set to `true`, then the socket associated with each
     * incoming connection will be paused, and no data will be read from its handle.
     * This allows connections to be passed between processes without any data being
     * read by the original process. To begin reading data from a paused socket, call `socket.resume()`.
     *
     * The server can be a TCP server or an `IPC` server, depending on what it `listen()` to.
     *
     * Here is an example of a TCP echo server which listens for connections
     * on port 8124:
     *
     * ```js
     * const net = require('node:net');
     * const server = net.createServer((c) => {
     *   // 'connection' listener.
     *   console.log('client connected');
     *   c.on('end', () => {
     *     console.log('client disconnected');
     *   });
     *   c.write('hello\r\n');
     *   c.pipe(c);
     * });
     * server.on('error', (err) => {
     *   throw err;
     * });
     * server.listen(8124, () => {
     *   console.log('server bound');
     * });
     * ```
     *
     * Test this by using `telnet`:
     *
     * ```bash
     * telnet localhost 8124
     * ```
     *
     * To listen on the socket `/tmp/echo.sock`:
     *
     * ```js
     * server.listen('/tmp/echo.sock', () => {
     *   console.log('server bound');
     * });
     * ```
     *
     * Use `nc` to connect to a Unix domain socket server:
     *
     * ```bash
     * nc -U /tmp/echo.sock
     * ```
     * @since v0.5.0
     * @param connectionListener Automatically set as a listener for the {@link 'connection'} event.
     */
    function createServer(connectionListener?: (socket: Socket) => void): Server;
    function createServer(options?: ServerOpts, connectionListener?: (socket: Socket) => void): Server;
    /**
     * Aliases to {@link createConnection}.
     *
     * Possible signatures:
     *
     * * {@link connect}
     * * {@link connect} for `IPC` connections.
     * * {@link connect} for TCP connections.
     */
    function connect(options: NetConnectOpts, connectionListener?: () => void): Socket;
    function connect(port: number, host?: string, connectionListener?: () => void): Socket;
    function connect(path: string, connectionListener?: () => void): Socket;
    /**
     * A factory function, which creates a new {@link Socket},
     * immediately initiates connection with `socket.connect()`,
     * then returns the `net.Socket` that starts the connection.
     *
     * When the connection is established, a `'connect'` event will be emitted
     * on the returned socket. The last parameter `connectListener`, if supplied,
     * will be added as a listener for the `'connect'` event **once**.
     *
     * Possible signatures:
     *
     * * {@link createConnection}
     * * {@link createConnection} for `IPC` connections.
     * * {@link createConnection} for TCP connections.
     *
     * The {@link connect} function is an alias to this function.
     */
    function createConnection(options: NetConnectOpts, connectionListener?: () => void): Socket;
    function createConnection(port: number, host?: string, connectionListener?: () => void): Socket;
    function createConnection(path: string, connectionListener?: () => void): Socket;
    /**
     * Gets the current default value of the `autoSelectFamily` option of `socket.connect(options)`.
     * The initial default value is `true`, unless the command line option`--no-network-family-autoselection` is provided.
     * @since v19.4.0
     */
    function getDefaultAutoSelectFamily(): boolean;
    /**
     * Sets the default value of the `autoSelectFamily` option of `socket.connect(options)`.
     * @since v19.4.0
     */
    function setDefaultAutoSelectFamily(value: boolean): void;
    /**
     * Gets the current default value of the `autoSelectFamilyAttemptTimeout` option of `socket.connect(options)`.
     * The initial default value is `250` or the value specified via the command line option `--network-family-autoselection-attempt-timeout`.
     * @returns The current default value of the `autoSelectFamilyAttemptTimeout` option.
     * @since v19.8.0, v18.8.0
     */
    function getDefaultAutoSelectFamilyAttemptTimeout(): number;
    /**
     * Sets the default value of the `autoSelectFamilyAttemptTimeout` option of `socket.connect(options)`.
     * @param value The new default value, which must be a positive number. If the number is less than `10`, the value `10` is used instead. The initial default value is `250` or the value specified via the command line
     * option `--network-family-autoselection-attempt-timeout`.
     * @since v19.8.0, v18.8.0
     */
    function setDefaultAutoSelectFamilyAttemptTimeout(value: number): void;
    /**
     * Returns `6` if `input` is an IPv6 address. Returns `4` if `input` is an IPv4
     * address in [dot-decimal notation](https://en.wikipedia.org/wiki/Dot-decimal_notation) with no leading zeroes. Otherwise, returns`0`.
     *
     * ```js
     * net.isIP('::1'); // returns 6
     * net.isIP('127.0.0.1'); // returns 4
     * net.isIP('127.000.000.001'); // returns 0
     * net.isIP('127.0.0.1/24'); // returns 0
     * net.isIP('fhqwhgads'); // returns 0
     * ```
     * @since v0.3.0
     */
    function isIP(input: string): number;
    /**
     * Returns `true` if `input` is an IPv4 address in [dot-decimal notation](https://en.wikipedia.org/wiki/Dot-decimal_notation) with no
     * leading zeroes. Otherwise, returns `false`.
     *
     * ```js
     * net.isIPv4('127.0.0.1'); // returns true
     * net.isIPv4('127.000.000.001'); // returns false
     * net.isIPv4('127.0.0.1/24'); // returns false
     * net.isIPv4('fhqwhgads'); // returns false
     * ```
     * @since v0.3.0
     */
    function isIPv4(input: string): boolean;
    /**
     * Returns `true` if `input` is an IPv6 address. Otherwise, returns `false`.
     *
     * ```js
     * net.isIPv6('::1'); // returns true
     * net.isIPv6('fhqwhgads'); // returns false
     * ```
     * @since v0.3.0
     */
    function isIPv6(input: string): boolean;
    interface SocketAddressInitOptions {
        /**
         * The network address as either an IPv4 or IPv6 string.
         * @default 127.0.0.1
         */
        address?: string | undefined;
        /**
         * @default `'ipv4'`
         */
        family?: IPVersion | undefined;
        /**
         * An IPv6 flow-label used only if `family` is `'ipv6'`.
         * @default 0
         */
        flowlabel?: number | undefined;
        /**
         * An IP port.
         * @default 0
         */
        port?: number | undefined;
    }
    /**
     * @since v15.14.0, v14.18.0
     */
    class SocketAddress {
        constructor(options: SocketAddressInitOptions);
        /**
         * Either \`'ipv4'\` or \`'ipv6'\`.
         * @since v15.14.0, v14.18.0
         */
        readonly address: string;
        /**
         * Either \`'ipv4'\` or \`'ipv6'\`.
         * @since v15.14.0, v14.18.0
         */
        readonly family: IPVersion;
        /**
         * @since v15.14.0, v14.18.0
         */
        readonly port: number;
        /**
         * @since v15.14.0, v14.18.0
         */
        readonly flowlabel: number;
    }
}
declare module "node:net" {
    export * from "net";
}
/**
 * The `node:os` module provides operating system-related utility methods and
 * properties. It can be accessed using:
 *
 * ```js
 * const os = require('node:os');
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/os.js)
 */
declare module "os" {
    interface CpuInfo {
        model: string;
        speed: number;
        times: {
            /** The number of milliseconds the CPU has spent in user mode. */
            user: number;
            /** The number of milliseconds the CPU has spent in nice mode. */
            nice: number;
            /** The number of milliseconds the CPU has spent in sys mode. */
            sys: number;
            /** The number of milliseconds the CPU has spent in idle mode. */
            idle: number;
            /** The number of milliseconds the CPU has spent in irq mode. */
            irq: number;
        };
    }
    interface NetworkInterfaceBase {
        address: string;
        netmask: string;
        mac: string;
        internal: boolean;
        cidr: string | null;
    }
    interface NetworkInterfaceInfoIPv4 extends NetworkInterfaceBase {
        family: "IPv4";
        scopeid?: undefined;
    }
    interface NetworkInterfaceInfoIPv6 extends NetworkInterfaceBase {
        family: "IPv6";
        scopeid: number;
    }
    interface UserInfo<T> {
        username: T;
        uid: number;
        gid: number;
        shell: T | null;
        homedir: T;
    }
    type NetworkInterfaceInfo = NetworkInterfaceInfoIPv4 | NetworkInterfaceInfoIPv6;
    /**
     * Returns the host name of the operating system as a string.
     * @since v0.3.3
     */
    function hostname(): string;
    /**
     * Returns an array containing the 1, 5, and 15 minute load averages.
     *
     * The load average is a measure of system activity calculated by the operating
     * system and expressed as a fractional number.
     *
     * The load average is a Unix-specific concept. On Windows, the return value is
     * always `[0, 0, 0]`.
     * @since v0.3.3
     */
    function loadavg(): number[];
    /**
     * Returns the system uptime in number of seconds.
     * @since v0.3.3
     */
    function uptime(): number;
    /**
     * Returns the amount of free system memory in bytes as an integer.
     * @since v0.3.3
     */
    function freemem(): number;
    /**
     * Returns the total amount of system memory in bytes as an integer.
     * @since v0.3.3
     */
    function totalmem(): number;
    /**
     * Returns an array of objects containing information about each logical CPU core.
     * The array will be empty if no CPU information is available, such as if the `/proc` file system is unavailable.
     *
     * The properties included on each object include:
     *
     * ```js
     * [
     *   {
     *     model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
     *     speed: 2926,
     *     times: {
     *       user: 252020,
     *       nice: 0,
     *       sys: 30340,
     *       idle: 1070356870,
     *       irq: 0,
     *     },
     *   },
     *   {
     *     model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
     *     speed: 2926,
     *     times: {
     *       user: 306960,
     *       nice: 0,
     *       sys: 26980,
     *       idle: 1071569080,
     *       irq: 0,
     *     },
     *   },
     *   {
     *     model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
     *     speed: 2926,
     *     times: {
     *       user: 248450,
     *       nice: 0,
     *       sys: 21750,
     *       idle: 1070919370,
     *       irq: 0,
     *     },
     *   },
     *   {
     *     model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
     *     speed: 2926,
     *     times: {
     *       user: 256880,
     *       nice: 0,
     *       sys: 19430,
     *       idle: 1070905480,
     *       irq: 20,
     *     },
     *   },
     * ]
     * ```
     *
     * `nice` values are POSIX-only. On Windows, the `nice` values of all processors
     * are always 0.
     *
     * `os.cpus().length` should not be used to calculate the amount of parallelism
     * available to an application. Use {@link availableParallelism} for this purpose.
     * @since v0.3.3
     */
    function cpus(): CpuInfo[];
    /**
     * Returns an estimate of the default amount of parallelism a program should use.
     * Always returns a value greater than zero.
     *
     * This function is a small wrapper about libuv's [`uv_available_parallelism()`](https://docs.libuv.org/en/v1.x/misc.html#c.uv_available_parallelism).
     * @since v19.4.0, v18.14.0
     */
    function availableParallelism(): number;
    /**
     * Returns the operating system name as returned by [`uname(3)`](https://linux.die.net/man/3/uname). For example, it
     * returns `'Linux'` on Linux, `'Darwin'` on macOS, and `'Windows_NT'` on Windows.
     *
     * See [https://en.wikipedia.org/wiki/Uname#Examples](https://en.wikipedia.org/wiki/Uname#Examples) for additional information
     * about the output of running [`uname(3)`](https://linux.die.net/man/3/uname) on various operating systems.
     * @since v0.3.3
     */
    function type(): string;
    /**
     * Returns the operating system as a string.
     *
     * On POSIX systems, the operating system release is determined by calling [`uname(3)`](https://linux.die.net/man/3/uname). On Windows, `GetVersionExW()` is used. See
     * [https://en.wikipedia.org/wiki/Uname#Examples](https://en.wikipedia.org/wiki/Uname#Examples) for more information.
     * @since v0.3.3
     */
    function release(): string;
    /**
     * Returns an object containing network interfaces that have been assigned a
     * network address.
     *
     * Each key on the returned object identifies a network interface. The associated
     * value is an array of objects that each describe an assigned network address.
     *
     * The properties available on the assigned network address object include:
     *
     * ```js
     * {
     *   lo: [
     *     {
     *       address: '127.0.0.1',
     *       netmask: '255.0.0.0',
     *       family: 'IPv4',
     *       mac: '00:00:00:00:00:00',
     *       internal: true,
     *       cidr: '127.0.0.1/8'
     *     },
     *     {
     *       address: '::1',
     *       netmask: 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff',
     *       family: 'IPv6',
     *       mac: '00:00:00:00:00:00',
     *       scopeid: 0,
     *       internal: true,
     *       cidr: '::1/128'
     *     }
     *   ],
     *   eth0: [
     *     {
     *       address: '192.168.1.108',
     *       netmask: '255.255.255.0',
     *       family: 'IPv4',
     *       mac: '01:02:03:0a:0b:0c',
     *       internal: false,
     *       cidr: '192.168.1.108/24'
     *     },
     *     {
     *       address: 'fe80::a00:27ff:fe4e:66a1',
     *       netmask: 'ffff:ffff:ffff:ffff::',
     *       family: 'IPv6',
     *       mac: '01:02:03:0a:0b:0c',
     *       scopeid: 1,
     *       internal: false,
     *       cidr: 'fe80::a00:27ff:fe4e:66a1/64'
     *     }
     *   ]
     * }
     * ```
     * @since v0.6.0
     */
    function networkInterfaces(): NodeJS.Dict<NetworkInterfaceInfo[]>;
    /**
     * Returns the string path of the current user's home directory.
     *
     * On POSIX, it uses the `$HOME` environment variable if defined. Otherwise it
     * uses the [effective UID](https://en.wikipedia.org/wiki/User_identifier#Effective_user_ID) to look up the user's home directory.
     *
     * On Windows, it uses the `USERPROFILE` environment variable if defined.
     * Otherwise it uses the path to the profile directory of the current user.
     * @since v2.3.0
     */
    function homedir(): string;
    /**
     * Returns information about the currently effective user. On POSIX platforms,
     * this is typically a subset of the password file. The returned object includes
     * the `username`, `uid`, `gid`, `shell`, and `homedir`. On Windows, the `uid` and `gid` fields are `-1`, and `shell` is `null`.
     *
     * The value of `homedir` returned by `os.userInfo()` is provided by the operating
     * system. This differs from the result of `os.homedir()`, which queries
     * environment variables for the home directory before falling back to the
     * operating system response.
     *
     * Throws a [`SystemError`](https://nodejs.org/docs/latest-v22.x/api/errors.html#class-systemerror) if a user has no `username` or `homedir`.
     * @since v6.0.0
     */
    function userInfo(options: { encoding: "buffer" }): UserInfo<Buffer>;
    function userInfo(options?: { encoding: BufferEncoding }): UserInfo<string>;
    type SignalConstants = {
        [key in NodeJS.Signals]: number;
    };
    namespace constants {
        const UV_UDP_REUSEADDR: number;
        namespace signals {}
        const signals: SignalConstants;
        namespace errno {
            const E2BIG: number;
            const EACCES: number;
            const EADDRINUSE: number;
            const EADDRNOTAVAIL: number;
            const EAFNOSUPPORT: number;
            const EAGAIN: number;
            const EALREADY: number;
            const EBADF: number;
            const EBADMSG: number;
            const EBUSY: number;
            const ECANCELED: number;
            const ECHILD: number;
            const ECONNABORTED: number;
            const ECONNREFUSED: number;
            const ECONNRESET: number;
            const EDEADLK: number;
            const EDESTADDRREQ: number;
            const EDOM: number;
            const EDQUOT: number;
            const EEXIST: number;
            const EFAULT: number;
            const EFBIG: number;
            const EHOSTUNREACH: number;
            const EIDRM: number;
            const EILSEQ: number;
            const EINPROGRESS: number;
            const EINTR: number;
            const EINVAL: number;
            const EIO: number;
            const EISCONN: number;
            const EISDIR: number;
            const ELOOP: number;
            const EMFILE: number;
            const EMLINK: number;
            const EMSGSIZE: number;
            const EMULTIHOP: number;
            const ENAMETOOLONG: number;
            const ENETDOWN: number;
            const ENETRESET: number;
            const ENETUNREACH: number;
            const ENFILE: number;
            const ENOBUFS: number;
            const ENODATA: number;
            const ENODEV: number;
            const ENOENT: number;
            const ENOEXEC: number;
            const ENOLCK: number;
            const ENOLINK: number;
            const ENOMEM: number;
            const ENOMSG: number;
            const ENOPROTOOPT: number;
            const ENOSPC: number;
            const ENOSR: number;
            const ENOSTR: number;
            const ENOSYS: number;
            const ENOTCONN: number;
            const ENOTDIR: number;
            const ENOTEMPTY: number;
            const ENOTSOCK: number;
            const ENOTSUP: number;
            const ENOTTY: number;
            const ENXIO: number;
            const EOPNOTSUPP: number;
            const EOVERFLOW: number;
            const EPERM: number;
            const EPIPE: number;
            const EPROTO: number;
            const EPROTONOSUPPORT: number;
            const EPROTOTYPE: number;
            const ERANGE: number;
            const EROFS: number;
            const ESPIPE: number;
            const ESRCH: number;
            const ESTALE: number;
            const ETIME: number;
            const ETIMEDOUT: number;
            const ETXTBSY: number;
            const EWOULDBLOCK: number;
            const EXDEV: number;
            const WSAEINTR: number;
            const WSAEBADF: number;
            const WSAEACCES: number;
            const WSAEFAULT: number;
            const WSAEINVAL: number;
            const WSAEMFILE: number;
            const WSAEWOULDBLOCK: number;
            const WSAEINPROGRESS: number;
            const WSAEALREADY: number;
            const WSAENOTSOCK: number;
            const WSAEDESTADDRREQ: number;
            const WSAEMSGSIZE: number;
            const WSAEPROTOTYPE: number;
            const WSAENOPROTOOPT: number;
            const WSAEPROTONOSUPPORT: number;
            const WSAESOCKTNOSUPPORT: number;
            const WSAEOPNOTSUPP: number;
            const WSAEPFNOSUPPORT: number;
            const WSAEAFNOSUPPORT: number;
            const WSAEADDRINUSE: number;
            const WSAEADDRNOTAVAIL: number;
            const WSAENETDOWN: number;
            const WSAENETUNREACH: number;
            const WSAENETRESET: number;
            const WSAECONNABORTED: number;
            const WSAECONNRESET: number;
            const WSAENOBUFS: number;
            const WSAEISCONN: number;
            const WSAENOTCONN: number;
            const WSAESHUTDOWN: number;
            const WSAETOOMANYREFS: number;
            const WSAETIMEDOUT: number;
            const WSAECONNREFUSED: number;
            const WSAELOOP: number;
            const WSAENAMETOOLONG: number;
            const WSAEHOSTDOWN: number;
            const WSAEHOSTUNREACH: number;
            const WSAENOTEMPTY: number;
            const WSAEPROCLIM: number;
            const WSAEUSERS: number;
            const WSAEDQUOT: number;
            const WSAESTALE: number;
            const WSAEREMOTE: number;
            const WSASYSNOTREADY: number;
            const WSAVERNOTSUPPORTED: number;
            const WSANOTINITIALISED: number;
            const WSAEDISCON: number;
            const WSAENOMORE: number;
            const WSAECANCELLED: number;
            const WSAEINVALIDPROCTABLE: number;
            const WSAEINVALIDPROVIDER: number;
            const WSAEPROVIDERFAILEDINIT: number;
            const WSASYSCALLFAILURE: number;
            const WSASERVICE_NOT_FOUND: number;
            const WSATYPE_NOT_FOUND: number;
            const WSA_E_NO_MORE: number;
            const WSA_E_CANCELLED: number;
            const WSAEREFUSED: number;
        }
        namespace dlopen {
            const RTLD_LAZY: number;
            const RTLD_NOW: number;
            const RTLD_GLOBAL: number;
            const RTLD_LOCAL: number;
            const RTLD_DEEPBIND: number;
        }
        namespace priority {
            const PRIORITY_LOW: number;
            const PRIORITY_BELOW_NORMAL: number;
            const PRIORITY_NORMAL: number;
            const PRIORITY_ABOVE_NORMAL: number;
            const PRIORITY_HIGH: number;
            const PRIORITY_HIGHEST: number;
        }
    }
    const devNull: string;
    /**
     * The operating system-specific end-of-line marker.
     * * `\n` on POSIX
     * * `\r\n` on Windows
     */
    const EOL: string;
    /**
     * Returns the operating system CPU architecture for which the Node.js binary was
     * compiled. Possible values are `'arm'`, `'arm64'`, `'ia32'`, `'loong64'`, `'mips'`, `'mipsel'`, `'ppc'`, `'ppc64'`, `'riscv64'`, `'s390'`, `'s390x'`,
     * and `'x64'`.
     *
     * The return value is equivalent to [process.arch](https://nodejs.org/docs/latest-v22.x/api/process.html#processarch).
     * @since v0.5.0
     */
    function arch(): string;
    /**
     * Returns a string identifying the kernel version.
     *
     * On POSIX systems, the operating system release is determined by calling [`uname(3)`](https://linux.die.net/man/3/uname). On Windows, `RtlGetVersion()` is used, and if it is not
     * available, `GetVersionExW()` will be used. See [https://en.wikipedia.org/wiki/Uname#Examples](https://en.wikipedia.org/wiki/Uname#Examples) for more information.
     * @since v13.11.0, v12.17.0
     */
    function version(): string;
    /**
     * Returns a string identifying the operating system platform for which
     * the Node.js binary was compiled. The value is set at compile time.
     * Possible values are `'aix'`, `'darwin'`, `'freebsd'`, `'linux'`, `'openbsd'`, `'sunos'`, and `'win32'`.
     *
     * The return value is equivalent to `process.platform`.
     *
     * The value `'android'` may also be returned if Node.js is built on the Android
     * operating system. [Android support is experimental](https://github.com/nodejs/node/blob/HEAD/BUILDING.md#androidandroid-based-devices-eg-firefox-os).
     * @since v0.5.0
     */
    function platform(): NodeJS.Platform;
    /**
     * Returns the machine type as a string, such as `arm`, `arm64`, `aarch64`, `mips`, `mips64`, `ppc64`, `ppc64le`, `s390`, `s390x`, `i386`, `i686`, `x86_64`.
     *
     * On POSIX systems, the machine type is determined by calling [`uname(3)`](https://linux.die.net/man/3/uname). On Windows, `RtlGetVersion()` is used, and if it is not
     * available, `GetVersionExW()` will be used. See [https://en.wikipedia.org/wiki/Uname#Examples](https://en.wikipedia.org/wiki/Uname#Examples) for more information.
     * @since v18.9.0, v16.18.0
     */
    function machine(): string;
    /**
     * Returns the operating system's default directory for temporary files as a
     * string.
     * @since v0.9.9
     */
    function tmpdir(): string;
    /**
     * Returns a string identifying the endianness of the CPU for which the Node.js
     * binary was compiled.
     *
     * Possible values are `'BE'` for big endian and `'LE'` for little endian.
     * @since v0.9.4
     */
    function endianness(): "BE" | "LE";
    /**
     * Returns the scheduling priority for the process specified by `pid`. If `pid` is
     * not provided or is `0`, the priority of the current process is returned.
     * @since v10.10.0
     * @param [pid=0] The process ID to retrieve scheduling priority for.
     */
    function getPriority(pid?: number): number;
    /**
     * Attempts to set the scheduling priority for the process specified by `pid`. If `pid` is not provided or is `0`, the process ID of the current process is used.
     *
     * The `priority` input must be an integer between `-20` (high priority) and `19` (low priority). Due to differences between Unix priority levels and Windows
     * priority classes, `priority` is mapped to one of six priority constants in `os.constants.priority`. When retrieving a process priority level, this range
     * mapping may cause the return value to be slightly different on Windows. To avoid
     * confusion, set `priority` to one of the priority constants.
     *
     * On Windows, setting priority to `PRIORITY_HIGHEST` requires elevated user
     * privileges. Otherwise the set priority will be silently reduced to `PRIORITY_HIGH`.
     * @since v10.10.0
     * @param [pid=0] The process ID to set scheduling priority for.
     * @param priority The scheduling priority to assign to the process.
     */
    function setPriority(priority: number): void;
    function setPriority(pid: number, priority: number): void;
}
declare module "node:os" {
    export * from "os";
}
{
    "name": "@types/node",
    "version": "22.5.5",
    "description": "TypeScript definitions for node",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/node",
    "license": "MIT",
    "contributors": [
        {
            "name": "Microsoft TypeScript",
            "githubUsername": "Microsoft",
            "url": "https://github.com/Microsoft"
        },
        {
            "name": "Alberto Schiabel",
            "githubUsername": "jkomyno",
            "url": "https://github.com/jkomyno"
        },
        {
            "name": "Alvis HT Tang",
            "githubUsername": "alvis",
            "url": "https://github.com/alvis"
        },
        {
            "name": "Andrew Makarov",
            "githubUsername": "r3nya",
            "url": "https://github.com/r3nya"
        },
        {
            "name": "Benjamin Toueg",
            "githubUsername": "btoueg",
            "url": "https://github.com/btoueg"
        },
        {
            "name": "Chigozirim C.",
            "githubUsername": "smac89",
            "url": "https://github.com/smac89"
        },
        {
            "name": "David Junger",
            "githubUsername": "touffy",
            "url": "https://github.com/touffy"
        },
        {
            "name": "Deividas Bakanas",
            "githubUsername": "DeividasBakanas",
            "url": "https://github.com/DeividasBakanas"
        },
        {
            "name": "Eugene Y. Q. Shen",
            "githubUsername": "eyqs",
            "url": "https://github.com/eyqs"
        },
        {
            "name": "Hannes Magnusson",
            "githubUsername": "Hannes-Magnusson-CK",
            "url": "https://github.com/Hannes-Magnusson-CK"
        },
        {
            "name": "Huw",
            "githubUsername": "hoo29",
            "url": "https://github.com/hoo29"
        },
        {
            "name": "Kelvin Jin",
            "githubUsername": "kjin",
            "url": "https://github.com/kjin"
        },
        {
            "name": "Klaus Meinhardt",
            "githubUsername": "ajafff",
            "url": "https://github.com/ajafff"
        },
        {
            "name": "Lishude",
            "githubUsername": "islishude",
            "url": "https://github.com/islishude"
        },
        {
            "name": "Mariusz Wiktorczyk",
            "githubUsername": "mwiktorczyk",
            "url": "https://github.com/mwiktorczyk"
        },
        {
            "name": "Mohsen Azimi",
            "githubUsername": "mohsen1",
            "url": "https://github.com/mohsen1"
        },
        {
            "name": "Nikita Galkin",
            "githubUsername": "galkin",
            "url": "https://github.com/galkin"
        },
        {
            "name": "Parambir Singh",
            "githubUsername": "parambirs",
            "url": "https://github.com/parambirs"
        },
        {
            "name": "Sebastian Silbermann",
            "githubUsername": "eps1lon",
            "url": "https://github.com/eps1lon"
        },
        {
            "name": "Thomas den Hollander",
            "githubUsername": "ThomasdenH",
            "url": "https://github.com/ThomasdenH"
        },
        {
            "name": "Wilco Bakker",
            "githubUsername": "WilcoBakker",
            "url": "https://github.com/WilcoBakker"
        },
        {
            "name": "wwwy3y3",
            "githubUsername": "wwwy3y3",
            "url": "https://github.com/wwwy3y3"
        },
        {
            "name": "Samuel Ainsworth",
            "githubUsername": "samuela",
            "url": "https://github.com/samuela"
        },
        {
            "name": "Kyle Uehlein",
            "githubUsername": "kuehlein",
            "url": "https://github.com/kuehlein"
        },
        {
            "name": "Thanik Bhongbhibhat",
            "githubUsername": "bhongy",
            "url": "https://github.com/bhongy"
        },
        {
            "name": "Marcin Kopacz",
            "githubUsername": "chyzwar",
            "url": "https://github.com/chyzwar"
        },
        {
            "name": "Trivikram Kamat",
            "githubUsername": "trivikr",
            "url": "https://github.com/trivikr"
        },
        {
            "name": "Junxiao Shi",
            "githubUsername": "yoursunny",
            "url": "https://github.com/yoursunny"
        },
        {
            "name": "Ilia Baryshnikov",
            "githubUsername": "qwelias",
            "url": "https://github.com/qwelias"
        },
        {
            "name": "ExE Boss",
            "githubUsername": "ExE-Boss",
            "url": "https://github.com/ExE-Boss"
        },
        {
            "name": "Piotr Błażejewicz",
            "githubUsername": "peterblazejewicz",
            "url": "https://github.com/peterblazejewicz"
        },
        {
            "name": "Anna Henningsen",
            "githubUsername": "addaleax",
            "url": "https://github.com/addaleax"
        },
        {
            "name": "Victor Perin",
            "githubUsername": "victorperin",
            "url": "https://github.com/victorperin"
        },
        {
            "name": "Yongsheng Zhang",
            "githubUsername": "ZYSzys",
            "url": "https://github.com/ZYSzys"
        },
        {
            "name": "NodeJS Contributors",
            "githubUsername": "NodeJS",
            "url": "https://github.com/NodeJS"
        },
        {
            "name": "Linus Unnebäck",
            "githubUsername": "LinusU",
            "url": "https://github.com/LinusU"
        },
        {
            "name": "wafuwafu13",
            "githubUsername": "wafuwafu13",
            "url": "https://github.com/wafuwafu13"
        },
        {
            "name": "Matteo Collina",
            "githubUsername": "mcollina",
            "url": "https://github.com/mcollina"
        },
        {
            "name": "Dmitry Semigradsky",
            "githubUsername": "Semigradsky",
            "url": "https://github.com/Semigradsky"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/node"
    },
    "scripts": {},
    "dependencies": {
        "undici-types": "~6.19.2"
    },
    "typesPublisherContentHash": "49c6854801c6eca5f0c4debaa90673195b7385ea09dc082e76a86be2fa20430f",
    "typeScriptVersion": "4.8"
}declare module "path/posix" {
    import path = require("path");
    export = path;
}
declare module "path/win32" {
    import path = require("path");
    export = path;
}
/**
 * The `node:path` module provides utilities for working with file and directory
 * paths. It can be accessed using:
 *
 * ```js
 * const path = require('node:path');
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/path.js)
 */
declare module "path" {
    namespace path {
        /**
         * A parsed path object generated by path.parse() or consumed by path.format().
         */
        interface ParsedPath {
            /**
             * The root of the path such as '/' or 'c:\'
             */
            root: string;
            /**
             * The full directory path such as '/home/user/dir' or 'c:\path\dir'
             */
            dir: string;
            /**
             * The file name including extension (if any) such as 'index.html'
             */
            base: string;
            /**
             * The file extension (if any) such as '.html'
             */
            ext: string;
            /**
             * The file name without extension (if any) such as 'index'
             */
            name: string;
        }
        interface FormatInputPathObject {
            /**
             * The root of the path such as '/' or 'c:\'
             */
            root?: string | undefined;
            /**
             * The full directory path such as '/home/user/dir' or 'c:\path\dir'
             */
            dir?: string | undefined;
            /**
             * The file name including extension (if any) such as 'index.html'
             */
            base?: string | undefined;
            /**
             * The file extension (if any) such as '.html'
             */
            ext?: string | undefined;
            /**
             * The file name without extension (if any) such as 'index'
             */
            name?: string | undefined;
        }
        interface PlatformPath {
            /**
             * Normalize a string path, reducing '..' and '.' parts.
             * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.
             *
             * @param path string path to normalize.
             * @throws {TypeError} if `path` is not a string.
             */
            normalize(path: string): string;
            /**
             * Join all arguments together and normalize the resulting path.
             *
             * @param paths paths to join.
             * @throws {TypeError} if any of the path segments is not a string.
             */
            join(...paths: string[]): string;
            /**
             * The right-most parameter is considered {to}. Other parameters are considered an array of {from}.
             *
             * Starting from leftmost {from} parameter, resolves {to} to an absolute path.
             *
             * If {to} isn't already absolute, {from} arguments are prepended in right to left order,
             * until an absolute path is found. If after using all {from} paths still no absolute path is found,
             * the current working directory is used as well. The resulting path is normalized,
             * and trailing slashes are removed unless the path gets resolved to the root directory.
             *
             * @param paths A sequence of paths or path segments.
             * @throws {TypeError} if any of the arguments is not a string.
             */
            resolve(...paths: string[]): string;
            /**
             * The `path.matchesGlob()` method determines if `path` matches the `pattern`.
             * @param path The path to glob-match against.
             * @param pattern The glob to check the path against.
             * @returns Whether or not the `path` matched the `pattern`.
             * @throws {TypeError} if `path` or `pattern` are not strings.
             * @since v22.5.0
             */
            matchesGlob(path: string, pattern: string): boolean;
            /**
             * Determines whether {path} is an absolute path. An absolute path will always resolve to the same location, regardless of the working directory.
             *
             * If the given {path} is a zero-length string, `false` will be returned.
             *
             * @param path path to test.
             * @throws {TypeError} if `path` is not a string.
             */
            isAbsolute(path: string): boolean;
            /**
             * Solve the relative path from {from} to {to} based on the current working directory.
             * At times we have two absolute paths, and we need to derive the relative path from one to the other. This is actually the reverse transform of path.resolve.
             *
             * @throws {TypeError} if either `from` or `to` is not a string.
             */
            relative(from: string,